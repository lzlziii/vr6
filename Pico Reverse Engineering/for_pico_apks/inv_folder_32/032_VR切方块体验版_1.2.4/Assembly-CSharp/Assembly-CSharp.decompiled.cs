using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using AOT;
using AudioVisualizer;
using BoundarySystem_Ext;
using DSPLib;
using LitJson;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using RayFire;
using RayFire.DotNet;
using ShatterToolkit;
using ShatterToolkit.Helpers;
using TMPro;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Android;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.XR;
using UnityStandardAssets.Effects;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class SciFiBeamScript : MonoBehaviour
{
	[Header("Prefabs")]
	public GameObject[] beamLineRendererPrefab;

	public GameObject[] beamStartPrefab;

	public GameObject[] beamEndPrefab;

	private int currentBeam;

	private GameObject beamStart;

	private GameObject beamEnd;

	private GameObject beam;

	private LineRenderer line;

	[Header("Adjustable Variables")]
	public float beamEndOffset = 1f;

	public float textureScrollSpeed = 8f;

	public float textureLengthScale = 3f;

	[Header("Put Sliders here (Optional)")]
	public Slider endOffSetSlider;

	public Slider scrollSpeedSlider;

	[Header("Put UI Text object here to show beam name")]
	public Text textBeamName;

	private void Start()
	{
		if ((bool)textBeamName)
		{
			textBeamName.text = beamLineRendererPrefab[currentBeam].name;
		}
		if ((bool)endOffSetSlider)
		{
			endOffSetSlider.value = beamEndOffset;
		}
		if ((bool)scrollSpeedSlider)
		{
			scrollSpeedSlider.value = textureScrollSpeed;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
		if (Input.GetMouseButtonDown(0))
		{
			beamStart = UnityEngine.Object.Instantiate(beamStartPrefab[currentBeam], new UnityEngine.Vector3(0f, 0f, 0f), UnityEngine.Quaternion.identity);
			beamEnd = UnityEngine.Object.Instantiate(beamEndPrefab[currentBeam], new UnityEngine.Vector3(0f, 0f, 0f), UnityEngine.Quaternion.identity);
			beam = UnityEngine.Object.Instantiate(beamLineRendererPrefab[currentBeam], new UnityEngine.Vector3(0f, 0f, 0f), UnityEngine.Quaternion.identity);
			line = beam.GetComponent<LineRenderer>();
		}
		if (Input.GetMouseButtonUp(0))
		{
			UnityEngine.Object.Destroy(beamStart);
			UnityEngine.Object.Destroy(beamEnd);
			UnityEngine.Object.Destroy(beam);
		}
		if (Input.GetMouseButton(0))
		{
			Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray.origin, ray.direction, out var hitInfo))
			{
				UnityEngine.Vector3 dir = hitInfo.point - base.transform.position;
				ShootBeamInDir(base.transform.position, dir);
			}
		}
		if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextBeam();
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			nextBeam();
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			previousBeam();
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			previousBeam();
		}
	}

	public void nextBeam()
	{
		if (currentBeam < beamLineRendererPrefab.Length - 1)
		{
			currentBeam++;
		}
		else
		{
			currentBeam = 0;
		}
		if ((bool)textBeamName)
		{
			textBeamName.text = beamLineRendererPrefab[currentBeam].name;
		}
	}

	public void previousBeam()
	{
		if (currentBeam > 0)
		{
			currentBeam--;
		}
		else
		{
			currentBeam = beamLineRendererPrefab.Length - 1;
		}
		if ((bool)textBeamName)
		{
			textBeamName.text = beamLineRendererPrefab[currentBeam].name;
		}
	}

	public void UpdateEndOffset()
	{
		beamEndOffset = endOffSetSlider.value;
	}

	public void UpdateScrollSpeed()
	{
		textureScrollSpeed = scrollSpeedSlider.value;
	}

	private void ShootBeamInDir(UnityEngine.Vector3 start, UnityEngine.Vector3 dir)
	{
		line.SetVertexCount(2);
		line.SetPosition(0, start);
		beamStart.transform.position = start;
		UnityEngine.Vector3 zero = UnityEngine.Vector3.zero;
		zero = ((!Physics.Raycast(start, dir, out var hitInfo)) ? (base.transform.position + dir * 100f) : (hitInfo.point - dir.normalized * beamEndOffset));
		beamEnd.transform.position = zero;
		line.SetPosition(1, zero);
		beamStart.transform.LookAt(beamEnd.transform.position);
		beamEnd.transform.LookAt(beamStart.transform.position);
		float num = UnityEngine.Vector3.Distance(start, zero);
		line.sharedMaterial.mainTextureScale = new UnityEngine.Vector2(num / textureLengthScale, 1f);
		line.sharedMaterial.mainTextureOffset -= new UnityEngine.Vector2(Time.deltaTime * textureScrollSpeed, 0f);
	}
}
public class SciFiLightFlicker : MonoBehaviour
{
	public string waveFunction = "sin";

	public float startValue;

	public float amplitude = 1f;

	public float phase;

	public float frequency = 0.5f;

	private Color originalColor;

	private void Start()
	{
		originalColor = GetComponent<Light>().color;
	}

	private void Update()
	{
		GetComponent<Light>().color = originalColor * EvalWave();
	}

	private float EvalWave()
	{
		float num = (Time.time + phase) * frequency;
		num -= Mathf.Floor(num);
		float num2 = ((waveFunction == "sin") ? Mathf.Sin(num * 2f * (float)Math.PI) : ((waveFunction == "tri") ? ((!(num < 0.5f)) ? (-4f * num + 3f) : (4f * num - 1f)) : ((waveFunction == "sqr") ? ((!(num < 0.5f)) ? (-1f) : 1f) : ((waveFunction == "saw") ? num : ((waveFunction == "inv") ? (1f - num) : ((!(waveFunction == "noise")) ? 1f : (1f - UnityEngine.Random.value * 2f)))))));
		return num2 * amplitude + startValue;
	}
}
public class BeatDetection : MonoBehaviour
{
	public enum beatmode
	{
		Energy,
		Frequency,
		Both
	}

	public enum beatType
	{
		None = 0,
		kick = 1,
		snare = 2,
		hithat = 4,
		energy = 8
	}

	public enum EventType
	{
		Energy,
		Kick,
		Snare,
		HitHat
	}

	public class EventInfo
	{
		public EventType messageInfo;

		public BeatDetection sender;
	}

	public delegate void CallbackEventHandler(EventInfo eventInfo);

	public beatmode beatMode;

	public CallbackEventHandler CallBackFunction;

	private int numSamples = 1024;

	private int minFrequency = 60;

	private const int MAX_FRQSEC = 50;

	private const int LINEAR_OCTAVE_DIVISIONS = 3;

	private const int HISTORY_LENGTH = 43;

	private const int MAX_HISTORY = 500;

	private const float MIN_BEAT_SEPARATION = 0.05f;

	private int numHistory;

	private int circularHistory;

	private float[] energyHistory = new float[500];

	private float[] mediasHistory = new float[500];

	private float[,] freqHistory = new float[50, 500];

	private float[,] medHistory = new float[50, 500];

	private float[] averages = new float[50];

	private bool[] detectados = new bool[50];

	private int acumula;

	private float[] estad1 = new float[50];

	private float[] estad2 = new float[50];

	private float sampleRate;

	private int avgPerOctave;

	private int octaves;

	private int totalBfLen;

	private int historyLength;

	private int sampleRange;

	private float tIni;

	private float[] tIniF = new float[50];

	private int kg;

	private float[] spectrum0;

	private float[] spectrum1;

	private float[] frames0;

	private float[] frames1;

	private void Update()
	{
		int num = isBeat();
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			SendEvent(EventType.Kick);
		}
		if (((uint)num & 2u) != 0)
		{
			SendEvent(EventType.Snare);
		}
		if (((uint)num & 4u) != 0)
		{
			SendEvent(EventType.HitHat);
		}
		if (((uint)num & 8u) != 0)
		{
			SendEvent(EventType.Energy);
		}
	}

	private void SendEvent(EventType theEvent)
	{
		if (CallBackFunction != null)
		{
			EventInfo eventInfo = new EventInfo();
			eventInfo.sender = this;
			eventInfo.messageInfo = theEvent;
			CallBackFunction(eventInfo);
		}
	}

	private void Start()
	{
		spectrum0 = new float[numSamples];
		spectrum1 = new float[numSamples];
		frames0 = new float[numSamples];
		frames1 = new float[numSamples];
		setUpEnergy();
		setUpFrequency();
		tIni = Time.time;
		for (int i = 0; i < 50; i++)
		{
			tIniF[i] = Time.time;
		}
	}

	private int isBeat()
	{
		GetComponent<AudioSource>().GetSpectrumData(spectrum0, 0, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetSpectrumData(spectrum1, 1, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetOutputData(frames0, 0);
		GetComponent<AudioSource>().GetOutputData(frames1, 1);
		beatType beatType = beatType.None;
		switch (beatMode)
		{
		case beatmode.Energy:
			if (isBeatEnergy())
			{
				return 8;
			}
			break;
		case beatmode.Frequency:
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat());
		case beatmode.Both:
			if (isBeatEnergy())
			{
				beatType = beatType.energy;
			}
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat() | beatType);
		}
		return 0;
	}

	private void initDetector()
	{
		numHistory = 0;
		circularHistory = 0;
		for (int i = 0; i < 500; i++)
		{
			energyHistory[i] = 0f;
			mediasHistory[i] = 0f;
		}
		acumula = 0;
		historyLength = 0;
	}

	private void setUpEnergy()
	{
		sampleRate = AudioSettings.outputSampleRate;
		sampleRange = numSamples;
		historyLength = 43;
		numHistory = 0;
		circularHistory = 0;
	}

	private void setUpFrequency()
	{
		sampleRange = numSamples;
		historyLength = 43;
		sampleRate = AudioSettings.outputSampleRate;
		numHistory = 0;
		circularHistory = 0;
		float num = sampleRate / 2f;
		octaves = 1;
		while ((num /= 2f) > (float)minFrequency)
		{
			octaves++;
		}
		avgPerOctave = 3;
		totalBfLen = octaves * avgPerOctave;
		for (int i = 0; i < totalBfLen; i++)
		{
			for (int j = 0; j < historyLength; j++)
			{
				freqHistory[i, j] = 0f;
				medHistory[i, j] = 0f;
			}
		}
	}

	private bool isBeatEnergy()
	{
		float num = 0f;
		for (int i = 0; i < sampleRange; i++)
		{
			num += frames0[i] * frames0[i] + frames1[i] * frames1[i];
		}
		num /= (float)sampleRange;
		float num2 = Mathf.Sqrt(num) * 100f;
		float num3 = 0f;
		for (int j = 0; j < numHistory; j++)
		{
			num3 += energyHistory[j];
		}
		if (numHistory > 0)
		{
			num3 /= (float)numHistory;
		}
		float num4 = 0f;
		for (int k = 0; k < numHistory; k++)
		{
			num4 += (energyHistory[k] - num3) * (energyHistory[k] - num3);
		}
		if (numHistory > 0)
		{
			num4 /= (float)numHistory;
		}
		float num5 = -0.0025714f * num4 + 1.5142857f;
		float num6 = Mathf.Max(num2 - num5 * num3, 0f);
		float num7 = 0f;
		int num8 = 0;
		for (int l = 0; l < numHistory; l++)
		{
			if (mediasHistory[l] > 0f)
			{
				num7 += mediasHistory[l];
				num8++;
			}
		}
		if (num8 > 0)
		{
			num7 /= (float)num8;
		}
		float num9 = Mathf.Max(num6 - num7, 0f);
		bool result;
		if (Time.time - tIni < 0.05f)
		{
			result = false;
		}
		else if ((double)num9 > 0.0 && (double)num2 > 2.0)
		{
			result = true;
			tIni = Time.time;
		}
		else
		{
			result = false;
		}
		numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
		energyHistory[circularHistory] = num2;
		mediasHistory[circularHistory] = num6;
		circularHistory++;
		circularHistory %= historyLength;
		return result;
	}

	private int freqToIndex(float freq)
	{
		float num = sampleRate / (float)sampleRange;
		if (freq < num / 2f)
		{
			return 0;
		}
		if (freq > sampleRate / 2f - num / 2f)
		{
			return sampleRange / 2 - 1;
		}
		float num2 = freq / sampleRate;
		return (int)((float)sampleRange * num2);
	}

	private float calcAvg(float lowFreq, float hiFreq, float[] spectrum)
	{
		int num = freqToIndex(lowFreq);
		int num2 = freqToIndex(hiFreq);
		float num3 = 0f;
		for (int i = num; i <= num2; i++)
		{
			num3 += spectrum[i];
		}
		return num3 / (float)(num2 - num + 1);
	}

	private void isBeatFrequency()
	{
		for (int i = 0; i < octaves; i++)
		{
			float num = ((i != 0) ? (sampleRate / 2f / Mathf.Pow(2f, octaves - i)) : 0f);
			float num2 = (sampleRate / 2f / Mathf.Pow(2f, octaves - i - 1) - num) / (float)avgPerOctave;
			float num3 = num;
			for (int j = 0; j < avgPerOctave; j++)
			{
				int num4 = j + i * avgPerOctave;
				float num5 = calcAvg(num3, num3 + num2, spectrum0);
				float num6 = calcAvg(num3, num3 + num2, spectrum1);
				averages[num4] = num6;
				if (num5 > num6)
				{
					averages[num4] = num5;
				}
				num3 += num2;
			}
		}
		acumula++;
		for (int k = 0; k < totalBfLen; k++)
		{
			if (kg == 2)
			{
				estad1[k] = averages[k];
				estad2[k] = averages[k];
				continue;
			}
			estad1[k] += averages[k];
			if (averages[k] > estad2[k])
			{
				estad2[k] = averages[k];
			}
		}
		for (int l = 1; l < totalBfLen; l++)
		{
			float num7 = 0f;
			float num8 = 0f;
			float num9 = 0f;
			float num10 = averages[l];
			num7 = 0f;
			for (int m = 0; m < numHistory; m++)
			{
				num7 += freqHistory[l, m];
			}
			if (numHistory > 0)
			{
				num7 /= (float)numHistory;
			}
			num8 = 0f;
			for (int n = 0; n < numHistory; n++)
			{
				num8 += (freqHistory[l, n] - num7) * (freqHistory[l, n] - num7);
			}
			if (numHistory > 0)
			{
				num8 /= (float)numHistory;
			}
			num9 = -0.0025714f * num8 + 1.5142857f;
			float num11 = Mathf.Max(num10 - num9 * num7, 0f);
			float num12 = 0f;
			int num13 = 0;
			for (int num14 = 0; num14 < numHistory; num14++)
			{
				if (medHistory[l, num14] > 0f)
				{
					num12 += medHistory[l, num14];
					num13++;
				}
			}
			if (num13 > 0)
			{
				num12 /= (float)num13;
			}
			Mathf.Max(num11 - num12, 0f);
			float num15;
			float num16;
			if (l < 7)
			{
				num15 = 0.003f;
				num16 = 2f;
			}
			else if (l > 6 && l < 20)
			{
				num15 = 0.001f;
				num16 = 3f;
			}
			else
			{
				num15 = 0.001f;
				num16 = 4f;
			}
			if (Time.time - tIniF[l] < 0.05f)
			{
				detectados[l] = false;
			}
			else if (num10 > num16 * num7 && num10 > num15)
			{
				detectados[l] = true;
				tIniF[l] = Time.time;
			}
			else
			{
				detectados[l] = false;
			}
			numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
			freqHistory[l, circularHistory] = num10;
			medHistory[l, circularHistory] = num11;
			circularHistory++;
			circularHistory %= historyLength;
		}
	}

	private beatType isKick()
	{
		int high = ((6 >= totalBfLen) ? totalBfLen : 6);
		if (isRange(1, high, 2))
		{
			return beatType.kick;
		}
		return beatType.None;
	}

	private beatType isSnare()
	{
		int num = ((8 >= totalBfLen) ? totalBfLen : 8);
		int num2 = totalBfLen - 5;
		int threshold = (num2 - num) / 3;
		if (isRange(num, num2, threshold))
		{
			return beatType.snare;
		}
		return beatType.None;
	}

	private beatType isHat()
	{
		int low = ((totalBfLen - 6 >= 0) ? (totalBfLen - 6) : 0);
		int high = totalBfLen - 1;
		if (isRange(low, high, 1))
		{
			return beatType.hithat;
		}
		return beatType.None;
	}

	private bool isRange(int low, int high, int threshold)
	{
		int num = 0;
		for (int i = low; i < high + 1; i++)
		{
			if (detectados[i])
			{
				num++;
			}
		}
		if (num >= threshold)
		{
			return true;
		}
		return false;
	}
}
public class EventMicExample : MonoBehaviour
{
	public GameObject AudioBeat;

	public Text energy;

	public Text kick;

	public Text snare;

	public Text hithat;

	public GameObject genergy;

	public GameObject gkick;

	public GameObject gsnare;

	public GameObject ghithat;

	public Material matOn;

	public Material matOff;

	private bool micSelected;

	private bool started;

	private int minFreq;

	private int maxFreq;

	public string selectedDevice { get; private set; }

	public void MyCallbackEventHandler(BeatDetection.EventInfo eventInfo)
	{
		switch (eventInfo.messageInfo)
		{
		case BeatDetection.EventType.Energy:
			StartCoroutine(showText(energy, genergy));
			break;
		case BeatDetection.EventType.HitHat:
			StartCoroutine(showText(hithat, ghithat));
			break;
		case BeatDetection.EventType.Kick:
			StartCoroutine(showText(kick, gkick));
			break;
		case BeatDetection.EventType.Snare:
			StartCoroutine(showText(snare, gsnare));
			break;
		}
	}

	private IEnumerator showText(Text texto, GameObject objeto)
	{
		texto.enabled = true;
		objeto.GetComponent<Renderer>().material = matOn;
		yield return new WaitForSeconds(0.15f);
		texto.enabled = false;
		objeto.GetComponent<Renderer>().material = matOff;
	}

	private void Start()
	{
		AudioBeat.GetComponent<BeatDetection>().CallBackFunction = MyCallbackEventHandler;
		started = false;
		selectedDevice = Microphone.devices[0].ToString();
		micSelected = true;
		GetMicCaps();
		setUptMic();
		StartCapture();
	}

	public void StartCapture()
	{
		if (!started)
		{
			StartMicrophone();
			started = true;
		}
	}

	public void StopCapture()
	{
		StopMicrophone();
		started = false;
	}

	private void setUptMic()
	{
		AudioBeat.GetComponent<AudioSource>().clip = null;
		AudioBeat.GetComponent<AudioSource>().loop = true;
		AudioBeat.GetComponent<AudioSource>().mute = false;
	}

	public void GetMicCaps()
	{
		Microphone.GetDeviceCaps(selectedDevice, out minFreq, out maxFreq);
		if (minFreq + maxFreq == 0)
		{
			maxFreq = 44100;
		}
	}

	public void StartMicrophone()
	{
		AudioBeat.GetComponent<AudioSource>().clip = Microphone.Start(selectedDevice, loop: true, 10, maxFreq);
		while (Microphone.GetPosition(selectedDevice) <= 0)
		{
		}
		AudioBeat.GetComponent<AudioSource>().Play();
	}

	public void StopMicrophone()
	{
		AudioBeat.GetComponent<AudioSource>().Stop();
		Microphone.End(selectedDevice);
	}
}
public class EventExample : MonoBehaviour
{
	public GameObject AudioBeat;

	public Text energy;

	public Text kick;

	public Text snare;

	public Text hithat;

	public GameObject genergy;

	public GameObject gkick;

	public GameObject gsnare;

	public GameObject ghithat;

	public Material matOn;

	public Material matOff;

	public void MyCallbackEventHandler(BeatDetection.EventInfo eventInfo)
	{
		switch (eventInfo.messageInfo)
		{
		case BeatDetection.EventType.Energy:
			StartCoroutine(showText(energy, genergy));
			break;
		case BeatDetection.EventType.HitHat:
			StartCoroutine(showText(hithat, ghithat));
			break;
		case BeatDetection.EventType.Kick:
			StartCoroutine(showText(kick, gkick));
			break;
		case BeatDetection.EventType.Snare:
			StartCoroutine(showText(snare, gsnare));
			break;
		}
	}

	private IEnumerator showText(Text texto, GameObject objeto)
	{
		texto.enabled = true;
		objeto.GetComponent<Renderer>().material = matOn;
		yield return new WaitForSeconds(0.15f);
		texto.enabled = false;
		objeto.GetComponent<Renderer>().material = matOff;
	}

	private void Start()
	{
		AudioBeat.GetComponent<BeatDetection>().CallBackFunction = MyCallbackEventHandler;
	}
}
public class BeatDetectionExampleMic : MonoBehaviour
{
	public enum beatmode
	{
		Energy,
		Frequency,
		Both
	}

	public enum beatType
	{
		None = 0,
		kick = 1,
		snare = 2,
		hithat = 4,
		energy = 8
	}

	private bool micSelected;

	private bool started;

	private int minFreq;

	private int maxFreq;

	public Text energy;

	public Text kick;

	public Text snare;

	public Text hithat;

	public GameObject genergy;

	public GameObject gkick;

	public GameObject gsnare;

	public GameObject ghithat;

	public Material matOn;

	public Material matOff;

	public beatmode beatMode;

	private int numSamples = 1024;

	private int minFrequency = 60;

	private const int MAX_FRQSEC = 50;

	private const int LINEAR_OCTAVE_DIVISIONS = 3;

	private const int HISTORY_LENGTH = 43;

	private const int MAX_HISTORY = 500;

	private const float MIN_BEAT_SEPARATION = 0.05f;

	private int numHistory;

	private int circularHistory;

	private float[] energyHistory = new float[500];

	private float[] mediasHistory = new float[500];

	private float[,] freqHistory = new float[50, 500];

	private float[,] medHistory = new float[50, 500];

	private float[] averages = new float[50];

	private bool[] detectados = new bool[50];

	private int acumula;

	private float[] estad1 = new float[50];

	private float[] estad2 = new float[50];

	private float sampleRate;

	private int avgPerOctave;

	private int octaves;

	private int totalBfLen;

	private int historyLength;

	private int sampleRange;

	private float tIni;

	private float[] tIniF = new float[50];

	private int kg;

	private float[] spectrum0;

	private float[] spectrum1;

	private float[] frames0;

	private float[] frames1;

	public string selectedDevice { get; private set; }

	public void StartCapture()
	{
		if (!started)
		{
			StartMicrophone();
			started = true;
		}
	}

	public void StopCapture()
	{
		StopMicrophone();
		started = false;
	}

	private void setUptMic()
	{
		GetComponent<AudioSource>().clip = null;
		GetComponent<AudioSource>().loop = true;
		GetComponent<AudioSource>().mute = false;
	}

	public void GetMicCaps()
	{
		Microphone.GetDeviceCaps(selectedDevice, out minFreq, out maxFreq);
		if (minFreq + maxFreq == 0)
		{
			maxFreq = 44100;
		}
	}

	public void StartMicrophone()
	{
		GetComponent<AudioSource>().clip = Microphone.Start(selectedDevice, loop: true, 10, maxFreq);
		while (Microphone.GetPosition(selectedDevice) <= 0)
		{
		}
		GetComponent<AudioSource>().Play();
	}

	public void StopMicrophone()
	{
		GetComponent<AudioSource>().Stop();
		Microphone.End(selectedDevice);
	}

	private void Update()
	{
		int num = isBeat();
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			StartCoroutine(showText(kick, gkick));
		}
		if (((uint)num & 2u) != 0)
		{
			StartCoroutine(showText(snare, gsnare));
		}
		if (((uint)num & 4u) != 0)
		{
			StartCoroutine(showText(hithat, ghithat));
		}
		if (((uint)num & 8u) != 0)
		{
			StartCoroutine(showText(energy, genergy));
		}
	}

	private IEnumerator showText(Text texto, GameObject objeto)
	{
		texto.enabled = true;
		objeto.GetComponent<Renderer>().material = matOn;
		yield return new WaitForSeconds(0.15f);
		texto.enabled = false;
		objeto.GetComponent<Renderer>().material = matOff;
	}

	private void Start()
	{
		started = false;
		selectedDevice = Microphone.devices[0].ToString();
		micSelected = true;
		GetMicCaps();
		setUptMic();
		StartCapture();
		spectrum0 = new float[numSamples];
		spectrum1 = new float[numSamples];
		frames0 = new float[numSamples];
		frames1 = new float[numSamples];
		setUpEnergy();
		setUpFrequency();
		tIni = Time.time;
		for (int i = 0; i < 50; i++)
		{
			tIniF[i] = Time.time;
		}
	}

	private int isBeat()
	{
		GetComponent<AudioSource>().GetSpectrumData(spectrum0, 0, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetSpectrumData(spectrum1, 1, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetOutputData(frames0, 0);
		GetComponent<AudioSource>().GetOutputData(frames1, 1);
		beatType beatType = beatType.None;
		switch (beatMode)
		{
		case beatmode.Energy:
			if (isBeatEnergy())
			{
				return 8;
			}
			break;
		case beatmode.Frequency:
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat());
		case beatmode.Both:
			if (isBeatEnergy())
			{
				beatType = beatType.energy;
			}
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat() | beatType);
		}
		return 0;
	}

	private void initDetector()
	{
		numHistory = 0;
		circularHistory = 0;
		for (int i = 0; i < 500; i++)
		{
			energyHistory[i] = 0f;
			mediasHistory[i] = 0f;
		}
		acumula = 0;
		historyLength = 0;
	}

	private void setUpEnergy()
	{
		sampleRate = AudioSettings.outputSampleRate;
		sampleRange = numSamples;
		historyLength = 43;
		numHistory = 0;
		circularHistory = 0;
	}

	private void setUpFrequency()
	{
		sampleRange = numSamples;
		historyLength = 43;
		sampleRate = AudioSettings.outputSampleRate;
		numHistory = 0;
		circularHistory = 0;
		float num = sampleRate / 2f;
		octaves = 1;
		while ((num /= 2f) > (float)minFrequency)
		{
			octaves++;
		}
		avgPerOctave = 3;
		totalBfLen = octaves * avgPerOctave;
		for (int i = 0; i < totalBfLen; i++)
		{
			for (int j = 0; j < historyLength; j++)
			{
				freqHistory[i, j] = 0f;
				medHistory[i, j] = 0f;
			}
		}
	}

	private bool isBeatEnergy()
	{
		float num = 0f;
		for (int i = 0; i < sampleRange; i++)
		{
			num += frames0[i] * frames0[i] + frames1[i] * frames1[i];
		}
		num /= (float)sampleRange;
		float num2 = Mathf.Sqrt(num) * 100f;
		float num3 = 0f;
		for (int j = 0; j < numHistory; j++)
		{
			num3 += energyHistory[j];
		}
		if (numHistory > 0)
		{
			num3 /= (float)numHistory;
		}
		float num4 = 0f;
		for (int k = 0; k < numHistory; k++)
		{
			num4 += (energyHistory[k] - num3) * (energyHistory[k] - num3);
		}
		if (numHistory > 0)
		{
			num4 /= (float)numHistory;
		}
		float num5 = -0.0025714f * num4 + 1.5142857f;
		float num6 = Mathf.Max(num2 - num5 * num3, 0f);
		float num7 = 0f;
		int num8 = 0;
		for (int l = 0; l < numHistory; l++)
		{
			if (mediasHistory[l] > 0f)
			{
				num7 += mediasHistory[l];
				num8++;
			}
		}
		if (num8 > 0)
		{
			num7 /= (float)num8;
		}
		float num9 = Mathf.Max(num6 - num7, 0f);
		bool result;
		if (Time.time - tIni < 0.05f)
		{
			result = false;
		}
		else if ((double)num9 > 0.0 && (double)num2 > 2.0)
		{
			result = true;
			tIni = Time.time;
		}
		else
		{
			result = false;
		}
		numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
		energyHistory[circularHistory] = num2;
		mediasHistory[circularHistory] = num6;
		circularHistory++;
		circularHistory %= historyLength;
		return result;
	}

	private int freqToIndex(float freq)
	{
		float num = sampleRate / (float)sampleRange;
		if (freq < num / 2f)
		{
			return 0;
		}
		if (freq > sampleRate / 2f - num / 2f)
		{
			return sampleRange / 2 - 1;
		}
		float num2 = freq / sampleRate;
		return (int)((float)sampleRange * num2);
	}

	private float calcAvg(float lowFreq, float hiFreq, float[] spectrum)
	{
		int num = freqToIndex(lowFreq);
		int num2 = freqToIndex(hiFreq);
		float num3 = 0f;
		for (int i = num; i <= num2; i++)
		{
			num3 += spectrum[i];
		}
		return num3 / (float)(num2 - num + 1);
	}

	private void isBeatFrequency()
	{
		for (int i = 0; i < octaves; i++)
		{
			float num = ((i != 0) ? (sampleRate / 2f / Mathf.Pow(2f, octaves - i)) : 0f);
			float num2 = (sampleRate / 2f / Mathf.Pow(2f, octaves - i - 1) - num) / (float)avgPerOctave;
			float num3 = num;
			for (int j = 0; j < avgPerOctave; j++)
			{
				int num4 = j + i * avgPerOctave;
				float num5 = calcAvg(num3, num3 + num2, spectrum0);
				float num6 = calcAvg(num3, num3 + num2, spectrum1);
				averages[num4] = num6;
				if (num5 > num6)
				{
					averages[num4] = num5;
				}
				num3 += num2;
			}
		}
		acumula++;
		for (int k = 0; k < totalBfLen; k++)
		{
			if (kg == 2)
			{
				estad1[k] = averages[k];
				estad2[k] = averages[k];
				continue;
			}
			estad1[k] += averages[k];
			if (averages[k] > estad2[k])
			{
				estad2[k] = averages[k];
			}
		}
		for (int l = 1; l < totalBfLen; l++)
		{
			float num7 = 0f;
			float num8 = 0f;
			float num9 = 0f;
			float num10 = averages[l];
			num7 = 0f;
			for (int m = 0; m < numHistory; m++)
			{
				num7 += freqHistory[l, m];
			}
			if (numHistory > 0)
			{
				num7 /= (float)numHistory;
			}
			num8 = 0f;
			for (int n = 0; n < numHistory; n++)
			{
				num8 += (freqHistory[l, n] - num7) * (freqHistory[l, n] - num7);
			}
			if (numHistory > 0)
			{
				num8 /= (float)numHistory;
			}
			num9 = -0.0025714f * num8 + 1.5142857f;
			float num11 = Mathf.Max(num10 - num9 * num7, 0f);
			float num12 = 0f;
			int num13 = 0;
			for (int num14 = 0; num14 < numHistory; num14++)
			{
				if (medHistory[l, num14] > 0f)
				{
					num12 += medHistory[l, num14];
					num13++;
				}
			}
			if (num13 > 0)
			{
				num12 /= (float)num13;
			}
			Mathf.Max(num11 - num12, 0f);
			float num15;
			float num16;
			if (l < 7)
			{
				num15 = 0.003f;
				num16 = 2f;
			}
			else if (l > 6 && l < 20)
			{
				num15 = 0.001f;
				num16 = 3f;
			}
			else
			{
				num15 = 0.001f;
				num16 = 4f;
			}
			if (Time.time - tIniF[l] < 0.05f)
			{
				detectados[l] = false;
			}
			else if (num10 > num16 * num7 && num10 > num15)
			{
				detectados[l] = true;
				tIniF[l] = Time.time;
			}
			else
			{
				detectados[l] = false;
			}
			numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
			freqHistory[l, circularHistory] = num10;
			medHistory[l, circularHistory] = num11;
			circularHistory++;
			circularHistory %= historyLength;
		}
	}

	private beatType isKick()
	{
		int high = ((6 >= totalBfLen) ? totalBfLen : 6);
		if (isRange(1, high, 2))
		{
			return beatType.kick;
		}
		return beatType.None;
	}

	private beatType isSnare()
	{
		int num = ((8 >= totalBfLen) ? totalBfLen : 8);
		int num2 = totalBfLen - 5;
		int threshold = (num2 - num) / 3;
		if (isRange(num, num2, threshold))
		{
			return beatType.snare;
		}
		return beatType.None;
	}

	private beatType isHat()
	{
		int low = ((totalBfLen - 6 >= 0) ? (totalBfLen - 6) : 0);
		int high = totalBfLen - 1;
		if (isRange(low, high, 1))
		{
			return beatType.hithat;
		}
		return beatType.None;
	}

	private bool isRange(int low, int high, int threshold)
	{
		int num = 0;
		for (int i = low; i < high + 1; i++)
		{
			if (detectados[i])
			{
				num++;
			}
		}
		if (num >= threshold)
		{
			return true;
		}
		return false;
	}
}
public class BeatDetectionExample : MonoBehaviour
{
	public enum beatmode
	{
		Energy,
		Frequency,
		Both
	}

	public enum beatType
	{
		None = 0,
		kick = 1,
		snare = 2,
		hithat = 4,
		energy = 8
	}

	public Text energy;

	public Text kick;

	public Text snare;

	public Text hithat;

	public GameObject genergy;

	public GameObject gkick;

	public GameObject gsnare;

	public GameObject ghithat;

	public Material matOn;

	public Material matOff;

	public beatmode beatMode;

	private int numSamples = 1024;

	private int minFrequency = 60;

	private const int MAX_FRQSEC = 50;

	private const int LINEAR_OCTAVE_DIVISIONS = 3;

	private const int HISTORY_LENGTH = 43;

	private const int MAX_HISTORY = 500;

	private const float MIN_BEAT_SEPARATION = 0.05f;

	private int numHistory;

	private int circularHistory;

	private float[] energyHistory = new float[500];

	private float[] mediasHistory = new float[500];

	private float[,] freqHistory = new float[50, 500];

	private float[,] medHistory = new float[50, 500];

	private float[] averages = new float[50];

	private bool[] detectados = new bool[50];

	private int acumula;

	private float[] estad1 = new float[50];

	private float[] estad2 = new float[50];

	private float sampleRate;

	private int avgPerOctave;

	private int octaves;

	private int totalBfLen;

	private int historyLength;

	private int sampleRange;

	private float tIni;

	private float[] tIniF = new float[50];

	private int kg;

	private float[] spectrum0;

	private float[] spectrum1;

	private float[] frames0;

	private float[] frames1;

	private void Update()
	{
		int num = isBeat();
		if (((uint)num & (true ? 1u : 0u)) != 0)
		{
			StartCoroutine(showText(kick, gkick));
		}
		if (((uint)num & 2u) != 0)
		{
			StartCoroutine(showText(snare, gsnare));
		}
		if (((uint)num & 4u) != 0)
		{
			StartCoroutine(showText(hithat, ghithat));
		}
		if (((uint)num & 8u) != 0)
		{
			StartCoroutine(showText(energy, genergy));
		}
	}

	private IEnumerator showText(Text texto, GameObject objeto)
	{
		texto.enabled = true;
		objeto.GetComponent<Renderer>().material = matOn;
		yield return new WaitForSeconds(0.15f);
		texto.enabled = false;
		objeto.GetComponent<Renderer>().material = matOff;
	}

	private void Start()
	{
		spectrum0 = new float[numSamples];
		spectrum1 = new float[numSamples];
		frames0 = new float[numSamples];
		frames1 = new float[numSamples];
		setUpEnergy();
		setUpFrequency();
		tIni = Time.time;
		for (int i = 0; i < 50; i++)
		{
			tIniF[i] = Time.time;
		}
	}

	private int isBeat()
	{
		GetComponent<AudioSource>().GetSpectrumData(spectrum0, 0, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetSpectrumData(spectrum1, 1, FFTWindow.BlackmanHarris);
		GetComponent<AudioSource>().GetOutputData(frames0, 0);
		GetComponent<AudioSource>().GetOutputData(frames1, 1);
		beatType beatType = beatType.None;
		switch (beatMode)
		{
		case beatmode.Energy:
			if (isBeatEnergy())
			{
				return 8;
			}
			break;
		case beatmode.Frequency:
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat());
		case beatmode.Both:
			if (isBeatEnergy())
			{
				beatType = beatType.energy;
			}
			isBeatFrequency();
			return (int)(isKick() | isSnare() | isHat() | beatType);
		}
		return 0;
	}

	private void initDetector()
	{
		numHistory = 0;
		circularHistory = 0;
		for (int i = 0; i < 500; i++)
		{
			energyHistory[i] = 0f;
			mediasHistory[i] = 0f;
		}
		acumula = 0;
		historyLength = 0;
	}

	private void setUpEnergy()
	{
		sampleRate = AudioSettings.outputSampleRate;
		sampleRange = numSamples;
		historyLength = 43;
		numHistory = 0;
		circularHistory = 0;
	}

	private void setUpFrequency()
	{
		sampleRange = numSamples;
		historyLength = 43;
		sampleRate = AudioSettings.outputSampleRate;
		numHistory = 0;
		circularHistory = 0;
		float num = sampleRate / 2f;
		octaves = 1;
		while ((num /= 2f) > (float)minFrequency)
		{
			octaves++;
		}
		avgPerOctave = 3;
		totalBfLen = octaves * avgPerOctave;
		for (int i = 0; i < totalBfLen; i++)
		{
			for (int j = 0; j < historyLength; j++)
			{
				freqHistory[i, j] = 0f;
				medHistory[i, j] = 0f;
			}
		}
	}

	private bool isBeatEnergy()
	{
		float num = 0f;
		for (int i = 0; i < sampleRange; i++)
		{
			num += frames0[i] * frames0[i] + frames1[i] * frames1[i];
		}
		num /= (float)sampleRange;
		float num2 = Mathf.Sqrt(num) * 100f;
		float num3 = 0f;
		for (int j = 0; j < numHistory; j++)
		{
			num3 += energyHistory[j];
		}
		if (numHistory > 0)
		{
			num3 /= (float)numHistory;
		}
		float num4 = 0f;
		for (int k = 0; k < numHistory; k++)
		{
			num4 += (energyHistory[k] - num3) * (energyHistory[k] - num3);
		}
		if (numHistory > 0)
		{
			num4 /= (float)numHistory;
		}
		float num5 = -0.0025714f * num4 + 1.5142857f;
		float num6 = Mathf.Max(num2 - num5 * num3, 0f);
		float num7 = 0f;
		int num8 = 0;
		for (int l = 0; l < numHistory; l++)
		{
			if (mediasHistory[l] > 0f)
			{
				num7 += mediasHistory[l];
				num8++;
			}
		}
		if (num8 > 0)
		{
			num7 /= (float)num8;
		}
		float num9 = Mathf.Max(num6 - num7, 0f);
		bool result;
		if (Time.time - tIni < 0.05f)
		{
			result = false;
		}
		else if ((double)num9 > 0.0 && (double)num2 > 2.0)
		{
			result = true;
			tIni = Time.time;
		}
		else
		{
			result = false;
		}
		numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
		energyHistory[circularHistory] = num2;
		mediasHistory[circularHistory] = num6;
		circularHistory++;
		circularHistory %= historyLength;
		return result;
	}

	private int freqToIndex(float freq)
	{
		float num = sampleRate / (float)sampleRange;
		if (freq < num / 2f)
		{
			return 0;
		}
		if (freq > sampleRate / 2f - num / 2f)
		{
			return sampleRange / 2 - 1;
		}
		float num2 = freq / sampleRate;
		return (int)((float)sampleRange * num2);
	}

	private float calcAvg(float lowFreq, float hiFreq, float[] spectrum)
	{
		int num = freqToIndex(lowFreq);
		int num2 = freqToIndex(hiFreq);
		float num3 = 0f;
		for (int i = num; i <= num2; i++)
		{
			num3 += spectrum[i];
		}
		return num3 / (float)(num2 - num + 1);
	}

	private void isBeatFrequency()
	{
		for (int i = 0; i < octaves; i++)
		{
			float num = ((i != 0) ? (sampleRate / 2f / Mathf.Pow(2f, octaves - i)) : 0f);
			float num2 = (sampleRate / 2f / Mathf.Pow(2f, octaves - i - 1) - num) / (float)avgPerOctave;
			float num3 = num;
			for (int j = 0; j < avgPerOctave; j++)
			{
				int num4 = j + i * avgPerOctave;
				float num5 = calcAvg(num3, num3 + num2, spectrum0);
				float num6 = calcAvg(num3, num3 + num2, spectrum1);
				averages[num4] = num6;
				if (num5 > num6)
				{
					averages[num4] = num5;
				}
				num3 += num2;
			}
		}
		acumula++;
		for (int k = 0; k < totalBfLen; k++)
		{
			if (kg == 2)
			{
				estad1[k] = averages[k];
				estad2[k] = averages[k];
				continue;
			}
			estad1[k] += averages[k];
			if (averages[k] > estad2[k])
			{
				estad2[k] = averages[k];
			}
		}
		for (int l = 1; l < totalBfLen; l++)
		{
			float num7 = 0f;
			float num8 = 0f;
			float num9 = 0f;
			float num10 = averages[l];
			num7 = 0f;
			for (int m = 0; m < numHistory; m++)
			{
				num7 += freqHistory[l, m];
			}
			if (numHistory > 0)
			{
				num7 /= (float)numHistory;
			}
			num8 = 0f;
			for (int n = 0; n < numHistory; n++)
			{
				num8 += (freqHistory[l, n] - num7) * (freqHistory[l, n] - num7);
			}
			if (numHistory > 0)
			{
				num8 /= (float)numHistory;
			}
			num9 = -0.0025714f * num8 + 1.5142857f;
			float num11 = Mathf.Max(num10 - num9 * num7, 0f);
			float num12 = 0f;
			int num13 = 0;
			for (int num14 = 0; num14 < numHistory; num14++)
			{
				if (medHistory[l, num14] > 0f)
				{
					num12 += medHistory[l, num14];
					num13++;
				}
			}
			if (num13 > 0)
			{
				num12 /= (float)num13;
			}
			Mathf.Max(num11 - num12, 0f);
			float num15;
			float num16;
			if (l < 7)
			{
				num15 = 0.003f;
				num16 = 2f;
			}
			else if (l > 6 && l < 20)
			{
				num15 = 0.001f;
				num16 = 3f;
			}
			else
			{
				num15 = 0.001f;
				num16 = 4f;
			}
			if (Time.time - tIniF[l] < 0.05f)
			{
				detectados[l] = false;
			}
			else if (num10 > num16 * num7 && num10 > num15)
			{
				detectados[l] = true;
				tIniF[l] = Time.time;
			}
			else
			{
				detectados[l] = false;
			}
			numHistory = ((numHistory < historyLength) ? (numHistory + 1) : numHistory);
			freqHistory[l, circularHistory] = num10;
			medHistory[l, circularHistory] = num11;
			circularHistory++;
			circularHistory %= historyLength;
		}
	}

	private beatType isKick()
	{
		int high = ((6 >= totalBfLen) ? totalBfLen : 6);
		if (isRange(1, high, 2))
		{
			return beatType.kick;
		}
		return beatType.None;
	}

	private beatType isSnare()
	{
		int num = ((8 >= totalBfLen) ? totalBfLen : 8);
		int num2 = totalBfLen - 5;
		int threshold = (num2 - num) / 3;
		if (isRange(num, num2, threshold))
		{
			return beatType.snare;
		}
		return beatType.None;
	}

	private beatType isHat()
	{
		int low = ((totalBfLen - 6 >= 0) ? (totalBfLen - 6) : 0);
		int high = totalBfLen - 1;
		if (isRange(low, high, 1))
		{
			return beatType.hithat;
		}
		return beatType.None;
	}

	private bool isRange(int low, int high, int threshold)
	{
		int num = 0;
		for (int i = low; i < high + 1; i++)
		{
			if (detectados[i])
			{
				num++;
			}
		}
		if (num >= threshold)
		{
			return true;
		}
		return false;
	}
}
public class StageController : MonoBehaviour
{
	public GameObject lightning;

	public GameObject leftfocus;

	public GameObject rightfocus;

	public GameObject pinkflare;

	public GameObject blueflare;

	public GameObject vlight;

	public GameObject startButton;

	public Sprite focuson;

	public float duration = 0.2f;

	public List<Color> focusColors = new List<Color>();

	private int currentColor;

	public void MyCallbackEventHandler(BeatDetection.EventInfo eventInfo)
	{
		switch (eventInfo.messageInfo)
		{
		case BeatDetection.EventType.Energy:
			RotateColor();
			PinkflareOn();
			break;
		case BeatDetection.EventType.HitHat:
			LightningOn();
			break;
		case BeatDetection.EventType.Kick:
			VLightOn();
			break;
		case BeatDetection.EventType.Snare:
			BlueflareOn();
			break;
		}
	}

	private void Start()
	{
		GetComponent<BeatDetection>().CallBackFunction = MyCallbackEventHandler;
	}

	public void GoStage()
	{
		startButton.SetActive(value: false);
		GetComponent<AudioSource>().Play();
	}

	private void RotateColor()
	{
		currentColor++;
		currentColor %= focusColors.Count;
		leftfocus.GetComponent<Image>().color = focusColors[currentColor];
		rightfocus.GetComponent<Image>().color = focusColors[currentColor];
	}

	private void LightningOn()
	{
		if (!lightning.activeSelf)
		{
			lightning.SetActive(value: true);
			Invoke("LightningOff", duration);
		}
	}

	private void LightningOff()
	{
		lightning.SetActive(value: false);
	}

	private void PinkflareOn()
	{
		if (!pinkflare.activeSelf)
		{
			pinkflare.SetActive(value: true);
			Invoke("PinkflareOff", duration);
		}
	}

	private void PinkflareOff()
	{
		pinkflare.SetActive(value: false);
	}

	private void BlueflareOn()
	{
		if (!blueflare.activeSelf)
		{
			blueflare.SetActive(value: true);
			Invoke("BlueflareOff", duration);
		}
	}

	private void BlueflareOff()
	{
		blueflare.SetActive(value: false);
	}

	private void VLightOn()
	{
		if (!vlight.activeSelf)
		{
			vlight.SetActive(value: true);
			Invoke("VLightOff", duration);
		}
	}

	private void VLightOff()
	{
		vlight.SetActive(value: false);
	}
}
public class AnimatedBall : MonoBehaviour
{
	private UnityEngine.Quaternion _startRotation;

	private void Start()
	{
		_startRotation = base.gameObject.transform.rotation;
	}

	private void Update()
	{
		if (demo.ballsRotation)
		{
			UnityEngine.Vector3 eulerAngles = base.gameObject.transform.rotation.eulerAngles;
			eulerAngles.y += 2f;
			_startRotation.eulerAngles = eulerAngles;
			base.gameObject.transform.rotation = _startRotation;
		}
	}
}
public class demo : MonoBehaviour
{
	public static bool ballsRotation = true;

	public GameObject _lights;

	private string address = "https://www.assetstore.unity3d.com/en/#!/search/page=1/sortby=popularity/query=publisher:20415";

	public void openURL()
	{
		Application.OpenURL(address);
	}

	public void toggleRotation()
	{
		ballsRotation = !ballsRotation;
	}

	public void toggleLight()
	{
		_lights.SetActive(!_lights.activeSelf);
	}

	public void toggleWireframe()
	{
	}
}
public enum ButtonTypes
{
	NotDefined,
	Previous,
	Next
}
public class PEButtonScript : MonoBehaviour, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler
{
	private Button myButton;

	public ButtonTypes ButtonType;

	private void Start()
	{
		myButton = base.gameObject.GetComponent<Button>();
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		UICanvasManager.GlobalAccess.MouseOverButton = true;
		UICanvasManager.GlobalAccess.UpdateToolTip(ButtonType);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		UICanvasManager.GlobalAccess.MouseOverButton = false;
		UICanvasManager.GlobalAccess.ClearToolTip();
	}

	public void OnButtonClicked()
	{
		UICanvasManager.GlobalAccess.UIButtonClick(ButtonType);
	}
}
public class PEDestoryTimed : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class ParticleEffectsLibrary : MonoBehaviour
{
	public static ParticleEffectsLibrary GlobalAccess;

	public int TotalEffects;

	public int CurrentParticleEffectIndex;

	public int CurrentParticleEffectNum;

	public UnityEngine.Vector3[] ParticleEffectSpawnOffsets;

	public float[] ParticleEffectLifetimes;

	public GameObject[] ParticleEffectPrefabs;

	private string effectNameString = "";

	private List<Transform> currentActivePEList;

	private UnityEngine.Vector3 spawnPosition = UnityEngine.Vector3.zero;

	private void Awake()
	{
		GlobalAccess = this;
		currentActivePEList = new List<Transform>();
		TotalEffects = ParticleEffectPrefabs.Length;
		CurrentParticleEffectNum = 1;
		if (ParticleEffectSpawnOffsets.Length != TotalEffects)
		{
			UnityEngine.Debug.LogError("ParticleEffectsLibrary-ParticleEffectSpawnOffset: Not all arrays match length, double check counts.");
		}
		if (ParticleEffectPrefabs.Length != TotalEffects)
		{
			UnityEngine.Debug.LogError("ParticleEffectsLibrary-ParticleEffectPrefabs: Not all arrays match length, double check counts.");
		}
		effectNameString = ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	private void Start()
	{
	}

	public string GetCurrentPENameString()
	{
		return ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	public void PreviousParticleEffect()
	{
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] == 0f && currentActivePEList.Count > 0)
		{
			for (int i = 0; i < currentActivePEList.Count; i++)
			{
				if (currentActivePEList[i] != null)
				{
					UnityEngine.Object.Destroy(currentActivePEList[i].gameObject);
				}
			}
			currentActivePEList.Clear();
		}
		if (CurrentParticleEffectIndex > 0)
		{
			CurrentParticleEffectIndex--;
		}
		else
		{
			CurrentParticleEffectIndex = TotalEffects - 1;
		}
		CurrentParticleEffectNum = CurrentParticleEffectIndex + 1;
		effectNameString = ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	public void NextParticleEffect()
	{
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] == 0f && currentActivePEList.Count > 0)
		{
			for (int i = 0; i < currentActivePEList.Count; i++)
			{
				if (currentActivePEList[i] != null)
				{
					UnityEngine.Object.Destroy(currentActivePEList[i].gameObject);
				}
			}
			currentActivePEList.Clear();
		}
		if (CurrentParticleEffectIndex < TotalEffects - 1)
		{
			CurrentParticleEffectIndex++;
		}
		else
		{
			CurrentParticleEffectIndex = 0;
		}
		CurrentParticleEffectNum = CurrentParticleEffectIndex + 1;
		effectNameString = ParticleEffectPrefabs[CurrentParticleEffectIndex].name + " (" + CurrentParticleEffectNum + " of " + TotalEffects + ")";
	}

	public void SpawnParticleEffect(UnityEngine.Vector3 positionInWorldToSpawn)
	{
		spawnPosition = positionInWorldToSpawn + ParticleEffectSpawnOffsets[CurrentParticleEffectIndex];
		GameObject gameObject = UnityEngine.Object.Instantiate(ParticleEffectPrefabs[CurrentParticleEffectIndex], spawnPosition, ParticleEffectPrefabs[CurrentParticleEffectIndex].transform.rotation);
		gameObject.name = "PE_" + ParticleEffectPrefabs[CurrentParticleEffectIndex];
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] == 0f)
		{
			currentActivePEList.Add(gameObject.transform);
		}
		currentActivePEList.Add(gameObject.transform);
		if (ParticleEffectLifetimes[CurrentParticleEffectIndex] != 0f)
		{
			UnityEngine.Object.Destroy(gameObject, ParticleEffectLifetimes[CurrentParticleEffectIndex]);
		}
	}
}
public class UICanvasManager : MonoBehaviour
{
	public static UICanvasManager GlobalAccess;

	public bool MouseOverButton;

	public Text PENameText;

	public Text ToolTipText;

	private RaycastHit rayHit;

	private void Awake()
	{
		GlobalAccess = this;
	}

	private void Start()
	{
		if (PENameText != null)
		{
			PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
		}
	}

	private void Update()
	{
		if (!MouseOverButton && Input.GetMouseButtonUp(0))
		{
			SpawnCurrentParticleEffect();
		}
		if (Input.GetKeyUp(KeyCode.A))
		{
			SelectPreviousPE();
		}
		if (Input.GetKeyUp(KeyCode.D))
		{
			SelectNextPE();
		}
	}

	public void UpdateToolTip(ButtonTypes toolTipType)
	{
		if (ToolTipText != null)
		{
			switch (toolTipType)
			{
			case ButtonTypes.Previous:
				ToolTipText.text = "Select Previous Particle Effect";
				break;
			case ButtonTypes.Next:
				ToolTipText.text = "Select Next Particle Effect";
				break;
			}
		}
	}

	public void ClearToolTip()
	{
		if (ToolTipText != null)
		{
			ToolTipText.text = "";
		}
	}

	private void SelectPreviousPE()
	{
		ParticleEffectsLibrary.GlobalAccess.PreviousParticleEffect();
		if (PENameText != null)
		{
			PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
		}
	}

	private void SelectNextPE()
	{
		ParticleEffectsLibrary.GlobalAccess.NextParticleEffect();
		if (PENameText != null)
		{
			PENameText.text = ParticleEffectsLibrary.GlobalAccess.GetCurrentPENameString();
		}
	}

	private void SpawnCurrentParticleEffect()
	{
		if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out rayHit))
		{
			ParticleEffectsLibrary.GlobalAccess.SpawnParticleEffect(rayHit.point);
		}
	}

	public void UIButtonClick(ButtonTypes buttonTypeClicked)
	{
		switch (buttonTypeClicked)
		{
		case ButtonTypes.Previous:
			SelectPreviousPE();
			break;
		case ButtonTypes.Next:
			SelectNextPE();
			break;
		}
	}
}
public class ETFXProjectileScript : MonoBehaviour
{
	public GameObject impactParticle;

	public GameObject projectileParticle;

	public GameObject muzzleParticle;

	public GameObject[] trailParticles;

	[HideInInspector]
	public UnityEngine.Vector3 impactNormal;

	private bool hasCollided;

	private void Start()
	{
		projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
		projectileParticle.transform.parent = base.transform;
		if ((bool)muzzleParticle)
		{
			muzzleParticle = UnityEngine.Object.Instantiate(muzzleParticle, base.transform.position, base.transform.rotation);
			UnityEngine.Object.Destroy(muzzleParticle, 1.5f);
		}
	}

	private void OnCollisionEnter(Collision hit)
	{
		if (hasCollided)
		{
			return;
		}
		hasCollided = true;
		impactParticle = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3.up, impactNormal));
		if (hit.gameObject.tag == "Destructible")
		{
			UnityEngine.Object.Destroy(hit.gameObject);
		}
		GameObject[] array = trailParticles;
		foreach (GameObject gameObject in array)
		{
			GameObject obj = base.transform.Find(projectileParticle.name + "/" + gameObject.name).gameObject;
			obj.transform.parent = null;
			UnityEngine.Object.Destroy(obj, 3f);
		}
		UnityEngine.Object.Destroy(projectileParticle, 3f);
		UnityEngine.Object.Destroy(impactParticle, 5f);
		UnityEngine.Object.Destroy(base.gameObject);
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		for (int j = 1; j < componentsInChildren.Length; j++)
		{
			ParticleSystem particleSystem = componentsInChildren[j];
			if (particleSystem.gameObject.name.Contains("Trail"))
			{
				particleSystem.transform.SetParent(null);
				UnityEngine.Object.Destroy(particleSystem.gameObject, 2f);
			}
		}
	}
}
public class ETFXSceneManager : MonoBehaviour
{
	public void LoadScene1()
	{
		SceneManager.LoadScene("etfx_explosions");
	}

	public void LoadScene2()
	{
		SceneManager.LoadScene("etfx_explosions2");
	}

	public void LoadScene3()
	{
		SceneManager.LoadScene("etfx_portals");
	}

	public void LoadScene4()
	{
		SceneManager.LoadScene("etfx_magic");
	}

	public void LoadScene5()
	{
		SceneManager.LoadScene("etfx_emojis");
	}

	public void LoadScene6()
	{
		SceneManager.LoadScene("etfx_sparkles");
	}

	public void LoadScene7()
	{
		SceneManager.LoadScene("etfx_fireworks");
	}

	public void LoadScene8()
	{
		SceneManager.LoadScene("etfx_powerups");
	}

	public void LoadScene9()
	{
		SceneManager.LoadScene("etfx_swordcombat");
	}

	public void LoadScene10()
	{
		SceneManager.LoadScene("etfx_maindemo");
	}

	public void LoadScene11()
	{
		SceneManager.LoadScene("etfx_combat");
	}

	public void LoadScene12()
	{
		SceneManager.LoadScene("etfx_2ddemo");
	}

	public void LoadScene13()
	{
		SceneManager.LoadScene("etfx_missiles");
	}
}
public class Button1 : MonoBehaviour
{
	public Transform effectToPlay;

	public Transform objectToAnimate;

	private void OnMouseDown()
	{
		StartCoroutine(PlayEffect());
	}

	private IEnumerator PlayEffect()
	{
		objectToAnimate.GetComponent<Animation>().Play("attack");
		objectToAnimate.GetComponent<Animation>().PlayQueued("idle");
		yield return new WaitForSeconds(0.4f);
		float num = -10f;
		UnityEngine.Vector3 position = objectToAnimate.TransformPoint(objectToAnimate.forward * num);
		position.y += 1.2f;
		position.x -= 1.5f;
		UnityEngine.Object.Instantiate(effectToPlay, position, UnityEngine.Quaternion.identity).gameObject.AddComponent<EffectSelfDestruct>();
	}
}
public class EffectSelfDestruct : MonoBehaviour
{
	private void Start()
	{
		ParticleSystem particleSystem = (ParticleSystem)base.gameObject.GetComponent("ParticleSystem");
		UnityEngine.Object.Destroy(base.gameObject, particleSystem.duration);
	}
}
public class CloudFlow : MonoBehaviour
{
	public float m_SpeedU = 0.1f;

	private void Update()
	{
		float x = Time.time * m_SpeedU;
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().material.mainTextureOffset = new UnityEngine.Vector2(x, 0f);
		}
	}
}
public class FloatObject : MonoBehaviour
{
	private enum statMove
	{
		statMoveBegin,
		statMoveAway,
		statMoveBack
	}

	public float m_Time = 2f;

	public float m_TimeSpread = 0.25f;

	public float m_HorizontalSpread = 0.25f;

	public float m_VerticalSpread = 0.25f;

	private float m_TimeRound = 1f;

	private float m_TimeCount;

	private UnityEngine.Vector3 m_StartPosition;

	private UnityEngine.Vector3 m_EndPosition;

	private statMove m_statMove;

	private void Start()
	{
		m_StartPosition = base.transform.localPosition;
		SetupNewMove();
	}

	private void Update()
	{
		if (m_TimeCount >= m_TimeRound)
		{
			SetupNewMove();
			return;
		}
		float t = m_TimeCount / m_TimeRound;
		if (m_statMove == statMove.statMoveAway)
		{
			base.transform.localPosition = UnityEngine.Vector3.Lerp(m_StartPosition, m_EndPosition, t);
		}
		else
		{
			base.transform.localPosition = UnityEngine.Vector3.Lerp(m_EndPosition, m_StartPosition, t);
		}
		m_TimeCount += Time.deltaTime;
	}

	private void SetupNewMove()
	{
		m_TimeRound = m_Time + UnityEngine.Random.Range(0f - m_TimeSpread, m_TimeSpread);
		m_TimeCount = 0f;
		if (m_statMove == statMove.statMoveAway)
		{
			m_statMove = statMove.statMoveBack;
		}
		else if (m_statMove == statMove.statMoveBack || m_statMove == statMove.statMoveBegin)
		{
			m_EndPosition = m_StartPosition + new UnityEngine.Vector3(UnityEngine.Random.Range(0f - m_HorizontalSpread, m_HorizontalSpread), UnityEngine.Random.Range(0f - m_VerticalSpread, m_VerticalSpread), UnityEngine.Random.Range(0f - m_HorizontalSpread, m_HorizontalSpread));
			m_statMove = statMove.statMoveAway;
		}
	}
}
public class FollowObject : MonoBehaviour
{
	public Transform m_Target;

	public bool m_TranslateXPosition = true;

	public bool m_TranslateYPosition;

	public bool m_TranslateZPosition = true;

	private Bounds m_Bounds;

	private UnityEngine.Vector3 m_DifCenter;

	private void Start()
	{
		if (!(m_Target != null))
		{
			return;
		}
		if (m_Target.GetComponent<Renderer>() != null)
		{
			m_Bounds = m_Target.GetComponent<Renderer>().bounds;
			foreach (Transform item in m_Target)
			{
				m_Bounds.Encapsulate(item.gameObject.GetComponent<Renderer>().bounds);
			}
		}
		else
		{
			UnityEngine.Vector3 zero = UnityEngine.Vector3.zero;
			foreach (Transform item2 in m_Target)
			{
				zero += item2.gameObject.GetComponent<Renderer>().bounds.center;
			}
			zero /= (float)m_Target.childCount;
			m_Bounds = new Bounds(zero, UnityEngine.Vector3.zero);
			foreach (Transform item3 in m_Target)
			{
				m_Bounds.Encapsulate(item3.gameObject.GetComponent<Renderer>().bounds);
			}
		}
		m_DifCenter = m_Bounds.center - m_Target.transform.position;
	}

	private void Update()
	{
		if (m_TranslateXPosition || m_TranslateYPosition || m_TranslateZPosition)
		{
			float x = base.transform.position.x;
			float y = base.transform.position.y;
			float z = base.transform.position.z;
			if (m_TranslateXPosition)
			{
				x = m_Target.transform.position.x + m_DifCenter.x;
			}
			if (m_TranslateYPosition)
			{
				y = m_Target.transform.position.y + m_DifCenter.y;
			}
			if (m_TranslateZPosition)
			{
				z = m_Target.transform.position.z + m_DifCenter.z;
			}
			base.transform.position = new UnityEngine.Vector3(x, y, z);
		}
	}
}
public class RandomMoveOnTerrain : MonoBehaviour
{
	public Terrain m_Terrain;

	public float m_Speed = 1f;

	public float m_SpeedSpread = 0.25f;

	public float m_MoveDistance = 3f;

	private float m_currentSpeed;

	private float m_TimeRound = 1f;

	private float m_TimeCount;

	private UnityEngine.Vector3 m_StartPosition;

	private UnityEngine.Vector3 m_EndPosition;

	private Bounds m_LimitArea;

	private void Start()
	{
		m_StartPosition = base.transform.position;
		m_EndPosition = m_StartPosition;
		if (m_Terrain != null)
		{
			m_LimitArea.min = m_Terrain.transform.position;
			m_LimitArea.max = m_LimitArea.min + m_Terrain.terrainData.size;
			m_LimitArea.center = (m_LimitArea.min + m_LimitArea.max) / 2f;
		}
		SetupNewMove();
	}

	private void Update()
	{
		if (!(m_Terrain != null))
		{
			return;
		}
		if (m_TimeCount >= m_TimeRound)
		{
			SetupNewMove();
			return;
		}
		float t = m_TimeCount / m_TimeRound;
		base.transform.position = UnityEngine.Vector3.Lerp(m_StartPosition, m_EndPosition, t);
		m_TimeCount += Time.deltaTime;
		if (m_Terrain != null)
		{
			float num = Terrain.activeTerrain.SampleHeight(base.transform.position);
			base.transform.position = new UnityEngine.Vector3(base.transform.position.x, num + m_LimitArea.min.y, base.transform.position.z);
		}
	}

	private void SetupNewMove()
	{
		m_StartPosition = base.transform.position;
		m_EndPosition = m_StartPosition + new UnityEngine.Vector3(UnityEngine.Random.Range(0f - m_MoveDistance, m_MoveDistance), 0f, UnityEngine.Random.Range(0f - m_MoveDistance, m_MoveDistance));
		if (m_Terrain != null)
		{
			if (m_EndPosition.x < m_LimitArea.min.x)
			{
				m_EndPosition.x = m_LimitArea.min.x;
			}
			if (m_EndPosition.x > m_LimitArea.max.x)
			{
				m_EndPosition.x = m_LimitArea.max.x;
			}
			if (m_EndPosition.z < m_LimitArea.min.z)
			{
				m_EndPosition.z = m_LimitArea.min.z;
			}
			if (m_EndPosition.z > m_LimitArea.max.z)
			{
				m_EndPosition.z = m_LimitArea.max.z;
			}
		}
		float num = UnityEngine.Vector2.Distance(new UnityEngine.Vector2(m_StartPosition.x, m_StartPosition.z), new UnityEngine.Vector2(m_EndPosition.x, m_EndPosition.z));
		m_currentSpeed = m_Speed + UnityEngine.Random.Range(0f - m_SpeedSpread, m_SpeedSpread);
		m_TimeRound = num / m_currentSpeed;
		m_TimeCount = 0f;
	}
}
public class WaterFlow : MonoBehaviour
{
	public float m_SpeedU = 0.1f;

	public float m_SpeedV = -0.1f;

	private void Update()
	{
		float x = Time.time * m_SpeedU;
		float y = Time.time * m_SpeedV;
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().material.mainTextureOffset = new UnityEngine.Vector2(x, y);
		}
	}
}
public class BallExploreBsJian : BallExploreBase
{
	private ParticleSystem particle;

	private ParticleSystem particleF;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
		particleF = ball.transform.Find("effect/explore/GYJZexploreBlackF").GetComponent<ParticleSystem>();
		particleF.transform.position = colliderPoint;
		particleF.Play();
		addExploreForeceFs(particleF, blade, 10f);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
		particleF = ball.transform.Find("effect/explore/GYJZexploreLeftF").GetComponent<ParticleSystem>();
		particleF.transform.position = colliderPoint;
		particleF.Play();
		addExploreForeceFs(particleF, blade, 10f);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
		particleF = ball.transform.Find("effect/explore/GYJZexploreRightF").GetComponent<ParticleSystem>();
		particleF.transform.position = colliderPoint;
		particleF.Play();
		addExploreForeceFs(particleF, blade, 10f);
	}

	internal override float splitAndDistroy()
	{
		ball.GetComponent<BoxCollider>().enabled = false;
		ball.ball.GetComponent<Animator>().Play("dissapearBsJian");
		return particle.main.duration;
	}
}
public class CubeLarger : MonoBehaviour
{
	public BoxCollider boxCollider;

	public Transform cube;

	public Transform waveRayOrigin;

	public List<Transform> planePoints;

	internal void larger()
	{
		float cubeLarger = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeLarger;
		float num = boxCollider.size.x / 2f;
		boxCollider.size *= cubeLarger;
		cube.localScale *= cubeLarger;
		foreach (Transform planePoint in planePoints)
		{
			planePoint.localPosition *= cubeLarger;
		}
		waveRayOrigin.localPosition = new UnityEngine.Vector3(0f, num * cubeLarger + 0.01f, 0f);
	}
}
public class AdjBlade : MonoBehaviour
{
	public Blade blade;

	public void OnCollisionEnter(Collision collision)
	{
		blade.OnCollisionEnter(collision);
	}

	public void OnCollisionStay(Collision collision)
	{
		blade.OnCollisionStay(collision);
	}

	public void OnCollisionExit(Collision collision)
	{
		blade.OnCollisionExit(collision);
	}
}
public class BallFlyPos
{
	public UnityEngine.Vector3 originPos;

	public UnityEngine.Vector3 jiaSuEndPos;

	public UnityEngine.Vector3 rightWeiZhiPos;

	public float originZRotation;

	public float rightZRotation;

	public bool leftFlyToRight;

	public bool rightFlyToLeft;
}
public class HuXianTest : MonoBehaviour
{
	public GameObject t1;

	public GameObject t2;

	private void Start()
	{
		base.transform.position = t1.transform.position;
	}

	private void Update()
	{
		UnityEngine.Vector3 vector = (t1.transform.position + t2.transform.position) * 0.5f;
		vector -= new UnityEngine.Vector3(0f, -1f, 0f);
		UnityEngine.Vector3 a = t1.transform.position - vector;
		UnityEngine.Vector3 b = t2.transform.position - vector;
		base.transform.position = UnityEngine.Vector3.Slerp(a, b, Time.time / 5f);
		base.transform.position += vector;
	}
}
public class LengthAdj : MonoBehaviour
{
	private float saberLarger;

	private float saberMove;

	public Transform AdjBladTransform;

	private void Start()
	{
		saberLarger = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger;
		saberMove = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove;
		base.transform.localPosition = new UnityEngine.Vector3(0f, saberMove, 0f);
		AdjBladTransform.localScale = new UnityEngine.Vector3(1f, saberLarger, 1f);
	}
}
public class P122SettingManager : MonoBehaviour
{
	public Button saberLagerSubBtn;

	public TMP_Text saberLagerValue;

	public Button saberLagerAddBtn;

	public Button saberMoveSubBtn;

	public TMP_Text saberMoveValue;

	public Button saberMoveAddBtn;

	public Button yuPanBiLiSubBtn;

	public TMP_Text yuPanBiLiValue;

	public Button yuPanBiLiAddBtn;

	public Button flyDongHuaSubBtn;

	public TMP_Text flyDongHuaValue;

	public Button flyDongHuaAddBtn;

	public Button saberFovSubBtn;

	public TMP_Text saberFovValue;

	public Button saberFovAddBtn;

	private void Awake()
	{
		AudioSourceCommon.AttachPointEnterAudio(saberLagerSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(saberLagerAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(saberMoveSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(saberMoveAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(yuPanBiLiSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(yuPanBiLiAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(flyDongHuaSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(flyDongHuaAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(saberFovSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(saberFovAddBtn.transform);
	}

	private void Start()
	{
		saberLagerValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger.ToString("f2");
		saberMoveValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove.ToString("f2");
		yuPanBiLiValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili.ToString("f2");
		flyDongHuaValue.text = getFlyDongHuaText();
		saberFovValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov.ToString("f1");
	}

	private string getFlyDongHuaText()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua == 0)
		{
			return "关";
		}
		return "开";
	}

	public void clickSaberLagerSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger - 0.05f;
		if (!(num < 0.5f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			saberLagerValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger.ToString("f2");
		}
	}

	public void clickSaberLagerAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger + 0.05f;
		if (!((double)num > 2.5))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			saberLagerValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberLarger.ToString("f2");
		}
	}

	public void clickSaberMoveSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove - 0.02f;
		if (!(num < -0.3f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			saberMoveValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove.ToString("f2");
		}
	}

	public void clickSaberMoveAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove + 0.02f;
		if (!((double)num > 0.3))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			saberMoveValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberMove.ToString("f2");
		}
	}

	public void clickYuPanBiLiSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili - 0.05f;
		if (!(num < -0.01f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			yuPanBiLiValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili.ToString("f2");
		}
	}

	public void clickYuPanBiLiAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili + 0.05f;
		if (!(num > 3f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			yuPanBiLiValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili.ToString("f2");
		}
	}

	public void clickFlyDongHuaSub()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua != 0)
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua = 0;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			flyDongHuaValue.text = getFlyDongHuaText();
		}
	}

	public void clickFlyDongHuaAdd()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua != 1)
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua = 1;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			flyDongHuaValue.text = getFlyDongHuaText();
		}
	}

	public void clickSaberFovSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov - 0.5f;
		if (!(num < -30.1f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			saberFovValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov.ToString("f1");
		}
	}

	public void clickSaberFovAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov + 0.5f;
		if (!(num > 30.1f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			saberFovValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov.ToString("f1");
		}
	}
}
public class YuPanTest : MonoBehaviour
{
	public Transform t1;

	public Transform t2;

	public GameObject cube;

	private void Start()
	{
		UnityEngine.Vector3 position = t2.position + (t2.position - t1.position) * 0.1f;
		UnityEngine.Object.Instantiate(cube, position, UnityEngine.Quaternion.Euler(0f, 0f, 0f));
	}

	private void Update()
	{
	}
}
public class audioText : MonoBehaviour
{
	private AudioSource audioSource;

	private float playTime;

	private float pitch;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		playTime = -1f;
		pitch = 0.5f;
	}

	private void Update()
	{
		if (Time.time - playTime > 2f)
		{
			audioSource.pitch = pitch;
			audioSource.Play();
			playTime = Time.time;
			pitch += 0.1f;
			if (pitch > 2f)
			{
				pitch = 0.1f;
			}
		}
	}
}
public class infoMusicFail : MonoBehaviour
{
	public GameObject infoMusicFailText;

	public float showStartTime;

	public float showDurationTime = 1.5f;

	private void Start()
	{
		infoMusicFailText.SetActive(value: false);
		showStartTime = 0f;
	}

	private void Update()
	{
		if (infoMusicFailText.activeInHierarchy && Time.time - showDurationTime > showStartTime)
		{
			infoMusicFailText.SetActive(value: false);
		}
	}

	public void ShowInfoMusicFail()
	{
		infoMusicFailText.SetActive(value: true);
		showStartTime = Time.time;
	}
}
public class BallExploreBsST : BallExploreBase
{
	private ParticleSystem particle;

	private ParticleSystem particleF;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/STexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/STexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/STexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		if (UnityEngine.Vector3.Magnitude(blade.ThisTopDetectPoint - blade.lastTopDetectPoint) < 0.0001f || (double)blade.waveDistancePerSecond < 0.3)
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, ball.transform.position);
		}
		else
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, ball.transform.position);
		}
		UnityEngine.Plane[] planes = new UnityEngine.Plane[1] { plane };
		ball.ball.GetComponent<ShatterTool>().Split(planes, new Ball.BallCollisionInfo(colliderPoint, blade));
		ball.ball.SetActive(value: false);
		ball.GetComponent<BoxCollider>().enabled = false;
		return particle.main.duration;
	}
}
public class RoadColorManager : MonoBehaviour
{
	public Material BanMaXianLeft;

	public Material BanMaXianRight;

	public Material StTiaoLeft;

	public Material StTiaoRight;

	public Material StPlaneLeft;

	public Material StPlaneRight;

	public string key_borderLight;

	public string key_borderGlow;

	public CurveWaveform curveWaveformLeft;

	public CurveWaveform curveWaveformRight;

	private void Start()
	{
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		Color cubeColor2 = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		BanMaXianLeft.SetColor(key_borderLight, cubeColor);
		BanMaXianRight.SetColor(key_borderLight, cubeColor2);
		StTiaoLeft.SetColor(key_borderLight, cubeColor);
		StTiaoRight.SetColor(key_borderLight, cubeColor2);
		StPlaneLeft.SetColor(key_borderGlow, cubeColor);
		StPlaneRight.SetColor(key_borderGlow, cubeColor2);
		curveWaveformLeft.lineAtt.startColor = cubeColor;
		curveWaveformLeft.lineAtt.endColor = cubeColor;
		curveWaveformRight.lineAtt.startColor = cubeColor2;
		curveWaveformRight.lineAtt.endColor = cubeColor2;
	}
}
public class STHitManager : MonoBehaviour
{
	public Animator leftBanMaAni;

	public Animator RightBanMaAni;

	internal void bladeHit(bool isLeft)
	{
		if (isLeft)
		{
			leftBanMaAni.Play("LeftHit", 0, 0f);
		}
		else
		{
			RightBanMaAni.Play("HitRight", 0, 0f);
		}
	}
}
public class BallExploreBs : BallExploreBase
{
	private ParticleSystem particle;

	private ParticleSystem particleF;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
		particleF = ball.transform.Find("effect/explore/GYJZexploreBlackF").GetComponent<ParticleSystem>();
		particleF.transform.position = colliderPoint;
		particleF.Play();
		addExploreForeceFs(particleF, blade, 10f);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
		particleF = ball.transform.Find("effect/explore/GYJZexploreLeftF").GetComponent<ParticleSystem>();
		particleF.transform.position = colliderPoint;
		particleF.Play();
		addExploreForeceFs(particleF, blade, 10f);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
		particleF = ball.transform.Find("effect/explore/GYJZexploreRightF").GetComponent<ParticleSystem>();
		particleF.transform.position = colliderPoint;
		particleF.Play();
		addExploreForeceFs(particleF, blade, 10f);
	}

	internal override float splitAndDistroy()
	{
		if (UnityEngine.Vector3.Magnitude(blade.ThisTopDetectPoint - blade.lastTopDetectPoint) < 0.0001f || (double)blade.waveDistancePerSecond < 0.3)
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, ball.transform.position);
		}
		else
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, ball.transform.position);
		}
		UnityEngine.Plane[] planes = new UnityEngine.Plane[1] { plane };
		ball.ball.GetComponent<ShatterTool>().Split(planes, new Ball.BallCollisionInfo(colliderPoint, blade));
		ball.ball.SetActive(value: false);
		ball.GetComponent<BoxCollider>().enabled = false;
		return particle.main.duration;
	}
}
public class BsCubeEffectColor : MonoBehaviour
{
	public ParticleSystem startLeft;

	public ParticleSystem startRight;

	public ParticleSystem exploreLeftST;

	public ParticleSystem exploreRightST;

	public ParticleSystem exploreLeft;

	public ParticleSystem exploreRight;

	public ParticleSystem exploreLeftF;

	public ParticleSystem exploreRightF;

	public Color leftColor;

	public Color rightColor;

	private void Start()
	{
		leftColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		rightColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		updateColor(startLeft, leftColor);
		updateColor(startRight, rightColor);
		updateColor(exploreLeftST, leftColor);
		updateColor(exploreRightST, rightColor);
		updateColor(exploreLeft, leftColor);
		updateColor(exploreRight, rightColor);
		updateColor(exploreLeftF, leftColor);
		updateColor(exploreRightF, rightColor);
	}

	private void updateColor(ParticleSystem particle, Color color)
	{
		ParticleSystem.MainModule main = particle.main;
		main.startColor = new ParticleSystem.MinMaxGradient(color, color);
	}
}
public class DiZuoColorManager : MonoBehaviour
{
	public Material tiaoMat;

	public Material borderGlowMat;

	public string keyTiaoDai;

	public string keyBorderGlow;

	private void Start()
	{
		Color tiaoDaiLiangColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getTiaoDaiLiangColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		tiaoMat.SetColor(keyTiaoDai, tiaoDaiLiangColor);
		borderGlowMat.SetColor(keyBorderGlow, cubeColor);
	}
}
public class SpinY : MonoBehaviour
{
	public Transform CB;

	public int state;

	public bool rotate;

	public float actionStartTime;

	public float actionDuration;

	public float speed;

	private void Start()
	{
		float x = UnityEngine.Random.Range(25f, 65f);
		CB.localRotation = UnityEngine.Quaternion.Euler(x, 0f, 0f);
		state = 0;
		rotate = false;
		actionStartTime = 0f;
		actionDuration = 0f;
	}

	private void Update()
	{
		if (state == 0)
		{
			RandomSpin();
			state = 1;
		}
		else if (Time.time - actionDuration > actionStartTime)
		{
			state = 0;
		}
		else if (rotate)
		{
			base.transform.Rotate(UnityEngine.Vector3.up * speed);
		}
	}

	private void RandomSpin()
	{
		int num = Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.99f));
		actionStartTime = Time.time;
		actionDuration = UnityEngine.Random.Range(5f, 25f);
		speed = UnityEngine.Random.Range(0.2f, 1.5f);
		if (num < 1)
		{
			speed *= -1f;
		}
		rotate = true;
	}
}
public class ZhuanDongColorManager : MonoBehaviour
{
	public Material leftMat;

	public Material rightMat;

	public string key;

	private void Start()
	{
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		Color cubeColor2 = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		leftMat.SetColor(key, cubeColor);
		rightMat.SetColor(key, cubeColor2);
	}
}
public class OneItemManager : MonoBehaviour
{
	public Animator animator;

	public List<GameObject> lights;

	private void Start()
	{
	}

	private void Update()
	{
	}

	internal void bladeHit(bool isLeft)
	{
		animator.Play("D1", 0, 0f);
	}

	internal void SetLigntActive(bool enable)
	{
		foreach (GameObject light in lights)
		{
			light.SetActive(enable);
		}
	}
}
public class RoundColorChangeManager : MonoBehaviour
{
	public Material TiaoLiang;

	public Material TiaoGlow;

	public Material Sp3;

	public List<OneItemManager> items;

	public string KeyTiaoLiang;

	public string KeyTiaoGlow;

	public string KeySp3;

	private int state;

	private float stateDuringTime;

	private float stateStartTime;

	private void Start()
	{
		ToRightColor();
	}

	private void Update()
	{
		if (!(Time.time < stateStartTime + stateDuringTime))
		{
			switch (getNextState())
			{
			case 1:
				ToLeftColor();
				break;
			case 2:
				ToRightColor();
				break;
			case 3:
				ToDark();
				break;
			default:
				ToRightColor();
				break;
			}
		}
	}

	private int getNextState()
	{
		int num = Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.99f));
		int num2 = state;
		num2 = ((num <= 0) ? (num2 - 1) : (num2 + 1));
		if (num2 == 0)
		{
			num2 = 3;
		}
		if (num2 == 4)
		{
			num2 = 1;
		}
		return num2;
	}

	public void ToLeftColor()
	{
		setEnableAll(enable: true);
		Color tiaoDaiLiangColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getTiaoDaiLiangColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		TiaoLiang.SetColor(KeyTiaoLiang, tiaoDaiLiangColor);
		TiaoGlow.SetColor(KeyTiaoGlow, cubeColor);
		Sp3.SetColor(KeySp3, cubeColor);
		state = 1;
		resetTime();
	}

	public void ToRightColor()
	{
		setEnableAll(enable: true);
		Color tiaoDaiLiangColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getTiaoDaiLiangColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		TiaoLiang.SetColor(KeyTiaoLiang, tiaoDaiLiangColor);
		TiaoGlow.SetColor(KeyTiaoGlow, cubeColor);
		Sp3.SetColor(KeySp3, cubeColor);
		state = 2;
		resetTime();
	}

	public void ToDark()
	{
		setEnableAll(enable: false);
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		Sp3.SetColor(KeySp3, cubeColor);
		state = 3;
		resetTime();
	}

	private void setEnableAll(bool enable)
	{
		foreach (OneItemManager item in items)
		{
			item.SetLigntActive(enable);
		}
	}

	private void resetTime()
	{
		stateStartTime = Time.time;
		stateDuringTime = UnityEngine.Random.Range(25f, 45f);
	}
}
public class RoundHitManager : MonoBehaviour
{
	public List<OneItemManager> items;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void bladeHit(bool isLeft)
	{
		foreach (OneItemManager item in items)
		{
			item.bladeHit(isLeft);
		}
	}
}
public class SiBianManager : MonoBehaviour
{
	public List<GameObject> lightsList;

	public Material LiangMat;

	public Material GlowMat;

	public string KeyLiang;

	public string KeyGlow;

	private float stateDuringTime;

	private float stateStartTime;

	private int state;

	private float targetDegree;

	private float rotateTime = 1f;

	private float rotateSpeed;

	private void Start()
	{
		setLightEnable(enable: false);
		rotateSpeed = 45f;
		resetTime();
		state = 0;
	}

	private void Update()
	{
		if (state == 1)
		{
			rotateSiJiao();
		}
		else if (Time.time > stateStartTime + stateDuringTime)
		{
			resetTime();
			targetDegree = base.transform.rotation.eulerAngles.z + 90f;
			if (targetDegree >= 360f)
			{
				targetDegree = 0f;
			}
			state = 1;
		}
	}

	private void resetTime()
	{
		stateStartTime = Time.time;
		stateDuringTime = UnityEngine.Random.Range(10f, 25f);
	}

	private void rotateSiJiao()
	{
		UnityEngine.Debug.Log("rotate , Time.deltaTime:" + Time.deltaTime);
		UnityEngine.Debug.Log("rotate , rotateSpeed:" + rotateSpeed);
		UnityEngine.Debug.Log("rotate , Time.deltaTime * rotateSpeed:" + Time.deltaTime * rotateSpeed);
		base.transform.Rotate(0f, 0f, Time.deltaTime * rotateSpeed);
		if (EnoughRotate())
		{
			UnityEngine.Vector3 localEulerAngles = new UnityEngine.Vector3(base.transform.localEulerAngles.x, base.transform.localEulerAngles.y, targetDegree);
			base.transform.localEulerAngles = localEulerAngles;
			state = 0;
		}
	}

	private bool EnoughRotate()
	{
		if (targetDegree > 1f)
		{
			return base.transform.localEulerAngles.z >= targetDegree;
		}
		return base.transform.localEulerAngles.z < 90f;
	}

	public void hit(bool isLeft)
	{
		setLightEnable(enable: true);
		Color tiaoDaiLiangColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getTiaoDaiLiangColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		if (isLeft)
		{
			tiaoDaiLiangColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getTiaoDaiLiangColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		}
		LiangMat.SetColor(KeyLiang, tiaoDaiLiangColor);
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		if (isLeft)
		{
			cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		}
		GlowMat.SetColor(KeyGlow, cubeColor);
	}

	private void setLightEnable(bool enable)
	{
		foreach (GameObject lights in lightsList)
		{
			lights.SetActive(enable);
		}
	}
}
public class SphereSpin : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(UnityEngine.Vector3.up * 0.01f);
	}
}
public class BladeTest : MonoBehaviour
{
	public enum BladeType
	{
		Head,
		LeftHand,
		RightHand
	}

	public bool isMoreDetect = true;

	public BladeType bladeType;

	private List<UnityEngine.Vector3> lastPosition;

	public Transform topDetectPoint;

	public Transform endDetectPoint;

	public float lastDeltaTime;

	public UnityEngine.Vector3 lastTopDetectPoint;

	public UnityEngine.Vector3 ThisTopDetectPoint;

	public UnityEngine.Vector3 waveDirection;

	public float waveDistancePerSecond;

	public UnityEngine.Vector3 lastEndDetectPoint;

	public UnityEngine.Vector3 ThisEndDetectPoint;

	public float hengRayTopDisStep = 0.05f;

	private void Start()
	{
		lastPosition = new List<UnityEngine.Vector3>();
		topDetectPoint = base.transform.Find("TopDetectPoint");
		endDetectPoint = base.transform.Find("EndDetectPoint");
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.P))
		{
			base.transform.Rotate(new UnityEngine.Vector3(120f, 0f, 0f));
		}
		if (isMoreDetect)
		{
			if (lastPosition.Count > 0)
			{
				detectByRay();
			}
			updateLastPosition();
		}
		if (topDetectPoint != null)
		{
			lastTopDetectPoint = ThisTopDetectPoint;
			ThisTopDetectPoint = topDetectPoint.position;
			lastEndDetectPoint = ThisEndDetectPoint;
			ThisEndDetectPoint = endDetectPoint.position;
			lastDeltaTime = Time.deltaTime;
			waveDirection = lastTopDetectPoint - ThisTopDetectPoint;
			if (ThisTopDetectPoint == UnityEngine.Vector3.zero || lastTopDetectPoint == UnityEngine.Vector3.zero)
			{
				waveDistancePerSecond = 0f;
			}
			else
			{
				waveDistancePerSecond = waveDirection.magnitude / lastDeltaTime;
			}
			detectByHengRay();
		}
	}

	private void detectByHengRay()
	{
		if (ThisTopDetectPoint.Equals(UnityEngine.Vector3.zero) || ThisEndDetectPoint.Equals(UnityEngine.Vector3.zero) || ThisTopDetectPoint.Equals(UnityEngine.Vector3.zero) || lastTopDetectPoint.Equals(UnityEngine.Vector3.zero))
		{
			return;
		}
		float magnitude = (ThisTopDetectPoint - ThisEndDetectPoint).magnitude;
		float magnitude2 = (ThisTopDetectPoint - lastTopDetectPoint).magnitude;
		if (magnitude2 < hengRayTopDisStep)
		{
			return;
		}
		for (float num = hengRayTopDisStep; num < magnitude2; num += hengRayTopDisStep)
		{
			UnityEngine.Vector3 vector = UnityEngine.Vector3.Lerp(lastEndDetectPoint, ThisEndDetectPoint, num / magnitude2);
			UnityEngine.Vector3 direction = UnityEngine.Vector3.Lerp(lastTopDetectPoint, ThisTopDetectPoint, num / magnitude2) - vector;
			RaycastHit[] array = Physics.RaycastAll(vector, direction, magnitude);
			if (array.Length == 0)
			{
				continue;
			}
			RaycastHit[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit = array2[i];
				if (raycastHit.collider.gameObject.name.Equals("TestCube"))
				{
					UnityEngine.Debug.Log("detectByHengRay:" + raycastHit.collider.gameObject.name);
				}
			}
		}
	}

	public void detectByRay()
	{
		for (int i = 1; i <= 9; i++)
		{
			UnityEngine.Vector3 position = base.transform.Find("MoreDected/point" + i).position;
			for (int j = 0; j < 9; j++)
			{
				UnityEngine.Vector3 vector = lastPosition[j];
				float magnitude = (position - vector).magnitude;
				UnityEngine.Vector3 direction = position - vector;
				RaycastHit[] array = Physics.RaycastAll(vector, direction, magnitude);
				if (array.Length == 0)
				{
					continue;
				}
				RaycastHit[] array2 = array;
				for (int k = 0; k < array2.Length; k++)
				{
					RaycastHit raycastHit = array2[k];
					if (raycastHit.collider.gameObject.name.Equals("TestCube"))
					{
						UnityEngine.Debug.Log("detectByRay:" + raycastHit.collider.gameObject.name + ";index, or:" + (j + 1) + ";target:" + i);
					}
				}
			}
		}
	}

	public void updateLastPosition()
	{
		lastPosition.Clear();
		for (int i = 1; i <= 9; i++)
		{
			lastPosition.Add(base.transform.Find("MoreDected/point" + i).position);
		}
	}

	public void OnCollisionEnter(Collision collision)
	{
		UnityEngine.Debug.Log("OnCollisionEnter:" + collision.gameObject.name);
		if (collision.gameObject.tag.Equals("ball"))
		{
			_ = collision.contacts.LongLength;
		}
	}

	public void OnCollisionStay(Collision collision)
	{
		UnityEngine.Debug.Log("OnCollisionStay:" + collision.gameObject.name);
		if (collision.gameObject.tag.Equals("ball"))
		{
			_ = collision.contacts.LongLength;
		}
	}

	public void OnCollisionExit(Collision collision)
	{
		UnityEngine.Debug.Log("OnCollisionExit:" + collision.gameObject.name);
		if (collision.gameObject.tag.Equals("ball"))
		{
			_ = collision.contacts.LongLength;
		}
	}

	private UnityEngine.Vector3 GetIntersectWithLineAndPlane(UnityEngine.Vector3 top, UnityEngine.Vector3 end)
	{
		UnityEngine.Vector3 vector = top - end;
		UnityEngine.Vector3 rhs = new UnityEngine.Vector3(0f, 1f, 0f);
		return UnityEngine.Vector3.Dot(new UnityEngine.Vector3(0f, 0f, 0f) - top, rhs) / UnityEngine.Vector3.Dot(vector.normalized, rhs) * vector.normalized + top;
	}
}
public class BladeColorManager : MonoBehaviour
{
	public MeshRenderer saber;

	public MeshRenderer HL1;

	public MeshRenderer HL2;

	public MeleeWeaponTrail meleeWeaponTrail;

	public bool isLeftBlade;

	public string saberKey;

	public string HLKey;

	public string MeleeWeaponTrailKey;

	private void Start()
	{
		if (GetComponent<Blade>().LengthAdj)
		{
			saber = base.transform.Find("LengthAdj/AdjBlade/Blade").GetComponent<MeshRenderer>();
			HL1 = base.transform.Find("LengthAdj/HandleLights/1").GetComponent<MeshRenderer>();
			HL2 = base.transform.Find("LengthAdj/HandleLights/2").GetComponent<MeshRenderer>();
			meleeWeaponTrail = base.transform.Find("LengthAdj/AdjBlade/Blade/BladeTrail").GetComponent<MeleeWeaponTrail>();
		}
		int colorIndex = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor;
		if (isLeftBlade)
		{
			colorIndex = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor;
		}
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(colorIndex);
		saber.material.SetColor(saberKey, cubeColor);
		HL1.material.SetColor(HLKey, cubeColor);
		HL2.material.SetColor(HLKey, cubeColor);
		meleeWeaponTrail._material.SetColor(MeleeWeaponTrailKey, cubeColor);
	}
}
public class ColorDynamicManager
{
	private Dictionary<int, Color> cubeColorDic;

	private Dictionary<int, Color> diLieAnColorDic;

	private Dictionary<int, Color> tiaoLiangColorDic;

	public void init()
	{
		cubeColorDic = new Dictionary<int, Color>();
		cubeColorDic.Add(0, GetColorByHex("D10810"));
		cubeColorDic.Add(1, GetColorByHex("D17C08"));
		cubeColorDic.Add(2, GetColorByHex("D1BE08"));
		cubeColorDic.Add(3, GetColorByHex("09D108"));
		cubeColorDic.Add(4, GetColorByHex("00E9D3"));
		cubeColorDic.Add(5, GetColorByHex("088CD1"));
		cubeColorDic.Add(6, GetColorByHex("7F08D1"));
		cubeColorDic.Add(7, GetColorByHex("FF00BB"));
		diLieAnColorDic = new Dictionary<int, Color>();
		diLieAnColorDic.Add(0, GetColorByHex("A40A01"));
		diLieAnColorDic.Add(1, GetColorByHex("A46A01"));
		diLieAnColorDic.Add(2, GetColorByHex("A49C01"));
		diLieAnColorDic.Add(3, GetColorByHex("04A401"));
		diLieAnColorDic.Add(4, GetColorByHex("00E9D3"));
		diLieAnColorDic.Add(5, GetColorByHex("0055C3"));
		diLieAnColorDic.Add(6, GetColorByHex("9F01A4"));
		diLieAnColorDic.Add(7, GetColorByHex("FF00BB"));
		tiaoLiangColorDic = new Dictionary<int, Color>();
		tiaoLiangColorDic.Add(0, GetColorByHex("A97272"));
		tiaoLiangColorDic.Add(1, GetColorByHex("A99472"));
		tiaoLiangColorDic.Add(2, GetColorByHex("A9A972"));
		tiaoLiangColorDic.Add(3, GetColorByHex("7AA972"));
		tiaoLiangColorDic.Add(4, GetColorByHex("00E9D3"));
		tiaoLiangColorDic.Add(5, GetColorByHex("728FA9"));
		tiaoLiangColorDic.Add(6, GetColorByHex("A972A9"));
		tiaoLiangColorDic.Add(7, GetColorByHex("FF00BB"));
	}

	internal Color getCubeColor(GeneratorLaw.BallType ballType)
	{
		if (ballType == GeneratorLaw.BallType.BlackBall)
		{
			return Color.black;
		}
		int colorIndex = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor;
		if (ballType == GeneratorLaw.BallType.RightBall)
		{
			colorIndex = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor;
		}
		return getCubeColor(colorIndex);
	}

	public Color getCubeColor(int colorIndex)
	{
		Color value = Color.black;
		cubeColorDic.TryGetValue(colorIndex, out value);
		return value;
	}

	public Color getDiLieAnColor(int colorIndex)
	{
		Color value = Color.black;
		diLieAnColorDic.TryGetValue(colorIndex, out value);
		return value;
	}

	public Color getTiaoDaiLiangColor(int colorIndex)
	{
		Color value = Color.black;
		tiaoLiangColorDic.TryGetValue(colorIndex, out value);
		return value;
	}

	public static Color GetColorByHex(string hex)
	{
		Color color = Color.white;
		ColorUtility.TryParseHtmlString("#" + hex, out color);
		return color;
	}
}
public class BsSettingManager : MonoBehaviour
{
	public Button hitDisSubBtn;

	public TMP_Text hitDisValue;

	public Button hitDisAddBtn;

	public Button cubeHeightSubBtn;

	public TMP_Text cubeHeightValue;

	public Button cubeHeightAddBtn;

	public Button bsSpeedAdjustSubBtn;

	public TMP_Text bsSpeedAdjustValue;

	public Button bsSpeedAdjustAddBtn;

	private void Awake()
	{
		AudioSourceCommon.AttachPointEnterAudio(hitDisSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(hitDisAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(cubeHeightSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(cubeHeightAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(bsSpeedAdjustSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(bsSpeedAdjustAddBtn.transform);
	}

	private void Start()
	{
		hitDisValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis.ToString("f1");
		cubeHeightValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight.ToString("f2");
		bsSpeedAdjustValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust.ToString("f1");
	}

	public void clickHitDisSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis - 0.1f;
		if (!(num < 0f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			hitDisValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis.ToString("f1");
		}
	}

	public void clickHitDisAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis + 0.1f;
		if (!(num > 3f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			hitDisValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis.ToString("f1");
		}
	}

	public void clickCubeHeightSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight - 0.02f;
		if (!((double)num < 0.2))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			cubeHeightValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight.ToString("f2");
		}
	}

	public void clickCubeHeightAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight + 0.02f;
		if (!((double)num > 1.4))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			cubeHeightValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight.ToString("f2");
		}
	}

	public void clickBsSpeedAdjustSub()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust - 0.5f;
		if (!(num < -5f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			bsSpeedAdjustValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust.ToString("f1");
		}
	}

	public void clickBsSpeedAdjustAdd()
	{
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust + 0.5f;
		if (!(num > 15f))
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust = num;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			bsSpeedAdjustValue.text = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust.ToString("f1");
		}
	}
}
public class ColorSettingManager : MonoBehaviour
{
	public Button leftColorSubBtn;

	public TMP_Text leftColorValue;

	public Button leftColorAddBtn;

	public Button rightColorSubBtn;

	public TMP_Text rightColorValue;

	public Button rightColorAddBtn;

	public Button blockColorSubBtn;

	public TMP_Text blockColorValue;

	public Button blockColorAddBtn;

	private void Awake()
	{
		AudioSourceCommon.AttachPointEnterAudio(leftColorSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(leftColorAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(rightColorSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(rightColorAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(blockColorSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(blockColorAddBtn.transform);
	}

	private void Start()
	{
		setColorText(leftColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		setColorText(rightColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		setColorText(blockColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor);
	}

	private void setColorText(TMP_Text colorValue, int colorIndex)
	{
		colorValue.text = getColorTextByIndex(colorIndex);
	}

	private string getColorTextByIndex(int index)
	{
		return index switch
		{
			0 => "红", 
			1 => "橙", 
			2 => "黄", 
			3 => "绿", 
			4 => "青", 
			5 => "蓝", 
			6 => "紫", 
			7 => "洋红", 
			_ => "红", 
		};
	}

	private int getNewColorIndex(bool next, int origin, int skip)
	{
		int num = origin - 1;
		if (next)
		{
			num = origin + 1;
		}
		if (num == -1)
		{
			num = 7;
		}
		if (num == 8)
		{
			num = 0;
		}
		if (num == skip)
		{
			return getNewColorIndex(next, num, skip);
		}
		return num;
	}

	public void clickLeftColorSub()
	{
		int newColorIndex = getNewColorIndex(next: false, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor = newColorIndex;
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
		setColorText(leftColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
	}

	public void clickLeftColorAdd()
	{
		int newColorIndex = getNewColorIndex(next: true, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor = newColorIndex;
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
		setColorText(leftColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
	}

	public void clickRightColorSub()
	{
		int newColorIndex = getNewColorIndex(next: false, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor = newColorIndex;
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
		setColorText(rightColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
	}

	public void clickRightColorAdd()
	{
		int newColorIndex = getNewColorIndex(next: true, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor = newColorIndex;
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
		setColorText(rightColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
	}

	public void clickBlockColorSub()
	{
		int newColorIndex = getNewColorIndex(next: false, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor, -10);
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor = newColorIndex;
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
		setColorText(blockColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor);
	}

	public void clickBlockColorAdd()
	{
		int newColorIndex = getNewColorIndex(next: true, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor, -10);
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor = newColorIndex;
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
		setColorText(blockColorValue, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor);
	}
}
public class Test : MonoBehaviour
{
	private void Start()
	{
		DynamicGI.UpdateEnvironment();
	}
}
public class ExampleWheelController : MonoBehaviour
{
	private static class Uniforms
	{
		internal static readonly int _MotionAmount = Shader.PropertyToID("_MotionAmount");
	}

	public float acceleration;

	public Renderer motionVectorRenderer;

	private Rigidbody m_Rigidbody;

	private void Start()
	{
		m_Rigidbody = GetComponent<Rigidbody>();
		m_Rigidbody.maxAngularVelocity = 100f;
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.UpArrow))
		{
			m_Rigidbody.AddRelativeTorque(new UnityEngine.Vector3(-1f * acceleration, 0f, 0f), ForceMode.Acceleration);
		}
		else if (Input.GetKey(KeyCode.DownArrow))
		{
			m_Rigidbody.AddRelativeTorque(new UnityEngine.Vector3(1f * acceleration, 0f, 0f), ForceMode.Acceleration);
		}
		float value = (0f - m_Rigidbody.angularVelocity.x) / 100f;
		if ((bool)motionVectorRenderer)
		{
			motionVectorRenderer.material.SetFloat(Uniforms._MotionAmount, Mathf.Clamp(value, -0.25f, 0.25f));
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(LineRenderer))]
public class LineWave : MonoBehaviour
{
	public enum Origins
	{
		Start,
		Middle
	}

	private float ampT;

	public Material traceMaterial;

	public float traceWidth = 0.3f;

	public GameObject targetOptional;

	public float altRotation;

	public Origins origin;

	public int size = 300;

	public float lengh = 10f;

	public float freq = 2.5f;

	public float amp = 1f;

	public bool ampByFreq;

	public bool centered = true;

	public bool centCrest = true;

	public bool warp = true;

	public bool warpInvert;

	public float warpRandom;

	public float walkManual;

	public float walkAuto;

	public bool spiral;

	private float start;

	private float warpT;

	private float angle;

	private float sinAngle;

	private float sinAngleZ;

	private double walkShift;

	private UnityEngine.Vector3 posVtx2;

	private UnityEngine.Vector3 posVtxSizeMinusOne;

	private LineRenderer lrComp;

	private void Awake()
	{
		lrComp = GetComponent<LineRenderer>();
		lrComp.useWorldSpace = false;
		lrComp.material = traceMaterial;
	}

	private void Update()
	{
		lrComp.SetWidth(traceWidth, traceWidth);
		if (targetOptional != null)
		{
			origin = Origins.Start;
			lengh = (base.transform.position - targetOptional.transform.position).magnitude;
			base.transform.LookAt(targetOptional.transform.position);
			base.transform.Rotate(altRotation, -90f, 0f);
		}
		if (warpRandom <= 0f)
		{
			warpRandom = 0f;
		}
		if (size <= 2)
		{
			size = 2;
		}
		lrComp.SetVertexCount(size);
		if (ampByFreq)
		{
			ampT = Mathf.Sin(freq * (float)Math.PI);
		}
		else
		{
			ampT = 1f;
		}
		ampT *= amp;
		if (warp && warpInvert)
		{
			ampT /= 2f;
		}
		for (int i = 0; i < size; i++)
		{
			angle = (float)Math.PI * 2f / (float)size * (float)i * freq;
			if (centered)
			{
				angle -= freq * (float)Math.PI;
				if (centCrest)
				{
					angle -= (float)Math.PI / 2f;
				}
			}
			else
			{
				centCrest = false;
			}
			walkShift -= walkAuto / (float)size * Time.deltaTime;
			angle += (float)walkShift - walkManual;
			sinAngle = Mathf.Sin(angle);
			if (spiral)
			{
				sinAngleZ = Mathf.Cos(angle);
			}
			else
			{
				sinAngleZ = 0f;
			}
			if (origin == Origins.Start)
			{
				start = 0f;
			}
			else
			{
				start = lengh / 2f;
			}
			if (warp)
			{
				warpT = size - i;
				warpT /= size;
				warpT = Mathf.Sin((float)Math.PI * warpT * (warpRandom + 1f));
				if (warpInvert)
				{
					warpT = 1f / warpT;
				}
				lrComp.SetPosition(i, new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT * warpT, sinAngleZ * ampT * warpT));
			}
			else
			{
				lrComp.SetPosition(i, new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT, sinAngleZ * ampT));
				warpInvert = false;
			}
			if (i == 1)
			{
				posVtx2 = new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT * warpT, sinAngleZ * ampT * warpT);
			}
			if (i == size - 1)
			{
				posVtxSizeMinusOne = new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT * warpT, sinAngleZ * ampT * warpT);
			}
		}
		if (warpInvert)
		{
			lrComp.SetPosition(0, posVtx2);
			lrComp.SetPosition(size - 1, posVtxSizeMinusOne);
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class LineWaveCollider : MonoBehaviour
{
	public enum Origins
	{
		Start,
		Middle
	}

	public enum WaveColliders
	{
		Box,
		Sphere
	}

	private float ampT;

	public Material traceMaterial;

	public float traceWidth = 0.3f;

	public GameObject targetOptional;

	public float altRotation;

	public Origins origin;

	public int size = 300;

	public float lengh = 10f;

	public float freq = 2.5f;

	public float amp = 1f;

	public bool ampByFreq;

	public bool centered = true;

	public bool centCrest = true;

	public bool warp = true;

	public bool warpInvert;

	public float warpRandom;

	public float walkManual;

	public float walkAuto;

	public bool spiral;

	private float start;

	private float warpT;

	private float angle;

	private float sinAngle;

	private float sinAngleZ;

	private double walkShift;

	private UnityEngine.Vector3 posVtx2;

	private UnityEngine.Vector3 posVtxSizeMinusOne;

	private LineRenderer lrComp;

	private List<UnityEngine.Vector3> linePositions;

	public WaveColliders waveCollider;

	private List<GameObject> colliders;

	private GameObject Colliders;

	private GameObject colliderGO;

	private Type colType;

	public float colliderSize = 0.2f;

	public int collidersGap = 5;

	private void Awake()
	{
		lrComp = GetComponent<LineRenderer>();
		lrComp.useWorldSpace = false;
		lrComp.material = traceMaterial;
		linePositions = new List<UnityEngine.Vector3>();
		colliders = new List<GameObject>();
		Colliders = new GameObject("Colliders");
		Colliders.transform.parent = base.transform;
		colliderGO = new GameObject("col");
		colliderGO.transform.position = base.transform.position;
		colliderGO.transform.parent = Colliders.transform;
	}

	private void Update()
	{
		lrComp.SetWidth(traceWidth, traceWidth);
		base.gameObject.transform.localScale = UnityEngine.Vector3.one;
		if (targetOptional != null)
		{
			origin = Origins.Start;
			lengh = (base.transform.position - targetOptional.transform.position).magnitude;
			base.transform.LookAt(targetOptional.transform.position);
			base.transform.Rotate(altRotation, -90f, 0f);
		}
		if (warpRandom <= 0f)
		{
			warpRandom = 0f;
		}
		if (size <= 2)
		{
			size = 2;
		}
		lrComp.SetVertexCount(size);
		if (ampByFreq)
		{
			ampT = Mathf.Sin(freq * (float)Math.PI);
		}
		else
		{
			ampT = 1f;
		}
		ampT *= amp;
		if (warp && warpInvert)
		{
			ampT /= 2f;
		}
		foreach (GameObject collider in colliders)
		{
			UnityEngine.Object.Destroy(collider);
		}
		linePositions.Clear();
		colliders.Clear();
		for (int i = 0; i < size; i++)
		{
			angle = (float)Math.PI * 2f / (float)size * (float)i * freq;
			if (centered)
			{
				angle -= freq * (float)Math.PI;
				if (centCrest)
				{
					angle -= (float)Math.PI / 2f;
				}
			}
			else
			{
				centCrest = false;
			}
			walkShift -= walkAuto / (float)size * Time.deltaTime;
			angle += (float)walkShift - walkManual;
			sinAngle = Mathf.Sin(angle);
			if (spiral)
			{
				sinAngleZ = Mathf.Cos(angle);
			}
			else
			{
				sinAngleZ = 0f;
			}
			if (origin == Origins.Start)
			{
				start = 0f;
			}
			else
			{
				start = lengh / 2f;
			}
			if (warp)
			{
				warpT = size - i;
				warpT /= size;
				warpT = Mathf.Sin((float)Math.PI * warpT * (warpRandom + 1f));
				if (warpInvert)
				{
					warpT = 1f / warpT;
				}
				linePositions.Add(new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT * warpT, sinAngleZ * ampT * warpT));
			}
			else
			{
				linePositions.Add(new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT, sinAngleZ * ampT));
				warpInvert = false;
			}
			if (i == 1)
			{
				posVtx2 = new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT * warpT, sinAngleZ * ampT * warpT);
			}
			if (i == size - 1)
			{
				posVtxSizeMinusOne = new UnityEngine.Vector3(lengh / (float)size * (float)i - start, sinAngle * ampT * warpT, sinAngleZ * ampT * warpT);
			}
		}
		switch (waveCollider)
		{
		case WaveColliders.Box:
			colType = typeof(BoxCollider);
			break;
		case WaveColliders.Sphere:
			colType = typeof(SphereCollider);
			break;
		}
		if (colliderGO.GetComponent(colType) == null)
		{
			UnityEngine.Object.Destroy(colliderGO.GetComponent(typeof(Collider)));
			colliderGO.AddComponent(colType);
		}
		colliderGO.SetActive(value: true);
		colliderGO.transform.localScale = new UnityEngine.Vector3(colliderSize, colliderSize, colliderSize);
		collidersGap = Mathf.Clamp(collidersGap, 1, 20);
		for (int j = 0; j < linePositions.Count; j++)
		{
			lrComp.SetPosition(j, linePositions[j]);
			if (j % collidersGap == 0)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(colliderGO);
				gameObject.transform.parent = Colliders.transform;
				if ((bool)targetOptional)
				{
					gameObject.transform.position = UnityEngine.Vector3.Lerp(base.gameObject.transform.position, targetOptional.transform.position, (float)j / (float)linePositions.Count);
					gameObject.transform.Translate(0f, linePositions[j].y, linePositions[j].z, base.gameObject.transform);
				}
				else
				{
					gameObject.transform.position = base.gameObject.transform.position;
					gameObject.transform.Translate(linePositions[j].x, linePositions[j].y, linePositions[j].z, base.gameObject.transform);
				}
				gameObject.transform.rotation = base.gameObject.transform.rotation;
				colliders.Add(gameObject);
			}
		}
		colliderGO.SetActive(value: false);
		if (warpInvert)
		{
			lrComp.SetPosition(0, posVtx2);
			lrComp.SetPosition(size - 1, posVtxSizeMinusOne);
		}
	}
}
public class guiE3 : MonoBehaviour
{
	public GameObject waveSphere;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		waveSphere.GetComponent<LineWaveCollider>().walkAuto = GUI.HorizontalSlider(new Rect((float)Screen.width * 0.4f, Screen.height - 20, (float)Screen.width * 0.2f, 10f), waveSphere.GetComponent<LineWaveCollider>().walkAuto, -7f, 7f);
	}
}
public class guiMenu : MonoBehaviour
{
	public GameObject sphere1;

	public GameObject sphere2;

	public GameObject sphere3;

	public GameObject cam;

	public GUIStyle tgStyle;

	private GameObject activeSphere;

	private float guiWidth = 200f;

	private float guiHeight = 150f;

	private string[] tbContent = new string[3] { "Red", "Green", "Blue" };

	private int tgInt;

	private void OnGUI()
	{
		tgInt = GUI.Toolbar(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 20f, guiWidth - 30f, 30f), tgInt, tbContent);
		switch (tgInt)
		{
		case 0:
			sphere1.GetComponent<LineWave>().freq = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 40f, (float)Screen.height - guiHeight + 65f, guiWidth - 70f, 20f), sphere1.GetComponent<LineWave>().freq, 0f, 20f);
			sphere1.GetComponent<LineWave>().warpRandom = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 30f, (float)Screen.height - guiHeight + 85f, guiWidth - 60f, 20f), sphere1.GetComponent<LineWave>().warpRandom, 0f, 20f);
			sphere1.GetComponent<LineWave>().walkAuto = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 50f, (float)Screen.height - guiHeight + 105f, guiWidth - 80f, 20f), sphere1.GetComponent<LineWave>().walkAuto, -80f, 80f);
			sphere1.GetComponent<LineWave>().amp = GUI.VerticalSlider(new Rect(Screen.width - 20, (float)Screen.height - guiHeight + 20f, 20f, guiHeight - 30f), sphere1.GetComponent<LineWave>().amp, 15f, 0f);
			sphere1.GetComponent<LineWave>().spiral = GUI.Toggle(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 120f, guiWidth / 3f, 20f), sphere1.GetComponent<LineWave>().spiral, "Spiral");
			activeSphere = sphere1;
			break;
		case 1:
			sphere2.GetComponent<LineWave>().freq = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 40f, (float)Screen.height - guiHeight + 65f, guiWidth - 70f, 20f), sphere2.GetComponent<LineWave>().freq, 0f, 20f);
			sphere2.GetComponent<LineWave>().warpRandom = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 30f, (float)Screen.height - guiHeight + 85f, guiWidth - 60f, 20f), sphere2.GetComponent<LineWave>().warpRandom, 0f, 20f);
			sphere2.GetComponent<LineWave>().walkAuto = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 50f, (float)Screen.height - guiHeight + 105f, guiWidth - 80f, 20f), sphere2.GetComponent<LineWave>().walkAuto, -80f, 80f);
			sphere2.GetComponent<LineWave>().amp = GUI.VerticalSlider(new Rect(Screen.width - 20, (float)Screen.height - guiHeight + 20f, 20f, guiHeight - 30f), sphere2.GetComponent<LineWave>().amp, 15f, 0f);
			sphere2.GetComponent<LineWave>().spiral = GUI.Toggle(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 120f, guiWidth / 3f, 20f), sphere2.GetComponent<LineWave>().spiral, "Spiral");
			activeSphere = sphere2;
			break;
		case 2:
			sphere3.GetComponent<LineWave>().freq = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 40f, (float)Screen.height - guiHeight + 65f, guiWidth - 70f, 20f), sphere3.GetComponent<LineWave>().freq, 0f, 20f);
			sphere3.GetComponent<LineWave>().warpRandom = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 30f, (float)Screen.height - guiHeight + 85f, guiWidth - 60f, 20f), sphere3.GetComponent<LineWave>().warpRandom, 0f, 20f);
			sphere3.GetComponent<LineWave>().walkAuto = GUI.HorizontalSlider(new Rect((float)Screen.width - guiWidth + 50f, (float)Screen.height - guiHeight + 105f, guiWidth - 80f, 20f), sphere3.GetComponent<LineWave>().walkAuto, -80f, 80f);
			sphere3.GetComponent<LineWave>().amp = GUI.VerticalSlider(new Rect(Screen.width - 20, (float)Screen.height - guiHeight + 20f, 20f, guiHeight - 30f), sphere3.GetComponent<LineWave>().amp, 15f, 0f);
			sphere3.GetComponent<LineWave>().spiral = GUI.Toggle(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 120f, guiWidth / 3f, 20f), sphere3.GetComponent<LineWave>().spiral, "Spiral");
			activeSphere = sphere3;
			break;
		}
		GUI.Label(new Rect((float)Screen.width * 0.44f, Screen.height - 35, 150f, 20f), "  Mouse1: CamOrbit");
		GUI.Label(new Rect((float)Screen.width * 0.44f, Screen.height - 20, 150f, 20f), "Mouse2: MoveSpheres");
		GUI.Label(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 60f, 50f, 20f), "Freq.");
		GUI.Label(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 60f, 50f, 20f), "Freq.");
		GUI.Label(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 80f, 50f, 20f), "Var.");
		GUI.Label(new Rect((float)Screen.width - guiWidth, (float)Screen.height - guiHeight + 100f, 50f, 20f), "Speed.");
		GUI.Label(new Rect((float)Screen.width - guiWidth + 140f, (float)Screen.height - guiHeight + 120f, 50f, 20f), "Amp.");
	}

	private void Update()
	{
		if (Input.GetMouseButton(1))
		{
			activeSphere.transform.Translate(Input.GetAxis("Mouse X") / 2f, Input.GetAxis("Mouse Y") / 2f, 0f, cam.transform);
		}
	}
}
public class meanPos : MonoBehaviour
{
	public GameObject[] objects;

	private UnityEngine.Vector3 posSum;

	private void Update()
	{
		posSum = UnityEngine.Vector3.zero;
		GameObject[] array = objects;
		foreach (GameObject gameObject in array)
		{
			posSum += gameObject.transform.position;
		}
		base.transform.position = posSum / objects.Length;
	}
}
public class LightFlicker : MonoBehaviour
{
	public bool flicker = true;

	public float flickerIntensity = 0.5f;

	private float baseIntensity;

	private Light lightComp;

	private void Awake()
	{
		lightComp = base.gameObject.GetComponent<Light>();
		baseIntensity = lightComp.intensity;
	}

	private void Update()
	{
		if (flicker)
		{
			float t = Mathf.PerlinNoise(UnityEngine.Random.Range(0f, 1000f), Time.time);
			lightComp.intensity = Mathf.Lerp(baseIntensity - flickerIntensity, baseIntensity, t);
		}
	}
}
public class MagicLoadSceneOnClick : MonoBehaviour
{
	public void LoadSceneProjectiles()
	{
		SceneManager.LoadScene("magic_projectiles");
	}

	public void LoadSceneSprays()
	{
		SceneManager.LoadScene("magic_sprays");
	}

	public void LoadSceneAura()
	{
		SceneManager.LoadScene("magic_aura");
	}

	public void LoadSceneModular()
	{
		SceneManager.LoadScene("magic_modular");
	}

	public void LoadSceneShields2()
	{
		SceneManager.LoadScene("magic_domes");
	}

	public void LoadSceneShields()
	{
		SceneManager.LoadScene("magic_shields");
	}

	public void LoadSceneSphereBlast()
	{
		SceneManager.LoadScene("magic_sphereblast");
	}

	public void LoadSceneEnchant()
	{
		SceneManager.LoadScene("magic_enchant");
	}

	public void LoadSceneSlash()
	{
		SceneManager.LoadScene("magic_slash");
	}

	public void LoadSceneCharge()
	{
		SceneManager.LoadScene("magic_charge");
	}

	public void LoadSceneCleave()
	{
		SceneManager.LoadScene("magic_cleave");
	}

	public void LoadSceneAura2()
	{
		SceneManager.LoadScene("magic_aura2");
	}

	public void LoadSceneWalls()
	{
		SceneManager.LoadScene("magic_walls");
	}

	public void LoadSceneBeams()
	{
		SceneManager.LoadScene("magic_beams");
	}

	public void LoadSceneMeshGlow()
	{
		SceneManager.LoadScene("magic_meshglow");
	}

	public void LoadScenePillarBlast()
	{
		SceneManager.LoadScene("magic_pillarblast");
	}
}
public class MagicProjectileScript : MonoBehaviour
{
	public GameObject impactParticle;

	public GameObject projectileParticle;

	public GameObject muzzleParticle;

	public GameObject[] trailParticles;

	[HideInInspector]
	public UnityEngine.Vector3 impactNormal;

	private bool hasCollided;

	private void Start()
	{
		projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
		projectileParticle.transform.parent = base.transform;
		if ((bool)muzzleParticle)
		{
			muzzleParticle = UnityEngine.Object.Instantiate(muzzleParticle, base.transform.position, base.transform.rotation);
			UnityEngine.Object.Destroy(muzzleParticle, 1.5f);
		}
	}

	private void OnCollisionEnter(Collision hit)
	{
		if (hasCollided)
		{
			return;
		}
		hasCollided = true;
		impactParticle = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3.up, impactNormal));
		if (hit.gameObject.tag == "Destructible")
		{
			UnityEngine.Object.Destroy(hit.gameObject);
		}
		GameObject[] array = trailParticles;
		foreach (GameObject gameObject in array)
		{
			GameObject obj = base.transform.Find(projectileParticle.name + "/" + gameObject.name).gameObject;
			obj.transform.parent = null;
			UnityEngine.Object.Destroy(obj, 3f);
		}
		UnityEngine.Object.Destroy(projectileParticle, 3f);
		UnityEngine.Object.Destroy(impactParticle, 5f);
		UnityEngine.Object.Destroy(base.gameObject);
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		for (int j = 1; j < componentsInChildren.Length; j++)
		{
			ParticleSystem particleSystem = componentsInChildren[j];
			if (particleSystem.gameObject.name.Contains("Trail"))
			{
				particleSystem.transform.SetParent(null);
				UnityEngine.Object.Destroy(particleSystem.gameObject, 2f);
			}
		}
	}
}
public class MagicBeamScript : MonoBehaviour
{
	[Header("Prefabs")]
	public GameObject[] beamLineRendererPrefab;

	public GameObject[] beamStartPrefab;

	public GameObject[] beamEndPrefab;

	private int currentBeam;

	private GameObject beamStart;

	private GameObject beamEnd;

	private GameObject beam;

	private LineRenderer line;

	[Header("Adjustable Variables")]
	public float beamEndOffset = 1f;

	public float textureScrollSpeed = 8f;

	public float textureLengthScale = 3f;

	[Header("Put Sliders here (Optional)")]
	public Slider endOffSetSlider;

	public Slider scrollSpeedSlider;

	[Header("Put UI Text object here to show beam name")]
	public Text textBeamName;

	private void Start()
	{
		if ((bool)textBeamName)
		{
			textBeamName.text = beamLineRendererPrefab[currentBeam].name;
		}
		if ((bool)endOffSetSlider)
		{
			endOffSetSlider.value = beamEndOffset;
		}
		if ((bool)scrollSpeedSlider)
		{
			scrollSpeedSlider.value = textureScrollSpeed;
		}
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
		if (Input.GetMouseButtonDown(0))
		{
			beamStart = UnityEngine.Object.Instantiate(beamStartPrefab[currentBeam], new UnityEngine.Vector3(0f, 0f, 0f), UnityEngine.Quaternion.identity);
			beamEnd = UnityEngine.Object.Instantiate(beamEndPrefab[currentBeam], new UnityEngine.Vector3(0f, 0f, 0f), UnityEngine.Quaternion.identity);
			beam = UnityEngine.Object.Instantiate(beamLineRendererPrefab[currentBeam], new UnityEngine.Vector3(0f, 0f, 0f), UnityEngine.Quaternion.identity);
			line = beam.GetComponent<LineRenderer>();
		}
		if (Input.GetMouseButtonUp(0))
		{
			UnityEngine.Object.Destroy(beamStart);
			UnityEngine.Object.Destroy(beamEnd);
			UnityEngine.Object.Destroy(beam);
		}
		if (Input.GetMouseButton(0))
		{
			Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray.origin, ray.direction, out var hitInfo))
			{
				UnityEngine.Vector3 dir = hitInfo.point - base.transform.position;
				ShootBeamInDir(base.transform.position, dir);
			}
		}
		if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			nextBeam();
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			nextBeam();
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			previousBeam();
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			previousBeam();
		}
	}

	public void nextBeam()
	{
		if (currentBeam < beamLineRendererPrefab.Length - 1)
		{
			currentBeam++;
		}
		else
		{
			currentBeam = 0;
		}
		if ((bool)textBeamName)
		{
			textBeamName.text = beamLineRendererPrefab[currentBeam].name;
		}
	}

	public void previousBeam()
	{
		if (currentBeam > 0)
		{
			currentBeam--;
		}
		else
		{
			currentBeam = beamLineRendererPrefab.Length - 1;
		}
		if ((bool)textBeamName)
		{
			textBeamName.text = beamLineRendererPrefab[currentBeam].name;
		}
	}

	public void UpdateEndOffset()
	{
		beamEndOffset = endOffSetSlider.value;
	}

	public void UpdateScrollSpeed()
	{
		textureScrollSpeed = scrollSpeedSlider.value;
	}

	private void ShootBeamInDir(UnityEngine.Vector3 start, UnityEngine.Vector3 dir)
	{
		line.positionCount = 2;
		line.SetPosition(0, start);
		beamStart.transform.position = start;
		UnityEngine.Vector3 zero = UnityEngine.Vector3.zero;
		zero = ((!Physics.Raycast(start, dir, out var hitInfo)) ? (base.transform.position + dir * 100f) : (hitInfo.point - dir.normalized * beamEndOffset));
		beamEnd.transform.position = zero;
		line.SetPosition(1, zero);
		beamStart.transform.LookAt(beamEnd.transform.position);
		beamEnd.transform.LookAt(beamStart.transform.position);
		float num = UnityEngine.Vector3.Distance(start, zero);
		line.sharedMaterial.mainTextureScale = new UnityEngine.Vector2(num / textureLengthScale, 1f);
		line.sharedMaterial.mainTextureOffset -= new UnityEngine.Vector2(Time.deltaTime * textureScrollSpeed, 0f);
	}
}
public class LookAtTarget : MonoBehaviour
{
	[SerializeField]
	private Transform _target;

	[SerializeField]
	private float _speed = 0.5f;

	private UnityEngine.Vector3 _lookAtTarget;

	private void Update()
	{
		_lookAtTarget = UnityEngine.Vector3.Lerp(_lookAtTarget, _target.position, Time.deltaTime * _speed);
		base.transform.LookAt(_lookAtTarget);
	}
}
public class MouseMove : MonoBehaviour
{
	[SerializeField]
	private float _sensitivity = 0.5f;

	private UnityEngine.Vector3 _originalPos;

	private void Start()
	{
		_originalPos = base.transform.position;
	}

	private void Update()
	{
		UnityEngine.Vector3 mousePosition = Input.mousePosition;
		mousePosition.x /= Screen.width;
		mousePosition.y /= Screen.height;
		mousePosition.x -= 0.5f;
		mousePosition.y -= 0.5f;
		mousePosition *= 2f * _sensitivity;
		base.transform.position = _originalPos + mousePosition;
	}
}
public class SwooshTest : MonoBehaviour
{
	[SerializeField]
	private AnimationClip _animation;

	private AnimationState _animationState;

	[SerializeField]
	private int _start;

	[SerializeField]
	private int _end;

	private float _startN;

	private float _endN;

	private float _time;

	private float _prevTime;

	private float _prevAnimTime;

	[SerializeField]
	private MeleeWeaponTrail _trail;

	private bool _firstFrame = true;

	private void Start()
	{
		float num = _animation.frameRate * _animation.length;
		_startN = (float)_start / num;
		_endN = (float)_end / num;
		_animationState = GetComponent<Animation>()[_animation.name];
		_trail.Emit = false;
	}

	private void Update()
	{
		_time += _animationState.normalizedTime - _prevAnimTime;
		if (_time > 1f || _firstFrame)
		{
			if (!_firstFrame)
			{
				_time -= 1f;
			}
			_firstFrame = false;
		}
		if (_prevTime < _startN && _time >= _startN)
		{
			_trail.Emit = true;
		}
		else if (_prevTime < _endN && _time >= _endN)
		{
			_trail.Emit = false;
		}
		_prevTime = _time;
		_prevAnimTime = _animationState.normalizedTime;
	}
}
public class Interpolate
{
	public enum EaseType
	{
		Linear,
		EaseInQuad,
		EaseOutQuad,
		EaseInOutQuad,
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInQuart,
		EaseOutQuart,
		EaseInOutQuart,
		EaseInQuint,
		EaseOutQuint,
		EaseInOutQuint,
		EaseInSine,
		EaseOutSine,
		EaseInOutSine,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		EaseInCirc,
		EaseOutCirc,
		EaseInOutCirc
	}

	public delegate UnityEngine.Vector3 ToVector3<T>(T v);

	public delegate float Function(float a, float b, float c, float d);

	private static UnityEngine.Vector3 Identity(UnityEngine.Vector3 v)
	{
		return v;
	}

	private static UnityEngine.Vector3 TransformDotPosition(Transform t)
	{
		return t.position;
	}

	private static IEnumerable<float> NewTimer(float duration)
	{
		float elapsedTime = 0f;
		while (elapsedTime < duration)
		{
			yield return elapsedTime;
			elapsedTime += Time.deltaTime;
			if (elapsedTime >= duration)
			{
				yield return elapsedTime;
			}
		}
	}

	private static IEnumerable<float> NewCounter(int start, int end, int step)
	{
		for (int i = start; i <= end; i += step)
		{
			yield return i;
		}
	}

	public static IEnumerator NewEase(Function ease, UnityEngine.Vector3 start, UnityEngine.Vector3 end, float duration)
	{
		IEnumerable<float> driver = NewTimer(duration);
		return NewEase(ease, start, end, duration, driver);
	}

	public static IEnumerator NewEase(Function ease, UnityEngine.Vector3 start, UnityEngine.Vector3 end, int slices)
	{
		IEnumerable<float> driver = NewCounter(0, slices + 1, 1);
		return NewEase(ease, start, end, slices + 1, driver);
	}

	private static IEnumerator NewEase(Function ease, UnityEngine.Vector3 start, UnityEngine.Vector3 end, float total, IEnumerable<float> driver)
	{
		UnityEngine.Vector3 distance = end - start;
		foreach (float item in driver)
		{
			yield return Ease(ease, start, distance, item, total);
		}
	}

	private static UnityEngine.Vector3 Ease(Function ease, UnityEngine.Vector3 start, UnityEngine.Vector3 distance, float elapsedTime, float duration)
	{
		start.x = ease(start.x, distance.x, elapsedTime, duration);
		start.y = ease(start.y, distance.y, elapsedTime, duration);
		start.z = ease(start.z, distance.z, elapsedTime, duration);
		return start;
	}

	public static Function Ease(EaseType type)
	{
		Function result = null;
		switch (type)
		{
		case EaseType.Linear:
			result = Linear;
			break;
		case EaseType.EaseInQuad:
			result = EaseInQuad;
			break;
		case EaseType.EaseOutQuad:
			result = EaseOutQuad;
			break;
		case EaseType.EaseInOutQuad:
			result = EaseInOutQuad;
			break;
		case EaseType.EaseInCubic:
			result = EaseInCubic;
			break;
		case EaseType.EaseOutCubic:
			result = EaseOutCubic;
			break;
		case EaseType.EaseInOutCubic:
			result = EaseInOutCubic;
			break;
		case EaseType.EaseInQuart:
			result = EaseInQuart;
			break;
		case EaseType.EaseOutQuart:
			result = EaseOutQuart;
			break;
		case EaseType.EaseInOutQuart:
			result = EaseInOutQuart;
			break;
		case EaseType.EaseInQuint:
			result = EaseInQuint;
			break;
		case EaseType.EaseOutQuint:
			result = EaseOutQuint;
			break;
		case EaseType.EaseInOutQuint:
			result = EaseInOutQuint;
			break;
		case EaseType.EaseInSine:
			result = EaseInSine;
			break;
		case EaseType.EaseOutSine:
			result = EaseOutSine;
			break;
		case EaseType.EaseInOutSine:
			result = EaseInOutSine;
			break;
		case EaseType.EaseInExpo:
			result = EaseInExpo;
			break;
		case EaseType.EaseOutExpo:
			result = EaseOutExpo;
			break;
		case EaseType.EaseInOutExpo:
			result = EaseInOutExpo;
			break;
		case EaseType.EaseInCirc:
			result = EaseInCirc;
			break;
		case EaseType.EaseOutCirc:
			result = EaseOutCirc;
			break;
		case EaseType.EaseInOutCirc:
			result = EaseInOutCirc;
			break;
		}
		return result;
	}

	public static IEnumerable<UnityEngine.Vector3> NewBezier(Function ease, Transform[] nodes, float duration)
	{
		IEnumerable<float> steps = NewTimer(duration);
		return NewBezier<Transform>(ease, nodes, TransformDotPosition, duration, steps);
	}

	public static IEnumerable<UnityEngine.Vector3> NewBezier(Function ease, Transform[] nodes, int slices)
	{
		IEnumerable<float> steps = NewCounter(0, slices + 1, 1);
		return NewBezier<Transform>(ease, nodes, TransformDotPosition, slices + 1, steps);
	}

	public static IEnumerable<UnityEngine.Vector3> NewBezier(Function ease, UnityEngine.Vector3[] points, float duration)
	{
		IEnumerable<float> steps = NewTimer(duration);
		return NewBezier<UnityEngine.Vector3>(ease, points, Identity, duration, steps);
	}

	public static IEnumerable<UnityEngine.Vector3> NewBezier(Function ease, UnityEngine.Vector3[] points, int slices)
	{
		IEnumerable<float> steps = NewCounter(0, slices + 1, 1);
		return NewBezier<UnityEngine.Vector3>(ease, points, Identity, slices + 1, steps);
	}

	private static IEnumerable<UnityEngine.Vector3> NewBezier<T>(Function ease, IList nodes, ToVector3<T> toVector3, float maxStep, IEnumerable<float> steps)
	{
		if (nodes.Count < 2)
		{
			yield break;
		}
		UnityEngine.Vector3[] points = new UnityEngine.Vector3[nodes.Count];
		foreach (float step in steps)
		{
			for (int i = 0; i < nodes.Count; i++)
			{
				points[i] = toVector3((T)nodes[i]);
			}
			yield return Bezier(ease, points, step, maxStep);
		}
	}

	private static UnityEngine.Vector3 Bezier(Function ease, UnityEngine.Vector3[] points, float elapsedTime, float duration)
	{
		for (int num = points.Length - 1; num > 0; num--)
		{
			for (int i = 0; i < num; i++)
			{
				points[i].x = ease(points[i].x, points[i + 1].x - points[i].x, elapsedTime, duration);
				points[i].y = ease(points[i].y, points[i + 1].y - points[i].y, elapsedTime, duration);
				points[i].z = ease(points[i].z, points[i + 1].z - points[i].z, elapsedTime, duration);
			}
		}
		return points[0];
	}

	public static IEnumerable<UnityEngine.Vector3> NewCatmullRom(Transform[] nodes, int slices, bool loop)
	{
		return NewCatmullRom<Transform>(nodes, TransformDotPosition, slices, loop);
	}

	public static IEnumerable<UnityEngine.Vector3> NewCatmullRom(UnityEngine.Vector3[] points, int slices, bool loop)
	{
		return NewCatmullRom<UnityEngine.Vector3>(points, Identity, slices, loop);
	}

	private static IEnumerable<UnityEngine.Vector3> NewCatmullRom<T>(IList nodes, ToVector3<T> toVector3, int slices, bool loop)
	{
		if (nodes.Count < 2)
		{
			yield break;
		}
		yield return toVector3((T)nodes[0]);
		int last = nodes.Count - 1;
		for (int current = 0; loop || current < last; current++)
		{
			if (loop && current > last)
			{
				current = 0;
			}
			int previous = ((current != 0) ? (current - 1) : (loop ? last : current));
			int start = current;
			int end = ((current != last) ? (current + 1) : ((!loop) ? current : 0));
			int next = ((end != last) ? (end + 1) : ((!loop) ? end : 0));
			int stepCount = slices + 1;
			for (int step = 1; step <= stepCount; step++)
			{
				yield return CatmullRom(toVector3((T)nodes[previous]), toVector3((T)nodes[start]), toVector3((T)nodes[end]), toVector3((T)nodes[next]), step, stepCount);
			}
		}
	}

	private static UnityEngine.Vector3 CatmullRom(UnityEngine.Vector3 previous, UnityEngine.Vector3 start, UnityEngine.Vector3 end, UnityEngine.Vector3 next, float elapsedTime, float duration)
	{
		float num = elapsedTime / duration;
		float num2 = num * num;
		float num3 = num2 * num;
		return previous * (-0.5f * num3 + num2 - 0.5f * num) + start * (1.5f * num3 + -2.5f * num2 + 1f) + end * (-1.5f * num3 + 2f * num2 + 0.5f * num) + next * (0.5f * num3 - 0.5f * num2);
	}

	private static float Linear(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * (elapsedTime / duration) + start;
	}

	private static float EaseInQuad(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutQuad(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return (0f - distance) * elapsedTime * (elapsedTime - 2f) + start;
	}

	private static float EaseInOutQuad(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 1f;
		return (0f - distance) / 2f * (elapsedTime * (elapsedTime - 2f) - 1f) + start;
	}

	private static float EaseInCubic(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutCubic(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return distance * (elapsedTime * elapsedTime * elapsedTime + 1f) + start;
	}

	private static float EaseInOutCubic(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 2f;
		return distance / 2f * (elapsedTime * elapsedTime * elapsedTime + 2f) + start;
	}

	private static float EaseInQuart(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutQuart(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return (0f - distance) * (elapsedTime * elapsedTime * elapsedTime * elapsedTime - 1f) + start;
	}

	private static float EaseInOutQuart(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 2f;
		return (0f - distance) / 2f * (elapsedTime * elapsedTime * elapsedTime * elapsedTime - 2f) + start;
	}

	private static float EaseInQuint(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return distance * elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
	}

	private static float EaseOutQuint(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return distance * (elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + 1f) + start;
	}

	private static float EaseInOutQuint(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + start;
		}
		elapsedTime -= 2f;
		return distance / 2f * (elapsedTime * elapsedTime * elapsedTime * elapsedTime * elapsedTime + 2f) + start;
	}

	private static float EaseInSine(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return (0f - distance) * Mathf.Cos(elapsedTime / duration * ((float)Math.PI / 2f)) + distance + start;
	}

	private static float EaseOutSine(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * Mathf.Sin(elapsedTime / duration * ((float)Math.PI / 2f)) + start;
	}

	private static float EaseInOutSine(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return (0f - distance) / 2f * (Mathf.Cos((float)Math.PI * elapsedTime / duration) - 1f) + start;
	}

	private static float EaseInExpo(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * Mathf.Pow(2f, 10f * (elapsedTime / duration - 1f)) + start;
	}

	private static float EaseOutExpo(float start, float distance, float elapsedTime, float duration)
	{
		if (elapsedTime > duration)
		{
			elapsedTime = duration;
		}
		return distance * (0f - Mathf.Pow(2f, -10f * elapsedTime / duration) + 1f) + start;
	}

	private static float EaseInOutExpo(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return distance / 2f * Mathf.Pow(2f, 10f * (elapsedTime - 1f)) + start;
		}
		elapsedTime -= 1f;
		return distance / 2f * (0f - Mathf.Pow(2f, -10f * elapsedTime) + 2f) + start;
	}

	private static float EaseInCirc(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		return (0f - distance) * (Mathf.Sqrt(1f - elapsedTime * elapsedTime) - 1f) + start;
	}

	private static float EaseOutCirc(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 1f : (elapsedTime / duration));
		elapsedTime -= 1f;
		return distance * Mathf.Sqrt(1f - elapsedTime * elapsedTime) + start;
	}

	private static float EaseInOutCirc(float start, float distance, float elapsedTime, float duration)
	{
		elapsedTime = ((elapsedTime > duration) ? 2f : (elapsedTime / (duration / 2f)));
		if (elapsedTime < 1f)
		{
			return (0f - distance) / 2f * (Mathf.Sqrt(1f - elapsedTime * elapsedTime) - 1f) + start;
		}
		elapsedTime -= 2f;
		return distance / 2f * (Mathf.Sqrt(1f - elapsedTime * elapsedTime) + 1f) + start;
	}
}
public class MeleeWeaponTrail : MonoBehaviour
{
	[Serializable]
	public class Point
	{
		public float timeCreated;

		public UnityEngine.Vector3 basePosition;

		public UnityEngine.Vector3 tipPosition;
	}

	[SerializeField]
	private bool _emit = true;

	private bool _use = true;

	[SerializeField]
	private float _emitTime;

	[SerializeField]
	public Material _material;

	[SerializeField]
	private float _lifeTime = 1f;

	[SerializeField]
	private Color[] _colors;

	[SerializeField]
	private float[] _sizes;

	[SerializeField]
	private float _minVertexDistance = 0.1f;

	[SerializeField]
	private float _maxVertexDistance = 10f;

	private float _minVertexDistanceSqr;

	private float _maxVertexDistanceSqr;

	[SerializeField]
	private float _maxAngle = 3f;

	[SerializeField]
	private bool _autoDestruct;

	[SerializeField]
	private int subdivisions = 4;

	[SerializeField]
	private Transform _base;

	[SerializeField]
	private Transform _tip;

	private List<Point> _points = new List<Point>();

	private List<Point> _smoothedPoints = new List<Point>();

	private GameObject _trailObject;

	private Mesh _trailMesh;

	private UnityEngine.Vector3 _lastPosition;

	public bool Emit
	{
		set
		{
			_emit = value;
		}
	}

	public bool Use
	{
		set
		{
			_use = value;
		}
	}

	private void Start()
	{
		_lastPosition = base.transform.position;
		_trailObject = new GameObject("Trail");
		_trailObject.transform.parent = null;
		_trailObject.transform.position = UnityEngine.Vector3.zero;
		_trailObject.transform.rotation = UnityEngine.Quaternion.identity;
		_trailObject.transform.localScale = UnityEngine.Vector3.one;
		_trailObject.AddComponent(typeof(MeshFilter));
		_trailObject.AddComponent(typeof(MeshRenderer));
		_trailObject.GetComponent<Renderer>().material = _material;
		_trailMesh = new Mesh();
		_trailMesh.name = base.name + "TrailMesh";
		_trailObject.GetComponent<MeshFilter>().mesh = _trailMesh;
		_minVertexDistanceSqr = _minVertexDistance * _minVertexDistance;
		_maxVertexDistanceSqr = _maxVertexDistance * _maxVertexDistance;
	}

	private void OnDisable()
	{
		UnityEngine.Object.Destroy(_trailObject);
	}

	private void Update()
	{
		if (!_use)
		{
			return;
		}
		if (_emit && _emitTime != 0f)
		{
			_emitTime -= Time.deltaTime;
			if (_emitTime == 0f)
			{
				_emitTime = -1f;
			}
			if (_emitTime < 0f)
			{
				_emit = false;
			}
		}
		if (!_emit && _points.Count == 0 && _autoDestruct)
		{
			UnityEngine.Object.Destroy(_trailObject);
			UnityEngine.Object.Destroy(base.gameObject);
		}
		float sqrMagnitude = (_lastPosition - base.transform.position).sqrMagnitude;
		if (_emit)
		{
			if (sqrMagnitude > _minVertexDistanceSqr)
			{
				bool flag = false;
				if (_points.Count < 3)
				{
					flag = true;
				}
				else
				{
					UnityEngine.Vector3 from = _points[_points.Count - 2].tipPosition - _points[_points.Count - 3].tipPosition;
					UnityEngine.Vector3 to = _points[_points.Count - 1].tipPosition - _points[_points.Count - 2].tipPosition;
					if (UnityEngine.Vector3.Angle(from, to) > _maxAngle || sqrMagnitude > _maxVertexDistanceSqr)
					{
						flag = true;
					}
				}
				if (flag)
				{
					Point point = new Point();
					point.basePosition = _base.position;
					point.tipPosition = _tip.position;
					point.timeCreated = Time.time;
					_points.Add(point);
					_lastPosition = base.transform.position;
					if (_points.Count == 1)
					{
						_smoothedPoints.Add(point);
					}
					else if (_points.Count > 1)
					{
						for (int i = 0; i < 1 + subdivisions; i++)
						{
							_smoothedPoints.Add(point);
						}
					}
					if (_points.Count >= 4)
					{
						IEnumerable<UnityEngine.Vector3> collection = Interpolate.NewCatmullRom(new UnityEngine.Vector3[4]
						{
							_points[_points.Count - 4].tipPosition,
							_points[_points.Count - 3].tipPosition,
							_points[_points.Count - 2].tipPosition,
							_points[_points.Count - 1].tipPosition
						}, subdivisions, loop: false);
						IEnumerable<UnityEngine.Vector3> collection2 = Interpolate.NewCatmullRom(new UnityEngine.Vector3[4]
						{
							_points[_points.Count - 4].basePosition,
							_points[_points.Count - 3].basePosition,
							_points[_points.Count - 2].basePosition,
							_points[_points.Count - 1].basePosition
						}, subdivisions, loop: false);
						List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>(collection);
						List<UnityEngine.Vector3> list2 = new List<UnityEngine.Vector3>(collection2);
						float timeCreated = _points[_points.Count - 4].timeCreated;
						float timeCreated2 = _points[_points.Count - 1].timeCreated;
						for (int j = 0; j < list.Count; j++)
						{
							int num = _smoothedPoints.Count - (list.Count - j);
							if (num > -1 && num < _smoothedPoints.Count)
							{
								Point point2 = new Point();
								point2.basePosition = list2[j];
								point2.tipPosition = list[j];
								point2.timeCreated = Mathf.Lerp(timeCreated, timeCreated2, (float)j / (float)list.Count);
								_smoothedPoints[num] = point2;
							}
						}
					}
				}
				else
				{
					_points[_points.Count - 1].basePosition = _base.position;
					_points[_points.Count - 1].tipPosition = _tip.position;
					_smoothedPoints[_smoothedPoints.Count - 1].basePosition = _base.position;
					_smoothedPoints[_smoothedPoints.Count - 1].tipPosition = _tip.position;
				}
			}
			else
			{
				if (_points.Count > 0)
				{
					_points[_points.Count - 1].basePosition = _base.position;
					_points[_points.Count - 1].tipPosition = _tip.position;
				}
				if (_smoothedPoints.Count > 0)
				{
					_smoothedPoints[_smoothedPoints.Count - 1].basePosition = _base.position;
					_smoothedPoints[_smoothedPoints.Count - 1].tipPosition = _tip.position;
				}
			}
		}
		RemoveOldPoints(_points);
		if (_points.Count == 0)
		{
			_trailMesh.Clear();
		}
		RemoveOldPoints(_smoothedPoints);
		if (_smoothedPoints.Count == 0)
		{
			_trailMesh.Clear();
		}
		List<Point> smoothedPoints = _smoothedPoints;
		if (smoothedPoints.Count <= 1)
		{
			return;
		}
		UnityEngine.Vector3[] array = new UnityEngine.Vector3[smoothedPoints.Count * 2];
		UnityEngine.Vector2[] array2 = new UnityEngine.Vector2[smoothedPoints.Count * 2];
		int[] array3 = new int[(smoothedPoints.Count - 1) * 6];
		Color[] array4 = new Color[smoothedPoints.Count * 2];
		for (int k = 0; k < smoothedPoints.Count; k++)
		{
			Point point3 = smoothedPoints[k];
			float num2 = (Time.time - point3.timeCreated) / _lifeTime;
			Color color = Color.Lerp(Color.white, Color.clear, num2);
			if (_colors != null && _colors.Length != 0)
			{
				float num3 = num2 * (float)(_colors.Length - 1);
				float num4 = Mathf.Floor(num3);
				float num5 = Mathf.Clamp(Mathf.Ceil(num3), 1f, _colors.Length - 1);
				float t = Mathf.InverseLerp(num4, num5, num3);
				if (num4 >= (float)_colors.Length)
				{
					num4 = _colors.Length - 1;
				}
				if (num4 < 0f)
				{
					num4 = 0f;
				}
				if (num5 >= (float)_colors.Length)
				{
					num5 = _colors.Length - 1;
				}
				if (num5 < 0f)
				{
					num5 = 0f;
				}
				color = Color.Lerp(_colors[(int)num4], _colors[(int)num5], t);
			}
			float num6 = 0f;
			if (_sizes != null && _sizes.Length != 0)
			{
				float num7 = num2 * (float)(_sizes.Length - 1);
				float num8 = Mathf.Floor(num7);
				float num9 = Mathf.Clamp(Mathf.Ceil(num7), 1f, _sizes.Length - 1);
				float t2 = Mathf.InverseLerp(num8, num9, num7);
				if (num8 >= (float)_sizes.Length)
				{
					num8 = _sizes.Length - 1;
				}
				if (num8 < 0f)
				{
					num8 = 0f;
				}
				if (num9 >= (float)_sizes.Length)
				{
					num9 = _sizes.Length - 1;
				}
				if (num9 < 0f)
				{
					num9 = 0f;
				}
				num6 = Mathf.Lerp(_sizes[(int)num8], _sizes[(int)num9], t2);
			}
			UnityEngine.Vector3 vector = point3.tipPosition - point3.basePosition;
			array[k * 2] = point3.basePosition - vector * (num6 * 0.5f);
			array[k * 2 + 1] = point3.tipPosition + vector * (num6 * 0.5f);
			array4[k * 2] = (array4[k * 2 + 1] = color);
			float x = (float)k / (float)smoothedPoints.Count;
			array2[k * 2] = new UnityEngine.Vector2(x, 0f);
			array2[k * 2 + 1] = new UnityEngine.Vector2(x, 1f);
			if (k > 0)
			{
				array3[(k - 1) * 6] = k * 2 - 2;
				array3[(k - 1) * 6 + 1] = k * 2 - 1;
				array3[(k - 1) * 6 + 2] = k * 2;
				array3[(k - 1) * 6 + 3] = k * 2 + 1;
				array3[(k - 1) * 6 + 4] = k * 2;
				array3[(k - 1) * 6 + 5] = k * 2 - 1;
			}
		}
		_trailMesh.Clear();
		_trailMesh.vertices = array;
		_trailMesh.colors = array4;
		_trailMesh.uv = array2;
		_trailMesh.triangles = array3;
	}

	private void RemoveOldPoints(List<Point> pointList)
	{
		List<Point> list = new List<Point>();
		foreach (Point point in pointList)
		{
			if (Time.time - point.timeCreated > _lifeTime)
			{
				list.Add(point);
			}
		}
		foreach (Point item in list)
		{
			pointList.Remove(item);
		}
	}
}
public class FreeCam : MonoBehaviour
{
	public float speedNormal = 3f;

	public float speedFast = 45f;

	public float mouseSensX = 2f;

	public float mouseSensY = 2f;

	private float rotY;

	private float speed;

	private void Start()
	{
	}

	private void Update()
	{
		Input.GetMouseButton(0);
		if (Input.GetMouseButton(1))
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * mouseSensX;
			rotY += Input.GetAxis("Mouse Y") * mouseSensY;
			rotY = Mathf.Clamp(rotY, -80f, 80f);
			base.transform.localEulerAngles = new UnityEngine.Vector3(0f - rotY, y, 0f);
		}
		float axis = Input.GetAxis("Vertical");
		float axis2 = Input.GetAxis("Horizontal");
		if (axis != 0f)
		{
			if (Input.GetKey(KeyCode.LeftShift))
			{
				speed = speedFast;
			}
			else
			{
				speed = speedNormal;
			}
			UnityEngine.Vector3 vector = new UnityEngine.Vector3(0f, 0f, axis * speed * Time.deltaTime);
			base.transform.localPosition += base.transform.localRotation * vector;
		}
		if (axis2 != 0f)
		{
			if (Input.GetKey(KeyCode.LeftShift))
			{
				speed = speedFast;
			}
			else
			{
				speed = speedNormal;
			}
			UnityEngine.Vector3 vector2 = new UnityEngine.Vector3(axis2 * speed * Time.deltaTime, 0f, 0f);
			base.transform.localPosition += base.transform.localRotation * vector2;
		}
	}
}
public class Movement : MonoBehaviour
{
	public UnityEngine.Vector3 movementVector;

	private void Update()
	{
		base.transform.position += movementVector * Time.deltaTime;
	}
}
[ExecuteInEditMode]
public class MobilePostProcessing : MonoBehaviour
{
	public bool Blur;

	[Range(0f, 1f)]
	public float BlurAmount = 1f;

	public Texture2D BlurMask;

	public bool Bloom;

	public Color BloomColor = Color.white;

	[Range(0f, 5f)]
	public float BloomAmount = 1f;

	[Range(0f, 1f)]
	public float BloomDiffuse = 1f;

	[Range(0f, 1f)]
	public float BloomThreshold;

	[Range(0f, 1f)]
	public float BloomSoftness;

	public bool LUT;

	[Range(0f, 1f)]
	public float LutAmount;

	public Texture2D SourceLut;

	public bool ImageFiltering;

	public Color Color = Color.white;

	[Range(0f, 1f)]
	public float Contrast;

	[Range(-1f, 1f)]
	public float Brightness;

	[Range(-1f, 1f)]
	public float Saturation;

	[Range(-1f, 1f)]
	public float Exposure;

	[Range(-1f, 1f)]
	public float Gamma;

	[Range(0f, 1f)]
	public float Sharpness;

	public bool ChromaticAberration;

	public float Offset;

	[Range(-1f, 1f)]
	public float FishEyeDistortion;

	[Range(0f, 1f)]
	public float GlitchAmount;

	public bool Distortion;

	[Range(0f, 1f)]
	public float LensDistortion;

	public bool Vignette;

	public Color VignetteColor = Color.black;

	[Range(0f, 1f)]
	public float VignetteAmount;

	[Range(0.001f, 1f)]
	public float VignetteSoftness = 0.0001f;

	private static readonly int blurTexString = Shader.PropertyToID("_BlurTex");

	private static readonly int maskTextureString = Shader.PropertyToID("_MaskTex");

	private static readonly int blurAmountString = Shader.PropertyToID("_BlurAmount");

	private static readonly int bloomColorString = Shader.PropertyToID("_BloomColor");

	private static readonly int blDiffuseString = Shader.PropertyToID("_BloomDiffuse");

	private static readonly int blDataString = Shader.PropertyToID("_BloomData");

	private static readonly int lutTextureString = Shader.PropertyToID("_LutTex");

	private static readonly int lutAmountString = Shader.PropertyToID("_LutAmount");

	private static readonly int colorString = Shader.PropertyToID("_Color");

	private static readonly int contrastString = Shader.PropertyToID("_Contrast");

	private static readonly int brightnessString = Shader.PropertyToID("_Brightness");

	private static readonly int saturationString = Shader.PropertyToID("_Saturation");

	private static readonly int centralFactorString = Shader.PropertyToID("_CentralFactor");

	private static readonly int sideFactorString = Shader.PropertyToID("_SideFactor");

	private static readonly int offsetString = Shader.PropertyToID("_Offset");

	private static readonly int fishEyeString = Shader.PropertyToID("_FishEye");

	private static readonly int lensdistortionString = Shader.PropertyToID("_LensDistortion");

	private static readonly int vignetteColorString = Shader.PropertyToID("_VignetteColor");

	private static readonly int vignetteAmountString = Shader.PropertyToID("_VignetteAmount");

	private static readonly int vignetteSoftnessString = Shader.PropertyToID("_VignetteSoftness");

	private static readonly string bloomKeyword = "BLOOM";

	private static readonly string blurKeyword = "BLUR";

	private static readonly string chromaKeyword = "CHROMA";

	private static readonly string lutKeyword = "LUT";

	private static readonly string filterKeyword = "FILTER";

	private static readonly string shaprenKeyword = "SHARPEN";

	private static readonly string distortionKeyword = "DISTORTION";

	public Material material;

	private Texture2D previous;

	private Texture3D converted3D;

	private float t;

	private float a;

	private float knee;

	private int numberOfPasses = 3;

	public void Start()
	{
		if (BlurMask == null)
		{
			Shader.SetGlobalTexture(maskTextureString, Texture2D.whiteTexture);
		}
		else
		{
			Shader.SetGlobalTexture(maskTextureString, BlurMask);
		}
	}

	public void Update()
	{
		if (SourceLut != previous)
		{
			previous = SourceLut;
			Convert3D(SourceLut);
		}
	}

	private void OnDestroy()
	{
		if (converted3D != null)
		{
			UnityEngine.Object.DestroyImmediate(converted3D);
		}
		converted3D = null;
	}

	private void Convert3D(Texture2D temp3DTex)
	{
		Color[] pixels = temp3DTex.GetPixels();
		Color[] array = new Color[pixels.Length];
		for (int i = 0; i < 16; i++)
		{
			for (int j = 0; j < 16; j++)
			{
				for (int k = 0; k < 16; k++)
				{
					int num = 16 - j - 1;
					array[i + j * 16 + k * 256] = pixels[k * 16 + i + num * 256];
				}
			}
		}
		if ((bool)converted3D)
		{
			UnityEngine.Object.DestroyImmediate(converted3D);
		}
		converted3D = new Texture3D(16, 16, 16, TextureFormat.ARGB32, mipChain: false);
		converted3D.SetPixels(array);
		converted3D.Apply();
		converted3D.wrapMode = TextureWrapMode.Clamp;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (Blur || Bloom)
		{
			material.DisableKeyword(blurKeyword);
			material.DisableKeyword(bloomKeyword);
			if (Bloom)
			{
				material.EnableKeyword(bloomKeyword);
				material.SetColor(bloomColorString, BloomColor * BloomAmount);
				material.SetFloat(blDiffuseString, BloomDiffuse);
				numberOfPasses = Mathf.Max(Mathf.CeilToInt(BloomDiffuse * 4f), 1);
				material.SetFloat(blDiffuseString, (numberOfPasses > 1) ? ((BloomDiffuse * 4f - (float)Mathf.FloorToInt(BloomDiffuse * 4f - 0.001f)) * 0.5f + 0.5f) : (BloomDiffuse * 4f));
				knee = BloomThreshold * BloomSoftness;
				material.SetVector(blDataString, new UnityEngine.Vector4(BloomThreshold, BloomThreshold - knee, 2f * knee, 1f / (4f * knee + 1E-05f)));
			}
			if (Blur)
			{
				material.EnableKeyword(blurKeyword);
				numberOfPasses = Mathf.Max(Mathf.CeilToInt(BlurAmount * 4f), 1);
				material.SetFloat(blurAmountString, (numberOfPasses > 1) ? ((BlurAmount * 4f - (float)Mathf.FloorToInt(BlurAmount * 4f - 0.001f)) * 0.5f + 0.5f) : (BlurAmount * 4f));
			}
			if (BlurAmount > 0f || !Blur)
			{
				RenderTexture renderTexture = null;
				if (numberOfPasses == 1)
				{
					renderTexture = RenderTexture.GetTemporary(Screen.width / 2, Screen.height / 2, 0, source.format);
					Graphics.Blit(source, renderTexture, material, 0);
				}
				else if (numberOfPasses == 2)
				{
					renderTexture = RenderTexture.GetTemporary(Screen.width / 2, Screen.height / 2, 0, source.format);
					RenderTexture temporary = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
					Graphics.Blit(source, temporary, material, 0);
					Graphics.Blit(temporary, renderTexture, material, 0);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else if (numberOfPasses == 3)
				{
					renderTexture = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
					RenderTexture temporary2 = RenderTexture.GetTemporary(Screen.width / 8, Screen.height / 8, 0, source.format);
					Graphics.Blit(source, renderTexture, material, 0);
					Graphics.Blit(renderTexture, temporary2, material, 0);
					Graphics.Blit(temporary2, renderTexture, material, 0);
					RenderTexture.ReleaseTemporary(temporary2);
				}
				else if (numberOfPasses == 4)
				{
					renderTexture = RenderTexture.GetTemporary(Screen.width / 4, Screen.height / 4, 0, source.format);
					RenderTexture temporary3 = RenderTexture.GetTemporary(Screen.width / 8, Screen.height / 8, 0, source.format);
					RenderTexture temporary4 = RenderTexture.GetTemporary(Screen.width / 16, Screen.height / 16, 0, source.format);
					Graphics.Blit(source, renderTexture, material, 0);
					Graphics.Blit(renderTexture, temporary3, material, 0);
					Graphics.Blit(temporary3, temporary4, material, 0);
					Graphics.Blit(temporary4, temporary3, material, 0);
					Graphics.Blit(temporary3, renderTexture, material, 0);
					RenderTexture.ReleaseTemporary(temporary3);
					RenderTexture.ReleaseTemporary(temporary4);
				}
				material.SetTexture(blurTexString, renderTexture);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			else
			{
				material.SetTexture(blurTexString, source);
			}
		}
		else
		{
			material.DisableKeyword(blurKeyword);
			material.DisableKeyword(bloomKeyword);
		}
		if (LUT)
		{
			material.EnableKeyword(lutKeyword);
			material.SetFloat(lutAmountString, LutAmount);
			material.SetTexture(lutTextureString, converted3D);
		}
		else
		{
			material.DisableKeyword(lutKeyword);
		}
		if (ImageFiltering)
		{
			material.EnableKeyword(filterKeyword);
			material.SetColor(colorString, (Mathf.Pow(2f, Exposure) - Gamma) * Color);
			material.SetFloat(contrastString, Contrast + 1f);
			material.SetFloat(brightnessString, Brightness * 0.5f - Contrast);
			material.SetFloat(saturationString, Saturation + 1f);
			if (Sharpness > 0f)
			{
				material.EnableKeyword(shaprenKeyword);
				material.SetFloat(centralFactorString, 1f + 3.2f * Sharpness);
				material.SetFloat(sideFactorString, 0.8f * Sharpness);
			}
			else
			{
				material.DisableKeyword(shaprenKeyword);
			}
		}
		else
		{
			material.DisableKeyword(filterKeyword);
			material.DisableKeyword(shaprenKeyword);
		}
		if (ChromaticAberration)
		{
			material.EnableKeyword(chromaKeyword);
			if (GlitchAmount > 0f)
			{
				t = Time.realtimeSinceStartup;
				a = (1f + Mathf.Sin(t * 6f)) * (0.5f + Mathf.Sin(t * 16f) * 0.25f) * (0.5f + Mathf.Sin(t * 19f) * 0.25f) * (0.5f + Mathf.Sin(t * 27f) * 0.25f);
				material.SetFloat(offsetString, 10f * Offset + GlitchAmount * Mathf.Pow(a, 3f) * 200f);
			}
			else
			{
				material.SetFloat(offsetString, 10f * Offset);
			}
			material.SetFloat(fishEyeString, 0.1f * FishEyeDistortion);
		}
		else
		{
			material.DisableKeyword(chromaKeyword);
		}
		if (Distortion)
		{
			material.SetFloat(lensdistortionString, 0f - LensDistortion);
			material.EnableKeyword(distortionKeyword);
		}
		else
		{
			material.DisableKeyword(distortionKeyword);
		}
		if (Vignette)
		{
			material.SetColor(vignetteColorString, VignetteColor);
			material.SetFloat(vignetteAmountString, 1f - VignetteAmount);
			material.SetFloat(vignetteSoftnessString, 1f - VignetteSoftness - VignetteAmount);
		}
		else
		{
			material.SetFloat(vignetteAmountString, 1f);
			material.SetFloat(vignetteSoftnessString, 0.999f);
		}
		Graphics.Blit(source, destination, material, 1);
	}
}
[ExecuteInEditMode]
public class EditValues : MonoBehaviour
{
	public bool Blur;

	[Range(0f, 1f)]
	public float BlurAmount = 1f;

	public bool Bloom;

	public Color BloomColor = Color.white;

	[Range(0f, 5f)]
	public float BloomAmount = 1f;

	[Range(0f, 1f)]
	public float BloomDiffuse = 1f;

	[Range(0f, 1f)]
	public float BloomThreshold;

	[Range(0f, 1f)]
	public float BloomSoftness;

	public bool LUT;

	[Range(0f, 1f)]
	public float LutAmount;

	public Texture2D SourceLut;

	public bool ImageFiltering;

	public Color Color = Color.white;

	[Range(0f, 1f)]
	public float Contrast;

	[Range(-1f, 1f)]
	public float Brightness;

	[Range(-1f, 1f)]
	public float Saturation;

	[Range(-1f, 1f)]
	public float Exposure;

	[Range(-1f, 1f)]
	public float Gamma;

	[Range(0f, 1f)]
	public float Sharpness;

	public bool ChromaticAberration;

	public float Offset;

	[Range(-1f, 1f)]
	public float FishEyeDistortion;

	[Range(0f, 1f)]
	public float GlitchAmount;

	public bool Distortion;

	[Range(0f, 1f)]
	public float LensDistortion;

	public bool Vignette;

	public Color VignetteColor = Color.black;

	[Range(0f, 1f)]
	public float VignetteAmount;

	[Range(0.001f, 1f)]
	public float VignetteSoftness = 0.001f;

	private void Update()
	{
		if (!(PostProcessUrp.Instance == null))
		{
			PostProcessUrp.Instance.settings.Blur = Blur;
			PostProcessUrp.Instance.settings.BlurAmount = BlurAmount;
			PostProcessUrp.Instance.settings.Bloom = Bloom;
			PostProcessUrp.Instance.settings.BloomColor = BloomColor;
			PostProcessUrp.Instance.settings.BloomAmount = BloomAmount;
			PostProcessUrp.Instance.settings.BloomDiffuse = BloomDiffuse;
			PostProcessUrp.Instance.settings.BloomThreshold = BloomThreshold;
			PostProcessUrp.Instance.settings.BloomSoftness = BloomSoftness;
			PostProcessUrp.Instance.settings.LUT = LUT;
			PostProcessUrp.Instance.settings.LutAmount = LutAmount;
			PostProcessUrp.Instance.settings.SourceLut = SourceLut;
			PostProcessUrp.Instance.settings.ImageFiltering = ImageFiltering;
			PostProcessUrp.Instance.settings.Color = Color;
			PostProcessUrp.Instance.settings.Contrast = Contrast;
			PostProcessUrp.Instance.settings.Brightness = Brightness;
			PostProcessUrp.Instance.settings.Saturation = Saturation;
			PostProcessUrp.Instance.settings.Exposure = Exposure;
			PostProcessUrp.Instance.settings.Gamma = Gamma;
			PostProcessUrp.Instance.settings.Sharpness = Sharpness;
			PostProcessUrp.Instance.settings.ChromaticAberration = ChromaticAberration;
			PostProcessUrp.Instance.settings.Offset = Offset;
			PostProcessUrp.Instance.settings.FishEyeDistortion = FishEyeDistortion;
			PostProcessUrp.Instance.settings.GlitchAmount = GlitchAmount;
			PostProcessUrp.Instance.settings.Distortion = Distortion;
			PostProcessUrp.Instance.settings.LensDistortion = LensDistortion;
			PostProcessUrp.Instance.settings.Vignette = Vignette;
			PostProcessUrp.Instance.settings.VignetteColor = VignetteColor;
			PostProcessUrp.Instance.settings.VignetteAmount = VignetteAmount;
			PostProcessUrp.Instance.settings.VignetteSoftness = VignetteSoftness;
			PostProcessUrp.Instance.Create();
		}
	}
}
public class PIDI_ForceUpdate : MonoBehaviour
{
	public bool affectAllReflections;

	public PIDI_PlanarReflection[] reflections = new PIDI_PlanarReflection[0];

	public void Start()
	{
		GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
		if (affectAllReflections)
		{
			reflections = UnityEngine.Object.FindObjectsOfType<PIDI_PlanarReflection>();
		}
	}

	public void OnPreRender()
	{
		for (int i = 0; i < reflections.Length; i++)
		{
			reflections[i].OnWillRenderObject(GetComponent<Camera>());
		}
	}
}
[RequireComponent(typeof(MeshRenderer))]
[ExecuteInEditMode]
public class PIDI_PlanarReflection : MonoBehaviour
{
	public struct ReflectionCamera
	{
		public Camera reflector;

		public Camera source;

		public PIDI_PlanarReflection owner;

		public ReflectionCamera(Camera v_ref, Camera v_source, PIDI_PlanarReflection v_owner)
		{
			reflector = v_ref;
			source = v_source;
			owner = v_owner;
		}
	}

	private static ReflectionCamera[] v_reflectionPool = new ReflectionCamera[0];

	private List<ReflectionCamera> v_reflectionCameras = new List<ReflectionCamera>();

	public RenderingPath v_renderingPath = RenderingPath.Forward;

	public RenderTexture v_staticTexture;

	public bool b_displayGizmos;

	public bool b_updateInEditMode = true;

	public bool b_useFixedUptade;

	public bool b_ignoreSkybox;

	public Color v_backdropColor = Color.blue;

	public int v_timesPerSecond = 30;

	public bool b_useGlobalSettings = true;

	public static int v_maxResolution = 4096;

	public static int v_forcedQualityDowngrade = 0;

	public bool b_useExplicitCameras;

	public bool b_useExplicitNormal;

	public bool b_localNormal;

	public UnityEngine.Vector3 v_explicitNormal = new UnityEngine.Vector3(0f, 0f, 1f);

	public Shader depthShader;

	public bool b_forcePower2 = true;

	public bool b_useScreenResolution;

	public bool b_useDynamicResolution;

	public int v_dynRes;

	public float v_resMultiplier = 1f;

	public UnityEngine.Vector2 v_minMaxDistance = new UnityEngine.Vector2(1f, 15f);

	public bool b_useReflectionsPool = true;

	public int v_poolSize = 1;

	public float v_disableOnDistance = -1f;

	public UnityEngine.Vector2 v_resolution = new UnityEngine.Vector2(1024f, 1024f);

	private UnityEngine.Vector2 v_oldRes;

	public int v_pixelLights = -1;

	public LayerMask v_reflectLayers = -1;

	public bool b_simplifyLandscapes = true;

	public int v_agressiveness = 2;

	public float v_shadowDistance = 25f;

	public float v_clippingOffset;

	public float v_nearClipModifier;

	public float v_farClipModifier = 100f;

	public bool b_safeClipping = true;

	public bool b_realOblique = true;

	public UnityEngine.Vector2 v_mirrorSize = new UnityEngine.Vector2(0f, 0f);

	private RenderTexture v_oldRend;

	private RenderTexture v_oldDepth;

	private float v_nextUpdate;

	private UnityEngine.Vector3 v_surfaceNormal;

	private static bool b_isRendering;

	private RenderTexture v_refTexture;

	private float v_oldDistance;

	private float v_distance;

	private Camera v_reflectionCam;

	private Camera v_srcCamera;

	private bool b_oldUsePool;

	private bool b_willRender;

	public Mesh v_defaultMesh;

	public Material v_defaultMat;

	[SerializeField]
	private Material v_matInstance;

	public void OnEnable()
	{
		GenerateReflectionsPool(0);
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().enabled = true;
		}
	}

	public void Update()
	{
		if (Application.isPlaying && b_useFixedUptade)
		{
			if (Time.realtimeSinceStartup > v_nextUpdate && b_willRender)
			{
				b_willRender = false;
				v_nextUpdate = Time.realtimeSinceStartup + 1f / (float)v_timesPerSecond;
			}
			else if (Time.realtimeSinceStartup > v_nextUpdate)
			{
				b_willRender = true;
			}
		}
	}

	public void OnWillRenderObject()
	{
		b_realOblique = b_safeClipping;
		if (v_oldRend != v_staticTexture)
		{
			v_refTexture = null;
			v_oldRend = v_staticTexture;
		}
		if (((bool)GetComponent<PIDI_ForceUpdate>() || !GetComponent<MeshFilter>() || !GetComponent<MeshFilter>().sharedMesh) && !v_staticTexture)
		{
			return;
		}
		if (!Application.isPlaying && !b_updateInEditMode)
		{
			ClearReflectors();
		}
		else
		{
			if (Application.isPlaying && b_useFixedUptade && !b_willRender)
			{
				return;
			}
			if (!base.enabled || !GetComponent<Renderer>())
			{
				ClearReflectors();
			}
			else
			{
				if (b_isRendering)
				{
					return;
				}
				v_srcCamera = Camera.current;
				if (!v_srcCamera)
				{
					ClearReflectors();
					return;
				}
				UnityEngine.Quaternion quaternion = v_srcCamera.transform.rotation;
				if (v_srcCamera.transform.eulerAngles.x == 0f || v_srcCamera.transform.eulerAngles.z == 0f)
				{
					v_srcCamera.transform.Rotate(0.0001f, 0f, 0.0001f);
				}
				if (b_useExplicitCameras)
				{
					if ((bool)v_srcCamera.transform.Find("ExplicitCamera"))
					{
						v_srcCamera = v_srcCamera.transform.Find("ExplicitCamera").GetComponent<Camera>();
					}
					else if (Camera.current.cameraType != CameraType.SceneView)
					{
						return;
					}
				}
				if (base.transform.InverseTransformPoint(v_srcCamera.transform.position).z < 0f && !b_useExplicitNormal)
				{
					return;
				}
				v_distance = UnityEngine.Vector3.Distance(v_srcCamera.transform.position, base.transform.position);
				if (b_useScreenResolution)
				{
					v_resolution = new UnityEngine.Vector2((float)Screen.width * v_resMultiplier, (float)Screen.height * v_resMultiplier);
					if (b_useDynamicResolution)
					{
						if (v_distance < v_minMaxDistance.x)
						{
							v_resolution *= 1f;
						}
						else if (v_disableOnDistance > v_minMaxDistance.y)
						{
							v_resolution *= 0.25f;
						}
						else
						{
							v_resolution *= 0.5f;
						}
					}
					else
					{
						v_resolution *= Mathf.Pow(0.5f, v_dynRes);
					}
				}
				v_surfaceNormal = ((!b_useExplicitNormal) ? base.transform.forward : (b_localNormal ? base.transform.TransformDirection(v_explicitNormal) : v_explicitNormal));
				UnityEngine.Vector3 position = base.transform.position;
				float num = UnityEngine.Vector3.Dot(v_srcCamera.transform.forward, v_surfaceNormal);
				if (v_disableOnDistance > 0f && v_distance > v_disableOnDistance)
				{
					return;
				}
				b_isRendering = true;
				if (b_oldUsePool != b_useReflectionsPool)
				{
					GenerateReflectionsPool(0);
					ClearReflectors();
					b_oldUsePool = b_useReflectionsPool;
				}
				if (b_useReflectionsPool && v_reflectionPool.Length < v_poolSize)
				{
					GenerateReflectionsPool(v_poolSize);
				}
				if (Mathf.Abs(num) > 1f)
				{
					num %= 1f;
				}
				float farClipPlane = v_srcCamera.farClipPlane;
				float nearClipPlane = v_srcCamera.nearClipPlane;
				UnityEngine.Vector2 vector = v_mirrorSize;
				if (!b_safeClipping)
				{
					vector *= 0f;
				}
				float[] array = new float[5];
				UnityEngine.Vector3 inNormal = -v_srcCamera.transform.forward;
				new UnityEngine.Plane(-v_surfaceNormal, v_srcCamera.transform.position).Raycast(new Ray(position, v_surfaceNormal), out array[0]);
				array[0] = Mathf.Abs(array[0]);
				UnityEngine.Plane plane = new UnityEngine.Plane(inNormal, v_srcCamera.transform.position);
				plane.Raycast(new Ray(base.transform.TransformPoint(vector.x * -0.5f, 0f, 0f), v_surfaceNormal), out array[1]);
				plane.Raycast(new Ray(base.transform.TransformPoint(vector.x * 0.5f, 0f, 0f), v_surfaceNormal), out array[2]);
				plane.Raycast(new Ray(base.transform.TransformPoint(0f, vector.y * 0.5f, 0f), v_surfaceNormal), out array[3]);
				plane.Raycast(new Ray(base.transform.TransformPoint(0f, vector.y * -0.5f, 0f), v_surfaceNormal), out array[4]);
				float num2 = 0f;
				if (!b_safeClipping)
				{
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = Mathf.Abs(array[i]);
					}
					num2 = Mathf.Min(array);
					v_srcCamera.nearClipPlane = ((Mathf.Abs(num) > 0f) ? ((num2 + v_nearClipModifier) * Mathf.Abs(num)) : (num2 + v_nearClipModifier));
					v_srcCamera.farClipPlane = v_farClipModifier + v_srcCamera.nearClipPlane;
				}
				else
				{
					num2 = Mathf.Abs((num >= 0f) ? Mathf.Min(array) : Mathf.Max(array));
					v_srcCamera.nearClipPlane = ((Mathf.Abs(num) > 0f) ? ((num2 + v_nearClipModifier) * Mathf.Abs(num)) : (num2 + v_nearClipModifier));
					v_srcCamera.farClipPlane = v_farClipModifier + v_srcCamera.nearClipPlane;
				}
				GetReflectionCamera(v_srcCamera, out v_reflectionCam);
				if (v_reflectionCam == null)
				{
					b_isRendering = false;
					return;
				}
				SynchCameras(v_srcCamera, v_reflectionCam);
				float w = 0f - UnityEngine.Vector3.Dot(v_surfaceNormal, position) - v_clippingOffset;
				UnityEngine.Vector4 v_refPlane = new UnityEngine.Vector4(v_surfaceNormal.x, v_surfaceNormal.y, v_surfaceNormal.z, w);
				UnityEngine.Matrix4x4 v_refMatrix = UnityEngine.Matrix4x4.zero;
				CalculateReflectionMatrix(ref v_refMatrix, v_refPlane);
				v_reflectionCam.transform.position = v_refMatrix.MultiplyPoint(v_srcCamera.transform.position);
				v_reflectionCam.worldToCameraMatrix = v_srcCamera.worldToCameraMatrix * v_refMatrix;
				if (b_safeClipping && b_realOblique)
				{
					v_reflectionCam.projectionMatrix = v_srcCamera.CalculateObliqueMatrix(CameraSpacePlane(v_reflectionCam, base.transform.position, v_surfaceNormal, 1f));
					v_reflectionCam.nearClipPlane += v_nearClipModifier;
					v_reflectionCam.farClipPlane = v_reflectionCam.nearClipPlane + v_farClipModifier;
				}
				else
				{
					v_reflectionCam.projectionMatrix = v_srcCamera.projectionMatrix;
				}
				v_reflectionCam.cullingMask = -17 & v_reflectLayers.value;
				v_reflectionCam.renderingPath = v_renderingPath;
				float shadowDistance = QualitySettings.shadowDistance;
				if (v_shadowDistance > -1f)
				{
					QualitySettings.shadowDistance = v_shadowDistance;
				}
				int pixelLightCount = QualitySettings.pixelLightCount;
				if (v_pixelLights > -1)
				{
					QualitySettings.pixelLightCount = v_pixelLights;
				}
				GL.invertCulling = true;
				v_reflectionCam.targetTexture = v_refTexture;
				float[] array2 = new float[Terrain.activeTerrains.Length];
				float[] array3 = new float[array2.Length];
				float[] array4 = new float[array2.Length];
				if (b_simplifyLandscapes)
				{
					for (int j = 0; j < array2.Length; j++)
					{
						array2[j] = Terrain.activeTerrains[j].heightmapPixelError;
						array3[j] = Terrain.activeTerrains[j].detailObjectDistance;
						array4[j] = Terrain.activeTerrains[j].treeBillboardDistance;
						Terrain.activeTerrains[j].heightmapPixelError = array2[j] * ((float)v_agressiveness * 0.25f);
						Terrain.activeTerrains[j].detailObjectDistance = ((v_agressiveness > 8) ? 0f : Mathf.Clamp01(array3[j] / (float)v_agressiveness));
						Terrain.activeTerrains[j].treeBillboardDistance = ((v_agressiveness > 8) ? 0f : Mathf.Clamp(array4[j] / (float)v_agressiveness, 0f, 1000f));
					}
				}
				v_reflectionCam.useOcclusionCulling = false;
				v_reflectionCam.depthTextureMode = DepthTextureMode.None;
				v_reflectionCam.Render();
				bool flag = false;
				Material[] sharedMaterials = GetComponent<Renderer>().sharedMaterials;
				foreach (Material material in sharedMaterials)
				{
					if (material != null && material.HasProperty("_ReflectionDepth"))
					{
						flag = true;
					}
				}
				if ((bool)v_oldDepth && v_oldDepth.IsCreated())
				{
					RenderTexture.ReleaseTemporary(v_oldDepth);
					v_oldDepth = null;
				}
				if (!v_oldDepth && flag)
				{
					v_oldDepth = RenderTexture.GetTemporary((int)v_resolution.x, (int)v_resolution.y, 0, RenderTextureFormat.ARGB32);
					v_reflectionCam.targetTexture = v_oldDepth;
					v_reflectionCam.clearFlags = CameraClearFlags.Color;
					v_reflectionCam.backgroundColor = Color.green;
					if ((bool)depthShader)
					{
						Shader.SetGlobalVector("_DepthPlaneOrigin", new UnityEngine.Vector4(base.transform.position.x, base.transform.position.y, base.transform.position.z));
						Shader.SetGlobalVector("_DepthPlaneNormal", new UnityEngine.Vector4(0f - v_surfaceNormal.x, 0f - v_surfaceNormal.y, 0f - v_surfaceNormal.z));
						v_reflectionCam.renderingPath = RenderingPath.Forward;
						v_reflectionCam.RenderWithShader(depthShader, "");
					}
				}
				if (b_simplifyLandscapes)
				{
					for (int l = 0; l < array2.Length; l++)
					{
						Terrain.activeTerrains[l].heightmapPixelError = array2[l];
						Terrain.activeTerrains[l].detailObjectDistance = array3[l];
						Terrain.activeTerrains[l].treeBillboardDistance = array4[l];
					}
				}
				v_reflectionCam.transform.position = v_srcCamera.transform.position;
				v_reflectionCam.transform.eulerAngles = new UnityEngine.Vector3(0f, v_srcCamera.transform.eulerAngles.y, v_srcCamera.transform.eulerAngles.z);
				v_reflectionCam.enabled = false;
				QualitySettings.shadowDistance = shadowDistance;
				QualitySettings.pixelLightCount = pixelLightCount;
				v_srcCamera.farClipPlane = farClipPlane;
				v_srcCamera.nearClipPlane = nearClipPlane;
				GL.invertCulling = false;
				Material[] sharedMaterials2 = GetComponent<Renderer>().sharedMaterials;
				if (sharedMaterials2.Length != 0 && GetComponent<Renderer>().sharedMaterial != null)
				{
					UnityEngine.Matrix4x4 matrix4x = UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3.one * 0.5f, UnityEngine.Quaternion.identity, UnityEngine.Vector3.one * 0.5f);
					UnityEngine.Vector3 lossyScale = base.transform.lossyScale;
					UnityEngine.Matrix4x4 matrix4x2 = base.transform.localToWorldMatrix * UnityEngine.Matrix4x4.Scale(new UnityEngine.Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z));
					matrix4x2 = matrix4x * v_srcCamera.projectionMatrix * v_srcCamera.worldToCameraMatrix * matrix4x2;
					sharedMaterials = sharedMaterials2;
					foreach (Material material2 in sharedMaterials)
					{
						if (material2 != null && material2.HasProperty("_ReflectionTex"))
						{
							material2.SetMatrix("_ProjMatrix", matrix4x2);
							material2.SetTexture("_ReflectionTex", v_refTexture);
							material2.SetTexture("_ReflectionDepth", v_oldDepth);
							if (material2.HasProperty("_ChromaKeyColor"))
							{
								material2.SetColor("_ChromaKeyColor", b_ignoreSkybox ? v_backdropColor : Color.clear);
							}
						}
					}
				}
				v_srcCamera.transform.rotation = quaternion;
				b_isRendering = false;
				if (b_useReflectionsPool)
				{
					ReleaseCamera();
				}
			}
		}
	}

	public void OnWillRenderObject(Camera withCamera)
	{
		b_realOblique = b_safeClipping;
		if (v_oldRend != v_staticTexture)
		{
			v_refTexture = null;
			v_oldRend = v_staticTexture;
		}
		if ((!GetComponent<MeshFilter>() || !GetComponent<MeshFilter>().sharedMesh) && !v_staticTexture)
		{
			return;
		}
		if (!Application.isPlaying && !b_updateInEditMode)
		{
			ClearReflectors();
		}
		else
		{
			if (Application.isPlaying && b_useFixedUptade && !b_willRender)
			{
				return;
			}
			if (!base.enabled || !GetComponent<Renderer>())
			{
				ClearReflectors();
			}
			else
			{
				if (b_isRendering)
				{
					return;
				}
				v_srcCamera = withCamera;
				if (!v_srcCamera)
				{
					ClearReflectors();
					return;
				}
				UnityEngine.Quaternion quaternion = v_srcCamera.transform.rotation;
				if (v_srcCamera.transform.eulerAngles.x == 0f || v_srcCamera.transform.eulerAngles.z == 0f)
				{
					v_srcCamera.transform.Rotate(0.0001f, 0f, 0.0001f);
				}
				v_distance = UnityEngine.Vector3.Distance(v_srcCamera.transform.position, base.transform.position);
				if (b_useScreenResolution)
				{
					v_resolution = new UnityEngine.Vector2((float)Screen.width * v_resMultiplier, (float)Screen.height * v_resMultiplier);
					if (b_useDynamicResolution)
					{
						if (v_distance < v_minMaxDistance.x)
						{
							v_resolution *= 1f;
						}
						else if (v_disableOnDistance > v_minMaxDistance.y)
						{
							v_resolution *= 0.25f;
						}
						else
						{
							v_resolution *= 0.5f;
						}
					}
					else
					{
						v_resolution *= Mathf.Pow(0.5f, v_dynRes);
					}
				}
				v_surfaceNormal = ((!b_useExplicitNormal) ? base.transform.forward : (b_localNormal ? base.transform.TransformDirection(v_explicitNormal) : v_explicitNormal));
				UnityEngine.Vector3 position = base.transform.position;
				float num = UnityEngine.Vector3.Dot(v_srcCamera.transform.forward, v_surfaceNormal);
				if (v_disableOnDistance > 0f && v_distance > v_disableOnDistance)
				{
					return;
				}
				b_isRendering = true;
				if (b_oldUsePool != b_useReflectionsPool)
				{
					GenerateReflectionsPool(0);
					ClearReflectors();
					b_oldUsePool = b_useReflectionsPool;
				}
				if (b_useReflectionsPool && v_reflectionPool.Length < v_poolSize)
				{
					GenerateReflectionsPool(v_poolSize);
				}
				if (Mathf.Abs(num) > 1f)
				{
					num %= 1f;
				}
				float farClipPlane = v_srcCamera.farClipPlane;
				float nearClipPlane = v_srcCamera.nearClipPlane;
				UnityEngine.Vector2 vector = v_mirrorSize;
				if (!b_safeClipping)
				{
					vector *= 0f;
				}
				float[] array = new float[5];
				UnityEngine.Vector3 inNormal = -v_srcCamera.transform.forward;
				new UnityEngine.Plane(-v_surfaceNormal, v_srcCamera.transform.position).Raycast(new Ray(position, v_surfaceNormal), out array[0]);
				array[0] = Mathf.Abs(array[0]);
				UnityEngine.Plane plane = new UnityEngine.Plane(inNormal, v_srcCamera.transform.position);
				plane.Raycast(new Ray(base.transform.TransformPoint(vector.x * -0.5f, 0f, 0f), v_surfaceNormal), out array[1]);
				plane.Raycast(new Ray(base.transform.TransformPoint(vector.x * 0.5f, 0f, 0f), v_surfaceNormal), out array[2]);
				plane.Raycast(new Ray(base.transform.TransformPoint(0f, vector.y * 0.5f, 0f), v_surfaceNormal), out array[3]);
				plane.Raycast(new Ray(base.transform.TransformPoint(0f, vector.y * -0.5f, 0f), v_surfaceNormal), out array[4]);
				float num2 = 0f;
				if (!b_safeClipping)
				{
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = Mathf.Abs(array[i]);
					}
					num2 = Mathf.Min(array);
					v_srcCamera.nearClipPlane = ((Mathf.Abs(num) > 0f) ? ((num2 + v_nearClipModifier) * Mathf.Abs(num)) : (num2 + v_nearClipModifier));
					v_srcCamera.farClipPlane = v_farClipModifier + v_srcCamera.nearClipPlane;
				}
				else
				{
					num2 = Mathf.Abs((num >= 0f) ? Mathf.Min(array) : Mathf.Max(array));
					v_srcCamera.nearClipPlane = ((Mathf.Abs(num) > 0f) ? ((num2 + v_nearClipModifier) * Mathf.Abs(num)) : (num2 + v_nearClipModifier));
					v_srcCamera.farClipPlane = v_farClipModifier + v_srcCamera.nearClipPlane;
				}
				GetReflectionCamera(v_srcCamera, out v_reflectionCam);
				if (v_reflectionCam == null)
				{
					b_isRendering = false;
					return;
				}
				SynchCameras(v_srcCamera, v_reflectionCam);
				float w = 0f - UnityEngine.Vector3.Dot(v_surfaceNormal, position) - v_clippingOffset;
				UnityEngine.Vector4 v_refPlane = new UnityEngine.Vector4(v_surfaceNormal.x, v_surfaceNormal.y, v_surfaceNormal.z, w);
				UnityEngine.Matrix4x4 v_refMatrix = UnityEngine.Matrix4x4.zero;
				CalculateReflectionMatrix(ref v_refMatrix, v_refPlane);
				v_reflectionCam.transform.position = v_refMatrix.MultiplyPoint(v_srcCamera.transform.position);
				v_reflectionCam.worldToCameraMatrix = v_srcCamera.worldToCameraMatrix * v_refMatrix;
				if (b_safeClipping && b_realOblique)
				{
					v_reflectionCam.projectionMatrix = v_srcCamera.CalculateObliqueMatrix(CameraSpacePlane(v_reflectionCam, base.transform.position, v_surfaceNormal, 1f));
					v_reflectionCam.nearClipPlane += v_nearClipModifier;
					v_reflectionCam.farClipPlane = v_reflectionCam.nearClipPlane + v_farClipModifier;
				}
				else
				{
					v_reflectionCam.projectionMatrix = v_srcCamera.projectionMatrix;
				}
				v_reflectionCam.cullingMask = -17 & v_reflectLayers.value;
				v_reflectionCam.renderingPath = v_renderingPath;
				float shadowDistance = QualitySettings.shadowDistance;
				if (v_shadowDistance > -1f)
				{
					QualitySettings.shadowDistance = v_shadowDistance;
				}
				int pixelLightCount = QualitySettings.pixelLightCount;
				if (v_pixelLights > -1)
				{
					QualitySettings.pixelLightCount = v_pixelLights;
				}
				GL.invertCulling = true;
				v_reflectionCam.targetTexture = v_refTexture;
				float[] array2 = new float[Terrain.activeTerrains.Length];
				float[] array3 = new float[array2.Length];
				float[] array4 = new float[array2.Length];
				if (b_simplifyLandscapes)
				{
					for (int j = 0; j < array2.Length; j++)
					{
						array2[j] = Terrain.activeTerrains[j].heightmapPixelError;
						array3[j] = Terrain.activeTerrains[j].detailObjectDistance;
						array4[j] = Terrain.activeTerrains[j].treeBillboardDistance;
						Terrain.activeTerrains[j].heightmapPixelError = array2[j] * ((float)v_agressiveness * 0.25f);
						Terrain.activeTerrains[j].detailObjectDistance = ((v_agressiveness > 8) ? 0f : Mathf.Clamp01(array3[j] / (float)v_agressiveness));
						Terrain.activeTerrains[j].treeBillboardDistance = ((v_agressiveness > 8) ? 0f : Mathf.Clamp(array4[j] / (float)v_agressiveness, 0f, 1000f));
					}
				}
				v_reflectionCam.useOcclusionCulling = false;
				v_reflectionCam.Render();
				bool flag = false;
				Material[] sharedMaterials = GetComponent<Renderer>().sharedMaterials;
				foreach (Material material in sharedMaterials)
				{
					if (material != null && material.HasProperty("_ReflectionDepth"))
					{
						flag = true;
					}
				}
				if ((bool)v_oldDepth && v_oldDepth.IsCreated())
				{
					RenderTexture.ReleaseTemporary(v_oldDepth);
					v_oldDepth = null;
				}
				if (!v_oldDepth && flag)
				{
					v_oldDepth = RenderTexture.GetTemporary((int)v_resolution.x, (int)v_resolution.y);
					v_reflectionCam.targetTexture = v_oldDepth;
					v_reflectionCam.clearFlags = CameraClearFlags.Color;
					v_reflectionCam.backgroundColor = Color.green;
					if ((bool)depthShader)
					{
						Shader.SetGlobalVector("_DepthPlaneOrigin", new UnityEngine.Vector4(base.transform.position.x, base.transform.position.y, base.transform.position.z));
						Shader.SetGlobalVector("_DepthPlaneNormal", new UnityEngine.Vector4(0f - v_surfaceNormal.x, 0f - v_surfaceNormal.y, 0f - v_surfaceNormal.z));
						v_reflectionCam.RenderWithShader(depthShader, "");
					}
				}
				if (b_simplifyLandscapes)
				{
					for (int l = 0; l < array2.Length; l++)
					{
						Terrain.activeTerrains[l].heightmapPixelError = array2[l];
						Terrain.activeTerrains[l].detailObjectDistance = array3[l];
						Terrain.activeTerrains[l].treeBillboardDistance = array4[l];
					}
				}
				v_reflectionCam.transform.position = v_srcCamera.transform.position;
				v_reflectionCam.transform.eulerAngles = new UnityEngine.Vector3(0f, v_srcCamera.transform.eulerAngles.y, v_srcCamera.transform.eulerAngles.z);
				v_reflectionCam.enabled = false;
				QualitySettings.shadowDistance = shadowDistance;
				QualitySettings.pixelLightCount = pixelLightCount;
				v_srcCamera.farClipPlane = farClipPlane;
				v_srcCamera.nearClipPlane = nearClipPlane;
				GL.invertCulling = false;
				Material[] sharedMaterials2 = GetComponent<Renderer>().sharedMaterials;
				if (sharedMaterials2.Length != 0 && GetComponent<Renderer>().sharedMaterial != null)
				{
					UnityEngine.Matrix4x4 matrix4x = UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3.one * 0.5f, UnityEngine.Quaternion.identity, UnityEngine.Vector3.one * 0.5f);
					UnityEngine.Vector3 lossyScale = base.transform.lossyScale;
					UnityEngine.Matrix4x4 matrix4x2 = base.transform.localToWorldMatrix * UnityEngine.Matrix4x4.Scale(new UnityEngine.Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z));
					matrix4x2 = matrix4x * v_srcCamera.projectionMatrix * v_srcCamera.worldToCameraMatrix * matrix4x2;
					sharedMaterials = sharedMaterials2;
					foreach (Material material2 in sharedMaterials)
					{
						if (material2 != null && material2.HasProperty("_ReflectionTex"))
						{
							material2.SetMatrix("_ProjMatrix", matrix4x2);
							material2.SetTexture("_ReflectionTex", v_refTexture);
							if (material2.HasProperty("_ChromaKeyColor"))
							{
								material2.SetColor("_ChromaKeyColor", b_ignoreSkybox ? v_backdropColor : Color.clear);
							}
						}
					}
				}
				v_srcCamera.transform.rotation = quaternion;
				b_isRendering = false;
				if (b_useReflectionsPool)
				{
					ReleaseCamera();
				}
			}
		}
	}

	public void OnDrawGizmos()
	{
		if (b_displayGizmos)
		{
			Gizmos.matrix = UnityEngine.Matrix4x4.TRS(base.transform.position, b_useExplicitNormal ? UnityEngine.Quaternion.FromToRotation(base.transform.up, b_localNormal ? base.transform.TransformDirection(v_explicitNormal) : v_explicitNormal) : base.transform.rotation, UnityEngine.Vector3.one);
			Gizmos.color = new Color(0f, 0f, 1f, 0.35f);
			Gizmos.DrawCube(UnityEngine.Vector3.zero, new UnityEngine.Vector3(v_mirrorSize.x, v_mirrorSize.y, 0.08f));
			Gizmos.color = Color.cyan;
			Gizmos.matrix = UnityEngine.Matrix4x4.identity;
			Gizmos.DrawRay(new Ray(base.transform.position, (!b_useExplicitNormal) ? base.transform.forward : (b_localNormal ? base.transform.TransformDirection(v_explicitNormal) : v_explicitNormal)));
		}
	}

	public static void GenerateReflectionsPool(int v_size)
	{
		ReflectionCamera[] array = v_reflectionPool;
		for (int i = 0; i < array.Length; i++)
		{
			ReflectionCamera reflectionCamera = array[i];
			if (reflectionCamera.reflector != null)
			{
				UnityEngine.Object.DestroyImmediate(reflectionCamera.reflector.GetComponent<FlareLayer>());
				UnityEngine.Object.DestroyImmediate(reflectionCamera.reflector.gameObject);
			}
		}
		v_reflectionPool = new ReflectionCamera[v_size];
		for (int j = 0; j < v_size; j++)
		{
			v_reflectionPool[j] = default(ReflectionCamera);
			if ((bool)GameObject.Find("Pooled Reflector " + j))
			{
				v_reflectionPool[j].reflector = GameObject.Find("Pooled Reflector " + j).GetComponent<Camera>();
				continue;
			}
			GameObject gameObject = new GameObject("Pooled Reflector " + j, typeof(Camera), typeof(Skybox));
			v_reflectionPool[j].reflector = gameObject.GetComponent<Camera>();
			v_reflectionPool[j].reflector.enabled = false;
			if (!v_reflectionPool[j].reflector.GetComponent<FlareLayer>())
			{
				v_reflectionPool[j].reflector.gameObject.AddComponent<FlareLayer>();
			}
			v_reflectionPool[j].reflector.transform.position = UnityEngine.Vector3.zero;
			v_reflectionPool[j].reflector.transform.rotation = UnityEngine.Quaternion.identity;
			v_reflectionPool[j].reflector.gameObject.hideFlags = HideFlags.HideAndDontSave;
		}
	}

	private void GetReflectionCamera(Camera v_source, out Camera v_reflected)
	{
		v_reflected = null;
		if (b_useReflectionsPool)
		{
			for (int i = 0; i < v_reflectionPool.Length; i++)
			{
				if (v_reflectionPool[i].owner == null)
				{
					v_reflectionPool[i].owner = this;
					v_reflected = v_reflectionPool[i].reflector;
					v_reflectionPool[i].source = v_source;
				}
			}
		}
		else
		{
			foreach (ReflectionCamera v_reflectionCamera in v_reflectionCameras)
			{
				if (v_reflectionCamera.source == v_source)
				{
					v_reflected = v_reflectionCamera.reflector;
					v_reflected.enabled = false;
				}
			}
			if (v_reflected == null)
			{
				GameObject gameObject = new GameObject("RefCamera " + GetInstanceID() + " from " + v_source.GetInstanceID(), typeof(Camera), typeof(Skybox));
				v_reflected = gameObject.GetComponent<Camera>();
				v_reflected.enabled = false;
				if (!v_reflected.gameObject.GetComponent<FlareLayer>())
				{
					v_reflected.gameObject.AddComponent<FlareLayer>();
				}
				v_reflected.transform.position = UnityEngine.Vector3.zero;
				v_reflected.transform.rotation = UnityEngine.Quaternion.Euler(0.0001f, 0f, 0.001f);
				v_reflected.gameObject.hideFlags = HideFlags.HideAndDontSave;
				v_reflectionCameras.Add(new ReflectionCamera(v_reflected, v_source, null));
			}
		}
		v_reflected.orthographic = false;
		UnityEngine.Vector2 vector = v_resolution;
		if (b_useGlobalSettings)
		{
			vector.x = (int)(vector.x / Mathf.Pow(2f, Mathf.Clamp(v_forcedQualityDowngrade, 0, 3)));
			vector.x = (int)Mathf.Clamp(vector.x, 16f, v_maxResolution);
			vector.y = (int)(vector.y / Mathf.Pow(2f, Mathf.Clamp(v_forcedQualityDowngrade, 0, 3)));
			vector.y = (int)Mathf.Clamp(vector.y, 16f, v_maxResolution);
		}
		if ((bool)GetComponent<MeshFilter>() && (bool)GetComponent<MeshFilter>().sharedMesh && !v_staticTexture && (!v_refTexture || v_oldRes != vector))
		{
			if ((bool)v_refTexture)
			{
				UnityEngine.Object.DestroyImmediate(v_refTexture);
			}
			v_refTexture = new RenderTexture((int)vector.x, (int)vector.y, 16);
			v_refTexture.name = "RenderTextureFrom " + GetInstanceID();
			v_refTexture.isPowerOfTwo = true;
			v_refTexture.hideFlags = HideFlags.DontSave;
			v_oldRes = vector;
		}
		else if ((bool)v_staticTexture)
		{
			v_refTexture = v_staticTexture;
		}
	}

	public void ReleaseCamera()
	{
		for (int i = 0; i < v_reflectionPool.Length; i++)
		{
			if (v_reflectionPool[i].owner == this)
			{
				v_reflectionPool[i].owner = null;
			}
		}
	}

	private void SynchCameras(Camera v_source, Camera v_reflected)
	{
		if (v_reflected == null)
		{
			return;
		}
		v_reflected.clearFlags = (b_ignoreSkybox ? CameraClearFlags.Color : v_source.clearFlags);
		v_reflected.backgroundColor = (b_ignoreSkybox ? v_backdropColor : v_source.backgroundColor);
		if (v_source.clearFlags == CameraClearFlags.Skybox)
		{
			Skybox component = v_source.GetComponent<Skybox>();
			Skybox component2 = v_reflected.GetComponent<Skybox>();
			if (!component || !component.material)
			{
				component2.enabled = false;
			}
			else
			{
				component2.material = component.material;
				component2.enabled = true;
			}
		}
		v_reflected.nearClipPlane = v_source.nearClipPlane;
		v_reflected.farClipPlane = v_source.farClipPlane;
		v_reflected.orthographic = v_source.orthographic;
		v_reflected.orthographicSize = v_source.orthographicSize;
		v_reflected.fieldOfView = v_source.fieldOfView;
		v_reflected.aspect = v_source.aspect;
	}

	private void CalculateReflectionMatrix(ref UnityEngine.Matrix4x4 v_refMatrix, UnityEngine.Vector4 v_refPlane)
	{
		v_refMatrix.m00 = 1f - 2f * v_refPlane[0] * v_refPlane[0];
		v_refMatrix.m01 = -2f * v_refPlane[0] * v_refPlane[1];
		v_refMatrix.m02 = -2f * v_refPlane[0] * v_refPlane[2];
		v_refMatrix.m03 = -2f * v_refPlane[3] * v_refPlane[0];
		v_refMatrix.m10 = -2f * v_refPlane[1] * v_refPlane[0];
		v_refMatrix.m11 = 1f - 2f * v_refPlane[1] * v_refPlane[1];
		v_refMatrix.m12 = -2f * v_refPlane[1] * v_refPlane[2];
		v_refMatrix.m13 = -2f * v_refPlane[3] * v_refPlane[1];
		v_refMatrix.m20 = -2f * v_refPlane[2] * v_refPlane[0];
		v_refMatrix.m21 = -2f * v_refPlane[2] * v_refPlane[1];
		v_refMatrix.m22 = 1f - 2f * v_refPlane[2] * v_refPlane[2];
		v_refMatrix.m23 = -2f * v_refPlane[3] * v_refPlane[2];
		v_refMatrix.m30 = 0f;
		v_refMatrix.m31 = 0f;
		v_refMatrix.m32 = 0f;
		v_refMatrix.m33 = 1f;
	}

	private UnityEngine.Vector4 CameraSpacePlane(Camera v_cam, UnityEngine.Vector3 v_pos, UnityEngine.Vector3 v_normal, float sideSign)
	{
		UnityEngine.Vector3 point = v_pos + v_normal * v_clippingOffset;
		UnityEngine.Matrix4x4 worldToCameraMatrix = v_cam.worldToCameraMatrix;
		UnityEngine.Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		UnityEngine.Vector3 rhs = worldToCameraMatrix.MultiplyVector(v_normal).normalized * sideSign;
		return new UnityEngine.Vector4(rhs.x, rhs.y, rhs.z, 0f - UnityEngine.Vector3.Dot(lhs, rhs));
	}

	public void ClearReflectors()
	{
		if ((bool)v_oldDepth && v_oldDepth.IsCreated())
		{
			RenderTexture.ReleaseTemporary(v_oldDepth);
			v_oldDepth = null;
		}
		if ((bool)v_refTexture && v_refTexture != v_staticTexture)
		{
			UnityEngine.Object.DestroyImmediate(v_refTexture);
		}
		if (b_useReflectionsPool)
		{
			v_reflectionPool = new ReflectionCamera[0];
			foreach (ReflectionCamera v_reflectionCamera in v_reflectionCameras)
			{
				if (v_reflectionCamera.reflector != null)
				{
					UnityEngine.Object.DestroyImmediate(v_reflectionCamera.reflector.gameObject);
				}
			}
			v_reflectionCameras.Clear();
			return;
		}
		foreach (ReflectionCamera v_reflectionCamera2 in v_reflectionCameras)
		{
			if (v_reflectionCamera2.reflector != null)
			{
				UnityEngine.Object.DestroyImmediate(v_reflectionCamera2.reflector.gameObject);
			}
		}
		v_reflectionCameras.Clear();
	}

	public void OnDisable()
	{
		ClearReflectors();
		GC.Collect();
	}

	public bool IsObjectReflectionVisible(Transform targetObject, Camera fromCamera)
	{
		if ((bool)targetObject && (bool)fromCamera)
		{
			float w = 0f - UnityEngine.Vector3.Dot(v_surfaceNormal, base.transform.position) - v_clippingOffset;
			UnityEngine.Vector4 v_refPlane = new UnityEngine.Vector4(v_surfaceNormal.x, v_surfaceNormal.y, v_surfaceNormal.z, w);
			UnityEngine.Matrix4x4 v_refMatrix = UnityEngine.Matrix4x4.zero;
			CalculateReflectionMatrix(ref v_refMatrix, v_refPlane);
			UnityEngine.Vector3 vector = v_refMatrix.MultiplyPoint(targetObject.position);
			Ray ray = new Ray(fromCamera.transform.position, (vector - fromCamera.transform.position).normalized);
			float enter = 0f;
			if (new UnityEngine.Plane(v_surfaceNormal, base.transform.position).Raycast(ray, out enter) && (bool)GetComponent<MeshRenderer>() && GetComponent<MeshRenderer>().bounds.Contains(ray.GetPoint(enter)))
			{
				return true;
			}
		}
		return false;
	}
}
public class HoloLens_ForcedUpdate : MonoBehaviour
{
	public PIDI_PlanarReflection[] reflections = new PIDI_PlanarReflection[0];

	public void OnPreRender()
	{
		for (int i = 0; i < reflections.Length; i++)
		{
			reflections[i].OnWillRenderObject(GetComponent<Camera>());
		}
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private UnityEngine.Vector3[] inputDirection = new UnityEngine.Vector3[2];

	public static UnityEngine.Vector3 pointerPosition { get; set; }

	public static UnityEngine.Quaternion pointerRotation { get; set; }

	public static UnityEngine.Vector3 elbowPosition { get; set; }

	public static UnityEngine.Quaternion elbowRotation { get; set; }

	public static UnityEngine.Vector3 wristPosition { get; set; }

	public static UnityEngine.Quaternion wristRotation { get; set; }

	public static UnityEngine.Vector3 shoulderPosition { get; set; }

	public static UnityEngine.Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = UnityEngine.Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = UnityEngine.Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = UnityEngine.Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = UnityEngine.Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void UpdateTest()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		ElbowHeight = 0f;
		ElbowDepth = 0f;
		PointerTiltAngle = 0f;
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		ElbowHeight = 0f;
		ElbowDepth = 0f;
		PointerTiltAngle = 0f;
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private UnityEngine.Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return UnityEngine.Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		UnityEngine.Quaternion quaternion = default(UnityEngine.Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		UnityEngine.Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			UnityEngine.Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * UnityEngine.Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = UnityEngine.Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(UnityEngine.Vector3);
			}
			UnityEngine.Quaternion quaternion2 = UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		UnityEngine.Vector3 vector;
		UnityEngine.Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new UnityEngine.Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new UnityEngine.Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new UnityEngine.Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new UnityEngine.Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new UnityEngine.Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new UnityEngine.Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new UnityEngine.Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new UnityEngine.Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = UnityEngine.Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new UnityEngine.Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new UnityEngine.Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = UnityEngine.Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new UnityEngine.Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new UnityEngine.Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new UnityEngine.Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new UnityEngine.Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new UnityEngine.Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = UnityEngine.Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = UnityEngine.Quaternion.Euler(new UnityEngine.Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new UnityEngine.Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new UnityEngine.Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new UnityEngine.Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new UnityEngine.Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new UnityEngine.Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public UnityEngine.Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new UnityEngine.Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public UnityEngine.Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new UnityEngine.Vector3(0f, 0f, 0f);
	}

	public UnityEngine.Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new UnityEngine.Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = UnityEngine.Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= UnityEngine.Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= UnityEngine.Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= UnityEngine.Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= UnityEngine.Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public UnityEngine.Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new UnityEngine.Vector3(0f, 0f, 0f);
	}

	public UnityEngine.Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new UnityEngine.Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new UnityEngine.Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new UnityEngine.Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new UnityEngine.Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new UnityEngine.Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(UnityEngine.Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(UnityEngine.Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = UnityEngine.Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? UnityEngine.Vector3.one : UnityEngine.Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private UnityEngine.Vector2 currPos;

	private UnityEngine.Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private UnityEngine.Vector2 lastTouchDownPos;

	private UnityEngine.Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private UnityEngine.Vector2 vecOrigin = UnityEngine.Vector2.zero;

	private UnityEngine.Vector2 vecOriginNeo2 = new UnityEngine.Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		UnityEngine.Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				UnityEngine.Vector2 vector2 = new UnityEngine.Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		UnityEngine.Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				UnityEngine.Vector2 vector2 = new UnityEngine.Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(UnityEngine.Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new UnityEngine.Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("用户自定义，非演示demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("商品码支付" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:请先登录}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new UnityEngine.Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		UnityEngine.Debug.Log("调用login回调:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用pay回调:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("调用userInfo回调:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("无接收该Message的控件");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "网络异常");
		mydic.Add("10000", "登录成功");
		mydic.Add("10001", "用户未登陆");
		mydic.Add("10002", "请输入正确金额");
		mydic.Add("10003", "登陆过期，请重新登陆");
		mydic.Add("11000", "商户验证成功");
		mydic.Add("11001", "商户验证失败");
		mydic.Add("11002", "用户验证参数错误或请求过期");
		mydic.Add("11003", "商户未验证");
		mydic.Add("12000", "支付成功");
		mydic.Add("12001", "支付失败");
		mydic.Add("12003", "P币不足");
		mydic.Add("12004", "余额可用");
		mydic.Add("13000", "生成订单");
		mydic.Add("13001", "获取数据失败");
		mydic.Add("13002", "生成订单失败");
		mydic.Add("14000", "查询订单成功");
		mydic.Add("14001", "订单不存在/有误");
		mydic.Add("14002", "用户取消支付操作");
		mydic.Add("15000", "未输入商品信息");
		mydic.Add("15001", "未输入预付ID");
		mydic.Add("15002", "请输入Pico支付订单号或商户订单号");
		mydic.Add("NOAUTH", "商户无此接口权限");
		mydic.Add("SYSTEMERROR", "系统错误");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID不存在");
		mydic.Add("MCHID_NOT_EXIST", "MCHID不存在");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_id和mch_id不匹配ID");
		mydic.Add("LACK_PARAMS", "缺少参数");
		mydic.Add("SIGNERROR", "签名错误");
		mydic.Add("NO_DATA", "没有查询到数据");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public UnityEngine.Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public UnityEngine.Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public UnityEngine.Vector3 leftEyeOffset;

	[HideInInspector]
	public UnityEngine.Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public UnityEngine.Matrix4x4 leftEyeView;

	[HideInInspector]
	public UnityEngine.Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public UnityEngine.Vector3 neckOffset = new UnityEngine.Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new UnityEngine.Vector2(w, h);
	}

	public UnityEngine.Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new UnityEngine.Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new UnityEngine.Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new UnityEngine.Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new UnityEngine.Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != UnityEngine.Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(UnityEngine.Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new UnityEngine.Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new UnityEngine.Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new UnityEngine.Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new UnityEngine.Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new UnityEngine.Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new UnityEngine.Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new UnityEngine.Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != UnityEngine.Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, UnityEngine.Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, UnityEngine.Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, UnityEngine.Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		UnityEngine.Vector3[] array = new UnityEngine.Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new UnityEngine.Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		UnityEngine.Matrix4x4 identity = UnityEngine.Matrix4x4.identity;
		identity.SetTRS(UnityEngine.Vector3.left * num, UnityEngine.Quaternion.identity, UnityEngine.Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		UnityEngine.Matrix4x4 identity2 = UnityEngine.Matrix4x4.identity;
		identity2.SetTRS(UnityEngine.Vector3.right * num, UnityEngine.Quaternion.identity, UnityEngine.Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private UnityEngine.Matrix4x4 realProj = UnityEngine.Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.beginCameraRendering += MyPreRender;
			RenderPipelineManager.endCameraRendering += MyPostRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.beginCameraRendering -= MyPreRender;
			RenderPipelineManager.endCameraRendering -= MyPostRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = UnityEngine.Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new UnityEngine.Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new UnityEngine.Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new UnityEngine.Vector3(0f, 1f, 0f));
		GL.Vertex(new UnityEngine.Vector3(0.005f, 1f, 0f));
		GL.Vertex(new UnityEngine.Vector3(0.005f, 0f, 0f));
		GL.Vertex(new UnityEngine.Vector3(0f, 0f, 0f));
		GL.Vertex(new UnityEngine.Vector3(0.995f, 1f, 0f));
		GL.Vertex(new UnityEngine.Vector3(1f, 1f, 0f));
		GL.Vertex(new UnityEngine.Vector3(1f, 0f, 0f));
		GL.Vertex(new UnityEngine.Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		UnityEngine.Vector3 vector = UnityEngine.Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public UnityEngine.Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = UnityEngine.Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int i = 0; i < Pvr_UnitySDKEyeOverlay.Instances.Count; i++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[i];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public UnityEngine.Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return UnityEngine.Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return UnityEngine.Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		UnityEngine.Vector3 zero = UnityEngine.Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		UnityEngine.Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = UnityEngine.Vector3.Dot(foveatedGazeDirection, UnityEngine.Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		UnityEngine.Vector3[] array = new UnityEngine.Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new UnityEngine.Vector3(0f - num, 0f - num2, z);
		array[1] = new UnityEngine.Vector3(num, 0f - num2, z);
		array[2] = new UnityEngine.Vector3(0f - num, num2, z);
		array[3] = new UnityEngine.Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new UnityEngine.Vector3[4]
		{
			-UnityEngine.Vector3.forward,
			-UnityEngine.Vector3.forward,
			-UnityEngine.Vector3.forward,
			-UnityEngine.Vector3.forward
		};
		mesh.uv = new UnityEngine.Vector2[4]
		{
			new UnityEngine.Vector2(0f, 0f),
			new UnityEngine.Vector2(1f, 0f),
			new UnityEngine.Vector2(0f, 1f),
			new UnityEngine.Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		MethodInfo[] methods = typeof(AndroidDevice).GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			if (methodInfo.Name == "VRDeviceUseOwnSurface")
			{
				PLOG.I("Use VRDeviceUseOwnSurface");
				methodInfo.Invoke(null, null);
				return true;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public UnityEngine.Matrix4x4[] MVMatrixs = new UnityEngine.Matrix4x4[2];

	public UnityEngine.Vector3[] ModelScales = new UnityEngine.Vector3[2];

	public UnityEngine.Quaternion[] ModelRotations = new UnityEngine.Quaternion[2];

	public UnityEngine.Vector3[] ModelTranslations = new UnityEngine.Vector3[2];

	public UnityEngine.Quaternion[] CameraRotations = new UnityEngine.Quaternion[2];

	public UnityEngine.Vector3[] CameraTranslations = new UnityEngine.Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public UnityEngine.Vector4 colorScale = UnityEngine.Vector4.one;

	public UnityEngine.Vector4 colorOffset = UnityEngine.Vector4.zero;

	private UnityEngine.Vector4 overlayLayerColorScaleDefault = UnityEngine.Vector4.one;

	private UnityEngine.Vector4 overlayLayerColorOffsetDefault = UnityEngine.Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				UnityEngine.Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(UnityEngine.Vector4 scale, UnityEngine.Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public UnityEngine.Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public UnityEngine.Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private UnityEngine.Vector2 prefinger1 = new UnityEngine.Vector2(0f, 0f);

	private UnityEngine.Vector2 prefinger2 = new UnityEngine.Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new UnityEngine.Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new UnityEngine.Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		UnityEngine.Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			UnityEngine.Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, UnityEngine.Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		UnityEngine.Vector2 position = Input.touches[0].position;
		UnityEngine.Vector2 position2 = Input.touches[1].position;
		if (UnityEngine.Vector2.Distance(prefinger1, position) > 2f && UnityEngine.Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public UnityEngine.Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		UnityEngine.Vector2 vector = new UnityEngine.Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private UnityEngine.Matrix4x4[] unity_StereoMatrixP = new UnityEngine.Matrix4x4[2];

	private UnityEngine.Matrix4x4[] unity_StereoMatrixInvP = new UnityEngine.Matrix4x4[2];

	private static UnityEngine.Matrix4x4[] unity_StereoWorldToCamera = new UnityEngine.Matrix4x4[2];

	private UnityEngine.Matrix4x4[] unity_StereoCameraToWorld = new UnityEngine.Matrix4x4[2];

	private UnityEngine.Matrix4x4[] unity_StereoMatrixVP = new UnityEngine.Matrix4x4[2];

	private UnityEngine.Vector3[] eyesOffset = new UnityEngine.Vector3[2];

	private static UnityEngine.Matrix4x4[] eyesOffsetMatrix = new UnityEngine.Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new UnityEngine.Vector4[2]
		{
			new UnityEngine.Vector4(1f, 1f, 0f, 0f),
			new UnityEngine.Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		UnityEngine.Vector3 vector = new UnityEngine.Vector3((0f - res) / 2f, 0f, 0f);
		UnityEngine.Vector3 vector2 = new UnityEngine.Vector3(res / 2f, 0f, 0f);
		UnityEngine.Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = UnityEngine.Quaternion.identity;
		UnityEngine.Vector3 vector4 = vector - vector3;
		UnityEngine.Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = UnityEngine.Matrix4x4.TRS(vector4, UnityEngine.Quaternion.identity, UnityEngine.Vector3.one);
		eyesOffsetMatrix[1] = UnityEngine.Matrix4x4.TRS(vector5, UnityEngine.Quaternion.identity, UnityEngine.Vector3.one);
	}

	public void SetEyeProjection()
	{
		UnityEngine.Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		UnityEngine.Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static UnityEngine.Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = UnityEngine.Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static UnityEngine.Matrix4x4 MakeProjection(float n, float f)
	{
		UnityEngine.Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		UnityEngine.Matrix4x4 zero = UnityEngine.Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(UnityEngine.Matrix4x4 left, UnityEngine.Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static UnityEngine.Matrix4x4[] GetStereoWorldToCameraMat()
	{
		UnityEngine.Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		UnityEngine.Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		UnityEngine.Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		UnityEngine.Vector4[] values = new UnityEngine.Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		UnityEngine.Matrix4x4 transpose = (UnityEngine.Matrix4x4.LookAt(UnityEngine.Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * UnityEngine.Matrix4x4.Scale(new UnityEngine.Vector3(1f, 1f, -1f))).transpose;
		UnityEngine.Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		UnityEngine.Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		UnityEngine.Matrix4x4[] values = new UnityEngine.Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		UnityEngine.Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new UnityEngine.Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private UnityEngine.Vector3 startingPosition;

	private UnityEngine.Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private UnityEngine.Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(UnityEngine.Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(UnityEngine.Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		UnityEngine.Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	public static bool picoCheck;

	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		picoCheck = false;
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			picoCheck = true;
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			UnityEngine.Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			UnityEngine.Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = UnityEngine.Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			UnityEngine.Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly UnityEngine.Matrix4x4 flipZ = UnityEngine.Matrix4x4.Scale(new UnityEngine.Vector3(1f, 1f, -1f));

	public UnityEngine.Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public UnityEngine.Vector3 Position { get; protected set; }

	public UnityEngine.Quaternion Orientation { get; protected set; }

	public UnityEngine.Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(UnityEngine.Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(UnityEngine.Vector3 position, UnityEngine.Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(UnityEngine.Vector3 position, UnityEngine.Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = UnityEngine.Matrix4x4.TRS(position, orientation, UnityEngine.Vector3.one);
	}

	protected void Set(UnityEngine.Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = UnityEngine.Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private UnityEngine.Quaternion NormalizeQuaternion(ref UnityEngine.Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private UnityEngine.Quaternion UnityQuaternion = UnityEngine.Quaternion.identity;

	private UnityEngine.Vector3 UnityPosition = UnityEngine.Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(UnityEngine.Vector3.zero, UnityEngine.Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * UnityEngine.Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * UnityEngine.Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new UnityEngine.Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = UnityEngine.Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private UnityEngine.Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		UnityEngine.Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new UnityEngine.Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public UnityEngine.Vector2 hotspot = new UnityEngine.Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new UnityEngine.Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<UnityEngine.Vector3> vertices;

	private List<UnityEngine.Vector2> uv;

	private List<UnityEngine.Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<UnityEngine.Vector3>();
		uv = new List<UnityEngine.Vector2>();
		normals = new List<UnityEngine.Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		UnityEngine.Vector3[] array = new UnityEngine.Vector3[faceData.Count];
		UnityEngine.Vector2[] array2 = new UnityEngine.Vector2[faceData.Count];
		UnityEngine.Vector3[] array3 = new UnityEngine.Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new UnityEngine.Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new UnityEngine.Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new UnityEngine.Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
			}
			else if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			return;
		}
		foreach (RaycastResult result in results)
		{
			if (!ValidElement(result.gameObject))
			{
				continue;
			}
			GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject != null)
			{
				Selectable component = gameObject.GetComponent<Selectable>();
				if ((bool)component)
				{
					Navigation navigation = default(Navigation);
					navigation.mode = Navigation.Mode.None;
					component.navigation = navigation;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
				pointer.hoveringElement = gameObject;
				pointer.pointerEventData.pointerCurrentRaycast = result;
				pointer.pointerEventData.pointerEnter = gameObject;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void HoverNew(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != UnityEngine.Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			UnityEngine.Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new UnityEngine.Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, UnityEngine.Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = UnityEngine.Vector3.zero;
			obj.transform.localRotation = UnityEngine.Quaternion.identity;
			obj.transform.localScale = UnityEngine.Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			if (draggablePanelCreation != null)
			{
				StopCoroutine(draggablePanelCreation);
			}
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected UnityEngine.Vector3 startPosition;

	protected UnityEngine.Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected UnityEngine.Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = UnityEngine.Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			UnityEngine.Vector3 forward = transform.forward;
			float num = UnityEngine.Vector3.Dot(forward, transform.position - ray.origin) / UnityEngine.Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				UnityEngine.Vector3 point = ray.GetPoint(num);
				UnityEngine.Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual UnityEngine.Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual UnityEngine.Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly UnityEngine.Vector3 neckOffset = new UnityEngine.Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public UnityEngine.Matrix4x4 headView;

	[HideInInspector]
	public UnityEngine.Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public UnityEngine.Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public UnityEngine.Matrix4x4 leftEyeProj;

	[HideInInspector]
	public UnityEngine.Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public UnityEngine.Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public UnityEngine.Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static UnityEngine.Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		UnityEngine.Matrix4x4 zero = UnityEngine.Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		UnityEngine.Vector2 vector = new UnityEngine.Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = UnityEngine.Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new UnityEngine.Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new UnityEngine.Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		UnityEngine.Quaternion quaternion = UnityEngine.Quaternion.Euler(mouseY, mouseX, mouseZ);
		UnityEngine.Matrix4x4 matrix = UnityEngine.Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * UnityEngine.Vector3.up) * neckModelScale, quaternion, UnityEngine.Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ！");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume：" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number：" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number：" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness：" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
[ExecuteInEditMode]
[ImageEffectAllowedInSceneView]
public class CameraBloomEffect : MonoBehaviour
{
	private const int BoxDownPrefilterPass = 0;

	private const int BoxDownPass = 1;

	private const int BoxUpPass = 2;

	private const int ApplyBloomPass = 3;

	private const int DebugBloomPass = 4;

	private readonly RenderTexture[] _textures = new RenderTexture[16];

	[NonSerialized]
	private Material _bloom;

	private static readonly int Filter = Shader.PropertyToID("_Filter");

	private static readonly int Intensity = Shader.PropertyToID("_Intensity");

	private static readonly int SourceTex = Shader.PropertyToID("_SourceTex");

	[SerializeField]
	private Shader bloomShader;

	[Range(0f, 10f)]
	[SerializeField]
	public float intensity = 0.6f;

	[Range(1f, 16f)]
	[SerializeField]
	public int iterations = 8;

	[Range(0f, 10f)]
	[SerializeField]
	public float threshold = 0.9f;

	[Range(0f, 1f)]
	[SerializeField]
	public float softThreshold;

	[FormerlySerializedAs("Force activate HDR")]
	[SerializeField]
	public bool forceActivateHdr = true;

	[SerializeField]
	private bool DebugMode;

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		InitBloomIfNecessary();
		float thresholdProduct = threshold * softThreshold;
		UnityEngine.Vector4 filter = CreateImageFilter(thresholdProduct);
		UpdateShaderFilterAndIntensity(filter);
		int num = source.width / 2;
		int num2 = source.height / 2;
		RenderTextureFormat format = source.format;
		RenderTexture renderTexture = (_textures[0] = RenderTexture.GetTemporary(num, num2, 0, format));
		Graphics.Blit(source, renderTexture, _bloom, 0);
		RenderTexture renderTexture2 = renderTexture;
		int i;
		for (i = 1; i < iterations; i++)
		{
			num /= 2;
			num2 /= 2;
			if (num2 < 2)
			{
				break;
			}
			renderTexture = (_textures[i] = RenderTexture.GetTemporary(num, num2, 0, format));
			Graphics.Blit(renderTexture2, renderTexture, _bloom, 1);
			renderTexture2 = renderTexture;
		}
		for (i -= 2; i >= 0; i--)
		{
			renderTexture = _textures[i];
			_textures[i] = null;
			Graphics.Blit(renderTexture2, renderTexture, _bloom, 2);
			RenderTexture.ReleaseTemporary(renderTexture2);
			renderTexture2 = renderTexture;
		}
		if (DebugMode)
		{
			Graphics.Blit(renderTexture2, destination, _bloom, 4);
		}
		else
		{
			_bloom.SetTexture(SourceTex, source);
			Graphics.Blit(renderTexture2, destination, _bloom, 3);
		}
		RenderTexture.ReleaseTemporary(renderTexture2);
	}

	private void InitBloomIfNecessary()
	{
		if (_bloom == null)
		{
			_bloom = new Material(bloomShader)
			{
				hideFlags = HideFlags.HideAndDontSave
			};
		}
	}

	private void UpdateShaderFilterAndIntensity(UnityEngine.Vector4 filter)
	{
		_bloom.SetVector(Filter, filter);
		_bloom.SetFloat(Intensity, Mathf.GammaToLinearSpace(intensity));
	}

	private UnityEngine.Vector4 CreateImageFilter(float thresholdProduct)
	{
		UnityEngine.Vector4 result = default(UnityEngine.Vector4);
		result.x = threshold;
		result.y = result.x - thresholdProduct;
		result.z = 2f * thresholdProduct;
		float num = 1E-05f;
		result.w = 0.25f / (thresholdProduct + num);
		return result;
	}

	public void Start()
	{
		TryForceActivateHdr();
	}

	private void TryForceActivateHdr()
	{
	}
}
public class ActivationEventScript : MonoBehaviour
{
	public bool globalSubscription;

	public bool localSubscription;

	public RayfireRigid localRigidComponent;

	private void OnEnable()
	{
		if (globalSubscription)
		{
			RFActivationEvent.GlobalEvent += GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.activationEvent.LocalEvent += LocalMethod;
		}
	}

	private void OnDisable()
	{
		if (globalSubscription)
		{
			RFActivationEvent.GlobalEvent -= GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.activationEvent.LocalEvent -= LocalMethod;
		}
	}

	private void LocalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Local activation: " + rigid.name + " was just activated");
	}

	private void GlobalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Global activation: " + rigid.name + " was just activated");
	}
}
public class AddRigidComponent : MonoBehaviour
{
	public GameObject targetObject;

	private void Update()
	{
		if (Input.GetKeyDown("space") && targetObject != null)
		{
			RayfireRigid rayfireRigid = targetObject.AddComponent<RayfireRigid>();
			rayfireRigid.simulationType = SimType.Dynamic;
			rayfireRigid.demolitionType = DemolitionType.Runtime;
			rayfireRigid.objectType = ObjectType.Mesh;
			rayfireRigid.Initialize();
		}
	}
}
public class ApplyDamageScript : MonoBehaviour
{
	public RayfireRigid rigid;

	public float damageValue = 50f;

	public Transform damagePoint;

	public float damageRadius = 2f;

	private void Update()
	{
		if (Input.GetKeyDown("space") && rigid != null)
		{
			UnityEngine.Vector3 vector = UnityEngine.Vector3.zero;
			if (damagePoint != null)
			{
				vector = damagePoint.position;
			}
			rigid.ApplyDamage(damageValue, vector, damageRadius);
		}
	}
}
public class DemolitionEventScript : MonoBehaviour
{
	public bool globalSubscription;

	public bool localSubscription;

	public RayfireRigid localRigidComponent;

	private void OnEnable()
	{
		if (globalSubscription)
		{
			RFDemolitionEvent.GlobalEvent += GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.demolitionEvent.LocalEvent += LocalMethod;
		}
	}

	private void OnDisable()
	{
		if (globalSubscription)
		{
			RFActivationEvent.GlobalEvent -= GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.demolitionEvent.LocalEvent -= LocalMethod;
		}
	}

	private void LocalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Local demolition: " + rigid.name + " was just demolished and created " + rigid.fragments.Count + " fragments");
		UnityEngine.Debug.Log("Contact point: " + rigid.limitations.contactPoint);
		base.transform.position = rigid.limitations.contactPoint;
	}

	private void GlobalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Global demolition: " + rigid.name + " was just demolished and created " + rigid.fragments.Count + " fragments");
		UnityEngine.Debug.Log("Contact point: " + rigid.limitations.contactPoint);
		base.transform.position = rigid.limitations.contactPoint;
	}
}
public class MenuSceneLoader : MonoBehaviour
{
	public GameObject menuUI;

	private GameObject m_Go;

	private void Awake()
	{
		if (m_Go == null)
		{
			m_Go = UnityEngine.Object.Instantiate(menuUI);
		}
	}
}
public class PauseMenu : MonoBehaviour
{
	private Toggle m_MenuToggle;

	private float m_TimeScaleRef = 1f;

	private float m_VolumeRef = 1f;

	private bool m_Paused;

	private void Awake()
	{
		m_MenuToggle = GetComponent<Toggle>();
	}

	private void MenuOn()
	{
		m_TimeScaleRef = Time.timeScale;
		Time.timeScale = 0f;
		m_VolumeRef = AudioListener.volume;
		AudioListener.volume = 0f;
		m_Paused = true;
	}

	public void MenuOff()
	{
		Time.timeScale = m_TimeScaleRef;
		AudioListener.volume = m_VolumeRef;
		m_Paused = false;
	}

	public void OnMenuStatusChange()
	{
		if (m_MenuToggle.isOn && !m_Paused)
		{
			MenuOn();
		}
		else if (!m_MenuToggle.isOn && m_Paused)
		{
			MenuOff();
		}
	}
}
public class SceneAndURLLoader : MonoBehaviour
{
	private PauseMenu m_PauseMenu;

	private void Awake()
	{
		m_PauseMenu = GetComponentInChildren<PauseMenu>();
	}

	public void SceneLoad(string sceneName)
	{
		m_PauseMenu.MenuOff();
		SceneManager.LoadScene(sceneName);
	}

	public void LoadURL(string url)
	{
		Application.OpenURL(url);
	}
}
public class CameraSwitch : MonoBehaviour
{
	public GameObject[] objects;

	public Text text;

	private int m_CurrentActiveObject;

	private void OnEnable()
	{
		text.text = objects[m_CurrentActiveObject].name;
	}

	public void NextCamera()
	{
		int num = ((m_CurrentActiveObject + 1 < objects.Length) ? (m_CurrentActiveObject + 1) : 0);
		for (int i = 0; i < objects.Length; i++)
		{
			objects[i].SetActive(i == num);
		}
		m_CurrentActiveObject = num;
		text.text = objects[m_CurrentActiveObject].name;
	}
}
public class LevelReset : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public void OnPointerClick(PointerEventData data)
	{
		SceneManager.LoadScene(SceneManager.GetSceneAt(0).name);
	}
}
public class PlotController : MonoBehaviour
{
	public List<Transform> plotPoints;

	private Material highlightMaterial;

	public int displayWindowSize = 300;

	private void Start()
	{
		plotPoints = new List<Transform>();
		float x = base.transform.Find("Point/BasePoint").localScale.x;
		for (int i = 0; i < displayWindowSize; i++)
		{
			Transform transform = (UnityEngine.Object.Instantiate(Resources.Load("Point"), base.transform) as GameObject).transform;
			float x2 = (float)(displayWindowSize / 2 * -1) * x + (float)i * x;
			transform.localPosition = new UnityEngine.Vector3(x2, transform.localPosition.y, transform.localPosition.z);
			plotPoints.Add(transform);
		}
	}

	public void updatePlot(List<SpectralFluxInfo> pointInfo, int curIndex = -1)
	{
		if (plotPoints.Count < displayWindowSize - 1)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		if (curIndex > 0)
		{
			num2 = Mathf.Max(0, curIndex - displayWindowSize / 2);
			num3 = Mathf.Min(curIndex + displayWindowSize / 2, pointInfo.Count - 1);
		}
		else
		{
			num2 = Mathf.Max(0, pointInfo.Count - displayWindowSize - 1);
			num3 = Mathf.Min(num2 + displayWindowSize, pointInfo.Count);
		}
		for (int i = num2; i < num3; i++)
		{
			int index = num;
			num++;
			Transform point = plotPoints[index].Find("FluxPoint");
			Transform point2 = plotPoints[index].Find("ThreshPoint");
			Transform point3 = plotPoints[index].Find("PeakPoint");
			if (pointInfo[i].isPeak)
			{
				setPointHeight(point3, pointInfo[i].spectralFlux);
				setPointHeight(point, 0f);
			}
			else
			{
				setPointHeight(point, pointInfo[i].spectralFlux);
				setPointHeight(point3, 0f);
			}
			setPointHeight(point2, pointInfo[i].threshold);
		}
	}

	public void setPointHeight(Transform point, float height)
	{
		float num = 0.06f;
		point.localPosition = new UnityEngine.Vector3(point.localPosition.x, height * num, point.localPosition.z);
	}
}
public class SongController : MonoBehaviour
{
	private float[] realTimeSpectrum;

	private SpectralFluxAnalyzer realTimeSpectralFluxAnalyzer;

	private PlotController realTimePlotController;

	private int numChannels;

	private int numTotalSamples;

	private int sampleRate;

	private float clipLength;

	private float[] multiChannelSamples;

	private SpectralFluxAnalyzer preProcessedSpectralFluxAnalyzer;

	private PlotController preProcessedPlotController;

	private AudioSource audioSource;

	public bool realTimeSamples = true;

	public bool preProcessSamples;

	private void Start()
	{
		audioSource = GetComponent<AudioSource>();
		if (realTimeSamples)
		{
			realTimeSpectrum = new float[1024];
			realTimeSpectralFluxAnalyzer = new SpectralFluxAnalyzer();
			realTimePlotController = GameObject.Find("RealtimePlot").GetComponent<PlotController>();
			sampleRate = AudioSettings.outputSampleRate;
		}
		if (preProcessSamples)
		{
			preProcessedSpectralFluxAnalyzer = new SpectralFluxAnalyzer();
			preProcessedPlotController = GameObject.Find("PreprocessedPlot").GetComponent<PlotController>();
			multiChannelSamples = new float[audioSource.clip.samples * audioSource.clip.channels];
			numChannels = audioSource.clip.channels;
			numTotalSamples = audioSource.clip.samples;
			clipLength = audioSource.clip.length;
			sampleRate = audioSource.clip.frequency;
			audioSource.clip.GetData(multiChannelSamples, 0);
			UnityEngine.Debug.Log("GetData done");
			Thread thread = new Thread(getFullSpectrumThreaded);
			UnityEngine.Debug.Log("Starting Background Thread");
			thread.Start();
		}
	}

	private void Update()
	{
		if (realTimeSamples)
		{
			audioSource.GetSpectrumData(realTimeSpectrum, 0, FFTWindow.BlackmanHarris);
			realTimeSpectralFluxAnalyzer.analyzeSpectrum(realTimeSpectrum, audioSource.time);
			realTimePlotController.updatePlot(realTimeSpectralFluxAnalyzer.spectralFluxSamples);
		}
		if (preProcessSamples)
		{
			int curIndex = getIndexFromTime(audioSource.time) / 1024;
			preProcessedPlotController.updatePlot(preProcessedSpectralFluxAnalyzer.spectralFluxSamples, curIndex);
		}
	}

	public int getIndexFromTime(float curTime)
	{
		float num = clipLength / (float)numTotalSamples;
		return Mathf.FloorToInt(curTime / num);
	}

	public float getTimeFromIndex(int index)
	{
		return 1f / (float)sampleRate * (float)index;
	}

	public void getFullSpectrumThreaded()
	{
		try
		{
			float[] array = new float[numTotalSamples];
			int num = 0;
			float num2 = 0f;
			for (int i = 0; i < multiChannelSamples.Length; i++)
			{
				num2 += multiChannelSamples[i];
				if ((i + 1) % numChannels == 0)
				{
					array[num] = num2 / (float)numChannels;
					num++;
					num2 = 0f;
				}
			}
			UnityEngine.Debug.Log("Combine Channels done");
			UnityEngine.Debug.Log(array.Length);
			int num3 = 1024;
			int num4 = array.Length / num3;
			FFT fFT = new FFT();
			fFT.Initialize((uint)num3);
			UnityEngine.Debug.Log($"Processing {num4} time domain samples for FFT");
			double[] array2 = new double[num3];
			for (int j = 0; j < num4; j++)
			{
				Array.Copy(array, j * num3, array2, 0, num3);
				double[] array3 = DSP.Window.Coefficients(DSP.Window.Type.Hanning, (uint)num3);
				double[] timeSeries = DSP.Math.Multiply(array2, array3);
				double b = DSP.Window.ScaleFactor.Signal(array3);
				double[] a = DSP.ConvertComplex.ToMagnitude(fFT.Execute(timeSeries));
				a = DSP.Math.Multiply(a, b);
				float time = getTimeFromIndex(j) * (float)num3;
				preProcessedSpectralFluxAnalyzer.analyzeSpectrum(Array.ConvertAll(a, (double x) => (float)x), time);
			}
			UnityEngine.Debug.Log("Spectrum Analysis done");
			UnityEngine.Debug.Log("Background Thread Completed");
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log(ex.ToString());
		}
	}
}
public class SpectralFluxInfo
{
	public float time;

	public float spectralFlux;

	public float threshold;

	public float prunedSpectralFlux;

	public bool isPeak;

	public float peakScore;
}
public class SpectralFluxAnalyzer
{
	private int numSamples = MusicDataCenter.SampleSize;

	private float thresholdMultiplier = 1.5f;

	private int thresholdWindowSize = 50;

	public List<SpectralFluxInfo> spectralFluxSamples;

	private float[] curSpectrum;

	private float[] prevSpectrum;

	private int indexToProcess;

	public SpectralFluxAnalyzer()
	{
		spectralFluxSamples = new List<SpectralFluxInfo>();
		indexToProcess = thresholdWindowSize / 2;
		curSpectrum = new float[numSamples];
		prevSpectrum = new float[numSamples];
	}

	public void setCurSpectrum(float[] spectrum)
	{
		curSpectrum.CopyTo(prevSpectrum, 0);
		spectrum.CopyTo(curSpectrum, 0);
	}

	public void analyzeSpectrum(float[] spectrum, float time)
	{
		setCurSpectrum(spectrum);
		SpectralFluxInfo spectralFluxInfo = new SpectralFluxInfo();
		spectralFluxInfo.time = time;
		spectralFluxInfo.spectralFlux = calculateRectifiedSpectralFlux();
		spectralFluxSamples.Add(spectralFluxInfo);
		if (spectralFluxSamples.Count >= thresholdWindowSize)
		{
			spectralFluxSamples[indexToProcess].threshold = getFluxThreshold(indexToProcess);
			spectralFluxSamples[indexToProcess].prunedSpectralFlux = getPrunedSpectralFlux(indexToProcess);
			int num = indexToProcess - 1;
			if (isPeak(num))
			{
				spectralFluxSamples[num].isPeak = true;
				spectralFluxSamples[num].peakScore = getPeakScore(num);
			}
			indexToProcess++;
		}
		else
		{
			UnityEngine.Debug.Log($"Not ready yet.  At spectral flux sample size of {spectralFluxSamples.Count} growing to {thresholdWindowSize}");
		}
	}

	private float calculateRectifiedSpectralFlux()
	{
		float num = 0f;
		for (int i = 0; i < numSamples; i++)
		{
			num += Mathf.Max(0f, curSpectrum[i] - prevSpectrum[i]);
		}
		return num;
	}

	private float getFluxThreshold(int spectralFluxIndex)
	{
		int num = Mathf.Max(0, spectralFluxIndex - thresholdWindowSize / 2);
		int num2 = Mathf.Min(spectralFluxSamples.Count - 1, spectralFluxIndex + thresholdWindowSize / 2);
		float num3 = 0f;
		for (int i = num; i < num2; i++)
		{
			num3 += spectralFluxSamples[i].spectralFlux;
		}
		return num3 / (float)(num2 - num) * thresholdMultiplier;
	}

	private float getPrunedSpectralFlux(int spectralFluxIndex)
	{
		return Mathf.Max(0f, spectralFluxSamples[spectralFluxIndex].spectralFlux - spectralFluxSamples[spectralFluxIndex].threshold);
	}

	private bool isPeak(int spectralFluxIndex)
	{
		if (spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux > spectralFluxSamples[spectralFluxIndex + 1].prunedSpectralFlux && spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux > spectralFluxSamples[spectralFluxIndex - 1].prunedSpectralFlux)
		{
			return true;
		}
		return false;
	}

	private float getPeakScore(int spectralFluxIndex)
	{
		if (spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux > spectralFluxSamples[spectralFluxIndex + 1].prunedSpectralFlux && spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux > spectralFluxSamples[spectralFluxIndex - 1].prunedSpectralFlux)
		{
			return spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux - spectralFluxSamples[spectralFluxIndex + 1].prunedSpectralFlux + (spectralFluxSamples[spectralFluxIndex].prunedSpectralFlux - spectralFluxSamples[spectralFluxIndex - 1].prunedSpectralFlux);
		}
		return 0f;
	}

	private void logSample(int indexToLog)
	{
		int num = Mathf.Max(0, indexToLog - thresholdWindowSize / 2);
		int num2 = Mathf.Min(spectralFluxSamples.Count - 1, indexToLog + thresholdWindowSize / 2);
		UnityEngine.Debug.Log($"Peak detected at song time {spectralFluxSamples[indexToLog].time} with pruned flux of {spectralFluxSamples[indexToLog].prunedSpectralFlux} ({spectralFluxSamples[indexToLog].spectralFlux} over thresh of {spectralFluxSamples[indexToLog].threshold}).\nThresh calculated on time window of {spectralFluxSamples[num].time}-{spectralFluxSamples[num2].time} ({spectralFluxSamples[num2].time - spectralFluxSamples[num].time} seconds) containing {num2 - num} samples.");
	}
}
public class AudioManager : UnitySingleton<AudioManager>
{
	private UnityWebRequest uwr1;

	private UnityWebRequest uwr2;

	private UnityWebRequest uwr3;

	private UnityWebRequest uwr4;

	public new void Awake()
	{
		base.Awake();
	}

	private void Start()
	{
		IEnumerator routine = loadZiDingYi();
		StartCoroutine(routine);
		IEnumerator routine2 = loadZiDingYiWav();
		StartCoroutine(routine2);
		IEnumerator routine3 = loadZiDingYiFail();
		StartCoroutine(routine3);
		IEnumerator routine4 = loadZiDingYiFailwav();
		StartCoroutine(routine4);
		setVolume(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitSound, "hit");
		setVolume(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound, "hitFail");
	}

	private IEnumerator loadZiDingYi()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound != 1)
		{
			yield break;
		}
		string uri = "file://" + Path.Combine(Application.persistentDataPath, "hit.mp3");
		if (!File.Exists(Path.Combine(Application.persistentDataPath, "hit.mp3")))
		{
			yield break;
		}
		using (uwr1 = UnityWebRequestMultimedia.GetAudioClip(uri, AudioType.MPEG))
		{
			UnityEngine.Debug.Log("start read music:" + DateTime.Now);
			yield return uwr1.SendWebRequest();
			if (uwr1.isNetworkError)
			{
				UnityEngine.Debug.LogError(uwr1.error);
				yield break;
			}
			foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
			{
				if (!componentInChild.gameObject.name.Equals("hit"))
				{
					continue;
				}
				try
				{
					AudioClip content = DownloadHandlerAudioClip.GetContent(uwr1);
					if (content != null)
					{
						componentInChild.GetComponent<AudioSource>().clip = content;
					}
				}
				catch (Exception message)
				{
					UnityEngine.Debug.Log(message);
				}
			}
		}
	}

	private IEnumerator loadZiDingYiWav()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound != 1)
		{
			yield break;
		}
		string uri = "file://" + Path.Combine(Application.persistentDataPath, "hit.wav");
		if (!File.Exists(Path.Combine(Application.persistentDataPath, "hit.wav")))
		{
			yield break;
		}
		using (uwr2 = UnityWebRequestMultimedia.GetAudioClip(uri, AudioType.WAV))
		{
			UnityEngine.Debug.Log("start read music:" + DateTime.Now);
			yield return uwr2.SendWebRequest();
			if (uwr2.isNetworkError)
			{
				UnityEngine.Debug.LogError(uwr2.error);
				yield break;
			}
			foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
			{
				if (!componentInChild.gameObject.name.Equals("hit"))
				{
					continue;
				}
				try
				{
					AudioClip content = DownloadHandlerAudioClip.GetContent(uwr2);
					if (content != null)
					{
						componentInChild.GetComponent<AudioSource>().clip = content;
					}
				}
				catch (Exception message)
				{
					UnityEngine.Debug.Log(message);
				}
			}
		}
	}

	private IEnumerator loadZiDingYiFail()
	{
		string uri = "file://" + Path.Combine(Application.persistentDataPath, "hitFail.mp3");
		if (!File.Exists(Path.Combine(Application.persistentDataPath, "hitFail.mp3")))
		{
			yield break;
		}
		using (uwr3 = UnityWebRequestMultimedia.GetAudioClip(uri, AudioType.MPEG))
		{
			UnityEngine.Debug.Log("start read music:" + DateTime.Now);
			yield return uwr3.SendWebRequest();
			if (uwr3.isNetworkError)
			{
				UnityEngine.Debug.LogError(uwr3.error);
				yield break;
			}
			foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
			{
				if (!componentInChild.gameObject.name.Equals("hitFail"))
				{
					continue;
				}
				try
				{
					AudioClip content = DownloadHandlerAudioClip.GetContent(uwr3);
					if (content != null)
					{
						componentInChild.GetComponent<AudioSource>().clip = content;
					}
				}
				catch (Exception message)
				{
					UnityEngine.Debug.Log(message);
				}
			}
		}
	}

	private IEnumerator loadZiDingYiFailwav()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound != 1)
		{
			yield break;
		}
		string uri = "file://" + Path.Combine(Application.persistentDataPath, "hitFail.wav");
		if (!File.Exists(Path.Combine(Application.persistentDataPath, "hitFail.wav")))
		{
			yield break;
		}
		using (uwr4 = UnityWebRequestMultimedia.GetAudioClip(uri, AudioType.WAV))
		{
			UnityEngine.Debug.Log("start read music:" + DateTime.Now);
			yield return uwr4.SendWebRequest();
			if (uwr4.isNetworkError)
			{
				UnityEngine.Debug.LogError(uwr4.error);
				yield break;
			}
			foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
			{
				if (!componentInChild.gameObject.name.Equals("hitFail"))
				{
					continue;
				}
				try
				{
					AudioClip content = DownloadHandlerAudioClip.GetContent(uwr4);
					if (content != null)
					{
						componentInChild.GetComponent<AudioSource>().clip = content;
					}
				}
				catch (Exception message)
				{
					UnityEngine.Debug.Log(message);
				}
			}
		}
	}

	public void setVolume(int hitSound, string name)
	{
		float volume = 1f;
		if (hitSound == 0)
		{
			volume = 0f;
		}
		if (hitSound == 1)
		{
			volume = 0.3f;
		}
		if (hitSound == 2)
		{
			volume = 0.6f;
		}
		foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
		{
			if (componentInChild.gameObject.name.Equals(name))
			{
				componentInChild.GetComponent<AudioSource>().volume = volume;
				break;
			}
		}
	}

	public AudioSource GetAudioSource(string name)
	{
		foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
		{
			if (componentInChild.gameObject.name.Equals(name))
			{
				return componentInChild.GetComponent<AudioSource>();
			}
		}
		return null;
	}

	private void DisableAll()
	{
		foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
		{
			componentInChild.gameObject.SetActive(value: false);
		}
	}

	public void PlayMusicHit(float speed = -1f)
	{
		float pitch = 1f;
		if (speed > 80f)
		{
			speed = 80f;
		}
		if (speed > 0f)
		{
			pitch = 0.5f + speed * (3f / 160f);
		}
		PlayMusicOnce("hit", pitch);
	}

	public AudioSource PlayMainMusic(string name)
	{
		foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
		{
			if (componentInChild.gameObject.name.Equals(name))
			{
				componentInChild.GetComponent<AudioSource>().Play();
				return componentInChild.GetComponent<AudioSource>();
			}
		}
		return null;
	}

	public void PlayMusicOnce(string name, float pitch = 1f)
	{
		foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
		{
			if (componentInChild.gameObject.name.Equals(name))
			{
				componentInChild.GetComponent<AudioSource>().pitch = pitch;
				componentInChild.GetComponent<AudioSource>().Play();
				break;
			}
		}
	}

	public void StopPlayMusic(string name)
	{
		foreach (Transform componentInChild in base.transform.GetComponentInChildren<Transform>())
		{
			if (componentInChild.gameObject.name.Equals(name))
			{
				componentInChild.GetComponent<AudioSource>().Stop();
				break;
			}
		}
	}
}
public class AudioSourceCommon : MonoBehaviour
{
	public AudioSource pointEnterAudio;

	public static AudioSourceCommon _instance { get; private set; }

	private void Awake()
	{
		_instance = this;
	}

	public void PlayPointEnterAudio(BaseEventData baseEventData)
	{
		pointEnterAudio.Play();
	}

	public static void AttachPointEnterAudio(Transform transform, UnityAction<BaseEventData> outAction = null)
	{
		EventTrigger eventTrigger = transform.gameObject.GetComponent<EventTrigger>();
		if (eventTrigger == null)
		{
			eventTrigger = transform.gameObject.AddComponent<EventTrigger>();
		}
		eventTrigger.triggers = new List<EventTrigger.Entry>();
		EventTrigger.Entry entry = new EventTrigger.Entry();
		entry.eventID = EventTriggerType.PointerEnter;
		entry.callback = new EventTrigger.TriggerEvent();
		UnityAction<BaseEventData> call = _instance.PlayPointEnterAudio;
		entry.callback.AddListener(call);
		if (outAction != null)
		{
			entry.callback.AddListener(outAction);
		}
		eventTrigger.triggers.Add(entry);
	}

	public static void ClearPointEnterAudio(Transform transform)
	{
		EventTrigger eventTrigger = transform.gameObject.GetComponent<EventTrigger>();
		if (eventTrigger == null)
		{
			eventTrigger = transform.gameObject.AddComponent<EventTrigger>();
		}
		eventTrigger.triggers = new List<EventTrigger.Entry>();
	}
}
public class Ball : MonoBehaviour
{
	public class BallCollisionInfo
	{
		public UnityEngine.Vector3 colliderPoint;

		public Blade blade;

		public BallCollisionInfo(UnityEngine.Vector3 colliderPoint, Blade blade)
		{
			this.colliderPoint = colliderPoint;
			this.blade = blade;
		}
	}

	public GameObject ball;

	public Transform waveRayOrigin;

	public bool explosed;

	public float HitDistance = 0.6f;

	public GeneratorLaw.BallInfo ballInfo;

	public UnityEngine.Vector3 target;

	public UnityEngine.Vector3 hitTarget;

	public float speed;

	public GeneratorLaw.BallType ballType;

	public GeneratorLaw.BallDirection ballDirection;

	public bool fly;

	public MainPlayControl mainPlayControl;

	public Transform t1;

	public Transform t2;

	public Transform t3;

	public Transform t4;

	public Transform b1;

	public Transform b2;

	public Transform b3;

	public Transform b4;

	public Transform hipScore;

	public GameObject hipScoreLeft;

	public GameObject hipScoreRight;

	public GameObject hipScoreFail;

	public CubeLarger cubeLarger;

	private Color colorPurple = new Color(1f, 0f, 0.9747953f, 1f);

	private Color colorYellow = new Color(1f, 0.9561809f, 0f, 1f);

	private Color colorBlack = new Color(0.32f, 0.27f, 0.31f, 1f);

	private bool overHitTarget;

	private float bsSlowSpeed;

	public BallFlyPos ballFlyPos;

	public int flyDongHuaStage;

	public static float endDis = 0.1f;

	private float rotateSpeed;

	private float totalChangeFlyTime;

	private float changeFlyStartTime;

	private UnityEngine.Vector3 changeFlyCenter;

	private UnityEngine.Vector3 changeFlystart;

	private UnityEngine.Vector3 changeFlyend;

	public void Explose(UnityEngine.Vector3 colliderPoint, Blade blade, UnityEngine.Plane plane, bool validPlane = true)
	{
		float z = base.transform.rotation.eulerAngles.z;
		hipScore.Rotate(new UnityEngine.Vector3(0f, 0f, 0f - z));
		fly = false;
		if (blade.bladeType == Blade.BladeType.LeftHand)
		{
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 0);
		}
		if (blade.bladeType == Blade.BladeType.RightHand)
		{
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 1);
		}
		int num = RightHitWave(blade, plane, validPlane);
		UnityEngine.Debug.Log("splitScore:" + num);
		BallExploreBase ballExplore = BallExploreBase.getBallExplore(this, colliderPoint, num, blade, plane, validPlane);
		if (RightBlade(blade.bladeType) && num > 0)
		{
			UnitySingleton<DataCenter>.Instance.gamePlayInfo.totalScore += num;
			UnitySingleton<AudioManager>.Instance.PlayMusicHit(blade.waveDistancePerSecond);
			UnitySingleton<DataCenter>.Instance.hitSuccess();
			if (blade.bladeType == Blade.BladeType.LeftHand)
			{
				ballExplore.playLeftExplore();
				mainPlayControl.roundHitManager?.bladeHit(isLeft: true);
				mainPlayControl.stHitManager?.bladeHit(isLeft: true);
			}
			else
			{
				ballExplore.playRightExplore();
				mainPlayControl.roundHitManager?.bladeHit(isLeft: false);
				mainPlayControl.stHitManager?.bladeHit(isLeft: false);
			}
		}
		else
		{
			UnitySingleton<AudioManager>.Instance.PlayMusicOnce("hitFail");
			UnitySingleton<DataCenter>.Instance.AddMissed();
			ballExplore.playBlackExplore();
		}
		UnitySingleton<DataCenter>.Instance.gamePlayInfo.setHitSpeed(blade.bladeType, num);
		mainPlayControl.gameInfoBoard.updateInfo();
		explosed = true;
		float num2 = ballExplore.splitAndDistroy();
		UnityEngine.Debug.Log("delayDestoryTime:" + num2);
		UnityEngine.Object.Destroy(base.gameObject, num2);
	}

	public void setBallMat(GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		this.ballDirection = ballDirection;
		this.ballType = ballType;
		BallMatSetting.setBallMat(ball, ballDirection, ballType);
	}

	private int RightHitWave(Blade blade, UnityEngine.Plane plane, bool validPlane)
	{
		float num = 0f;
		if (ballDirection == GeneratorLaw.BallDirection.All)
		{
			return 20 + Mathf.FloorToInt(80f * ((blade.waveDistancePerSecond / 50f > 1f) ? 1f : (blade.waveDistancePerSecond / 50f)));
		}
		if (!validPlane)
		{
			return -1;
		}
		if ((double)blade.waveDistancePerSecond < 0.2)
		{
			return -1;
		}
		if (!Physics.Raycast(waveRayOrigin.position, -blade.waveDirection, out var hitInfo, 0.23f))
		{
			return -1;
		}
		if (hitInfo.collider.gameObject.GetComponent<Ball>() != this)
		{
			return -1;
		}
		float hed = getHed(t1.position, t2.position, plane);
		float hed2 = getHed(t4.position, t3.position, plane);
		float hed3 = getHed(b1.position, b2.position, plane);
		float hed4 = getHed(b4.position, b3.position, plane);
		if (!(hed2 <= 0f))
		{
			_ = 0f;
		}
		num += 15f * hed + 15f * hed2 + 15f * hed3 + 15f * hed4 + 40f * ((blade.waveDistancePerSecond / 50f > 1f) ? 1f : (blade.waveDistancePerSecond / 50f));
		return Mathf.FloorToInt(num);
	}

	private float getHed(UnityEngine.Vector3 original, UnityEngine.Vector3 target, UnityEngine.Plane plane)
	{
		Ray ray = new Ray(original, target - original);
		if (!plane.Raycast(ray, out var enter))
		{
			return 0f;
		}
		float magnitude = (target - original).magnitude;
		if (magnitude < enter)
		{
			return 0f;
		}
		return 1f - Mathf.Abs(magnitude / 2f - enter) / (magnitude / 2f);
	}

	private bool RightBlade(Blade.BladeType bladeType)
	{
		if (ballType == GeneratorLaw.BallType.BlackBall)
		{
			return false;
		}
		if ((bladeType != Blade.BladeType.LeftHand || ballType != 0) && (bladeType != Blade.BladeType.RightHand || ballType != GeneratorLaw.BallType.RightBall))
		{
			return bladeType == Blade.BladeType.Head;
		}
		return true;
	}

	public void Fly(UnityEngine.Vector3 target, float speed)
	{
		this.target = target;
		this.speed = speed;
		fly = true;
		bsSlowSpeed = -1f;
		overHitTarget = false;
		switch (ballType)
		{
		case GeneratorLaw.BallType.LeftBall:
			base.transform.Find("effect/GYJZ/startEffectGYJZLeft").GetComponent<ParticleSystem>().Play();
			break;
		case GeneratorLaw.BallType.RightBall:
			base.transform.Find("effect/GYJZ/startEffectGYJZRight").GetComponent<ParticleSystem>().Play();
			break;
		case GeneratorLaw.BallType.BlackBall:
			base.transform.Find("effect/GYJZ/startEffectGYJZBlack").GetComponent<ParticleSystem>().Play();
			break;
		}
		if (cubeLarger != null)
		{
			cubeLarger.larger();
		}
		flyDongHuaStage = 0;
	}

	public void Update()
	{
		if (!fly || mainPlayControl.pause)
		{
			return;
		}
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua == 1)
			{
				if (flyDongHuaStage == 0)
				{
					if ((base.transform.position - ballFlyPos.jiaSuEndPos).magnitude < endDis)
					{
						flyDongHuaStage = 1;
						base.transform.position = ballFlyPos.jiaSuEndPos;
					}
					else
					{
						float maxDistanceDelta = speed * BsMusicManager.JiaSuBeiShu * Time.deltaTime;
						base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, ballFlyPos.jiaSuEndPos, maxDistanceDelta);
					}
				}
				else if (flyDongHuaStage == 1)
				{
					if ((base.transform.position - ballFlyPos.rightWeiZhiPos).magnitude < endDis)
					{
						flyDongHuaStage = 2;
						base.transform.position = ballFlyPos.rightWeiZhiPos;
						base.transform.localRotation = UnityEngine.Quaternion.Euler(0f, 0f, ballFlyPos.rightZRotation);
						bsSlowSpeed = -1f;
					}
					else
					{
						if (bsSlowSpeed < 0f)
						{
							bsSlowSpeed = (ballFlyPos.rightWeiZhiPos.z - hitTarget.z + (base.transform.position - ballFlyPos.rightWeiZhiPos).magnitude) / (((float)(ballInfo.bsTimeHitTimeIndex - UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex) + 0f) / (float)MainPlayControl.timeIndexPerSeconds - mainPlayControl.thisTime);
							rotateSpeed = (ballFlyPos.rightZRotation - ballFlyPos.originZRotation) / ((base.transform.position - ballFlyPos.rightWeiZhiPos).magnitude / bsSlowSpeed);
							totalChangeFlyTime = (base.transform.position - ballFlyPos.rightWeiZhiPos).magnitude / bsSlowSpeed;
							changeFlyStartTime = Time.time;
							changeFlyCenter = (base.transform.position + ballFlyPos.rightWeiZhiPos) / 2f;
							if (ballFlyPos.leftFlyToRight)
							{
								changeFlyCenter -= new UnityEngine.Vector3(0f, -2f, 0f);
							}
							else if (ballFlyPos.rightFlyToLeft)
							{
								changeFlyCenter -= new UnityEngine.Vector3(0f, 2f, 0f);
							}
							changeFlystart = base.transform.position - changeFlyCenter;
							changeFlyend = ballFlyPos.rightWeiZhiPos - changeFlyCenter;
						}
						if (ballFlyPos.leftFlyToRight || ballFlyPos.rightFlyToLeft)
						{
							base.transform.position = UnityEngine.Vector3.Slerp(changeFlystart, changeFlyend, (Time.time - changeFlyStartTime) / totalChangeFlyTime);
							base.transform.position += changeFlyCenter;
						}
						else
						{
							float maxDistanceDelta2 = bsSlowSpeed * Time.deltaTime;
							base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, ballFlyPos.rightWeiZhiPos, maxDistanceDelta2);
						}
						base.transform.Rotate(UnityEngine.Vector3.forward * rotateSpeed * Time.deltaTime);
					}
				}
				else
				{
					if (bsSlowSpeed < 0f)
					{
						bsSlowSpeed = (base.transform.position.z - hitTarget.z) / (((float)(ballInfo.bsTimeHitTimeIndex - UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex) + 0f) / (float)MainPlayControl.timeIndexPerSeconds - mainPlayControl.thisTime);
						UnityEngine.Debug.Log("cube speed:" + bsSlowSpeed);
					}
					float maxDistanceDelta3 = bsSlowSpeed * Time.deltaTime;
					base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, maxDistanceDelta3);
				}
			}
			else
			{
				float maxDistanceDelta4 = UnitySingleton<DataCenter>.Instance.bsMusicManager.getBsBallSpeed(speed, base.gameObject.transform.position, target, hitTarget, mainPlayControl.timeIndex, ballInfo.bsTimeHitTimeIndex) * Time.deltaTime;
				if (bsSlowSpeed < 0f && base.transform.position.z < BsMusicManager.slowDistance)
				{
					bsSlowSpeed = (base.transform.position.z - hitTarget.z) / (((float)(ballInfo.bsTimeHitTimeIndex - UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex) + 0f) / (float)MainPlayControl.timeIndexPerSeconds - mainPlayControl.thisTime);
					maxDistanceDelta4 = bsSlowSpeed * Time.deltaTime;
					UnityEngine.Debug.Log("cube speed:" + bsSlowSpeed);
				}
				if (bsSlowSpeed > 0f)
				{
					maxDistanceDelta4 = bsSlowSpeed * Time.deltaTime;
				}
				base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, maxDistanceDelta4);
			}
		}
		else
		{
			float maxDistanceDelta5 = speed * Time.deltaTime;
			base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, maxDistanceDelta5);
		}
		if ((hitTarget - base.transform.position).magnitude < 0.1f && !overHitTarget)
		{
			overHitTarget = true;
		}
		if ((target - base.transform.position).magnitude < 0.01f)
		{
			ball.SetActive(value: false);
			fly = false;
			if (ballType == GeneratorLaw.BallType.LeftBall || ballType == GeneratorLaw.BallType.RightBall)
			{
				UnitySingleton<AudioManager>.Instance.PlayMusicOnce("hitFail");
				UnitySingleton<DataCenter>.Instance.AddMissed();
				mainPlayControl.gameInfoBoard.updateInfo();
			}
			explosed = true;
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class Blade : MonoBehaviour
{
	public delegate void Enter(GameObject gameObject, UnityEngine.Vector3 colliderPoint, Blade blade);

	public enum BladeType
	{
		Head,
		LeftHand,
		RightHand
	}

	public BladeEffectManager bladeEffectManager;

	public bool isMoreDetect;

	public BladeType bladeType;

	private List<UnityEngine.Vector3> lastPosition;

	public Transform topDetectPoint;

	public Transform endDetectPoint;

	public float lastDeltaTime;

	public UnityEngine.Vector3 lastTopDetectPoint;

	public UnityEngine.Vector3 ThisTopDetectPoint;

	public UnityEngine.Vector3 waveDirection;

	public float waveDistancePerSecond;

	public UnityEngine.Vector3 lastEndDetectPoint;

	public UnityEngine.Vector3 ThisEndDetectPoint;

	public float hengRayTopDisStep = 0.05f;

	public bool LengthAdj;

	public Enter enter { get; set; }

	private void Start()
	{
		lastPosition = new List<UnityEngine.Vector3>();
		if (LengthAdj)
		{
			topDetectPoint = base.transform.Find("LengthAdj/AdjBlade/TopDetectPoint");
			endDetectPoint = base.transform.Find("LengthAdj/AdjBlade/EndDetectPoint");
		}
		else
		{
			topDetectPoint = base.transform.Find("TopDetectPoint");
			endDetectPoint = base.transform.Find("EndDetectPoint");
		}
		float x = 56f + UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.saberFov;
		base.transform.localEulerAngles = new UnityEngine.Vector3(x, 0f, 0f);
	}

	private void Update()
	{
		checkGround();
		if (isMoreDetect)
		{
			if (lastPosition.Count > 0)
			{
				detectByRay();
			}
			updateLastPosition();
		}
		if (topDetectPoint != null)
		{
			lastTopDetectPoint = ThisTopDetectPoint;
			ThisTopDetectPoint = topDetectPoint.position;
			lastEndDetectPoint = ThisEndDetectPoint;
			ThisEndDetectPoint = endDetectPoint.position;
			lastDeltaTime = Time.deltaTime;
			waveDirection = lastTopDetectPoint - ThisTopDetectPoint;
			if (ThisTopDetectPoint == UnityEngine.Vector3.zero || lastTopDetectPoint == UnityEngine.Vector3.zero)
			{
				waveDistancePerSecond = 0f;
			}
			else
			{
				waveDistancePerSecond = waveDirection.magnitude / lastDeltaTime;
			}
			detectByHengRay();
			yuPanHengRay();
			yuPanHengRay(houXiang: true);
		}
	}

	private void detectByHengRay()
	{
		if (ThisTopDetectPoint.Equals(UnityEngine.Vector3.zero) || ThisEndDetectPoint.Equals(UnityEngine.Vector3.zero) || ThisTopDetectPoint.Equals(UnityEngine.Vector3.zero) || lastTopDetectPoint.Equals(UnityEngine.Vector3.zero))
		{
			return;
		}
		float magnitude = (ThisTopDetectPoint - ThisEndDetectPoint).magnitude;
		float magnitude2 = (ThisTopDetectPoint - lastTopDetectPoint).magnitude;
		if (magnitude2 < hengRayTopDisStep)
		{
			return;
		}
		for (float num = hengRayTopDisStep; num < magnitude2; num += hengRayTopDisStep)
		{
			UnityEngine.Vector3 vector = UnityEngine.Vector3.Lerp(lastEndDetectPoint, ThisEndDetectPoint, num / magnitude2);
			UnityEngine.Vector3 direction = UnityEngine.Vector3.Lerp(lastTopDetectPoint, ThisTopDetectPoint, num / magnitude2) - vector;
			RaycastHit[] array = Physics.RaycastAll(vector, direction, magnitude);
			if (array.Length == 0)
			{
				continue;
			}
			RaycastHit[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit = array2[i];
				if (raycastHit.collider.gameObject.tag.Equals("ball"))
				{
					enter?.Invoke(raycastHit.collider.gameObject, raycastHit.point, this);
				}
			}
		}
	}

	private void yuPanHengRay(bool houXiang = false)
	{
		if (ThisTopDetectPoint.Equals(UnityEngine.Vector3.zero) || ThisEndDetectPoint.Equals(UnityEngine.Vector3.zero) || ThisTopDetectPoint.Equals(UnityEngine.Vector3.zero) || lastTopDetectPoint.Equals(UnityEngine.Vector3.zero) || waveDistancePerSecond < 0.1f)
		{
			return;
		}
		float yuPanBili = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.yuPanBili;
		if (yuPanBili < 0.02f)
		{
			return;
		}
		float num = ((waveDistancePerSecond / 50f > 1f) ? 1f : (waveDistancePerSecond / 50f));
		if (num < 0.05f)
		{
			num = 0.05f;
		}
		UnityEngine.Vector3 vector = ThisTopDetectPoint + (ThisTopDetectPoint - lastTopDetectPoint).normalized * yuPanBili * num;
		UnityEngine.Vector3 vector2 = ThisEndDetectPoint + (ThisEndDetectPoint - lastEndDetectPoint).normalized * yuPanBili * num;
		if (houXiang)
		{
			vector = lastTopDetectPoint + (lastTopDetectPoint - ThisTopDetectPoint).normalized * yuPanBili * num;
			vector2 = lastEndDetectPoint + (lastEndDetectPoint - ThisEndDetectPoint).normalized * yuPanBili * num;
		}
		UnityEngine.Vector3 direction = vector - vector2;
		float magnitude = (ThisTopDetectPoint - ThisEndDetectPoint).magnitude;
		RaycastHit[] array = Physics.RaycastAll(vector2, direction, magnitude);
		if (array.Length != 0)
		{
			RaycastHit[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit = array2[i];
				if (raycastHit.collider.gameObject.tag.Equals("ball"))
				{
					enter?.Invoke(raycastHit.collider.gameObject, raycastHit.point, this);
				}
			}
		}
		float magnitude2 = (vector - ThisTopDetectPoint).magnitude;
		if (houXiang)
		{
			magnitude2 = (vector - lastTopDetectPoint).magnitude;
		}
		if (magnitude2 < hengRayTopDisStep)
		{
			return;
		}
		for (float num2 = hengRayTopDisStep; num2 < magnitude2; num2 += hengRayTopDisStep)
		{
			UnityEngine.Vector3 vector3 = UnityEngine.Vector3.Lerp(lastEndDetectPoint, vector2, num2 / magnitude2);
			UnityEngine.Vector3 vector4 = UnityEngine.Vector3.Lerp(lastTopDetectPoint, vector, num2 / magnitude2);
			if (houXiang)
			{
				vector3 = UnityEngine.Vector3.Lerp(ThisEndDetectPoint, vector2, num2 / magnitude2);
				vector4 = UnityEngine.Vector3.Lerp(ThisTopDetectPoint, vector, num2 / magnitude2);
			}
			UnityEngine.Vector3 direction2 = vector4 - vector3;
			RaycastHit[] array3 = Physics.RaycastAll(vector3, direction2, magnitude);
			if (array3.Length == 0)
			{
				continue;
			}
			RaycastHit[] array2 = array3;
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit raycastHit2 = array2[i];
				if (raycastHit2.collider.gameObject.tag.Equals("ball"))
				{
					enter?.Invoke(raycastHit2.collider.gameObject, raycastHit2.point, this);
				}
			}
		}
	}

	public void detectByRay()
	{
		for (int i = 1; i <= 9; i++)
		{
			UnityEngine.Vector3 zero = UnityEngine.Vector3.zero;
			zero = ((!LengthAdj) ? base.transform.Find("MoreDected/point" + i).position : base.transform.Find("LengthAdj/AdjBlade/MoreDected/point" + i).position);
			for (int j = 0; j < 9; j++)
			{
				UnityEngine.Vector3 vector = lastPosition[j];
				float magnitude = (zero - vector).magnitude;
				UnityEngine.Vector3 direction = zero - vector;
				RaycastHit[] array = Physics.RaycastAll(vector, direction, magnitude);
				if (array.Length == 0)
				{
					continue;
				}
				RaycastHit[] array2 = array;
				for (int k = 0; k < array2.Length; k++)
				{
					RaycastHit raycastHit = array2[k];
					if (raycastHit.collider.gameObject.tag.Equals("ball"))
					{
						enter?.Invoke(raycastHit.collider.gameObject, raycastHit.point, this);
					}
				}
			}
		}
	}

	public void updateLastPosition()
	{
		lastPosition.Clear();
		for (int i = 1; i <= 9; i++)
		{
			if (LengthAdj)
			{
				lastPosition.Add(base.transform.Find("LengthAdj/AdjBlade/MoreDected/point" + i).position);
			}
			else
			{
				lastPosition.Add(base.transform.Find("MoreDected/point" + i).position);
			}
		}
	}

	public void OnCollisionEnter(Collision collision)
	{
		if (bladeType.Equals(BladeType.LeftHand) && collision.gameObject.tag.Equals("RightBlade") && collision.contacts.Length != 0)
		{
			bladeEffectManager.bladeTouch(collision.contacts[0].point);
		}
		else if (collision.gameObject.tag.Equals("ball") && collision.contacts.Length != 0)
		{
			enter?.Invoke(collision.gameObject, collision.contacts[0].point, this);
		}
	}

	public void OnCollisionStay(Collision collision)
	{
		if (bladeType.Equals(BladeType.LeftHand) && collision.gameObject.tag.Equals("RightBlade") && collision.contacts.Length != 0)
		{
			bladeEffectManager.bladeTouch(collision.contacts[0].point);
		}
		else if (collision.gameObject.tag.Equals("ball") && collision.contacts.Length != 0)
		{
			enter?.Invoke(collision.gameObject, collision.contacts[0].point, this);
		}
	}

	public void OnCollisionExit(Collision collision)
	{
		if (bladeType.Equals(BladeType.LeftHand) && collision.gameObject.tag.Equals("RightBlade") && collision.contacts.Length != 0)
		{
			bladeEffectManager.bladeTouchExit(collision.contacts[0].point);
		}
		else if (collision.gameObject.tag.Equals("ball") && collision.contacts.Length != 0)
		{
			enter?.Invoke(collision.gameObject, collision.contacts[0].point, this);
		}
	}

	private void checkGround()
	{
		UnityEngine.Vector3 position = topDetectPoint.position;
		UnityEngine.Vector3 position2 = endDetectPoint.position;
		if (position.y > 0f)
		{
			if (bladeType.Equals(BladeType.LeftHand))
			{
				bladeEffectManager.bladeGroundTouchLeftExit();
			}
			else
			{
				bladeEffectManager.bladeGroundTouchRightExit();
			}
		}
		else if (position.y < 0f)
		{
			if (bladeType.Equals(BladeType.LeftHand))
			{
				bladeEffectManager.bladeGroundTouchLeft(GetIntersectWithLineAndPlane(position, position2));
			}
			else
			{
				bladeEffectManager.bladeGroundTouchRight(GetIntersectWithLineAndPlane(position, position2));
			}
		}
	}

	private UnityEngine.Vector3 GetIntersectWithLineAndPlane(UnityEngine.Vector3 top, UnityEngine.Vector3 end)
	{
		UnityEngine.Vector3 vector = top - end;
		UnityEngine.Vector3 rhs = new UnityEngine.Vector3(0f, 1f, 0f);
		return UnityEngine.Vector3.Dot(new UnityEngine.Vector3(0f, 0f, 0f) - top, rhs) / UnityEngine.Vector3.Dot(vector.normalized, rhs) * vector.normalized + top;
	}
}
public class CommonController : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject currentController;

	private Ray ray;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	public bool haveRay = true;

	private void Start()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
			HeadSetController.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(!Convert.ToBoolean(Convert.ToInt16(state)));
	}

	private void Update()
	{
		SetEnableControllerRay(currentController, haveRay);
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = UnityEngine.Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out var hitInfo))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new UnityEngine.Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hitInfo.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hitInfo.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hitInfo.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hitInfo.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hitInfo.point;
					HeadSetController.transform.position -= (hitInfo.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hitInfo.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new UnityEngine.Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = UnityEngine.Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new UnityEngine.Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.position + currentController.transform.forward.normalized * (0.5f + rayDefaultLength) - currentController.transform.Find("start").position;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out var hitInfo2))
			{
				currentHit = hitInfo2.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hitInfo2.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hitInfo2.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hitInfo2.point;
						disX = hitInfo2.transform.position.x - referenceObj.transform.position.x;
						disY = hitInfo2.transform.position.y - referenceObj.transform.position.y;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(0)) && hitInfo2.transform == dragObj.transform)
					{
						referenceObj.transform.position = new UnityEngine.Vector3(hitInfo2.point.x, hitInfo2.point.y, hitInfo2.transform.position.z);
					}
				}
				lastHit = hitInfo2.transform;
				currentController.transform.Find("dot").position = hitInfo2.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new UnityEngine.Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new UnityEngine.Vector3(0.178f, 0.178f, 1f);
					currentController.transform.Find("dot").position = currentController.transform.position + currentController.transform.forward.normalized * (0.5f + rayDefaultLength);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void SetEnableControllerRay(GameObject controller, bool enable)
	{
		if (!(controller == null))
		{
			controller.transform.Find("dot").gameObject.SetActive(enable);
			controller.transform.Find("ray_alpha").gameObject.SetActive(value: false);
			controller.transform.Find("ray_LengthAdaptive").gameObject.SetActive(enable);
			controller.transform.Find("start").gameObject.SetActive(enable);
		}
	}

	private bool HandSwitch()
	{
		if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Left))
		{
			SetEnableControllerRay(controller0, enable: true);
			SetEnableControllerRay(controller1, enable: false);
			currentController = controller0;
			Controller.UPvr_SetMainHandNess(0);
			return true;
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Right))
		{
			SetEnableControllerRay(controller0, enable: false);
			SetEnableControllerRay(controller1, enable: true);
			currentController = controller1;
			Controller.UPvr_SetMainHandNess(1);
			return true;
		}
		return false;
	}
}
public class DataCenter : UnitySingleton<DataCenter>
{
	public MusicDataCenter musicDataCenter = new MusicDataCenter();

	public GenerateParameter generateParameter = new GenerateParameter();

	public BsMusicManager bsMusicManager = new BsMusicManager();

	public MusicListDataCenter musicListDataCenter = new MusicListDataCenter();

	public HipSettingDataManager hipSettingDataManager = new HipSettingDataManager();

	public GamePlayInfo gamePlayInfo = new GamePlayInfo();

	public ScoreRankDataManger scoreRankDataManger = new ScoreRankDataManger();

	public SceneSelectDataManager sceneSelectDataManager = new SceneSelectDataManager();

	public ColorDynamicManager colorDynamicManager = new ColorDynamicManager();

	public OpControl opControl = new OpControl();

	public GeneratorLaw generatorLaw;

	public string musicName;

	public bool returnFromGame;

	public List<Material> skyboxList;

	private List<SpectralFluxInfo> spectralFluxSamples;

	public AudioClip playClip;

	public int minGenDistance;

	public int comboGenDistance;

	public int thresholdMultiply = 2;

	private bool isLoaded;

	public int MinDirctionChangeDis = 20 * MainPlayControl.timeIndexPerSeconds;

	public int MinDirctionCheckDis = 5 * MainPlayControl.timeIndexPerSeconds;

	public int TwoDirctionCheckDis = 15 * MainPlayControl.timeIndexPerSeconds;

	public int TwoDirctionMinDis = 70 * MainPlayControl.timeIndexPerSeconds;

	private int lastDirectionChangeTimeIndex;

	private int lastDirectionCheckTimeIndex;

	private int lastChangeSignSparkTimeIndex;

	private float flyOPDistance = 24.32f;

	public int flyOPDistanceIndex;

	private int lastTwoWayEndTimeIndex;

	public bool doPicoCheck = true;

	public int musicPage;

	public bool isGameOver { get; set; }

	public Action GameOver { get; set; }

	public Action GameDone { get; set; }

	private new void Awake()
	{
		base.Awake();
		if (!FileUtils.LYJCD)
		{
			string text = Pvr_UnitySDKAPI.System.UPvr_GetDeviceSN();
			if (text != null && text.Length < FileUtils.LYJ.Length)
			{
				int length = text.Length;
				FileUtils.LYJ = FileUtils.LYJ.Substring(length) + text;
			}
			FileUtils.LYJCD = true;
		}
		sceneSelectDataManager.LoadSceneSelectData();
		colorDynamicManager.init();
		musicPage = 1;
	}

	public void testLYJ()
	{
		if (!FileUtils.LYJCD)
		{
			string text = "PA7G10NGE9240190W";
			if (text != null && text.Length < FileUtils.LYJ.Length)
			{
				int length = text.Length;
				FileUtils.LYJ = FileUtils.LYJ.Substring(length) + text;
			}
			FileUtils.LYJCD = true;
		}
	}

	public void initLoad(bool loadMusic = true)
	{
		if (!isLoaded)
		{
			if (loadMusic)
			{
				musicListDataCenter.LoadMusic();
				isLoaded = true;
			}
			returnFromGame = false;
			hipSettingDataManager.LoadHipSettingData();
			scoreRankDataManger.LoadScoreRankData();
			BallPosConstantInfo.loadPosDicForSaveToPosDic();
		}
	}

	public void initMusic(bool debugMode = false)
	{
		Resources.UnloadUnusedAssets();
		GC.Collect();
		generatorLaw = new GeneratorLaw();
		generatorLaw.totalTimeUnits = Mathf.FloorToInt(playClip.length * (float)MainPlayControl.timeIndexPerSeconds);
		generatorLaw.musicName = musicName;
		if (bsMusicManager.isBsMusic)
		{
			bsMusicManager.initBsMusic();
			musicDataCenter.isAnalysisMusicDone = true;
		}
		else
		{
			generateBeatInfo(playClip, debugMode);
		}
		if (debugMode)
		{
			CheckGenerateBeatBasicInfoDone();
		}
	}

	private void generateBeatInfo(AudioClip clip, bool debugMode = false)
	{
		generatorLaw.generatorBeatDic = new Dictionary<int, GeneratorLaw.BeatInfo>();
		generatorLaw.generatorBeatDicWithCombAndScore = new Dictionary<int, GeneratorLaw.BeatInfo>();
		generatorLaw.generatorBeatGateSparkDic = new Dictionary<int, List<int>>();
		generatorLaw.generatorBeatOriginChangeDic = new Dictionary<int, GenGateInfo.OriginChangeShow>();
		musicDataCenter.AnalysisMusic(clip, debugMode);
	}

	public bool CheckGenerateBeatBasicInfoDone()
	{
		if (bsMusicManager.isBsMusic)
		{
			gamePlayInfo.init(musicName);
			reStart();
			return true;
		}
		if (!musicDataCenter.isAnalysisMusicDone)
		{
			return false;
		}
		spectralFluxSamples = musicDataCenter.preProcessedSpectralFluxAnalyzer.spectralFluxSamples;
		float num = playClip.length / (float)spectralFluxSamples.Count;
		for (int i = 0; i < spectralFluxSamples.Count; i++)
		{
			SpectralFluxInfo spectralFluxInfo = spectralFluxSamples[i];
			if (spectralFluxInfo.isPeak)
			{
				int key = Mathf.FloorToInt(num * (float)i * (float)MainPlayControl.timeIndexPerSeconds);
				generatorLaw.generatorBeatDic.TryGetValue(key, out var value);
				if (value == null)
				{
					value = new GeneratorLaw.BeatInfo();
					value.isPeak = true;
					value.spectralFlux = spectralFluxInfo.spectralFlux;
					value.spectralFluxInfo = spectralFluxInfo;
					value.fluxThreadRatio = spectralFluxInfo.spectralFlux / spectralFluxInfo.threshold;
					generatorLaw.generatorBeatDic.Add(key, value);
				}
			}
		}
		gamePlayInfo.init(musicName);
		loadGenerateParameter();
		generateBeatAndCombo();
		generateLaw();
		reStart();
		return true;
	}

	private void loadGenerateParameter()
	{
		generateParameter.angleType = hipSettingDataManager.gateNumValueList[hipSettingDataManager.hipSettingData.gateNum];
		generateParameter.ballComboLevel = hipSettingDataManager.comboLevelValueList[hipSettingDataManager.hipSettingData.comboLevel];
		generateParameter.ballSpeed = hipSettingDataManager.flySpeedValueList[hipSettingDataManager.hipSettingData.cubeFlySpeed];
		generateParameter.beatOfTimeUnit = Mathf.FloorToInt(1f / hipSettingDataManager.cubesPerSecondsValueList[hipSettingDataManager.hipSettingData.cubesPerSeconds] * (float)MainPlayControl.timeIndexPerSeconds);
		generateParameter.wallComboLevel = hipSettingDataManager.hipSettingData.wallComboLevel;
	}

	private void generateBeatAndCombo()
	{
		GeneratorLaw.BeatInfo beatInfo = null;
		for (int i = 0; i < generatorLaw.totalTimeUnits; i++)
		{
			generatorLaw.generatorBeatDic.TryGetValue(i, out var value);
			if (value == null)
			{
				continue;
			}
			value.timeIndex = i;
			value.beatScore = value.spectralFluxInfo.peakScore;
			value.comboBeatInflList = new List<GeneratorLaw.BeatInfo>();
			if (beatInfo == null || i - beatInfo.timeIndex > 0)
			{
				if (beatInfo != null)
				{
					beatInfo.nextBeatIndex = i;
					value.prevBeatIndex = beatInfo.timeIndex;
				}
				beatInfo = value;
				generatorLaw.generatorBeatDicWithCombAndScore.Add(i, value);
			}
			else
			{
				beatInfo.comboBeatInflList.Add(value);
				beatInfo.beatScore += value.beatScore;
			}
		}
		int num = generatorLaw.totalTimeUnits / generateParameter.beatOfTimeUnit;
		while (generatorLaw.generatorBeatDicWithCombAndScore.Count > num)
		{
			GeneratorLaw.BeatInfo beatInfo2 = null;
			for (int j = 0; j < generatorLaw.totalTimeUnits; j++)
			{
				generatorLaw.generatorBeatDicWithCombAndScore.TryGetValue(j, out var value2);
				if (value2 != null && !(value2.beatScore < generatorLaw.beatGenThreshold))
				{
					if (beatInfo2 == null)
					{
						value2.prevBeatIndex = 0;
					}
					else
					{
						value2.prevBeatIndex = beatInfo2.timeIndex;
						beatInfo2.nextBeatIndex = value2.timeIndex;
					}
					beatInfo2 = value2;
				}
			}
			int key = -1;
			int num2 = generatorLaw.totalTimeUnits;
			for (int k = 0; k < generatorLaw.totalTimeUnits; k++)
			{
				generatorLaw.generatorBeatDicWithCombAndScore.TryGetValue(k, out var value3);
				if (value3 != null && !(value3.beatScore < generatorLaw.beatGenThreshold) && value3.nextBeatIndex != 0)
				{
					int num3 = value3.nextBeatIndex - value3.prevBeatIndex;
					if (num3 < num2)
					{
						key = k;
						num2 = num3;
					}
				}
			}
			generatorLaw.generatorBeatDicWithCombAndScore.Remove(key);
		}
	}

	public void AddMissed()
	{
		if (!isGameOver)
		{
			GradualBlack.instance.PlayHurtAnimation();
			if (gamePlayInfo.addHitFail())
			{
				isGameOver = true;
				scoreRankDataManger.putNewData(success: false);
				GameOver?.Invoke();
			}
		}
	}

	public void reStart()
	{
		isGameOver = false;
	}

	public void hitSuccess()
	{
		if (!isGameOver)
		{
			gamePlayInfo.addHitSuccess();
		}
	}

	public void gameDone()
	{
		isGameOver = true;
		gamePlayInfo.gameSuccess = true;
		scoreRankDataManger.putNewData(success: true);
		GameDone?.Invoke();
	}

	private void generateLaw()
	{
		generatorLaw.generatorDic = new Dictionary<int, List<GeneratorLaw.BallInfo>>();
		generatorLaw.generatorBeatWallDic = new Dictionary<int, WallInfo>();
		int num = -999;
		GenGateInfo.OriginDirection originDirection = new GenGateInfo.OriginDirection();
		BallComboContainer.InitBallComboContainer();
		WallComboContainer.InitWallComboContainer();
		WallPosConstantInfo.init();
		BaseBallCombo.LastGenTimeIndex = 0;
		BaseBallCombo.LastRGenEndTimeIndex = 0;
		lastChangeSignSparkTimeIndex = 0;
		lastDirectionChangeTimeIndex = 0;
		lastDirectionCheckTimeIndex = 0;
		flyOPDistanceIndex = Convert.ToInt32(((double)flyOPDistance - 0.6) / (double)generateParameter.ballSpeed * (double)MainPlayControl.timeIndexPerSeconds);
		bool flag = false;
		int num2 = Convert.ToInt32((float)flyOPDistanceIndex * generateParameter.originDirectionChangeWaiting);
		bool flag2 = false;
		int num3 = 0;
		int num4 = 0;
		for (int i = 0; i < generatorLaw.totalTimeUnits; i++)
		{
			generatorLaw.generatorBeatDicWithCombAndScore.TryGetValue(i, out var value);
			if (value == null || !value.isPeak || i - num < minGenDistance)
			{
				continue;
			}
			if (flag)
			{
				if (i < lastChangeSignSparkTimeIndex + num2)
				{
					continue;
				}
				generatorLaw.generatorBeatOriginChangeDic.Add(lastChangeSignSparkTimeIndex, GeneratorLaw.GetOriginChangeShow(originDirection));
				flag = false;
			}
			else if (!flag2)
			{
				originDirection = UpdateOriginDirction(originDirection, i);
				if (originDirection.newFirstDirection)
				{
					lastChangeSignSparkTimeIndex = i;
					flag = true;
					continue;
				}
			}
			if (flag2)
			{
				if (i < num4 + num3)
				{
					continue;
				}
				flag2 = false;
			}
			else
			{
				num3 = Mathf.CeilToInt(WallComboContainer.randomGenerateWallCombo(value, generatorLaw.generatorBeatWallDic, generatorLaw.generatorDic, originDirection) / generateParameter.ballSpeed * (float)MainPlayControl.timeIndexPerSeconds);
				if (num3 >= 0)
				{
					num4 = i;
					flag2 = true;
					continue;
				}
			}
			BallComboContainer.randomGenerateBallCombo(value, generatorLaw.generatorDic, originDirection);
			num = i;
		}
		resetTapTime(generatorLaw);
		resetWallTapTime(generatorLaw);
		generateBeatGateLaw();
	}

	private void generateBeatGateLaw()
	{
		foreach (KeyValuePair<int, List<GeneratorLaw.BallInfo>> item in generatorLaw.generatorDic)
		{
			foreach (GeneratorLaw.BallInfo item2 in item.Value)
			{
				generatorLaw.generatorBeatGateSparkDic.TryGetValue(item.Key, out var value);
				if (value == null)
				{
					value = new List<int>();
					value.Add(item2.dingWeiIndex);
					generatorLaw.generatorBeatGateSparkDic.Add(item.Key, value);
				}
				else if (!value.Contains(item2.dingWeiIndex))
				{
					value.Add(item2.dingWeiIndex);
				}
			}
		}
	}

	private GenGateInfo.OriginDirection UpdateOriginDirction(GenGateInfo.OriginDirection originDirection, int timeIndex)
	{
		originDirection.oldbaseIndex = originDirection.baseIndex;
		originDirection.newFirstDirection = false;
		originDirection.twoWayBackToSingle = false;
		if (generateParameter.angleType == GenerateParameter.AngleType.Single)
		{
			return originDirection;
		}
		if (originDirection.originSourceMode == GenGateInfo.OriginSourceMode.Single)
		{
			if (timeIndex < lastDirectionChangeTimeIndex + MinDirctionChangeDis)
			{
				return originDirection;
			}
			if (timeIndex < lastDirectionCheckTimeIndex + MinDirctionCheckDis)
			{
				return originDirection;
			}
			lastDirectionCheckTimeIndex = timeIndex;
			if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.99f)) == 0)
			{
				originDirection.baseIndex = generateParameter.GetChangeDirectionIndex(originDirection.baseIndex);
				originDirection.changeTimeIndex = timeIndex;
				originDirection.newFirstDirection = true;
				originDirection.originSourceMode = GenGateInfo.OriginSourceMode.Single;
				lastDirectionChangeTimeIndex = timeIndex;
				return originDirection;
			}
			if (timeIndex < lastTwoWayEndTimeIndex + TwoDirctionMinDis)
			{
				return originDirection;
			}
			if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.99f)) == 0)
			{
				GenGateInfo.OriginSourceMode originSourceModeTwoWay = getOriginSourceModeTwoWay();
				if (originSourceModeTwoWay == GenGateInfo.OriginSourceMode.Single)
				{
					return originDirection;
				}
				originDirection.changeTimeIndex = timeIndex;
				originDirection.newFirstDirection = true;
				originDirection.originSourceMode = originSourceModeTwoWay;
				originDirection.twoWayAnotherIndex = getTwoWayAnotherIndex(originDirection.baseIndex, originSourceModeTwoWay);
				lastDirectionChangeTimeIndex = timeIndex;
				return originDirection;
			}
			return originDirection;
		}
		if (timeIndex < lastDirectionChangeTimeIndex + TwoDirctionCheckDis)
		{
			return originDirection;
		}
		originDirection.changeTimeIndex = timeIndex;
		originDirection.newFirstDirection = true;
		originDirection.originSourceMode = GenGateInfo.OriginSourceMode.Single;
		originDirection.twoWayBackToSingle = true;
		lastTwoWayEndTimeIndex = timeIndex;
		lastDirectionChangeTimeIndex = timeIndex;
		return originDirection;
	}

	public static int getTwoWayAnotherIndex(int baseIndex, GenGateInfo.OriginSourceMode originSourceModeTwoWay)
	{
		int num = baseIndex;
		switch (originSourceModeTwoWay)
		{
		case GenGateInfo.OriginSourceMode.P120:
			num = baseIndex + 1;
			break;
		case GenGateInfo.OriginSourceMode.P180:
			num = baseIndex + 2;
			break;
		}
		if (num > 6)
		{
			num -= 6;
		}
		return num;
	}

	private GenGateInfo.OriginSourceMode getOriginSourceModeTwoWay()
	{
		if (generateParameter.ballComboLevel == 3)
		{
			return GenGateInfo.OriginSourceMode.P120;
		}
		if (generateParameter.ballComboLevel == 4)
		{
			if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 2.99f)) == 0)
			{
				_ = generateParameter.angleType;
				_ = 3;
				return GenGateInfo.OriginSourceMode.P120;
			}
			return GenGateInfo.OriginSourceMode.P120;
		}
		if (generateParameter.ballComboLevel == 5)
		{
			if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 2.99f)) == 0)
			{
				return GenGateInfo.OriginSourceMode.P120;
			}
			_ = generateParameter.angleType;
			_ = 3;
			return GenGateInfo.OriginSourceMode.P120;
		}
		return GenGateInfo.OriginSourceMode.Single;
	}

	private GeneratorLaw resetTapTime(GeneratorLaw generatorLaw)
	{
		Dictionary<int, List<GeneratorLaw.BallInfo>> dictionary = new Dictionary<int, List<GeneratorLaw.BallInfo>>();
		int num = 0;
		foreach (KeyValuePair<int, List<GeneratorLaw.BallInfo>> item in generatorLaw.generatorDic)
		{
			foreach (GeneratorLaw.BallInfo item2 in item.Value)
			{
				BallPosConstantInfo.posDic.TryGetValue(item2.dingWeiIndex, out var value);
				if (value == null)
				{
					MonoBehaviour.print("dingWeiInfo == null:" + item2.dingWeiIndex);
				}
				value.originIndexMap.TryGetValue(item2.targetIndex, out var value2);
				value.targetIndexMap.TryGetValue(item2.targetIndex, out var value3);
				if (!value3.Equals(UnityEngine.Vector3.zero))
				{
					int num2 = Convert.ToInt32(((double)(value3 - value2).magnitude - 1.2) / (double)generateParameter.ballSpeed * (double)MainPlayControl.timeIndexPerSeconds);
					int num3 = item.Key - num2;
					if (num3 < num)
					{
						num = num3;
					}
					dictionary.TryGetValue(num3 - num + 1, out var value4);
					if (value4 != null)
					{
						value4.Add(item2);
						continue;
					}
					value4 = new List<GeneratorLaw.BallInfo>();
					value4.Add(item2);
					dictionary.Add(num3 - num + 1, value4);
					generatorLaw.indexToStart = item.Key - (num3 - num + 1);
				}
			}
		}
		generatorLaw.generatorDicAfterTimeReset = dictionary;
		generatorLaw.minIndex = num;
		return generatorLaw;
	}

	private GeneratorLaw resetWallTapTime(GeneratorLaw generatorLaw)
	{
		Dictionary<int, WallInfo> dictionary = new Dictionary<int, WallInfo>();
		foreach (KeyValuePair<int, WallInfo> item in generatorLaw.generatorBeatWallDic)
		{
			WallInfo value = item.Value;
			WallPosConstantInfo.posDic.TryGetValue(value.dingWeiIndex, out var value2);
			if (value2 == null)
			{
				UnityEngine.Debug.LogError("wallDingWeiInfo is null, dingWeiIndex:" + value.dingWeiIndex);
			}
			else
			{
				dictionary.Add(item.Key - generatorLaw.indexToStart, value);
			}
		}
		generatorLaw.generatorBeatWallDicAfterTimeReset = dictionary;
		return generatorLaw;
	}

	private void Update()
	{
	}
}
public class GamePlayInfo
{
	public float lastHitSpeedLeft;

	public float lastHitSpeedRight;

	public float totalhitSpeed;

	public int hitNum;

	public int hitSuccessNum;

	public int hitFailNum;

	public int grandFailNum;

	public int comboNum;

	public int continueHitSuccess;

	public bool gameSuccess;

	public string playMusicName;

	public int hipSettingLevel;

	public string playTime;

	public float fastHitSpeed;

	public int totalScore;

	public const int grandFailOverNum = 5;

	public const int continueHitSuccessSubGrandFailNum = 3;

	public void init(string musicName)
	{
		hitNum = 0;
		lastHitSpeedLeft = 0f;
		lastHitSpeedRight = 0f;
		totalhitSpeed = 0f;
		hitSuccessNum = 0;
		hitFailNum = 0;
		grandFailNum = 0;
		continueHitSuccess = 0;
		comboNum = 0;
		totalScore = 0;
		gameSuccess = false;
		playMusicName = musicName;
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			hipSettingLevel = calBsHipScore(UnitySingleton<DataCenter>.Instance.bsMusicManager.difficultyRank);
		}
		else
		{
			hipSettingLevel = UnitySingleton<DataCenter>.Instance.hipSettingDataManager.getHipScoreBySetting(UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData);
		}
		fastHitSpeed = 0f;
	}

	private int calBsHipScore(int difficultyRank)
	{
		return difficultyRank * 9;
	}

	public void setHitSpeed(Blade.BladeType bladeType, float speed)
	{
		if (speed > fastHitSpeed)
		{
			fastHitSpeed = speed;
		}
		if (bladeType == Blade.BladeType.LeftHand)
		{
			lastHitSpeedLeft = speed;
		}
		else
		{
			lastHitSpeedRight = speed;
		}
		totalhitSpeed += speed;
		hitNum++;
	}

	internal bool addHitFail()
	{
		hitFailNum++;
		comboNum = 0;
		continueHitSuccess = 0;
		if (grandFailNum < 5)
		{
			grandFailNum++;
			return false;
		}
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.execriseMode == 1)
		{
			return false;
		}
		return true;
	}

	internal void addHitSuccess()
	{
		hitSuccessNum++;
		comboNum++;
		continueHitSuccess++;
		if (continueHitSuccess >= 3)
		{
			if (grandFailNum > 0)
			{
				grandFailNum--;
			}
			continueHitSuccess = 0;
		}
	}
}
public class GenerateParameter
{
	public enum AngleType
	{
		Single,
		Two,
		Three,
		All
	}

	public int beatOfTimeUnit;

	public AngleType angleType;

	public float ballSpeed;

	public int ballComboLevel;

	public bool haveBlackCube;

	public float originDirectionChangeWaiting;

	public int wallComboLevel;

	public GenerateParameter()
	{
		beatOfTimeUnit = 30;
		angleType = AngleType.All;
		ballSpeed = 5f;
		ballComboLevel = 5;
		haveBlackCube = true;
		originDirectionChangeWaiting = 0f;
		wallComboLevel = 0;
	}

	public int GetChangeDirectionIndex(int lastOriginDirection)
	{
		List<int> list = new List<int>();
		for (int i = 1; i <= 6; i++)
		{
			if (i != lastOriginDirection && angleType != 0 && (angleType != AngleType.Two || (i != 3 && i != 4 && i != 5 && i != 6)) && (angleType != AngleType.Three || (i != 3 && i != 4 && i != 5)))
			{
				list.Add(i);
			}
		}
		int index = Mathf.FloorToInt(UnityEngine.Random.Range(0f, (float)list.Count - 0.01f));
		return list[index];
	}
}
public class MusicDataCenter
{
	public bool isfirstTimeLoad = true;

	public static int SampleSize = 1024;

	private float[] multiChannelSamples;

	private int numChannels;

	private int numTotalSamples;

	private float clipLength;

	private int sampleRate;

	private string musicName;

	private string persistentDataPath;

	public SpectralFluxAnalyzer preProcessedSpectralFluxAnalyzer;

	public bool isAnalysisMusicDone;

	public bool isInMusicAnalysis;

	public int musicAnalysisTotal;

	public int musicAnalysisNow;

	public void AnalysisMusic(AudioClip clip, bool debugMode = false)
	{
		persistentDataPath = Application.persistentDataPath;
		musicName = clip.name;
		musicAnalysisTotal = clip.samples * clip.channels;
		isAnalysisMusicDone = false;
		isInMusicAnalysis = false;
		string text = FileUtils.ReadFile(Path.Combine(persistentDataPath, "playMusic", musicName + ".gyjzjp"));
		if (text != null)
		{
			try
			{
				isfirstTimeLoad = false;
				preProcessedSpectralFluxAnalyzer = JsonConvert.DeserializeObject<SpectralFluxAnalyzer>(text);
				isAnalysisMusicDone = true;
				return;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log(ex.ToString());
			}
		}
		isfirstTimeLoad = true;
		preProcessedSpectralFluxAnalyzer = new SpectralFluxAnalyzer();
		isInMusicAnalysis = true;
		multiChannelSamples = new float[clip.samples * clip.channels];
		numChannels = clip.channels;
		numTotalSamples = clip.samples;
		clipLength = clip.length;
		sampleRate = clip.frequency;
		clip.GetData(multiChannelSamples, 0);
		if (debugMode)
		{
			getFullSpectrumThreaded();
			return;
		}
		Thread thread = new Thread(getFullSpectrumThreaded);
		UnityEngine.Debug.Log("Starting Background Thread");
		thread.Start();
	}

	public void getFullSpectrumThreaded()
	{
		try
		{
			float[] array = new float[numTotalSamples];
			int num = 0;
			float num2 = 0f;
			for (int i = 0; i < multiChannelSamples.Length; i++)
			{
				num2 += multiChannelSamples[i];
				if ((i + 1) % numChannels == 0)
				{
					array[num] = num2 / (float)numChannels;
					num++;
					num2 = 0f;
				}
			}
			UnityEngine.Debug.Log("Combine Channels done");
			UnityEngine.Debug.Log(array.Length);
			int sampleSize = SampleSize;
			int num3 = array.Length / sampleSize;
			FFT fFT = new FFT();
			fFT.Initialize((uint)sampleSize);
			UnityEngine.Debug.Log($"Processing {num3} time domain samples for FFT");
			double[] array2 = new double[sampleSize];
			for (int j = 0; j < num3; j++)
			{
				Array.Copy(array, j * sampleSize, array2, 0, sampleSize);
				double[] array3 = DSP.Window.Coefficients(DSP.Window.Type.Hanning, (uint)sampleSize);
				double[] timeSeries = DSP.Math.Multiply(array2, array3);
				double b = DSP.Window.ScaleFactor.Signal(array3);
				double[] a = DSP.ConvertComplex.ToMagnitude(fFT.Execute(timeSeries));
				a = DSP.Math.Multiply(a, b);
				float time = getTimeFromIndex(j) * (float)sampleSize;
				preProcessedSpectralFluxAnalyzer.analyzeSpectrum(Array.ConvertAll(a, (double x) => (float)x), time);
				musicAnalysisNow = j;
			}
			FileUtils.SaveFile(Path.Combine(persistentDataPath, "playMusic", musicName + ".gyjzjp"), JsonConvert.SerializeObject(preProcessedSpectralFluxAnalyzer), Path.Combine(persistentDataPath, "playMusic"));
			isAnalysisMusicDone = true;
			isInMusicAnalysis = false;
			UnityEngine.Debug.Log("Spectrum Analysis done");
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log(ex.ToString());
		}
	}

	public float getTimeFromIndex(int index)
	{
		return 1f / (float)sampleRate * (float)index;
	}
}
public class MusicListDataCenter
{
	public class MusicInfo
	{
		public string fullPath { get; set; }

		public string name { get; set; }

		public string bsFolderName { get; set; }

		public bool innterMusic { get; set; }

		public bool bsMusic { get; set; }

		public bool isLike { get; set; }

		public InfoDat bsInfoDat { get; set; }

		public MusicInfo(string fullPath, string name, bool innterMusic = false)
		{
			this.fullPath = fullPath;
			this.name = name;
			bsMusic = false;
			this.innterMusic = innterMusic;
			isLike = false;
		}

		public MusicInfo()
		{
			isLike = false;
		}
	}

	private List<MusicInfo> audioList;

	public List<MusicInfo> audioCurrentList;

	public bool isAudioLoaded;

	private BsMusicListManager bsMusicListManager;

	private UnityWebRequest uwr;

	public MusicListDataCenter()
	{
		audioList = new List<MusicInfo>();
		audioCurrentList = new List<MusicInfo>();
		isAudioLoaded = false;
		bsMusicListManager = new BsMusicListManager();
	}

	public void LoadMusic()
	{
		UnityEngine.Debug.Log("Start Load music" + DateTime.Now);
		if (SceneSelectDataManager.ck)
		{
			List<MusicInfo> list = bsMusicListManager.loadOuterMusic(Path.Combine(Application.persistentDataPath, "playMusic"));
			if (list != null)
			{
				audioList.AddRange(list);
			}
			List<FileInfo> list2 = FileUtils.ReadMusicFileList(Path.Combine(Application.persistentDataPath, "playMusic"));
			for (int i = 0; i < list2.Count; i++)
			{
				FileInfo fileInfo = list2[i];
				audioList.Add(new MusicInfo("<MP3>" + fileInfo.FullName, Path.GetFileNameWithoutExtension(fileInfo.FullName)));
			}
			UnityEngine.Debug.Log(string.Concat("end Load outter music", DateTime.Now, "; path:", Path.Combine(Application.persistentDataPath, "playMusic")));
		}
		audioList.AddRange(getInnerMusicList());
		SetMusicLikeInfo();
		updateaudioCurrentList();
		UnityEngine.Debug.Log("end Load inner music" + DateTime.Now);
		isAudioLoaded = true;
	}

	private void SetMusicLikeInfo()
	{
		List<string> audioListLike = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.audioListLike;
		if (audioListLike == null)
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.audioListLike = new List<string>();
			audioListLike = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.audioListLike;
		}
		for (int i = 0; i < audioListLike.Count; i++)
		{
			string text = audioListLike[i];
			bool flag = false;
			foreach (MusicInfo audio in audioList)
			{
				if (audio.name.Equals(text))
				{
					flag = true;
					audio.isLike = true;
				}
			}
			if (!flag)
			{
				audioListLike.Remove(text);
			}
		}
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
	}

	public void updateaudioCurrentList()
	{
		audioCurrentList.Clear();
		List<string> audioListLike = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.audioListLike;
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.isShowAudioLikeList)
		{
			foreach (MusicInfo audio in audioList)
			{
				foreach (string item in audioListLike)
				{
					if (item.Equals(audio.name))
					{
						audioCurrentList.Add(audio);
						break;
					}
				}
			}
			return;
		}
		audioCurrentList.AddRange(audioList);
	}

	public IEnumerator LoadAudioClip(MusicInfo musicInfo, Action loadDone, Action loadError = null)
	{
		if (musicInfo.innterMusic)
		{
			AudioClip playClip = ((!musicInfo.bsMusic) ? Resources.Load<AudioClip>(Path.Combine("playMusic", musicInfo.name)) : Resources.Load<AudioClip>(Path.Combine("playMusic", musicInfo.bsFolderName, Path.GetFileNameWithoutExtension(musicInfo.bsInfoDat._songFilename))));
			UnitySingleton<DataCenter>.Instance.playClip = playClip;
			loadDone?.Invoke();
			yield break;
		}
		string uri = "file://" + musicInfo.fullPath;
		using (uwr = UnityWebRequestMultimedia.GetAudioClip(uri, musicInfo.bsMusic ? AudioType.OGGVORBIS : AudioType.MPEG))
		{
			UnityEngine.Debug.Log("start read music:" + DateTime.Now);
			yield return uwr.SendWebRequest();
			if (uwr.isNetworkError)
			{
				UnityEngine.Debug.LogError(uwr.error);
				yield break;
			}
			try
			{
				readSingleMusicData();
				loadDone?.Invoke();
			}
			catch (Exception message)
			{
				UnityEngine.Debug.LogError(message);
				loadError?.Invoke();
			}
		}
	}

	private void readSingleMusicData()
	{
		AudioClip content = DownloadHandlerAudioClip.GetContent(uwr);
		UnitySingleton<DataCenter>.Instance.playClip = content;
	}

	private List<MusicInfo> getInnerMusicList()
	{
		List<MusicInfo> list = new List<MusicInfo>();
		list.Add(bsMusicListManager.loadBsMusic("Harajuku Iyahoi - aggrogahu", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("8e48 (Red Sun (Hong Ri) - Joetastic)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("45ca (Pu tong Disco - sbtlo)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("6268 (芒种 - DJ-wdj20xp)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("8949 (灼之花 Burning flower - Schwi)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("a21e (海（sea） - 滢芷)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("dc4 (taohuaduoduokai - xiesseven)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("a921 (Roly Poly - Zounder)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("141 (Gangnam Style - greatyazer)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("c2d3 (Cry Cry - Zounder)", isInner: true));
		list.Add(bsMusicListManager.loadBsMusic("5ad9 (To Zanarkand - Rigid)", isInner: true));
		if (SceneSelectDataManager.ck)
		{
			list.Add(bsMusicListManager.loadBsMusic("23c3 (Without Me - ILLENIUM Remix - styngme)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("155 (Midnight City - bennydabeast)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("459 (Royals (Yinyues Remix) - awfulnaut)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("2f08 (7 rings - Syntheseizure)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("96a (Pacific Rim - yusinosama)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("348 (Shake It Off - jovian)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("570 (Mr. Blue Sky - greatyazer)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("flowerDance1", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("473a (Everybody - kikaeaeon)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("Luv Letter", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("2f59 (Gentleman - Radevirot)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("3d57 (Mr - kikaeaeon)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("4f0f (BAAM - Bloodcloak)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("5ce7 (DDU-DU DDU-DU - Heisenberg)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("a059 (HOT - Joetastic)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("5b0 (aLIEz - bakuenjin)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("12b77 (Moonlight - Dack)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("19cca (Into the Night夜に駆ける - Fefy)", isInner: true));
			list.Add(bsMusicListManager.loadBsMusic("8727 (Lemon - Stumi)", isInner: true));
		}
		return list;
	}
}
public class OpControl
{
	public bool inMusicLoading;

	public OpControl()
	{
		inMusicLoading = false;
	}
}
public class UnitySingleton<T> : MonoBehaviour where T : UnityEngine.Component
{
	public bool IsDontDestroyOnLoad = true;

	private static T _instance;

	public static T Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType(typeof(T)) as T;
				if (_instance == null)
				{
					_instance = (T)new GameObject
					{
						hideFlags = HideFlags.HideAndDontSave
					}.AddComponent(typeof(T));
				}
			}
			return _instance;
		}
	}

	public virtual void Awake()
	{
		if (IsDontDestroyOnLoad)
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		if (_instance == null)
		{
			_instance = this as T;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class BsEvent
{
	public float _time;

	public int _type;

	public int _value;
}
public class BsHipData
{
	public List<BsEvent> _events;

	public List<BsNotes> _notes;

	public List<BsObstacles> _obstacles;
}
public class BsNotes
{
	public float _time;

	public int _lineIndex;

	public int _lineLayer;

	public int _type;

	public int _cutDirection;
}
public class BsObstacles
{
	public float _time;

	public int _lineIndex;

	public int _type;

	public int _width;

	public float _duration;
}
public class BsMusicManager
{
	public bool isBsMusic;

	public bool isInnerBs;

	public string floderPath;

	public InfoDat infoDat;

	public string selectedDifficultyName;

	public BsHipData selectedBsHipData;

	private Dictionary<int, List<GeneratorLaw.BallInfo>> generatorDicBs;

	private Dictionary<int, BsEvent> BsEventDic;

	private Dictionary<int, List<BsWallInfo>> bsWallInfoDic;

	private int delayIndex;

	private int indexDistance;

	public int difficultyRank;

	public static float BsWallOrigin_Z = 70f;

	public static float BsWallOrigin_X_OR = -0.9f;

	public static float BsWallOrigin_X_OR_QX = -1.2f;

	public static float BsWallOrigin_X_Step = 0.45f;

	public static float BsWallOrigin_X_Step_QX = 0.6f;

	public static float BsWallOrigin_Y_Step = 0.45f;

	public static float BsWallOrigin_Y_Step_QX = 0.6f;

	public static float BsWallOrigin_Z_Target = -0.6f;

	public static float BsBall_QX_Shift = 0.075f;

	public static float BsWallWidthSlot = 0.08f;

	public static float JianSuBeiShu = 1f;

	public static float JiaSuBeiShu = 15f;

	public static float slowDistance = 13f;

	public static float rightWeiZhiPosZ = 9f;

	public BsMusicManager()
	{
		isBsMusic = false;
	}

	public InfoDat loadBsMusicInfo(bool isInnerBs, string path = null)
	{
		this.isInnerBs = isInnerBs;
		if (path != null)
		{
			floderPath = path;
		}
		string value = ((!isInnerBs) ? FileUtils.ReadFile(Path.Combine(Application.persistentDataPath, "playMusic", floderPath, "info.dat")) : Resources.Load<TextAsset>(Path.Combine("playMusic", floderPath, "info")).text);
		try
		{
			infoDat = JsonConvert.DeserializeObject<InfoDat>(value);
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
			return null;
		}
		return infoDat;
	}

	public static bool checkBsMusicInfo(bool isInnerBs, string floderPath, InfoDat infoDat)
	{
		try
		{
			foreach (DifficultyBeatmap difficultyBeatmap in infoDat._difficultyBeatmapSets[0]._difficultyBeatmaps)
			{
				if (isInnerBs)
				{
					JsonConvert.DeserializeObject<BsHipData>(Resources.Load<TextAsset>(Path.Combine("playMusic", floderPath, Path.GetFileNameWithoutExtension(difficultyBeatmap._beatmapFilename))).text);
				}
				else
				{
					JsonConvert.DeserializeObject<BsHipData>(FileUtils.ReadFile(Path.Combine(Application.persistentDataPath, "playMusic", floderPath, difficultyBeatmap._beatmapFilename)));
				}
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
			return false;
		}
		return true;
	}

	public void initBsMusic()
	{
		string text = null;
		foreach (DifficultyBeatmap difficultyBeatmap in infoDat._difficultyBeatmapSets[0]._difficultyBeatmaps)
		{
			if (selectedDifficultyName == null || selectedDifficultyName.Equals(difficultyBeatmap._difficulty))
			{
				text = difficultyBeatmap._beatmapFilename;
				difficultyRank = difficultyBeatmap._difficultyRank;
				UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed = ajudstBsSpeed(difficultyBeatmap._noteJumpMovementSpeed);
				break;
			}
		}
		if (isInnerBs)
		{
			string text2 = Resources.Load<TextAsset>(Path.Combine("playMusic", floderPath, Path.GetFileNameWithoutExtension(text))).text;
			selectedBsHipData = JsonConvert.DeserializeObject<BsHipData>(text2);
		}
		else
		{
			string value = FileUtils.ReadFile(Path.Combine(Application.persistentDataPath, "playMusic", floderPath, text));
			selectedBsHipData = JsonConvert.DeserializeObject<BsHipData>(value);
		}
		generatorDicBs = new Dictionary<int, List<GeneratorLaw.BallInfo>>();
		BsEventDic = new Dictionary<int, BsEvent>();
		bsWallInfoDic = new Dictionary<int, List<BsWallInfo>>();
		foreach (BsEvent @event in selectedBsHipData._events)
		{
			int key = Mathf.RoundToInt(@event._time * 60f / infoDat._beatsPerMinute * (float)MainPlayControl.timeIndexPerSeconds);
			BsEvent value2 = null;
			BsEventDic.TryGetValue(key, out value2);
			if (value2 == null)
			{
				BsEventDic.Add(Mathf.RoundToInt(@event._time * 60f / infoDat._beatsPerMinute * (float)MainPlayControl.timeIndexPerSeconds), @event);
			}
		}
		foreach (BsNotes note in selectedBsHipData._notes)
		{
			int num = Mathf.RoundToInt(note._time * 60f / infoDat._beatsPerMinute * (float)MainPlayControl.timeIndexPerSeconds);
			GeneratorLaw.BallInfo ballInfo = getBallInfo(note, num);
			if (ballInfo != null)
			{
				generatorDicBs.TryGetValue(num, out var value3);
				if (value3 == null)
				{
					value3 = new List<GeneratorLaw.BallInfo>();
					value3.Add(ballInfo);
					generatorDicBs.Add(num, value3);
				}
				else
				{
					value3.Add(ballInfo);
				}
			}
		}
		foreach (BsObstacles obstacle in selectedBsHipData._obstacles)
		{
			int num2 = Mathf.RoundToInt(obstacle._time * 60f / infoDat._beatsPerMinute * (float)MainPlayControl.timeIndexPerSeconds);
			BsWallInfo bsWallInfo = getBsWallInfo(obstacle, num2);
			if (bsWallInfo != null)
			{
				bsWallInfoDic.TryGetValue(num2, out var value4);
				if (value4 == null)
				{
					value4 = new List<BsWallInfo>();
					value4.Add(bsWallInfo);
					bsWallInfoDic.Add(num2, value4);
				}
				else
				{
					value4.Add(bsWallInfo);
				}
			}
		}
		delayIndex = 0;
		setDelayedTimeIndex();
		UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex = delayIndex;
	}

	private float ajudstBsSpeed(float noteJumpMovementSpeed)
	{
		if (noteJumpMovementSpeed == 0f)
		{
			noteJumpMovementSpeed = 10f;
		}
		if (noteJumpMovementSpeed > 15f)
		{
			return 13f + UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust;
		}
		if (noteJumpMovementSpeed > 12f)
		{
			return 12f + UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust;
		}
		return noteJumpMovementSpeed + UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.bsSpeedAdjust;
	}

	private void setDelayedTimeIndex()
	{
		foreach (KeyValuePair<int, List<GeneratorLaw.BallInfo>> generatorDicB in generatorDicBs)
		{
			foreach (GeneratorLaw.BallInfo item in generatorDicB.Value)
			{
				BallPosConstantInfo.posDicBs.TryGetValue(item.dingWeiIndex, out var value);
				if (value == null)
				{
					UnityEngine.Debug.Log("dingWeiInfo == null:" + item.dingWeiIndex);
				}
				UnityEngine.Vector3 bsBallOrPos = GetBsBallOrPos(item);
				UnityEngine.Vector3 bsBallTargetPos = GetBsBallTargetPos(item);
				UnityEngine.Vector3 bsBallHitPos = GetBsBallHitPos(item);
				if (!bsBallTargetPos.Equals(UnityEngine.Vector3.zero))
				{
					float num = (bsBallHitPos - bsBallOrPos).magnitude - slowDistance;
					_ = num / (UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed * JiaSuBeiShu);
					_ = MainPlayControl.timeIndexPerSeconds;
					_ = slowDistance / (UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed * JiaSuBeiShu);
					_ = MainPlayControl.timeIndexPerSeconds;
					indexDistance = Convert.ToInt32(num / (UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed * JiaSuBeiShu) * (float)MainPlayControl.timeIndexPerSeconds + slowDistance / (UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed * JianSuBeiShu) * (float)MainPlayControl.timeIndexPerSeconds);
					int num2 = generatorDicB.Key - indexDistance;
					if (num2 < delayIndex)
					{
						delayIndex = num2;
					}
				}
			}
		}
		delayIndex -= 2 * MainPlayControl.timeIndexPerSeconds;
	}

	private GeneratorLaw.BallInfo getBallInfo(BsNotes bsNotes, int timeIndex)
	{
		GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
		ballInfo.dingWeiIndex = 1;
		if (bsNotes._type == 0)
		{
			ballInfo.ballType = GeneratorLaw.BallType.LeftBall;
		}
		else if (bsNotes._type == 1)
		{
			ballInfo.ballType = GeneratorLaw.BallType.RightBall;
		}
		else
		{
			ballInfo.ballType = GeneratorLaw.BallType.BlackBall;
		}
		switch (bsNotes._cutDirection)
		{
		case 0:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.Up;
			break;
		case 1:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.Down;
			break;
		case 2:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.Left;
			break;
		case 3:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.Right;
			break;
		case 4:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.UpLeft;
			break;
		case 5:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.UpRight;
			break;
		case 6:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.DownLeft;
			break;
		case 7:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.DownRight;
			break;
		default:
			ballInfo.ballDirection = GeneratorLaw.BallDirection.All;
			break;
		}
		int x = bsNotes._lineIndex + 1;
		int y = bsNotes._lineLayer + 1;
		ballInfo.targetIndex = new Vector2Int(x, y);
		ballInfo.bsTimeHitTimeIndex = timeIndex;
		return ballInfo;
	}

	private BsWallInfo getBsWallInfo(BsObstacles bsObstacles, int timeIndex)
	{
		return new BsWallInfo
		{
			bsObstacles = bsObstacles,
			originPos = new UnityEngine.Vector3(adjustWallPosX(bsObstacles._lineIndex), 0f, BsWallOrigin_Z),
			targetPos = new UnityEngine.Vector3(adjustWallPosX(bsObstacles._lineIndex), 0f, -0.2f - BsWall._durationBaseLegth * bsObstacles._duration),
			orTargetPos = new UnityEngine.Vector3(adjustWallPosX(bsObstacles._lineIndex), 0f, -0.6f),
			hitPos = new UnityEngine.Vector3(adjustWallPosX(bsObstacles._lineIndex), 0f, UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis),
			hitTimeIndex = timeIndex
		};
	}

	private float adjustWallPosX(int lineIndex)
	{
		float num = 0f;
		switch (lineIndex)
		{
		case 0:
			num = BsWall.BS_WALL_START_1;
			break;
		case 1:
			num = BsWall.BS_WALL_START_2;
			break;
		case 2:
			num = BsWall.BS_WALL_START_3;
			break;
		case 3:
			num = BsWall.BS_WALL_START_4;
			break;
		}
		return num + BsWallWidthSlot;
	}

	internal List<GeneratorLaw.BallInfo> getBallInfoList(int timeIndex)
	{
		List<GeneratorLaw.BallInfo> value = null;
		int key = timeIndex + indexDistance + delayIndex;
		generatorDicBs.TryGetValue(key, out value);
		return value;
	}

	internal List<BsWallInfo> getBsObstaclesList(int timeIndex)
	{
		List<BsWallInfo> value = null;
		int key = timeIndex + indexDistance + delayIndex;
		bsWallInfoDic.TryGetValue(key, out value);
		return value;
	}

	internal float getBsBallSpeed(float speed, UnityEngine.Vector3 position, UnityEngine.Vector3 target, UnityEngine.Vector3 hitTarget, int nowTimeIndex, int hitTimeIndex)
	{
		float magnitude = (position - target).magnitude;
		_ = (target - hitTarget).magnitude;
		if ((double)magnitude - 0.6 > (double)slowDistance)
		{
			return speed * JiaSuBeiShu;
		}
		return speed * JianSuBeiShu;
	}

	internal UnityEngine.Vector3 GetBsBallOrPos(GeneratorLaw.BallInfo ballInfo)
	{
		generatorDicBs.TryGetValue(ballInfo.bsTimeHitTimeIndex, out var value);
		float bsBallX = GetBsBallX(ballInfo, value);
		float bsBallY = GetBsBallY(ballInfo, value);
		return new UnityEngine.Vector3(bsBallX, bsBallY, BsWallOrigin_Z);
	}

	internal UnityEngine.Vector3 GetBsBallTargetPos(GeneratorLaw.BallInfo ballInfo)
	{
		generatorDicBs.TryGetValue(ballInfo.bsTimeHitTimeIndex, out var value);
		float bsBallX = GetBsBallX(ballInfo, value);
		float bsBallY = GetBsBallY(ballInfo, value);
		return new UnityEngine.Vector3(bsBallX, bsBallY, BsWallOrigin_Z_Target);
	}

	internal UnityEngine.Vector3 GetBsBallHitPos(GeneratorLaw.BallInfo ballInfo)
	{
		generatorDicBs.TryGetValue(ballInfo.bsTimeHitTimeIndex, out var value);
		float bsBallX = GetBsBallX(ballInfo, value);
		float bsBallY = GetBsBallY(ballInfo, value);
		float hitDis = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitDis;
		return new UnityEngine.Vector3(bsBallX, bsBallY, hitDis);
	}

	private float GetBsBallX(GeneratorLaw.BallInfo ballInfo, List<GeneratorLaw.BallInfo> ballInfos)
	{
		int x = ballInfo.targetIndex.x;
		int y = ballInfo.targetIndex.y;
		float num = BsWallOrigin_X_OR + (float)(x - 1) * BsWallOrigin_X_Step + BsWallOrigin_X_Step / 2f;
		if (ballInfos == null || ballInfos.Count == 1)
		{
			return num;
		}
		switch (x)
		{
		case 1:
		{
			GeneratorLaw.BallInfo bsBallInOneByIndex4 = GetBsBallInOneByIndex(ballInfos, 2, y);
			if (bsBallInOneByIndex4 != null && bsBallInOneByIndex4.isQSBall() && ballInfo.isQSBall())
			{
				return num - 3f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex4 != null && bsBallInOneByIndex4.isQSBall() && !ballInfo.isQSBall())
			{
				return num - 2f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex4 != null && !bsBallInOneByIndex4.isQSBall() && ballInfo.isQSBall())
			{
				return num - 1f * BsBall_QX_Shift;
			}
			int num4 = y + 1;
			if (num4 < 5)
			{
				GeneratorLaw.BallInfo bsBallInOneByIndex5 = GetBsBallInOneByIndex(ballInfos, 2, num4);
				if (bsBallInOneByIndex5 != null && bsBallInOneByIndex5.isQSBall())
				{
					if (ballInfo.isQSBall())
					{
						return num - 3f * BsBall_QX_Shift;
					}
					return num - 2f * BsBall_QX_Shift;
				}
			}
			int num5 = y - 1;
			if (num5 <= 0)
			{
				break;
			}
			GeneratorLaw.BallInfo bsBallInOneByIndex6 = GetBsBallInOneByIndex(ballInfos, 2, num5);
			if (bsBallInOneByIndex6 != null && bsBallInOneByIndex6.isQSBall())
			{
				if (ballInfo.isQSBall())
				{
					return num - 3f * BsBall_QX_Shift;
				}
				return num - 2f * BsBall_QX_Shift;
			}
			break;
		}
		case 2:
			if (ballInfo.isQSBall())
			{
				return num - 1f * BsBall_QX_Shift;
			}
			break;
		case 3:
			if (ballInfo.isQSBall())
			{
				return num + 1f * BsBall_QX_Shift;
			}
			break;
		case 4:
		{
			GeneratorLaw.BallInfo bsBallInOneByIndex = GetBsBallInOneByIndex(ballInfos, 3, y);
			if (bsBallInOneByIndex != null && bsBallInOneByIndex.isQSBall() && ballInfo.isQSBall())
			{
				return num + 3f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex != null && bsBallInOneByIndex.isQSBall() && !ballInfo.isQSBall())
			{
				return num + 2f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex != null && !bsBallInOneByIndex.isQSBall() && ballInfo.isQSBall())
			{
				return num + 1f * BsBall_QX_Shift;
			}
			int num2 = y + 1;
			if (num2 < 5)
			{
				GeneratorLaw.BallInfo bsBallInOneByIndex2 = GetBsBallInOneByIndex(ballInfos, 3, num2);
				if (bsBallInOneByIndex2 != null && bsBallInOneByIndex2.isQSBall())
				{
					if (ballInfo.isQSBall())
					{
						return num + 2f * BsBall_QX_Shift;
					}
					return num + 1f * BsBall_QX_Shift;
				}
			}
			int num3 = y - 1;
			if (num3 <= 0)
			{
				break;
			}
			GeneratorLaw.BallInfo bsBallInOneByIndex3 = GetBsBallInOneByIndex(ballInfos, 3, num3);
			if (bsBallInOneByIndex3 != null && bsBallInOneByIndex3.isQSBall())
			{
				if (ballInfo.isQSBall())
				{
					return num + 3f * BsBall_QX_Shift;
				}
				return num + 2f * BsBall_QX_Shift;
			}
			break;
		}
		}
		return num;
	}

	private float GetBsBallY(GeneratorLaw.BallInfo ballInfo, List<GeneratorLaw.BallInfo> ballInfos)
	{
		int x = ballInfo.targetIndex.x;
		int y = ballInfo.targetIndex.y;
		float num = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.cubeHeight + (float)(ballInfo.targetIndex.y - 1) * BsWallOrigin_Y_Step + BsWallOrigin_Y_Step / 2f;
		if (ballInfos == null || ballInfos.Count == 1)
		{
			return num;
		}
		switch (y)
		{
		case 1:
		{
			GeneratorLaw.BallInfo bsBallInOneByIndex2 = GetBsBallInOneByIndex(ballInfos, x, 2);
			if (bsBallInOneByIndex2 != null && bsBallInOneByIndex2.isQSBall() && ballInfo.isQSBall())
			{
				return num - 2f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex2 != null && bsBallInOneByIndex2.isQSBall() && !ballInfo.isQSBall())
			{
				return num - 1f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex2 != null && !bsBallInOneByIndex2.isQSBall() && ballInfo.isQSBall())
			{
				return num - 1f * BsBall_QX_Shift;
			}
			break;
		}
		case 2:
			if (ballInfo.isQSBall())
			{
				return num - 1f * BsBall_QX_Shift;
			}
			break;
		case 3:
			if (ballInfo.isQSBall())
			{
				return num + 1f * BsBall_QX_Shift;
			}
			break;
		case 4:
		{
			GeneratorLaw.BallInfo bsBallInOneByIndex = GetBsBallInOneByIndex(ballInfos, x, 3);
			if (bsBallInOneByIndex != null && bsBallInOneByIndex.isQSBall() && ballInfo.isQSBall())
			{
				return num + 2f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex != null && bsBallInOneByIndex.isQSBall() && !ballInfo.isQSBall())
			{
				return num + 1f * BsBall_QX_Shift;
			}
			if (bsBallInOneByIndex != null && !bsBallInOneByIndex.isQSBall() && ballInfo.isQSBall())
			{
				return num + 1f * BsBall_QX_Shift;
			}
			break;
		}
		}
		return num;
	}

	private GeneratorLaw.BallInfo GetBsBallInOneByIndex(List<GeneratorLaw.BallInfo> ballInfos, int xIndex, int yIndex)
	{
		foreach (GeneratorLaw.BallInfo ballInfo in ballInfos)
		{
			if (ballInfo.targetIndex.x == xIndex && ballInfo.targetIndex.y == yIndex)
			{
				return ballInfo;
			}
		}
		return null;
	}

	internal BallFlyPos GetBsBallFlyPos(GeneratorLaw.BallInfo ballInfo)
	{
		BallFlyPos ballFlyPos = new BallFlyPos();
		generatorDicBs.TryGetValue(ballInfo.bsTimeHitTimeIndex, out var value);
		int shiftY = getShiftY(ballInfo, value);
		int shiftX = getShiftX(ballInfo, value);
		GeneratorLaw.BallInfo copy = ballInfo.getCopy();
		copy.targetIndex = new Vector2Int(shiftX, shiftY);
		float bsBallX = GetBsBallX(ballInfo, value);
		float bsBallX2 = GetBsBallX(copy, value);
		float bsBallY = GetBsBallY(ballInfo, value);
		float bsBallY2 = GetBsBallY(copy, value);
		ballFlyPos.originPos = new UnityEngine.Vector3(bsBallX2, bsBallY2, BsWallOrigin_Z);
		ballFlyPos.jiaSuEndPos = new UnityEngine.Vector3(bsBallX2, bsBallY2, slowDistance);
		ballFlyPos.rightWeiZhiPos = new UnityEngine.Vector3(bsBallX, bsBallY, rightWeiZhiPosZ);
		ballFlyPos.originZRotation = GetZRoatateOriginByDirection(ballInfo.ballDirection, ballInfo.ballType);
		ballFlyPos.rightZRotation = GeneratorLaw.GetZRoatateByDirection(ballInfo.ballDirection, ballInfo.ballType);
		ballFlyPos.rightFlyToLeft = false;
		ballFlyPos.leftFlyToRight = false;
		if (shiftX != ballInfo.targetIndex.x)
		{
			if (ballInfo.ballType == GeneratorLaw.BallType.LeftBall)
			{
				ballFlyPos.rightFlyToLeft = true;
			}
			else
			{
				ballFlyPos.leftFlyToRight = true;
			}
		}
		return ballFlyPos;
	}

	private int getShiftX(GeneratorLaw.BallInfo ballInfo, List<GeneratorLaw.BallInfo> ballInfos)
	{
		int x = ballInfo.targetIndex.x;
		if (!isShiftX(ballInfos))
		{
			return x;
		}
		if (ballInfo.ballType == GeneratorLaw.BallType.LeftBall)
		{
			if (ballInfo.targetIndex.x == 2)
			{
				return x - 1;
			}
			return x - 2;
		}
		if (ballInfo.ballType == GeneratorLaw.BallType.RightBall)
		{
			if (ballInfo.targetIndex.x == 3)
			{
				return x + 1;
			}
			return x + 2;
		}
		return x;
	}

	private bool isShiftX(List<GeneratorLaw.BallInfo> ballInfos)
	{
		if (ballInfos == null || ballInfos.Count != 2)
		{
			return false;
		}
		bool flag = false;
		bool flag2 = false;
		int num = 0;
		int num2 = 0;
		foreach (GeneratorLaw.BallInfo ballInfo in ballInfos)
		{
			if (ballInfo.ballType == GeneratorLaw.BallType.RightBall)
			{
				num2 = ballInfo.targetIndex.x;
			}
			if (ballInfo.ballType == GeneratorLaw.BallType.LeftBall)
			{
				num = ballInfo.targetIndex.x;
			}
			if (ballInfo.ballType == GeneratorLaw.BallType.RightBall && ballInfo.targetIndex.x < 3)
			{
				flag2 = true;
			}
			if (ballInfo.ballType == GeneratorLaw.BallType.LeftBall && ballInfo.targetIndex.x > 2)
			{
				flag = true;
			}
		}
		if (!(flag && flag2) && (num != 2 || num2 != 1))
		{
			if (num == 4)
			{
				return num2 == 3;
			}
			return false;
		}
		return true;
	}

	private int getShiftY(GeneratorLaw.BallInfo ballInfo, List<GeneratorLaw.BallInfo> ballInfos)
	{
		int y = ballInfo.targetIndex.y;
		if (ballInfos == null)
		{
			return y;
		}
		if (y == 1)
		{
			return y;
		}
		return getBlewNum(ballInfo.targetIndex, ballInfos) + 1;
	}

	private int getBlewNum(Vector2Int targetIndex, List<GeneratorLaw.BallInfo> ballInfos)
	{
		int num = 0;
		foreach (GeneratorLaw.BallInfo ballInfo in ballInfos)
		{
			if (ballInfo.targetIndex.x == targetIndex.x && ballInfo.targetIndex.y < targetIndex.y)
			{
				num++;
			}
		}
		return num;
	}

	private float GetZRoatateOriginByDirection(GeneratorLaw.BallDirection direction, GeneratorLaw.BallType ballType)
	{
		if (direction == GeneratorLaw.BallDirection.All || ballType == GeneratorLaw.BallType.BlackBall)
		{
			return 0f;
		}
		return direction switch
		{
			GeneratorLaw.BallDirection.Up => 180f, 
			GeneratorLaw.BallDirection.Left => 270f, 
			GeneratorLaw.BallDirection.Right => 90f, 
			GeneratorLaw.BallDirection.UpLeft => 180f, 
			GeneratorLaw.BallDirection.UpRight => 90f, 
			GeneratorLaw.BallDirection.DownLeft => 270f, 
			GeneratorLaw.BallDirection.DownRight => 0f, 
			_ => 0f, 
		};
	}
}
public class BsMusicListManager
{
	internal MusicListDataCenter.MusicInfo loadBsMusic(string floderName, bool isInner = false)
	{
		MusicListDataCenter.MusicInfo musicInfo = new MusicListDataCenter.MusicInfo();
		musicInfo.bsFolderName = floderName;
		musicInfo.innterMusic = isInner;
		musicInfo.bsMusic = true;
		musicInfo.bsInfoDat = UnitySingleton<DataCenter>.Instance.bsMusicManager.loadBsMusicInfo(isInnerBs: true, floderName);
		if (musicInfo.bsInfoDat == null)
		{
			UnityEngine.Debug.LogError("bsDebugLoad fail");
			return null;
		}
		musicInfo.bsInfoDat = UnitySingleton<DataCenter>.Instance.bsMusicManager.infoDat;
		musicInfo.name = musicInfo.bsInfoDat._songName;
		return musicInfo;
	}

	internal List<MusicListDataCenter.MusicInfo> loadOuterMusic(string playMusicPath)
	{
		List<MusicListDataCenter.MusicInfo> list = new List<MusicListDataCenter.MusicInfo>();
		foreach (string bsFolder in FileUtils.getBsFolderList(playMusicPath))
		{
			MusicListDataCenter.MusicInfo musicInfo = new MusicListDataCenter.MusicInfo();
			musicInfo.bsFolderName = bsFolder;
			musicInfo.innterMusic = false;
			musicInfo.bsMusic = true;
			musicInfo.bsInfoDat = UnitySingleton<DataCenter>.Instance.bsMusicManager.loadBsMusicInfo(isInnerBs: false, bsFolder);
			if (musicInfo.bsInfoDat == null)
			{
				UnityEngine.Debug.LogError("bsDebugLoad fail");
				continue;
			}
			musicInfo.name = musicInfo.bsInfoDat._songName;
			musicInfo.fullPath = Path.Combine(Application.persistentDataPath, "playMusic", musicInfo.bsFolderName, UnitySingleton<DataCenter>.Instance.bsMusicManager.infoDat._songFilename);
			list.Add(musicInfo);
		}
		return list;
	}
}
public class DifficultyBeatmap
{
	public string _difficulty;

	public int _difficultyRank;

	public string _beatmapFilename;

	public float _noteJumpMovementSpeed;
}
public class DifficultyBeatmapSet
{
	public string _beatmapCharacteristicName;

	public List<DifficultyBeatmap> _difficultyBeatmaps;
}
public class InfoDat
{
	public float _beatsPerMinute;

	public float _previewStartTime;

	public float _previewDuration;

	public string _songFilename;

	public string _songName;

	public List<DifficultyBeatmapSet> _difficultyBeatmapSets;
}
public class BsLevelSetting : MonoBehaviour
{
	public GameObject hipSettingLevel;

	public GameObject hipSettingDetail;

	public GameObject bsLevelSetting;

	public musicSelectManagerN musicSelectManagerNObj;

	public GameObject levelEasy;

	public GameObject levelNormal;

	public GameObject levelHard;

	public GameObject levelExpert;

	public GameObject levelExpertPlus;

	private MusicListDataCenter.MusicInfo selectedMusicInfo;

	public string selectedLevelName;

	private GameObject selectedLevel;

	private List<GameObject> levelBtnList = new List<GameObject>();

	private Dictionary<string, GameObject> levelDic = new Dictionary<string, GameObject>();

	private Dictionary<GameObject, string> levelStrDic = new Dictionary<GameObject, string>();

	public static string Easy = "Easy";

	public static string Normal = "Normal";

	public static string Hard = "Hard";

	public static string Expert = "Expert";

	public static string ExpertPlus = "ExpertPlus";

	private void Awake()
	{
		levelBtnList.Add(levelEasy);
		levelBtnList.Add(levelNormal);
		levelBtnList.Add(levelHard);
		levelBtnList.Add(levelExpert);
		levelBtnList.Add(levelExpertPlus);
		for (int i = 0; i < levelBtnList.Count; i++)
		{
			Button component = levelBtnList[i].transform.Find("normal").GetComponent<Button>();
			int level = i;
			component.onClick.AddListener(delegate
			{
				setBsLevelParam(level);
			});
		}
		levelDic.Add(Easy, levelEasy);
		levelDic.Add(Normal, levelNormal);
		levelDic.Add(Hard, levelHard);
		levelDic.Add(Expert, levelExpert);
		levelDic.Add(ExpertPlus, levelExpertPlus);
		levelStrDic.Add(levelEasy, Easy);
		levelStrDic.Add(levelNormal, Normal);
		levelStrDic.Add(levelHard, Hard);
		levelStrDic.Add(levelExpert, Expert);
		levelStrDic.Add(levelExpertPlus, ExpertPlus);
	}

	private void Start()
	{
		hipSettingLevel.SetActive(value: false);
		hipSettingDetail.SetActive(value: false);
		bsLevelSetting.SetActive(value: false);
	}

	public void hideAll()
	{
		hipSettingLevel.SetActive(value: false);
		hipSettingDetail.SetActive(value: false);
		bsLevelSetting.SetActive(value: false);
	}

	public void NormalMusicSelected()
	{
		hipSettingLevel.SetActive(value: true);
		hipSettingDetail.SetActive(value: true);
		bsLevelSetting.SetActive(value: false);
		UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic = false;
	}

	public void BsMusicSelected()
	{
		hipSettingLevel.SetActive(value: false);
		hipSettingDetail.SetActive(value: false);
		bsLevelSetting.SetActive(value: true);
		disableAll();
		loadLevel();
		UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic = true;
	}

	public void disableAll()
	{
		foreach (GameObject levelBtn in levelBtnList)
		{
			Button component = levelBtn.transform.Find("normal").GetComponent<Button>();
			component.interactable = false;
			AudioSourceCommon.ClearPointEnterAudio(component.transform);
		}
	}

	private void loadLevel()
	{
		foreach (DifficultyBeatmap difficultyBeatmap in selectedMusicInfo.bsInfoDat._difficultyBeatmapSets[0]._difficultyBeatmaps)
		{
			string difficulty = difficultyBeatmap._difficulty;
			levelDic.TryGetValue(difficulty, out var value);
			if (value != null)
			{
				value.transform.Find("normal").GetComponent<Button>().interactable = true;
				AudioSourceCommon.AttachPointEnterAudio(value.transform.Find("normal"));
			}
		}
	}

	internal void setBsLevel(MusicListDataCenter.MusicInfo musicInfo)
	{
		if (musicInfo.bsMusic)
		{
			selectedMusicInfo = musicInfo;
			if (selectedLevel != null)
			{
				selectedLevel.transform.Find("normal").gameObject.SetActive(value: true);
				selectedLevel.transform.Find("selected").gameObject.SetActive(value: false);
			}
			selectedLevelName = null;
			selectedLevel = null;
			BsMusicSelected();
		}
		else
		{
			NormalMusicSelected();
			selectedMusicInfo = null;
		}
	}

	private void setBsLevelParam(int level)
	{
		GameObject key = levelBtnList[level];
		if (selectedLevel != null)
		{
			selectedLevel.transform.Find("normal").gameObject.SetActive(value: true);
			selectedLevel.transform.Find("selected").gameObject.SetActive(value: false);
		}
		selectedLevel = key;
		selectedLevel.transform.Find("normal").gameObject.SetActive(value: false);
		selectedLevel.transform.Find("selected/Text").GetComponent<Text>().text = selectedLevel.transform.Find("normal/Text").GetComponent<Text>().text;
		selectedLevel.transform.Find("selected").gameObject.SetActive(value: true);
		levelStrDic.TryGetValue(key, out var value);
		selectedLevelName = value;
		UnitySingleton<DataCenter>.Instance.bsMusicManager.infoDat = selectedMusicInfo.bsInfoDat;
		UnitySingleton<DataCenter>.Instance.bsMusicManager.selectedDifficultyName = selectedLevelName;
		UnitySingleton<DataCenter>.Instance.bsMusicManager.floderPath = selectedMusicInfo.bsFolderName;
		UnitySingleton<DataCenter>.Instance.bsMusicManager.isInnerBs = selectedMusicInfo.innterMusic;
		musicSelectManagerNObj.startGameBtnEnable(enable: true);
	}
}
public class MusicSelectManagerN
{
}
public class BsWall : MonoBehaviour
{
	internal MainPlayControl mainPlayControl;

	private static float missAddIntervalTime = 0.1f;

	private static float inHeadCheckTime = 0.05f;

	public GameObject type0;

	public GameObject type1;

	public Material bianMat;

	private float lastMissCountTime;

	private UnityEngine.Vector3 target;

	private float speed;

	private bool isInHead;

	private float inHeadMissedTime;

	private float checkMissedTime;

	private BsWallInfo bsWallInfo;

	public static float _durationBaseLegth = 3.1f;

	private float bsSlowSpeed;

	public int flyDongHuaStage;

	public static float BS_WALL_START_1 = -1.2f;

	public static float BS_WALL_START_2 = -0.45f;

	public static float BS_WALL_START_3 = 0f;

	public static float BS_WALL_START_4 = 0.6f;

	public static float BS_WALL_END_1 = -0.6f;

	public static float BS_WALL_END_2 = 0f;

	public static float BS_WALL_END_3 = 0.45f;

	public static float BS_WALL_END_4 = 1.2f;

	public static float endDis = 0.1f;

	internal void initWall(BsWallInfo bsWallInfo, float speed)
	{
		lastMissCountTime = -1f;
		hideAll();
		this.bsWallInfo = bsWallInfo;
		UnityEngine.Vector3 vector = new UnityEngine.Vector3(adjustBsWallWidthX(bsWallInfo.bsObstacles._lineIndex, bsWallInfo.bsObstacles._width), 1f, _durationBaseLegth * bsWallInfo.bsObstacles._duration);
		if (bsWallInfo.bsObstacles._type == 0)
		{
			type0.SetActive(value: true);
			type0.GetComponentInChildren<BsWallCube>().AdjustBoraderScale(vector);
		}
		else
		{
			type1.SetActive(value: true);
			type1.GetComponentInChildren<BsWallCube>().AdjustBoraderScale(vector);
		}
		base.transform.localScale = vector;
		target = bsWallInfo.targetPos;
		this.speed = speed;
		setBianColor();
		bsSlowSpeed = -1f;
		flyDongHuaStage = 0;
	}

	private float adjustBsWallWidthX(int lineIndex, int width)
	{
		float num = 0f;
		switch (lineIndex)
		{
		case 0:
			num = BS_WALL_START_1;
			break;
		case 1:
			num = BS_WALL_START_2;
			break;
		case 2:
			num = BS_WALL_START_3;
			break;
		case 3:
			num = BS_WALL_START_4;
			break;
		}
		float num2 = 0f;
		switch (lineIndex + width)
		{
		case 1:
			num2 = BS_WALL_END_1;
			break;
		case 2:
			num2 = BS_WALL_END_2;
			break;
		case 3:
			num2 = BS_WALL_END_3;
			break;
		case 4:
			num2 = BS_WALL_END_4;
			break;
		}
		return (num2 - num - 2f * BsMusicManager.BsWallWidthSlot) / 0.6f;
	}

	private void Update()
	{
		if (isInHead)
		{
			if (checkMissedTime > inHeadCheckTime)
			{
				isInHead = false;
			}
			checkMissedTime += Time.deltaTime;
		}
		if (mainPlayControl.pause)
		{
			return;
		}
		float num = speed * Time.deltaTime;
		_ = BsMusicManager.slowDistance;
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua == 1)
		{
			_ = BsMusicManager.rightWeiZhiPosZ;
		}
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua == 1)
			{
				if (flyDongHuaStage == 0)
				{
					if (base.transform.position.z - BsMusicManager.slowDistance < endDis)
					{
						flyDongHuaStage = 1;
						base.transform.position = new UnityEngine.Vector3(base.transform.position.x, base.transform.position.y, BsMusicManager.slowDistance);
					}
					else
					{
						num = speed * BsMusicManager.JiaSuBeiShu * Time.deltaTime;
						base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, new UnityEngine.Vector3(base.transform.position.x, base.transform.position.y, BsMusicManager.slowDistance), num);
					}
				}
				else if (flyDongHuaStage == 1)
				{
					if (base.transform.position.z - BsMusicManager.rightWeiZhiPosZ < endDis)
					{
						flyDongHuaStage = 2;
						base.transform.position = new UnityEngine.Vector3(base.transform.position.x, base.transform.position.y, BsMusicManager.rightWeiZhiPosZ);
						bsSlowSpeed = -1f;
					}
					else
					{
						if (bsSlowSpeed < 0f)
						{
							bsSlowSpeed = (base.transform.position.z - bsWallInfo.hitPos.z) / (((float)(bsWallInfo.hitTimeIndex - UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex) + 0f) / (float)MainPlayControl.timeIndexPerSeconds - mainPlayControl.thisTime);
						}
						num = bsSlowSpeed * Time.deltaTime;
						base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, new UnityEngine.Vector3(base.transform.position.x, base.transform.position.y, BsMusicManager.rightWeiZhiPosZ), num);
					}
				}
				else
				{
					if (bsSlowSpeed < 0f)
					{
						bsSlowSpeed = (base.transform.position.z - bsWallInfo.hitPos.z) / (((float)(bsWallInfo.hitTimeIndex - UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex) + 0f) / (float)MainPlayControl.timeIndexPerSeconds - mainPlayControl.thisTime);
						UnityEngine.Debug.Log("wall speed:" + bsSlowSpeed);
					}
					num = bsSlowSpeed * Time.deltaTime;
					base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, num);
				}
			}
			else
			{
				num = UnitySingleton<DataCenter>.Instance.bsMusicManager.getBsBallSpeed(speed, base.gameObject.transform.position, bsWallInfo.orTargetPos, bsWallInfo.hitPos, mainPlayControl.timeIndex, bsWallInfo.hitTimeIndex) * Time.deltaTime;
				if (bsSlowSpeed < 0f && base.transform.position.z < BsMusicManager.slowDistance)
				{
					bsSlowSpeed = (base.transform.position.z - bsWallInfo.hitPos.z) / (((float)(bsWallInfo.hitTimeIndex - UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex) + 0f) / (float)MainPlayControl.timeIndexPerSeconds - mainPlayControl.thisTime);
					num = bsSlowSpeed * Time.deltaTime;
					UnityEngine.Debug.Log("wall speed:" + bsSlowSpeed);
				}
				if (bsSlowSpeed > 0f)
				{
					num = bsSlowSpeed * Time.deltaTime;
				}
				base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, num);
			}
		}
		if ((target - base.transform.position).magnitude < 0.01f)
		{
			hideAll();
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void hideAll()
	{
		type0.SetActive(value: false);
		type1.SetActive(value: false);
	}

	internal void inHead()
	{
		checkMissedTime = 0f;
		if (!isInHead)
		{
			isInHead = true;
			inHeadMissedTime = 0f;
			return;
		}
		inHeadMissedTime += Time.deltaTime;
		if (inHeadMissedTime > missAddIntervalTime)
		{
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 0);
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 1);
			UnitySingleton<AudioManager>.Instance.PlayMusicOnce("hitFail");
			UnitySingleton<DataCenter>.Instance.AddMissed();
			inHeadMissedTime = 0f;
			UnityEngine.Debug.Log("hit head!!!!!!!!!!!!!1");
		}
	}

	private void setBianColor()
	{
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.wallBianColor);
		bianMat.SetColor("Color_D98005D8", cubeColor);
	}
}
public class BsWallCube : MonoBehaviour
{
	public BsWall wall;

	public List<Transform> YScaleLine;

	public List<Transform> XScaleLine;

	public List<Transform> ZScaleLine;

	private void OnCollisionEnter(Collision collision)
	{
		collision.gameObject.name.Equals("HeadCollider");
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject.name.Equals("HeadCollider"))
		{
			wall.inHead();
		}
	}

	public void AdjustBoraderScale(UnityEngine.Vector3 bsWallScale)
	{
		UnityEngine.Vector3 scale = new UnityEngine.Vector3(1f / bsWallScale.z, 1f, 1f / bsWallScale.y);
		adjustList(scale, XScaleLine);
		UnityEngine.Vector3 scale2 = new UnityEngine.Vector3(1f / bsWallScale.x, 1f, 1f / bsWallScale.z);
		adjustList(scale2, YScaleLine);
		UnityEngine.Vector3 scale3 = new UnityEngine.Vector3(1f / bsWallScale.x, 1f, 1f / bsWallScale.y);
		adjustList(scale3, ZScaleLine);
	}

	private void adjustList(UnityEngine.Vector3 scale, List<Transform> scaleLine)
	{
		foreach (Transform item in scaleLine)
		{
			UnityEngine.Vector3 localScale = item.localScale;
			UnityEngine.Vector3 localScale2 = new UnityEngine.Vector3(localScale.x * scale.x, localScale.y * scale.y, localScale.z * scale.z);
			item.localScale = localScale2;
		}
	}
}
public class BsWallInfo
{
	public UnityEngine.Vector3 originPos;

	public UnityEngine.Vector3 targetPos;

	public UnityEngine.Vector3 orTargetPos;

	public UnityEngine.Vector3 hitPos;

	public int hitTimeIndex;

	public BsObstacles bsObstacles;
}
public class GameSettingManager : MonoBehaviour
{
	public Button hitSoundSubBtn;

	public TMP_Text hitSoundValue;

	public Button hitSoundAddBtn;

	public Button execriseModeSubBtn;

	public TMP_Text execriseModeValue;

	public Button execriseModeAddBtn;

	public Button loadMyHitSoundSubBtn;

	public TMP_Text loadMyHitSoundValue;

	public Button loadMyHitSoundAddBtn;

	public Button hitFailSoundSubBtn;

	public TMP_Text hitFailSoundValue;

	public Button hitFailSoundAddBtn;

	private void Awake()
	{
		AudioSourceCommon.AttachPointEnterAudio(hitSoundSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(hitSoundAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(execriseModeSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(execriseModeAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(loadMyHitSoundSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(loadMyHitSoundAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(hitFailSoundSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(hitFailSoundAddBtn.transform);
	}

	private void Start()
	{
		setHitSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitSound);
		setHitFailSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound);
		setExcriseModeText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.execriseMode);
		setLoadMyHitSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound);
	}

	private void setLoadMyHitSoundText(int loadMyHitSound)
	{
		if (loadMyHitSound == 0)
		{
			loadMyHitSoundValue.text = "关";
		}
		else
		{
			loadMyHitSoundValue.text = "开";
		}
	}

	private void setExcriseModeText(int execriseMode)
	{
		if (execriseMode == 0)
		{
			execriseModeValue.text = "关";
		}
		else
		{
			execriseModeValue.text = "开";
		}
	}

	private void setHitSoundText(int hitSound)
	{
		switch (hitSound)
		{
		case 0:
			hitSoundValue.text = "关";
			break;
		case 1:
			hitSoundValue.text = "低";
			break;
		case 2:
			hitSoundValue.text = "中";
			break;
		default:
			hitSoundValue.text = "高";
			break;
		}
	}

	private void setHitFailSoundText(int hitFailSound)
	{
		switch (hitFailSound)
		{
		case 0:
			hitFailSoundValue.text = "关";
			break;
		case 1:
			hitFailSoundValue.text = "低";
			break;
		case 2:
			hitFailSoundValue.text = "中";
			break;
		default:
			hitFailSoundValue.text = "高";
			break;
		}
	}

	public void clickHitSoundSub()
	{
		int hitSound = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitSound;
		if (hitSound != 0)
		{
			hitSound--;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setHitSound(hitSound);
			setHitSoundText(hitSound);
		}
	}

	public void clickHitSoundAdd()
	{
		int hitSound = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitSound;
		if (hitSound != 3)
		{
			hitSound++;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setHitSound(hitSound);
			setHitSoundText(hitSound);
		}
	}

	public void clickHitFailSoundSub()
	{
		int hitFailSound = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound;
		if (hitFailSound != 0)
		{
			hitFailSound--;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound = hitFailSound;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			setHitFailSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound);
		}
	}

	public void clickHitFailSoundAdd()
	{
		int hitFailSound = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound;
		if (hitFailSound != 3)
		{
			hitFailSound++;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound = hitFailSound;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			setHitFailSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.hitFailSound);
		}
	}

	public void clickExcriseModeSub()
	{
		int execriseMode = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.execriseMode;
		if (execriseMode != 0)
		{
			execriseMode--;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setExecriseMode(execriseMode);
			setExcriseModeText(execriseMode);
		}
	}

	public void clickExcriseModeAdd()
	{
		int execriseMode = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.execriseMode;
		if (execriseMode != 1)
		{
			execriseMode++;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setExecriseMode(execriseMode);
			setExcriseModeText(execriseMode);
		}
	}

	public void clickLoadMyHitSoundSub()
	{
		int loadMyHitSound = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound;
		if (loadMyHitSound != 0)
		{
			loadMyHitSound--;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound = loadMyHitSound;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			setLoadMyHitSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound);
		}
	}

	public void clickLoadMyHitSoundAdd()
	{
		int loadMyHitSound = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound;
		if (loadMyHitSound != 1)
		{
			loadMyHitSound++;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound = loadMyHitSound;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
			setLoadMyHitSoundText(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound);
		}
	}
}
public class BreakOnCollision : MonoBehaviour
{
	public bool breaked;

	public float time;

	public MainSelectBall mainSelectBall;

	public Animator animator;

	private void Start()
	{
		time = 0f;
	}

	private void Update()
	{
		if (breaked)
		{
			time += Time.deltaTime;
			if (time > 2f)
			{
				GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/trans/selectCube");
				animator.Play("dissapear");
			}
		}
	}

	public void cubeDissapear()
	{
		base.gameObject.SetActive(value: false);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void OnCollisionEnter(Collision collision)
	{
		if (!breaked)
		{
			mainSelectBall.cubeBreak();
		}
	}
}
public class MainSelectBall : MonoBehaviour
{
	public float speed = 8f;

	private UnityEngine.Vector3 target;

	public GameObject ball;

	public ParticleSystem startEffect;

	public ShatterTool shatterTool;

	public Transform cubeSplitPoint;

	public Transform cubeSplitPoint2;

	public Transform cubeSplitPoint3;

	public bool splited;

	private void Start()
	{
		target = new UnityEngine.Vector3(0f, MainSelectBallControl.ballHeight, 0f);
	}

	private void Update()
	{
		if (!splited)
		{
			float maxDistanceDelta = speed * Time.deltaTime;
			base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, maxDistanceDelta);
		}
	}

	internal void cubeBreak()
	{
		shatterTool.Shatter(cubeSplitPoint.position);
		UnityEngine.Plane plane = new UnityEngine.Plane(cubeSplitPoint.position, cubeSplitPoint2.position, cubeSplitPoint3.position);
		(new UnityEngine.Plane[1])[0] = plane;
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class MainSelectBallControl : MonoBehaviour
{
	private class TransformAndGenTime
	{
		public Transform startPos;

		public int genTime;

		public TransformAndGenTime(Transform pos)
		{
			startPos = pos;
		}
	}

	public GameObject mainSelectBallPrefab;

	public Transform startPos1;

	public Transform startPos2;

	public Transform startPos3;

	public Transform startPos4;

	public Transform startPos5;

	public Transform startPos6;

	private float thisTime;

	private int timeIndex;

	public static float ballHeight = 0.75f;

	private TransformAndGenTime transformAndGenTime1;

	private TransformAndGenTime transformAndGenTime2;

	private TransformAndGenTime transformAndGenTime3;

	private TransformAndGenTime transformAndGenTime4;

	private TransformAndGenTime transformAndGenTime5;

	private TransformAndGenTime transformAndGenTime6;

	private void Start()
	{
		thisTime = 0f;
		timeIndex = 0;
		transformAndGenTime1 = new TransformAndGenTime(startPos1);
		transformAndGenTime2 = new TransformAndGenTime(startPos2);
		transformAndGenTime3 = new TransformAndGenTime(startPos3);
		transformAndGenTime4 = new TransformAndGenTime(startPos4);
		transformAndGenTime5 = new TransformAndGenTime(startPos5);
		transformAndGenTime6 = new TransformAndGenTime(startPos6);
	}

	private void Update()
	{
		if (!((double)Time.deltaTime > 0.05))
		{
			thisTime += Time.deltaTime;
			if (!(thisTime * 20f < (float)(timeIndex + 1)))
			{
				timeIndex = Mathf.FloorToInt(thisTime * (float)MainPlayControl.timeIndexPerSeconds);
				generateBall(transformAndGenTime1);
				generateBall(transformAndGenTime2);
				generateBall(transformAndGenTime3);
				generateBall(transformAndGenTime4);
				generateBall(transformAndGenTime5);
				generateBall(transformAndGenTime6);
			}
		}
	}

	private void generateBall(TransformAndGenTime transformAndGenTime)
	{
		if (timeIndex >= transformAndGenTime.genTime)
		{
			Transform startPos = transformAndGenTime.startPos;
			UnityEngine.Vector3 position = default(UnityEngine.Vector3);
			position.y = ballHeight;
			position.x = startPos.Find("pos").position.x;
			position.z = startPos.Find("pos").position.z;
			float y = startPos.rotation.eulerAngles.y;
			UnityEngine.Object.Instantiate(mainSelectBallPrefab, position, UnityEngine.Quaternion.Euler(0f, y, 0f)).GetComponent<MainSelectBall>().startEffect.Play();
			transformAndGenTime.genTime += Mathf.FloorToInt((float)MainPlayControl.timeIndexPerSeconds * UnityEngine.Random.Range(4f, 8f));
		}
	}
}
public class GameCompleteInfoManagerN : MonoBehaviour
{
	public GameObject titleSuccess;

	public GameObject titleFail;

	public GameObject exeriseMode;

	public Text musicName;

	public Text hipSettingLevel;

	public Text playTime;

	public Text averageSpeed;

	public Text chengjiu;

	public Text fastSpeed;

	public Text hitCubes;

	public Text hitCubesFail;

	public Text levelGet;

	public Text totalScore;

	public GameObject Loading;

	public MainSelectN mainSelectN;

	public GameObject particleFireWork;

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(base.transform.Find("gameCompleteInfo/reStartBtn"));
		AudioSourceCommon.AttachPointEnterAudio(base.transform.Find("gameCompleteInfo/huiZhuCaiDanBtn"));
	}

	public void init()
	{
		GamePlayInfo gamePlayInfo = UnitySingleton<DataCenter>.Instance.gamePlayInfo;
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.execriseMode == 1)
		{
			titleSuccess.SetActive(value: false);
			titleFail.SetActive(value: false);
			exeriseMode.SetActive(value: true);
			particleFireWork.SetActive(value: false);
		}
		else if (gamePlayInfo.gameSuccess)
		{
			titleSuccess.SetActive(value: true);
			titleFail.SetActive(value: false);
			exeriseMode.SetActive(value: false);
			particleFireWork.SetActive(value: true);
		}
		else
		{
			titleSuccess.SetActive(value: false);
			titleFail.SetActive(value: true);
			exeriseMode.SetActive(value: false);
			particleFireWork.SetActive(value: false);
		}
		musicName.text = "音乐: " + gamePlayInfo.playMusicName;
		hipSettingLevel.text = "总得分: " + gamePlayInfo.totalScore;
		playTime.text = "音乐时长: " + gamePlayInfo.playTime;
		if (gamePlayInfo.hitNum == 0)
		{
			averageSpeed.text = "平均击打分数: 0";
		}
		else
		{
			averageSpeed.text = "平均击打分数: " + (gamePlayInfo.totalhitSpeed / (float)gamePlayInfo.hitNum).ToString("f1");
		}
		chengjiu.text = "获得成就: " + UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastGetChengJiuStr();
		fastSpeed.text = "最高击打分数: " + gamePlayInfo.fastHitSpeed.ToString("f1");
		hitCubes.text = "打击成功方块数: " + gamePlayInfo.hitSuccessNum;
		hitCubesFail.text = "打击失败方块数: " + gamePlayInfo.hitFailNum;
		levelGet.text = "段位获得: " + UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastGetLevelStr();
		totalScore.text = "综合评分: " + UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastTotalSocre().ToString("f1");
	}

	public void reStart()
	{
		UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading = true;
		UnitySingleton<DataCenter>.Instance.initMusic();
		Loading.transform.parent.gameObject.SetActive(value: true);
		Loading.SetActive(value: true);
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			Loading.transform.Find("First").gameObject.SetActive(value: false);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: true);
		}
		else if (UnitySingleton<DataCenter>.Instance.musicDataCenter.isfirstTimeLoad)
		{
			Loading.transform.Find("First").gameObject.SetActive(value: true);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: false);
		}
		else
		{
			Loading.transform.Find("First").gameObject.SetActive(value: false);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: true);
		}
		base.gameObject.SetActive(value: false);
	}

	public void backToMainMenu()
	{
		mainSelectN.initNormal();
	}
}
public class HipSettingManagerN : MonoBehaviour
{
	public GameObject level1;

	public GameObject level2;

	public GameObject level3;

	public GameObject level4;

	public GameObject level5;

	public GameObject level6;

	public GameObject level7;

	public GameObject level8;

	public GameObject level9;

	public GameObject level10;

	public GameObject level11;

	public TMP_Text currentLevelText;

	public Button cubePerSecondsSubBtn;

	public TMP_Text cubePerSecondsValue;

	public Button cubePerSecondsAddBtn;

	public Button gateNumSubBtn;

	public TMP_Text gateNumValue;

	public Button gateNumAddBtn;

	public Button flySpeedSubBtn;

	public TMP_Text flySpeedValue;

	public Button flySpeedAddBtn;

	public Button comboLevelSubBtn;

	public TMP_Text comboLevelValue;

	public Button comboLevelAddBtn;

	public Button wallLevelSubBtn;

	public TMP_Text wallLevelValue;

	public Button wallLevelAddBtn;

	public Text hipLevelMaxAllowScore;

	public Text hipLevelScore;

	public HipSettingData hipSettingData;

	public Animator animator;

	private HipSettingDataManager hipSettingDataManager;

	private List<GameObject> levelBtnList = new List<GameObject>();

	private GameObject selectedLevel;

	private void Awake()
	{
		levelBtnList.Add(level1);
		levelBtnList.Add(level2);
		levelBtnList.Add(level3);
		levelBtnList.Add(level4);
		levelBtnList.Add(level5);
		levelBtnList.Add(level6);
		levelBtnList.Add(level7);
		levelBtnList.Add(level8);
		levelBtnList.Add(level9);
		levelBtnList.Add(level10);
		levelBtnList.Add(level11);
		AudioSourceCommon.AttachPointEnterAudio(cubePerSecondsSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(cubePerSecondsAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(gateNumSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(gateNumAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(flySpeedSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(flySpeedAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(comboLevelSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(comboLevelAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(wallLevelSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(wallLevelAddBtn.transform);
		for (int i = 0; i < levelBtnList.Count; i++)
		{
			Button component = levelBtnList[i].transform.Find("normal").GetComponent<Button>();
			int level = i + 1;
			component.onClick.AddListener(delegate
			{
				setLevelSuggestParam(level);
			});
		}
	}

	private void setLevelSuggestParam(int level)
	{
		hipSettingData = hipSettingDataManager.getSuggestionSettingByLevel(level, hipSettingData.level);
		GameObject gameObject = levelBtnList[level - 1];
		if (selectedLevel != null)
		{
			selectedLevel.transform.Find("normal").gameObject.SetActive(value: true);
			selectedLevel.transform.Find("selected").gameObject.SetActive(value: false);
		}
		selectedLevel = gameObject;
		selectedLevel.transform.Find("normal").gameObject.SetActive(value: false);
		selectedLevel.transform.Find("selected/Text").GetComponent<Text>().text = selectedLevel.transform.Find("normal/Text").GetComponent<Text>().text;
		selectedLevel.transform.Find("selected").gameObject.SetActive(value: true);
		setHipValue(clearSelected: false);
	}

	public void init()
	{
		hipSettingDataManager = UnitySingleton<DataCenter>.Instance.hipSettingDataManager;
		hipSettingData = hipSettingDataManager.hipSettingData.getCopyHipSettingData();
		setLevelEnable();
		setLevelText();
		setHipValue();
	}

	private void setHipValue(bool clearSelected = true)
	{
		cubePerSecondsValue.text = hipSettingDataManager.cubesPerSecondsValueList[hipSettingData.cubesPerSeconds].ToString();
		gateNumValue.text = hipSettingDataManager.gateNumStrList[hipSettingData.gateNum].ToString();
		flySpeedValue.text = hipSettingDataManager.flySpeedValueList[hipSettingData.cubeFlySpeed].ToString();
		comboLevelValue.text = hipSettingDataManager.comboLevelStrList[hipSettingData.comboLevel].ToString();
		wallLevelValue.text = hipSettingDataManager.wallLevelStrList[hipSettingData.wallComboLevel].ToString();
		int hipScoreBySetting = hipSettingDataManager.getHipScoreBySetting(hipSettingData);
		hipLevelScore.text = "难度系数: " + hipScoreBySetting;
		hipSettingDataManager.SaveHipSettingData(hipSettingData);
		if (clearSelected && selectedLevel != null)
		{
			selectedLevel.transform.Find("normal").gameObject.SetActive(value: true);
			selectedLevel.transform.Find("selected").gameObject.SetActive(value: false);
		}
	}

	private void setLevelText()
	{
		currentLevelText.text = "当前段位: " + hipSettingDataManager.getLevelNameById(hipSettingData.level);
		hipLevelMaxAllowScore.text = "最高可挑战难度: " + hipSettingData.level * 10;
	}

	private void setLevelEnable()
	{
		for (int i = 0; i < levelBtnList.Count; i++)
		{
			Button component = levelBtnList[i].transform.Find("normal").GetComponent<Button>();
			component.interactable = false;
			AudioSourceCommon.ClearPointEnterAudio(component.transform);
		}
		for (int j = 0; j < hipSettingData.level + 1 && j < levelBtnList.Count; j++)
		{
			Button component2 = levelBtnList[j].transform.Find("normal").GetComponent<Button>();
			component2.interactable = true;
			AudioSourceCommon.AttachPointEnterAudio(component2.transform);
		}
	}

	public void clickCubePerSecondsSub()
	{
		if (hipSettingData.cubesPerSeconds > 0)
		{
			hipSettingData.cubesPerSeconds--;
			setHipValue();
		}
	}

	private void playChao()
	{
		animator.Play("Chao", 0, 0f);
	}

	public void clickCubePerSecondsAdd()
	{
		if (hipSettingData.cubesPerSeconds < hipSettingDataManager.cubesPerSecondsValueList.Count - 1)
		{
			hipSettingData.cubesPerSeconds++;
			if (checkAddToLimit())
			{
				playChao();
				hipSettingData.cubesPerSeconds--;
			}
			else
			{
				setHipValue();
			}
		}
	}

	private bool checkAddToLimit()
	{
		int hipScoreBySetting = hipSettingDataManager.getHipScoreBySetting(hipSettingData);
		return hipSettingDataManager.checkHipScoreTooHigh(hipScoreBySetting, hipSettingData.level);
	}

	public void clickGateNumSub()
	{
		if (hipSettingData.gateNum > 0)
		{
			hipSettingData.gateNum--;
			setHipValue();
		}
	}

	public void clickGateNumAdd()
	{
		if (hipSettingData.gateNum < hipSettingDataManager.gateNumStrList.Count - 1)
		{
			hipSettingData.gateNum++;
			if (checkAddToLimit())
			{
				playChao();
				hipSettingData.gateNum--;
			}
			else
			{
				setHipValue();
			}
		}
	}

	public void clickFlySpeedSub()
	{
		if (hipSettingData.cubeFlySpeed > 0)
		{
			hipSettingData.cubeFlySpeed--;
			setHipValue();
		}
	}

	public void clickFlySpeedAdd()
	{
		if (hipSettingData.cubeFlySpeed < hipSettingDataManager.flySpeedValueList.Count - 1)
		{
			hipSettingData.cubeFlySpeed++;
			if (checkAddToLimit())
			{
				playChao();
				hipSettingData.cubeFlySpeed--;
			}
			else
			{
				setHipValue();
			}
		}
	}

	public void clickcomboLevelSub()
	{
		if (hipSettingData.comboLevel > 0)
		{
			hipSettingData.comboLevel--;
			setHipValue();
		}
	}

	public void clickcomboLevelAdd()
	{
		if (hipSettingData.comboLevel < hipSettingDataManager.comboLevelStrList.Count - 1)
		{
			hipSettingData.comboLevel++;
			if (checkAddToLimit())
			{
				playChao();
				hipSettingData.comboLevel--;
			}
			else
			{
				setHipValue();
			}
		}
	}

	public void clickWallLevelSub()
	{
		if (hipSettingData.wallComboLevel > 0)
		{
			hipSettingData.wallComboLevel--;
			setHipValue();
		}
	}

	public void clickWallLevelAdd()
	{
		if (hipSettingData.wallComboLevel < hipSettingDataManager.wallLevelStrList.Count - 1)
		{
			hipSettingData.wallComboLevel++;
			if (checkAddToLimit())
			{
				playChao();
				hipSettingData.wallComboLevel--;
			}
			else
			{
				setHipValue();
			}
		}
	}
}
public class ChengJiuManagerN : MonoBehaviour
{
	public Text firstTime;

	public Text tiliQiangren;

	public Text lingshiwu;

	public Text baijuzhan;

	public Text qianjuzhan;

	public Text dongzuogaoshou;

	public Text huijiankuangzhan;

	public Text mantianfeiwu;

	public Text xuanzhuandaren;

	public Text fanyingzuikuai;

	public Text ChengjiuDetailInfo;

	private Color getedColor = new Color(1f, 1f, 1f);

	private Color unGetedColor = new Color(0.5f, 0.5f, 0.5f);

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(firstTime.transform, firstTimeHint);
		AudioSourceCommon.AttachPointEnterAudio(tiliQiangren.transform, tiliQiangrenHint);
		AudioSourceCommon.AttachPointEnterAudio(lingshiwu.transform, lingshiwuHint);
		AudioSourceCommon.AttachPointEnterAudio(baijuzhan.transform, baijuzhanHint);
		AudioSourceCommon.AttachPointEnterAudio(qianjuzhan.transform, qianjuzhanHint);
		AudioSourceCommon.AttachPointEnterAudio(dongzuogaoshou.transform, dongzuogaoshouHint);
		AudioSourceCommon.AttachPointEnterAudio(huijiankuangzhan.transform, huijiankuangzhanHint);
		AudioSourceCommon.AttachPointEnterAudio(mantianfeiwu.transform, mantianfeiwuHint);
		AudioSourceCommon.AttachPointEnterAudio(xuanzhuandaren.transform, xuanzhuandarenHint);
		AudioSourceCommon.AttachPointEnterAudio(fanyingzuikuai.transform, fanyingzuikuaiHint);
	}

	private void firstTimeHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "第一次：第一次挑战成功后获得";
	}

	private void tiliQiangrenHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "体力强人：音乐时长大于8分钟，且难度系数大于30，挑战成功后获得";
	}

	private void lingshiwuHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "零失误：挑战过程中成功打击所有方块，难度系数大于30，挑战成功后获得";
	}

	private void baijuzhanHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "百局斩：完成100局挑战后获得";
	}

	private void qianjuzhanHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "千局斩：完成1000局挑战后获得";
	}

	private void dongzuogaoshouHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "动作高手：动作难度为极难，挑战成功后获得";
	}

	private void huijiankuangzhanHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "挥剑狂斩：平均打击速度大于35米/秒，且难度系数大于30，挑战成功后获得";
	}

	private void mantianfeiwuHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "漫天飞舞：平均每秒打击节拍数为4，挑战成功后获得";
	}

	private void xuanzhuandarenHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "旋转达人：传送门数量为360度，且难度系数大于30，挑战成功后获得";
	}

	private void fanyingzuikuaiHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "反应最快：方块飞行速度为11，且难度系数大于30，挑战成功后获得";
	}

	internal void init()
	{
		ChengJiuData chengJiuData = UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.chengJiuData;
		if (chengJiuData.firstTime)
		{
			firstTime.text = "第一次(已获得)";
			firstTime.color = getedColor;
		}
		else
		{
			firstTime.text = "第一次(未获得)";
			firstTime.color = unGetedColor;
		}
		if (chengJiuData.lingshiwu)
		{
			lingshiwu.text = "零失误(已获得)";
			lingshiwu.color = getedColor;
		}
		else
		{
			lingshiwu.text = "零失误(未获得)";
			lingshiwu.color = unGetedColor;
		}
		if (chengJiuData.tiliQiangren)
		{
			tiliQiangren.text = "体力强人(已获得)";
			tiliQiangren.color = getedColor;
		}
		else
		{
			tiliQiangren.text = "体力强人(未获得)";
			tiliQiangren.color = unGetedColor;
		}
		if (chengJiuData.baijuzhan)
		{
			baijuzhan.text = "百局斩(已获得)";
			baijuzhan.color = getedColor;
		}
		else
		{
			baijuzhan.text = "百局斩(未获得)";
			baijuzhan.color = unGetedColor;
		}
		if (chengJiuData.qianjuzhan)
		{
			qianjuzhan.text = "千局斩(已获得)";
			qianjuzhan.color = getedColor;
		}
		else
		{
			qianjuzhan.text = "千局斩(未获得)";
			qianjuzhan.color = unGetedColor;
		}
		if (chengJiuData.dongzuogaoshou)
		{
			dongzuogaoshou.text = "动作高手(已获得)";
			dongzuogaoshou.color = getedColor;
		}
		else
		{
			dongzuogaoshou.text = "动作高手(未获得)";
			dongzuogaoshou.color = unGetedColor;
		}
		if (chengJiuData.huijiankuangzhan)
		{
			huijiankuangzhan.text = "挥剑狂斩(已获得)";
			huijiankuangzhan.color = getedColor;
		}
		else
		{
			huijiankuangzhan.text = "挥剑狂斩(未获得)";
			huijiankuangzhan.color = unGetedColor;
		}
		if (chengJiuData.mantianfeiwu)
		{
			mantianfeiwu.text = "漫天飞舞(已获得)";
			mantianfeiwu.color = getedColor;
		}
		else
		{
			mantianfeiwu.text = "漫天飞舞(未获得)";
			mantianfeiwu.color = unGetedColor;
		}
		if (chengJiuData.xuanzhuandaren)
		{
			xuanzhuandaren.text = "旋转达人(已获得)";
			xuanzhuandaren.color = getedColor;
		}
		else
		{
			xuanzhuandaren.text = "旋转达人(未获得)";
			xuanzhuandaren.color = unGetedColor;
		}
		if (chengJiuData.fanyingzuikuai)
		{
			fanyingzuikuai.text = "反应最快(已获得)";
			fanyingzuikuai.color = getedColor;
		}
		else
		{
			fanyingzuikuai.text = "反应最快(未获得)";
			fanyingzuikuai.color = unGetedColor;
		}
		ChengjiuDetailInfo.gameObject.SetActive(value: false);
	}
}
public class TiaoZhanLiShiManagerN : MonoBehaviour
{
	public GameObject HistoryDetailItem1;

	public GameObject HistoryDetailItem2;

	public GameObject HistoryDetailItem3;

	public GameObject HistoryDetailItem4;

	public GameObject HistoryDetailItem5;

	public Button prevBtn;

	public Button nextBtn;

	public Text pageText;

	private int currentPage;

	private int totalPage;

	private List<HistoryDetailData> historyDetailDataList;

	private const int pageSize = 5;

	private void start()
	{
		AudioSourceCommon.AttachPointEnterAudio(prevBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(nextBtn.transform);
	}

	internal void init()
	{
		historyDetailDataList = new List<HistoryDetailData>();
		for (int num = UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.historyDetailDataList.Count - 1; num >= 0; num--)
		{
			historyDetailDataList.Add(UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.historyDetailDataList[num]);
		}
		currentPage = 1;
		totalPage = historyDetailDataList.Count / 5 + 1;
		setListData();
		setPage();
	}

	private void setPage()
	{
		prevBtn.gameObject.SetActive(value: true);
		nextBtn.gameObject.SetActive(value: true);
		if (currentPage == 1)
		{
			prevBtn.gameObject.SetActive(value: false);
		}
		if (currentPage == totalPage)
		{
			nextBtn.gameObject.SetActive(value: false);
		}
		pageText.text = currentPage + "/" + totalPage + "页";
	}

	public void nextPage()
	{
		currentPage++;
		setListData();
		setPage();
	}

	public void prevPage()
	{
		currentPage--;
		setListData();
		setPage();
	}

	private void setListData()
	{
		HistoryDetailItem1.SetActive(value: false);
		HistoryDetailItem2.SetActive(value: false);
		HistoryDetailItem3.SetActive(value: false);
		HistoryDetailItem4.SetActive(value: false);
		HistoryDetailItem5.SetActive(value: false);
		for (int i = 0; i < 5; i++)
		{
			int num = (currentPage - 1) * 5 + i;
			if (num < historyDetailDataList.Count)
			{
				HistoryDetailData historyDetailData = historyDetailDataList[num];
				if (i == 0)
				{
					setDetailData(HistoryDetailItem1, historyDetailData);
				}
				if (i == 1)
				{
					setDetailData(HistoryDetailItem2, historyDetailData);
				}
				if (i == 2)
				{
					setDetailData(HistoryDetailItem3, historyDetailData);
				}
				if (i == 3)
				{
					setDetailData(HistoryDetailItem4, historyDetailData);
				}
				if (i == 4)
				{
					setDetailData(HistoryDetailItem5, historyDetailData);
				}
				continue;
			}
			break;
		}
	}

	private void setDetailData(GameObject historyDetailItem, HistoryDetailData historyDetailData)
	{
		historyDetailItem.SetActive(value: true);
		historyDetailItem.transform.Find("musicName").GetComponent<Text>().text = historyDetailData.musicName;
		historyDetailItem.transform.Find("hipLevelScore").GetComponent<Text>().text = historyDetailData.hipLevelScore.ToString();
		historyDetailItem.transform.Find("sucess").GetComponent<Text>().text = (historyDetailData.sucess ? "成功" : "失败");
		historyDetailItem.transform.Find("getChengJiu").GetComponent<Text>().text = historyDetailData.getChengJiu;
		historyDetailItem.transform.Find("getLevel").GetComponent<Text>().text = historyDetailData.getLevel;
		historyDetailItem.transform.Find("playScore").GetComponent<Text>().text = historyDetailData.playScore.ToString("f1");
		historyDetailItem.transform.Find("playTime").GetComponent<Text>().text = historyDetailData.playTime;
	}
}
public class TiaoZhanTongJiManagerN : MonoBehaviour
{
	public Text totalPlays;

	public Text totalSuccessPlays;

	public Text totalFailPlays;

	public Text totalSuccessFailRate;

	public Text highestHipLevelScoreSuccessPlay;

	public Text highestGameScorePlay;

	public Text fastestHit;

	public Text longestSinglePlay;

	internal void init()
	{
		HistoryTotalData historyTotalData = UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.historyTotalData;
		totalPlays.text = "总挑战局数：" + historyTotalData.totalPlays;
		totalSuccessPlays.text = "挑战成功局数：" + historyTotalData.totalSuccessPlays;
		totalFailPlays.text = "挑战失败局数：" + historyTotalData.totalFailPlays;
		float num = historyTotalData.totalSuccessPlays;
		float num2 = historyTotalData.totalPlays;
		totalSuccessFailRate.text = "挑战成功率：" + ((historyTotalData.totalPlays == 0) ? 0f : (num / num2 * 100f)).ToString("f1") + "%";
		highestHipLevelScoreSuccessPlay.text = "挑战成功最高难度系数：" + historyTotalData.highestHipLevelScoreSuccessPlay;
		highestGameScorePlay.text = "最高综合评分：" + historyTotalData.highestGameScorePlay;
		fastestHit.text = "最快挥剑速度：" + historyTotalData.fastestHit.ToString("f1") + "米/秒";
		longestSinglePlay.text = "最长音乐时长：" + getTimeStr(historyTotalData.longestSinglePlay);
	}

	private string getTimeStr(int longestSinglePlay)
	{
		int num = Mathf.FloorToInt(longestSinglePlay / MainPlayControl.timeIndexPerSeconds / 60);
		int num2 = (longestSinglePlay - num * 60 * MainPlayControl.timeIndexPerSeconds) / MainPlayControl.timeIndexPerSeconds;
		return num + "分" + num2 + "秒";
	}
}
public class InfoManagerN : MonoBehaviour
{
	public Button YouXiShuoMingBtn;

	public Button HuoDeChengJiuBtn;

	public Button TiaoZhanTongJiBtn;

	public Button TiaoZhanLiShiBtn;

	public Button GuanYuZuoZheBtn;

	public GameObject YouXiShuoMingContent;

	public GameObject HuoDeChengJiuContent;

	public GameObject TiaoZhanTongJiContent;

	public GameObject TiaoZhanLiShiContent;

	public GameObject GuanYuZuoZheContent;

	private Button selectedBtn;

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(YouXiShuoMingBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(HuoDeChengJiuBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(TiaoZhanTongJiBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(TiaoZhanLiShiBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(GuanYuZuoZheBtn.transform);
		YouXiShuoMingSelect();
	}

	public void YouXiShuoMingSelect()
	{
		hideAll();
		YouXiShuoMingContent.SetActive(value: true);
		setSelectedBtn(YouXiShuoMingBtn);
	}

	public void HuoDeChengJiuSelect()
	{
		hideAll();
		HuoDeChengJiuContent.SetActive(value: true);
		setSelectedBtn(HuoDeChengJiuBtn);
	}

	public void TiaoZhanTongJiSelect()
	{
		hideAll();
		TiaoZhanTongJiContent.SetActive(value: true);
		setSelectedBtn(TiaoZhanTongJiBtn);
	}

	public void TiaoZhanLiShiSelect()
	{
		hideAll();
		TiaoZhanLiShiContent.SetActive(value: true);
		setSelectedBtn(TiaoZhanLiShiBtn);
	}

	public void GuanYuZuoZheSelect()
	{
		hideAll();
		GuanYuZuoZheContent.SetActive(value: true);
		setSelectedBtn(GuanYuZuoZheBtn);
	}

	private void setSelectedBtn(Button newSelectedBtn)
	{
		selectedBtn = newSelectedBtn;
		selectedBtn.transform.Find("Quad").gameObject.SetActive(value: false);
		selectedBtn.transform.Find("QuadSelected").gameObject.SetActive(value: true);
		selectedBtn.enabled = false;
	}

	private void hideAll()
	{
		setUnSelectedBorder(YouXiShuoMingBtn);
		setUnSelectedBorder(HuoDeChengJiuBtn);
		setUnSelectedBorder(TiaoZhanTongJiBtn);
		setUnSelectedBorder(TiaoZhanLiShiBtn);
		setUnSelectedBorder(GuanYuZuoZheBtn);
		YouXiShuoMingContent.SetActive(value: false);
		HuoDeChengJiuContent.SetActive(value: false);
		TiaoZhanTongJiContent.SetActive(value: false);
		TiaoZhanLiShiContent.SetActive(value: false);
		GuanYuZuoZheContent.SetActive(value: false);
	}

	public void setUnSelectedBorder(Button btn)
	{
		btn.transform.Find("Quad").gameObject.SetActive(value: true);
		btn.transform.Find("QuadSelected").gameObject.SetActive(value: false);
		btn.enabled = true;
	}
}
public class MainSelectN : MonoBehaviour
{
	public GameObject left;

	public GameObject center;

	public GameObject right;

	public GameObject gameCompleteInfo;

	public GameObject loading;

	public GameObject particleNoraml;

	public GameObject particleFireWork;

	private void Start()
	{
		UnitySingleton<DataCenter>.Instance.initLoad();
		if (UnitySingleton<DataCenter>.Instance.returnFromGame)
		{
			left.SetActive(value: false);
			center.SetActive(value: false);
			right.SetActive(value: false);
			particleNoraml.SetActive(value: false);
			gameCompleteInfo.GetComponent<GameCompleteInfoManagerN>().init();
			gameCompleteInfo.SetActive(value: true);
		}
		else
		{
			initNormal();
		}
		loading.SetActive(value: false);
	}

	private void Update()
	{
	}

	public void initNormal()
	{
		left.SetActive(value: true);
		center.SetActive(value: true);
		right.SetActive(value: true);
		gameCompleteInfo.SetActive(value: false);
		particleFireWork.SetActive(value: false);
		particleNoraml.SetActive(value: true);
		center.transform.Find("musicSelect").GetComponent<musicSelectManagerN>().init();
		left.GetComponent<HipSettingManagerN>().init();
		right.transform.Find("info/Content/HuoDeChengJiu").GetComponent<ChengJiuManagerN>().init();
		right.transform.Find("info/Content/TiaoZhanTongJi").GetComponent<TiaoZhanTongJiManagerN>().init();
		right.transform.Find("info/Content/TiaoZhanLiShi").GetComponent<TiaoZhanLiShiManagerN>().init();
	}

	internal void hideNormal()
	{
		left.SetActive(value: false);
		center.SetActive(value: false);
		right.SetActive(value: false);
		gameCompleteInfo.SetActive(value: false);
	}
}
public class TiYanBanInfo : MonoBehaviour
{
	public GameObject info1;

	public GameObject info2;

	public GameObject MaiLeInfo;

	private void Start()
	{
		if (SceneSelectDataManager.ck)
		{
			info1.SetActive(value: false);
			info2.SetActive(value: false);
			MaiLeInfo.SetActive(value: true);
		}
		else
		{
			info1.SetActive(value: true);
			info2.SetActive(value: false);
			MaiLeInfo.SetActive(value: false);
		}
	}

	private void Update()
	{
	}
}
public class musicSelectManagerN : MonoBehaviour
{
	private const int PageSize = 12;

	public Button PrevPage;

	public Button NextPage;

	public Button StartGame;

	public Button ExitGame;

	public Button ShowAllList;

	public Button ShowLikeList;

	public Text PageText;

	public GameObject Container;

	public GameObject Loading;

	public AudioSource audioSource;

	public MainSelectN mainSelectN;

	public GameObject notPass;

	public BsLevelSetting bsLevelSetting;

	private GameObject selectedMusicItem;

	private int selectedMusicIndex;

	private int totalPage;

	private int currentPage;

	private bool inited;

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(PrevPage.transform);
		AudioSourceCommon.AttachPointEnterAudio(NextPage.transform);
		AudioSourceCommon.AttachPointEnterAudio(StartGame.transform);
		AudioSourceCommon.AttachPointEnterAudio(ExitGame.transform);
		AudioSourceCommon.AttachPointEnterAudio(ShowAllList.transform);
		AudioSourceCommon.AttachPointEnterAudio(ShowLikeList.transform);
	}

	public void init()
	{
		_ = inited;
		if (audioSource.isPlaying)
		{
			audioSource.Stop();
		}
		bsLevelSetting.hideAll();
		clearSelect();
		PrevPage.gameObject.SetActive(value: false);
		NextPage.gameObject.SetActive(value: false);
		Loading.SetActive(value: false);
		Container.SetActive(value: false);
		PageText.text = "1/1页";
		UpdataMusicListUI();
		SetPageSatus();
		inited = true;
		SetLikeListButton();
	}

	private void SetLikeListButton()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.isShowAudioLikeList)
		{
			ShowAllList.transform.Find("QuadSelected").gameObject.SetActive(value: false);
			ShowAllList.transform.Find("QuadNotSelected").gameObject.SetActive(value: true);
			ShowLikeList.transform.Find("QuadSelected").gameObject.SetActive(value: true);
			ShowLikeList.transform.Find("QuadNotSelected").gameObject.SetActive(value: false);
		}
		else
		{
			ShowAllList.transform.Find("QuadSelected").gameObject.SetActive(value: true);
			ShowAllList.transform.Find("QuadNotSelected").gameObject.SetActive(value: false);
			ShowLikeList.transform.Find("QuadSelected").gameObject.SetActive(value: false);
			ShowLikeList.transform.Find("QuadNotSelected").gameObject.SetActive(value: true);
		}
	}

	public void showAllList()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.isShowAudioLikeList)
		{
			UnitySingleton<DataCenter>.Instance.musicPage = 1;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.isShowAudioLikeList = false;
			UnitySingleton<DataCenter>.Instance.musicListDataCenter.updateaudioCurrentList();
			init();
		}
	}

	public void showLikeList()
	{
		if (!UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.isShowAudioLikeList)
		{
			UnitySingleton<DataCenter>.Instance.musicPage = 1;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.isShowAudioLikeList = true;
			UnitySingleton<DataCenter>.Instance.musicListDataCenter.updateaudioCurrentList();
			init();
		}
	}

	private void UpdataMusicListUI()
	{
		totalPage = UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList.Count / 12 + 1;
		if (12 * (totalPage - 1) == UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList.Count)
		{
			totalPage--;
		}
		currentPage = UnitySingleton<DataCenter>.Instance.musicPage;
		SetPageData();
	}

	private void SetPageData()
	{
		for (int i = 0; i < 12; i++)
		{
			Container.transform.Find(string.Concat(i + 1)).gameObject.SetActive(value: false);
		}
		for (int j = 0; j < 12; j++)
		{
			int index = (currentPage - 1) * 12 + j;
			if (index >= UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList.Count)
			{
				break;
			}
			GameObject gameObject = Container.transform.Find(string.Concat(j + 1)).gameObject;
			string text = index + 1 + ". " + UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[index].name;
			gameObject.transform.Find("musicItem").Find("Text").GetComponent<Text>()
				.text = text;
			gameObject.transform.Find("musicItem").GetComponent<Button>().onClick.RemoveAllListeners();
			int itemIndex = j;
			gameObject.transform.Find("musicItem").GetComponent<Button>().onClick.AddListener(delegate
			{
				SelecteMusic(index, itemIndex);
			});
			AudioSourceCommon.AttachPointEnterAudio(gameObject.transform.Find("musicItem"));
			if (UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[index].isLike)
			{
				gameObject.transform.Find("LikeBtn/Like").gameObject.SetActive(value: true);
				gameObject.transform.Find("LikeBtn/NotLike").gameObject.SetActive(value: false);
			}
			else
			{
				gameObject.transform.Find("LikeBtn/Like").gameObject.SetActive(value: false);
				gameObject.transform.Find("LikeBtn/NotLike").gameObject.SetActive(value: true);
			}
			gameObject.transform.Find("LikeBtn").GetComponent<Button>().onClick.RemoveAllListeners();
			gameObject.transform.Find("LikeBtn").GetComponent<Button>().onClick.AddListener(delegate
			{
				setLike(index, itemIndex);
			});
			gameObject.SetActive(value: true);
		}
		Container.SetActive(value: true);
	}

	private void SetPageSatus()
	{
		PageText.text = currentPage + "/" + totalPage + "页";
		if (currentPage != 1)
		{
			PrevPage.gameObject.SetActive(value: true);
		}
		else
		{
			PrevPage.gameObject.SetActive(value: false);
		}
		if (currentPage != totalPage)
		{
			NextPage.gameObject.SetActive(value: true);
		}
		else
		{
			NextPage.gameObject.SetActive(value: false);
		}
		UnitySingleton<DataCenter>.Instance.musicPage = currentPage;
	}

	public void ToNextPage()
	{
		currentPage++;
		clearSelect(pageChange: true);
		SetPageData();
		SetPageSatus();
	}

	public void ToPrevPage()
	{
		currentPage--;
		clearSelect(pageChange: true);
		SetPageData();
		SetPageSatus();
	}

	public void StartToPlayGame()
	{
		try
		{
			UnitySingleton<DataCenter>.Instance.musicName = UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[selectedMusicIndex].name;
			UnitySingleton<DataCenter>.Instance.initMusic();
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
			loadMusicError();
			return;
		}
		PrevPage.gameObject.SetActive(value: false);
		NextPage.gameObject.SetActive(value: false);
		Loading.SetActive(value: false);
		Container.SetActive(value: false);
		startGameBtnEnable(enable: false);
		UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading = true;
		Loading.transform.parent.gameObject.SetActive(value: true);
		Loading.SetActive(value: true);
		if (UnitySingleton<DataCenter>.Instance.musicDataCenter.isfirstTimeLoad && !UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			Loading.transform.Find("First").gameObject.SetActive(value: true);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: false);
		}
		else
		{
			Loading.transform.Find("First").gameObject.SetActive(value: false);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: true);
		}
		mainSelectN.hideNormal();
	}

	public void startGameBtnEnable(bool enable)
	{
		if (enable)
		{
			StartGame.interactable = true;
			Text component = StartGame.transform.Find("Text").GetComponent<Text>();
			component.color = new Color(component.color.r, component.color.g, component.color.b, 1f);
			AudioSourceCommon.AttachPointEnterAudio(StartGame.transform);
		}
		else
		{
			StartGame.interactable = false;
			Text component2 = StartGame.transform.Find("Text").GetComponent<Text>();
			component2.color = new Color(component2.color.r, component2.color.g, component2.color.b, 0.5f);
			AudioSourceCommon.ClearPointEnterAudio(StartGame.transform);
		}
	}

	private void clearSelect(bool pageChange = false)
	{
		if (selectedMusicIndex != -1)
		{
			if (selectedMusicItem != null)
			{
				selectedMusicItem.transform.Find("musicItem").GetComponent<Animator>().Play("Normal");
				selectedMusicItem.transform.Find("musicItem").GetComponent<Button>().enabled = true;
			}
			selectedMusicItem = null;
			if (!pageChange)
			{
				selectedMusicIndex = -1;
				startGameBtnEnable(enable: false);
				bsLevelSetting.hideAll();
			}
		}
	}

	public void SelecteMusic(int musicIndex, int itemIdex)
	{
		GameObject musicItem = Container.transform.Find(string.Concat(itemIdex + 1)).gameObject;
		if (musicIndex != selectedMusicIndex)
		{
			MusicListDataCenter.MusicInfo musicInfo = UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex];
			if (musicInfo.bsMusic && !BsMusicManager.checkBsMusicInfo(musicInfo.innterMusic, musicInfo.bsFolderName, musicInfo.bsInfoDat))
			{
				loadMusicError();
			}
			else
			{
				PlayMusic(musicItem, musicIndex);
			}
		}
	}

	public void setLike(int musicIndex, int itemIdex)
	{
		GameObject gameObject = Container.transform.Find(string.Concat(itemIdex + 1)).gameObject;
		if (UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex].isLike)
		{
			gameObject.transform.Find("LikeBtn/Like").gameObject.SetActive(value: false);
			gameObject.transform.Find("LikeBtn/NotLike").gameObject.SetActive(value: true);
			UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex].isLike = false;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.audioListLike.Remove(UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex].name);
		}
		else
		{
			gameObject.transform.Find("LikeBtn/Like").gameObject.SetActive(value: true);
			gameObject.transform.Find("LikeBtn/NotLike").gameObject.SetActive(value: false);
			UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex].isLike = true;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.audioListLike.Add(UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex].name);
		}
		UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.SaveSelectedSceneData();
	}

	public void PlayMusic(GameObject musicItem, int musicIndex)
	{
		IEnumerator routine = UnitySingleton<DataCenter>.Instance.musicListDataCenter.LoadAudioClip(UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex], delegate
		{
			audioSource.clip = UnitySingleton<DataCenter>.Instance.playClip;
			audioSource.Play();
			if (!UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[musicIndex].bsMusic)
			{
				startGameBtnEnable(enable: true);
			}
			else
			{
				startGameBtnEnable(enable: false);
			}
			selectedMusicIndex = musicIndex;
			if (selectedMusicItem != null)
			{
				selectedMusicItem.transform.Find("musicItem").GetComponent<Animator>().Play("Normal");
				selectedMusicItem.transform.Find("musicItem").GetComponent<Button>().enabled = true;
			}
			selectedMusicItem = musicItem;
			selectedMusicItem.transform.Find("musicItem").GetComponent<Button>().Select();
			bsLevelSetting.setBsLevel(UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[selectedMusicIndex]);
		}, loadMusicError);
		StartCoroutine(routine);
	}

	public void loadMusicError()
	{
		GetComponent<infoMusicFail>().ShowInfoMusicFail();
	}

	public void QuitGyjz()
	{
		GradualBlack.instance.blackMidAction = delegate
		{
			Application.Quit();
		};
		GradualBlack.instance.playAll = false;
		GradualBlack.instance.StartGradualBlack();
	}

	private void Update()
	{
	}
}
public class sceneSelectedManagerN : MonoBehaviour
{
	public GameObject Bs;

	public GameObject BsJian;

	public GameObject jiHeGuangYing;

	public GameObject fire;

	public GameObject ice;

	public GameObject thunder;

	public GameObject zhongShiGuiGuai;

	public GameObject xiQing;

	public GameObject BsSteet;

	public GameObject BsSteet2;

	private GameObject selectedScene;

	private List<GameObject> secenList;

	private int selectedIndex;

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(Bs.transform);
		AudioSourceCommon.AttachPointEnterAudio(BsJian.transform);
		AudioSourceCommon.AttachPointEnterAudio(jiHeGuangYing.transform);
		AudioSourceCommon.AttachPointEnterAudio(fire.transform);
		AudioSourceCommon.AttachPointEnterAudio(ice.transform);
		AudioSourceCommon.AttachPointEnterAudio(thunder.transform);
		AudioSourceCommon.AttachPointEnterAudio(zhongShiGuiGuai.transform);
		AudioSourceCommon.AttachPointEnterAudio(xiQing.transform);
		AudioSourceCommon.AttachPointEnterAudio(BsSteet.transform);
		AudioSourceCommon.AttachPointEnterAudio(BsSteet2.transform);
		secenList = new List<GameObject>();
		secenList.Add(jiHeGuangYing);
		secenList.Add(fire);
		secenList.Add(ice);
		secenList.Add(thunder);
		secenList.Add(zhongShiGuiGuai);
		secenList.Add(xiQing);
		secenList.Add(Bs);
		secenList.Add(BsJian);
		secenList.Add(BsSteet);
		secenList.Add(BsSteet2);
		Bs.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(6);
		});
		BsJian.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(7);
		});
		BsSteet.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(8);
		});
		BsSteet2.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(9);
		});
		jiHeGuangYing.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(0);
		});
		fire.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(1);
		});
		ice.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(2);
		});
		thunder.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(3);
		});
		zhongShiGuiGuai.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(4);
		});
		xiQing.GetComponent<Button>().onClick.AddListener(delegate
		{
			setSelected(5);
		});
		selectedIndex = 8;
		setSelected(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex, init: true);
	}

	private void setSelected(int selectedIndex, bool init = false)
	{
		if (this.selectedIndex == selectedIndex && !init)
		{
			return;
		}
		this.selectedIndex = selectedIndex;
		selectedScene = secenList[this.selectedIndex];
		foreach (GameObject secen in secenList)
		{
			secen.transform.Find("Quad").gameObject.SetActive(value: true);
			secen.transform.Find("QuadSelected").gameObject.SetActive(value: false);
		}
		selectedScene.transform.Find("Quad").gameObject.SetActive(value: false);
		selectedScene.transform.Find("QuadSelected").gameObject.SetActive(value: true);
		if (!init)
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setScene(selectedIndex);
		}
	}

	private bool checkCk(int selectedIndexCom, bool init)
	{
		if (SceneSelectDataManager.ck)
		{
			return false;
		}
		if (selectedIndexCom == 0 || selectedIndexCom == 1)
		{
			return false;
		}
		if (init)
		{
			selectedIndex = selectedIndexCom;
		}
		if (selectedIndex > 1 || init)
		{
			selectedIndex = 0;
			selectedScene = secenList[selectedIndex];
			foreach (GameObject secen in secenList)
			{
				secen.transform.Find("Quad").gameObject.SetActive(value: true);
				secen.transform.Find("QuadSelected").gameObject.SetActive(value: false);
			}
			selectedScene.transform.Find("Quad").gameObject.SetActive(value: false);
			selectedScene.transform.Find("QuadSelected").gameObject.SetActive(value: true);
			if (!init)
			{
				UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setScene(selectedIndex);
			}
		}
		return true;
	}
}
public class startLoading : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading && UnitySingleton<DataCenter>.Instance.musicDataCenter.isAnalysisMusicDone)
		{
			UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading = false;
			GradualBlack.instance.blackMidAction = delegate
			{
				UnitySingleton<DataCenter>.Instance.CheckGenerateBeatBasicInfoDone();
				SceneManager.LoadScene(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex + 1);
			};
			GradualBlack.instance.playAll = false;
			GradualBlack.instance.StartGradualBlack();
		}
	}
}
public class BallExplose
{
}
public class BallMatSetting
{
	internal static void setBallMat(GameObject cube, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		switch (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex)
		{
		case 0:
			setBallMatGYJH(cube, ballDirection, ballType);
			break;
		case 1:
			setBallMatFire(cube, ballDirection, ballType);
			break;
		case 2:
			setBallMatIce(cube, ballDirection, ballType);
			break;
		case 3:
			setBallMatThunder(cube, ballDirection, ballType);
			break;
		case 4:
			setBallMatGhost(cube, ballDirection, ballType);
			break;
		case 5:
			setBallMatSci(cube, ballDirection, ballType);
			break;
		case 6:
			setBallMatBs(cube, ballDirection, ballType);
			break;
		case 7:
			setBallMatBs(cube, ballDirection, ballType);
			break;
		case 8:
			setBallMatBs(cube, ballDirection, ballType);
			break;
		case 9:
			setBallMatBs(cube, ballDirection, ballType);
			break;
		}
	}

	private static void setBallMatSci(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string matName = getMatName(ballDirection, ballType, "Cross", "CircleLeft", "CircleRight", "ArrowLeft", "ArrowRight");
		ball.GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/sci/" + matName);
	}

	private static void setBallMatGhost(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string matName = getMatName(ballDirection, ballType, "Cross", "CircleLeft", "CircleRight", "ArrowLeft", "ArrowRight");
		ball.GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/ghost/" + matName);
		ball.GetComponentInChildren<FrageDisappear>().alphaMatPath = "CubeMatN/ghost/trans/" + matName;
	}

	private static void setBallMatThunder(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string matName = getMatName(ballDirection, ballType, "Cross", "CircleLeft", "CircleRight", "ArrowLeft", "ArrowRight");
		Material material = new Material(Resources.Load<Material>("CubeMatN/thunder/" + matName));
		UnityEngine.Vector4 vector = material.GetVector("Vector2_A637F09C");
		material.SetVector("Vector2_A637F09C", randomEspeed(vector));
		UnityEngine.Vector4 vector2 = material.GetVector("Vector2_EF9704FA");
		material.SetVector("Vector2_EF9704FA", randomEspeed(vector2));
		UnityEngine.Vector4 vector3 = material.GetVector("Vector2_98EE98A1");
		vector3.x = UnityEngine.Random.Range(-10, 10);
		vector3.y = UnityEngine.Random.Range(-10, 10);
		material.SetVector("Vector2_98EE98A1", vector3);
		ball.GetComponent<MeshRenderer>().material = material;
	}

	private static UnityEngine.Vector4 randomEspeed(UnityEngine.Vector4 espeed)
	{
		float min = 0.95f;
		float max = 1.05f;
		espeed.x *= UnityEngine.Random.Range(min, max);
		espeed.y *= UnityEngine.Random.Range(min, max);
		espeed.z *= UnityEngine.Random.Range(min, max);
		espeed.w *= UnityEngine.Random.Range(min, max);
		return espeed;
	}

	private static void setBallMatIce(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string matName = getMatName(ballDirection, ballType, "Cross", "CircleLeft", "CircleRight", "ArrowLeft", "ArrowRight");
		ball.GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/ice/" + matName);
		ball.GetComponentInChildren<FrageDisappear>().alphaMatPath = "CubeMatN/ice/trans/" + matName;
	}

	private static void setBallMatGYJH(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string matName = getMatName(ballDirection, ballType, "GYJZCross", "GYJZCircleLeft", "GYJZCircleRight", "GYJZArrowLeft", "GYJZArrowRight");
		ball.GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/" + matName);
		ball.GetComponentInChildren<FrageDisappear>().alphaMatPath = "CubeMatN/trans/" + matName;
	}

	private static void setBallMatBs(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string bsMatName = getBsMatName(ballDirection, ballType);
		ball.GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/bs/" + bsMatName);
		Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(ballType);
		ball.GetComponent<MeshRenderer>().material.SetColor("Color_4FB9F87E", cubeColor);
		ball.GetComponentInChildren<FrageDisappear>().alphaMatPath = "CubeMatN/bs/trans/" + bsMatName;
		ball.GetComponentInChildren<FrageDisappear>().dynamicColorKey = "Color_FB8CF364";
		ball.GetComponentInChildren<FrageDisappear>().dynamicColor = cubeColor;
	}

	private static void setBallMatFire(GameObject ball, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		string matName = getMatName(ballDirection, ballType, "FireCross", "FireCircleLeft", "FireCircleRight", "FireArrowLeft", "FireArrowRight");
		ball.GetComponent<MeshRenderer>().material = Resources.Load<Material>("CubeMatN/fire/" + matName);
	}

	private static string getMatName(GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType, string cross, string circleLeft, string circleRight, string arrowLeft, string arrowRight)
	{
		if (ballType == GeneratorLaw.BallType.BlackBall)
		{
			return cross;
		}
		if (ballDirection == GeneratorLaw.BallDirection.All)
		{
			if (ballType == GeneratorLaw.BallType.LeftBall)
			{
				return circleLeft;
			}
			return circleRight;
		}
		if (ballType == GeneratorLaw.BallType.LeftBall)
		{
			return arrowLeft;
		}
		return arrowRight;
	}

	private static string getBsMatName(GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType)
	{
		if (ballType == GeneratorLaw.BallType.BlackBall)
		{
			return "BsCubeZhaDan";
		}
		if (ballDirection == GeneratorLaw.BallDirection.All)
		{
			return "BsCubeCricle";
		}
		return "BsCubeArrow";
	}
}
public class BladeEffectManager : MonoBehaviour
{
	public GameObject bladeTouchEffect;

	public GameObject bladeGroundTouchLeftEffect;

	public GameObject bladeGroundTouchRightEffect;

	public BladeEffectManagerDiLie bladeEffectManagerDiLie;

	public float detectTimeLimit = 0.5f;

	private float bladeTouchEffectStartTime;

	private float bladeGroundTouchLeftStartTime;

	private float bladeGroundTouchRightStartTime;

	private void Start()
	{
		bladeTouchEffectStartTime = 0f;
		bladeGroundTouchLeftStartTime = 0f;
		bladeGroundTouchRightStartTime = 0f;
		updateBsEffectColor();
		bladeTouchEffect.SetActive(value: false);
		bladeGroundTouchLeftEffect.SetActive(value: false);
		bladeGroundTouchRightEffect.SetActive(value: false);
	}

	private void Update()
	{
		if (bladeTouchEffect.activeInHierarchy)
		{
			bladeTouchEffectStartTime += Time.deltaTime;
			if (bladeTouchEffectStartTime > detectTimeLimit)
			{
				bladeTouchEffectStartTime = 0f;
				bladeTouchEffect.SetActive(value: false);
			}
		}
		if (bladeGroundTouchLeftEffect.activeInHierarchy)
		{
			bladeGroundTouchLeftStartTime += Time.deltaTime;
			if (bladeGroundTouchLeftStartTime > detectTimeLimit)
			{
				bladeGroundTouchLeftStartTime = 0f;
				bladeGroundTouchLeftEffect.SetActive(value: false);
			}
		}
		if (bladeGroundTouchRightEffect.activeInHierarchy)
		{
			bladeGroundTouchRightStartTime += Time.deltaTime;
			if (bladeGroundTouchRightStartTime > detectTimeLimit)
			{
				bladeGroundTouchRightStartTime = 0f;
				bladeGroundTouchRightEffect.SetActive(value: false);
			}
		}
	}

	public void bladeGroundTouchLeft(UnityEngine.Vector3 point)
	{
		if (bladeEffectManagerDiLie != null)
		{
			bladeEffectManagerDiLie.bladeGroundTouchLeft(point);
			return;
		}
		if (!bladeGroundTouchLeftEffect.activeInHierarchy)
		{
			bladeGroundTouchLeftEffect.SetActive(value: true);
		}
		bladeGroundTouchLeftStartTime = 0f;
		point.y = 0f;
		bladeGroundTouchLeftEffect.transform.position = point;
	}

	public void bladeGroundTouchLeftExit()
	{
		bladeGroundTouchLeftEffect.SetActive(value: false);
		bladeGroundTouchLeftStartTime = 0f;
	}

	public void bladeGroundTouchRight(UnityEngine.Vector3 point)
	{
		if (bladeEffectManagerDiLie != null)
		{
			bladeEffectManagerDiLie.bladeGroundTouchRight(point);
			return;
		}
		if (!bladeGroundTouchRightEffect.activeInHierarchy)
		{
			bladeGroundTouchRightEffect.SetActive(value: true);
		}
		bladeGroundTouchRightStartTime = 0f;
		point.y = 0f;
		bladeGroundTouchRightEffect.transform.position = point;
	}

	public void bladeGroundTouchRightExit()
	{
		bladeGroundTouchRightEffect.SetActive(value: false);
		bladeGroundTouchRightStartTime = 0f;
	}

	internal void bladeTouch(UnityEngine.Vector3 point)
	{
		if (!bladeTouchEffect.activeInHierarchy)
		{
			bladeTouchEffect.SetActive(value: true);
		}
		bladeTouchEffectStartTime = 0f;
		bladeTouchEffect.transform.position = point;
		Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 0);
		Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 1);
	}

	internal void bladeTouchExit(UnityEngine.Vector3 point)
	{
		bladeTouchEffect.SetActive(value: false);
		bladeTouchEffectStartTime = 0f;
	}

	private void updateBsEffectColor()
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex == 6 || UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex == 7 || UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex == 8 || UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex == 9)
		{
			Color cubeColor = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
			Color cubeColor2 = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
			ParticleSystem.MainModule main = bladeTouchEffect.GetComponentInChildren<ParticleSystem>().main;
			main.startColor = new ParticleSystem.MinMaxGradient(cubeColor, cubeColor2);
			ParticleSystem.MainModule main2 = bladeGroundTouchLeftEffect.GetComponentInChildren<ParticleSystem>().main;
			main2.startColor = new ParticleSystem.MinMaxGradient(cubeColor, cubeColor);
			ParticleSystem.MainModule main3 = bladeGroundTouchRightEffect.GetComponentInChildren<ParticleSystem>().main;
			main3.startColor = new ParticleSystem.MinMaxGradient(cubeColor2, cubeColor2);
		}
	}
}
public class BladeEffectManagerDiLie : MonoBehaviour
{
	public GameObject DiLieLeft;

	public GameObject DiLieRight;

	public float SameReGenTimeInterval = 1.5f;

	public float SamePosDistance = 0.05f;

	private UnityEngine.Vector3 lastLeftPos;

	private UnityEngine.Vector3 leftPos;

	private float lastLeftTime;

	private float leftTime;

	private UnityEngine.Vector3 lastRightPos;

	private UnityEngine.Vector3 rightPos;

	private float lastRightTime;

	private float rightTime;

	private Color leftLiang;

	private Color leftAn;

	private Color rightLiang;

	private Color rightAn;

	private void Start()
	{
		leftLiang = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		rightLiang = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getCubeColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
		leftAn = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getDiLieAnColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.leftColor);
		rightAn = UnitySingleton<DataCenter>.Instance.colorDynamicManager.getDiLieAnColor(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.rightColor);
	}

	private void Update()
	{
	}

	internal void bladeGroundTouchRight(UnityEngine.Vector3 point)
	{
		bladeGroundTouch(point, isLeft: false);
	}

	internal void bladeGroundTouchLeft(UnityEngine.Vector3 point)
	{
		bladeGroundTouch(point, isLeft: true);
	}

	private void bladeGroundTouch(UnityEngine.Vector3 point, bool isLeft)
	{
		point.y = 0.001f;
		if (!checkNoNeedCreate(point, isLeft))
		{
			if (isLeft)
			{
				leftPos = point;
				leftTime = Time.time;
				GameObject diLie = UnityEngine.Object.Instantiate(DiLieLeft, point, UnityEngine.Quaternion.Euler(0f, 0f, 0f));
				initDiLieColor(diLie, isLeft);
				chaZhi(isLeft);
				lastLeftPos = point;
				lastLeftTime = Time.time;
			}
			else
			{
				rightPos = point;
				rightTime = Time.time;
				GameObject diLie2 = UnityEngine.Object.Instantiate(DiLieRight, point, UnityEngine.Quaternion.Euler(0f, 0f, 0f));
				initDiLieColor(diLie2, isLeft);
				chaZhi(isLeft);
				lastRightPos = point;
				lastRightTime = Time.time;
			}
		}
	}

	private void chaZhi(bool isLeft)
	{
		UnityEngine.Vector3 vector = (isLeft ? leftPos : rightPos);
		float num = (isLeft ? leftTime : rightTime);
		UnityEngine.Vector3 vector2 = (isLeft ? lastLeftPos : lastRightPos);
		float num2 = (isLeft ? lastLeftTime : lastRightTime);
		if (!(num - num2 > 0.03f) && !((vector - vector2).magnitude < SamePosDistance * 2f))
		{
			float num3 = SamePosDistance / (vector - vector2).magnitude;
			float num4 = num3;
			GameObject original = (isLeft ? DiLieLeft : DiLieRight);
			for (; num4 < 1f; num4 += num3)
			{
				UnityEngine.Vector3 position = UnityEngine.Vector3.Lerp(vector2, vector, num4);
				GameObject diLie = UnityEngine.Object.Instantiate(original, position, UnityEngine.Quaternion.Euler(0f, 0f, 0f));
				initDiLieColor(diLie, isLeft);
			}
		}
	}

	private bool checkNoNeedCreate(UnityEngine.Vector3 point, bool isLeft)
	{
		UnityEngine.Vector3 vector = (isLeft ? leftPos : rightPos);
		float num = (isLeft ? leftTime : rightTime);
		if (Time.time - num < SameReGenTimeInterval)
		{
			return (point - vector).magnitude < SamePosDistance;
		}
		return false;
	}

	private void initDiLieColor(GameObject diLie, bool isLeft)
	{
		if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex == 6)
		{
			string text = "Color_1032F576";
			Material material = diLie.GetComponent<Renderer>().material;
			if (isLeft)
			{
				material.SetColor(text, leftLiang);
			}
			else
			{
				material.SetColor(text, rightLiang);
			}
		}
	}
}
public class FrageDisappear : MonoBehaviour
{
	public bool breaked;

	public float time;

	public Animator animator;

	public string alphaMatPath;

	public float stayTime = 0.5f;

	public bool isIce;

	public bool isGhost;

	public bool isBs;

	public Color dynamicColor = Color.black;

	public string dynamicColorKey;

	public bool startDispear;

	private void Start()
	{
		time = 0f;
		startDispear = false;
	}

	private void Update()
	{
		if (!breaked || startDispear)
		{
			return;
		}
		time += Time.deltaTime;
		if (time > stayTime)
		{
			GetComponent<MeshRenderer>().material = Resources.Load<Material>(alphaMatPath);
			if (dynamicColorKey != null)
			{
				GetComponent<MeshRenderer>().material.SetColor(dynamicColorKey, dynamicColor);
			}
			if (isIce)
			{
				animator.Play("dissapearIce");
			}
			else if (isGhost)
			{
				animator.Play("dissapearGhost");
			}
			else if (isBs)
			{
				animator.Play("dissapearBs");
			}
			else
			{
				animator.Play("dissapear");
			}
			startDispear = true;
		}
	}

	public void cubeDissapear()
	{
		base.gameObject.SetActive(value: false);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class AnimatorExControl : MonoBehaviour
{
	public GameInfoBoard GameInfoBoard;

	public void showCanvasRotate()
	{
		GameInfoBoard.showCanvasRotate();
	}
}
public class RotateTipManager : MonoBehaviour
{
	public GameObject Left;

	public GameObject LeftMin;

	public GameObject Right;

	public GameObject RightMin;

	public GameObject Back;

	public AudioSource Didi;

	private void Start()
	{
		hideAll();
	}

	public void showRotateTip(int timeIndex)
	{
		if (!UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			UnitySingleton<DataCenter>.Instance.generatorLaw.generatorBeatOriginChangeDic.TryGetValue(timeIndex + 80, out var value);
			if (value != null && !value.twoWayBackToSingle && !value.mutual)
			{
				setPositionRotate(value);
				setShow(value);
				GetComponent<Animator>().Play("RotateTipSpark", 0, 0f);
			}
		}
	}

	public void playDidi()
	{
		Didi?.Play();
	}

	private void setShow(GenGateInfo.OriginChangeShow originChangeShow)
	{
		hideAll();
		switch (originChangeShow.originChangeType)
		{
		case GenGateInfo.OriginChangeType.Back:
			Back.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.Left:
			Left.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.Right:
			Right.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.RightMin:
			RightMin.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.LeftMin:
			LeftMin.SetActive(value: true);
			break;
		}
	}

	private void setPositionRotate(GenGateInfo.OriginChangeShow originChangeShow)
	{
		int orIndex = originChangeShow.orIndex;
		int num = 0;
		num = orIndex switch
		{
			1 => 0, 
			2 => 60, 
			3 => 120, 
			4 => 180, 
			5 => 240, 
			6 => 300, 
			_ => 0, 
		};
		UnityEngine.Vector3 eulerAngles = base.transform.eulerAngles;
		base.transform.eulerAngles = new UnityEngine.Vector3(eulerAngles.x, num, eulerAngles.z);
	}

	public void hideAll()
	{
		Left.SetActive(value: false);
		LeftMin.SetActive(value: false);
		Right.SetActive(value: false);
		RightMin.SetActive(value: false);
		Back.SetActive(value: false);
	}
}
public abstract class BallExploreBase
{
	public Ball ball;

	public UnityEngine.Vector3 colliderPoint;

	public int splitScore;

	public Blade blade;

	public UnityEngine.Plane plane;

	public bool validPlane;

	public void setData(Ball ball, UnityEngine.Vector3 colliderPoint, int splitScore, Blade blade, UnityEngine.Plane plane, bool validPlane)
	{
		this.ball = ball;
		this.colliderPoint = colliderPoint;
		this.splitScore = splitScore;
		this.blade = blade;
		this.plane = plane;
		this.validPlane = validPlane;
	}

	internal static BallExploreBase getBallExplore(Ball ball, UnityEngine.Vector3 colliderPoint, int splitScore, Blade blade, UnityEngine.Plane plane, bool validPlane)
	{
		BallExploreBase ballExploreBase = UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex switch
		{
			0 => new BallExploreGYJH(), 
			1 => new BallExploreFire(), 
			2 => new BallExploreIce(), 
			3 => new BallExploreThunder(), 
			4 => new BallExploreGhost(), 
			5 => new BallExploreSci(), 
			6 => new BallExploreBs(), 
			7 => new BallExploreBsJian(), 
			8 => new BallExploreBsST(), 
			9 => new BallExploreBsST(), 
			_ => new BallExploreIce(), 
		};
		ballExploreBase.setData(ball, colliderPoint, splitScore, blade, plane, validPlane);
		return ballExploreBase;
	}

	public void addExploreForece(ParticleSystem particle, Blade blade)
	{
		float num = -0.2f;
		ParticleSystem.ForceOverLifetimeModule forceOverLifetime = particle.forceOverLifetime;
		forceOverLifetime.x = blade.waveDirection.x * num * blade.waveDistancePerSecond;
		forceOverLifetime.y = blade.waveDirection.y * num * blade.waveDistancePerSecond;
		forceOverLifetime.z = blade.waveDirection.z * num * blade.waveDistancePerSecond;
	}

	public void addExploreForeceFs(ParticleSystem particle, Blade blade, float Fs)
	{
		ParticleSystem.ForceOverLifetimeModule forceOverLifetime = particle.forceOverLifetime;
		UnityEngine.Vector3 normalized = blade.waveDirection.normalized;
		float num = ((50f / blade.waveDistancePerSecond > 1f) ? 1f : (50f / blade.waveDistancePerSecond)) * 50f + 10f;
		forceOverLifetime.x = (0f - normalized.x) * num;
		forceOverLifetime.y = (0f - normalized.y) * num;
		forceOverLifetime.z = (0f - normalized.z) * num;
	}

	internal abstract void playLeftExplore();

	internal abstract void playRightExplore();

	internal abstract void playBlackExplore();

	internal abstract float splitAndDistroy();
}
public class BallExploreFire : BallExploreBase
{
	private ParticleSystem particle;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		ball.GetComponent<BoxCollider>().enabled = false;
		ball.ball.GetComponent<Animator>().Play("Larger");
		return particle.main.duration;
	}
}
public class BallExploreGYJH : BallExploreBase
{
	private ParticleSystem particle;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		if (UnityEngine.Vector3.Magnitude(blade.ThisTopDetectPoint - blade.lastTopDetectPoint) < 0.0001f || (double)blade.waveDistancePerSecond < 0.3)
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, ball.transform.position);
		}
		else
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.lastTopDetectPoint, ball.transform.position);
		}
		UnityEngine.Plane[] planes = new UnityEngine.Plane[1] { plane };
		ball.ball.GetComponent<ShatterTool>().Split(planes, new Ball.BallCollisionInfo(colliderPoint, blade));
		ball.ball.SetActive(value: false);
		ball.GetComponent<BoxCollider>().enabled = false;
		return particle.main.duration;
	}
}
public class BallExploreGhost : BallExploreBase
{
	internal override void playBlackExplore()
	{
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		if (!validPlane)
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, blade.topDetectPoint.transform.position + (ball.transform.position - ball.target));
		}
		(new UnityEngine.Plane[1])[0] = plane;
		ball.ball.GetComponent<ShatterTool>().Shatter(colliderPoint, new Ball.BallCollisionInfo(colliderPoint, blade));
		ball.ball.SetActive(value: false);
		ball.GetComponent<BoxCollider>().enabled = false;
		return 2f;
	}
}
public class BallExploreIce : BallExploreBase
{
	private ParticleSystem particle;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		if (UnityEngine.Vector3.Magnitude(blade.ThisTopDetectPoint - blade.lastTopDetectPoint) < 0.0001f || (double)blade.waveDistancePerSecond < 0.3)
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.endDetectPoint.transform.position, ball.transform.position);
		}
		else
		{
			plane = new UnityEngine.Plane(blade.topDetectPoint.transform.position, blade.lastTopDetectPoint, ball.transform.position);
		}
		UnityEngine.Plane[] planes = new UnityEngine.Plane[1] { plane };
		ball.ball.GetComponent<ShatterTool>().Split(planes, new Ball.BallCollisionInfo(colliderPoint, blade));
		ball.ball.SetActive(value: false);
		ball.GetComponent<BoxCollider>().enabled = false;
		return particle.main.duration;
	}
}
public class BallExploreSci : BallExploreBase
{
	internal override void playBlackExplore()
	{
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		if (ball.ballType == GeneratorLaw.BallType.LeftBall)
		{
			ball.transform.Find("Cube/exploreSci/SmallExplosionFire").gameObject.SetActive(value: true);
		}
		else if (ball.ballType == GeneratorLaw.BallType.RightBall)
		{
			ball.transform.Find("Cube/exploreSci/SmallExplosionBlue").gameObject.SetActive(value: true);
		}
		else
		{
			ball.transform.Find("Cube/exploreSci/SmallExplosionBlack").gameObject.SetActive(value: true);
		}
		ball.GetComponent<SphereCollider>().enabled = false;
		ball.ball.GetComponent<MeshCollider>().enabled = true;
		ball.ball.GetComponent<Rigidbody>().constraints = RigidbodyConstraints.None;
		ball.ball.GetComponent<Rigidbody>().useGravity = true;
		UnityEngine.Vector3 vector = -blade.waveDirection.normalized * (0f + blade.waveDistancePerSecond * 35f);
		_ = colliderPoint;
		UnityEngine.Vector3 vector2 = (ball.transform.position - ball.target).normalized * 100f;
		UnityEngine.Vector3 force = vector + vector2;
		ball.ball.GetComponent<Rigidbody>().AddForce(force);
		ball.ball.GetComponent<Animator>().Play("dissapearSci");
		return 2.5f;
	}
}
public class BallExploreThunder : BallExploreBase
{
	private ParticleSystem particle;

	internal override void playBlackExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreBlack").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreFail.SetActive(value: true);
	}

	internal override void playLeftExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreLeft").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreLeft.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreLeft.SetActive(value: true);
	}

	internal override void playRightExplore()
	{
		particle = ball.transform.Find("effect/explore/GYJZexploreRight").GetComponent<ParticleSystem>();
		particle.transform.position = colliderPoint;
		particle.Play();
		addExploreForece(particle, blade);
		ball.hipScoreRight.transform.Find("text").GetComponent<Text>().text = splitScore.ToString();
		ball.hipScoreRight.SetActive(value: true);
	}

	internal override float splitAndDistroy()
	{
		ball.GetComponent<BoxCollider>().enabled = false;
		ball.ball.GetComponent<Animator>().Play("thunderDissolve");
		return particle.main.duration;
	}
}
public class FireCubeExplore : MonoBehaviour
{
	public void exploreEnd()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class rotation : MonoBehaviour
{
	public float rotateSpeed;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(0f, rotateSpeed * Time.deltaTime, 0f);
	}
}
public class LightningManager : MonoBehaviour
{
	public List<Transform> positions;

	public GameObject lightning1;

	public GameObject lightning2;

	public float maxPosRandomDis = 15f;

	public float checkInterval = 0.5f;

	private List<float> lightTimes;

	private List<float> lightCheckTimes;

	public AudioSource thunderSound;

	private void Start()
	{
		lightTimes = new List<float>();
		for (int i = 0; i < positions.Count; i++)
		{
			lightTimes.Add(0f);
		}
		lightCheckTimes = new List<float>();
		for (int j = 0; j < positions.Count; j++)
		{
			lightCheckTimes.Add(0f);
		}
	}

	private void Update()
	{
		float time = Time.time;
		for (int i = 0; i < positions.Count; i++)
		{
			generateOneLight(time, i);
		}
	}

	private void generateOneLight(float time, int index)
	{
		float num = lightTimes[index];
		if (time - lightCheckTimes[index] < checkInterval)
		{
			return;
		}
		lightCheckTimes[index] = time;
		if (time - num < 4f)
		{
			return;
		}
		if (time - num < 10f)
		{
			if (gaiLv100(20f))
			{
				showRandomLight(positions[index], index);
			}
		}
		else if (time - num < 15f)
		{
			if (gaiLv100(40f))
			{
				showRandomLight(positions[index], index);
			}
		}
		else if (time - num < 23f)
		{
			if (gaiLv100(60f))
			{
				showRandomLight(positions[index], index);
			}
		}
		else if (time - num < 30f)
		{
			if (gaiLv100(80f))
			{
				showRandomLight(positions[index], index);
			}
		}
		else
		{
			showRandomLight(positions[index], index);
		}
	}

	private void showRandomLight(Transform transform, int index)
	{
		UnityEngine.Vector3 position = transform.position;
		position.x += UnityEngine.Random.value * maxPosRandomDis - maxPosRandomDis / 2f;
		position.y += UnityEngine.Random.value * maxPosRandomDis - maxPosRandomDis / 2f;
		position.z += UnityEngine.Random.value * maxPosRandomDis - maxPosRandomDis / 2f;
		GameObject gameObject = ((!gaiLv100(50f)) ? UnityEngine.Object.Instantiate(lightning2, position, UnityEngine.Quaternion.Euler(0f, 0f, 0f)) : UnityEngine.Object.Instantiate(lightning1, position, UnityEngine.Quaternion.Euler(0f, 0f, 0f)));
		gameObject.transform.LookAt(new UnityEngine.Vector3(0f, 1.7f, 0f));
		lightTimes[index] = Time.time;
		thunderSound?.Play();
	}

	private bool gaiLv100(float gaiLv)
	{
		return UnityEngine.Random.value * 100f < gaiLv;
	}
}
public class Wall : MonoBehaviour
{
	internal MainPlayControl mainPlayControl;

	private static float missAddIntervalTime = 0.2f;

	private static float inHeadCheckTime = 0.1f;

	public GameObject top;

	public GameObject left;

	public GameObject right;

	private float lastMissCountTime;

	private UnityEngine.Vector3 target;

	private float speed;

	private bool isInHead;

	private float inHeadMissedTime;

	private float checkMissedTime;

	private void Update()
	{
		if (isInHead)
		{
			if (checkMissedTime > inHeadCheckTime)
			{
				isInHead = false;
			}
			checkMissedTime += Time.deltaTime;
		}
		if (!mainPlayControl.pause)
		{
			float maxDistanceDelta = speed * Time.deltaTime;
			base.gameObject.transform.position = UnityEngine.Vector3.MoveTowards(base.gameObject.transform.position, target, maxDistanceDelta);
			if ((target - base.transform.position).magnitude < 0.01f)
			{
				hideAll();
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}

	internal void initWall(WallInfo wallInfo, UnityEngine.Vector3 targetPos, float speed)
	{
		lastMissCountTime = -1f;
		hideAll();
		if (wallInfo.wallType == WallInfo.WallType.Top)
		{
			top.SetActive(value: true);
		}
		else if (wallInfo.wallType == WallInfo.WallType.Left)
		{
			left.SetActive(value: true);
		}
		else
		{
			right.SetActive(value: true);
		}
		target = targetPos;
		this.speed = speed;
	}

	private void hideAll()
	{
		top.SetActive(value: false);
		left.SetActive(value: false);
		right.SetActive(value: false);
	}

	internal void inHead()
	{
		checkMissedTime = 0f;
		if (!isInHead)
		{
			isInHead = true;
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 0);
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 1);
			UnitySingleton<DataCenter>.Instance.AddMissed();
			inHeadMissedTime = 0f;
			return;
		}
		inHeadMissedTime += Time.deltaTime;
		if (inHeadMissedTime > missAddIntervalTime)
		{
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 0);
			Controller.UPvr_VibrateNeo2Controller(1f, MainPlayControl.vibrateTime, 1);
			UnitySingleton<DataCenter>.Instance.AddMissed();
			inHeadMissedTime = 0f;
		}
	}
}
public abstract class BaseWallCombo
{
	public bool PutWallInfoList(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, WallInfo> generatorWallDic, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorBallDic, GenGateInfo.OriginDirection originDirection)
	{
		int num = beatInfo.timeIndex - BaseBallCombo.LastGenTimeIndex;
		BaseBallCombo.LastGenTimeIndex = beatInfo.timeIndex;
		if (beatInfo.timeIndex - num < BaseBallCombo.LastRGenEndTimeIndex)
		{
			return false;
		}
		BaseBallCombo.LastRGenEndTimeIndex = beatInfo.timeIndex;
		putWall(beatInfo, generatorWallDic, originDirection);
		putBall(beatInfo, generatorBallDic, originDirection);
		return true;
	}

	public abstract void putWall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, WallInfo> generatorWallDic, GenGateInfo.OriginDirection originDirection);

	public abstract void putBall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorBallDic, GenGateInfo.OriginDirection originDirection);
}
public class LeftWallCombo : BaseWallCombo
{
	public override void putBall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorBallDic, GenGateInfo.OriginDirection originDirection)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		switch (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 3.999f)))
		{
		case 0:
			generateTwoBall(list, originDirection);
			break;
		case 1:
			generateOneBallTop(list, originDirection);
			break;
		case 2:
			generateOneBallBottom(list, originDirection);
			break;
		}
		if (list.Count > 0)
		{
			generatorBallDic.Add(beatInfo.timeIndex, list);
		}
	}

	public void generateTwoBall(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.999f)) == 0)
		{
			ballInfos.Add(topBall(originDirection, 0));
			ballInfos.Add(bottomBall(originDirection, 1));
		}
		else
		{
			ballInfos.Add(topBall(originDirection, 1));
			ballInfos.Add(bottomBall(originDirection, 0));
		}
	}

	public void generateOneBallTop(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.999f)) == 0)
		{
			ballInfos.Add(topBall(originDirection, 0));
		}
		else
		{
			ballInfos.Add(topBall(originDirection, 1));
		}
	}

	public void generateOneBallBottom(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.999f)) == 0)
		{
			ballInfos.Add(bottomBall(originDirection, 0));
		}
		else
		{
			ballInfos.Add(bottomBall(originDirection, 1));
		}
	}

	public GeneratorLaw.BallInfo bottomBall(GenGateInfo.OriginDirection originDirection, int ballType)
	{
		return new GeneratorLaw.BallInfo
		{
			dingWeiIndex = originDirection.baseIndex,
			ballType = ((ballType != 0) ? GeneratorLaw.BallType.RightBall : GeneratorLaw.BallType.LeftBall),
			ballDirection = GeneratorLaw.BallDirection.Down,
			targetIndex = new Vector2Int(4, 1)
		};
	}

	public GeneratorLaw.BallInfo topBall(GenGateInfo.OriginDirection originDirection, int ballType)
	{
		return new GeneratorLaw.BallInfo
		{
			dingWeiIndex = originDirection.baseIndex,
			ballType = ((ballType != 0) ? GeneratorLaw.BallType.RightBall : GeneratorLaw.BallType.LeftBall),
			ballDirection = GeneratorLaw.BallDirection.Up,
			targetIndex = new Vector2Int(4, 4)
		};
	}

	public override void putWall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, WallInfo> generatorWallDic, GenGateInfo.OriginDirection originDirection)
	{
		WallInfo wallInfo = new WallInfo();
		wallInfo.wallType = WallInfo.WallType.Left;
		wallInfo.dingWeiIndex = originDirection.baseIndex;
		generatorWallDic.Add(beatInfo.timeIndex, wallInfo);
	}
}
public class RightWallCombo : BaseWallCombo
{
	public override void putBall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorBallDic, GenGateInfo.OriginDirection originDirection)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		switch (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 3.999f)))
		{
		case 0:
			generateTwoBall(list, originDirection);
			break;
		case 1:
			generateOneBallTop(list, originDirection);
			break;
		case 2:
			generateOneBallBottom(list, originDirection);
			break;
		}
		if (list.Count > 0)
		{
			generatorBallDic.Add(beatInfo.timeIndex, list);
		}
	}

	public void generateTwoBall(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.999f)) == 0)
		{
			ballInfos.Add(topBall(originDirection, 0));
			ballInfos.Add(bottomBall(originDirection, 1));
		}
		else
		{
			ballInfos.Add(topBall(originDirection, 1));
			ballInfos.Add(bottomBall(originDirection, 0));
		}
	}

	public void generateOneBallTop(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.999f)) == 0)
		{
			ballInfos.Add(topBall(originDirection, 0));
		}
		else
		{
			ballInfos.Add(topBall(originDirection, 1));
		}
	}

	public void generateOneBallBottom(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 1.999f)) == 0)
		{
			ballInfos.Add(bottomBall(originDirection, 0));
		}
		else
		{
			ballInfos.Add(bottomBall(originDirection, 1));
		}
	}

	public override void putWall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, WallInfo> generatorWallDic, GenGateInfo.OriginDirection originDirection)
	{
		WallInfo wallInfo = new WallInfo();
		wallInfo.wallType = WallInfo.WallType.Right;
		wallInfo.dingWeiIndex = originDirection.baseIndex;
		generatorWallDic.Add(beatInfo.timeIndex, wallInfo);
	}

	public GeneratorLaw.BallInfo bottomBall(GenGateInfo.OriginDirection originDirection, int ballType)
	{
		return new GeneratorLaw.BallInfo
		{
			dingWeiIndex = originDirection.baseIndex,
			ballType = ((ballType != 0) ? GeneratorLaw.BallType.RightBall : GeneratorLaw.BallType.LeftBall),
			ballDirection = GeneratorLaw.BallDirection.Down,
			targetIndex = new Vector2Int(1, 1)
		};
	}

	public GeneratorLaw.BallInfo topBall(GenGateInfo.OriginDirection originDirection, int ballType)
	{
		return new GeneratorLaw.BallInfo
		{
			dingWeiIndex = originDirection.baseIndex,
			ballType = ((ballType != 0) ? GeneratorLaw.BallType.RightBall : GeneratorLaw.BallType.LeftBall),
			ballDirection = GeneratorLaw.BallDirection.Up,
			targetIndex = new Vector2Int(1, 4)
		};
	}
}
public class TopWallCombo : BaseWallCombo
{
	public override void putBall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorBallDic, GenGateInfo.OriginDirection originDirection)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		switch (Mathf.FloorToInt(UnityEngine.Random.Range(0f, 3.999f)))
		{
		case 0:
			generateTwoBall(list, originDirection);
			break;
		case 1:
			generateOneBallLeft(list, originDirection);
			break;
		case 2:
			generateOneBallRight(list, originDirection);
			break;
		}
		if (list.Count > 0)
		{
			generatorBallDic.Add(beatInfo.timeIndex, list);
		}
	}

	private void generateTwoBall(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		ballInfos.Add(leftBall(originDirection));
		ballInfos.Add(RightBall(originDirection));
	}

	private void generateOneBallLeft(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		ballInfos.Add(leftBall(originDirection));
	}

	private void generateOneBallRight(List<GeneratorLaw.BallInfo> ballInfos, GenGateInfo.OriginDirection originDirection)
	{
		ballInfos.Add(RightBall(originDirection));
	}

	private GeneratorLaw.BallInfo leftBall(GenGateInfo.OriginDirection originDirection)
	{
		return new GeneratorLaw.BallInfo
		{
			dingWeiIndex = originDirection.baseIndex,
			ballType = GeneratorLaw.BallType.LeftBall,
			ballDirection = GeneratorLaw.BallDirection.Left,
			targetIndex = new Vector2Int(1, 1)
		};
	}

	private GeneratorLaw.BallInfo RightBall(GenGateInfo.OriginDirection originDirection)
	{
		return new GeneratorLaw.BallInfo
		{
			dingWeiIndex = originDirection.baseIndex,
			ballType = GeneratorLaw.BallType.RightBall,
			ballDirection = GeneratorLaw.BallDirection.Right,
			targetIndex = new Vector2Int(4, 1)
		};
	}

	public override void putWall(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, WallInfo> generatorWallDic, GenGateInfo.OriginDirection originDirection)
	{
		WallInfo wallInfo = new WallInfo();
		wallInfo.wallType = WallInfo.WallType.Top;
		wallInfo.dingWeiIndex = originDirection.baseIndex;
		generatorWallDic.Add(beatInfo.timeIndex, wallInfo);
	}
}
public class WallComboContainer
{
	public static List<BaseWallCombo> wallComboList;

	private static int smallIntervalTime = 20 * MainPlayControl.timeIndexPerSeconds;

	private static int longIntervalTime = 40 * MainPlayControl.timeIndexPerSeconds;

	private static int checkIntervalTime = 3 * MainPlayControl.timeIndexPerSeconds;

	private static int lastWallTime = -1;

	private static int lastCheckTime = -1;

	private static float wallLength = 3f;

	internal static void InitWallComboContainer()
	{
		lastWallTime = -smallIntervalTime;
		lastCheckTime = -1;
		wallComboList = new List<BaseWallCombo>();
		wallComboList.Add(new TopWallCombo());
		wallComboList.Add(new LeftWallCombo());
		wallComboList.Add(new RightWallCombo());
	}

	internal static float randomGenerateWallCombo(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, WallInfo> generatorWallDic, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorBallDic, GenGateInfo.OriginDirection originDirection)
	{
		int num;
		switch (UnitySingleton<DataCenter>.Instance.generateParameter.wallComboLevel)
		{
		case 0:
			return -1f;
		default:
			num = smallIntervalTime;
			break;
		case 1:
			num = longIntervalTime;
			break;
		}
		int num2 = num;
		if (beatInfo.timeIndex < lastWallTime + num2)
		{
			return -1f;
		}
		if (beatInfo.timeIndex < lastCheckTime + checkIntervalTime)
		{
			return -1f;
		}
		lastCheckTime = beatInfo.timeIndex;
		if (Mathf.FloorToInt(UnityEngine.Random.Range(0f, (float)wallComboList.Count - 0.001f)) > 1)
		{
			return -1f;
		}
		int index = Mathf.FloorToInt(UnityEngine.Random.Range(0f, (float)wallComboList.Count - 0.001f));
		if (wallComboList[index].PutWallInfoList(beatInfo, generatorWallDic, generatorBallDic, originDirection))
		{
			lastWallTime = beatInfo.timeIndex;
			return wallLength;
		}
		return -1f;
	}
}
public class WallCube : MonoBehaviour
{
	public Wall wall;

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.name.Equals("HeadCollider"))
		{
			wall.inHead();
		}
	}

	private void OnCollisionStay(Collision collision)
	{
		if (collision.gameObject.name.Equals("HeadCollider"))
		{
			wall.inHead();
		}
	}
}
public class WallDingWeiCal : MonoBehaviour
{
	public Transform d1Origin;

	public Transform d1Target;

	public Transform d2Origin;

	public Transform d2Target;

	public Transform d3Origin;

	public Transform d3Target;

	public Transform d4Origin;

	public Transform d4Target;

	public Transform d5Origin;

	public Transform d5Target;

	public Transform d6Origin;

	public Transform d6Target;

	private void Start()
	{
		UnityEngine.Debug.Log(getDingCodeString(d1Origin, d1Target, 1) + "\n" + getDingCodeString(d2Origin, d2Target, 2) + "\n" + getDingCodeString(d3Origin, d3Target, 3) + "\n" + getDingCodeString(d4Origin, d4Target, 4) + "\n" + getDingCodeString(d5Origin, d5Target, 5) + "\n" + getDingCodeString(d6Origin, d6Target, 6));
	}

	private string getDingCodeString(Transform origin, Transform target, int index)
	{
		return "posDic.Add(" + index + ", new WallDingWeiInfo(1, " + getDingWeiString(origin.position) + ", " + getDingWeiString(target.position) + "));";
	}

	private string getDingWeiString(UnityEngine.Vector3 pos)
	{
		return "new Vector3(" + pos.x + "f," + pos.y + "f," + pos.z + "f)";
	}

	private void Update()
	{
	}
}
public class WallDingWeiInfo
{
	public int index { get; set; }

	public UnityEngine.Vector3 targetPos { get; set; }

	public UnityEngine.Vector3 originPos { get; set; }

	public WallDingWeiInfo(int index, UnityEngine.Vector3 originPos, UnityEngine.Vector3 targetPos)
	{
		this.index = index;
		this.targetPos = targetPos;
		this.originPos = originPos;
	}
}
public class WallInfo
{
	public enum WallType
	{
		Top,
		Left,
		Right
	}

	public WallType wallType { get; set; }

	public int dingWeiIndex { get; set; }
}
public class WallPosConstantInfo
{
	public static Dictionary<int, WallDingWeiInfo> posDic = new Dictionary<int, WallDingWeiInfo>();

	public static void init()
	{
		if (posDic.Count <= 0)
		{
			posDic.Add(1, new WallDingWeiInfo(1, new UnityEngine.Vector3(0f, 0f, 25f), new UnityEngine.Vector3(0f, 0f, -1.8f)));
			posDic.Add(2, new WallDingWeiInfo(1, new UnityEngine.Vector3(21.65063f, 0f, 12.5f), new UnityEngine.Vector3(-1.558846f, 0f, -0.9f)));
			posDic.Add(3, new WallDingWeiInfo(1, new UnityEngine.Vector3(21.65063f, 0f, -12.5f), new UnityEngine.Vector3(-1.558846f, 0f, 0.9000001f)));
			posDic.Add(4, new WallDingWeiInfo(1, new UnityEngine.Vector3(0f, 0f, -25f), new UnityEngine.Vector3(0f, 0f, 1.8f)));
			posDic.Add(5, new WallDingWeiInfo(1, new UnityEngine.Vector3(-21.65063f, 0f, -12.5f), new UnityEngine.Vector3(1.558846f, 0f, 0.8999999f)));
			posDic.Add(6, new WallDingWeiInfo(1, new UnityEngine.Vector3(-21.65063f, 0f, 12.5f), new UnityEngine.Vector3(1.558846f, 0f, -0.9f)));
		}
	}
}
public class CommonController1 : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject currentController;

	private Ray ray;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	public bool haveRay = true;

	private void Start()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
			HeadSetController.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(!Convert.ToBoolean(Convert.ToInt16(state)));
	}

	private void Update()
	{
		SetEnableControllerRay(currentController, haveRay);
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = UnityEngine.Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out var hitInfo))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new UnityEngine.Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hitInfo.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hitInfo.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hitInfo.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hitInfo.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hitInfo.point;
					HeadSetController.transform.position -= (hitInfo.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hitInfo.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new UnityEngine.Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = UnityEngine.Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new UnityEngine.Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.position + currentController.transform.forward.normalized * (0.5f + rayDefaultLength) - currentController.transform.Find("start").position;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out var hitInfo2))
			{
				currentHit = hitInfo2.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hitInfo2.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hitInfo2.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hitInfo2.point;
						disX = hitInfo2.transform.position.x - referenceObj.transform.position.x;
						disY = hitInfo2.transform.position.y - referenceObj.transform.position.y;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButton(0)) && hitInfo2.transform == dragObj.transform)
					{
						referenceObj.transform.position = new UnityEngine.Vector3(hitInfo2.point.x, hitInfo2.point.y, hitInfo2.transform.position.z);
					}
				}
				lastHit = hitInfo2.transform;
				currentController.transform.Find("dot").position = hitInfo2.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new UnityEngine.Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new UnityEngine.Vector3(0.178f, 0.178f, 1f);
					currentController.transform.Find("dot").position = currentController.transform.position + currentController.transform.forward.normalized * (0.5f + rayDefaultLength);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void SetEnableControllerRay(GameObject controller, bool enable)
	{
		if (!(controller == null))
		{
			controller.transform.Find("dot").gameObject.SetActive(enable);
			controller.transform.Find("ray_alpha").gameObject.SetActive(value: false);
			controller.transform.Find("ray_LengthAdaptive").gameObject.SetActive(enable);
			controller.transform.Find("start").gameObject.SetActive(enable);
		}
	}

	private bool HandSwitch()
	{
		if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Left))
		{
			SetEnableControllerRay(controller0, enable: true);
			SetEnableControllerRay(controller1, enable: false);
			currentController = controller0;
			Controller.UPvr_SetMainHandNess(0);
			return true;
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.Right))
		{
			SetEnableControllerRay(controller0, enable: false);
			SetEnableControllerRay(controller1, enable: true);
			currentController = controller1;
			Controller.UPvr_SetMainHandNess(1);
			return true;
		}
		return false;
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class DisableParticleRoll : MonoBehaviour
{
	private ParticleSystem m_ParticleSystem;

	private float m_LastRotation;

	private void Start()
	{
		m_ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void LateUpdate()
	{
		Camera main = Camera.main;
		if (!main)
		{
			return;
		}
		float z = main.transform.rotation.eulerAngles.z;
		if (m_LastRotation != z)
		{
			float num = z - m_LastRotation;
			NativeArray<ParticleSystem.Particle> particles = new NativeArray<ParticleSystem.Particle>(m_ParticleSystem.particleCount, Allocator.Temp);
			int particles2 = m_ParticleSystem.GetParticles(particles);
			for (int i = 0; i < particles2; i++)
			{
				ParticleSystem.Particle value = particles[i];
				value.rotation += num;
				particles[i] = value;
			}
			m_ParticleSystem.SetParticles(particles, particles2);
			particles.Dispose();
			m_ParticleSystem.startRotation += num * ((float)Math.PI / 180f);
			m_LastRotation = z;
		}
	}
}
public class FogController : MonoBehaviour
{
	private ParticleSystem m_ParticleSystem;

	private float m_LastRotation;

	public Transform head;

	private void Start()
	{
		m_ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void LateUpdate()
	{
		float z = head.transform.rotation.eulerAngles.z;
		if (m_LastRotation != z)
		{
			float num = z - m_LastRotation;
			NativeArray<ParticleSystem.Particle> particles = new NativeArray<ParticleSystem.Particle>(m_ParticleSystem.particleCount, Allocator.Temp);
			int particles2 = m_ParticleSystem.GetParticles(particles);
			for (int i = 0; i < particles2; i++)
			{
				ParticleSystem.Particle value = particles[i];
				value.rotation += num;
				particles[i] = value;
			}
			m_ParticleSystem.SetParticles(particles, particles2);
			particles.Dispose();
			m_LastRotation = z;
		}
	}
}
public class GameInfoBoard : MonoBehaviour
{
	public Transform Head;

	public Transform GameInfoBoardCanvas;

	public Text playProgress;

	public Text comboNum;

	public GameObject hitFailMissedNum;

	public Transform timeCircle;

	public Transform hitFailCircle;

	public RotateTipManager rotateTipManager;

	private int timeIndex;

	private int lastHitFailMissed;

	private int lastYuShu;

	private int dingWeiIndex;

	private int hitFailCircleStartTimeIndex;

	private int hitFailCirclePlayedTimeIndex;

	private int hitFailCircleTotalRotate = 60;

	private int hitFailCircleRotateTimes = 10;

	private int failDirection;

	private int timeCircleTotalOneRotate = 6;

	private int timeCircleTotalOneRotateCiShu = 5;

	private void Start()
	{
		timeIndex = 0;
		lastHitFailMissed = 0;
		lastYuShu = -1;
		hitFailCircleStartTimeIndex = -1;
	}

	private void setDingWeiIndx(int dingWeiIndex)
	{
		this.dingWeiIndex = dingWeiIndex;
		GameInfoBoardCanvas.GetComponent<Animator>().Play("hide");
	}

	public void showCanvasRotate()
	{
		int num = 0;
		num = dingWeiIndex switch
		{
			1 => 0, 
			2 => 60, 
			3 => 120, 
			4 => 180, 
			5 => 240, 
			6 => 300, 
			_ => 0, 
		};
		UnityEngine.Vector3 eulerAngles = GameInfoBoardCanvas.eulerAngles;
		GameInfoBoardCanvas.eulerAngles = new UnityEngine.Vector3(eulerAngles.x, num, eulerAngles.z);
		GameInfoBoardCanvas.GetComponent<Animator>().Play("show");
	}

	internal void updateGameInfoBoard(int timeIndex)
	{
		if (timeIndex > 0)
		{
			this.timeIndex = timeIndex;
		}
		rotateTipManager.showRotateTip(timeIndex);
		updateInfo();
		if (!UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			UnitySingleton<DataCenter>.Instance.generatorLaw.generatorBeatOriginChangeDic.TryGetValue(timeIndex + 30, out var value);
			if (value != null && !value.twoWayBackToSingle && !value.mutual)
			{
				int toIndex = value.toIndex;
				setDingWeiIndx(toIndex);
			}
		}
	}

	public void updateInfo()
	{
		UnitySingleton<DataCenter>.Instance.gamePlayInfo.playTime = getPlayProgressStr();
		playProgress.text = getPlayProgressDJSStr();
		if (comboNum != null)
		{
			comboNum.text = getComboNum();
		}
		timeCircleUpdate();
		updateHitFailMissedNum();
	}

	private string getComboNum()
	{
		return string.Concat(UnitySingleton<DataCenter>.Instance.gamePlayInfo.comboNum);
	}

	private void updateHitFailMissedNum()
	{
		int grandFailNum = UnitySingleton<DataCenter>.Instance.gamePlayInfo.grandFailNum;
		playHitFailCircle(grandFailNum - lastHitFailMissed);
		if (grandFailNum != lastHitFailMissed)
		{
			hitFailMissedNum.GetComponent<Text>().text = grandFailNum.ToString();
			hitFailMissedNum.GetComponent<Animation>().Play();
			lastHitFailMissed = grandFailNum;
		}
	}

	private void playHitFailCircle(int failNum)
	{
		if (failNum == 0 && hitFailCircleStartTimeIndex < 0)
		{
			return;
		}
		if (failNum != 0 && hitFailCircleStartTimeIndex < 0)
		{
			failDirection = -failNum;
			hitFailCircleStartTimeIndex = timeIndex;
			hitFailCirclePlayedTimeIndex = timeIndex;
			float z = hitFailCircleTotalRotate / hitFailCircleRotateTimes * failDirection;
			hitFailCircle.Rotate(new UnityEngine.Vector3(0f, 0f, z));
		}
		if (hitFailCircleStartTimeIndex > 0 && timeIndex > hitFailCirclePlayedTimeIndex)
		{
			int num = timeIndex - hitFailCirclePlayedTimeIndex;
			float z2 = hitFailCircleTotalRotate / hitFailCircleRotateTimes * failDirection * num;
			hitFailCircle.Rotate(new UnityEngine.Vector3(0f, 0f, z2));
			hitFailCirclePlayedTimeIndex = timeIndex;
			if (hitFailCirclePlayedTimeIndex - hitFailCircleStartTimeIndex > hitFailCircleRotateTimes)
			{
				hitFailCircleStartTimeIndex = -1;
			}
		}
	}

	private Color getColorByHitFailMissed(int hitFailMissed)
	{
		return getFailTextColor(hitFailMissed);
	}

	private Color getFailTextColor(int index)
	{
		float num = 1f;
		float num2 = 1f;
		float num3 = 1f;
		float num4 = 0.4f;
		int num5 = 8;
		if (index < 0 || index > num5)
		{
			return new Color(num, num2, num3);
		}
		float num6 = (num - num4) / (float)num5;
		float num7 = (num2 - num4) / (float)num5;
		float num8 = (num3 - num4) / (float)num5;
		return new Color(num - (float)index * num6, num2 - (float)index * num7, num3 - (float)index * num8);
	}

	private string getPlayProgressDJSStr()
	{
		int totalTimeUnits = UnitySingleton<DataCenter>.Instance.generatorLaw.totalTimeUnits;
		return getTimeStrByTimeUnits((totalTimeUnits - timeIndex >= 0) ? (totalTimeUnits - timeIndex) : 0);
	}

	private void timeCircleUpdate()
	{
		int num = timeIndex % MainPlayControl.timeIndexPerSeconds;
		if (num != lastYuShu)
		{
			lastYuShu = num;
			if (lastYuShu > MainPlayControl.timeIndexPerSeconds - timeCircleTotalOneRotateCiShu)
			{
				float num2 = timeCircleTotalOneRotate / timeCircleTotalOneRotateCiShu;
				timeCircle.Rotate(new UnityEngine.Vector3(0f, 0f, 0f - num2));
			}
		}
	}

	private string getPlayProgressStr()
	{
		int totalTimeUnits = UnitySingleton<DataCenter>.Instance.generatorLaw.totalTimeUnits;
		string timeStrByTimeUnits = getTimeStrByTimeUnits(totalTimeUnits);
		return getTimeStrByTimeUnits((timeIndex < totalTimeUnits) ? timeIndex : totalTimeUnits) + "/" + timeStrByTimeUnits;
	}

	private string getTimeStrByTimeUnits(int timeInUnits)
	{
		int num = timeInUnits / MainPlayControl.timeIndexPerSeconds;
		int num2 = num / 60;
		int num3 = num - num2 * 60;
		if (num3 > 9)
		{
			return num2 + ":" + num3;
		}
		return num2 + ":0" + num3;
	}
}
public class GateController : MonoBehaviour
{
	public GameObject gate1;

	public GameObject gate2;

	public GameObject gate3;

	public GameObject gate4;

	public GameObject gate5;

	public GameObject gate6;

	private List<GameObject> hideSparkList = new List<GameObject>();

	private bool isSparking;

	private float sparkingTime;

	private bool isShowOriginChange;

	private float showOriginChangeTime;

	private void Start()
	{
		isSparking = false;
		sparkingTime = 0f;
		isShowOriginChange = false;
		showOriginChangeTime = 0f;
		HideAll();
		if (UnitySingleton<DataCenter>.Instance.generateParameter.angleType == GenerateParameter.AngleType.Single)
		{
			gate1.SetActive(value: true);
		}
		if (UnitySingleton<DataCenter>.Instance.generateParameter.angleType == GenerateParameter.AngleType.Two)
		{
			gate1.SetActive(value: true);
			gate2.SetActive(value: true);
		}
		if (UnitySingleton<DataCenter>.Instance.generateParameter.angleType == GenerateParameter.AngleType.Three)
		{
			gate1.SetActive(value: true);
			gate2.SetActive(value: true);
			gate6.SetActive(value: true);
		}
		if (UnitySingleton<DataCenter>.Instance.generateParameter.angleType == GenerateParameter.AngleType.All)
		{
			gate1.SetActive(value: true);
			gate2.SetActive(value: true);
			gate3.SetActive(value: true);
			gate4.SetActive(value: true);
			gate5.SetActive(value: true);
			gate6.SetActive(value: true);
		}
	}

	private void HideAll()
	{
		gate1.SetActive(value: false);
		gate2.SetActive(value: false);
		gate3.SetActive(value: false);
		gate4.SetActive(value: false);
		gate5.SetActive(value: false);
		gate6.SetActive(value: false);
	}

	private void Update()
	{
	}

	internal void spark(int timeIndex)
	{
		if (isSparking)
		{
			sparkUpdate();
			return;
		}
		UnitySingleton<DataCenter>.Instance.generatorLaw.generatorBeatGateSparkDic.TryGetValue(timeIndex, out var value);
		if (value != null)
		{
			hideSparkList.Clear();
			for (int i = 0; i < value.Count; i++)
			{
				GameObject gateByIndex = getGateByIndex(value[i]);
				ParticalSpark(gateByIndex);
				hideSparkList.Add(gateByIndex.transform.Find("vlights").gameObject);
				gateByIndex.transform.Find("vlights").gameObject.SetActive(value: true);
			}
			isSparking = true;
			sparkingTime = 0f;
		}
	}

	private void ParticalSpark(GameObject gate)
	{
		gate.transform.Find("PurpleLightJump").GetComponent<ParticleSystem>().Play();
		gate.transform.Find("YellowLightJump").GetComponent<ParticleSystem>().Play();
	}

	private GameObject getGateByIndex(int index)
	{
		return index switch
		{
			1 => gate1, 
			2 => gate2, 
			3 => gate3, 
			4 => gate4, 
			5 => gate5, 
			6 => gate6, 
			_ => gate1, 
		};
	}

	internal void sparkUpdate()
	{
		sparkingTime += Time.deltaTime;
		if (sparkingTime > 0.01f)
		{
			for (int i = 0; i < hideSparkList.Count; i++)
			{
				hideSparkList[i].SetActive(value: false);
			}
			isSparking = false;
		}
	}

	internal void showOriginChange(int timeIndex)
	{
		if (isShowOriginChange)
		{
			UpdateShowOriginChange();
			return;
		}
		int key = timeIndex + UnitySingleton<DataCenter>.Instance.flyOPDistanceIndex;
		UnitySingleton<DataCenter>.Instance.generatorLaw.generatorBeatOriginChangeDic.TryGetValue(key, out var value);
		if (value == null)
		{
			return;
		}
		if (value.twoWayBackToSingle)
		{
			GameObject gateByIndex = getGateByIndex(value.twoWayBackToSingleOrIndex);
			ShowOriginChange(gateByIndex, value.originChangeTypeTwoWayBackToSingle);
		}
		else
		{
			GameObject gateByIndex2 = getGateByIndex(value.orIndex);
			ShowOriginChange(gateByIndex2, value.originChangeType);
			if (value.mutual)
			{
				GameObject gateByIndex3 = getGateByIndex(value.toIndex);
				ShowOriginChange(gateByIndex3, value.originChangeTypeMutual);
			}
		}
		isShowOriginChange = true;
		showOriginChangeTime = 0f;
	}

	private void ShowOriginChange(GameObject gate, GenGateInfo.OriginChangeType originChangeType)
	{
		switch (originChangeType)
		{
		case GenGateInfo.OriginChangeType.Back:
			gate.transform.Find("OriginChange/Back").gameObject.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.Left:
			gate.transform.Find("OriginChange/Left").gameObject.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.Right:
			gate.transform.Find("OriginChange/Right").gameObject.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.RightMin:
			gate.transform.Find("OriginChange/RightMin").gameObject.SetActive(value: true);
			break;
		case GenGateInfo.OriginChangeType.LeftMin:
			gate.transform.Find("OriginChange/LeftMin").gameObject.SetActive(value: true);
			break;
		}
	}

	private void UpdateShowOriginChange()
	{
		showOriginChangeTime += Time.deltaTime;
		if (showOriginChangeTime > (float)(UnitySingleton<DataCenter>.Instance.flyOPDistanceIndex / 40))
		{
			HideOriginChange(gate1);
			HideOriginChange(gate2);
			HideOriginChange(gate3);
			HideOriginChange(gate4);
			HideOriginChange(gate5);
			HideOriginChange(gate6);
			isShowOriginChange = false;
		}
	}

	private void HideOriginChange(GameObject gate)
	{
		gate.transform.Find("OriginChange/Left").gameObject.SetActive(value: false);
		gate.transform.Find("OriginChange/LeftMin").gameObject.SetActive(value: false);
		gate.transform.Find("OriginChange/Right").gameObject.SetActive(value: false);
		gate.transform.Find("OriginChange/RightMin").gameObject.SetActive(value: false);
		gate.transform.Find("OriginChange/Back").gameObject.SetActive(value: false);
	}
}
public class GenGateInfo
{
	public class OriginChangeShow
	{
		public int orIndex { get; set; }

		public int toIndex { get; set; }

		public bool mutual { get; set; }

		public bool twoWayBackToSingle { get; set; }

		public int twoWayBackToSingleOrIndex { get; set; }

		public OriginChangeType originChangeType { get; set; }

		public OriginChangeType originChangeTypeTwoWayBackToSingle { get; set; }

		public OriginChangeType originChangeTypeMutual { get; set; }
	}

	public enum OriginChangeType
	{
		Left,
		Right,
		Back,
		LeftMin,
		RightMin
	}

	public enum OriginSourceMode
	{
		Single,
		P60,
		P120,
		P180
	}

	public class OriginDirection
	{
		public OriginSourceMode originSourceMode { get; set; }

		public int baseIndex { get; set; }

		public int oldbaseIndex { get; set; }

		public bool newFirstDirection { get; set; }

		public int changeTimeIndex { get; set; }

		public bool twoWayBackToSingle { get; set; }

		public int twoWayAnotherIndex { get; set; }

		public OriginDirection()
		{
			originSourceMode = OriginSourceMode.Single;
			baseIndex = 1;
			oldbaseIndex = 1;
			twoWayAnotherIndex = 1;
			newFirstDirection = false;
			twoWayBackToSingle = false;
			changeTimeIndex = 0;
		}
	}

	public List<int> sparkGates { get; set; }

	public List<OriginChangeShow> originChangeShows { get; set; }
}
public abstract class BaseBallCombo
{
	public class TwoOriginTwoBall
	{
		public int x1 { get; set; }

		public int z1 { get; set; }

		public int x2 { get; set; }

		public int z2 { get; set; }

		public TwoOriginTwoBall(int x1, int z1, int x2, int z2)
		{
			this.x1 = x1;
			this.z1 = z1;
			this.x2 = x2;
			this.z2 = z2;
		}
	}

	public static int LastGenTimeIndex;

	public static int LastRGenEndTimeIndex;

	private static List<TwoOriginTwoBall> TwoOriginTwoBallLeftList;

	private static List<TwoOriginTwoBall> TwoOriginTwoBallRightList;

	public bool multipleOriginGate;

	public List<List<GeneratorLaw.BallInfo>> list;

	public List<List<List<GeneratorLaw.BallInfo>>> multiplTimeIndexList;

	public bool isTwoWayCombo;

	public GenGateInfo.OriginDirection originDirection;

	public abstract void listInit(int lastDirectionIndex);

	public void PutBallInfList(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorDic, GenGateInfo.OriginDirection originDirection)
	{
		this.originDirection = originDirection;
		if (this.list != null)
		{
			int num = beatInfo.timeIndex - LastGenTimeIndex;
			LastGenTimeIndex = beatInfo.timeIndex;
			if (beatInfo.timeIndex - num >= LastRGenEndTimeIndex)
			{
				this.list = new List<List<GeneratorLaw.BallInfo>>();
				listInit(originDirection.baseIndex);
				int index = Mathf.FloorToInt(UnityEngine.Random.Range(0f, (float)this.list.Count - 0.01f));
				List<GeneratorLaw.BallInfo> value = this.list[index];
				generatorDic.Add(beatInfo.timeIndex, value);
				LastRGenEndTimeIndex = beatInfo.timeIndex;
			}
			return;
		}
		int num2 = beatInfo.timeIndex - LastGenTimeIndex;
		LastGenTimeIndex = beatInfo.timeIndex;
		if (beatInfo.timeIndex - num2 >= LastRGenEndTimeIndex)
		{
			multiplTimeIndexList = new List<List<List<GeneratorLaw.BallInfo>>>();
			listInit(originDirection.baseIndex);
			int index2 = Mathf.FloorToInt(UnityEngine.Random.Range(0f, (float)multiplTimeIndexList.Count - 0.01f));
			List<List<GeneratorLaw.BallInfo>> list = multiplTimeIndexList[index2];
			int num3 = Mathf.FloorToInt(1f / UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed * (float)MainPlayControl.timeIndexPerSeconds) + 1;
			for (int i = 0; i < list.Count; i++)
			{
				List<GeneratorLaw.BallInfo> value2 = list[i];
				generatorDic.Add(beatInfo.timeIndex + i * num3, value2);
			}
			LastRGenEndTimeIndex = beatInfo.timeIndex + (list.Count - 1) * num3;
		}
	}

	public abstract int GetWeightByLevel(int level);

	public bool IsHaveBlack()
	{
		return false;
	}

	public List<GenerateParameter.AngleType> SupportedAngleTypes()
	{
		return AllAngleTypes();
	}

	public List<GenerateParameter.AngleType> AllAngleTypes()
	{
		return new List<GenerateParameter.AngleType>
		{
			GenerateParameter.AngleType.Single,
			GenerateParameter.AngleType.Two,
			GenerateParameter.AngleType.Three,
			GenerateParameter.AngleType.All
		};
	}

	public bool CheckMultipleDistance(GeneratorLaw.BeatInfo beatInfo)
	{
		return true;
	}

	public GeneratorLaw.BallInfo newBall(GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection ballDirection, int lastDirectionIndex)
	{
		return new GeneratorLaw.BallInfo
		{
			ballDirection = ballDirection,
			dingWeiIndex = lastDirectionIndex,
			targetIndex = new Vector2Int(x, z),
			ballType = ballType
		};
	}

	public void initBalls(params GeneratorLaw.BallInfo[] ballInfoArray)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		for (int i = 0; i < ballInfoArray.Length; i++)
		{
			list.Add(ballInfoArray[i]);
		}
		this.list.Add(list);
	}

	public List<GeneratorLaw.BallInfo> OneLineBlackHorizontal(int zBlackLine, int lastDirectionIndex)
	{
		return new List<GeneratorLaw.BallInfo>
		{
			newBall(GeneratorLaw.BallType.BlackBall, 1, zBlackLine, GeneratorLaw.BallDirection.Down, lastDirectionIndex),
			newBall(GeneratorLaw.BallType.BlackBall, 2, zBlackLine, GeneratorLaw.BallDirection.Down, lastDirectionIndex),
			newBall(GeneratorLaw.BallType.BlackBall, 3, zBlackLine, GeneratorLaw.BallDirection.Down, lastDirectionIndex),
			newBall(GeneratorLaw.BallType.BlackBall, 4, zBlackLine, GeneratorLaw.BallDirection.Down, lastDirectionIndex)
		};
	}

	public List<GeneratorLaw.BallInfo> OneLineBlackVertical(int xBlackLine, int lastDirectionIndex)
	{
		return new List<GeneratorLaw.BallInfo>
		{
			newBall(GeneratorLaw.BallType.BlackBall, xBlackLine, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex),
			newBall(GeneratorLaw.BallType.BlackBall, xBlackLine, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex),
			newBall(GeneratorLaw.BallType.BlackBall, xBlackLine, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex),
			newBall(GeneratorLaw.BallType.BlackBall, xBlackLine, 4, GeneratorLaw.BallDirection.Down, lastDirectionIndex)
		};
	}

	public List<TwoOriginTwoBall> getTwoOriginTwoBallLeftList()
	{
		if (TwoOriginTwoBallLeftList == null)
		{
			TwoOriginTwoBallList();
		}
		return TwoOriginTwoBallLeftList;
	}

	public List<TwoOriginTwoBall> getTwoOriginTwoBallRightList()
	{
		if (TwoOriginTwoBallRightList == null)
		{
			TwoOriginTwoBallList();
		}
		return TwoOriginTwoBallRightList;
	}

	private static void TwoOriginTwoBallList()
	{
		TwoOriginTwoBallLeftList = new List<TwoOriginTwoBall>();
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 4, 4, 4));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 3, 4, 3));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 2, 4, 2));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 1, 4, 1));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 4, 3, 3));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(4, 4, 4, 3));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 3, 3, 2));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(4, 3, 4, 2));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(3, 2, 3, 1));
		TwoOriginTwoBallLeftList.Add(new TwoOriginTwoBall(4, 2, 4, 1));
		TwoOriginTwoBallRightList = new List<TwoOriginTwoBall>();
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 4, 1, 4));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 3, 1, 3));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 2, 1, 2));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 1, 1, 1));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 4, 2, 3));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(1, 4, 1, 3));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 3, 2, 2));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(1, 3, 1, 2));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(2, 2, 2, 1));
		TwoOriginTwoBallRightList.Add(new TwoOriginTwoBall(1, 2, 1, 1));
	}
}
public class ThreeBallBlackHard : BaseBallCombo
{
	public ThreeBallBlackHard()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 0, 
			5 => 4, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initThreeBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 1, 2, 3, lastDirectionIndex);
		initThreeBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 2, 3, 4, lastDirectionIndex);
		initThreeBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 2, 3, 4, lastDirectionIndex);
	}

	private void initThreeBallHardVertical(int xBallLine, int xBlackLine1, int xBlackLine2, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType, int zBall1, int zBall2, int zBall3, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, xBallLine, zBall1, ballDirection, lastDirectionIndex));
		list.Add(newBall(ballType, xBallLine, zBall2, ballDirection, lastDirectionIndex));
		list.Add(newBall(ballType, xBallLine, zBall3, ballDirection, lastDirectionIndex));
		list.AddRange(OneLineBlackVertical(xBlackLine1, lastDirectionIndex));
		list.AddRange(OneLineBlackVertical(xBlackLine2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	private void initThreeBallHardHorizontal(int zBallLine, int zBlackLine1, int zBlackLine2, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType, int xBall1, int xBall2, int xBall3, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, xBall1, zBallLine, ballDirection, lastDirectionIndex));
		list.Add(newBall(ballType, xBall2, zBallLine, ballDirection, lastDirectionIndex));
		list.Add(newBall(ballType, xBall3, zBallLine, ballDirection, lastDirectionIndex));
		list.AddRange(OneLineBlackHorizontal(zBlackLine1, lastDirectionIndex));
		list.AddRange(OneLineBlackHorizontal(zBlackLine2, lastDirectionIndex));
		initBalls(list.ToArray());
	}
}
public class TwoBallBlackHard : BaseBallCombo
{
	public TwoBallBlackHard()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 1, 
			5 => 3, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initTwoBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 1, 2, lastDirectionIndex);
		initTwoBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 1, 2, lastDirectionIndex);
		initTwoBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 1, 2, lastDirectionIndex);
		initTwoBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 1, 2, lastDirectionIndex);
		initTwoBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 3, 4, lastDirectionIndex);
		initTwoBallHardHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 3, 4, lastDirectionIndex);
		initTwoBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 3, 4, lastDirectionIndex);
		initTwoBallHardHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 3, 4, lastDirectionIndex);
		initTwoBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 1, 2, lastDirectionIndex);
		initTwoBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 1, 2, lastDirectionIndex);
		initTwoBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 1, 2, lastDirectionIndex);
		initTwoBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 1, 2, lastDirectionIndex);
		initTwoBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 3, 4, lastDirectionIndex);
		initTwoBallHardVertical(3, 2, 4, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 4, lastDirectionIndex);
		initTwoBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 3, 4, lastDirectionIndex);
		initTwoBallHardVertical(2, 1, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 4, lastDirectionIndex);
	}

	private void initTwoBallHardVertical(int xBallLine, int xBlackLine1, int xBlackLine2, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType, int zBall1, int zBall2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, xBallLine, zBall1, ballDirection, lastDirectionIndex));
		list.Add(newBall(ballType, xBallLine, zBall2, ballDirection, lastDirectionIndex));
		list.AddRange(OneLineBlackVertical(xBlackLine1, lastDirectionIndex));
		list.AddRange(OneLineBlackVertical(xBlackLine2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	private void initTwoBallHardHorizontal(int zBallLine, int zBlackLine1, int zBlackLine2, GeneratorLaw.BallDirection ballDirection, GeneratorLaw.BallType ballType, int xBall1, int xBall2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, xBall1, zBallLine, ballDirection, lastDirectionIndex));
		list.Add(newBall(ballType, xBall2, zBallLine, ballDirection, lastDirectionIndex));
		list.AddRange(OneLineBlackHorizontal(zBlackLine1, lastDirectionIndex));
		list.AddRange(OneLineBlackHorizontal(zBlackLine2, lastDirectionIndex));
		initBalls(list.ToArray());
	}
}
public class OneBallTwoHandBlack : BaseBallCombo
{
	public OneBallTwoHandBlack()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 4, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initTwoLineBlackVertical(1, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, 4, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 3, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, 4, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, 4, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 3, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, 4, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, 4, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, 4, 3, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, 4, 3, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackVertical(1, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, 4, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initTwoLineBlackHorizontal(1, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Down, 4, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initTwoLineBlackHorizontal(4, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Up, 1, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
	}

	private void initTwoLineBlackHorizontal(int zLine1, int xBall1, GeneratorLaw.BallType ball1, GeneratorLaw.BallDirection ballDirection1, int zLine2, int xBall2, GeneratorLaw.BallType ball2, GeneratorLaw.BallDirection ballDirection2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(initOneLineBlackHorizontal(zLine1, xBall1, ball1, ballDirection1, lastDirectionIndex));
		list.AddRange(initOneLineBlackHorizontal(zLine2, xBall2, ball2, ballDirection2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	public List<GeneratorLaw.BallInfo> initOneLineBlackHorizontal(int zLine, int xBall, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		for (int i = 1; i < 5; i++)
		{
			GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
			if (i == xBall)
			{
				ballInfo.ballDirection = direction;
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(i, zLine);
				ballInfo.ballType = ballType;
			}
			else
			{
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(i, zLine);
				ballInfo.ballType = GeneratorLaw.BallType.BlackBall;
			}
			list.Add(ballInfo);
		}
		return list;
	}

	private void initTwoLineBlackVertical(int xLine1, int zBall1, GeneratorLaw.BallType ball1, GeneratorLaw.BallDirection ballDirection1, int xLine2, int zBall2, GeneratorLaw.BallType ball2, GeneratorLaw.BallDirection ballDirection2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(initOneLineBlackVertical(xLine1, zBall1, ball1, ballDirection1, lastDirectionIndex));
		list.AddRange(initOneLineBlackVertical(xLine2, zBall2, ball2, ballDirection2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	public List<GeneratorLaw.BallInfo> initOneLineBlackVertical(int xLine, int zBall, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		for (int i = 1; i < 5; i++)
		{
			GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
			if (i == zBall)
			{
				ballInfo.ballDirection = direction;
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(xLine, i);
				ballInfo.ballType = ballType;
			}
			else
			{
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(xLine, i);
				ballInfo.ballType = GeneratorLaw.BallType.BlackBall;
			}
			list.Add(ballInfo);
		}
		return list;
	}
}
public class SingleBallBlack : BaseBallCombo
{
	public SingleBallBlack()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 2, 
			4 => 3, 
			5 => 0, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initOneLineBlackHorizontal(1, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneLineBlackHorizontal(1, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneLineBlackHorizontal(2, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneLineBlackHorizontal(2, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneLineBlackHorizontal(3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneLineBlackHorizontal(3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneLineBlackHorizontal(4, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneLineBlackHorizontal(4, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneLineBlackVertical(1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(2, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(3, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(4, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneLineBlackVertical(4, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
	}

	private void initOneLineBlackVertical(int xLine, int zBall, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		initOneLineBlackVerticalSingleHand(xLine, zBall, GeneratorLaw.BallType.LeftBall, direction, lastDirectionIndex);
		initOneLineBlackVerticalSingleHand(xLine, zBall, GeneratorLaw.BallType.RightBall, direction, lastDirectionIndex);
	}

	private void initOneLineBlackVerticalSingleHand(int xLine, int zBall, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		for (int i = 1; i < 5; i++)
		{
			GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
			if (i == zBall)
			{
				ballInfo.ballDirection = direction;
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(xLine, i);
				ballInfo.ballType = ballType;
			}
			else
			{
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(xLine, i);
				ballInfo.ballType = GeneratorLaw.BallType.BlackBall;
			}
			list.Add(ballInfo);
		}
		initBalls(list.ToArray());
	}

	private void initOneLineBlackHorizontal(int zLine, int xBall, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		initOneLineBlackHorizontalSingleHand(zLine, xBall, GeneratorLaw.BallType.LeftBall, direction, lastDirectionIndex);
		initOneLineBlackHorizontalSingleHand(zLine, xBall, GeneratorLaw.BallType.RightBall, direction, lastDirectionIndex);
	}

	private void initOneLineBlackHorizontalSingleHand(int zLine, int xBall, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		for (int i = 1; i < 5; i++)
		{
			GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
			if (i == xBall)
			{
				ballInfo.ballDirection = direction;
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(i, zLine);
				ballInfo.ballType = ballType;
			}
			else
			{
				ballInfo.dingWeiIndex = lastDirectionIndex;
				ballInfo.targetIndex = new Vector2Int(i, zLine);
				ballInfo.ballType = GeneratorLaw.BallType.BlackBall;
			}
			list.Add(ballInfo);
		}
		initBalls(list.ToArray());
	}
}
public class OneBallTwoHandHaordConfilct : BaseBallCombo
{
	public OneBallTwoHandHaordConfilct()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 3, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneBallTwoHand(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
	}

	private void initOneBallTwoHand(GeneratorLaw.BallType ballType1, int x1, int z1, GeneratorLaw.BallDirection ballDirection1, GeneratorLaw.BallType ballType2, int x2, int z2, GeneratorLaw.BallDirection ballDirection2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(initOneBallHardConflict(x1, z1, ballType1, ballDirection1, lastDirectionIndex));
		list.AddRange(initOneBallHardConflict(x2, z2, ballType2, ballDirection2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	public List<GeneratorLaw.BallInfo> initOneBallHardConflict(int x, int z, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection ballDirection, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, x, z, ballDirection, lastDirectionIndex));
		switch (ballDirection)
		{
		case GeneratorLaw.BallDirection.Up:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x, z + 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		case GeneratorLaw.BallDirection.Down:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x, z - 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		case GeneratorLaw.BallDirection.Left:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x - 1, z, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		default:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x + 1, z, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		}
		return list;
	}
}
public class OneballHardConflict : BaseBallCombo
{
	public OneballHardConflict()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 2, 
			4 => 4, 
			5 => 1, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initOneBallHardConflict4DirectionTwoHand(2, 3, lastDirectionIndex);
		initOneBallHardConflict4DirectionTwoHand(3, 3, lastDirectionIndex);
		initOneBallHardConflict4DirectionTwoHand(2, 2, lastDirectionIndex);
		initOneBallHardConflict4DirectionTwoHand(3, 2, lastDirectionIndex);
	}

	private void initOneBallHardConflict4DirectionTwoHand(int x, int z, int lastDirectionIndex)
	{
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initOneBallHardConflict(x, z, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
	}

	public void initOneBallHardConflict(int x, int z, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection ballDirection, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, x, z, ballDirection, lastDirectionIndex));
		switch (ballDirection)
		{
		case GeneratorLaw.BallDirection.Up:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x, z + 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		case GeneratorLaw.BallDirection.Down:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x, z - 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		case GeneratorLaw.BallDirection.Left:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x - 1, z, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		default:
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x + 1, z, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		}
		initBalls(list.ToArray());
	}
}
public class TwoBallHardConflict : BaseBallCombo
{
	public TwoBallHardConflict()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 0, 
			5 => 3, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		InitTwoBallHardConflictHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(3, 2, 4, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictHorizontal(2, 1, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictVertical(2, 1, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictVertical(2, 1, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictVertical(3, 2, 4, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.LeftBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictVertical(3, 2, 4, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, lastDirectionIndex);
		InitTwoBallHardConflictVertical(2, 1, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictVertical(2, 1, 3, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictVertical(3, 2, 4, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.LeftBall, 2, lastDirectionIndex);
		InitTwoBallHardConflictVertical(3, 2, 4, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 2, lastDirectionIndex);
	}

	private void InitTwoBallHardConflictVertical(int xBallLine, int blackLine1, int blackLine2, GeneratorLaw.BallDirection direction, GeneratorLaw.BallType ballType, int zBall, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(OneLineBlackVertical(blackLine1, lastDirectionIndex));
		list.AddRange(OneLineBlackVertical(blackLine2, lastDirectionIndex));
		list.Add(newBall(ballType, xBallLine, zBall, direction, lastDirectionIndex));
		if (direction == GeneratorLaw.BallDirection.Down)
		{
			list.Add(newBall(ballType, xBallLine, zBall - 1, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, xBallLine, zBall - 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		}
		else
		{
			list.Add(newBall(ballType, xBallLine, zBall + 1, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, xBallLine, zBall + 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		}
		initBalls(list.ToArray());
	}

	private void InitTwoBallHardConflictHorizontal(int zBallLine, int blackLine1, int blackLine2, GeneratorLaw.BallDirection direction, GeneratorLaw.BallType ballType, int xBall, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(OneLineBlackHorizontal(blackLine1, lastDirectionIndex));
		list.AddRange(OneLineBlackHorizontal(blackLine2, lastDirectionIndex));
		list.Add(newBall(ballType, xBall, zBallLine, direction, lastDirectionIndex));
		if (direction == GeneratorLaw.BallDirection.Left)
		{
			list.Add(newBall(ballType, xBall - 1, zBallLine, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, xBall - 2, zBallLine, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		}
		else
		{
			list.Add(newBall(ballType, xBall + 1, zBallLine, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, xBall + 2, zBallLine, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		}
		initBalls(list.ToArray());
	}
}
public class TwoBallNoBlackConflict : BaseBallCombo
{
	public TwoBallNoBlackConflict()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 2, 
			4 => 4, 
			5 => 1, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
	}
}
public class TwoBallTwoHandConflict : BaseBallCombo
{
	public TwoBallTwoHandConflict()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public new bool IsHaveBlack()
	{
		return true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 0, 
			5 => 4, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Left, GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Right, GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Up, GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Down, GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
	}

	private void InitTwoBallTwoHandConflictVertical(GeneratorLaw.BallType ballType1, int x1, int z1, GeneratorLaw.BallDirection direction1, GeneratorLaw.BallType ballType2, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(OneLineBlackVertical(1, lastDirectionIndex));
		list.AddRange(OneLineBlackVertical(4, lastDirectionIndex));
		list.AddRange(TwoBallOneBlack(ballType1, x1, z1, direction1, lastDirectionIndex));
		list.AddRange(TwoBallOneBlack(ballType2, x2, z2, direction2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	private void InitTwoBallTwoHandConflictHorizontal(GeneratorLaw.BallType ballType1, int x1, int z1, GeneratorLaw.BallDirection direction1, GeneratorLaw.BallType ballType2, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.AddRange(OneLineBlackHorizontal(1, lastDirectionIndex));
		list.AddRange(OneLineBlackHorizontal(4, lastDirectionIndex));
		list.AddRange(TwoBallOneBlack(ballType1, x1, z1, direction1, lastDirectionIndex));
		list.AddRange(TwoBallOneBlack(ballType2, x2, z2, direction2, lastDirectionIndex));
		initBalls(list.ToArray());
	}

	private List<GeneratorLaw.BallInfo> TwoBallOneBlack(GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, x, z, direction, lastDirectionIndex));
		switch (direction)
		{
		case GeneratorLaw.BallDirection.Up:
			list.Add(newBall(ballType, x, z + 1, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x, z + 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		case GeneratorLaw.BallDirection.Down:
			list.Add(newBall(ballType, x, z - 1, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x, z - 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		case GeneratorLaw.BallDirection.Left:
			list.Add(newBall(ballType, x - 1, z, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x - 2, z, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		default:
			list.Add(newBall(ballType, x + 1, z, direction, lastDirectionIndex));
			list.Add(newBall(GeneratorLaw.BallType.BlackBall, x + 2, z, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
			break;
		}
		return list;
	}
}
public class OneBallTwoHandNegMaxDis : BaseBallCombo
{
	public OneBallTwoHandNegMaxDis()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 2, 
			5 => 3, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 1, 1, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 1, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 1, 4, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 1, 1, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 1, 4, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 1, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex));
	}
}
public class OneBallTwoHandNegMinDis : BaseBallCombo
{
	public OneBallTwoHandNegMinDis()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 1, 
			4 => 3, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.RightBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
	}
}
public class OneBallTwoHandPosMaxDis : BaseBallCombo
{
	public OneBallTwoHandPosMaxDis()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 3, 
			3 => 3, 
			4 => 2, 
			5 => 1, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 1, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 4, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 1, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
	}
}
public class OneBallTwoHandPosMinDis : BaseBallCombo
{
	public OneBallTwoHandPosMinDis()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 10, 
			2 => 8, 
			3 => 3, 
			4 => 1, 
			5 => 0, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 1, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 1, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 4, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
	}
}
public class OneBallTwoHandTangle : BaseBallCombo
{
	public OneBallTwoHandTangle()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 1, 
			2 => 4, 
			3 => 3, 
			4 => 1, 
			5 => 0, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
	}
}
public class QuickHardMaxDis : BaseBallCombo
{
	public QuickHardMaxDis()
	{
		multiplTimeIndexList = new List<List<List<GeneratorLaw.BallInfo>>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 2, 
			5 => 3, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initQuickHardMinDisSwitchHand(1, 1, GeneratorLaw.BallDirection.DownLeft, 4, 1, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 2, GeneratorLaw.BallDirection.Left, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 3, GeneratorLaw.BallDirection.Left, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 4, GeneratorLaw.BallDirection.UpLeft, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(2, 4, GeneratorLaw.BallDirection.Up, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(3, 4, GeneratorLaw.BallDirection.Up, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 4, GeneratorLaw.BallDirection.UpLeft, 1, 1, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(4, 1, GeneratorLaw.BallDirection.DownRight, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 1, GeneratorLaw.BallDirection.DownLeft, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 2, GeneratorLaw.BallDirection.Left, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 3, GeneratorLaw.BallDirection.Left, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 2, GeneratorLaw.BallDirection.Left, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(4, 2, GeneratorLaw.BallDirection.Right, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 3, GeneratorLaw.BallDirection.Left, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(4, 3, GeneratorLaw.BallDirection.Right, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
	}

	private void initQuickHardMinDisSwitchHand(int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		initQuickHardMinDis(GeneratorLaw.BallType.LeftBall, x1, z1, direction1, x2, z2, direction2, lastDirectionIndex);
		initQuickHardMinDis(GeneratorLaw.BallType.RightBall, x1, z1, direction1, x2, z2, direction2, lastDirectionIndex);
	}

	private void initQuickHardMinDis(GeneratorLaw.BallType ballType, int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		List<GeneratorLaw.BallInfo> list2 = new List<GeneratorLaw.BallInfo>();
		list2.Add(newBall(ballType, x1, z1, direction1, lastDirectionIndex));
		list.Add(list2);
		List<GeneratorLaw.BallInfo> list3 = new List<GeneratorLaw.BallInfo>();
		list3.Add(newBall(ballType, x2, z2, direction2, lastDirectionIndex));
		list.Add(list3);
		multiplTimeIndexList.Add(list);
	}
}
public class QuickHardMinDis : BaseBallCombo
{
	public QuickHardMinDis()
	{
		multiplTimeIndexList = new List<List<List<GeneratorLaw.BallInfo>>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 1, 
			3 => 4, 
			4 => 3, 
			5 => 1, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initQuickHardMinDisSwitchHand(2, 2, GeneratorLaw.BallDirection.Down, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(2, 1, GeneratorLaw.BallDirection.Down, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(2, 3, GeneratorLaw.BallDirection.Up, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(2, 4, GeneratorLaw.BallDirection.Up, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(2, 3, GeneratorLaw.BallDirection.Left, 2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(1, 3, GeneratorLaw.BallDirection.Left, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(3, 3, GeneratorLaw.BallDirection.Right, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initQuickHardMinDisSwitchHand(4, 3, GeneratorLaw.BallDirection.Right, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
	}

	private void initQuickHardMinDisSwitchHand(int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		initQuickHardMinDis(GeneratorLaw.BallType.LeftBall, x1, z1, direction1, x2, z2, direction2, lastDirectionIndex);
		initQuickHardMinDis(GeneratorLaw.BallType.RightBall, x1, z1, direction1, x2, z2, direction2, lastDirectionIndex);
	}

	private void initQuickHardMinDis(GeneratorLaw.BallType ballType, int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		List<GeneratorLaw.BallInfo> list2 = new List<GeneratorLaw.BallInfo>();
		list2.Add(newBall(ballType, x1, z1, direction1, lastDirectionIndex));
		list.Add(list2);
		List<GeneratorLaw.BallInfo> list3 = new List<GeneratorLaw.BallInfo>();
		list3.Add(newBall(ballType, x2, z2, direction2, lastDirectionIndex));
		list.Add(list3);
		multiplTimeIndexList.Add(list);
	}
}
public class QuickHardTwoHand : BaseBallCombo
{
	public QuickHardTwoHand()
	{
		multiplTimeIndexList = new List<List<List<GeneratorLaw.BallInfo>>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 2, 
			5 => 4, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.LeftBall, 1, 1, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 1, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.RightBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.RightBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.LeftBall, 1, 4, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 4, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.RightBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBallsQuickHardTwoHand(newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
	}

	private void initBallsQuickHardTwoHand(GeneratorLaw.BallInfo ballInfo1, GeneratorLaw.BallInfo ballInfo2, GeneratorLaw.BallInfo ballInfo3, GeneratorLaw.BallInfo ballInfo4)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		List<GeneratorLaw.BallInfo> list2 = new List<GeneratorLaw.BallInfo>();
		list2.Add(ballInfo1);
		list2.Add(ballInfo3);
		list.Add(list2);
		List<GeneratorLaw.BallInfo> list3 = new List<GeneratorLaw.BallInfo>();
		list3.Add(ballInfo2);
		list3.Add(ballInfo4);
		list.Add(list3);
		multiplTimeIndexList.Add(list);
	}
}
public class SingleBall : BaseBallCombo
{
	public SingleBall()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 10, 
			2 => 4, 
			3 => 1, 
			4 => 0, 
			5 => 0, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initSingleBall(1, 1, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex);
		initSingleBall(1, 1, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.DownLeft, lastDirectionIndex);
		initSingleBall(1, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initSingleBall(1, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initSingleBall(1, 3, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initSingleBall(1, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initSingleBall(1, 4, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex);
		initSingleBall(1, 4, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.UpLeft, lastDirectionIndex);
		initSingleBall(2, 4, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initSingleBall(2, 4, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initSingleBall(3, 4, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initSingleBall(3, 4, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initSingleBall(4, 4, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex);
		initSingleBall(4, 4, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.UpRight, lastDirectionIndex);
		initSingleBall(4, 3, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initSingleBall(4, 3, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initSingleBall(4, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initSingleBall(4, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initSingleBall(4, 2, GeneratorLaw.BallType.LeftBall, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex);
		initSingleBall(4, 2, GeneratorLaw.BallType.RightBall, GeneratorLaw.BallDirection.DownRight, lastDirectionIndex);
	}

	private void initSingleBall(int x, int z, GeneratorLaw.BallType ballType, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
		ballInfo.ballDirection = direction;
		ballInfo.dingWeiIndex = lastDirectionIndex;
		ballInfo.targetIndex = new Vector2Int(x, z);
		ballInfo.ballType = ballType;
		list.Add(ballInfo);
		base.list.Add(list);
	}
}
public class ThreeBallOneHand : BaseBallCombo
{
	public ThreeBallOneHand()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 1, 
			3 => 2, 
			4 => 4, 
			5 => 1, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initDirectThreeBallUp(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initDirectThreeBallUp(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initDirectThreeBallUp(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initDirectThreeBallUp(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initDirectThreeBallUp(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initDirectThreeBallUp(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex);
		initDirectThreeBallDown(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initDirectThreeBallDown(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initDirectThreeBallDown(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initDirectThreeBallDown(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initDirectThreeBallDown(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initDirectThreeBallDown(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Down, lastDirectionIndex);
		initDirectThreeBallLeft(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initDirectThreeBallLeft(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex);
		initDirectThreeBallRight(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
		initDirectThreeBallRight(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex);
	}

	public void initDirectThreeBallUp(GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		initBalls(newBall(ballType, x, z, direction, lastDirectionIndex), newBall(ballType, x, z + 1, direction, lastDirectionIndex), newBall(ballType, x, z + 2, direction, lastDirectionIndex));
	}

	public void initDirectThreeBallDown(GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		initBalls(newBall(ballType, x, z, direction, lastDirectionIndex), newBall(ballType, x, z - 1, direction, lastDirectionIndex), newBall(ballType, x, z - 2, direction, lastDirectionIndex));
	}

	public void initDirectThreeBallLeft(GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		initBalls(newBall(ballType, x, z, direction, lastDirectionIndex), newBall(ballType, x - 1, z, direction, lastDirectionIndex), newBall(ballType, x - 2, z, direction, lastDirectionIndex));
	}

	public void initDirectThreeBallRight(GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection direction, int lastDirectionIndex)
	{
		initBalls(newBall(ballType, x, z, direction, lastDirectionIndex), newBall(ballType, x + 1, z, direction, lastDirectionIndex), newBall(ballType, x + 2, z, direction, lastDirectionIndex));
	}
}
public class ThreeBallTwoHand : BaseBallCombo
{
	public ThreeBallTwoHand()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 2, 
			5 => 4, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initThreeBallTwoHandUp(1, 2, 2, 2, lastDirectionIndex);
		initThreeBallTwoHandUp(2, 2, 3, 2, lastDirectionIndex);
		initThreeBallTwoHandUp(3, 2, 4, 2, lastDirectionIndex);
		initThreeBallTwoHandDown(1, 3, 2, 3, lastDirectionIndex);
		initThreeBallTwoHandDown(2, 3, 3, 3, lastDirectionIndex);
		initThreeBallTwoHandDown(3, 3, 4, 3, lastDirectionIndex);
		initThreeBallTwoHandLeft(3, 3, 3, 2, lastDirectionIndex);
		initThreeBallTwoHandRight(2, 2, 2, 3, lastDirectionIndex);
	}

	private void initThreeBallTwoHandUp(int leftX, int leftZ, int rightX, int rightZ, int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ + 1, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ + 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ + 1, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ + 2, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
	}

	private void initThreeBallTwoHandDown(int leftX, int leftZ, int rightX, int rightZ, int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ - 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ - 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ - 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ - 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
	}

	private void initThreeBallTwoHandLeft(int leftX, int leftZ, int rightX, int rightZ, int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX - 1, leftZ, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX - 2, leftZ, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX - 1, rightZ, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX - 2, rightZ, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
	}

	private void initThreeBallTwoHandRight(int leftX, int leftZ, int rightX, int rightZ, int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, leftX, leftZ, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX + 1, leftZ, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, leftX + 2, leftZ, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX, rightZ, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX + 1, rightZ, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, rightX + 2, rightZ, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
	}
}
public class TwoBallOneHand : BaseBallCombo
{
	public TwoBallOneHand()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 2, 
			2 => 4, 
			3 => 6, 
			4 => 1, 
			5 => 0, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initTwoBallOneHandForTwoHandWithSecondBallDirection(1, 1, GeneratorLaw.BallDirection.DownLeft, 2, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(4, 4, GeneratorLaw.BallDirection.UpRight, 3, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(1, 4, GeneratorLaw.BallDirection.UpLeft, 2, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(4, 1, GeneratorLaw.BallDirection.DownRight, 3, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(2, 4, GeneratorLaw.BallDirection.Up, 2, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(3, 4, GeneratorLaw.BallDirection.Up, 3, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(4, 3, GeneratorLaw.BallDirection.Right, 3, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(4, 2, GeneratorLaw.BallDirection.Right, 3, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(3, 1, GeneratorLaw.BallDirection.Down, 3, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(2, 1, GeneratorLaw.BallDirection.Down, 2, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(1, 2, GeneratorLaw.BallDirection.Left, 2, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(1, 3, GeneratorLaw.BallDirection.Left, 2, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(2, 3, GeneratorLaw.BallDirection.Up, 2, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(3, 3, GeneratorLaw.BallDirection.Up, 3, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(2, 2, GeneratorLaw.BallDirection.Down, 2, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(3, 2, GeneratorLaw.BallDirection.Down, 3, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(3, 3, GeneratorLaw.BallDirection.Right, 2, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(3, 2, GeneratorLaw.BallDirection.Right, 2, 2, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(2, 3, GeneratorLaw.BallDirection.Left, 3, 3, lastDirectionIndex);
		initTwoBallOneHandForTwoHandWithSecondBallDirection(2, 2, GeneratorLaw.BallDirection.Left, 3, 2, lastDirectionIndex);
	}

	private void initTwoBallOneHandForTwoHandWithSecondBallDirection(int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, int lastDirectionIndex)
	{
		initTwoBallOneHandForTwoHand(x1, z1, direction1, x2, z2, direction1, lastDirectionIndex);
	}

	private void initTwoBallOneHandForTwoHand(int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, GeneratorLaw.BallDirection direction2, int lastDirectionIndex)
	{
		initTwoBallOneHand(x1, z1, direction1, x2, z2, direction2, GeneratorLaw.BallType.LeftBall, lastDirectionIndex);
		initTwoBallOneHand(x1, z1, direction1, x2, z2, direction2, GeneratorLaw.BallType.RightBall, lastDirectionIndex);
	}

	private void initTwoBallOneHand(int x1, int z1, GeneratorLaw.BallDirection direction1, int x2, int z2, GeneratorLaw.BallDirection direction2, GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
		ballInfo.ballDirection = direction1;
		ballInfo.dingWeiIndex = lastDirectionIndex;
		ballInfo.targetIndex = new Vector2Int(x1, z1);
		ballInfo.ballType = ballType;
		list.Add(ballInfo);
		GeneratorLaw.BallInfo ballInfo2 = new GeneratorLaw.BallInfo();
		ballInfo2.ballDirection = direction2;
		ballInfo2.dingWeiIndex = lastDirectionIndex;
		ballInfo2.targetIndex = new Vector2Int(x2, z2);
		ballInfo2.ballType = ballType;
		list.Add(ballInfo2);
		base.list.Add(list);
	}
}
public class TwoBallTwoHand : BaseBallCombo
{
	public TwoBallTwoHand()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 1, 
			3 => 2, 
			4 => 5, 
			5 => 3, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 1, GeneratorLaw.BallDirection.Down, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Up, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 4, GeneratorLaw.BallDirection.Up, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 2, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 3, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 2, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 1, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 2, 3, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
		initBalls(newBall(GeneratorLaw.BallType.LeftBall, 3, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.LeftBall, 4, 3, GeneratorLaw.BallDirection.Right, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 1, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex), newBall(GeneratorLaw.BallType.RightBall, 2, 2, GeneratorLaw.BallDirection.Left, lastDirectionIndex));
	}
}
public class TwoOriginOneBallCircle : BaseBallCombo
{
	public TwoOriginOneBallCircle()
	{
		multiplTimeIndexList = new List<List<List<GeneratorLaw.BallInfo>>>();
		isTwoWayCombo = true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 0, 
			5 => 3, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		int baseIndex = originDirection.baseIndex;
		int twoWayAnotherIndex = originDirection.twoWayAnotherIndex;
		multiplTimeIndexList.Add(ShunShiZhenFromBottom(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromLeft(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromTop(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromRight(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(NiShiZhenFromBottom(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(NiShiZhenFromLeft(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(NiShiZhenFromTop(baseIndex, twoWayAnotherIndex));
		multiplTimeIndexList.Add(NiShiZhenFromRight(baseIndex, twoWayAnotherIndex));
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromRight(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromBottom(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromTop(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromLeft(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromBottom(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromRight(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromTop(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromLeft(int baseOriginIndex, int anotherOriginIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, 1, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 4, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 3, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 4, 2, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 3, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 2, 1, baseOriginIndex, anotherOriginIndex);
		AddOneBallFrameToMultiple(list, 1, 2, baseOriginIndex, anotherOriginIndex);
		return list;
	}

	private void AddOneBallFrameToMultiple(List<List<GeneratorLaw.BallInfo>> multiplTimeIndexBallInfos, int x, int z, int baseOriginIndex, int anotherOriginIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(GeneratorLaw.BallType.LeftBall, x, z, GeneratorLaw.BallDirection.All, baseOriginIndex));
		list.Add(newBall(GeneratorLaw.BallType.RightBall, x, z, GeneratorLaw.BallDirection.All, anotherOriginIndex));
		multiplTimeIndexBallInfos.Add(list);
	}
}
public class TwoOriginOneBallNonSymmetrical : BaseBallCombo
{
	public TwoOriginOneBallNonSymmetrical()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
		isTwoWayCombo = true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 3, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		int baseIndex = originDirection.baseIndex;
		int twoWayAnotherIndex = originDirection.twoWayAnotherIndex;
		for (int i = 3; i < 5; i++)
		{
			for (int j = 1; j < 5; j++)
			{
				for (int k = 1; k < 3; k++)
				{
					for (int l = 1; l < 5; l++)
					{
						initBalls(newBall(GeneratorLaw.BallType.LeftBall, i, j, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.RightBall, k, l, GeneratorLaw.BallDirection.All, twoWayAnotherIndex));
					}
				}
			}
		}
	}
}
public class TwoOriginOneBallSymmetrical : BaseBallCombo
{
	public TwoOriginOneBallSymmetrical()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
		isTwoWayCombo = true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 6, 
			4 => 2, 
			5 => 0, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		int baseIndex = originDirection.baseIndex;
		int twoWayAnotherIndex = originDirection.twoWayAnotherIndex;
		for (int i = 3; i < 5; i++)
		{
			for (int j = 1; j < 5; j++)
			{
				initBalls(newBall(GeneratorLaw.BallType.LeftBall, i, j, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.RightBall, i - 2, j, GeneratorLaw.BallDirection.All, twoWayAnotherIndex));
			}
		}
	}
}
public class TwoOriginOneTwoBallNonSymmetrical : BaseBallCombo
{
	public TwoOriginOneTwoBallNonSymmetrical()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
		isTwoWayCombo = true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 2, 
			5 => 4, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		int baseIndex = originDirection.baseIndex;
		int twoWayAnotherIndex = originDirection.twoWayAnotherIndex;
		List<TwoOriginTwoBall> twoOriginTwoBallLeftList = getTwoOriginTwoBallLeftList();
		List<TwoOriginTwoBall> twoOriginTwoBallRightList = getTwoOriginTwoBallRightList();
		for (int i = 0; i < twoOriginTwoBallLeftList.Count; i++)
		{
			TwoOriginTwoBall twoOriginTwoBall = twoOriginTwoBallLeftList[i];
			for (int j = 1; j < 3; j++)
			{
				for (int k = 1; k < 5; k++)
				{
					initBalls(newBall(GeneratorLaw.BallType.LeftBall, twoOriginTwoBall.x1, twoOriginTwoBall.z1, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.LeftBall, twoOriginTwoBall.x2, twoOriginTwoBall.z2, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.RightBall, j, k, GeneratorLaw.BallDirection.All, twoWayAnotherIndex));
				}
			}
		}
		for (int l = 0; l < twoOriginTwoBallRightList.Count; l++)
		{
			TwoOriginTwoBall twoOriginTwoBall2 = twoOriginTwoBallRightList[l];
			for (int m = 3; m < 5; m++)
			{
				for (int n = 1; n < 5; n++)
				{
					initBalls(newBall(GeneratorLaw.BallType.LeftBall, m, n, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.RightBall, twoOriginTwoBall2.x1, twoOriginTwoBall2.z1, GeneratorLaw.BallDirection.All, twoWayAnotherIndex), newBall(GeneratorLaw.BallType.RightBall, twoOriginTwoBall2.x2, twoOriginTwoBall2.z2, GeneratorLaw.BallDirection.All, twoWayAnotherIndex));
				}
			}
		}
	}
}
public class TwoOriginTwoBalNonlSymmetrical : BaseBallCombo
{
	public TwoOriginTwoBalNonlSymmetrical()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
		isTwoWayCombo = true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 0, 
			4 => 2, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		int baseIndex = originDirection.baseIndex;
		int twoWayAnotherIndex = originDirection.twoWayAnotherIndex;
		List<TwoOriginTwoBall> twoOriginTwoBallLeftList = getTwoOriginTwoBallLeftList();
		List<TwoOriginTwoBall> twoOriginTwoBallRightList = getTwoOriginTwoBallRightList();
		for (int i = 0; i < twoOriginTwoBallLeftList.Count; i++)
		{
			TwoOriginTwoBall twoOriginTwoBall = twoOriginTwoBallLeftList[i];
			for (int j = 0; j < twoOriginTwoBallLeftList.Count; j++)
			{
				TwoOriginTwoBall twoOriginTwoBall2 = twoOriginTwoBallRightList[j];
				initBalls(newBall(GeneratorLaw.BallType.LeftBall, twoOriginTwoBall.x1, twoOriginTwoBall.z1, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.LeftBall, twoOriginTwoBall.x2, twoOriginTwoBall.z2, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.RightBall, twoOriginTwoBall2.x1, twoOriginTwoBall2.z1, GeneratorLaw.BallDirection.All, twoWayAnotherIndex), newBall(GeneratorLaw.BallType.RightBall, twoOriginTwoBall2.x2, twoOriginTwoBall2.z2, GeneratorLaw.BallDirection.All, twoWayAnotherIndex));
			}
		}
	}
}
public class TwoOriginTwoBallSymmetrical : BaseBallCombo
{
	public TwoOriginTwoBallSymmetrical()
	{
		list = new List<List<GeneratorLaw.BallInfo>>();
		isTwoWayCombo = true;
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 1, 
			4 => 4, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		int baseIndex = originDirection.baseIndex;
		int twoWayAnotherIndex = originDirection.twoWayAnotherIndex;
		List<TwoOriginTwoBall> twoOriginTwoBallLeftList = getTwoOriginTwoBallLeftList();
		List<TwoOriginTwoBall> twoOriginTwoBallRightList = getTwoOriginTwoBallRightList();
		for (int i = 0; i < twoOriginTwoBallLeftList.Count; i++)
		{
			TwoOriginTwoBall twoOriginTwoBall = twoOriginTwoBallLeftList[i];
			TwoOriginTwoBall twoOriginTwoBall2 = twoOriginTwoBallRightList[i];
			initBalls(newBall(GeneratorLaw.BallType.LeftBall, twoOriginTwoBall.x1, twoOriginTwoBall.z1, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.LeftBall, twoOriginTwoBall.x2, twoOriginTwoBall.z2, GeneratorLaw.BallDirection.All, baseIndex), newBall(GeneratorLaw.BallType.RightBall, twoOriginTwoBall2.x1, twoOriginTwoBall2.z1, GeneratorLaw.BallDirection.All, twoWayAnotherIndex), newBall(GeneratorLaw.BallType.RightBall, twoOriginTwoBall2.x2, twoOriginTwoBall2.z2, GeneratorLaw.BallDirection.All, twoWayAnotherIndex));
		}
	}
}
public class Circle : BaseBallCombo
{
	public Circle()
	{
		multiplTimeIndexList = new List<List<List<GeneratorLaw.BallInfo>>>();
	}

	public override int GetWeightByLevel(int level)
	{
		return level switch
		{
			1 => 0, 
			2 => 0, 
			3 => 1, 
			4 => 4, 
			5 => 2, 
			_ => 0, 
		};
	}

	public override void listInit(int lastDirectionIndex)
	{
		multiplTimeIndexList.Add(ShunShiZhenFromBottom(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromBottom(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromLeft(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromLeft(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromTop(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromTop(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromRight(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(ShunShiZhenFromRight(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromBottom(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromBottom(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromLeft(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromLeft(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromTop(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromTop(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromRight(GeneratorLaw.BallType.LeftBall, lastDirectionIndex));
		multiplTimeIndexList.Add(NiShiZhenFromRight(GeneratorLaw.BallType.RightBall, lastDirectionIndex));
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromRight(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromTop(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromLeft(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> NiShiZhenFromBottom(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromRight(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromTop(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromLeft(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private List<List<GeneratorLaw.BallInfo>> ShunShiZhenFromBottom(GeneratorLaw.BallType ballType, int lastDirectionIndex)
	{
		List<List<GeneratorLaw.BallInfo>> list = new List<List<GeneratorLaw.BallInfo>>();
		AddOneBallFrameToMultiple(list, ballType, 2, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 1, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 2, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 4, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 3, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 4, 2, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		AddOneBallFrameToMultiple(list, ballType, 3, 1, GeneratorLaw.BallDirection.All, lastDirectionIndex);
		return list;
	}

	private void AddOneBallFrameToMultiple(List<List<GeneratorLaw.BallInfo>> multiplTimeIndexBallInfos, GeneratorLaw.BallType ballType, int x, int z, GeneratorLaw.BallDirection ballDirection, int lastDirectionIndex)
	{
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		list.Add(newBall(ballType, x, z, ballDirection, lastDirectionIndex));
		multiplTimeIndexBallInfos.Add(list);
	}
}
public class BallComboContainer
{
	public static List<BaseBallCombo> ballComboList;

	public static void InitBallComboContainer()
	{
		ballComboList = new List<BaseBallCombo>();
		ballComboList.Add(new SingleBall());
		ballComboList.Add(new TwoBallOneHand());
		ballComboList.Add(new OneBallTwoHandPosMinDis());
		ballComboList.Add(new OneBallTwoHandPosMaxDis());
		ballComboList.Add(new OneBallTwoHandTangle());
		ballComboList.Add(new OneBallTwoHandNegMinDis());
		ballComboList.Add(new OneBallTwoHandNegMaxDis());
		ballComboList.Add(new TwoBallTwoHand());
		ballComboList.Add(new ThreeBallOneHand());
		ballComboList.Add(new ThreeBallTwoHand());
		ballComboList.Add(new SingleBallBlack());
		ballComboList.Add(new OneBallTwoHandBlack());
		ballComboList.Add(new TwoBallBlackHard());
		ballComboList.Add(new ThreeBallBlackHard());
		ballComboList.Add(new OneballHardConflict());
		ballComboList.Add(new OneBallTwoHandHaordConfilct());
		ballComboList.Add(new TwoBallHardConflict());
		ballComboList.Add(new TwoBallNoBlackConflict());
		ballComboList.Add(new TwoBallTwoHandConflict());
		ballComboList.Add(new QuickHardMinDis());
		ballComboList.Add(new QuickHardMaxDis());
		ballComboList.Add(new QuickHardTwoHand());
		ballComboList.Add(new Circle());
		ballComboList.Add(new TwoOriginOneBallSymmetrical());
		ballComboList.Add(new TwoOriginOneBallNonSymmetrical());
		ballComboList.Add(new TwoOriginTwoBallSymmetrical());
		ballComboList.Add(new TwoOriginTwoBalNonlSymmetrical());
		ballComboList.Add(new TwoOriginOneTwoBallNonSymmetrical());
		ballComboList.Add(new TwoOriginOneBallCircle());
	}

	public static BaseBallCombo GetBaseBallCombo(GeneratorLaw.BeatInfo beatInfo, GenGateInfo.OriginDirection originDirection)
	{
		List<BaseBallCombo> filterList = GetFilterList(beatInfo, originDirection);
		List<int> list = new List<int>();
		for (int i = 0; i < filterList.Count; i++)
		{
			int weightByLevel = filterList[i].GetWeightByLevel(UnitySingleton<DataCenter>.Instance.generateParameter.ballComboLevel);
			for (int j = 0; j < weightByLevel; j++)
			{
				list.Add(i);
			}
		}
		int index = Mathf.FloorToInt(UnityEngine.Random.Range(0f, (float)list.Count - 0.001f));
		int index2 = list[index];
		return filterList[index2];
	}

	private static bool checkRightWay(GeneratorLaw.BeatInfo beatInfo, BaseBallCombo baseBallCombo, GenGateInfo.OriginDirection originDirection)
	{
		if (originDirection.originSourceMode == GenGateInfo.OriginSourceMode.Single && !baseBallCombo.isTwoWayCombo)
		{
			return true;
		}
		if (originDirection.originSourceMode != 0 && baseBallCombo.isTwoWayCombo)
		{
			return true;
		}
		return false;
	}

	internal static void randomGenerateBallCombo(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorDic, GenGateInfo.OriginDirection originDirection)
	{
		_ = UnitySingleton<DataCenter>.Instance.generateParameter;
		GetBaseBallCombo(beatInfo, originDirection).PutBallInfList(beatInfo, generatorDic, originDirection);
	}

	private static void testGenerate(GeneratorLaw.BeatInfo beatInfo, Dictionary<int, List<GeneratorLaw.BallInfo>> generatorDic)
	{
		int x = Mathf.FloorToInt(UnityEngine.Random.Range(1f, 4.999f));
		int y = Mathf.FloorToInt(UnityEngine.Random.Range(1f, 4.999f));
		Mathf.FloorToInt(UnityEngine.Random.Range(1f, 3.999f));
		List<GeneratorLaw.BallInfo> list = new List<GeneratorLaw.BallInfo>();
		GeneratorLaw.BallInfo ballInfo = new GeneratorLaw.BallInfo();
		ballInfo.dingWeiIndex = 1;
		ballInfo.targetIndex = new Vector2Int(x, y);
		ballInfo.ballType = GeneratorLaw.GetRandomBallType();
		ballInfo.ballDirection = GeneratorLaw.GetRandomBallDirection();
		list.Add(ballInfo);
		generatorDic.Add(beatInfo.timeIndex, list);
	}

	private static List<BaseBallCombo> GetFilterList(GeneratorLaw.BeatInfo beatInfo, GenGateInfo.OriginDirection originDirection)
	{
		List<BaseBallCombo> list = new List<BaseBallCombo>();
		for (int i = 0; i < ballComboList.Count; i++)
		{
			GenerateParameter generateParameter = UnitySingleton<DataCenter>.Instance.generateParameter;
			BaseBallCombo baseBallCombo = ballComboList[i];
			if (baseBallCombo.SupportedAngleTypes().Contains(generateParameter.angleType) && baseBallCombo.GetWeightByLevel(generateParameter.ballComboLevel) != 0 && (generateParameter.haveBlackCube || !baseBallCombo.IsHaveBlack()) && checkRightWay(beatInfo, baseBallCombo, originDirection))
			{
				list.Add(baseBallCombo);
			}
		}
		return list;
	}
}
public class BallGenerator : MonoBehaviour
{
	public GameObject Ball;

	public GameObject Wall;

	public GameObject BsWall;

	private GeneratorLaw generatorLaw;

	private bool isMusic;

	private MainPlayControl mainPlayControl;

	private void Start()
	{
		mainPlayControl = GetComponent<MainPlayControl>();
		isMusic = false;
		generatorLaw = UnitySingleton<DataCenter>.Instance.generatorLaw;
	}

	public void reStart()
	{
		mainPlayControl.timeIndex = MainPlayControl.timeIndexStart;
		mainPlayControl.thisTime = 0f;
		isMusic = false;
		UnitySingleton<DataCenter>.Instance.reStart();
	}

	private void Update()
	{
	}

	public void GenerateUpdate()
	{
		PressUtils.PressTestRestart();
		generatorLaw = UnitySingleton<DataCenter>.Instance.generatorLaw;
		if (!isMusic && mainPlayControl.timeIndex >= -generatorLaw.minIndex)
		{
			UnityEngine.Debug.Log("music start:" + mainPlayControl.timeIndex);
			isMusic = true;
			UnitySingleton<AudioManager>.Instance.PlayMainMusic("mainPlay");
		}
		if (UnitySingleton<DataCenter>.Instance.isGameOver)
		{
			UnitySingleton<AudioManager>.Instance.StopPlayMusic(generatorLaw.musicName);
			return;
		}
		if (mainPlayControl.timeIndex > generatorLaw.totalTimeUnits - generatorLaw.minIndex)
		{
			UnitySingleton<DataCenter>.Instance.gameDone();
			return;
		}
		List<GeneratorLaw.BallInfo> value;
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			value = UnitySingleton<DataCenter>.Instance.bsMusicManager.getBallInfoList(mainPlayControl.timeIndex);
		}
		else
		{
			generatorLaw.generatorDicAfterTimeReset.TryGetValue(mainPlayControl.timeIndex, out value);
		}
		if (value != null)
		{
			foreach (GeneratorLaw.BallInfo item in value)
			{
				generateOneBall(item);
			}
		}
		if (!UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			generatorLaw.generatorBeatWallDicAfterTimeReset.TryGetValue(mainPlayControl.timeIndex, out var value2);
			if (value2 != null)
			{
				generateOneWall(value2);
			}
			return;
		}
		List<BsWallInfo> bsObstaclesList = UnitySingleton<DataCenter>.Instance.bsMusicManager.getBsObstaclesList(mainPlayControl.timeIndex);
		if (bsObstaclesList == null)
		{
			return;
		}
		foreach (BsWallInfo item2 in bsObstaclesList)
		{
			generateBsWall(item2);
		}
	}

	private void generateOneBall(GeneratorLaw.BallInfo ballInfo)
	{
		DingWeiInfo value;
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			BallPosConstantInfo.posDicBs.TryGetValue(ballInfo.dingWeiIndex, out value);
		}
		else
		{
			BallPosConstantInfo.posDic.TryGetValue(ballInfo.dingWeiIndex, out value);
		}
		value.originIndexMap.TryGetValue(ballInfo.targetIndex, out var value2);
		value.targetIndexMap.TryGetValue(ballInfo.targetIndex, out var value3);
		UnityEngine.Vector3 hitTarget = UnityEngine.Vector3.zero;
		BallFlyPos ballFlyPos = null;
		if (value3.Equals(UnityEngine.Vector3.zero))
		{
			return;
		}
		float yRoatateByDirection = GeneratorLaw.GetYRoatateByDirection(ballInfo.dingWeiIndex);
		float z = GeneratorLaw.GetZRoatateByDirection(ballInfo.ballDirection, ballInfo.ballType);
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			value2 = UnitySingleton<DataCenter>.Instance.bsMusicManager.GetBsBallOrPos(ballInfo);
			value3 = UnitySingleton<DataCenter>.Instance.bsMusicManager.GetBsBallTargetPos(ballInfo);
			hitTarget = UnitySingleton<DataCenter>.Instance.bsMusicManager.GetBsBallHitPos(ballInfo);
			ballFlyPos = UnitySingleton<DataCenter>.Instance.bsMusicManager.GetBsBallFlyPos(ballInfo);
			if (UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.flyDongHua == 1)
			{
				value2 = ballFlyPos.originPos;
				z = ballFlyPos.originZRotation;
			}
		}
		GameObject obj = UnityEngine.Object.Instantiate(Ball, value2, UnityEngine.Quaternion.Euler(0f, yRoatateByDirection, z));
		obj.GetComponent<Ball>().setBallMat(ballInfo.ballDirection, ballInfo.ballType);
		obj.GetComponent<Ball>().ballInfo = ballInfo;
		obj.GetComponent<Ball>().Fly(value3, UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed);
		obj.GetComponent<Ball>().hitTarget = hitTarget;
		obj.GetComponent<Ball>().ballFlyPos = ballFlyPos;
		obj.GetComponent<Ball>().mainPlayControl = mainPlayControl;
	}

	private void generateOneWall(WallInfo wallInfo)
	{
		WallPosConstantInfo.posDic.TryGetValue(wallInfo.dingWeiIndex, out var value);
		UnityEngine.Vector3 originPos = value.originPos;
		UnityEngine.Vector3 targetPos = value.targetPos;
		float yRoatateByDirection = GeneratorLaw.GetYRoatateByDirection(wallInfo.dingWeiIndex);
		GameObject obj = UnityEngine.Object.Instantiate(Wall, originPos, UnityEngine.Quaternion.Euler(0f, yRoatateByDirection, 0f));
		obj.GetComponent<Wall>().initWall(wallInfo, targetPos, UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed);
		obj.GetComponent<Wall>().mainPlayControl = mainPlayControl;
	}

	private void generateBsWall(BsWallInfo bsWallInfo)
	{
		GameObject obj = UnityEngine.Object.Instantiate(BsWall, bsWallInfo.originPos, UnityEngine.Quaternion.Euler(0f, 0f, 0f));
		obj.GetComponent<BsWall>().initWall(bsWallInfo, UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed);
		obj.GetComponent<BsWall>().mainPlayControl = mainPlayControl;
	}
}
public class BallPosConstantInfo
{
	public static string fileName = "posData";

	public static string fileNameBs = "posDataBs";

	public static bool isForBs = true;

	public static Dictionary<int, DingWeiInfo> posDic = new Dictionary<int, DingWeiInfo>();

	public static Dictionary<int, DingWeiInfoForSave> posDicForSave = new Dictionary<int, DingWeiInfoForSave>();

	public static Dictionary<int, DingWeiInfo> posDicBs = new Dictionary<int, DingWeiInfo>();

	public static Dictionary<int, DingWeiInfoForSave> posDicForSaveBs = new Dictionary<int, DingWeiInfoForSave>();

	public static BallPosInfo GetBallPostInfo(int startIndex, int xIndex, int zIndex)
	{
		BallPosInfo ballPosInfo = new BallPosInfo();
		posDic.TryGetValue(startIndex, out var value);
		ballPosInfo.StartPos = value.pos;
		Vector2Int key = new Vector2Int(xIndex, zIndex);
		value.targetIndexMap.TryGetValue(key, out var value2);
		ballPosInfo.TargetPos = value2;
		return ballPosInfo;
	}

	public static void LoadFromFile()
	{
		posDicForSave = JsonConvert.DeserializeObject<Dictionary<int, DingWeiInfoForSave>>(JsonRead(fileName));
		posDicForSaveBs = JsonConvert.DeserializeObject<Dictionary<int, DingWeiInfoForSave>>(JsonRead(fileNameBs));
	}

	public static string JsonRead(string name)
	{
		string text = "";
		TextAsset obj = (TextAsset)Resources.Load(name);
		UnityEngine.Debug.Log("file name:" + name);
		text = obj.text;
		if (string.IsNullOrEmpty(text))
		{
			return null;
		}
		return text;
	}

	internal static string printAll(int total)
	{
		string text = "";
		for (int i = 1; i <= total; i++)
		{
			posDic.TryGetValue(i, out var value);
			text += value.printStr();
		}
		UnityEngine.Debug.Log(text);
		return text;
	}

	public static void loadPosDicForSaveToPosDic()
	{
		LoadFromFile();
		posDic.Clear();
		foreach (KeyValuePair<int, DingWeiInfoForSave> item in posDicForSave)
		{
			DingWeiInfo normal = item.Value.getNormal();
			posDic.Add(item.Key, normal);
		}
		posDicBs.Clear();
		foreach (KeyValuePair<int, DingWeiInfoForSave> posDicForSaveB in posDicForSaveBs)
		{
			DingWeiInfo normal2 = posDicForSaveB.Value.getNormal();
			posDicBs.Add(posDicForSaveB.Key, normal2);
		}
	}

	public static void loadPosDicToPosDicForSave()
	{
		posDicForSave.Clear();
		foreach (KeyValuePair<int, DingWeiInfo> item in posDic)
		{
			DingWeiInfoForSave forSave = item.Value.getForSave();
			posDicForSave.Add(item.Key, forSave);
		}
	}
}
public class BallPosInfo
{
	public UnityEngine.Vector3 StartPos { get; set; }

	public UnityEngine.Vector3 TargetPos { get; set; }

	public float EndTime { get; set; }

	public float StartTime { get; set; }

	public void initStartTimeByEndTimeAndPos(float speed)
	{
	}
}
public class DingWeiInfo
{
	public int index { get; set; }

	public UnityEngine.Vector3 pos { get; set; }

	public Dictionary<Vector2Int, UnityEngine.Vector3> targetIndexMap { get; set; }

	public Dictionary<Vector2Int, UnityEngine.Vector3> originIndexMap { get; set; }

	public string printStr()
	{
		string text = "index:" + index + "\n";
		text = string.Concat(text, "pos:", pos, "\n");
		foreach (KeyValuePair<Vector2Int, UnityEngine.Vector3> item in targetIndexMap)
		{
			text = string.Concat(text, "target index:", item.Key, "; targetPos:", item.Value, "\n");
		}
		return text;
	}

	public DingWeiInfoForSave getForSave()
	{
		DingWeiInfoForSave dingWeiInfoForSave = new DingWeiInfoForSave();
		dingWeiInfoForSave.index = index;
		dingWeiInfoForSave.pos = pos.x + "_" + pos.y + "_" + pos.z;
		dingWeiInfoForSave.targetIndexMap = new Dictionary<string, string>();
		foreach (KeyValuePair<Vector2Int, UnityEngine.Vector3> item in targetIndexMap)
		{
			string key = item.Key.x + "_" + item.Key.y;
			string value = item.Value.x + "_" + item.Value.y + "_" + item.Value.z;
			dingWeiInfoForSave.targetIndexMap.Add(key, value);
		}
		dingWeiInfoForSave.originIndexMap = new Dictionary<string, string>();
		foreach (KeyValuePair<Vector2Int, UnityEngine.Vector3> item2 in originIndexMap)
		{
			string key2 = item2.Key.x + "_" + item2.Key.y;
			string value2 = item2.Value.x + "_" + item2.Value.y + "_" + item2.Value.z;
			dingWeiInfoForSave.originIndexMap.Add(key2, value2);
		}
		return dingWeiInfoForSave;
	}
}
public class PosCal : MonoBehaviour
{
	public GameObject cube;

	public GameObject plane;

	public GameObject planeOrigin;

	public DingWeiInfo dingWeiInfo;

	public void initDingWeiInfo(int index)
	{
		int num = 4;
		float num2 = 0.4f;
		float num3 = -0.6f;
		float num4 = -0.6f;
		dingWeiInfo = new DingWeiInfo();
		dingWeiInfo.index = index;
		dingWeiInfo.pos = cube.transform.position;
		dingWeiInfo.targetIndexMap = new Dictionary<Vector2Int, UnityEngine.Vector3>();
		for (int i = 1; i <= 4; i++)
		{
			for (int j = 1; j <= num; j++)
			{
				Vector2Int vector2Int = new Vector2Int(i, j);
				GameObject gameObject = UnityEngine.Object.Instantiate(cube, plane.transform);
				float x = num3 + num2 * (float)(i - 1);
				float z = num4 + num2 * (float)(j - 1);
				UnityEngine.Vector3 localPosition = new UnityEngine.Vector3(x, 0f, z);
				gameObject.transform.localPosition = localPosition;
				dingWeiInfo.targetIndexMap.Add(vector2Int, gameObject.transform.position);
				UnityEngine.Debug.Log(string.Concat("xz:", vector2Int, "; position:", gameObject.transform.position));
			}
		}
		dingWeiInfo.originIndexMap = new Dictionary<Vector2Int, UnityEngine.Vector3>();
		for (int k = 1; k <= 4; k++)
		{
			for (int l = 1; l <= num; l++)
			{
				Vector2Int key = new Vector2Int(k, l);
				GameObject gameObject2 = UnityEngine.Object.Instantiate(cube, planeOrigin.transform);
				float x2 = num3 + num2 * (float)(k - 1);
				float z2 = num4 + num2 * (float)(l - 1);
				UnityEngine.Vector3 localPosition2 = new UnityEngine.Vector3(x2, 0f, z2);
				gameObject2.transform.localPosition = localPosition2;
				dingWeiInfo.originIndexMap.Add(key, gameObject2.transform.position);
			}
		}
	}
}
public class PosCalTotal : MonoBehaviour
{
	public PosCal posCal1;

	public PosCal posCal2;

	public PosCal posCal3;

	public PosCal posCal4;

	public PosCal posCal5;

	public PosCal posCal6;

	private void Start()
	{
		posCal1.initDingWeiInfo(1);
		BallPosConstantInfo.posDic.Add(1, posCal1.dingWeiInfo);
		posCal2.initDingWeiInfo(2);
		BallPosConstantInfo.posDic.Add(2, posCal2.dingWeiInfo);
		posCal3.initDingWeiInfo(3);
		BallPosConstantInfo.posDic.Add(3, posCal3.dingWeiInfo);
		posCal4.initDingWeiInfo(4);
		BallPosConstantInfo.posDic.Add(4, posCal4.dingWeiInfo);
		posCal5.initDingWeiInfo(5);
		BallPosConstantInfo.posDic.Add(5, posCal5.dingWeiInfo);
		posCal6.initDingWeiInfo(6);
		BallPosConstantInfo.posDic.Add(6, posCal6.dingWeiInfo);
		MonoBehaviour.print(BallPosConstantInfo.printAll(1));
		string fileName = Path.Combine(Application.persistentDataPath, BallPosConstantInfo.isForBs ? BallPosConstantInfo.fileNameBs : (BallPosConstantInfo.fileName + ".txt"));
		BallPosConstantInfo.loadPosDicToPosDicForSave();
		SaveFile(fileName, JsonConvert.SerializeObject(BallPosConstantInfo.posDicForSave));
	}

	public static void SaveFile(string fileName, string content)
	{
		if (!File.Exists(fileName))
		{
			File.Create(fileName).Close();
		}
		File.WriteAllText(fileName, content);
	}

	private void Update()
	{
	}
}
public class DingWeiInfoForSave
{
	public int index { get; set; }

	public string pos { get; set; }

	public Dictionary<string, string> targetIndexMap { get; set; }

	public Dictionary<string, string> originIndexMap { get; set; }

	public string printStr()
	{
		string text = "index:" + index + "\n";
		text = text + "pos:" + pos + "\n";
		foreach (KeyValuePair<string, string> item in targetIndexMap)
		{
			text = text + "target index:" + item.Key + "; targetPos:" + item.Value + "\n";
		}
		return text;
	}

	internal DingWeiInfo getNormal()
	{
		DingWeiInfo dingWeiInfo = new DingWeiInfo();
		dingWeiInfo.index = index;
		string[] array = pos.Split('_');
		dingWeiInfo.pos = new UnityEngine.Vector3(Convert.ToSingle(array[0]), Convert.ToSingle(array[1]), Convert.ToSingle(array[2]));
		dingWeiInfo.targetIndexMap = new Dictionary<Vector2Int, UnityEngine.Vector3>();
		foreach (KeyValuePair<string, string> item in targetIndexMap)
		{
			string[] array2 = item.Key.Split('_');
			Vector2Int key = new Vector2Int(Convert.ToInt32(array2[0]), Convert.ToInt32(array2[1]));
			string[] array3 = item.Value.Split('_');
			UnityEngine.Vector3 value = new UnityEngine.Vector3(Convert.ToSingle(array3[0]), Convert.ToSingle(array3[1]), Convert.ToSingle(array3[2]));
			dingWeiInfo.targetIndexMap.Add(key, value);
		}
		dingWeiInfo.originIndexMap = new Dictionary<Vector2Int, UnityEngine.Vector3>();
		foreach (KeyValuePair<string, string> item2 in originIndexMap)
		{
			string[] array4 = item2.Key.Split('_');
			Vector2Int key2 = new Vector2Int(Convert.ToInt32(array4[0]), Convert.ToInt32(array4[1]));
			string[] array5 = item2.Value.Split('_');
			UnityEngine.Vector3 value2 = new UnityEngine.Vector3(Convert.ToSingle(array5[0]), Convert.ToSingle(array5[1]), Convert.ToSingle(array5[2]));
			dingWeiInfo.originIndexMap.Add(key2, value2);
		}
		return dingWeiInfo;
	}
}
public class GeneratorLaw
{
	public class BallInfo
	{
		public int dingWeiIndex { get; set; }

		public Vector2Int targetIndex { get; set; }

		public BallType ballType { get; set; }

		public BallDirection ballDirection { get; set; }

		public int bsTimeHitTimeIndex { get; set; }

		public bool isQSBall()
		{
			if (ballDirection == BallDirection.DownLeft || ballDirection == BallDirection.DownRight || ballDirection == BallDirection.UpLeft || ballDirection == BallDirection.UpRight)
			{
				return true;
			}
			return false;
		}

		public BallInfo getCopy()
		{
			return new BallInfo
			{
				dingWeiIndex = dingWeiIndex,
				targetIndex = new Vector2Int(targetIndex.x, targetIndex.y),
				ballType = ballType,
				ballDirection = ballDirection,
				bsTimeHitTimeIndex = bsTimeHitTimeIndex
			};
		}
	}

	public class BeatInfo
	{
		public bool isPeak { get; set; }

		public float spectralFlux { get; set; }

		public SpectralFluxInfo spectralFluxInfo { get; set; }

		public float fluxThreadRatio { get; set; }

		public List<BeatInfo> comboBeatInflList { get; set; }

		public float beatScore { get; set; }

		public int timeIndex { get; set; }

		public int prevBeatIndex { get; set; }

		public int nextBeatIndex { get; set; }

		public int totalDistance { get; set; }
	}

	public enum BallType
	{
		LeftBall,
		RightBall,
		BlackBall
	}

	public enum BallDirection
	{
		Up,
		Down,
		Left,
		Right,
		UpLeft,
		UpRight,
		DownLeft,
		DownRight,
		All
	}

	public Dictionary<int, List<BallInfo>> generatorDic;

	public Dictionary<int, List<BallInfo>> generatorDicAfterTimeReset;

	public Dictionary<int, BeatInfo> generatorBeatDic;

	public Dictionary<int, BeatInfo> generatorBeatDicWithCombAndScore;

	public Dictionary<int, List<int>> generatorBeatGateSparkDic;

	public Dictionary<int, GenGateInfo.OriginChangeShow> generatorBeatOriginChangeDic;

	public Dictionary<int, WallInfo> generatorBeatWallDic;

	public Dictionary<int, WallInfo> generatorBeatWallDicAfterTimeReset;

	public string musicName;

	public float beatGenThreshold;

	public int indexToStart;

	public int totalTimeUnits { get; set; }

	public int minIndex { get; set; }

	public static BallDirection GetRandomBallDirection()
	{
		return Mathf.FloorToInt(UnityEngine.Random.Range(1f, 9.999f)) switch
		{
			1 => BallDirection.Up, 
			2 => BallDirection.Down, 
			3 => BallDirection.Left, 
			4 => BallDirection.Right, 
			5 => BallDirection.UpLeft, 
			6 => BallDirection.UpRight, 
			7 => BallDirection.DownLeft, 
			8 => BallDirection.DownRight, 
			_ => BallDirection.All, 
		};
	}

	public static float GetZRoatateByDirection(BallDirection direction, BallType ballType)
	{
		if (direction == BallDirection.All || ballType == BallType.BlackBall)
		{
			return 0f;
		}
		return direction switch
		{
			BallDirection.Up => 180f, 
			BallDirection.Left => 270f, 
			BallDirection.Right => 90f, 
			BallDirection.UpLeft => 225f, 
			BallDirection.UpRight => 135f, 
			BallDirection.DownLeft => 315f, 
			BallDirection.DownRight => 45f, 
			_ => 0f, 
		};
	}

	internal static float GetYRoatateByDirection(int dingWeiIndex)
	{
		return dingWeiIndex switch
		{
			1 => 0f, 
			2 => 60f, 
			3 => 120f, 
			4 => 180f, 
			5 => 240f, 
			6 => 300f, 
			_ => 0f, 
		};
	}

	internal static BallType GetRandomBallType()
	{
		return Mathf.FloorToInt(UnityEngine.Random.Range(1f, 3.999f)) switch
		{
			1 => BallType.LeftBall, 
			2 => BallType.RightBall, 
			_ => BallType.BlackBall, 
		};
	}

	public static GenGateInfo.OriginChangeShow GetOriginChangeShow(GenGateInfo.OriginDirection originDirection)
	{
		bool flag = ((originDirection.originSourceMode != 0) ? true : false);
		int oldbaseIndex = originDirection.oldbaseIndex;
		int baseIndex = originDirection.baseIndex;
		GenGateInfo.OriginChangeShow originChangeShow = new GenGateInfo.OriginChangeShow();
		originChangeShow.orIndex = oldbaseIndex;
		originChangeShow.toIndex = baseIndex;
		originChangeShow.mutual = flag;
		if (flag)
		{
			originChangeShow.toIndex = originDirection.twoWayAnotherIndex;
			originChangeShow.originChangeType = GetOriginChangeType(oldbaseIndex, originDirection.twoWayAnotherIndex);
			originChangeShow.originChangeTypeMutual = GetOriginChangeType(originDirection.twoWayAnotherIndex, oldbaseIndex);
		}
		else if (originDirection.twoWayBackToSingle)
		{
			originChangeShow.toIndex = originDirection.twoWayAnotherIndex;
			originChangeShow.twoWayBackToSingle = true;
			originChangeShow.twoWayBackToSingleOrIndex = originDirection.twoWayAnotherIndex;
			originChangeShow.originChangeTypeTwoWayBackToSingle = GetOriginChangeType(originDirection.twoWayAnotherIndex, oldbaseIndex);
		}
		else
		{
			if (oldbaseIndex == baseIndex)
			{
				return null;
			}
			originChangeShow.originChangeType = GetOriginChangeType(oldbaseIndex, baseIndex);
		}
		return originChangeShow;
	}

	private static GenGateInfo.OriginChangeType GetOriginChangeType(int orIndex, int toIndex)
	{
		int num = 3 - orIndex;
		int num2 = toIndex + num;
		if (num2 < 1)
		{
			num2 += 6;
		}
		else if (num2 > 6)
		{
			num2 -= 6;
		}
		return num2 switch
		{
			2 => GenGateInfo.OriginChangeType.LeftMin, 
			1 => GenGateInfo.OriginChangeType.Left, 
			4 => GenGateInfo.OriginChangeType.RightMin, 
			5 => GenGateInfo.OriginChangeType.Right, 
			_ => GenGateInfo.OriginChangeType.Back, 
		};
	}
}
public class V2Int
{
	public int x { get; set; }

	public int z { get; set; }
}
public class V3
{
	public float x { get; set; }

	public float y { get; set; }

	public float z { get; set; }
}
public class GradualBlack : UnitySingleton<GradualBlack>
{
	public Animator animator;

	public static GradualBlack instance;

	private GameObject Left;

	private GameObject Right;

	private GameObject Head;

	public bool playAll = true;

	public Action blackMidAction { get; set; }

	public Action blackEndAction { get; set; }

	private void Start()
	{
		instance = this;
		Left = base.transform.Find("MaskInfoLeft/black").gameObject;
		Right = base.transform.Find("MaskInfoRight/black").gameObject;
		Head = base.transform.Find("MaskInfoHead/black").gameObject;
		Left.SetActive(value: false);
		Right.SetActive(value: false);
		Head.SetActive(value: false);
	}

	public void PlayHurtAnimation()
	{
		animator.Play("gradualRed");
	}

	public void PlayNormal()
	{
		animator.Play("normal");
	}

	public void StartGradualBlack()
	{
		Left.SetActive(value: true);
		Right.SetActive(value: true);
		Head.SetActive(value: true);
		animator.Play("gradualBlack");
	}

	public void MidAction()
	{
		blackMidAction?.Invoke();
		if (playAll)
		{
			animator.Play("blackGradual");
		}
		else
		{
			playAll = true;
		}
	}

	public void sceneEntry()
	{
		Left.SetActive(value: true);
		Right.SetActive(value: true);
		Head.SetActive(value: true);
		animator.Play("blackGradual");
	}

	public void EndGradualBlack()
	{
		Left.SetActive(value: false);
		Right.SetActive(value: false);
		Head.SetActive(value: false);
		animator.Play("normal");
		blackEndAction?.Invoke();
		blackMidAction = null;
		blackEndAction = null;
	}
}
public class MainPlayControl : MonoBehaviour
{
	public Blade headBlade;

	public Blade leftBlade;

	public Blade rightBlade;

	private BallGenerator ballGenerator;

	public GameInfoBoard gameInfoBoard;

	public AudioSource audioSource;

	public bool isReadyToPlay;

	public bool loadPosDataFromFile = true;

	public bool ballSparking;

	public float ballSparkTime;

	public float ballSparkEndTime;

	public int timeIndex;

	public static int timeIndexStart = -1;

	public static int timeIndexPerSeconds = 40;

	public float thisTime;

	public bool pause;

	public GameObject PauseInfoPanel;

	public Transform Head;

	public int debugSceneIndex;

	public RoundHitManager roundHitManager;

	public STHitManager stHitManager;

	public static int vibrateTime = 100;

	public static float fixDelayTime = 2000f;

	private string BS_musicTest = "45ca (Pu tong Disco - sbtlo)";

	private void Start()
	{
		_ = loadPosDataFromFile;
		ballGenerator = GetComponent<BallGenerator>();
		gameInfoBoard = GetComponent<GameInfoBoard>();
		leftBlade.enter = HandEnter;
		rightBlade.enter = HandEnter;
		headBlade.enter = HandEnter;
		UnitySingleton<DataCenter>.Instance.GameOver = GameOver;
		UnitySingleton<DataCenter>.Instance.GameDone = GameDone;
		timeIndex = timeIndexStart;
		thisTime = 0f;
		if (UnitySingleton<DataCenter>.Instance.playClip != null)
		{
			audioSource.clip = UnitySingleton<DataCenter>.Instance.playClip;
		}
		else
		{
			UnitySingleton<DataCenter>.Instance.initLoad(loadMusic: false);
			if (BS_musicTest != null)
			{
				UnitySingleton<DataCenter>.Instance.bsMusicManager.selectedDifficultyName = "Normal";
				InfoDat infoDat = UnitySingleton<DataCenter>.Instance.bsMusicManager.loadBsMusicInfo(isInnerBs: true, BS_musicTest);
				if (infoDat == null)
				{
					UnityEngine.Debug.LogError("bsDebugLoad fail");
				}
				audioSource.clip = Resources.Load<AudioClip>(Path.Combine("playMusic", BS_musicTest, Path.GetFileNameWithoutExtension(infoDat._songFilename)));
				UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic = true;
			}
			UnitySingleton<DataCenter>.Instance.playClip = audioSource.clip;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.gateNum = 2;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.cubeFlySpeed = 2;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.comboLevel = 3;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.wallComboLevel = 2;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex = debugSceneIndex;
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.loadMyHitSound = 1;
			UnitySingleton<DataCenter>.Instance.initMusic(debugMode: true);
		}
		pause = false;
		PauseInfoPanel.SetActive(value: false);
		UnitySingleton<DataCenter>.Instance.returnFromGame = true;
		enableSaber();
	}

	private void Update()
	{
		if (UnitySingleton<DataCenter>.Instance.isGameOver)
		{
			return;
		}
		if (pause)
		{
			CheckPausePress();
		}
		else
		{
			if (!loadPosDataFromFile)
			{
				return;
			}
			if (PressUtils.PressPause())
			{
				pause = true;
				audioSource.Pause();
				ShowPausePanel();
				return;
			}
			_ = (double)Time.deltaTime;
			_ = 0.05;
			thisTime += Time.deltaTime;
			if (!(thisTime * (float)timeIndexPerSeconds < (float)(timeIndex + 1)))
			{
				timeIndex = Mathf.FloorToInt(thisTime * (float)timeIndexPerSeconds);
				gameInfoBoard.updateGameInfoBoard(timeIndex + UnitySingleton<DataCenter>.Instance.generatorLaw.minIndex);
				ballGenerator.GenerateUpdate();
			}
		}
	}

	private void enableSaber()
	{
		if (!(leftBlade == null) && !(rightBlade == null))
		{
			if (!leftBlade.gameObject.activeInHierarchy)
			{
				leftBlade.gameObject.SetActive(value: true);
			}
			if (!rightBlade.gameObject.activeInHierarchy)
			{
				rightBlade.gameObject.SetActive(value: true);
			}
		}
	}

	private void CheckPausePress()
	{
		if (PressUtils.PressLeftTrigger())
		{
			pause = false;
			PauseInfoPanel.SetActive(value: false);
			audioSource.Play();
		}
		else if (PressUtils.PressRightTrigger())
		{
			GradualBlack.instance.blackMidAction = delegate
			{
				SceneManager.LoadScene(0);
			};
			GradualBlack.instance.playAll = false;
			UnitySingleton<DataCenter>.Instance.isGameOver = true;
			UnitySingleton<DataCenter>.Instance.scoreRankDataManger.putNewData(success: false);
			GradualBlack.instance.StartGradualBlack();
		}
	}

	private void ShowPausePanel()
	{
		_ = Head.position;
		_ = Head.forward;
		PauseInfoPanel.SetActive(value: true);
	}

	public void HandEnter(GameObject gameObject, UnityEngine.Vector3 colliderPoint, Blade blade)
	{
		if (pause || UnitySingleton<DataCenter>.Instance.isGameOver)
		{
			return;
		}
		Ball component = gameObject.GetComponent<Ball>();
		if (!component.explosed)
		{
			UnityEngine.Plane plane = new UnityEngine.Plane(blade.endDetectPoint.position, blade.ThisTopDetectPoint, blade.lastTopDetectPoint);
			if (UnityEngine.Vector3.Magnitude(blade.ThisTopDetectPoint - blade.lastTopDetectPoint) < 0.0001f || (double)blade.waveDistancePerSecond < 0.3)
			{
				component.Explose(colliderPoint, blade, plane, validPlane: false);
			}
			else
			{
				component.Explose(colliderPoint, blade, plane);
			}
		}
	}

	public void GameOver()
	{
		UnitySingleton<AudioManager>.Instance.PlayMusicOnce("fail");
		GradualBlack.instance.blackMidAction = gameOverAction;
		GradualBlack.instance.playAll = true;
		GradualBlack.instance.StartGradualBlack();
	}

	private void gameOverAction()
	{
		SceneManager.LoadScene(0);
	}

	public void GameDone()
	{
		GradualBlack.instance.blackMidAction = gameDoneAction;
		GradualBlack.instance.playAll = true;
		GradualBlack.instance.StartGradualBlack();
	}

	public void stop()
	{
		audioSource.Stop();
	}

	private void gameDoneAction()
	{
		SceneManager.LoadScene(0);
	}
}
public class Bottom : MonoBehaviour
{
	public Button MusicSelect;

	public Button HipSetting;

	public Button ScoreRatting;

	public Button SceneSelect;

	public Button GameDes;

	public Button Quit;

	public Text debugInfo;

	public static Text debugInfoStatic;

	private Button CurrentSelected;

	private MainSelect mainSelect;

	private void Awake()
	{
		mainSelect = GetComponent<MainSelect>();
		MusicSelect.onClick.AddListener(delegate
		{
			BottomBtnClick(MainSelect.BtnSelect.MusicSelect, MusicSelect);
		});
		HipSetting.onClick.AddListener(delegate
		{
			BottomBtnClick(MainSelect.BtnSelect.HipSetting, HipSetting);
		});
		ScoreRatting.onClick.AddListener(delegate
		{
			BottomBtnClick(MainSelect.BtnSelect.ScoreRatting, ScoreRatting);
		});
		SceneSelect.onClick.AddListener(delegate
		{
			BottomBtnClick(MainSelect.BtnSelect.SceneSelect, SceneSelect);
		});
		GameDes.onClick.AddListener(delegate
		{
			BottomBtnClick(MainSelect.BtnSelect.GameDes, GameDes);
		});
		Quit.onClick.AddListener(delegate
		{
			QuitGyjz();
		});
		AudioSourceCommon.AttachPointEnterAudio(MusicSelect.transform);
		AudioSourceCommon.AttachPointEnterAudio(HipSetting.transform);
		AudioSourceCommon.AttachPointEnterAudio(ScoreRatting.transform);
		AudioSourceCommon.AttachPointEnterAudio(SceneSelect.transform);
		AudioSourceCommon.AttachPointEnterAudio(GameDes.transform);
		AudioSourceCommon.AttachPointEnterAudio(Quit.transform);
		debugInfoStatic = debugInfo;
	}

	public static void AddDebugInfo(string info, bool refresh = false)
	{
		string text = "";
		if (!refresh)
		{
			text = debugInfoStatic.text + "/n";
		}
		text += info;
		debugInfoStatic.text = text;
	}

	private void QuitGyjz()
	{
		GradualBlack.instance.blackMidAction = delegate
		{
			Application.Quit();
		};
		GradualBlack.instance.playAll = false;
		GradualBlack.instance.StartGradualBlack();
	}

	private void BottomBtnClick(MainSelect.BtnSelect btnSelect, Button btn)
	{
		if (!UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading)
		{
			if (CurrentSelected == btn)
			{
				SetUnSelected(btn);
				CurrentSelected = null;
				mainSelect.SwitchMainShow(MainSelect.BtnSelect.None);
			}
			else
			{
				SetSelected(btn);
				CurrentSelected = btn;
				mainSelect.SwitchMainShow(btnSelect);
			}
		}
	}

	private void SetSelected(Button btn)
	{
		SetUnSelected(MusicSelect);
		SetUnSelected(HipSetting);
		SetUnSelected(ScoreRatting);
		SetUnSelected(SceneSelect);
		SetUnSelected(GameDes);
		btn.transform.Find("selected").gameObject.SetActive(value: true);
	}

	private void SetUnSelected(Button btn)
	{
		btn.transform.Find("selected").gameObject.SetActive(value: false);
	}

	private void Update()
	{
	}
}
public class GameCompleteInfoManager : MonoBehaviour
{
	public GameObject titleSuccess;

	public GameObject titleFail;

	public Text musicName;

	public Text hipSettingLevel;

	public Text playTime;

	public Text averageSpeed;

	public Text chengjiu;

	public Text fastSpeed;

	public Text hitCubes;

	public Text hitCubesFail;

	public Text levelGet;

	public Text totalScore;

	public GameObject noConditionInfo;

	public void init()
	{
		GamePlayInfo gamePlayInfo = UnitySingleton<DataCenter>.Instance.gamePlayInfo;
		if (gamePlayInfo.gameSuccess)
		{
			titleSuccess.SetActive(value: true);
			titleFail.SetActive(value: false);
		}
		else
		{
			titleSuccess.SetActive(value: false);
			titleFail.SetActive(value: true);
		}
		musicName.text = "音乐名称：" + gamePlayInfo.playMusicName;
		hipSettingLevel.text = "难度系数：" + gamePlayInfo.hipSettingLevel;
		playTime.text = "挑战时长：" + gamePlayInfo.playTime;
		if (gamePlayInfo.hitNum == 0)
		{
			averageSpeed.text = "平均打击速度：0.0米/秒";
		}
		else
		{
			averageSpeed.text = "平均打击速度：" + (gamePlayInfo.totalhitSpeed / (float)gamePlayInfo.hitNum).ToString("f1") + "米/秒";
		}
		chengjiu.text = "获得成就：" + UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastGetChengJiuStr();
		fastSpeed.text = "最快打击速度：" + gamePlayInfo.fastHitSpeed.ToString("f1") + "米/秒";
		hitCubes.text = "打击成功方块数：" + gamePlayInfo.hitSuccessNum;
		hitCubesFail.text = "打击失败方块数：" + gamePlayInfo.hitFailNum;
		levelGet.text = "段位获得：" + UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastGetLevelStr();
		totalScore.text = "综合评分：" + UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastTotalSocre().ToString("f1");
		if (UnitySingleton<DataCenter>.Instance.scoreRankDataManger.getLastValidMusic())
		{
			noConditionInfo.SetActive(value: false);
		}
		else
		{
			noConditionInfo.SetActive(value: true);
		}
	}
}
public class GameDesManager : MonoBehaviour
{
	public Button GuanYuYouXiTitle;

	public Button YouXiWanFaTitle;

	public Button NanDuSheZhiTitle;

	public Button ZiDingYiYinYueTitle;

	public Button WoDeChengJiuTitle;

	public Button BeiJingQieHuanTitle;

	public GameObject GuanYuYouXi;

	public GameObject YouXiWanFa;

	public GameObject NanDuSheZhi;

	public GameObject ZiDingYiYinYue;

	public GameObject WoDeChengJiu;

	public GameObject BeiJingQieHuan;

	private Button selectedTitle;

	private Color selectedColor = new Color(1f, 1f, 1f);

	private Color unSelectedColor = new Color(0.5f, 0.5f, 0.5f);

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(GuanYuYouXiTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(YouXiWanFaTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(NanDuSheZhiTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(ZiDingYiYinYueTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(WoDeChengJiuTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(BeiJingQieHuanTitle.transform);
		GuanYuYouXiTitle.onClick.AddListener(delegate
		{
			TitleClick(GuanYuYouXiTitle, GuanYuYouXi);
		});
		YouXiWanFaTitle.onClick.AddListener(delegate
		{
			TitleClick(YouXiWanFaTitle, YouXiWanFa);
		});
		NanDuSheZhiTitle.onClick.AddListener(delegate
		{
			TitleClick(NanDuSheZhiTitle, NanDuSheZhi);
		});
		ZiDingYiYinYueTitle.onClick.AddListener(delegate
		{
			TitleClick(ZiDingYiYinYueTitle, ZiDingYiYinYue);
		});
		WoDeChengJiuTitle.onClick.AddListener(delegate
		{
			TitleClick(WoDeChengJiuTitle, WoDeChengJiu);
		});
		BeiJingQieHuanTitle.onClick.AddListener(delegate
		{
			TitleClick(BeiJingQieHuanTitle, BeiJingQieHuan);
		});
		selectedTitle = null;
	}

	private void Update()
	{
	}

	internal void init()
	{
		TitleClick(GuanYuYouXiTitle, GuanYuYouXi);
	}

	private void TitleClick(Button toSelectedTitle, GameObject showContent)
	{
		if (!(selectedTitle == toSelectedTitle))
		{
			selectedTitle = toSelectedTitle;
			unSelectAll();
			toSelectedTitle.GetComponent<Text>().color = selectedColor;
			showContent.SetActive(value: true);
		}
	}

	private void unSelectAll()
	{
		GuanYuYouXiTitle.GetComponent<Text>().color = unSelectedColor;
		YouXiWanFaTitle.GetComponent<Text>().color = unSelectedColor;
		NanDuSheZhiTitle.GetComponent<Text>().color = unSelectedColor;
		ZiDingYiYinYueTitle.GetComponent<Text>().color = unSelectedColor;
		WoDeChengJiuTitle.GetComponent<Text>().color = unSelectedColor;
		BeiJingQieHuanTitle.GetComponent<Text>().color = unSelectedColor;
		GuanYuYouXi.SetActive(value: false);
		YouXiWanFa.SetActive(value: false);
		NanDuSheZhi.SetActive(value: false);
		ZiDingYiYinYue.SetActive(value: false);
		WoDeChengJiu.SetActive(value: false);
		BeiJingQieHuan.SetActive(value: false);
	}
}
public class HipSettingData
{
	public int level;

	public int cubesPerSeconds;

	public int gateNum;

	public int cubeFlySpeed;

	public int comboLevel;

	public int hipLevelScore;

	public int wallComboLevel;

	public HipSettingData getCopyHipSettingData()
	{
		return new HipSettingData
		{
			level = level,
			cubesPerSeconds = cubesPerSeconds,
			gateNum = gateNum,
			cubeFlySpeed = cubeFlySpeed,
			comboLevel = comboLevel,
			hipLevelScore = hipLevelScore,
			wallComboLevel = wallComboLevel
		};
	}
}
public class HipSettingDataManager
{
	public HipSettingData hipSettingData;

	public List<float> cubesPerSecondsValueList;

	public List<string> gateNumStrList;

	public List<GenerateParameter.AngleType> gateNumValueList;

	public List<float> flySpeedValueList;

	public List<string> comboLevelStrList;

	public List<int> comboLevelValueList;

	public List<string> wallLevelStrList;

	public static string fn = "HipSetting";

	public void LoadHipSettingData()
	{
		initConstList();
		string fileName = Path.Combine(Application.persistentDataPath, fn);
		string text = FileUtils.ReadFileWithEncrypt(fileName);
		if (text == null)
		{
			hipSettingData = startData();
			return;
		}
		try
		{
			hipSettingData = JsonConvert.DeserializeObject<HipSettingData>(text);
		}
		catch (Exception)
		{
			FileUtils.deleteFile(fileName);
			hipSettingData = startData();
		}
	}

	public void SaveHipSettingData(HipSettingData hipSettingDataNew)
	{
		if (hipSettingDataNew != null)
		{
			hipSettingData = hipSettingDataNew.getCopyHipSettingData();
		}
		FileUtils.SaveFileWithEncrypt(Path.Combine(Application.persistentDataPath, fn), JsonConvert.SerializeObject(hipSettingData), Path.Combine(Application.persistentDataPath));
	}

	public HipSettingData getSuggestionSettingByLevel(int level, int playerLevel)
	{
		HipSettingData hipSettingData = new HipSettingData();
		hipSettingData.level = playerLevel;
		switch (level)
		{
		case 1:
			hipSettingData.cubesPerSeconds = 0;
			hipSettingData.gateNum = 0;
			hipSettingData.cubeFlySpeed = 0;
			hipSettingData.comboLevel = 0;
			hipSettingData.wallComboLevel = 0;
			break;
		case 2:
			hipSettingData.cubesPerSeconds = 0;
			hipSettingData.gateNum = 0;
			hipSettingData.cubeFlySpeed = 0;
			hipSettingData.comboLevel = 1;
			hipSettingData.wallComboLevel = 0;
			break;
		case 3:
			hipSettingData.cubesPerSeconds = 1;
			hipSettingData.gateNum = 1;
			hipSettingData.cubeFlySpeed = 2;
			hipSettingData.comboLevel = 1;
			hipSettingData.wallComboLevel = 1;
			break;
		case 4:
			hipSettingData.cubesPerSeconds = 3;
			hipSettingData.gateNum = 1;
			hipSettingData.cubeFlySpeed = 2;
			hipSettingData.comboLevel = 2;
			hipSettingData.wallComboLevel = 1;
			break;
		case 5:
			hipSettingData.cubesPerSeconds = 4;
			hipSettingData.gateNum = 2;
			hipSettingData.cubeFlySpeed = 3;
			hipSettingData.comboLevel = 2;
			hipSettingData.wallComboLevel = 1;
			break;
		case 6:
			hipSettingData.cubesPerSeconds = 4;
			hipSettingData.gateNum = 2;
			hipSettingData.cubeFlySpeed = 3;
			hipSettingData.comboLevel = 3;
			hipSettingData.wallComboLevel = 1;
			break;
		case 7:
			hipSettingData.cubesPerSeconds = 6;
			hipSettingData.gateNum = 2;
			hipSettingData.cubeFlySpeed = 3;
			hipSettingData.comboLevel = 3;
			hipSettingData.wallComboLevel = 1;
			break;
		case 8:
			hipSettingData.cubesPerSeconds = 6;
			hipSettingData.gateNum = 3;
			hipSettingData.cubeFlySpeed = 4;
			hipSettingData.comboLevel = 3;
			hipSettingData.wallComboLevel = 1;
			break;
		case 9:
			hipSettingData.cubesPerSeconds = 6;
			hipSettingData.gateNum = 3;
			hipSettingData.cubeFlySpeed = 4;
			hipSettingData.comboLevel = 4;
			hipSettingData.wallComboLevel = 1;
			break;
		case 10:
			hipSettingData.cubesPerSeconds = 7;
			hipSettingData.gateNum = 3;
			hipSettingData.cubeFlySpeed = 4;
			hipSettingData.comboLevel = 4;
			hipSettingData.wallComboLevel = 1;
			break;
		case 11:
			hipSettingData.cubesPerSeconds = 8;
			hipSettingData.gateNum = 3;
			hipSettingData.cubeFlySpeed = 5;
			hipSettingData.comboLevel = 4;
			hipSettingData.wallComboLevel = 1;
			break;
		}
		return hipSettingData;
	}

	private HipSettingData startData()
	{
		return new HipSettingData
		{
			comboLevel = 0,
			cubeFlySpeed = 0,
			cubesPerSeconds = 0,
			gateNum = 0,
			level = 1
		};
	}

	public string getLevelNameById(int level)
	{
		return level switch
		{
			1 => "萌新", 
			2 => "第一次", 
			3 => "肥宅", 
			4 => "普通人", 
			5 => "经常锻炼", 
			6 => "身手矫健", 
			7 => "普通高手", 
			8 => "顶尖高手", 
			9 => "绝世高手", 
			10 => "独孤求败", 
			11 => "不可能", 
			_ => "你已无敌", 
		};
	}

	private void initConstList()
	{
		cubesPerSecondsValueList = new List<float>();
		cubesPerSecondsValueList.Add(0.25f);
		cubesPerSecondsValueList.Add(0.33f);
		cubesPerSecondsValueList.Add(0.5f);
		cubesPerSecondsValueList.Add(1f);
		cubesPerSecondsValueList.Add(1.5f);
		cubesPerSecondsValueList.Add(2f);
		cubesPerSecondsValueList.Add(2.5f);
		cubesPerSecondsValueList.Add(3f);
		cubesPerSecondsValueList.Add(3.5f);
		cubesPerSecondsValueList.Add(4f);
		gateNumStrList = new List<string>();
		gateNumStrList.Add("单向");
		gateNumStrList.Add("双向");
		gateNumStrList.Add("三向");
		gateNumStrList.Add("六向");
		gateNumValueList = new List<GenerateParameter.AngleType>();
		gateNumValueList.Add(GenerateParameter.AngleType.Single);
		gateNumValueList.Add(GenerateParameter.AngleType.Two);
		gateNumValueList.Add(GenerateParameter.AngleType.Three);
		gateNumValueList.Add(GenerateParameter.AngleType.All);
		flySpeedValueList = new List<float>();
		flySpeedValueList.Add(5f);
		flySpeedValueList.Add(6f);
		flySpeedValueList.Add(7f);
		flySpeedValueList.Add(8f);
		flySpeedValueList.Add(9f);
		flySpeedValueList.Add(10f);
		flySpeedValueList.Add(11f);
		comboLevelStrList = new List<string>();
		comboLevelStrList.Add("简单");
		comboLevelStrList.Add("容易");
		comboLevelStrList.Add("普通");
		comboLevelStrList.Add("困难");
		comboLevelStrList.Add("极难");
		comboLevelValueList = new List<int>();
		comboLevelValueList.Add(1);
		comboLevelValueList.Add(2);
		comboLevelValueList.Add(3);
		comboLevelValueList.Add(4);
		comboLevelValueList.Add(5);
		wallLevelStrList = new List<string>();
		wallLevelStrList.Add("无");
		wallLevelStrList.Add("少");
		wallLevelStrList.Add("多");
	}

	internal string getLevelNameByHipScore(int hipScore)
	{
		if (hipScore < 1)
		{
			return "萌新";
		}
		if (hipScore <= 10)
		{
			return "第一次";
		}
		if (hipScore <= 20)
		{
			return "肥宅";
		}
		if (hipScore <= 30)
		{
			return "普通人";
		}
		if (hipScore <= 40)
		{
			return "经常锻炼";
		}
		if (hipScore <= 50)
		{
			return "身手矫健";
		}
		if (hipScore <= 60)
		{
			return "普通高手";
		}
		if (hipScore <= 70)
		{
			return "顶尖高手";
		}
		if (hipScore <= 80)
		{
			return "绝世高手";
		}
		if (hipScore <= 90)
		{
			return "独孤求败";
		}
		return "不可能";
	}

	internal bool checkHipScoreTooHigh(int hipScore, int level)
	{
		if (hipScore > level * 10)
		{
			return true;
		}
		return false;
	}

	internal int getHipScoreBySetting(HipSettingData hipSettingData)
	{
		int num = 0;
		switch (hipSettingData.cubesPerSeconds)
		{
		case 0:
			num = num;
			break;
		case 1:
			num++;
			break;
		case 2:
			num += 2;
			break;
		case 3:
			num += 4;
			break;
		case 4:
			num += 7;
			break;
		case 5:
			num += 12;
			break;
		case 6:
			num += 18;
			break;
		case 7:
			num += 25;
			break;
		case 8:
			num += 30;
			break;
		case 9:
			num += 35;
			break;
		}
		switch (hipSettingData.gateNum)
		{
		case 0:
			num = num;
			break;
		case 1:
			num += 3;
			break;
		case 2:
			num += 8;
			break;
		case 3:
			num += 15;
			break;
		}
		switch (hipSettingData.cubeFlySpeed)
		{
		case 0:
			num = num;
			break;
		case 1:
			num = num;
			break;
		case 2:
			num += 4;
			break;
		case 3:
			num += 8;
			break;
		case 4:
			num += 12;
			break;
		case 5:
			num += 16;
			break;
		case 6:
			num += 20;
			break;
		}
		switch (hipSettingData.comboLevel)
		{
		case 0:
			num = num;
			break;
		case 1:
			num += 3;
			break;
		case 2:
			num += 10;
			break;
		case 3:
			num += 18;
			break;
		case 4:
			num += 30;
			break;
		}
		switch (hipSettingData.wallComboLevel)
		{
		case 0:
			num = num;
			break;
		case 1:
			num += 3;
			break;
		case 2:
			num += 3;
			break;
		}
		return num;
	}
}
public class HipSettingManager : MonoBehaviour
{
	public Button level1;

	public Button level2;

	public Button level3;

	public Button level4;

	public Button level5;

	public Button level6;

	public Button level7;

	public Button level8;

	public Button level9;

	public Button level10;

	public Button level11;

	public Text currentLevelText;

	public Text challengeLevelText;

	public Button cubePerSecondsSubBtn;

	public Text cubePerSecondsValue;

	public Button cubePerSecondsAddBtn;

	public Button gateNumSubBtn;

	public Text gateNumValue;

	public Button gateNumAddBtn;

	public Button flySpeedSubBtn;

	public Text flySpeedValue;

	public Button flySpeedAddBtn;

	public Button comboLevelSubBtn;

	public Text comboLevelValue;

	public Button comboLevelAddBtn;

	public Text hipLevelScore;

	public Text hipLevel;

	public Text notAllowText;

	public Button applySettingBtn;

	public HipSettingData hipSettingData;

	private HipSettingDataManager hipSettingDataManager;

	private List<Button> levelBtnList = new List<Button>();

	public Toast toast;

	private void Awake()
	{
		levelBtnList.Add(level1);
		levelBtnList.Add(level2);
		levelBtnList.Add(level3);
		levelBtnList.Add(level4);
		levelBtnList.Add(level5);
		levelBtnList.Add(level6);
		levelBtnList.Add(level7);
		levelBtnList.Add(level8);
		levelBtnList.Add(level9);
		levelBtnList.Add(level10);
		levelBtnList.Add(level11);
		AudioSourceCommon.AttachPointEnterAudio(cubePerSecondsSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(cubePerSecondsAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(gateNumSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(gateNumAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(flySpeedSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(flySpeedAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(comboLevelSubBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(comboLevelAddBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(applySettingBtn.transform);
		for (int i = 0; i < levelBtnList.Count; i++)
		{
			Button button = levelBtnList[i];
			int level = i + 1;
			button.onClick.AddListener(delegate
			{
				setLevelSuggestParam(level);
			});
		}
		applySettingBtn.onClick.AddListener(delegate
		{
			applyBtnEnable(enable: false);
			hipSettingDataManager.SaveHipSettingData(hipSettingData);
			toast.showToast("设置成功！");
		});
	}

	private void setLevelSuggestParam(int level)
	{
		hipSettingData = hipSettingDataManager.getSuggestionSettingByLevel(level, hipSettingData.level);
		setHipValue();
	}

	public void init()
	{
		hipSettingDataManager = UnitySingleton<DataCenter>.Instance.hipSettingDataManager;
		hipSettingData = hipSettingDataManager.hipSettingData.getCopyHipSettingData();
		setLevelEnable();
		setLevelText();
		setHipValue();
		applyBtnEnable(enable: false);
	}

	private void setHipValue()
	{
		cubePerSecondsValue.text = hipSettingDataManager.cubesPerSecondsValueList[hipSettingData.cubesPerSeconds].ToString();
		gateNumValue.text = hipSettingDataManager.gateNumStrList[hipSettingData.gateNum].ToString();
		flySpeedValue.text = hipSettingDataManager.flySpeedValueList[hipSettingData.cubeFlySpeed].ToString();
		comboLevelValue.text = hipSettingDataManager.comboLevelStrList[hipSettingData.comboLevel].ToString();
		int hipScoreBySetting = hipSettingDataManager.getHipScoreBySetting(hipSettingData);
		hipLevelScore.text = "难度系数: " + hipScoreBySetting;
		hipLevel.text = "段位: " + hipSettingDataManager.getLevelNameByHipScore(hipScoreBySetting);
		if (hipSettingDataManager.checkHipScoreTooHigh(hipScoreBySetting, hipSettingData.level))
		{
			notAllowText.gameObject.SetActive(value: true);
			applySettingBtn.gameObject.SetActive(value: false);
		}
		else
		{
			notAllowText.gameObject.SetActive(value: false);
			applySettingBtn.gameObject.SetActive(value: true);
			applyBtnEnable(enable: true);
		}
	}

	private void setLevelText()
	{
		currentLevelText.text = "当前段位: " + hipSettingDataManager.getLevelNameById(hipSettingData.level);
		challengeLevelText.text = "挑战段位: " + hipSettingDataManager.getLevelNameById(hipSettingData.level + 1);
	}

	private void setLevelEnable()
	{
		for (int i = 0; i < levelBtnList.Count; i++)
		{
			Button button = levelBtnList[i];
			button.enabled = false;
			Text component = button.transform.Find("Text").GetComponent<Text>();
			component.color = new Color(component.color.r, component.color.g, component.color.b, 0.5f);
			button.GetComponent<Animator>().enabled = false;
			button.GetComponent<Image>().sprite = Resources.Load("Img/UI/setting/greyBtn", typeof(Sprite)) as Sprite;
			AudioSourceCommon.ClearPointEnterAudio(button.transform);
		}
		for (int j = 0; j < hipSettingData.level + 1 && j < levelBtnList.Count; j++)
		{
			Button button2 = levelBtnList[j];
			button2.enabled = true;
			Text component2 = button2.transform.Find("Text").GetComponent<Text>();
			component2.color = new Color(component2.color.r, component2.color.g, component2.color.b, 1f);
			button2.GetComponent<Animator>().enabled = true;
			button2.GetComponent<Image>().sprite = Resources.Load("Img/UI/setting/BlueBtn", typeof(Sprite)) as Sprite;
			AudioSourceCommon.AttachPointEnterAudio(button2.transform);
		}
	}

	public void clickCubePerSecondsSub()
	{
		if (hipSettingData.cubesPerSeconds > 0)
		{
			hipSettingData.cubesPerSeconds--;
			setHipValue();
		}
	}

	public void clickCubePerSecondsAdd()
	{
		if (hipSettingData.cubesPerSeconds < hipSettingDataManager.cubesPerSecondsValueList.Count - 1)
		{
			hipSettingData.cubesPerSeconds++;
			setHipValue();
		}
	}

	public void clickGateNumSub()
	{
		if (hipSettingData.gateNum > 0)
		{
			hipSettingData.gateNum--;
			setHipValue();
		}
	}

	public void clickGateNumAdd()
	{
		if (hipSettingData.gateNum < hipSettingDataManager.gateNumStrList.Count - 1)
		{
			hipSettingData.gateNum++;
			setHipValue();
		}
	}

	public void clickFlySpeedSub()
	{
		if (hipSettingData.cubeFlySpeed > 0)
		{
			hipSettingData.cubeFlySpeed--;
			setHipValue();
		}
	}

	public void clickFlySpeedAdd()
	{
		if (hipSettingData.cubeFlySpeed < hipSettingDataManager.flySpeedValueList.Count - 1)
		{
			hipSettingData.cubeFlySpeed++;
			setHipValue();
		}
	}

	public void clickcomboLevelSub()
	{
		if (hipSettingData.comboLevel > 0)
		{
			hipSettingData.comboLevel--;
			setHipValue();
		}
	}

	public void clickcomboLevelAdd()
	{
		if (hipSettingData.comboLevel < hipSettingDataManager.comboLevelStrList.Count - 1)
		{
			hipSettingData.comboLevel++;
			setHipValue();
		}
	}

	public void applyBtnEnable(bool enable)
	{
		if (enable)
		{
			applySettingBtn.enabled = true;
			Text component = applySettingBtn.transform.Find("Text").GetComponent<Text>();
			component.color = new Color(component.color.r, component.color.g, component.color.b, 1f);
			applySettingBtn.GetComponent<Animator>().enabled = true;
			AudioSourceCommon.AttachPointEnterAudio(applySettingBtn.transform);
		}
		else
		{
			applySettingBtn.enabled = false;
			Text component2 = applySettingBtn.transform.Find("Text").GetComponent<Text>();
			component2.color = new Color(component2.color.r, component2.color.g, component2.color.b, 0.5f);
			applySettingBtn.GetComponent<Animator>().enabled = false;
			AudioSourceCommon.ClearPointEnterAudio(applySettingBtn.transform);
		}
	}
}
public class MainSelect : MonoBehaviour
{
	public enum BtnSelect
	{
		MusicSelect,
		HipSetting,
		ScoreRatting,
		GameDes,
		SceneSelect,
		GameCompleteInfo,
		None
	}

	private Bottom bottom;

	private MainShow mainShow;

	private BtnSelect currentSelect;

	private void Awake()
	{
		bottom = GetComponent<Bottom>();
		mainShow = GetComponent<MainShow>();
	}

	private void Start()
	{
		UnitySingleton<DataCenter>.Instance.initLoad();
		if (UnitySingleton<DataCenter>.Instance.returnFromGame)
		{
			SwitchMainShow(BtnSelect.GameCompleteInfo);
		}
		else
		{
			SwitchMainShow(BtnSelect.None);
		}
	}

	private void Update()
	{
	}

	internal void SwitchMainShow(BtnSelect btnSelect)
	{
		currentSelect = btnSelect;
		mainShow.SwitchMainShow(btnSelect);
	}
}
public class MainShow : MonoBehaviour
{
	public GameObject Title;

	public GameObject MusicSelect;

	public GameObject HipSetting;

	public GameObject ScoreRatting;

	public GameObject GameCompleteInfo;

	public GameObject SceneSelect;

	public GameObject GameDes;

	private void Start()
	{
	}

	private void Update()
	{
	}

	internal void SwitchMainShow(MainSelect.BtnSelect btnSelect)
	{
		HideAll();
		switch (btnSelect)
		{
		case MainSelect.BtnSelect.GameDes:
			GameDes?.SetActive(value: true);
			GameDes.GetComponent<GameDesManager>().init();
			break;
		case MainSelect.BtnSelect.HipSetting:
			HipSetting?.SetActive(value: true);
			HipSetting.GetComponent<HipSettingManager>().init();
			break;
		case MainSelect.BtnSelect.MusicSelect:
			MusicSelect?.SetActive(value: true);
			MusicSelect.GetComponent<MusicSelectManager>().init();
			break;
		case MainSelect.BtnSelect.ScoreRatting:
			ScoreRatting?.SetActive(value: true);
			ScoreRatting.GetComponent<ScoreRankManager>().init();
			break;
		case MainSelect.BtnSelect.None:
			Title.transform.Find("level");
			Title.transform.Find("level").GetComponent<Text>();
			Title.transform.Find("level").GetComponent<Text>().text = "当前段位: " + UnitySingleton<DataCenter>.Instance.hipSettingDataManager.getLevelNameById(UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level);
			Title?.SetActive(value: true);
			break;
		case MainSelect.BtnSelect.GameCompleteInfo:
			GameCompleteInfo.GetComponent<GameCompleteInfoManager>().init();
			GameCompleteInfo?.SetActive(value: true);
			break;
		case MainSelect.BtnSelect.SceneSelect:
			SceneSelect.GetComponent<SceneSelectManager>().init();
			SceneSelect?.SetActive(value: true);
			break;
		}
	}

	private void HideAll()
	{
		Title?.SetActive(value: false);
		MusicSelect?.SetActive(value: false);
		HipSetting?.SetActive(value: false);
		ScoreRatting?.SetActive(value: false);
		GameDes?.SetActive(value: false);
		GameCompleteInfo?.SetActive(value: false);
		SceneSelect?.SetActive(value: false);
	}
}
public class MusicLoading : MonoBehaviour
{
	public float rotateSpeed = 300f;

	private void Update()
	{
		if (base.gameObject.activeInHierarchy)
		{
			base.transform.Rotate(-UnityEngine.Vector3.forward * rotateSpeed * Time.deltaTime);
		}
	}
}
public class MusicSelectManager : MonoBehaviour
{
	private const int PageSize = 12;

	public Button PrevPage;

	public Button NextPage;

	public Button StartGame;

	public Text PageText;

	public Text hipSettingScoreText;

	public GameObject Container;

	public GameObject Loading;

	public AudioSource audioSource;

	public GameObject title;

	public GameObject PageTextObj;

	public GameObject leftController;

	public GameObject RightController;

	private GameObject selectedMusicItem;

	private int selectedMusicIndex;

	private int totalPage;

	private int currentPage;

	private bool inited;

	public Toast toast;

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(PrevPage.transform);
		AudioSourceCommon.AttachPointEnterAudio(NextPage.transform);
		AudioSourceCommon.AttachPointEnterAudio(StartGame.transform);
	}

	public void init()
	{
		hipSettingScoreText.text = "当前难度系数: " + UnitySingleton<DataCenter>.Instance.hipSettingDataManager.getHipScoreBySetting(UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData);
		if (!inited)
		{
			title.SetActive(value: true);
			PageTextObj.SetActive(value: true);
			clearSelect();
			PrevPage.gameObject.SetActive(value: false);
			NextPage.gameObject.SetActive(value: false);
			Loading.SetActive(value: false);
			Container.SetActive(value: false);
			PageText.text = "1/1页";
			UpdataMusicListUI();
			SetPageSatus();
			inited = true;
		}
	}

	private void UpdataMusicListUI()
	{
		totalPage = UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList.Count / 12 + 1;
		currentPage = 1;
		SetPageData();
	}

	private void SetPageData()
	{
		for (int i = 0; i < 12; i++)
		{
			Container.transform.Find(string.Concat(i + 1)).gameObject.SetActive(value: false);
		}
		for (int j = 0; j < 12; j++)
		{
			int index = (currentPage - 1) * 12 + j;
			if (index >= UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList.Count)
			{
				break;
			}
			GameObject obj = Container.transform.Find(string.Concat(j + 1)).gameObject;
			obj.transform.Find("Text").GetComponent<Text>().text = index + 1 + ". " + UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[index].name;
			obj.transform.Find("selected").gameObject.SetActive(value: false);
			obj.GetComponent<Button>().onClick.RemoveAllListeners();
			int itemIndex = j;
			obj.GetComponent<Button>().onClick.AddListener(delegate
			{
				SelecteMusic(index, itemIndex);
			});
			AudioSourceCommon.AttachPointEnterAudio(obj.transform);
			obj.SetActive(value: true);
		}
		Container.SetActive(value: true);
	}

	private void SetPageSatus()
	{
		PageText.text = currentPage + "/" + totalPage + "页";
		if (currentPage != 1)
		{
			PrevPage.gameObject.SetActive(value: true);
		}
		else
		{
			PrevPage.gameObject.SetActive(value: false);
		}
		if (currentPage != totalPage)
		{
			NextPage.gameObject.SetActive(value: true);
		}
		else
		{
			NextPage.gameObject.SetActive(value: false);
		}
	}

	public void ToNextPage()
	{
		currentPage++;
		clearSelect(pageChange: true);
		SetPageData();
		SetPageSatus();
	}

	public void ToPrevPage()
	{
		currentPage--;
		clearSelect(pageChange: true);
		SetPageData();
		SetPageSatus();
	}

	public void StartToPlayGame()
	{
		PrevPage.gameObject.SetActive(value: false);
		NextPage.gameObject.SetActive(value: false);
		Loading.SetActive(value: false);
		Container.SetActive(value: false);
		startGameBtnEnable(enable: false);
		UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading = true;
		title.SetActive(value: false);
		PageTextObj.SetActive(value: false);
		leftController.SetActive(value: false);
		RightController.SetActive(value: false);
		UnitySingleton<DataCenter>.Instance.musicName = UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[selectedMusicIndex].name;
		UnitySingleton<DataCenter>.Instance.initMusic();
		Loading.SetActive(value: true);
		if (UnitySingleton<DataCenter>.Instance.musicDataCenter.isfirstTimeLoad)
		{
			Loading.transform.Find("First").gameObject.SetActive(value: true);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: false);
		}
		else
		{
			Loading.transform.Find("First").gameObject.SetActive(value: false);
			Loading.transform.Find("notFirst").gameObject.SetActive(value: true);
		}
	}

	public void startGameBtnEnable(bool enable)
	{
		if (enable)
		{
			StartGame.enabled = true;
			Text component = StartGame.transform.Find("Text").GetComponent<Text>();
			component.color = new Color(component.color.r, component.color.g, component.color.b, 1f);
			StartGame.GetComponent<Animator>().enabled = true;
			AudioSourceCommon.AttachPointEnterAudio(StartGame.transform);
		}
		else
		{
			StartGame.enabled = false;
			Text component2 = StartGame.transform.Find("Text").GetComponent<Text>();
			component2.color = new Color(component2.color.r, component2.color.g, component2.color.b, 0.5f);
			StartGame.GetComponent<Animator>().enabled = false;
			AudioSourceCommon.ClearPointEnterAudio(StartGame.transform);
		}
	}

	private void clearSelect(bool pageChange = false)
	{
		if (selectedMusicIndex != -1)
		{
			if (selectedMusicItem != null)
			{
				selectedMusicItem.transform.Find("selected").gameObject.SetActive(value: false);
			}
			selectedMusicItem = null;
			if (!pageChange)
			{
				selectedMusicIndex = -1;
				startGameBtnEnable(enable: false);
			}
		}
	}

	public void SelecteMusic(int musicIndex, int itemIdex)
	{
		GameObject gameObject = Container.transform.Find(string.Concat(itemIdex + 1)).gameObject;
		if (musicIndex != selectedMusicIndex)
		{
			selectedMusicIndex = musicIndex;
			if (selectedMusicItem != null)
			{
				selectedMusicItem.transform.Find("selected").gameObject.SetActive(value: false);
			}
			selectedMusicItem = gameObject;
			selectedMusicItem.transform.Find("selected").gameObject.SetActive(value: true);
			PlayMusic();
		}
	}

	public void PlayMusic()
	{
		audioSource.Stop();
		IEnumerator routine = UnitySingleton<DataCenter>.Instance.musicListDataCenter.LoadAudioClip(UnitySingleton<DataCenter>.Instance.musicListDataCenter.audioCurrentList[selectedMusicIndex], delegate
		{
			audioSource.clip = UnitySingleton<DataCenter>.Instance.playClip;
			audioSource.Play();
			startGameBtnEnable(enable: true);
		});
		StartCoroutine(routine);
	}

	private void Update()
	{
		if (UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading && UnitySingleton<DataCenter>.Instance.musicDataCenter.isAnalysisMusicDone)
		{
			UnitySingleton<DataCenter>.Instance.opControl.inMusicLoading = false;
			GradualBlack.instance.blackMidAction = delegate
			{
				UnitySingleton<DataCenter>.Instance.CheckGenerateBeatBasicInfoDone();
				SceneManager.LoadScene(1);
			};
			GradualBlack.instance.playAll = false;
			GradualBlack.instance.StartGradualBlack();
		}
	}
}
public class SceneSelectDataManager
{
	public class SelectedSceneIndex
	{
		public int selectedIndex;

		public int hitSound;

		public int hitFailSound;

		public int execriseMode;

		public int loadMyHitSound;

		public int leftColor;

		public int rightColor;

		public int wallBianColor;

		public float hitDis;

		public float cubeHeight;

		public float bsSpeedAdjust;

		public float cubeLarger;

		public float saberLarger;

		public float saberMove;

		public float yuPanBili;

		public float saberFov;

		public int flyDongHua;

		public List<string> audioListLike;

		public bool isShowAudioLikeList;
	}

	public class GyjzCheck
	{
		public string sn;

		public string key;
	}

	public SelectedSceneIndex selectedSceneIndex;

	public static string fn = "selectedSceneIndex";

	public static bool ck = false;

	public void LoadSceneSelectData()
	{
		string fileName = Path.Combine(Application.persistentDataPath, fn);
		string text = FileUtils.ReadFileWithEncrypt(fileName);
		if (text == null)
		{
			selectedSceneIndex = startData();
			setScene(selectedSceneIndex.selectedIndex);
		}
		else
		{
			try
			{
				selectedSceneIndex = JsonConvert.DeserializeObject<SelectedSceneIndex>(text);
				checkupdate();
			}
			catch (Exception)
			{
				FileUtils.deleteFile(fileName);
				selectedSceneIndex = startData();
				setScene(selectedSceneIndex.selectedIndex);
			}
		}
		Lc();
	}

	private void checkupdate()
	{
		if (selectedSceneIndex.leftColor == selectedSceneIndex.rightColor || selectedSceneIndex.saberLarger == 0f)
		{
			selectedSceneIndex.leftColor = 4;
			selectedSceneIndex.rightColor = 7;
			selectedSceneIndex.selectedIndex = 8;
			selectedSceneIndex.wallBianColor = 7;
			selectedSceneIndex.loadMyHitSound = 0;
			selectedSceneIndex.hitDis = 1.5f;
			selectedSceneIndex.cubeHeight = 0.7f;
			selectedSceneIndex.bsSpeedAdjust = 0f;
			selectedSceneIndex.saberLarger = 1f;
			selectedSceneIndex.cubeLarger = 1f;
			selectedSceneIndex.hitFailSound = 3;
			selectedSceneIndex.saberLarger = 1f;
			selectedSceneIndex.saberMove = 0f;
			selectedSceneIndex.yuPanBili = 1.5f;
			selectedSceneIndex.flyDongHua = 1;
			selectedSceneIndex.saberFov = 0f;
			SaveSelectedSceneData();
		}
	}

	private void Lc()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetDeviceSN();
		if (text.Equals("UNKONWN"))
		{
			text = "PA7H10MGF5030351W";
		}
		UnityEngine.Debug.Log("serialno:" + text);
		string text2 = GenerateMD5(text + "LiuYuJiaMyBaby2021");
		string fileName = Path.Combine(Application.persistentDataPath, "GyjzCheck.txt");
		string text3 = FileUtils.ReadFile(fileName);
		if (text3 != null)
		{
			try
			{
				string key = JsonConvert.DeserializeObject<GyjzCheck>(text3).key;
				if (text2.Equals(key))
				{
					ck = true;
				}
				else
				{
					ck = false;
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log(ex.ToString());
				ck = false;
			}
		}
		else
		{
			GyjzCheck gyjzCheck = new GyjzCheck();
			gyjzCheck.sn = text;
			gyjzCheck.key = "";
			FileUtils.SaveFile(fileName, JsonConvert.SerializeObject(gyjzCheck), Path.Combine(Application.persistentDataPath));
			ck = false;
		}
		if (UnitySingleton<DataCenter>.Instance.doPicoCheck)
		{
			ck = true;
		}
	}

	private SelectedSceneIndex startData()
	{
		return new SelectedSceneIndex
		{
			selectedIndex = 8,
			hitSound = 3,
			hitFailSound = 3,
			execriseMode = 0,
			leftColor = 4,
			rightColor = 7,
			wallBianColor = 7,
			loadMyHitSound = 0,
			hitDis = 1.5f,
			cubeHeight = 0.7f,
			bsSpeedAdjust = 0f,
			saberLarger = 1f,
			saberMove = 0f,
			yuPanBili = 1.5f,
			flyDongHua = 1,
			saberFov = 0f,
			audioListLike = new List<string>(),
			isShowAudioLikeList = false
		};
	}

	public void SaveSelectedSceneData()
	{
		FileUtils.SaveFileWithEncrypt(Path.Combine(Application.persistentDataPath, fn), JsonConvert.SerializeObject(selectedSceneIndex), Path.Combine(Application.persistentDataPath));
	}

	public void setScene(int index)
	{
		selectedSceneIndex.selectedIndex = index;
		SaveSelectedSceneData();
	}

	public void setHitSound(int hitSound)
	{
		selectedSceneIndex.hitSound = hitSound;
		SaveSelectedSceneData();
	}

	public void setExecriseMode(int execriseMode)
	{
		selectedSceneIndex.execriseMode = execriseMode;
		SaveSelectedSceneData();
	}

	public static string GenerateMD5(string txt)
	{
		using MD5 mD = MD5.Create();
		byte[] bytes = Encoding.UTF8.GetBytes(txt);
		byte[] array = mD.ComputeHash(bytes);
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < array.Length; i++)
		{
			stringBuilder.Append(array[i].ToString("x2"));
		}
		return stringBuilder.ToString();
	}
}
public class SceneSelectManager : MonoBehaviour
{
	public Button scene0;

	public Button scene1;

	public Button scene2;

	public Button scene3;

	public Button scene4;

	public Button scene5;

	public Button scene6;

	public Button scene7;

	public Button scene8;

	private Button selectedButton;

	private int selectedIndex;

	private List<Button> secenBtnList;

	private Color colorNormal = new Color(0.95f, 0.51f, 0.86f);

	private Color colorSelected = new Color(1f, 1f, 1f);

	private int fontSizeNormal = 55;

	private int fontSizeSelected = 60;

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(scene0.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene1.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene2.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene3.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene4.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene5.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene6.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene7.transform);
		AudioSourceCommon.AttachPointEnterAudio(scene8.transform);
		scene0.onClick.AddListener(delegate
		{
			setSelected(0);
		});
		scene1.onClick.AddListener(delegate
		{
			setSelected(1);
		});
		scene2.onClick.AddListener(delegate
		{
			setSelected(2);
		});
		scene3.onClick.AddListener(delegate
		{
			setSelected(3);
		});
		scene4.onClick.AddListener(delegate
		{
			setSelected(4);
		});
		scene5.onClick.AddListener(delegate
		{
			setSelected(5);
		});
		scene6.onClick.AddListener(delegate
		{
			setSelected(6);
		});
		scene7.onClick.AddListener(delegate
		{
			setSelected(7);
		});
		scene8.onClick.AddListener(delegate
		{
			setSelected(8);
		});
	}

	internal void init()
	{
		secenBtnList = new List<Button>();
		secenBtnList.Add(scene0);
		secenBtnList.Add(scene1);
		secenBtnList.Add(scene2);
		secenBtnList.Add(scene3);
		secenBtnList.Add(scene4);
		secenBtnList.Add(scene5);
		secenBtnList.Add(scene6);
		secenBtnList.Add(scene7);
		secenBtnList.Add(scene8);
		selectedIndex = -1;
		setSelected(UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.selectedSceneIndex.selectedIndex, switchSkybox: false);
	}

	private void setSelected(int selectedIndex, bool switchSkybox = true)
	{
		if (this.selectedIndex == selectedIndex)
		{
			return;
		}
		this.selectedIndex = selectedIndex;
		selectedButton = secenBtnList[this.selectedIndex];
		foreach (Button secenBtn in secenBtnList)
		{
			Text component = secenBtn.transform.Find("text").GetComponent<Text>();
			component.fontStyle = FontStyle.Normal;
			component.fontSize = fontSizeNormal;
			component.color = colorNormal;
		}
		Text component2 = selectedButton.transform.Find("text").GetComponent<Text>();
		component2.fontStyle = FontStyle.Bold;
		component2.fontSize = fontSizeSelected;
		component2.color = colorSelected;
		if (switchSkybox)
		{
			UnitySingleton<DataCenter>.Instance.sceneSelectDataManager.setScene(selectedIndex);
		}
	}
}
public class ChengJiuManager : MonoBehaviour
{
	public Text firstTime;

	public Text tiliQiangren;

	public Text lingshiwu;

	public Text baijuzhan;

	public Text qianjuzhan;

	public Text dongzuogaoshou;

	public Text huijiankuangzhan;

	public Text mantianfeiwu;

	public Text xuanzhuandaren;

	public Text fanyingzuikuai;

	public Text ChengjiuDetailInfo;

	private Color getedColor = new Color(1f, 1f, 1f);

	private Color unGetedColor = new Color(0.5f, 0.5f, 0.5f);

	private void Start()
	{
		AudioSourceCommon.AttachPointEnterAudio(firstTime.transform, firstTimeHint);
		AudioSourceCommon.AttachPointEnterAudio(tiliQiangren.transform, tiliQiangrenHint);
		AudioSourceCommon.AttachPointEnterAudio(lingshiwu.transform, lingshiwuHint);
		AudioSourceCommon.AttachPointEnterAudio(baijuzhan.transform, baijuzhanHint);
		AudioSourceCommon.AttachPointEnterAudio(qianjuzhan.transform, qianjuzhanHint);
		AudioSourceCommon.AttachPointEnterAudio(dongzuogaoshou.transform, dongzuogaoshouHint);
		AudioSourceCommon.AttachPointEnterAudio(huijiankuangzhan.transform, huijiankuangzhanHint);
		AudioSourceCommon.AttachPointEnterAudio(mantianfeiwu.transform, mantianfeiwuHint);
		AudioSourceCommon.AttachPointEnterAudio(xuanzhuandaren.transform, xuanzhuandarenHint);
		AudioSourceCommon.AttachPointEnterAudio(fanyingzuikuai.transform, fanyingzuikuaiHint);
	}

	private void firstTimeHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "第一次：第一次挑战成功后获得";
	}

	private void tiliQiangrenHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "体力强人：音乐时长大于8分钟，且难度系数大于30，挑战成功后获得";
	}

	private void lingshiwuHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "零失误：挑战过程中成功打击所有方块，难度系数大于30，挑战成功后获得";
	}

	private void baijuzhanHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "百局斩：完成100局挑战后获得";
	}

	private void qianjuzhanHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "千局斩：完成1000局挑战后获得";
	}

	private void dongzuogaoshouHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "动作高手：动作难度为极难，挑战成功后获得";
	}

	private void huijiankuangzhanHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "挥剑狂斩：平均打击速度大于35米/秒，且难度系数大于30，挑战成功后获得";
	}

	private void mantianfeiwuHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "漫天飞舞：平均每秒打击节拍数为4，挑战成功后获得";
	}

	private void xuanzhuandarenHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "旋转达人：传送门数量为360度，且难度系数大于30，挑战成功后获得";
	}

	private void fanyingzuikuaiHint(BaseEventData arg0)
	{
		ChengjiuDetailInfo.gameObject.SetActive(value: true);
		ChengjiuDetailInfo.text = "反应最快：方块飞行速度为11，且难度系数大于30，挑战成功后获得";
	}

	internal void init()
	{
		ChengJiuData chengJiuData = UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.chengJiuData;
		if (chengJiuData.firstTime)
		{
			firstTime.text = "第一次(已获得)";
			firstTime.color = getedColor;
		}
		else
		{
			firstTime.text = "第一次(未获得)";
			firstTime.color = unGetedColor;
		}
		if (chengJiuData.lingshiwu)
		{
			lingshiwu.text = "零失误(已获得)";
			lingshiwu.color = getedColor;
		}
		else
		{
			lingshiwu.text = "零失误(未获得)";
			lingshiwu.color = unGetedColor;
		}
		if (chengJiuData.tiliQiangren)
		{
			tiliQiangren.text = "体力强人(已获得)";
			tiliQiangren.color = getedColor;
		}
		else
		{
			tiliQiangren.text = "体力强人(未获得)";
			tiliQiangren.color = unGetedColor;
		}
		if (chengJiuData.baijuzhan)
		{
			baijuzhan.text = "百局斩(已获得)";
			baijuzhan.color = getedColor;
		}
		else
		{
			baijuzhan.text = "百局斩(未获得)";
			baijuzhan.color = unGetedColor;
		}
		if (chengJiuData.qianjuzhan)
		{
			qianjuzhan.text = "千局斩(已获得)";
			qianjuzhan.color = getedColor;
		}
		else
		{
			qianjuzhan.text = "千局斩(未获得)";
			qianjuzhan.color = unGetedColor;
		}
		if (chengJiuData.dongzuogaoshou)
		{
			dongzuogaoshou.text = "动作高手(已获得)";
			dongzuogaoshou.color = getedColor;
		}
		else
		{
			dongzuogaoshou.text = "动作高手(未获得)";
			dongzuogaoshou.color = unGetedColor;
		}
		if (chengJiuData.huijiankuangzhan)
		{
			huijiankuangzhan.text = "挥剑狂斩(已获得)";
			huijiankuangzhan.color = getedColor;
		}
		else
		{
			huijiankuangzhan.text = "挥剑狂斩(未获得)";
			huijiankuangzhan.color = unGetedColor;
		}
		if (chengJiuData.mantianfeiwu)
		{
			mantianfeiwu.text = "漫天飞舞(已获得)";
			mantianfeiwu.color = getedColor;
		}
		else
		{
			mantianfeiwu.text = "漫天飞舞(未获得)";
			mantianfeiwu.color = unGetedColor;
		}
		if (chengJiuData.xuanzhuandaren)
		{
			xuanzhuandaren.text = "旋转达人(已获得)";
			xuanzhuandaren.color = getedColor;
		}
		else
		{
			xuanzhuandaren.text = "旋转达人(未获得)";
			xuanzhuandaren.color = unGetedColor;
		}
		if (chengJiuData.fanyingzuikuai)
		{
			fanyingzuikuai.text = "反应最快(已获得)";
			fanyingzuikuai.color = getedColor;
		}
		else
		{
			fanyingzuikuai.text = "反应最快(未获得)";
			fanyingzuikuai.color = unGetedColor;
		}
		ChengjiuDetailInfo.gameObject.SetActive(value: false);
	}
}
public class ChengJiuData
{
	public bool firstTime;

	public bool tiliQiangren;

	public bool lingshiwu;

	public bool baijuzhan;

	public bool qianjuzhan;

	public bool dongzuogaoshou;

	public bool huijiankuangzhan;

	public bool mantianfeiwu;

	public bool xuanzhuandaren;

	public bool fanyingzuikuai;

	public ChengJiuData()
	{
		firstTime = false;
		tiliQiangren = false;
		lingshiwu = false;
		baijuzhan = false;
		qianjuzhan = false;
		dongzuogaoshou = false;
		huijiankuangzhan = false;
		mantianfeiwu = false;
		xuanzhuandaren = false;
		fanyingzuikuai = false;
	}
}
public class HistoryDetailData
{
	public string musicName;

	public int hipLevelScore;

	public bool sucess;

	public string getChengJiu;

	public string getLevel;

	public float playScore;

	public string playTime;
}
public class HistoryTotalData
{
	public int totalPlays;

	public int totalSuccessPlays;

	public int totalFailPlays;

	public int highestHipLevelScoreSuccessPlay;

	public float highestGameScorePlay;

	public float fastestHit;

	public int longestSinglePlay;

	public HistoryTotalData()
	{
		totalPlays = 0;
		totalSuccessPlays = 0;
		totalFailPlays = 0;
		highestHipLevelScoreSuccessPlay = 0;
		highestGameScorePlay = 0f;
		fastestHit = 0f;
		longestSinglePlay = 0;
	}
}
public class ScoreRankData
{
	public ChengJiuData chengJiuData;

	public HistoryTotalData historyTotalData;

	public List<HistoryDetailData> historyDetailDataList;

	public ScoreRankData()
	{
		chengJiuData = new ChengJiuData();
		historyTotalData = new HistoryTotalData();
		historyDetailDataList = new List<HistoryDetailData>();
	}

	private void putTestData()
	{
		for (int i = 0; i < 23; i++)
		{
			HistoryDetailData historyDetailData = new HistoryDetailData();
			historyDetailData.musicName = "音乐" + i;
			historyDetailData.hipLevelScore = i;
			historyDetailData.sucess = i % 3 == 0;
			historyDetailData.getChengJiu = "旋转达人";
			historyDetailData.getLevel = "无";
			historyDetailData.playScore = 117f;
			historyDetailData.playTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm");
			historyDetailDataList.Add(historyDetailData);
		}
	}
}
public class HistoryDetailManager : MonoBehaviour
{
	public GameObject HistoryDetailItem1;

	public GameObject HistoryDetailItem2;

	public GameObject HistoryDetailItem3;

	public GameObject HistoryDetailItem4;

	public GameObject HistoryDetailItem5;

	public Button prevBtn;

	public Button nextBtn;

	public Text pageText;

	private int currentPage;

	private int totalPage;

	private List<HistoryDetailData> historyDetailDataList;

	private const int pageSize = 5;

	private void Awake()
	{
		AudioSourceCommon.AttachPointEnterAudio(prevBtn.transform);
		AudioSourceCommon.AttachPointEnterAudio(nextBtn.transform);
	}

	internal void init()
	{
		historyDetailDataList = new List<HistoryDetailData>();
		for (int num = UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.historyDetailDataList.Count - 1; num >= 0; num--)
		{
			historyDetailDataList.Add(UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.historyDetailDataList[num]);
		}
		currentPage = 1;
		totalPage = historyDetailDataList.Count / 5 + 1;
		setListData();
		setPage();
	}

	private void setPage()
	{
		prevBtn.gameObject.SetActive(value: true);
		nextBtn.gameObject.SetActive(value: true);
		if (currentPage == 1)
		{
			prevBtn.gameObject.SetActive(value: false);
		}
		if (currentPage == totalPage)
		{
			nextBtn.gameObject.SetActive(value: false);
		}
		pageText.text = currentPage + "/" + totalPage + "页";
	}

	public void nextPage()
	{
		currentPage++;
		setListData();
		setPage();
	}

	public void prevPage()
	{
		currentPage--;
		setListData();
		setPage();
	}

	private void setListData()
	{
		HistoryDetailItem1.SetActive(value: false);
		HistoryDetailItem2.SetActive(value: false);
		HistoryDetailItem3.SetActive(value: false);
		HistoryDetailItem4.SetActive(value: false);
		HistoryDetailItem5.SetActive(value: false);
		for (int i = 0; i < 5; i++)
		{
			int num = (currentPage - 1) * 5 + i;
			if (num < historyDetailDataList.Count)
			{
				HistoryDetailData historyDetailData = historyDetailDataList[num];
				if (i == 0)
				{
					setDetailData(HistoryDetailItem1, historyDetailData);
				}
				if (i == 1)
				{
					setDetailData(HistoryDetailItem2, historyDetailData);
				}
				if (i == 2)
				{
					setDetailData(HistoryDetailItem3, historyDetailData);
				}
				if (i == 3)
				{
					setDetailData(HistoryDetailItem4, historyDetailData);
				}
				if (i == 4)
				{
					setDetailData(HistoryDetailItem5, historyDetailData);
				}
				continue;
			}
			break;
		}
	}

	private void setDetailData(GameObject historyDetailItem, HistoryDetailData historyDetailData)
	{
		historyDetailItem.SetActive(value: true);
		historyDetailItem.transform.Find("musicName").GetComponent<Text>().text = historyDetailData.musicName;
		historyDetailItem.transform.Find("hipLevelScore").GetComponent<Text>().text = historyDetailData.hipLevelScore.ToString();
		historyDetailItem.transform.Find("sucess").GetComponent<Text>().text = (historyDetailData.sucess ? "成功" : "失败");
		historyDetailItem.transform.Find("getChengJiu").GetComponent<Text>().text = historyDetailData.getChengJiu;
		historyDetailItem.transform.Find("getLevel").GetComponent<Text>().text = historyDetailData.getLevel;
		historyDetailItem.transform.Find("playScore").GetComponent<Text>().text = historyDetailData.playScore.ToString("f1");
		historyDetailItem.transform.Find("playTime").GetComponent<Text>().text = historyDetailData.playTime;
	}
}
public class HistoryTotalManager : MonoBehaviour
{
	public Text totalPlays;

	public Text totalSuccessPlays;

	public Text totalFailPlays;

	public Text totalSuccessFailRate;

	public Text highestHipLevelScoreSuccessPlay;

	public Text highestGameScorePlay;

	public Text fastestHit;

	public Text longestSinglePlay;

	internal void init()
	{
		HistoryTotalData historyTotalData = UnitySingleton<DataCenter>.Instance.scoreRankDataManger.scoreRankData.historyTotalData;
		totalPlays.text = "总挑战局数：" + historyTotalData.totalPlays;
		totalSuccessPlays.text = "挑战成功局数：" + historyTotalData.totalSuccessPlays;
		totalFailPlays.text = "挑战失败局数：" + historyTotalData.totalFailPlays;
		float num = historyTotalData.totalSuccessPlays;
		float num2 = historyTotalData.totalPlays;
		totalSuccessFailRate.text = "挑战成功率：" + ((historyTotalData.totalPlays == 0) ? 0f : (num / num2 * 100f)).ToString("f1") + "%";
		highestHipLevelScoreSuccessPlay.text = "挑战成功最高难度系数：" + historyTotalData.highestHipLevelScoreSuccessPlay;
		highestGameScorePlay.text = "最高综合评分：" + historyTotalData.highestGameScorePlay;
		fastestHit.text = "最快挥剑速度：" + historyTotalData.fastestHit.ToString("f1") + "米/秒";
		longestSinglePlay.text = "最长音乐时长：" + getTimeStr(historyTotalData.longestSinglePlay);
	}

	private string getTimeStr(int longestSinglePlay)
	{
		int num = Mathf.FloorToInt(longestSinglePlay / MainPlayControl.timeIndexPerSeconds / 60);
		int num2 = (longestSinglePlay - num * 60 * MainPlayControl.timeIndexPerSeconds) / MainPlayControl.timeIndexPerSeconds;
		return num + "分" + num2 + "秒";
	}
}
public class ScoreRankDataManger
{
	public ScoreRankData scoreRankData;

	public HistoryDetailData newHistoryDetailData;

	public static string fn = "ScoreRankData";

	public void LoadScoreRankData()
	{
		string fileName = Path.Combine(Application.persistentDataPath, fn);
		string text = FileUtils.ReadFileWithEncrypt(fileName);
		if (text == null)
		{
			scoreRankData = startData();
			return;
		}
		try
		{
			scoreRankData = JsonConvert.DeserializeObject<ScoreRankData>(text);
		}
		catch (Exception)
		{
			FileUtils.deleteFile(fileName);
			scoreRankData = startData();
		}
	}

	private ScoreRankData startData()
	{
		return new ScoreRankData();
	}

	public void SaveScoreRankData()
	{
		FileUtils.SaveFileWithEncrypt(Path.Combine(Application.persistentDataPath, fn), JsonConvert.SerializeObject(scoreRankData), Path.Combine(Application.persistentDataPath));
	}

	internal void putNewData(bool success)
	{
		newHistoryDetailData = new HistoryDetailData();
		putChengJiuData(success);
		putLevelUpdate(success);
		putHistoryTotalData(success);
		putHistoryDetailDataList(success);
		SaveScoreRankData();
	}

	private void putLevelUpdate(bool success)
	{
		newHistoryDetailData.getLevel = "无";
		if (!success || !getLastValidMusic())
		{
			return;
		}
		GamePlayInfo gamePlayInfo = UnitySingleton<DataCenter>.Instance.gamePlayInfo;
		int level = UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level;
		switch (level)
		{
		case 11:
			return;
		case 1:
			if (gamePlayInfo.hipSettingLevel > 1)
			{
				newHistoryDetailData.getLevel = "第一次";
				UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 2;
				UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
			}
			break;
		}
		if (level == 2 && gamePlayInfo.hipSettingLevel > 10)
		{
			newHistoryDetailData.getLevel = "肥宅";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 3;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 3 && gamePlayInfo.hipSettingLevel > 20)
		{
			newHistoryDetailData.getLevel = "普通人";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 4;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 4 && gamePlayInfo.hipSettingLevel > 30)
		{
			newHistoryDetailData.getLevel = "经常锻炼";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 5;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 5 && gamePlayInfo.hipSettingLevel > 40)
		{
			newHistoryDetailData.getLevel = "身手矫健";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 6;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 6 && gamePlayInfo.hipSettingLevel > 50)
		{
			newHistoryDetailData.getLevel = "普通高手";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 7;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 7 && gamePlayInfo.hipSettingLevel > 60)
		{
			newHistoryDetailData.getLevel = "顶尖高手";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 8;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 8 && gamePlayInfo.hipSettingLevel > 70)
		{
			newHistoryDetailData.getLevel = "绝世高手";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 9;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 9 && gamePlayInfo.hipSettingLevel > 80)
		{
			newHistoryDetailData.getLevel = "独孤求败";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 10;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
		if (level == 10 && gamePlayInfo.hipSettingLevel > 90)
		{
			newHistoryDetailData.getLevel = "不可能";
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData.level = 11;
			UnitySingleton<DataCenter>.Instance.hipSettingDataManager.SaveHipSettingData(null);
		}
	}

	private void putHistoryDetailDataList(bool success)
	{
		newHistoryDetailData.musicName = UnitySingleton<DataCenter>.Instance.generatorLaw.musicName;
		newHistoryDetailData.hipLevelScore = UnitySingleton<DataCenter>.Instance.hipSettingDataManager.getHipScoreBySetting(UnitySingleton<DataCenter>.Instance.hipSettingDataManager.hipSettingData);
		newHistoryDetailData.sucess = success;
		newHistoryDetailData.playTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm");
		scoreRankData.historyDetailDataList.Add(newHistoryDetailData);
		int num = 200;
		if (scoreRankData.historyDetailDataList.Count > num)
		{
			int index = scoreRankData.historyDetailDataList.Count - num;
			scoreRankData.historyDetailDataList = scoreRankData.historyDetailDataList.GetRange(index, num);
		}
	}

	private void putHistoryTotalData(bool success)
	{
		scoreRankData.historyTotalData.totalPlays++;
		if (success)
		{
			scoreRankData.historyTotalData.totalSuccessPlays++;
		}
		else
		{
			scoreRankData.historyTotalData.totalFailPlays++;
		}
		newHistoryDetailData.playScore = 0f;
		if (success)
		{
			GamePlayInfo gamePlayInfo = UnitySingleton<DataCenter>.Instance.gamePlayInfo;
			if (gamePlayInfo.hipSettingLevel > scoreRankData.historyTotalData.highestHipLevelScoreSuccessPlay)
			{
				scoreRankData.historyTotalData.highestHipLevelScoreSuccessPlay = gamePlayInfo.hipSettingLevel;
			}
			float num = (getLastValidMusic() ? gamePlayInfo.hipSettingLevel : 0);
			if (UnitySingleton<DataCenter>.Instance.gamePlayInfo.hitNum > 0)
			{
				_ = UnitySingleton<DataCenter>.Instance.gamePlayInfo.totalhitSpeed / (float)UnitySingleton<DataCenter>.Instance.gamePlayInfo.hitNum;
			}
			float num2 = ((gamePlayInfo.totalhitSpeed > 35f) ? 5f : (gamePlayInfo.totalhitSpeed / 7f));
			float num3 = ((gamePlayInfo.hitSuccessNum > 0) ? (gamePlayInfo.hitSuccessNum / (gamePlayInfo.hitSuccessNum + gamePlayInfo.hitFailNum) * 5) : 0);
			newHistoryDetailData.playScore = num + num2 + num3;
			if (newHistoryDetailData.playScore > scoreRankData.historyTotalData.highestGameScorePlay)
			{
				scoreRankData.historyTotalData.highestGameScorePlay = newHistoryDetailData.playScore;
			}
			if (gamePlayInfo.fastHitSpeed > scoreRankData.historyTotalData.fastestHit)
			{
				scoreRankData.historyTotalData.fastestHit = gamePlayInfo.fastHitSpeed;
			}
			int totalTimeUnits = UnitySingleton<DataCenter>.Instance.generatorLaw.totalTimeUnits;
			if (totalTimeUnits > scoreRankData.historyTotalData.longestSinglePlay)
			{
				scoreRankData.historyTotalData.longestSinglePlay = totalTimeUnits;
			}
		}
	}

	private void putChengJiuData(bool success)
	{
		GamePlayInfo gamePlayInfo = UnitySingleton<DataCenter>.Instance.gamePlayInfo;
		newHistoryDetailData.getChengJiu = "无";
		if (success && getLastValidMusic())
		{
			if (!scoreRankData.chengJiuData.firstTime)
			{
				scoreRankData.chengJiuData.firstTime = true;
				newHistoryDetailData.getChengJiu = "第一次";
			}
			if (!scoreRankData.chengJiuData.tiliQiangren && UnitySingleton<DataCenter>.Instance.generatorLaw.totalTimeUnits > 480 * MainPlayControl.timeIndexPerSeconds && gamePlayInfo.hipSettingLevel > 30)
			{
				scoreRankData.chengJiuData.tiliQiangren = true;
				newHistoryDetailData.getChengJiu = "体力强人";
			}
			if (!scoreRankData.chengJiuData.lingshiwu && gamePlayInfo.hitFailNum == 0 && gamePlayInfo.hipSettingLevel > 30)
			{
				scoreRankData.chengJiuData.lingshiwu = true;
				newHistoryDetailData.getChengJiu = "零失误";
			}
			if (!scoreRankData.chengJiuData.baijuzhan && scoreRankData.historyTotalData.totalPlays >= 99)
			{
				scoreRankData.chengJiuData.baijuzhan = true;
				newHistoryDetailData.getChengJiu = "百局斩";
			}
			if (!scoreRankData.chengJiuData.qianjuzhan && scoreRankData.historyTotalData.totalPlays >= 999)
			{
				scoreRankData.chengJiuData.qianjuzhan = true;
				newHistoryDetailData.getChengJiu = "千局斩";
			}
			if (!scoreRankData.chengJiuData.dongzuogaoshou && UnitySingleton<DataCenter>.Instance.generateParameter.ballComboLevel == 5)
			{
				scoreRankData.chengJiuData.dongzuogaoshou = true;
				newHistoryDetailData.getChengJiu = "动作高手";
			}
			if (!scoreRankData.chengJiuData.huijiankuangzhan && UnitySingleton<DataCenter>.Instance.gamePlayInfo.hitNum > 0 && UnitySingleton<DataCenter>.Instance.gamePlayInfo.totalhitSpeed / (float)UnitySingleton<DataCenter>.Instance.gamePlayInfo.hitNum > 35f)
			{
				scoreRankData.chengJiuData.huijiankuangzhan = true;
				newHistoryDetailData.getChengJiu = "挥剑狂斩";
			}
			if (!scoreRankData.chengJiuData.mantianfeiwu && UnitySingleton<DataCenter>.Instance.generateParameter.beatOfTimeUnit < 6)
			{
				scoreRankData.chengJiuData.mantianfeiwu = true;
				newHistoryDetailData.getChengJiu = "漫天飞舞";
			}
			if (!scoreRankData.chengJiuData.xuanzhuandaren && UnitySingleton<DataCenter>.Instance.generateParameter.angleType == GenerateParameter.AngleType.All && gamePlayInfo.hipSettingLevel > 40)
			{
				scoreRankData.chengJiuData.xuanzhuandaren = true;
				newHistoryDetailData.getChengJiu = "旋转达人";
			}
			if (!scoreRankData.chengJiuData.fanyingzuikuai && UnitySingleton<DataCenter>.Instance.generateParameter.ballSpeed > 10f)
			{
				scoreRankData.chengJiuData.fanyingzuikuai = true;
				newHistoryDetailData.getChengJiu = "反应最快";
			}
		}
	}

	internal string getLastGetChengJiuStr()
	{
		return newHistoryDetailData.getChengJiu;
	}

	internal string getLastGetLevelStr()
	{
		return newHistoryDetailData.getLevel;
	}

	internal float getLastTotalSocre()
	{
		return newHistoryDetailData.playScore;
	}

	internal bool getLastValidMusic()
	{
		if (UnitySingleton<DataCenter>.Instance.bsMusicManager.isBsMusic)
		{
			return false;
		}
		if (UnitySingleton<DataCenter>.Instance.generatorLaw.totalTimeUnits < 120 * MainPlayControl.timeIndexPerSeconds)
		{
			return false;
		}
		int num = UnitySingleton<DataCenter>.Instance.generatorLaw.totalTimeUnits / UnitySingleton<DataCenter>.Instance.generateParameter.beatOfTimeUnit;
		if (UnitySingleton<DataCenter>.Instance.generatorLaw.generatorBeatDicWithCombAndScore.Count < num)
		{
			return false;
		}
		return true;
	}
}
public class ScoreRankManager : MonoBehaviour
{
	public Button chengJiuTitle;

	public Button historyTotalTitle;

	public Button historyDetailTitle;

	public GameObject chengjiu;

	public GameObject historyTotal;

	public GameObject historydetail;

	private ChengJiuManager chengJiuManager;

	private HistoryTotalManager historyTotalManager;

	private HistoryDetailManager historyDetailManager;

	private Button selectedTitle;

	private Color selectedColor = new Color(1f, 1f, 1f);

	private Color unSelectedColor = new Color(0.5f, 0.5f, 0.5f);

	private void Awake()
	{
		AudioSourceCommon.AttachPointEnterAudio(chengJiuTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(historyTotalTitle.transform);
		AudioSourceCommon.AttachPointEnterAudio(historyDetailTitle.transform);
		chengJiuManager = GetComponent<ChengJiuManager>();
		historyTotalManager = GetComponent<HistoryTotalManager>();
		historyDetailManager = GetComponent<HistoryDetailManager>();
		selectedTitle = null;
	}

	public void init()
	{
		chengJiuTitleClick();
	}

	public void chengJiuTitleClick()
	{
		if (!(selectedTitle == chengJiuTitle))
		{
			chengJiuManager.init();
			selectedTitle = chengJiuTitle;
			chengJiuTitle.GetComponent<Text>().color = selectedColor;
			historyTotalTitle.GetComponent<Text>().color = unSelectedColor;
			historyDetailTitle.GetComponent<Text>().color = unSelectedColor;
			chengjiu.SetActive(value: true);
			historyTotal.SetActive(value: false);
			historydetail.SetActive(value: false);
		}
	}

	public void historyTotalTitleClick()
	{
		if (!(selectedTitle == historyTotalTitle))
		{
			historyTotalManager.init();
			selectedTitle = historyTotalTitle;
			chengJiuTitle.GetComponent<Text>().color = unSelectedColor;
			historyTotalTitle.GetComponent<Text>().color = selectedColor;
			historyDetailTitle.GetComponent<Text>().color = unSelectedColor;
			chengjiu.SetActive(value: false);
			historyTotal.SetActive(value: true);
			historydetail.SetActive(value: false);
		}
	}

	public void historyDetailTitleClick()
	{
		if (!(selectedTitle == historyDetailTitle))
		{
			historyDetailManager.init();
			selectedTitle = historyDetailTitle;
			chengJiuTitle.GetComponent<Text>().color = unSelectedColor;
			historyTotalTitle.GetComponent<Text>().color = unSelectedColor;
			historyDetailTitle.GetComponent<Text>().color = selectedColor;
			chengjiu.SetActive(value: false);
			historyTotal.SetActive(value: false);
			historydetail.SetActive(value: true);
		}
	}
}
public class Toast : MonoBehaviour
{
	public GameObject toastPanel;

	private float showTime;

	private void Start()
	{
		showTime = 0f;
	}

	private void Update()
	{
		if (toastPanel.activeInHierarchy)
		{
			showTime += Time.deltaTime;
			if (showTime > 1.5f)
			{
				toastPanel.SetActive(value: false);
				showTime = 0f;
			}
		}
	}

	internal void showToast(string str)
	{
		toastPanel.SetActive(value: true);
		showTime = 0f;
		toastPanel.transform.Find("Text").GetComponent<Text>().text = str;
	}
}
public class CylinderSpark : MonoBehaviour
{
	public RoundSpark roundSpark;

	public Material sparkMaterial;

	private void Start()
	{
		roundSpark?.matDic.Add(base.gameObject, new RoundSpark.MatComb(GetComponent<MeshRenderer>().material, sparkMaterial));
	}
}
public class HideSpark : MonoBehaviour
{
	public RoundSpark roundSpark;

	public GameObject sparkObj;

	private void Start()
	{
		roundSpark.hideSparkList.Add(sparkObj);
	}
}
public class RoundSpark : MonoBehaviour
{
	public class MatComb
	{
		public Material defaultMat { get; set; }

		public Material sparkMat { get; set; }

		public MatComb(Material defaultMat, Material sparkMat)
		{
			this.defaultMat = defaultMat;
			this.sparkMat = sparkMat;
		}
	}

	public Material black;

	public Material lightSphere;

	public Material lightSphereOrange;

	public Dictionary<GameObject, MatComb> matDic = new Dictionary<GameObject, MatComb>();

	public List<GameObject> hideSparkList = new List<GameObject>();

	public List<ParticleSystem> particleSparkList = new List<ParticleSystem>();

	private bool isSparking;

	private float sparkingTime;

	private void Start()
	{
		isSparking = false;
		sparkingTime = 0f;
	}

	internal void spark()
	{
		if (!isSparking)
		{
			ToSparkMat();
			isSparking = true;
			sparkingTime = 0f;
		}
	}

	internal void sparkUpdate()
	{
		if (isSparking)
		{
			sparkingTime += Time.deltaTime;
			if (sparkingTime > 0.01f)
			{
				ToDefaultMat();
				isSparking = false;
			}
		}
	}

	private void ToDefaultMat()
	{
		foreach (KeyValuePair<GameObject, MatComb> item in matDic)
		{
			ToSparkMatSingle(item.Key, toSpark: false);
		}
		foreach (GameObject hideSpark in hideSparkList)
		{
			_ = hideSpark;
		}
	}

	private void ToSparkMat()
	{
		foreach (KeyValuePair<GameObject, MatComb> item in matDic)
		{
			ToSparkMatSingle(item.Key, toSpark: true);
		}
		foreach (GameObject hideSpark in hideSparkList)
		{
			_ = hideSpark;
		}
		foreach (ParticleSystem particleSpark in particleSparkList)
		{
			_ = particleSpark;
		}
	}

	private void ToSparkMatSingle(GameObject gameObject, bool toSpark)
	{
		matDic.TryGetValue(gameObject, out var value);
		if (toSpark)
		{
			gameObject.GetComponent<MeshRenderer>().material = value.sparkMat;
		}
		else
		{
			gameObject.GetComponent<MeshRenderer>().material = value.defaultMat;
		}
	}
}
public class InGameInfo : MonoBehaviour
{
	public Text leftText;

	public Text rightText;

	private bool isInfoChanged;

	private string debugInfo;

	private void Update()
	{
		if (isInfoChanged)
		{
			leftText.text = debugInfo;
			isInfoChanged = false;
		}
	}

	public void showHitInfo(Blade blade)
	{
	}

	internal void sendHitDebugInfo(Blade blade, float isRightHitWave, bool isRight)
	{
		debugInfo = string.Concat("调试信息：\n光剑手:", blade.bladeType, "\n打击速度:", Convert.ToInt32(blade.waveDistancePerSecond), "\n打击方向偏移:", isRightHitWave, "\n有效打击:", isRight ? "是" : "否");
		isInfoChanged = true;
	}
}
public class bcInfo : MonoBehaviour
{
	public Text subTitle;

	public GameObject musicNotLoad;

	private void Start()
	{
		if (SceneSelectDataManager.ck)
		{
			subTitle.text = "（单机完整版）";
			musicNotLoad.SetActive(value: false);
		}
		else
		{
			subTitle.text = "（单机免费版）";
			musicNotLoad.SetActive(value: true);
		}
	}
}
public class FileUtils
{
	public static string LYJ = "12345678901234567890123456789000";

	public static bool LYJCD = false;

	public static void SaveFile(string fileName, string content, string path)
	{
		if (path != null)
		{
			DirectoryInfo directoryInfo = new DirectoryInfo(path);
			if (!directoryInfo.Exists)
			{
				directoryInfo.Create();
			}
		}
		if (!File.Exists(fileName))
		{
			File.Create(fileName).Close();
		}
		File.WriteAllText(fileName, content);
	}

	public static void SaveFileWithEncrypt(string fileName, string content, string path)
	{
		if (path != null)
		{
			DirectoryInfo directoryInfo = new DirectoryInfo(path);
			if (!directoryInfo.Exists)
			{
				directoryInfo.Create();
			}
		}
		if (!File.Exists(fileName))
		{
			File.Create(fileName).Close();
		}
		byte[] bytes = Encrypt(content, LYJ);
		File.WriteAllBytes(fileName, bytes);
	}

	public static string ReadFile(string fileName)
	{
		if (!File.Exists(fileName))
		{
			return null;
		}
		return File.ReadAllText(fileName);
	}

	public static void deleteFile(string fileName)
	{
		if (File.Exists(fileName))
		{
			File.Delete(fileName);
		}
	}

	public static string ReadFileWithEncrypt(string fileName)
	{
		if (!File.Exists(fileName))
		{
			return null;
		}
		try
		{
			byte[] bytes = Decrypt(File.ReadAllBytes(fileName), LYJ);
			return Encoding.UTF8.GetString(bytes);
		}
		catch (Exception)
		{
			deleteFile(fileName);
			return null;
		}
	}

	public static List<FileInfo> ReadMusicFileList(string path)
	{
		List<FileInfo> list = new List<FileInfo>();
		DirectoryInfo directoryInfo = new DirectoryInfo(path);
		if (!directoryInfo.Exists)
		{
			directoryInfo.Create();
			return list;
		}
		FileInfo[] files = directoryInfo.GetFiles();
		foreach (FileInfo fileInfo in files)
		{
			if (fileInfo.Name.EndsWith(".mp3"))
			{
				list.Add(fileInfo);
			}
		}
		return list;
	}

	internal static List<string> getBsFolderList(string playMusicPath)
	{
		List<string> list = new List<string>();
		DirectoryInfo directoryInfo = new DirectoryInfo(playMusicPath);
		if (!directoryInfo.Exists)
		{
			directoryInfo.Create();
			return list;
		}
		DirectoryInfo[] directories = directoryInfo.GetDirectories();
		for (int i = 0; i < directories.Length; i++)
		{
			list.Add(directories[i].Name);
		}
		return list;
	}

	public static byte[] Encrypt(string Text, string sKey)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(sKey);
		ICryptoTransform cryptoTransform = new RijndaelManaged
		{
			Key = bytes,
			Mode = CipherMode.ECB,
			Padding = PaddingMode.PKCS7
		}.CreateEncryptor();
		byte[] bytes2 = Encoding.UTF8.GetBytes(Text);
		return cryptoTransform.TransformFinalBlock(bytes2, 0, bytes2.Length);
	}

	public static byte[] Decrypt(byte[] _EncryptArray, string sKey)
	{
		byte[] bytes = Encoding.UTF8.GetBytes(sKey);
		return new RijndaelManaged
		{
			Key = bytes,
			Mode = CipherMode.ECB,
			Padding = PaddingMode.PKCS7
		}.CreateDecryptor().TransformFinalBlock(_EncryptArray, 0, _EncryptArray.Length);
	}
}
public class PressUtils
{
	public static bool PressTestRestart()
	{
		if (!Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Left))
		{
			return Input.GetKeyDown(KeyCode.R);
		}
		return true;
	}

	public static bool PressPause()
	{
		if (!Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) && !Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP) && !Input.GetKeyDown(KeyCode.Escape))
		{
			return Input.GetKeyDown(KeyCode.P);
		}
		return true;
	}

	public static bool PressLeftTrigger()
	{
		if (!Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER))
		{
			return Input.GetKeyDown(KeyCode.O);
		}
		return true;
	}

	public static bool PressRightTrigger()
	{
		if (!Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER) && !Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP) && !Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP) && !Input.GetKeyDown(KeyCode.Escape))
		{
			return Input.GetKeyDown(KeyCode.P);
		}
		return true;
	}
}
public class TransformUtils
{
	public static void PlaneLookAt(Transform source, Transform target)
	{
		source.LookAt(new UnityEngine.Vector3(target.position.x, source.position.y, target.position.z));
	}

	public static UnityEngine.Vector3 PlaneY(UnityEngine.Vector3 xz, float y = 0f)
	{
		return new UnityEngine.Vector3(xz.x, y, xz.z);
	}
}
public class Demo_switch : MonoBehaviour
{
	public GameObject[] Sword;

	public bool act;

	public int sword_numd;

	public bool act1;

	private void Update()
	{
		if (act)
		{
			Sword[sword_numd].SetActive(value: false);
			sword_numd++;
			Sword[sword_numd].SetActive(value: true);
			act = false;
		}
		if (act1)
		{
			Sword[sword_numd].SetActive(value: false);
			sword_numd--;
			Sword[sword_numd].SetActive(value: true);
			act1 = false;
		}
		if (Input.GetKeyDown(KeyCode.E) && sword_numd < 9)
		{
			act = true;
		}
		if (Input.GetKeyDown(KeyCode.Q) && sword_numd > 0)
		{
			act1 = true;
		}
	}
}
public class SplitProperty : MonoBehaviour
{
	public bool forMainSelect;

	public bool forCubeCut;

	public bool forCubeBreak;

	public void newGameObjectSpecialSet(Rigidbody newGameObject, Ball.BallCollisionInfo ballCollisionInfo = null)
	{
		if (forMainSelect)
		{
			newGameObject.GetComponent<BreakOnCollision>().breaked = true;
			newGameObject.mass = 0.2f;
			newGameObject.constraints = RigidbodyConstraints.None;
			float num = 30f;
			newGameObject.AddForce(new UnityEngine.Vector3(UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num)));
			newGameObject.useGravity = true;
		}
		else if (forCubeCut)
		{
			newGameObject.GetComponent<FrageDisappear>().breaked = true;
			newGameObject.constraints = RigidbodyConstraints.None;
			if (ballCollisionInfo != null)
			{
				_ = newGameObject.GetComponent<MeshFilter>().mesh.bounds.center;
				_ = newGameObject.centerOfMass;
				float num2 = CalculateSumVolume(newGameObject.GetComponent<MeshFilter>().mesh, newGameObject.transform);
				float num3 = CalculateSumVolume(GetComponent<MeshFilter>().mesh, newGameObject.transform);
				newGameObject.mass = num2 / num3;
				UnityEngine.Vector3 normalized = (-ballCollisionInfo.blade.waveDirection).normalized;
				UnityEngine.Vector3 force = ballCollisionInfo.blade.waveDistancePerSecond * 6f * normalized + (newGameObject.worldCenterOfMass - base.transform.position).normalized * 60f;
				newGameObject.AddForce(force);
			}
			newGameObject.useGravity = true;
		}
		else if (forCubeBreak)
		{
			newGameObject.GetComponent<FrageDisappear>().breaked = true;
			newGameObject.constraints = RigidbodyConstraints.None;
			if (ballCollisionInfo != null)
			{
				_ = newGameObject.GetComponent<MeshFilter>().mesh.bounds.center;
				_ = newGameObject.centerOfMass;
				float num4 = CalculateSumVolume(newGameObject.GetComponent<MeshFilter>().mesh, newGameObject.transform);
				float num5 = CalculateSumVolume(GetComponent<MeshFilter>().mesh, newGameObject.transform);
				newGameObject.mass = 0.5f + 0.5f * num4 / num5;
				UnityEngine.Vector3 normalized2 = (newGameObject.worldCenterOfMass - ballCollisionInfo.colliderPoint).normalized;
				UnityEngine.Vector3 force2 = ballCollisionInfo.blade.waveDistancePerSecond * 8f * normalized2;
				newGameObject.AddForce(force2);
			}
			newGameObject.useGravity = true;
		}
	}

	private UnityEngine.Vector3 CalVecticesCenter(UnityEngine.Vector3[] vertices)
	{
		UnityEngine.Vector3 zero = UnityEngine.Vector3.zero;
		foreach (UnityEngine.Vector3 vector in vertices)
		{
			zero += vector;
		}
		return zero / vertices.Length;
	}

	private float CalculateSumVolume(Mesh mesh, Transform t)
	{
		UnityEngine.Vector3[] vertices = mesh.vertices;
		_ = mesh.triangles;
		float num = 0f;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			int[] triangles = mesh.GetTriangles(i);
			for (int j = 0; j < triangles.Length; j += 3)
			{
				num += CalculateVolume(vertices[triangles[j]], vertices[triangles[j + 1]], vertices[triangles[j + 2]], t);
			}
		}
		return Mathf.Abs(num);
	}

	private float CalculateVolume(UnityEngine.Vector3 pt0, UnityEngine.Vector3 pt1, UnityEngine.Vector3 pt2, Transform t)
	{
		pt0 = new UnityEngine.Vector3(pt0.x * t.lossyScale.x, pt0.y * t.lossyScale.y, pt0.z * t.lossyScale.z);
		pt1 = new UnityEngine.Vector3(pt1.x * t.lossyScale.x, pt1.y * t.lossyScale.y, pt1.z * t.lossyScale.z);
		pt2 = new UnityEngine.Vector3(pt2.x * t.lossyScale.x, pt2.y * t.lossyScale.y, pt2.z * t.lossyScale.z);
		float num = pt2.x * pt1.y * pt0.z;
		float num2 = pt1.x * pt2.y * pt0.z;
		float num3 = pt2.x * pt0.y * pt1.z;
		float num4 = pt0.x * pt2.y * pt1.z;
		float num5 = pt1.x * pt0.y * pt2.z;
		float num6 = pt0.x * pt1.y * pt2.z;
		return 1f / 6f * (0f - num + num2 + num3 - num4 - num5 + num6);
	}
}
public class SCS : MonoBehaviour
{
	public Transform Player;

	public float CloudsSpeed;

	private void Update()
	{
		base.transform.Rotate(0f, Time.deltaTime * CloudsSpeed, 0f);
	}
}
public class destroyMe : MonoBehaviour
{
	private float timer;

	public float deathtimer = 10f;

	private void Start()
	{
	}

	private void Update()
	{
		timer += Time.deltaTime;
		if (timer >= deathtimer)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class instantiateEffectCaller : MonoBehaviour
{
	[Serializable]
	public class chainEffect
	{
		[NonSerialized]
		public bool isPlayed;

		public float activateTimer;

		public GameObject Effect;

		public Transform effectLocator;
	}

	[NonSerialized]
	public bool fired;

	private float timer;

	public float timeLimit;

	public chainEffect[] chainEffectList;

	private void Start()
	{
	}

	private void Update()
	{
		timer += Time.deltaTime;
		CheckTimer();
	}

	private void CheckTimer()
	{
		for (int i = 0; i < chainEffectList.Length; i++)
		{
			if (timer >= chainEffectList[i].activateTimer && !chainEffectList[i].isPlayed)
			{
				UnityEngine.Object.Instantiate(chainEffectList[i].Effect, chainEffectList[i].effectLocator.transform.position, chainEffectList[i].effectLocator.transform.rotation);
				chainEffectList[i].isPlayed = true;
			}
		}
		if (timer >= timeLimit)
		{
			fired = false;
			ResetTimers();
		}
	}

	public void ResetTimers()
	{
		for (int i = 0; i < chainEffectList.Length; i++)
		{
			chainEffectList[i].isPlayed = false;
		}
		timer = 0f;
	}
}
[ExecuteInEditMode]
public class particleColorChanger : MonoBehaviour
{
	[Serializable]
	public class colorChange
	{
		public string Name;

		public ParticleSystem[] colored_ParticleSystem;

		public Gradient customer_Gradient;
	}

	public colorChange[] colorChangeList;

	private void Update()
	{
		for (int i = 0; i < colorChangeList.Length; i++)
		{
			for (int j = 0; j < colorChangeList[i].colored_ParticleSystem.Length; j++)
			{
				ParticleSystem.ColorOverLifetimeModule colorOverLifetime = colorChangeList[i].colored_ParticleSystem[j].colorOverLifetime;
				colorOverLifetime.color = colorChangeList[i].customer_Gradient;
			}
		}
	}
}
public class Readme : ScriptableObject
{
	[Serializable]
	public class Section
	{
		public string heading;

		public string text;

		public string linkText;

		public string url;
	}

	public Texture2D icon;

	public string title;

	public Section[] sections;

	public bool loadedLayout;
}
public class ParticleScale : MonoBehaviour
{
	public float scaleStep = 0.1f;

	private ParticleSystem _particle;

	public ParticleSystem particle
	{
		get
		{
			if (_particle == null)
			{
				_particle = GetComponent<ParticleSystem>();
			}
			return _particle;
		}
	}

	public void UpdateScale(float mod)
	{
		if (!(particle == null))
		{
			particle.startSize += particle.startSize * mod;
			particle.startSpeed += particle.startSpeed * mod;
		}
	}

	public void ReduceScale(float mod)
	{
		if (!(particle == null))
		{
			particle.startSize -= particle.startSize * mod;
			particle.startSpeed -= particle.startSpeed * mod;
		}
	}
}
public class JsonNetSample : MonoBehaviour
{
	public class Product
	{
		public string Name;

		public DateTime ExpiryDate = new DateTime(2000, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		public decimal Price;

		public string[] Sizes;

		public override bool Equals(object obj)
		{
			if (obj is Product)
			{
				Product product = (Product)obj;
				if (product.Name == Name && product.ExpiryDate == ExpiryDate)
				{
					return product.Price == Price;
				}
				return false;
			}
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			return (Name ?? string.Empty).GetHashCode();
		}
	}

	[Serializable]
	public class CharacterListItem
	{
		public int Id { get; set; }

		public string Name { get; set; }

		public int Level { get; set; }

		public string Class { get; set; }

		public string Sex { get; set; }
	}

	public class Movie
	{
		public string Name { get; set; }

		public string Description { get; set; }

		public string Classification { get; set; }

		public string Studio { get; set; }

		public DateTime? ReleaseDate { get; set; }

		public List<string> ReleaseCountries { get; set; }
	}

	public Text Output;

	private void Start()
	{
		Output.text = "Start!\n\n";
		TestJson();
		SerailizeJson();
		DeserializeJson();
		LinqToJson();
		JsonPath();
		WriteLine("\nDone!");
	}

	private void WriteLine(string msg)
	{
		Output.text = Output.text + msg + "\n";
	}

	private void TestJson()
	{
		WriteLine("* TestJson");
		CharacterListItem characterListItem = JsonConvert.DeserializeObject<CharacterListItem>("{\"Id\":51, \"Name\":\"padre\", \"Level\":0, \"Class\":\"Vampire\", \"Sex\":\"F\"}");
		WriteLine(characterListItem.Id + " " + characterListItem.Name);
	}

	private void SerailizeJson()
	{
		WriteLine("* SerailizeJson");
		Product product = new Product();
		product.Name = "Apple";
		product.ExpiryDate = new DateTime(2008, 12, 28);
		product.Sizes = new string[1] { "Small" };
		string msg = JsonConvert.SerializeObject(product);
		WriteLine(msg);
	}

	private void DeserializeJson()
	{
		WriteLine("* DeserializeJson");
		string msg = JsonConvert.DeserializeObject<Movie>("{\r\n          'Name': 'Bad Boys',\r\n          'ReleaseDate': '1995-4-7T00:00:00',\r\n          'Genres': [\r\n            'Action',\r\n            'Comedy'\r\n          ]\r\n        }").Name;
		WriteLine(msg);
	}

	private void LinqToJson()
	{
		WriteLine("* LinqToJson");
		JArray jArray = new JArray();
		jArray.Add("Manual text");
		jArray.Add(new DateTime(2000, 5, 23));
		string msg = new JObject { ["MyArray"] = jArray }.ToString();
		WriteLine(msg);
	}

	private void JsonPath()
	{
		WriteLine("* JsonPath");
		JObject jObject = JObject.Parse("{\r\n            'Stores': [\r\n            'Lambton Quay',\r\n            'Willis Street'\r\n            ],\r\n            'Manufacturers': [\r\n            {\r\n                'Name': 'Acme Co',\r\n                'Products': [\r\n                {\r\n                    'Name': 'Anvil',\r\n                    'Price': 50\r\n                }\r\n                ]\r\n            },\r\n            {\r\n                'Name': 'Contoso',\r\n                'Products': [\r\n                {\r\n                    'Name': 'Elbow Grease',\r\n                    'Price': 99.95\r\n                },\r\n                {\r\n                    'Name': 'Headlight Fluid',\r\n                    'Price': 4\r\n                }\r\n                ]\r\n            }\r\n            ]\r\n        }");
		JToken jToken = jObject.SelectToken("$.Manufacturers[?(@.Name == 'Acme Co')]");
		WriteLine(jToken.ToString());
		foreach (JToken item in jObject.SelectTokens("$..Products[?(@.Price >= 50)].Name"))
		{
			WriteLine(item.ToString());
		}
	}
}
public class particle_controller : MonoBehaviour
{
	public List<Transform> targets = new List<Transform>();

	public Transform startpos;

	public GameObject preftracer;

	public List<GameObject> PrefOfExpl = new List<GameObject>();

	public float speed = 0.1f;

	public int rangeOfRandom;

	public AudioSource missle;

	public AudioSource explore;

	private GameObject tracer;

	private float timeLerped;

	private float timeToLerp = 2f;

	private UnityEngine.Vector3 startingPosition;

	private UnityEngine.Vector3[] arrayOfTarget;

	private GameObject[] arrayOfTracers;

	private GameObject[] arrayOfExplos;

	private byte[] played;

	private int amount;

	private float timer;

	private int currentexp;

	private void GenerTargets()
	{
		for (int i = 0; i <= amount - 1; i++)
		{
			arrayOfTarget[i] = targets[i].transform.position;
			arrayOfTarget[i] = new UnityEngine.Vector3(arrayOfTarget[i].x + (float)UnityEngine.Random.Range(-rangeOfRandom, rangeOfRandom), arrayOfTarget[i].y + (float)UnityEngine.Random.Range(-rangeOfRandom, rangeOfRandom), arrayOfTarget[i].z + (float)UnityEngine.Random.Range(-rangeOfRandom, rangeOfRandom));
		}
	}

	private void Start()
	{
		amount = targets.Count;
		played = new byte[amount];
		arrayOfExplos = new GameObject[amount];
		arrayOfTracers = new GameObject[amount];
		arrayOfTarget = new UnityEngine.Vector3[amount];
		startingPosition = startpos.position;
		GenerTargets();
	}

	private void Update()
	{
		if (arrayOfTracers[0] == null)
		{
			for (int i = 0; i <= amount - 1; i++)
			{
				arrayOfTracers[i] = UnityEngine.Object.Instantiate(preftracer, startpos.position, startpos.rotation);
				played[i] = 1;
				missle?.Play();
			}
		}
		for (int j = 0; j <= amount - 1; j++)
		{
			if (arrayOfTracers[j].transform.position.y < arrayOfTarget[j].y)
			{
				UnityEngine.Quaternion quaternion = UnityEngine.Quaternion.LookRotation(-(arrayOfTarget[j] - arrayOfTracers[j].transform.position));
				arrayOfTracers[j].transform.rotation = quaternion;
				timeLerped += Time.deltaTime * speed;
				arrayOfTracers[j].transform.position = UnityEngine.Vector3.Lerp(startingPosition, arrayOfTarget[j], timeLerped / timeToLerp);
				continue;
			}
			arrayOfTracers[j].GetComponent<ParticleSystem>().Stop();
			if (played[j] == 1)
			{
				arrayOfExplos[j] = UnityEngine.Object.Instantiate(PrefOfExpl[currentexp], arrayOfTarget[j], targets[0].rotation);
				played[j] = 0;
				explore?.Play();
			}
		}
		if (played[amount - 1] != 0)
		{
			return;
		}
		timer += Time.deltaTime;
		if (timer >= 4f)
		{
			startingPosition = startpos.position;
			for (int k = 0; k <= amount - 1; k++)
			{
				played[k] = 1;
				UnityEngine.Object.Destroy(arrayOfExplos[k]);
				UnityEngine.Object.Destroy(arrayOfTracers[k]);
			}
			timeLerped = 0f;
			timeToLerp = 2f;
			timer = 0f;
			GenerTargets();
			currentexp++;
			if (currentexp == PrefOfExpl.Count)
			{
				currentexp = 0;
			}
		}
	}
}
namespace nTools.PrefabPainter
{
	public class PrefabPainterSceneSettings : MonoBehaviour
	{
		public GameObject parentForPrefabs;
	}
}
namespace ShatterToolkit
{
	public static class Tools
	{
		public static bool IsPointInsideTriangle(ref UnityEngine.Vector3 point, ref UnityEngine.Vector3 triangle0, ref UnityEngine.Vector3 triangle1, ref UnityEngine.Vector3 triangle2)
		{
			UnityEngine.Vector3 triangleNormal = UnityEngine.Vector3.Cross(triangle1 - triangle0, triangle2 - triangle0);
			return IsPointInsideTriangle(ref point, ref triangle0, ref triangle1, ref triangle2, ref triangleNormal);
		}

		public static bool IsPointInsideTriangle(ref UnityEngine.Vector3 point, ref UnityEngine.Vector3 triangle0, ref UnityEngine.Vector3 triangle1, ref UnityEngine.Vector3 triangle2, ref UnityEngine.Vector3 triangleNormal)
		{
			if (UnityEngine.Vector3.Cross(triangle1 - triangle0, triangle2 - triangle0) == UnityEngine.Vector3.zero)
			{
				return false;
			}
			UnityEngine.Vector3 vector = triangle0 - point;
			UnityEngine.Vector3 vector2 = triangle1 - point;
			UnityEngine.Vector3 vector3 = triangle2 - point;
			if (UnityEngine.Vector3.Dot(UnityEngine.Vector3.Cross(vector, vector2), triangleNormal) < 0f || UnityEngine.Vector3.Dot(UnityEngine.Vector3.Cross(vector2, vector3), triangleNormal) < 0f || UnityEngine.Vector3.Dot(UnityEngine.Vector3.Cross(vector3, vector), triangleNormal) < 0f)
			{
				return false;
			}
			return true;
		}
	}
	public class Edge
	{
		public int index;

		public Point point0;

		public Point point1;

		public UnityEngine.Vector3 line;

		public Edge(Point point0, Point point1)
		{
			this.point0 = point0;
			this.point1 = point1;
			line = point1.position - point0.position;
		}
	}
	public struct EdgeHit
	{
		public float scalar;

		public Edge splitA;

		public Edge splitB;
	}
	public class FastHull : IHull
	{
		protected static float smallestValidLength = 0.01f;

		protected static float smallestValidRatio = 0.05f;

		protected bool isValid = true;

		protected List<UnityEngine.Vector3> vertices;

		protected List<UnityEngine.Vector3> normals;

		protected List<Color32> colors;

		protected List<UnityEngine.Vector4> tangents;

		protected List<UnityEngine.Vector2> uvs;

		protected List<int> indices;

		public bool IsEmpty
		{
			get
			{
				if (isValid && vertices.Count >= 3)
				{
					return indices.Count < 3;
				}
				return true;
			}
		}

		public FastHull(Mesh mesh)
		{
			vertices = new List<UnityEngine.Vector3>(mesh.vertices);
			indices = new List<int>(mesh.triangles);
			if (mesh.normals.Length != 0)
			{
				normals = new List<UnityEngine.Vector3>(mesh.normals);
			}
			if (mesh.colors32.Length != 0)
			{
				colors = new List<Color32>(mesh.colors32);
			}
			if (mesh.tangents.Length != 0)
			{
				tangents = new List<UnityEngine.Vector4>(mesh.tangents);
			}
			if (mesh.uv.Length != 0)
			{
				uvs = new List<UnityEngine.Vector2>(mesh.uv);
			}
		}

		public FastHull(FastHull reference)
		{
			vertices = new List<UnityEngine.Vector3>(reference.vertices.Count);
			indices = new List<int>(reference.indices.Count);
			if (reference.normals != null)
			{
				normals = new List<UnityEngine.Vector3>(reference.normals.Count);
			}
			if (reference.colors != null)
			{
				colors = new List<Color32>(reference.colors.Count);
			}
			if (reference.tangents != null)
			{
				tangents = new List<UnityEngine.Vector4>(reference.tangents.Count);
			}
			if (reference.uvs != null)
			{
				uvs = new List<UnityEngine.Vector2>(reference.uvs.Count);
			}
		}

		public Mesh GetMesh()
		{
			if (isValid)
			{
				Mesh mesh = new Mesh();
				mesh.vertices = vertices.ToArray();
				mesh.triangles = indices.ToArray();
				if (normals != null)
				{
					mesh.normals = normals.ToArray();
				}
				if (colors != null)
				{
					mesh.colors32 = colors.ToArray();
				}
				if (tangents != null)
				{
					mesh.tangents = tangents.ToArray();
				}
				if (uvs != null)
				{
					mesh.uv = uvs.ToArray();
				}
				return mesh;
			}
			return null;
		}

		public void Split(UnityEngine.Vector3 localPointOnPlane, UnityEngine.Vector3 localPlaneNormal, bool fillCut, UvMapper uvMapper, ColorMapper colorMapper, out IHull resultA, out IHull resultB)
		{
			if (localPlaneNormal == UnityEngine.Vector3.zero)
			{
				localPlaneNormal = UnityEngine.Vector3.up;
			}
			FastHull fastHull = new FastHull(this);
			FastHull fastHull2 = new FastHull(this);
			AssignVertices(fastHull, fastHull2, localPointOnPlane, localPlaneNormal, out var vertexAbovePlane, out var oldToNewVertexMap);
			AssignTriangles(fastHull, fastHull2, vertexAbovePlane, oldToNewVertexMap, localPointOnPlane, localPlaneNormal, out var cutEdges);
			if (fillCut)
			{
				if (colors != null && colorMapper == null)
				{
					UnityEngine.Debug.LogWarning("Fill cut failed: A ColorMapper was not provided even though the mesh has a color channel");
				}
				else if ((tangents != null || uvs != null) && uvMapper == null)
				{
					UnityEngine.Debug.LogWarning("Fill cut failed: A UvMapper was not provided even though the mesh has a tangent/uv channel");
				}
				else
				{
					FillCutEdges(fastHull, fastHull2, cutEdges, localPlaneNormal, uvMapper, colorMapper);
				}
			}
			ValidateOutput(fastHull, fastHull2, localPlaneNormal);
			resultA = fastHull;
			resultB = fastHull2;
		}

		protected void AssignVertices(FastHull a, FastHull b, UnityEngine.Vector3 pointOnPlane, UnityEngine.Vector3 planeNormal, out bool[] vertexAbovePlane, out int[] oldToNewVertexMap)
		{
			vertexAbovePlane = new bool[vertices.Count];
			oldToNewVertexMap = new int[vertices.Count];
			for (int i = 0; i < vertices.Count; i++)
			{
				UnityEngine.Vector3 vector = vertices[i];
				bool flag = UnityEngine.Vector3.Dot(vector - pointOnPlane, planeNormal) >= 0f;
				vertexAbovePlane[i] = flag;
				if (flag)
				{
					oldToNewVertexMap[i] = a.vertices.Count;
					a.vertices.Add(vector);
					if (normals != null)
					{
						a.normals.Add(normals[i]);
					}
					if (colors != null)
					{
						a.colors.Add(colors[i]);
					}
					if (tangents != null)
					{
						a.tangents.Add(tangents[i]);
					}
					if (uvs != null)
					{
						a.uvs.Add(uvs[i]);
					}
				}
				else
				{
					oldToNewVertexMap[i] = b.vertices.Count;
					b.vertices.Add(vector);
					if (normals != null)
					{
						b.normals.Add(normals[i]);
					}
					if (colors != null)
					{
						b.colors.Add(colors[i]);
					}
					if (tangents != null)
					{
						b.tangents.Add(tangents[i]);
					}
					if (uvs != null)
					{
						b.uvs.Add(uvs[i]);
					}
				}
			}
		}

		protected void AssignTriangles(FastHull a, FastHull b, bool[] vertexAbovePlane, int[] oldToNewVertexMap, UnityEngine.Vector3 pointOnPlane, UnityEngine.Vector3 planeNormal, out IList<UnityEngine.Vector3> cutEdges)
		{
			cutEdges = new List<UnityEngine.Vector3>();
			int num = indices.Count / 3;
			for (int i = 0; i < num; i++)
			{
				int num2 = indices[i * 3];
				int num3 = indices[i * 3 + 1];
				int num4 = indices[i * 3 + 2];
				bool flag = vertexAbovePlane[num2];
				bool flag2 = vertexAbovePlane[num3];
				bool flag3 = vertexAbovePlane[num4];
				if (flag && flag2 && flag3)
				{
					a.indices.Add(oldToNewVertexMap[num2]);
					a.indices.Add(oldToNewVertexMap[num3]);
					a.indices.Add(oldToNewVertexMap[num4]);
					continue;
				}
				if (!flag && !flag2 && !flag3)
				{
					b.indices.Add(oldToNewVertexMap[num2]);
					b.indices.Add(oldToNewVertexMap[num3]);
					b.indices.Add(oldToNewVertexMap[num4]);
					continue;
				}
				int num5;
				int cw;
				int ccw;
				if (flag2 == flag3 && flag != flag2)
				{
					num5 = num2;
					cw = num3;
					ccw = num4;
				}
				else if (flag3 == flag && flag2 != flag3)
				{
					num5 = num3;
					cw = num4;
					ccw = num2;
				}
				else
				{
					num5 = num4;
					cw = num2;
					ccw = num3;
				}
				UnityEngine.Vector3 ccwIntersection;
				UnityEngine.Vector3 cwIntersection;
				if (vertexAbovePlane[num5])
				{
					SplitTriangle(a, b, oldToNewVertexMap, pointOnPlane, planeNormal, num5, cw, ccw, out ccwIntersection, out cwIntersection);
				}
				else
				{
					SplitTriangle(b, a, oldToNewVertexMap, pointOnPlane, planeNormal, num5, cw, ccw, out cwIntersection, out ccwIntersection);
				}
				if (ccwIntersection != cwIntersection)
				{
					cutEdges.Add(ccwIntersection);
					cutEdges.Add(cwIntersection);
				}
			}
		}

		protected void SplitTriangle(FastHull topHull, FastHull bottomHull, int[] oldToNewVertexMap, UnityEngine.Vector3 pointOnPlane, UnityEngine.Vector3 planeNormal, int top, int cw, int ccw, out UnityEngine.Vector3 cwIntersection, out UnityEngine.Vector3 ccwIntersection)
		{
			UnityEngine.Vector3 vector = vertices[top];
			UnityEngine.Vector3 vector2 = vertices[cw];
			UnityEngine.Vector3 vector3 = vertices[ccw];
			float num = UnityEngine.Vector3.Dot(vector2 - vector, planeNormal);
			float num2 = Mathf.Clamp01(UnityEngine.Vector3.Dot(pointOnPlane - vector, planeNormal) / num);
			float num3 = UnityEngine.Vector3.Dot(vector3 - vector, planeNormal);
			float num4 = Mathf.Clamp01(UnityEngine.Vector3.Dot(pointOnPlane - vector, planeNormal) / num3);
			UnityEngine.Vector3 vector4 = default(UnityEngine.Vector3);
			vector4.x = vector.x + (vector2.x - vector.x) * num2;
			vector4.y = vector.y + (vector2.y - vector.y) * num2;
			vector4.z = vector.z + (vector2.z - vector.z) * num2;
			UnityEngine.Vector3 vector5 = default(UnityEngine.Vector3);
			vector5.x = vector.x + (vector3.x - vector.x) * num4;
			vector5.y = vector.y + (vector3.y - vector.y) * num4;
			vector5.z = vector.z + (vector3.z - vector.z) * num4;
			int count = topHull.vertices.Count;
			topHull.vertices.Add(vector4);
			int count2 = topHull.vertices.Count;
			topHull.vertices.Add(vector5);
			topHull.indices.Add(oldToNewVertexMap[top]);
			topHull.indices.Add(count);
			topHull.indices.Add(count2);
			int count3 = bottomHull.vertices.Count;
			bottomHull.vertices.Add(vector4);
			int count4 = bottomHull.vertices.Count;
			bottomHull.vertices.Add(vector5);
			bottomHull.indices.Add(oldToNewVertexMap[cw]);
			bottomHull.indices.Add(oldToNewVertexMap[ccw]);
			bottomHull.indices.Add(count4);
			bottomHull.indices.Add(oldToNewVertexMap[cw]);
			bottomHull.indices.Add(count4);
			bottomHull.indices.Add(count3);
			if (normals != null)
			{
				UnityEngine.Vector3 vector6 = normals[top];
				UnityEngine.Vector3 vector7 = normals[cw];
				UnityEngine.Vector3 vector8 = normals[ccw];
				UnityEngine.Vector3 item = default(UnityEngine.Vector3);
				item.x = vector6.x + (vector7.x - vector6.x) * num2;
				item.y = vector6.y + (vector7.y - vector6.y) * num2;
				item.z = vector6.z + (vector7.z - vector6.z) * num2;
				item.Normalize();
				UnityEngine.Vector3 item2 = default(UnityEngine.Vector3);
				item2.x = vector6.x + (vector8.x - vector6.x) * num4;
				item2.y = vector6.y + (vector8.y - vector6.y) * num4;
				item2.z = vector6.z + (vector8.z - vector6.z) * num4;
				item2.Normalize();
				topHull.normals.Add(item);
				topHull.normals.Add(item2);
				bottomHull.normals.Add(item);
				bottomHull.normals.Add(item2);
			}
			if (colors != null)
			{
				Color32 a = colors[top];
				Color32 b = colors[cw];
				Color32 b2 = colors[ccw];
				Color32 item3 = Color32.Lerp(a, b, num2);
				Color32 item4 = Color32.Lerp(a, b2, num4);
				topHull.colors.Add(item3);
				topHull.colors.Add(item4);
				bottomHull.colors.Add(item3);
				bottomHull.colors.Add(item4);
			}
			if (tangents != null)
			{
				UnityEngine.Vector4 vector9 = tangents[top];
				UnityEngine.Vector4 vector10 = tangents[cw];
				UnityEngine.Vector4 vector11 = tangents[ccw];
				UnityEngine.Vector4 item5 = default(UnityEngine.Vector4);
				item5.x = vector9.x + (vector10.x - vector9.x) * num2;
				item5.y = vector9.y + (vector10.y - vector9.y) * num2;
				item5.z = vector9.z + (vector10.z - vector9.z) * num2;
				item5.Normalize();
				item5.w = vector10.w;
				UnityEngine.Vector4 item6 = default(UnityEngine.Vector4);
				item6.x = vector9.x + (vector11.x - vector9.x) * num4;
				item6.y = vector9.y + (vector11.y - vector9.y) * num4;
				item6.z = vector9.z + (vector11.z - vector9.z) * num4;
				item6.Normalize();
				item6.w = vector11.w;
				topHull.tangents.Add(item5);
				topHull.tangents.Add(item6);
				bottomHull.tangents.Add(item5);
				bottomHull.tangents.Add(item6);
			}
			if (uvs != null)
			{
				UnityEngine.Vector2 vector12 = uvs[top];
				UnityEngine.Vector2 vector13 = uvs[cw];
				UnityEngine.Vector2 vector14 = uvs[ccw];
				UnityEngine.Vector2 item7 = default(UnityEngine.Vector2);
				item7.x = vector12.x + (vector13.x - vector12.x) * num2;
				item7.y = vector12.y + (vector13.y - vector12.y) * num2;
				UnityEngine.Vector2 item8 = default(UnityEngine.Vector2);
				item8.x = vector12.x + (vector14.x - vector12.x) * num4;
				item8.y = vector12.y + (vector14.y - vector12.y) * num4;
				topHull.uvs.Add(item7);
				topHull.uvs.Add(item8);
				bottomHull.uvs.Add(item7);
				bottomHull.uvs.Add(item8);
			}
			cwIntersection = vector4;
			ccwIntersection = vector5;
		}

		protected void FillCutEdges(FastHull a, FastHull b, IList<UnityEngine.Vector3> edges, UnityEngine.Vector3 planeNormal, UvMapper uvMapper, ColorMapper colorMapper)
		{
			int num = edges.Count / 2;
			List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>(num);
			List<int> list2 = new List<int>(num * 2);
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				int num3 = i + 1;
				int num4 = num2;
				float num5 = (edges[i * 2 + 1] - edges[num2 * 2]).sqrMagnitude;
				for (int j = num3; j < num; j++)
				{
					float sqrMagnitude = (edges[i * 2 + 1] - edges[j * 2]).sqrMagnitude;
					if (sqrMagnitude < num5)
					{
						num4 = j;
						num5 = sqrMagnitude;
					}
				}
				if (num4 == num2 && i > num2)
				{
					int count = list.Count;
					int item = count;
					for (int k = num2; k < i; k++)
					{
						list.Add(edges[k * 2]);
						list2.Add(item++);
						list2.Add(item);
					}
					list.Add(edges[i * 2]);
					list2.Add(item);
					list2.Add(count);
					num2 = num3;
				}
				else if (num3 < num)
				{
					UnityEngine.Vector3 value = edges[num3 * 2];
					UnityEngine.Vector3 value2 = edges[num3 * 2 + 1];
					edges[num3 * 2] = edges[num4 * 2];
					edges[num3 * 2 + 1] = edges[num4 * 2 + 1];
					edges[num4 * 2] = value;
					edges[num4 * 2 + 1] = value2;
				}
			}
			if (list.Count <= 0)
			{
				return;
			}
			((ITriangulator)new Triangulator(list, list2, planeNormal)).Fill(out int[] _, out int[] newTriangles, out int[] _);
			int count2 = a.vertices.Count;
			int count3 = b.vertices.Count;
			a.vertices.AddRange(list);
			b.vertices.AddRange(list);
			if (normals != null)
			{
				UnityEngine.Vector3 item2 = -planeNormal;
				for (int l = 0; l < list.Count; l++)
				{
					a.normals.Add(item2);
					b.normals.Add(planeNormal);
				}
			}
			if (colors != null)
			{
				colorMapper.Map(list, planeNormal, out var colorsA, out var colorsB);
				a.colors.AddRange(colorsA);
				b.colors.AddRange(colorsB);
			}
			if (tangents != null || uvs != null)
			{
				uvMapper.Map(list, planeNormal, out var tangentsA, out var tangentsB, out var uvsA, out var uvsB);
				if (tangents != null)
				{
					a.tangents.AddRange(tangentsA);
					b.tangents.AddRange(tangentsB);
				}
				if (uvs != null)
				{
					a.uvs.AddRange(uvsA);
					b.uvs.AddRange(uvsB);
				}
			}
			int num6 = newTriangles.Length / 3;
			for (int m = 0; m < num6; m++)
			{
				a.indices.Add(count2 + newTriangles[m * 3]);
				a.indices.Add(count2 + newTriangles[m * 3 + 2]);
				a.indices.Add(count2 + newTriangles[m * 3 + 1]);
				b.indices.Add(count3 + newTriangles[m * 3]);
				b.indices.Add(count3 + newTriangles[m * 3 + 1]);
				b.indices.Add(count3 + newTriangles[m * 3 + 2]);
			}
		}

		protected void ValidateOutput(FastHull a, FastHull b, UnityEngine.Vector3 planeNormal)
		{
			float num = a.LengthAlongAxis(planeNormal);
			float num2 = b.LengthAlongAxis(planeNormal);
			float num3 = num + num2;
			if (num3 < smallestValidLength)
			{
				a.isValid = false;
				b.isValid = false;
			}
			else if (num / num3 < smallestValidRatio)
			{
				a.isValid = false;
			}
			else if (num2 / num3 < smallestValidRatio)
			{
				b.isValid = false;
			}
		}

		protected float LengthAlongAxis(UnityEngine.Vector3 axis)
		{
			if (vertices.Count > 0)
			{
				float num = UnityEngine.Vector3.Dot(vertices[0], axis);
				float num2 = num;
				foreach (UnityEngine.Vector3 vertex in vertices)
				{
					float a = UnityEngine.Vector3.Dot(vertex, axis);
					num = Mathf.Min(a, num);
					num2 = Mathf.Max(a, num2);
				}
				return num2 - num;
			}
			return 0f;
		}
	}
	public enum HullType
	{
		FastHull,
		LegacyHull
	}
	public interface IHull
	{
		bool IsEmpty { get; }

		Mesh GetMesh();

		void Split(UnityEngine.Vector3 localPointOnPlane, UnityEngine.Vector3 localPlaneNormal, bool fillCut, UvMapper uvMapper, ColorMapper colorMapper, out IHull resultA, out IHull resultB);
	}
	public class LegacyHull : IHull
	{
		protected static float smallestValidLength = 0.01f;

		protected static float smallestValidRatio = 0.05f;

		protected UnityEngine.Object key = new UnityEngine.Object();

		protected IList<UnityEngine.Vector3> vertices;

		protected IList<UnityEngine.Vector3> normals;

		protected IList<UnityEngine.Vector4> tangents;

		protected IList<UnityEngine.Vector2> uvs;

		protected IList<Point> vertexToPointMap;

		protected IList<Point> points;

		protected IList<Edge> edges;

		protected IList<Triangle> triangles;

		public bool IsEmpty
		{
			get
			{
				lock (key)
				{
					return points.Count < 3 || edges.Count < 3 || triangles.Count < 1;
				}
			}
		}

		public LegacyHull(Mesh mesh)
		{
			vertices = new List<UnityEngine.Vector3>(mesh.vertices);
			normals = new List<UnityEngine.Vector3>(mesh.normals);
			tangents = new List<UnityEngine.Vector4>(mesh.tangents);
			uvs = new List<UnityEngine.Vector2>(mesh.uv);
			vertexToPointMap = new List<Point>(vertices.Count);
			points = new List<Point>();
			edges = new List<Edge>();
			triangles = new List<Triangle>();
			for (int i = 0; i < vertices.Count; i++)
			{
				AddUniquePoint(vertices[i], out var uniquePoint);
				vertexToPointMap.Add(uniquePoint);
			}
			int[] array = mesh.triangles;
			for (int j = 0; j < array.Length / 3; j++)
			{
				int num = j * 3;
				AddTriangle(array[num], array[num + 1], array[num + 2]);
			}
		}

		public LegacyHull(LegacyHull reference)
		{
			int capacity = reference.vertices.Count * 2;
			vertices = new List<UnityEngine.Vector3>(capacity);
			normals = new List<UnityEngine.Vector3>(capacity);
			tangents = new List<UnityEngine.Vector4>(capacity);
			uvs = new List<UnityEngine.Vector2>(capacity);
			vertexToPointMap = new List<Point>(capacity);
			points = new List<Point>(reference.points.Count * 2);
			edges = new List<Edge>(reference.edges.Count * 2);
			triangles = new List<Triangle>(reference.triangles.Count * 2);
		}

		protected void AddUniquePoint(UnityEngine.Vector3 position, out Point uniquePoint)
		{
			foreach (Point point in points)
			{
				if (point.position == position)
				{
					uniquePoint = point;
					return;
				}
			}
			uniquePoint = new Point(position);
			points.Add(uniquePoint);
		}

		protected void AddUniqueEdge(Point point0, Point point1, out Edge uniqueEdge)
		{
			foreach (Edge edge in edges)
			{
				if ((edge.point0 == point0 && edge.point1 == point1) || (edge.point0 == point1 && edge.point1 == point0))
				{
					uniqueEdge = edge;
					return;
				}
			}
			uniqueEdge = new Edge(point0, point1);
			edges.Add(uniqueEdge);
		}

		protected void AddTriangle(int vertex0, int vertex1, int vertex2)
		{
			Point point = vertexToPointMap[vertex0];
			Point point2 = vertexToPointMap[vertex1];
			Point point3 = vertexToPointMap[vertex2];
			AddUniqueEdge(point, point2, out var uniqueEdge);
			AddUniqueEdge(point2, point3, out var uniqueEdge2);
			AddUniqueEdge(point3, point, out var uniqueEdge3);
			Triangle item = new Triangle(vertex0, vertex1, vertex2, point, point2, point3, uniqueEdge, uniqueEdge2, uniqueEdge3);
			triangles.Add(item);
		}

		protected void AddVertex(UnityEngine.Vector3 vertex, UnityEngine.Vector3 normal, UnityEngine.Vector4 tangent, UnityEngine.Vector2 uv, Point point, out int index)
		{
			index = vertices.Count;
			vertices.Add(vertex);
			normals.Add(normal);
			tangents.Add(tangent);
			uvs.Add(uv);
			vertexToPointMap.Add(point);
		}

		public void Clear()
		{
			lock (key)
			{
				vertices.Clear();
				normals.Clear();
				tangents.Clear();
				uvs.Clear();
				vertexToPointMap.Clear();
				points.Clear();
				edges.Clear();
				triangles.Clear();
			}
		}

		public Mesh GetMesh()
		{
			lock (key)
			{
				if (!IsEmpty)
				{
					UnityEngine.Vector3[] array = new UnityEngine.Vector3[vertices.Count];
					UnityEngine.Vector3[] array2 = new UnityEngine.Vector3[normals.Count];
					UnityEngine.Vector4[] array3 = new UnityEngine.Vector4[tangents.Count];
					UnityEngine.Vector2[] array4 = new UnityEngine.Vector2[uvs.Count];
					vertices.CopyTo(array, 0);
					normals.CopyTo(array2, 0);
					tangents.CopyTo(array3, 0);
					uvs.CopyTo(array4, 0);
					int[] array5 = new int[triangles.Count * 3];
					int num = 0;
					foreach (Triangle triangle in triangles)
					{
						array5[num++] = triangle.vertex0;
						array5[num++] = triangle.vertex1;
						array5[num++] = triangle.vertex2;
					}
					return new Mesh
					{
						vertices = array,
						normals = array2,
						tangents = array3,
						uv = array4,
						triangles = array5
					};
				}
				return null;
			}
		}

		public void Split(UnityEngine.Vector3 localPointOnPlane, UnityEngine.Vector3 localPlaneNormal, bool fillCut, UvMapper uvMapper, ColorMapper colorMapper, out IHull resultA, out IHull resultB)
		{
			lock (key)
			{
				if (localPlaneNormal == UnityEngine.Vector3.zero)
				{
					localPlaneNormal = UnityEngine.Vector3.up;
				}
				LegacyHull legacyHull = new LegacyHull(this);
				LegacyHull legacyHull2 = new LegacyHull(this);
				SetIndices();
				AssignPoints(legacyHull, legacyHull2, localPointOnPlane, localPlaneNormal, out var pointAbovePlane);
				AssignVertices(legacyHull, legacyHull2, pointAbovePlane, out var oldToNewVertex);
				AssignEdges(legacyHull, legacyHull2, pointAbovePlane, localPointOnPlane, localPlaneNormal, out var edgeIntersectsPlane, out var edgeHits);
				AssignTriangles(legacyHull, legacyHull2, pointAbovePlane, edgeIntersectsPlane, edgeHits, oldToNewVertex, out var cutEdgesA, out var cutEdgesB);
				if (fillCut)
				{
					SortCutEdges(cutEdgesA, cutEdgesB);
					FillCutEdges(legacyHull, legacyHull2, cutEdgesA, cutEdgesB, localPlaneNormal, uvMapper);
				}
				ValidateOutput(legacyHull, legacyHull2, localPlaneNormal);
				Clear();
				resultA = legacyHull;
				resultB = legacyHull2;
			}
		}

		protected void SetIndices()
		{
			int num = 0;
			foreach (Point point in points)
			{
				point.index = num++;
			}
			int num2 = 0;
			foreach (Edge edge in edges)
			{
				edge.index = num2++;
			}
		}

		protected void AssignPoints(LegacyHull a, LegacyHull b, UnityEngine.Vector3 pointOnPlane, UnityEngine.Vector3 planeNormal, out bool[] pointAbovePlane)
		{
			pointAbovePlane = new bool[points.Count];
			foreach (Point point in points)
			{
				bool flag = UnityEngine.Vector3.Dot(point.position - pointOnPlane, planeNormal) >= 0f;
				pointAbovePlane[point.index] = flag;
				if (flag)
				{
					a.points.Add(point);
				}
				else
				{
					b.points.Add(point);
				}
			}
		}

		protected void AssignVertices(LegacyHull a, LegacyHull b, bool[] pointAbovePlane, out int[] oldToNewVertex)
		{
			oldToNewVertex = new int[vertices.Count];
			for (int i = 0; i < vertices.Count; i++)
			{
				Point point = vertexToPointMap[i];
				if (pointAbovePlane[point.index])
				{
					a.AddVertex(vertices[i], normals[i], tangents[i], uvs[i], point, out oldToNewVertex[i]);
				}
				else
				{
					b.AddVertex(vertices[i], normals[i], tangents[i], uvs[i], point, out oldToNewVertex[i]);
				}
			}
		}

		protected void AssignEdges(LegacyHull a, LegacyHull b, bool[] pointAbovePlane, UnityEngine.Vector3 pointOnPlane, UnityEngine.Vector3 planeNormal, out bool[] edgeIntersectsPlane, out EdgeHit[] edgeHits)
		{
			edgeIntersectsPlane = new bool[edges.Count];
			edgeHits = new EdgeHit[edges.Count];
			foreach (Edge edge3 in edges)
			{
				bool flag = pointAbovePlane[edge3.point0.index];
				bool flag2 = pointAbovePlane[edge3.point1.index];
				if (flag && flag2)
				{
					a.edges.Add(edge3);
					continue;
				}
				if (!flag && !flag2)
				{
					b.edges.Add(edge3);
					continue;
				}
				float num = UnityEngine.Vector3.Dot(edge3.line, planeNormal);
				float num2 = Mathf.Clamp01(UnityEngine.Vector3.Dot(pointOnPlane - edge3.point0.position, planeNormal) / num);
				UnityEngine.Vector3 position = edge3.point0.position + edge3.line * num2;
				Point point = new Point(position);
				Point point2 = new Point(position);
				a.points.Add(point);
				b.points.Add(point2);
				Edge edge;
				Edge edge2;
				if (pointAbovePlane[edge3.point0.index])
				{
					edge = new Edge(point, edge3.point0);
					edge2 = new Edge(point2, edge3.point1);
				}
				else
				{
					edge = new Edge(point, edge3.point1);
					edge2 = new Edge(point2, edge3.point0);
				}
				a.edges.Add(edge);
				b.edges.Add(edge2);
				edgeIntersectsPlane[edge3.index] = true;
				edgeHits[edge3.index] = default(EdgeHit);
				edgeHits[edge3.index].scalar = num2;
				edgeHits[edge3.index].splitA = edge;
				edgeHits[edge3.index].splitB = edge2;
			}
		}

		protected void AssignTriangles(LegacyHull a, LegacyHull b, bool[] pointAbovePlane, bool[] edgeIntersectsPlane, EdgeHit[] edgeHits, int[] oldToNewVertex, out IList<Edge> cutEdgesA, out IList<Edge> cutEdgesB)
		{
			cutEdgesA = new List<Edge>();
			cutEdgesB = new List<Edge>();
			foreach (Triangle triangle in triangles)
			{
				bool flag = pointAbovePlane[triangle.point0.index];
				bool flag2 = pointAbovePlane[triangle.point1.index];
				bool flag3 = pointAbovePlane[triangle.point2.index];
				if (flag && flag2 && flag3)
				{
					triangle.vertex0 = oldToNewVertex[triangle.vertex0];
					triangle.vertex1 = oldToNewVertex[triangle.vertex1];
					triangle.vertex2 = oldToNewVertex[triangle.vertex2];
					a.triangles.Add(triangle);
					continue;
				}
				if (!flag && !flag2 && !flag3)
				{
					triangle.vertex0 = oldToNewVertex[triangle.vertex0];
					triangle.vertex1 = oldToNewVertex[triangle.vertex1];
					triangle.vertex2 = oldToNewVertex[triangle.vertex2];
					b.triangles.Add(triangle);
					continue;
				}
				Point point;
				Edge edge;
				Edge edge2;
				Edge bottomEdge;
				int vertex;
				int vertex2;
				int vertex3;
				if (edgeIntersectsPlane[triangle.edge0.index] && edgeIntersectsPlane[triangle.edge1.index])
				{
					point = triangle.point1;
					edge = triangle.edge0;
					edge2 = triangle.edge1;
					bottomEdge = triangle.edge2;
					vertex = triangle.vertex0;
					vertex2 = triangle.vertex1;
					vertex3 = triangle.vertex2;
				}
				else if (edgeIntersectsPlane[triangle.edge1.index] && edgeIntersectsPlane[triangle.edge2.index])
				{
					point = triangle.point2;
					edge = triangle.edge1;
					edge2 = triangle.edge2;
					bottomEdge = triangle.edge0;
					vertex = triangle.vertex1;
					vertex2 = triangle.vertex2;
					vertex3 = triangle.vertex0;
				}
				else
				{
					point = triangle.point0;
					edge = triangle.edge2;
					edge2 = triangle.edge0;
					bottomEdge = triangle.edge1;
					vertex = triangle.vertex2;
					vertex2 = triangle.vertex0;
					vertex3 = triangle.vertex1;
				}
				EdgeHit edgeHit = edgeHits[edge.index];
				EdgeHit edgeHit2 = edgeHits[edge2.index];
				float scalar = ((point == edge.point1) ? edgeHit.scalar : (1f - edgeHit.scalar));
				float scalar2 = ((point == edge2.point0) ? edgeHit2.scalar : (1f - edgeHit2.scalar));
				Edge edge3;
				Edge edge4;
				if (pointAbovePlane[point.index])
				{
					edge3 = new Edge(edgeHit2.splitA.point0, edgeHit.splitA.point0);
					edge4 = new Edge(edgeHit2.splitB.point0, edgeHit.splitB.point0);
					a.edges.Add(edge3);
					b.edges.Add(edge4);
					SplitTriangle(a, b, edgeHit.splitA, edgeHit2.splitA, edge3, edgeHit.splitB, edgeHit2.splitB, edge4, bottomEdge, vertex, vertex2, vertex3, scalar, scalar2, oldToNewVertex);
				}
				else
				{
					edge3 = new Edge(edgeHit.splitA.point0, edgeHit2.splitA.point0);
					edge4 = new Edge(edgeHit.splitB.point0, edgeHit2.splitB.point0);
					a.edges.Add(edge3);
					b.edges.Add(edge4);
					SplitTriangle(b, a, edgeHit.splitB, edgeHit2.splitB, edge4, edgeHit.splitA, edgeHit2.splitA, edge3, bottomEdge, vertex, vertex2, vertex3, scalar, scalar2, oldToNewVertex);
				}
				cutEdgesA.Add(edge3);
				cutEdgesB.Add(edge4);
			}
		}

		protected void SplitTriangle(LegacyHull topHull, LegacyHull bottomHull, Edge topEdge0, Edge topEdge1, Edge topCutEdge, Edge bottomEdge0, Edge bottomEdge1, Edge bottomCutEdge, Edge bottomEdge2, int vertex0, int vertex1, int vertex2, float scalar0, float scalar1, int[] oldToNewVertex)
		{
			UnityEngine.Vector3 vector = normals[vertex0];
			UnityEngine.Vector3 vector2 = normals[vertex1];
			UnityEngine.Vector3 vector3 = normals[vertex2];
			UnityEngine.Vector4 vector4 = tangents[vertex0];
			UnityEngine.Vector4 vector5 = tangents[vertex1];
			UnityEngine.Vector4 vector6 = tangents[vertex2];
			UnityEngine.Vector2 vector7 = uvs[vertex0];
			UnityEngine.Vector2 vector8 = uvs[vertex1];
			UnityEngine.Vector2 vector9 = uvs[vertex2];
			UnityEngine.Vector3 normal = default(UnityEngine.Vector3);
			normal.x = vector.x + (vector2.x - vector.x) * scalar0;
			normal.y = vector.y + (vector2.y - vector.y) * scalar0;
			normal.z = vector.z + (vector2.z - vector.z) * scalar0;
			normal.Normalize();
			UnityEngine.Vector3 normal2 = default(UnityEngine.Vector3);
			normal2.x = vector2.x + (vector3.x - vector2.x) * scalar1;
			normal2.y = vector2.y + (vector3.y - vector2.y) * scalar1;
			normal2.z = vector2.z + (vector3.z - vector2.z) * scalar1;
			normal2.Normalize();
			UnityEngine.Vector4 tangent = default(UnityEngine.Vector4);
			tangent.x = vector4.x + (vector5.x - vector4.x) * scalar0;
			tangent.y = vector4.y + (vector5.y - vector4.y) * scalar0;
			tangent.z = vector4.z + (vector5.z - vector4.z) * scalar0;
			tangent.Normalize();
			tangent.w = vector4.w;
			UnityEngine.Vector4 tangent2 = default(UnityEngine.Vector4);
			tangent2.x = vector5.x + (vector6.x - vector5.x) * scalar1;
			tangent2.y = vector5.y + (vector6.y - vector5.y) * scalar1;
			tangent2.z = vector5.z + (vector6.z - vector5.z) * scalar1;
			tangent2.Normalize();
			tangent2.w = vector5.w;
			UnityEngine.Vector2 uv = default(UnityEngine.Vector2);
			uv.x = vector7.x + (vector8.x - vector7.x) * scalar0;
			uv.y = vector7.y + (vector8.y - vector7.y) * scalar0;
			UnityEngine.Vector2 uv2 = default(UnityEngine.Vector2);
			uv2.x = vector8.x + (vector9.x - vector8.x) * scalar1;
			uv2.y = vector8.y + (vector9.y - vector8.y) * scalar1;
			topHull.AddVertex(topEdge0.point0.position, normal, tangent, uv, topEdge0.point0, out var index);
			topHull.AddVertex(topEdge1.point0.position, normal2, tangent2, uv2, topEdge1.point0, out var index2);
			bottomHull.AddVertex(bottomEdge0.point0.position, normal, tangent, uv, bottomEdge0.point0, out var index3);
			bottomHull.AddVertex(bottomEdge1.point0.position, normal2, tangent2, uv2, bottomEdge1.point0, out var index4);
			Triangle item = new Triangle(index, oldToNewVertex[vertex1], index2, topEdge0.point0, topEdge0.point1, topEdge1.point0, topEdge0, topEdge1, topCutEdge);
			topHull.triangles.Add(item);
			Edge edge = new Edge(bottomEdge0.point1, bottomEdge1.point0);
			Triangle item2 = new Triangle(oldToNewVertex[vertex0], index3, index4, bottomEdge0.point1, bottomEdge0.point0, bottomEdge1.point0, bottomEdge0, bottomCutEdge, edge);
			Triangle item3 = new Triangle(oldToNewVertex[vertex0], index4, oldToNewVertex[vertex2], bottomEdge0.point1, bottomEdge1.point0, bottomEdge1.point1, edge, bottomEdge1, bottomEdge2);
			bottomHull.edges.Add(edge);
			bottomHull.triangles.Add(item2);
			bottomHull.triangles.Add(item3);
		}

		protected void SortCutEdges(IList<Edge> edgesA, IList<Edge> edgesB)
		{
			Edge edge = null;
			for (int i = 0; i < edgesA.Count; i++)
			{
				if (edge == null)
				{
					edge = edgesA[i];
					continue;
				}
				Edge edge2 = edgesA[i - 1];
				for (int j = i; j < edgesA.Count; j++)
				{
					Edge edge3 = edgesA[j];
					if (edge2.point1 == edge3.point0)
					{
						Edge value = edgesA[i];
						edgesA[i] = edge3;
						edgesA[j] = value;
						Edge value2 = edgesB[i];
						edgesB[i] = edgesB[j];
						edgesB[j] = value2;
						if (edge3.point1 == edge.point0)
						{
							edge = null;
						}
						break;
					}
				}
			}
		}

		protected void FillCutEdges(LegacyHull a, LegacyHull b, IList<Edge> edgesA, IList<Edge> edgesB, UnityEngine.Vector3 planeNormal, UvMapper uvMapper)
		{
			int count = edgesA.Count;
			UnityEngine.Vector3[] array = new UnityEngine.Vector3[count];
			int[] array2 = new int[count * 2];
			int num = 0;
			for (int i = 0; i < count; i++)
			{
				int num2 = i;
				int num3 = (i + 1) % count;
				Edge edge = edgesA[num2];
				Edge edge2 = edgesA[num3];
				array[i] = edge.point0.position;
				array2[i * 2] = num2;
				if (edge.point1 == edge2.point0)
				{
					array2[i * 2 + 1] = num3;
					continue;
				}
				array2[i * 2 + 1] = num;
				num = num3;
			}
			((ITriangulator)new Triangulator(array, array2, planeNormal)).Fill(out int[] newEdges, out int[] newTriangles, out int[] newTriangleEdges);
			UnityEngine.Vector3 normal = -planeNormal;
			uvMapper.Map(array, planeNormal, out var tangentsA, out var tangentsB, out var uvsA, out var uvsB);
			int[] array3 = new int[count];
			int[] array4 = new int[count];
			for (int j = 0; j < count; j++)
			{
				a.AddVertex(array[j], normal, tangentsA[j], uvsA[j], edgesA[j].point0, out array3[j]);
				b.AddVertex(array[j], planeNormal, tangentsB[j], uvsB[j], edgesB[j].point0, out array4[j]);
			}
			for (int k = 0; k < newEdges.Length / 2; k++)
			{
				int index = newEdges[k * 2];
				int index2 = newEdges[k * 2 + 1];
				Edge item = new Edge(edgesA[index].point0, edgesA[index2].point0);
				Edge item2 = new Edge(edgesB[index].point0, edgesB[index2].point0);
				edgesA.Add(item);
				edgesB.Add(item2);
				a.edges.Add(item);
				b.edges.Add(item2);
			}
			for (int l = 0; l < newTriangles.Length / 3; l++)
			{
				int num4 = newTriangles[l * 3];
				int num5 = newTriangles[l * 3 + 1];
				int num6 = newTriangles[l * 3 + 2];
				int index3 = newTriangleEdges[l * 3];
				int index4 = newTriangleEdges[l * 3 + 1];
				int index5 = newTriangleEdges[l * 3 + 2];
				Triangle item3 = new Triangle(array3[num4], array3[num6], array3[num5], edgesA[num4].point0, edgesA[num6].point0, edgesA[num5].point0, edgesA[index5], edgesA[index4], edgesA[index3]);
				Triangle item4 = new Triangle(array4[num4], array4[num5], array4[num6], edgesB[num4].point0, edgesB[num5].point0, edgesB[num6].point0, edgesB[index3], edgesB[index4], edgesB[index5]);
				a.triangles.Add(item3);
				b.triangles.Add(item4);
			}
		}

		protected void ValidateOutput(LegacyHull a, LegacyHull b, UnityEngine.Vector3 planeNormal)
		{
			float num = a.LengthAlongAxis(planeNormal);
			float num2 = b.LengthAlongAxis(planeNormal);
			float num3 = num + num2;
			if (num3 < smallestValidLength)
			{
				a.Clear();
				b.Clear();
			}
			else if (num / num3 < smallestValidRatio)
			{
				a.Clear();
			}
			else if (num2 / num3 < smallestValidRatio)
			{
				b.Clear();
			}
		}

		protected float LengthAlongAxis(UnityEngine.Vector3 axis)
		{
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < points.Count; i++)
			{
				float num3 = UnityEngine.Vector3.Dot(points[i].position, axis);
				if (i == 0)
				{
					num = num3;
					num2 = num3;
				}
				else
				{
					num = Mathf.Min(num3, num);
					num2 = Mathf.Max(num3, num2);
				}
			}
			return num2 - num;
		}
	}
	public class Point
	{
		public int index;

		public UnityEngine.Vector3 position;

		public Point(UnityEngine.Vector3 position)
		{
			this.position = position;
		}
	}
	public class Triangle
	{
		public int vertex0;

		public int vertex1;

		public int vertex2;

		public Point point0;

		public Point point1;

		public Point point2;

		public Edge edge0;

		public Edge edge1;

		public Edge edge2;

		public Triangle(int vertex0, int vertex1, int vertex2, Point point0, Point point1, Point point2, Edge edge0, Edge edge1, Edge edge2)
		{
			this.vertex0 = vertex0;
			this.vertex1 = vertex1;
			this.vertex2 = vertex2;
			this.point0 = point0;
			this.point1 = point1;
			this.point2 = point2;
			this.edge0 = edge0;
			this.edge1 = edge1;
			this.edge2 = edge2;
		}
	}
	public interface ITriangulator
	{
		void Fill(out int[] newEdges, out int[] newTriangles, out int[] newTriangleEdges);
	}
	public class Triangulator : ITriangulator
	{
		protected List<UnityEngine.Vector3> points;

		protected List<int> edges;

		protected List<int> triangles;

		protected List<int> triangleEdges;

		protected List<List<int>> loops;

		protected List<List<bool>> concavities;

		protected List<int> duplicateEdges;

		protected UnityEngine.Vector3 planeNormal;

		protected int originalEdgeCount;

		public Triangulator(IList<UnityEngine.Vector3> points, IList<int> edges, UnityEngine.Vector3 planeNormal)
		{
			this.points = new List<UnityEngine.Vector3>(points);
			this.edges = new List<int>(edges);
			triangles = new List<int>();
			triangleEdges = new List<int>();
			this.planeNormal = planeNormal;
			originalEdgeCount = this.edges.Count;
		}

		public void Fill(out int[] newEdges, out int[] newTriangles, out int[] newTriangleEdges)
		{
			FindLoops();
			FindConcavities();
			PrepareDuplicateEdges();
			for (int i = 0; i < loops.Count; i++)
			{
				List<int> list = loops[i];
				List<bool> list2 = concavities[i];
				int num = 0;
				int num2 = 0;
				while (list.Count >= 3)
				{
					int zero = ((num == 0) ? (list.Count - 1) : (num - 1));
					int num3 = num;
					int second = (num + 1) % list.Count;
					int third = (num + 2) % list.Count;
					if (list2[num3] || IsTriangleOverlappingLoop(num3, second, third, list, list2))
					{
						num++;
						num2++;
					}
					else
					{
						if (MergeLoops(num3, second, third, list, list2, out var swallowedLoopIndex))
						{
							if (swallowedLoopIndex < i)
							{
								i--;
							}
						}
						else
						{
							FillTriangle(zero, num3, second, third, list, list2);
						}
						num2 = 0;
					}
					if (num2 >= list.Count)
					{
						break;
					}
					if (num >= list.Count)
					{
						num = 0;
						num2 = 0;
					}
				}
				if (list.Count <= 2)
				{
					loops.RemoveAt(i);
					concavities.RemoveAt(i);
					i--;
				}
			}
			for (int j = 0; j < loops.Count; j++)
			{
				List<int> list3 = loops[j];
				List<bool> concavity = concavities[j];
				while (list3.Count >= 3)
				{
					FillTriangle(0, 1, 2, 3 % list3.Count, list3, concavity);
				}
			}
			RemoveDuplicateEdges();
			SetOutput(out newEdges, out newTriangles, out newTriangleEdges);
		}

		protected void FindLoops()
		{
			loops = new List<List<int>>();
			List<int> list = new List<int>(edges.Count / 2);
			for (int i = 0; i < edges.Count / 2; i++)
			{
				int num = i * 2;
				int num2 = edges[num];
				int num3 = edges[num + 1];
				if (list.Count >= 1)
				{
					int num4 = edges[num - 1];
					if (num2 != num4)
					{
						UnityEngine.Debug.LogError("The edges do not form an edge loop!");
					}
				}
				list.Add(num);
				if (num3 == edges[list[0]])
				{
					loops.Add(list);
					list = new List<int>();
				}
			}
		}

		protected void FindConcavities()
		{
			concavities = new List<List<bool>>();
			foreach (List<int> loop in loops)
			{
				List<bool> list = new List<bool>(loop.Count);
				for (int i = 0; i < loop.Count; i++)
				{
					int index = edges[loop[i]];
					int index2 = edges[loop[(i + 1) % loop.Count]];
					int index3 = edges[loop[(i + 2) % loop.Count]];
					UnityEngine.Vector3 line = points[index2] - points[index];
					UnityEngine.Vector3 line2 = points[index3] - points[index2];
					list.Add(IsLinePairConcave(ref line, ref line2));
				}
				concavities.Add(list);
			}
		}

		protected void PrepareDuplicateEdges()
		{
			duplicateEdges = new List<int>();
		}

		protected void ValidateConcavities()
		{
			for (int i = 0; i < loops.Count; i++)
			{
				IList<int> list = loops[i];
				IList<bool> list2 = concavities[i];
				for (int j = 0; j < list.Count; j++)
				{
					int index = edges[list[j]];
					int index2 = edges[list[(j + 1) % list.Count]];
					int index3 = edges[list[(j + 2) % list.Count]];
					UnityEngine.Vector3 line = points[index2] - points[index];
					UnityEngine.Vector3 line2 = points[index3] - points[index2];
					if (list2[j] != IsLinePairConcave(ref line, ref line2))
					{
						UnityEngine.Debug.LogError("Concavity not valid!");
					}
				}
			}
		}

		protected void UpdateConcavity(int index, List<int> loop, List<bool> concavity)
		{
			int num = loop[index];
			int num2 = loop[(index + 1) % loop.Count];
			UnityEngine.Vector3 line = points[edges[num + 1]] - points[edges[num]];
			UnityEngine.Vector3 line2 = points[edges[num2 + 1]] - points[edges[num2]];
			concavity[index] = IsLinePairConcave(ref line, ref line2);
		}

		protected bool IsLinePairConcave(ref UnityEngine.Vector3 line0, ref UnityEngine.Vector3 line1)
		{
			UnityEngine.Vector3 rhs = UnityEngine.Vector3.Cross(line0, planeNormal);
			return UnityEngine.Vector3.Dot(line1, rhs) > 0f;
		}

		protected bool IsTriangleOverlappingLoop(int first, int second, int third, List<int> loop, List<bool> concavity)
		{
			int num = edges[loop[first]];
			int num2 = edges[loop[second]];
			int num3 = edges[loop[third]];
			UnityEngine.Vector3 triangle = points[num];
			UnityEngine.Vector3 triangle2 = points[num2];
			UnityEngine.Vector3 triangle3 = points[num3];
			for (int i = 0; i < loop.Count; i++)
			{
				if (!concavity[i])
				{
					continue;
				}
				int num4 = edges[loop[i] + 1];
				if (num4 != num && num4 != num2 && num4 != num3)
				{
					UnityEngine.Vector3 point = points[num4];
					if (Tools.IsPointInsideTriangle(ref point, ref triangle, ref triangle2, ref triangle3, ref planeNormal))
					{
						return true;
					}
				}
			}
			return false;
		}

		protected bool MergeLoops(int first, int second, int third, List<int> loop, List<bool> concavity, out int swallowedLoopIndex)
		{
			if (FindClosestPointInTriangle(first, second, third, loop, out var loopIndex, out var loopLocation))
			{
				InsertLoop(first, loop, concavity, loopLocation, loops[loopIndex], concavities[loopIndex]);
				loops.RemoveAt(loopIndex);
				concavities.RemoveAt(loopIndex);
				swallowedLoopIndex = loopIndex;
				return true;
			}
			swallowedLoopIndex = -1;
			return false;
		}

		protected bool FindClosestPointInTriangle(int first, int second, int third, List<int> loop, out int loopIndex, out int loopLocation)
		{
			UnityEngine.Vector3 triangle = points[edges[loop[first]]];
			UnityEngine.Vector3 triangle2 = points[edges[loop[second]]];
			UnityEngine.Vector3 triangle3 = points[edges[loop[third]]];
			UnityEngine.Vector3 rhs = UnityEngine.Vector3.Cross(planeNormal, triangle2 - triangle);
			int num = -1;
			int num2 = 0;
			float num3 = 0f;
			for (int i = 0; i < loops.Count; i++)
			{
				IList<int> list = loops[i];
				IList<bool> list2 = concavities[i];
				if (list == loop)
				{
					continue;
				}
				for (int j = 0; j < list.Count; j++)
				{
					if (!list2[j])
					{
						continue;
					}
					UnityEngine.Vector3 point = points[edges[list[j] + 1]];
					if (Tools.IsPointInsideTriangle(ref point, ref triangle, ref triangle2, ref triangle3, ref planeNormal))
					{
						float num4 = UnityEngine.Vector3.Dot(point - triangle, rhs);
						if (num4 < num3 || num == -1)
						{
							num = i;
							num2 = (j + 1) % list.Count;
							num3 = num4;
						}
					}
				}
			}
			loopIndex = num;
			loopLocation = num2;
			return num != -1;
		}

		protected void InsertLoop(int insertLocation, List<int> loop, List<bool> concavity, int otherAnchorLocation, List<int> otherLoop, List<bool> otherConcavity)
		{
			int item = edges[loop[insertLocation]];
			int item2 = edges[otherLoop[otherAnchorLocation]];
			int count = edges.Count;
			edges.Add(item2);
			edges.Add(item);
			int count2 = edges.Count;
			edges.Add(item);
			edges.Add(item2);
			duplicateEdges.Add(count2);
			int[] array = new int[otherLoop.Count + 2];
			bool[] array2 = new bool[otherConcavity.Count + 2];
			int num = 0;
			array[num] = count2;
			array2[num++] = false;
			for (int i = otherAnchorLocation; i < otherLoop.Count; i++)
			{
				array[num] = otherLoop[i];
				array2[num++] = otherConcavity[i];
			}
			for (int j = 0; j < otherAnchorLocation; j++)
			{
				array[num] = otherLoop[j];
				array2[num++] = otherConcavity[j];
			}
			array[num] = count;
			array2[num] = false;
			loop.InsertRange(insertLocation, array);
			concavity.InsertRange(insertLocation, array2);
			int index = ((insertLocation == 0) ? (loop.Count - 1) : (insertLocation - 1));
			UpdateConcavity(index, loop, concavity);
			UpdateConcavity(insertLocation, loop, concavity);
			UpdateConcavity(insertLocation + otherLoop.Count, loop, concavity);
			UpdateConcavity(insertLocation + otherLoop.Count + 1, loop, concavity);
		}

		protected void FillTriangle(int zero, int first, int second, int third, List<int> loop, List<bool> concavity)
		{
			int index = loop[zero];
			int num = loop[first];
			int num2 = loop[second];
			int num3 = loop[third];
			int num4 = edges[num];
			int item = edges[num2];
			int num5 = edges[num3];
			int num6;
			if (loop.Count != 3)
			{
				num6 = edges.Count;
				edges.Add(num4);
				edges.Add(num5);
			}
			else
			{
				num6 = num3;
			}
			triangles.Add(num4);
			triangles.Add(item);
			triangles.Add(num5);
			triangleEdges.Add(num);
			triangleEdges.Add(num2);
			triangleEdges.Add(num6);
			loop[second] = num6;
			loop.RemoveAt(first);
			UnityEngine.Vector3 line = points[num4] - points[edges[index]];
			UnityEngine.Vector3 line2 = points[num5] - points[num4];
			UnityEngine.Vector3 line3 = points[edges[num3 + 1]] - points[num5];
			concavity[zero] = IsLinePairConcave(ref line, ref line2);
			concavity[second] = IsLinePairConcave(ref line2, ref line3);
			concavity.RemoveAt(first);
		}

		protected void RemoveDuplicateEdges()
		{
			for (int i = 0; i < duplicateEdges.Count; i++)
			{
				int num = duplicateEdges[i];
				edges.RemoveRange(num, 2);
				for (int j = 0; j < triangleEdges.Count; j++)
				{
					if (triangleEdges[j] >= num)
					{
						triangleEdges[j] -= 2;
					}
				}
				for (int k = i + 1; k < duplicateEdges.Count; k++)
				{
					if (duplicateEdges[k] >= num)
					{
						duplicateEdges[k] -= 2;
					}
				}
			}
		}

		protected void SetOutput(out int[] newEdges, out int[] newTriangles, out int[] newTriangleEdges)
		{
			int num = edges.Count - originalEdgeCount;
			if (num > 0)
			{
				newEdges = new int[num];
				edges.CopyTo(originalEdgeCount, newEdges, 0, num);
			}
			else
			{
				newEdges = new int[0];
			}
			newTriangles = triangles.ToArray();
			newTriangleEdges = new int[triangleEdges.Count];
			for (int i = 0; i < triangleEdges.Count; i++)
			{
				newTriangleEdges[i] = triangleEdges[i] / 2;
			}
		}
	}
	public abstract class ColorMapper : MonoBehaviour
	{
		public abstract void Map(IList<UnityEngine.Vector3> points, UnityEngine.Vector3 planeNormal, out Color32[] colorsA, out Color32[] colorsB);
	}
	public abstract class UvMapper : MonoBehaviour
	{
		public abstract void Map(IList<UnityEngine.Vector3> points, UnityEngine.Vector3 planeNormal, out UnityEngine.Vector4[] tangentsA, out UnityEngine.Vector4[] tangentsB, out UnityEngine.Vector2[] uvsA, out UnityEngine.Vector2[] uvsB);
	}
	[RequireComponent(typeof(MeshFilter))]
	public class ShatterTool : MonoBehaviour
	{
		[SerializeField]
		protected int generation = 1;

		[SerializeField]
		protected int generationLimit = 3;

		[SerializeField]
		protected int cuts = 2;

		[SerializeField]
		protected bool fillCut = true;

		[SerializeField]
		protected bool sendPreSplitMessage;

		[SerializeField]
		protected bool sendPostSplitMessage;

		[SerializeField]
		protected HullType internalHullType;

		protected bool isIntact = true;

		protected IHull hull;

		protected UnityEngine.Vector3 center;

		private SplitProperty splitProperty;

		public int Generation
		{
			get
			{
				return generation;
			}
			set
			{
				generation = Mathf.Max(value, 1);
			}
		}

		public int GenerationLimit
		{
			get
			{
				return generationLimit;
			}
			set
			{
				generationLimit = Mathf.Max(value, 1);
			}
		}

		public int Cuts
		{
			get
			{
				return cuts;
			}
			set
			{
				cuts = Mathf.Max(value, 1);
			}
		}

		public bool FillCut
		{
			get
			{
				return fillCut;
			}
			set
			{
				fillCut = value;
			}
		}

		public bool SendPreSplitMessage
		{
			get
			{
				return sendPreSplitMessage;
			}
			set
			{
				sendPreSplitMessage = value;
			}
		}

		public bool SendPostSplitMessage
		{
			get
			{
				return sendPostSplitMessage;
			}
			set
			{
				sendPostSplitMessage = value;
			}
		}

		public HullType InternalHullType
		{
			get
			{
				return internalHullType;
			}
			set
			{
				internalHullType = value;
			}
		}

		public bool IsFirstGeneration => generation == 1;

		public bool IsLastGeneration => generation >= generationLimit;

		public UnityEngine.Vector3 Center => base.transform.TransformPoint(center);

		protected void CalculateCenter()
		{
			center = GetComponent<MeshFilter>().sharedMesh.bounds.center;
		}

		public void Start()
		{
			Mesh sharedMesh = GetComponent<MeshFilter>().sharedMesh;
			splitProperty = GetComponent<SplitProperty>();
			if (hull == null)
			{
				if (internalHullType == HullType.FastHull)
				{
					hull = new FastHull(sharedMesh);
				}
				else if (internalHullType == HullType.LegacyHull)
				{
					hull = new LegacyHull(sharedMesh);
				}
			}
			CalculateCenter();
		}

		public void Shatter(UnityEngine.Vector3 point, Ball.BallCollisionInfo ballCollisionInfo = null)
		{
			if (!IsLastGeneration)
			{
				generation++;
				UnityEngine.Plane[] array = new UnityEngine.Plane[cuts];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = new UnityEngine.Plane(UnityEngine.Random.onUnitSphere, point);
				}
				Split(array, ballCollisionInfo);
			}
		}

		public void Split(UnityEngine.Plane[] planes, Ball.BallCollisionInfo ballCollisionInfo = null)
		{
			if (planes != null && planes.Length != 0 && isIntact && hull != null && !hull.IsEmpty)
			{
				UvMapper component = GetComponent<UvMapper>();
				ColorMapper component2 = GetComponent<ColorMapper>();
				if (sendPreSplitMessage)
				{
					SendMessage("PreSplit", planes, SendMessageOptions.DontRequireReceiver);
				}
				ConvertPlanesToLocalspace(planes, out var points, out var normals);
				CreateNewHulls(component, component2, points, normals, out var newHulls);
				CreateNewGameObjects(newHulls, out var newGameObjects, ballCollisionInfo);
				if (sendPostSplitMessage)
				{
					SendMessage("PostSplit", newGameObjects, SendMessageOptions.DontRequireReceiver);
				}
				base.gameObject.SetActive(value: false);
				generation--;
			}
		}

		protected void ConvertPlanesToLocalspace(UnityEngine.Plane[] planes, out UnityEngine.Vector3[] points, out UnityEngine.Vector3[] normals)
		{
			points = new UnityEngine.Vector3[planes.Length];
			normals = new UnityEngine.Vector3[planes.Length];
			for (int i = 0; i < planes.Length; i++)
			{
				UnityEngine.Plane plane = planes[i];
				UnityEngine.Vector3 vector = base.transform.InverseTransformPoint(plane.normal * (0f - plane.distance));
				UnityEngine.Vector3 vector2 = base.transform.InverseTransformDirection(plane.normal);
				vector2.Scale(base.transform.localScale);
				vector2.Normalize();
				points[i] = vector;
				normals[i] = vector2;
			}
		}

		protected void CreateNewHulls(UvMapper uvMapper, ColorMapper colorMapper, UnityEngine.Vector3[] points, UnityEngine.Vector3[] normals, out IList<IHull> newHulls)
		{
			newHulls = new List<IHull>();
			newHulls.Add(this.hull);
			for (int i = 0; i < points.Length; i++)
			{
				int count = newHulls.Count;
				for (int j = 0; j < count; j++)
				{
					IHull hull = newHulls[0];
					hull.Split(points[i], normals[i], fillCut, uvMapper, colorMapper, out var resultA, out var resultB);
					newHulls.Remove(hull);
					if (!resultA.IsEmpty)
					{
						newHulls.Add(resultA);
					}
					if (!resultB.IsEmpty)
					{
						newHulls.Add(resultB);
					}
				}
			}
		}

		protected void CreateNewGameObjects(IList<IHull> newHulls, out GameObject[] newGameObjects, Ball.BallCollisionInfo ballCollisionInfo = null)
		{
			Mesh[] array = new Mesh[newHulls.Count];
			float[] array2 = new float[newHulls.Count];
			float num = 0f;
			for (int i = 0; i < newHulls.Count; i++)
			{
				Mesh mesh = newHulls[i].GetMesh();
				UnityEngine.Vector3 size = mesh.bounds.size;
				float num2 = size.x * size.y * size.z;
				array[i] = mesh;
				array2[i] = num2;
				num += num2;
			}
			GetComponent<MeshFilter>();
			GetComponent<MeshCollider>();
			Rigidbody component = GetComponent<Rigidbody>();
			newGameObjects = new GameObject[newHulls.Count];
			for (int j = 0; j < newHulls.Count; j++)
			{
				IHull hull = newHulls[j];
				Mesh sharedMesh = array[j];
				_ = array2[j];
				GameObject gameObject = UnityEngine.Object.Instantiate(base.gameObject);
				gameObject.transform.position = base.gameObject.transform.position;
				gameObject.transform.rotation = base.gameObject.transform.rotation;
				ShatterTool component2 = gameObject.GetComponent<ShatterTool>();
				if (component2 != null)
				{
					component2.hull = hull;
				}
				MeshFilter component3 = gameObject.GetComponent<MeshFilter>();
				if (component3 != null)
				{
					component3.sharedMesh = sharedMesh;
				}
				MeshCollider component4 = gameObject.GetComponent<MeshCollider>();
				if (component4 != null)
				{
					component4.sharedMesh = sharedMesh;
				}
				Rigidbody component5 = gameObject.GetComponent<Rigidbody>();
				if (component != null && component5 != null)
				{
					splitProperty?.newGameObjectSpecialSet(component5, ballCollisionInfo);
					if (!component5.isKinematic)
					{
						component5.velocity = component.GetPointVelocity(component5.worldCenterOfMass);
						component5.angularVelocity = component.angularVelocity;
					}
				}
				component2.CalculateCenter();
				newGameObjects[j] = gameObject;
			}
		}
	}
	public class SolidColorMapper : ColorMapper
	{
		public Color32 fillColor = Color.cyan;

		public override void Map(IList<UnityEngine.Vector3> points, UnityEngine.Vector3 planeNormal, out Color32[] colorsA, out Color32[] colorsB)
		{
			Color32[] array = new Color32[points.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = fillColor;
			}
			colorsA = array;
			colorsB = array;
		}
	}
	public class TargetUvMapper : UvMapper
	{
		public UnityEngine.Vector2 targetStart = UnityEngine.Vector2.zero;

		public UnityEngine.Vector2 targetSize = UnityEngine.Vector2.one;

		public bool square;

		public bool centerMeshOrigo;

		public override void Map(IList<UnityEngine.Vector3> points, UnityEngine.Vector3 planeNormal, out UnityEngine.Vector4[] tangentsA, out UnityEngine.Vector4[] tangentsB, out UnityEngine.Vector2[] uvsA, out UnityEngine.Vector2[] uvsB)
		{
			UnityEngine.Vector3 vector = UnityEngine.Vector3.Cross(planeNormal, UnityEngine.Vector3.up);
			if (vector == UnityEngine.Vector3.zero)
			{
				vector = UnityEngine.Vector3.Cross(planeNormal, UnityEngine.Vector3.forward);
			}
			UnityEngine.Vector3 rhs = UnityEngine.Vector3.Cross(vector, planeNormal);
			vector.Normalize();
			rhs.Normalize();
			UnityEngine.Vector4 vector2 = new UnityEngine.Vector4(vector.x, vector.y, vector.z, 1f);
			UnityEngine.Vector4 vector3 = new UnityEngine.Vector4(vector.x, vector.y, vector.z, -1f);
			tangentsA = new UnityEngine.Vector4[points.Count];
			tangentsB = new UnityEngine.Vector4[points.Count];
			for (int i = 0; i < points.Count; i++)
			{
				tangentsA[i] = vector2;
				tangentsB[i] = vector3;
			}
			UnityEngine.Vector2[] array = new UnityEngine.Vector2[points.Count];
			UnityEngine.Vector2 vector4 = UnityEngine.Vector2.zero;
			UnityEngine.Vector2 vector5 = UnityEngine.Vector2.zero;
			for (int j = 0; j < points.Count; j++)
			{
				UnityEngine.Vector3 lhs = points[j];
				array[j].x = UnityEngine.Vector3.Dot(lhs, vector);
				array[j].y = UnityEngine.Vector3.Dot(lhs, rhs);
				if (j == 0)
				{
					vector4 = array[j];
					vector5 = array[j];
				}
				else
				{
					vector4 = UnityEngine.Vector2.Min(array[j], vector4);
					vector5 = UnityEngine.Vector2.Max(array[j], vector5);
				}
			}
			UnityEngine.Vector2 vector6 = vector5 - vector4;
			if (square)
			{
				float num = Mathf.Max(vector6.x, vector6.y);
				UnityEngine.Vector2 vector7 = default(UnityEngine.Vector2);
				vector7.x = (num - vector6.x) * 0.5f;
				vector7.y = (num - vector6.y) * 0.5f;
				vector4 -= vector7;
				vector5 += vector7;
			}
			if (centerMeshOrigo)
			{
				UnityEngine.Vector2 vector8 = default(UnityEngine.Vector2);
				vector8.x = Mathf.Max(Mathf.Abs(vector4.x), Mathf.Abs(vector5.x));
				vector8.y = Mathf.Max(Mathf.Abs(vector4.y), Mathf.Abs(vector5.y));
				vector4 = -vector8;
				vector5 = vector8;
			}
			UnityEngine.Vector2 vector9 = vector5 - vector4;
			UnityEngine.Vector2 vector10 = new UnityEngine.Vector2(1f / vector9.x, 1f / vector9.y);
			for (int k = 0; k < points.Count; k++)
			{
				array[k].x = (array[k].x - vector4.x) * vector10.x;
				array[k].y = (array[k].y - vector4.y) * vector10.y;
				array[k].x = targetStart.x + targetSize.x * array[k].x;
				array[k].y = targetStart.y + targetSize.y * array[k].y;
			}
			uvsA = array;
			uvsB = array;
		}
	}
	public class WorldUvMapper : UvMapper
	{
		public UnityEngine.Vector2 scale = UnityEngine.Vector2.one;

		public override void Map(IList<UnityEngine.Vector3> points, UnityEngine.Vector3 planeNormal, out UnityEngine.Vector4[] tangentsA, out UnityEngine.Vector4[] tangentsB, out UnityEngine.Vector2[] uvsA, out UnityEngine.Vector2[] uvsB)
		{
			UnityEngine.Vector3 vector = UnityEngine.Vector3.Cross(planeNormal, UnityEngine.Vector3.up);
			if (vector == UnityEngine.Vector3.zero)
			{
				vector = UnityEngine.Vector3.Cross(planeNormal, UnityEngine.Vector3.forward);
			}
			UnityEngine.Vector3 rhs = UnityEngine.Vector3.Cross(vector, planeNormal);
			vector.Normalize();
			rhs.Normalize();
			UnityEngine.Vector4 vector2 = new UnityEngine.Vector4(vector.x, vector.y, vector.z, 1f);
			UnityEngine.Vector4 vector3 = new UnityEngine.Vector4(vector.x, vector.y, vector.z, -1f);
			tangentsA = new UnityEngine.Vector4[points.Count];
			tangentsB = new UnityEngine.Vector4[points.Count];
			for (int i = 0; i < points.Count; i++)
			{
				tangentsA[i] = vector2;
				tangentsB[i] = vector3;
			}
			UnityEngine.Vector2[] array = new UnityEngine.Vector2[points.Count];
			UnityEngine.Vector2 vector4 = UnityEngine.Vector2.zero;
			for (int j = 0; j < points.Count; j++)
			{
				UnityEngine.Vector3 lhs = points[j];
				array[j].x = UnityEngine.Vector3.Dot(lhs, vector);
				array[j].y = UnityEngine.Vector3.Dot(lhs, rhs);
				vector4 = ((j != 0) ? UnityEngine.Vector2.Min(array[j], vector4) : array[j]);
			}
			for (int k = 0; k < points.Count; k++)
			{
				array[k] -= vector4;
				array[k].x *= scale.x;
				array[k].y *= scale.y;
			}
			uvsA = array;
			uvsB = array;
		}
	}
}
namespace ShatterToolkit.Helpers
{
	[RequireComponent(typeof(ShatterTool))]
	public class HierarchyHandler : MonoBehaviour
	{
		public bool attachPieceToParent = true;

		public float maxPieceToParentDistance = 1f;

		public bool addRbToDetachedPieces = true;

		public bool attachChildrenToPieces = true;

		public float maxChildToPieceDistance = 1f;

		public bool addRbToDetachedChildren = true;

		protected Transform parent;

		protected Transform[] children;

		public void PreSplit(UnityEngine.Plane[] planes)
		{
			if (base.transform.parent != null)
			{
				parent = base.transform.parent;
				base.transform.parent = null;
			}
			children = new Transform[base.transform.childCount];
			int num = 0;
			foreach (Transform item in base.transform)
			{
				children[num++] = item;
			}
			base.transform.DetachChildren();
		}

		public void PostSplit(GameObject[] newGameObjects)
		{
			ShatterTool[] array = new ShatterTool[newGameObjects.Length];
			for (int i = 0; i < newGameObjects.Length; i++)
			{
				array[i] = newGameObjects[i].GetComponent<ShatterTool>();
			}
			if (parent != null)
			{
				ShatterTool component = parent.GetComponent<ShatterTool>();
				if (component != null)
				{
					ShatterTool shatterTool = null;
					if (attachPieceToParent)
					{
						shatterTool = FindClosestPiece(component, array, maxPieceToParentDistance);
						if (shatterTool != null)
						{
							shatterTool.transform.parent = parent;
						}
					}
					if (addRbToDetachedPieces)
					{
						ShatterTool[] array2 = array;
						foreach (ShatterTool shatterTool2 in array2)
						{
							if (shatterTool2 != null && shatterTool2 != shatterTool)
							{
								shatterTool2.gameObject.AddComponent<Rigidbody>();
							}
						}
					}
				}
			}
			Transform[] array3 = children;
			foreach (Transform transform in array3)
			{
				ShatterTool component2 = transform.GetComponent<ShatterTool>();
				if (component2 != null)
				{
					ShatterTool shatterTool3 = FindClosestPiece(component2, array, maxChildToPieceDistance);
					if (attachChildrenToPieces && shatterTool3 != null)
					{
						transform.parent = shatterTool3.transform;
					}
					else if (addRbToDetachedChildren)
					{
						transform.gameObject.AddComponent<Rigidbody>();
					}
				}
			}
		}

		protected ShatterTool FindClosestPiece(ShatterTool reference, ShatterTool[] pieces, float maxDistance)
		{
			UnityEngine.Vector3 center = reference.Center;
			float num = maxDistance * maxDistance;
			ShatterTool shatterTool = null;
			float num2 = 0f;
			foreach (ShatterTool shatterTool2 in pieces)
			{
				if (shatterTool2 != null)
				{
					float sqrMagnitude = (center - shatterTool2.Center).sqrMagnitude;
					if (sqrMagnitude < num && (sqrMagnitude < num2 || shatterTool == null))
					{
						shatterTool = shatterTool2;
						num2 = sqrMagnitude;
					}
				}
			}
			return shatterTool;
		}
	}
	[RequireComponent(typeof(ShatterTool))]
	public class PieceRemover : MonoBehaviour
	{
		public int startAtGeneration = 3;

		public float timeDelay = 5f;

		public bool whenOutOfViewOnly = true;

		protected ShatterTool shatterTool;

		protected Renderer renderer;

		protected float timeSinceInstantiated;

		private float collisionBoxTimer = 0.1f;

		public void Start()
		{
			shatterTool = GetComponent<ShatterTool>();
			renderer = GetComponent<Renderer>();
		}

		public void Update()
		{
			if (shatterTool.Generation >= startAtGeneration)
			{
				timeSinceInstantiated += Time.deltaTime;
				if (timeSinceInstantiated >= collisionBoxTimer)
				{
					UnityEngine.Object.Destroy(GetComponent<Collider>());
				}
				if (timeSinceInstantiated >= timeDelay && (!whenOutOfViewOnly || !renderer.isVisible))
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}
	public class ShatterOnCollision : MonoBehaviour
	{
		public float requiredVelocity = 1f;

		public float cooldownTime = 0.5f;

		protected float timeSinceInstantiated;

		public void Update()
		{
			timeSinceInstantiated += Time.deltaTime;
		}

		public void OnCollisionEnter(Collision collision)
		{
			if (!(timeSinceInstantiated >= cooldownTime) || !(collision.relativeVelocity.magnitude >= requiredVelocity) || collision.gameObject.CompareTag("Player") || collision.gameObject.CompareTag("DestroyedSpike"))
			{
				return;
			}
			ContactPoint[] contacts = collision.contacts;
			for (int i = 0; i < contacts.Length; i++)
			{
				ContactPoint contactPoint = contacts[i];
				if (contactPoint.otherCollider == collision.collider)
				{
					contactPoint.thisCollider.SendMessage("Shatter", contactPoint.point, SendMessageOptions.DontRequireReceiver);
					break;
				}
			}
		}
	}
	public class MouseForce : MonoBehaviour
	{
		public float impulseScale = 25f;

		protected Rigidbody grabBody;

		protected UnityEngine.Vector3 grabPoint;

		protected float grabDistance;

		public void Update()
		{
			GrabBody();
			ReleaseBody();
		}

		public void FixedUpdate()
		{
			MoveBody();
		}

		protected void GrabBody()
		{
			if (grabBody == null && Input.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo) && hitInfo.rigidbody != null)
			{
				grabBody = hitInfo.rigidbody;
				grabPoint = grabBody.transform.InverseTransformPoint(hitInfo.point);
				grabDistance = hitInfo.distance;
			}
		}

		protected void ReleaseBody()
		{
			if (grabBody != null && Input.GetMouseButtonUp(0))
			{
				grabBody = null;
			}
		}

		protected void MoveBody()
		{
			if (grabBody != null)
			{
				UnityEngine.Vector3 position = new UnityEngine.Vector3(Input.mousePosition.x, Input.mousePosition.y, grabDistance);
				UnityEngine.Vector3 vector = Camera.main.ScreenToWorldPoint(position);
				UnityEngine.Vector3 vector2 = grabBody.transform.TransformPoint(grabPoint);
				UnityEngine.Debug.DrawLine(vector, vector2, Color.red);
				UnityEngine.Vector3 force = (vector - vector2) * (impulseScale * Time.fixedDeltaTime);
				grabBody.AddForceAtPosition(force, vector2, ForceMode.Impulse);
			}
		}
	}
	public class MouseInstantiate : MonoBehaviour
	{
		public GameObject prefabToInstantiate;

		public float speed = 7f;

		public void Update()
		{
			if (Input.GetMouseButtonDown(0) && prefabToInstantiate != null)
			{
				Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
				Rigidbody component = UnityEngine.Object.Instantiate(prefabToInstantiate, ray.origin, UnityEngine.Quaternion.identity).GetComponent<Rigidbody>();
				if (component != null)
				{
					component.velocity = ray.direction * speed;
				}
			}
		}
	}
	public class MouseShatter : MonoBehaviour
	{
		public void Update()
		{
			if (Input.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
			{
				hitInfo.collider.SendMessage("Shatter", hitInfo.point, SendMessageOptions.DontRequireReceiver);
			}
		}
	}
	public class MouseSplit : MonoBehaviour
	{
		public int raycastCount = 5;

		protected bool started;

		protected UnityEngine.Vector3 start;

		protected UnityEngine.Vector3 end;

		public void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				start = Input.mousePosition;
				started = true;
			}
			if (!Input.GetMouseButtonUp(0) || !started)
			{
				return;
			}
			end = Input.mousePosition;
			Camera main = Camera.main;
			float nearClipPlane = main.nearClipPlane;
			UnityEngine.Vector3 lhs = main.ScreenToWorldPoint(new UnityEngine.Vector3(end.x, end.y, nearClipPlane)) - main.ScreenToWorldPoint(new UnityEngine.Vector3(start.x, start.y, nearClipPlane));
			for (int i = 0; i < raycastCount; i++)
			{
				Ray ray = main.ScreenPointToRay(UnityEngine.Vector3.Lerp(start, end, (float)i / (float)raycastCount));
				if (Physics.Raycast(ray, out var hitInfo))
				{
					UnityEngine.Plane plane = new UnityEngine.Plane(UnityEngine.Vector3.Normalize(UnityEngine.Vector3.Cross(lhs, ray.direction)), hitInfo.point);
					hitInfo.collider.SendMessage("Split", new UnityEngine.Plane[1] { plane }, SendMessageOptions.DontRequireReceiver);
					break;
				}
			}
			started = false;
		}
	}
}
namespace ShatterToolkit.Examples
{
	[RequireComponent(typeof(MouseForce), typeof(MouseSplit), typeof(MouseShatter))]
	public class MouseGUI : MonoBehaviour
	{
		public int defaultSelection;

		protected MouseForce mouseForce;

		protected MouseSplit mouseSplit;

		protected MouseShatter mouseShatter;

		protected int toolbarSelection;

		protected string[] toolbarLabels = new string[3] { "Mouse force (Click and drag)", "Mouse split (Click and drag, release)", "Mouse shatter (Click)" };

		public void Awake()
		{
			mouseForce = GetComponent<MouseForce>();
			mouseSplit = GetComponent<MouseSplit>();
			mouseShatter = GetComponent<MouseShatter>();
			toolbarSelection = defaultSelection;
			SelectTool();
		}

		public void OnGUI()
		{
			toolbarSelection = GUI.Toolbar(new Rect(10f, 10f, Screen.width - 20, 20f), toolbarSelection, toolbarLabels);
			if (GUI.changed)
			{
				SelectTool();
			}
		}

		protected void SelectTool()
		{
			mouseForce.enabled = false;
			mouseSplit.enabled = false;
			mouseShatter.enabled = false;
			if (toolbarSelection == 0)
			{
				mouseForce.enabled = true;
			}
			else if (toolbarSelection == 1)
			{
				mouseSplit.enabled = true;
			}
			else if (toolbarSelection == 2)
			{
				mouseShatter.enabled = true;
			}
		}
	}
	public class SceneGUI : MonoBehaviour
	{
		protected int toolbarSelection;

		protected string[] toolbarLabels = new string[3] { "Basic scene", "UvMapping scene", "Wall scene" };

		public void Awake()
		{
			toolbarSelection = Application.loadedLevel;
		}

		public void OnGUI()
		{
			toolbarSelection = GUI.Toolbar(new Rect(10f, Screen.height - 30, Screen.width - 20, 20f), toolbarSelection, toolbarLabels);
			if (GUI.changed)
			{
				Application.LoadLevel(toolbarSelection);
			}
		}
	}
	public class OutlineCreator : MonoBehaviour
	{
		protected List<UnityEngine.Vector3> points = new List<UnityEngine.Vector3>();

		protected List<int> edges = new List<int>();

		protected List<int> triangles = new List<int>();

		protected List<int> triangleEdges = new List<int>();

		protected bool isTriangulated;

		protected bool isLoopClosed;

		protected int loopStart;

		public int LoopPointCount => points.Count - loopStart;

		public void Reset()
		{
			points.Clear();
			edges.Clear();
			triangles.Clear();
			triangleEdges.Clear();
			isTriangulated = false;
			isLoopClosed = false;
			loopStart = 0;
		}

		public void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				if (isTriangulated)
				{
					Reset();
				}
				UnityEngine.Vector3 position = new UnityEngine.Vector3(Input.mousePosition.x, Input.mousePosition.y, 10f);
				UnityEngine.Vector3 item = Camera.main.ScreenToWorldPoint(position);
				points.Add(item);
				if (LoopPointCount >= 2)
				{
					edges.Add(points.Count - 2);
					edges.Add(points.Count - 1);
				}
				isLoopClosed = false;
			}
			else if (Input.GetMouseButtonDown(1) && LoopPointCount >= 3)
			{
				edges.Add(points.Count - 1);
				edges.Add(loopStart);
				isLoopClosed = true;
				loopStart = points.Count;
			}
			if (Input.GetKeyDown(KeyCode.Space) && !isTriangulated && isLoopClosed)
			{
				((ITriangulator)new Triangulator(points, edges, UnityEngine.Vector3.up)).Fill(out int[] newEdges, out int[] newTriangles, out int[] newTriangleEdges);
				edges.AddRange(newEdges);
				triangles.AddRange(newTriangles);
				triangleEdges.AddRange(newTriangleEdges);
				isTriangulated = true;
			}
		}

		public void OnGUI()
		{
			GUI.Box(new Rect(0f, 0f, 500f, 100f), "Please turn on Gizmos!\nCreate an outline by left-clicking in a clockwise order on the screen.\nRight-click to close a loop.\nCreate a hole by left-clicking in a counter-clockwise order inside a shape.\nBe careful not to overlap edges.\nPress SPACE to triangulate the closed loops!");
		}

		public void OnDrawGizmos()
		{
			Gizmos.color = Color.black;
			for (int i = 0; i < points.Count; i++)
			{
				Gizmos.DrawSphere(points[i], 0.1f);
			}
			for (int j = 0; j < edges.Count / 2; j++)
			{
				int num = j * 2;
				Gizmos.DrawLine(points[edges[num]], points[edges[num + 1]]);
			}
			for (int k = 0; k < triangles.Count / 3; k++)
			{
				int num2 = k * 3;
				UnityEngine.Vector3 from = (points[triangles[num2]] + points[triangles[num2 + 1]] + points[triangles[num2 + 2]]) / 3f;
				Gizmos.color = Color.red;
				Gizmos.DrawLine(from, (points[edges[triangleEdges[num2] * 2]] + points[edges[triangleEdges[num2] * 2 + 1]]) * 0.5f);
				Gizmos.color = Color.green;
				Gizmos.DrawLine(from, (points[edges[triangleEdges[num2 + 1] * 2]] + points[edges[triangleEdges[num2 + 1] * 2 + 1]]) * 0.5f);
				Gizmos.color = Color.blue;
				Gizmos.DrawLine(from, (points[edges[triangleEdges[num2 + 2] * 2]] + points[edges[triangleEdges[num2 + 2] * 2 + 1]]) * 0.5f);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class RotateRigidbody : MonoBehaviour
	{
		public UnityEngine.Vector3 axis = UnityEngine.Vector3.up;

		public float angularVelocity = 7f;

		protected Rigidbody rb;

		public void Start()
		{
			rb = GetComponent<Rigidbody>();
		}

		public void FixedUpdate()
		{
			UnityEngine.Quaternion quaternion = UnityEngine.Quaternion.AngleAxis(angularVelocity * Time.fixedDeltaTime, axis);
			rb.MoveRotation(rb.rotation * quaternion);
		}
	}
}
namespace System.Numerics
{
	[Serializable]
	public struct Complex : IEquatable<Complex>, IFormattable
	{
		private double m_real;

		private double m_imaginary;

		private const double LOG_10_INV = 0.43429448190325;

		public static readonly Complex Zero = new Complex(0.0, 0.0);

		public static readonly Complex One = new Complex(1.0, 0.0);

		public static readonly Complex ImaginaryOne = new Complex(0.0, 1.0);

		public double Real => m_real;

		public double Imaginary => m_imaginary;

		public double Magnitude => Abs(this);

		public double Phase => Math.Atan2(m_imaginary, m_real);

		public Complex(double real, double imaginary)
		{
			m_real = real;
			m_imaginary = imaginary;
		}

		public static Complex FromPolarCoordinates(double magnitude, double phase)
		{
			return new Complex(magnitude * Math.Cos(phase), magnitude * Math.Sin(phase));
		}

		public static Complex Negate(Complex value)
		{
			return -value;
		}

		public static Complex Add(Complex left, Complex right)
		{
			return left + right;
		}

		public static Complex Subtract(Complex left, Complex right)
		{
			return left - right;
		}

		public static Complex Multiply(Complex left, Complex right)
		{
			return left * right;
		}

		public static Complex Divide(Complex dividend, Complex divisor)
		{
			return dividend / divisor;
		}

		public static Complex operator -(Complex value)
		{
			return new Complex(0.0 - value.m_real, 0.0 - value.m_imaginary);
		}

		public static Complex operator +(Complex left, Complex right)
		{
			return new Complex(left.m_real + right.m_real, left.m_imaginary + right.m_imaginary);
		}

		public static Complex operator -(Complex left, Complex right)
		{
			return new Complex(left.m_real - right.m_real, left.m_imaginary - right.m_imaginary);
		}

		public static Complex operator *(Complex left, Complex right)
		{
			double real = left.m_real * right.m_real - left.m_imaginary * right.m_imaginary;
			double imaginary = left.m_imaginary * right.m_real + left.m_real * right.m_imaginary;
			return new Complex(real, imaginary);
		}

		public static Complex operator /(Complex left, Complex right)
		{
			double real = left.m_real;
			double imaginary = left.m_imaginary;
			double real2 = right.m_real;
			double imaginary2 = right.m_imaginary;
			if (Math.Abs(imaginary2) < Math.Abs(real2))
			{
				double num = imaginary2 / real2;
				return new Complex((real + imaginary * num) / (real2 + imaginary2 * num), (imaginary - real * num) / (real2 + imaginary2 * num));
			}
			double num2 = real2 / imaginary2;
			return new Complex((imaginary + real * num2) / (imaginary2 + real2 * num2), (0.0 - real + imaginary * num2) / (imaginary2 + real2 * num2));
		}

		public static double Abs(Complex value)
		{
			if (double.IsInfinity(value.m_real) || double.IsInfinity(value.m_imaginary))
			{
				return double.PositiveInfinity;
			}
			double num = Math.Abs(value.m_real);
			double num2 = Math.Abs(value.m_imaginary);
			if (num > num2)
			{
				double num3 = num2 / num;
				return num * Math.Sqrt(1.0 + num3 * num3);
			}
			if (num2 == 0.0)
			{
				return num;
			}
			double num4 = num / num2;
			return num2 * Math.Sqrt(1.0 + num4 * num4);
		}

		public static Complex Conjugate(Complex value)
		{
			return new Complex(value.m_real, 0.0 - value.m_imaginary);
		}

		public static Complex Reciprocal(Complex value)
		{
			if (value.m_real == 0.0 && value.m_imaginary == 0.0)
			{
				return Zero;
			}
			return One / value;
		}

		public static bool operator ==(Complex left, Complex right)
		{
			if (left.m_real == right.m_real)
			{
				return left.m_imaginary == right.m_imaginary;
			}
			return false;
		}

		public static bool operator !=(Complex left, Complex right)
		{
			if (left.m_real == right.m_real)
			{
				return left.m_imaginary != right.m_imaginary;
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is Complex))
			{
				return false;
			}
			return this == (Complex)obj;
		}

		public bool Equals(Complex value)
		{
			if (m_real.Equals(value.m_real))
			{
				return m_imaginary.Equals(value.m_imaginary);
			}
			return false;
		}

		public static implicit operator Complex(short value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(int value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(long value)
		{
			return new Complex(value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(ushort value)
		{
			return new Complex((int)value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(uint value)
		{
			return new Complex(value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(ulong value)
		{
			return new Complex(value, 0.0);
		}

		[CLSCompliant(false)]
		public static implicit operator Complex(sbyte value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(byte value)
		{
			return new Complex((int)value, 0.0);
		}

		public static implicit operator Complex(float value)
		{
			return new Complex(value, 0.0);
		}

		public static implicit operator Complex(double value)
		{
			return new Complex(value, 0.0);
		}

		public static explicit operator Complex(decimal value)
		{
			return new Complex((double)value, 0.0);
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", m_real, m_imaginary);
		}

		public string ToString(string format)
		{
			return string.Format(CultureInfo.CurrentCulture, "({0}, {1})", m_real.ToString(format, CultureInfo.CurrentCulture), m_imaginary.ToString(format, CultureInfo.CurrentCulture));
		}

		public string ToString(IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", m_real, m_imaginary);
		}

		public string ToString(string format, IFormatProvider provider)
		{
			return string.Format(provider, "({0}, {1})", m_real.ToString(format, provider), m_imaginary.ToString(format, provider));
		}

		public override int GetHashCode()
		{
			int num = 99999997;
			int num2 = m_real.GetHashCode() % num;
			int hashCode = m_imaginary.GetHashCode();
			return num2 ^ hashCode;
		}

		public static Complex Sin(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Sin(real) * Math.Cosh(imaginary), Math.Cos(real) * Math.Sinh(imaginary));
		}

		public static Complex Sinh(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Sinh(real) * Math.Cos(imaginary), Math.Cosh(real) * Math.Sin(imaginary));
		}

		public static Complex Asin(Complex value)
		{
			return -ImaginaryOne * Log(ImaginaryOne * value + Sqrt(One - value * value));
		}

		public static Complex Cos(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Cos(real) * Math.Cosh(imaginary), 0.0 - Math.Sin(real) * Math.Sinh(imaginary));
		}

		public static Complex Cosh(Complex value)
		{
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			return new Complex(Math.Cosh(real) * Math.Cos(imaginary), Math.Sinh(real) * Math.Sin(imaginary));
		}

		public static Complex Acos(Complex value)
		{
			return -ImaginaryOne * Log(value + ImaginaryOne * Sqrt(One - value * value));
		}

		public static Complex Tan(Complex value)
		{
			return Sin(value) / Cos(value);
		}

		public static Complex Tanh(Complex value)
		{
			return Sinh(value) / Cosh(value);
		}

		public static Complex Atan(Complex value)
		{
			Complex complex = new Complex(2.0, 0.0);
			return ImaginaryOne / complex * (Log(One - ImaginaryOne * value) - Log(One + ImaginaryOne * value));
		}

		public static Complex Log(Complex value)
		{
			return new Complex(Math.Log(Abs(value)), Math.Atan2(value.m_imaginary, value.m_real));
		}

		public static Complex Log(Complex value, double baseValue)
		{
			return Log(value) / Log(baseValue);
		}

		public static Complex Log10(Complex value)
		{
			return Scale(Log(value), 0.43429448190325);
		}

		public static Complex Exp(Complex value)
		{
			double num = Math.Exp(value.m_real);
			double real = num * Math.Cos(value.m_imaginary);
			double imaginary = num * Math.Sin(value.m_imaginary);
			return new Complex(real, imaginary);
		}

		public static Complex Sqrt(Complex value)
		{
			return FromPolarCoordinates(Math.Sqrt(value.Magnitude), value.Phase / 2.0);
		}

		public static Complex Pow(Complex value, Complex power)
		{
			if (power == Zero)
			{
				return One;
			}
			if (value == Zero)
			{
				return Zero;
			}
			double real = value.m_real;
			double imaginary = value.m_imaginary;
			double real2 = power.m_real;
			double imaginary2 = power.m_imaginary;
			double num = Abs(value);
			double num2 = Math.Atan2(imaginary, real);
			double num3 = real2 * num2 + imaginary2 * Math.Log(num);
			double num4 = Math.Pow(num, real2) * Math.Pow(Math.E, (0.0 - imaginary2) * num2);
			return new Complex(num4 * Math.Cos(num3), num4 * Math.Sin(num3));
		}

		public static Complex Pow(Complex value, double power)
		{
			return Pow(value, new Complex(power, 0.0));
		}

		private static Complex Scale(Complex value, double factor)
		{
			double real = factor * value.m_real;
			double imaginary = factor * value.m_imaginary;
			return new Complex(real, imaginary);
		}
	}
}
namespace DSPLib
{
	public class DFT
	{
		private double mDFTScale;

		private uint mLengthTotal;

		private uint mLengthHalf;

		private double[,] mCosTerm;

		private double[,] mSinTerm;

		private bool mOutOfMemory;

		public bool IsUsingCached
		{
			get
			{
				return !mOutOfMemory;
			}
			private set
			{
			}
		}

		public void Initialize(uint inputDataLength, uint zeroPaddingLength = 0u, bool forceNoCache = false)
		{
			mLengthTotal = inputDataLength + zeroPaddingLength;
			mLengthHalf = mLengthTotal / 2 + 1;
			mDFTScale = Math.Sqrt(2.0) / (double)(inputDataLength + zeroPaddingLength);
			mDFTScale *= (double)(inputDataLength + zeroPaddingLength) / (double)inputDataLength;
			if (forceNoCache)
			{
				mOutOfMemory = true;
				return;
			}
			mOutOfMemory = false;
			try
			{
				mCosTerm = new double[mLengthTotal, mLengthTotal];
				mSinTerm = new double[mLengthTotal, mLengthTotal];
				double num = Math.PI * 2.0 / (double)mLengthTotal;
				for (int i = 0; i < mLengthHalf; i++)
				{
					double num2 = (double)i * num;
					for (int j = 0; j < mLengthTotal; j++)
					{
						mCosTerm[i, j] = Math.Cos(num2 * (double)j) * mDFTScale;
						mSinTerm[i, j] = Math.Sin(num2 * (double)j) * mDFTScale;
					}
				}
			}
			catch (OutOfMemoryException)
			{
				mOutOfMemory = true;
			}
		}

		public Complex[] Execute(double[] timeSeries)
		{
			double[] array = new double[mLengthTotal];
			Array.Copy(timeSeries, array, timeSeries.Length);
			if (mOutOfMemory)
			{
				return Dft(array);
			}
			return DftCached(array);
		}

		private Complex[] Dft(double[] timeSeries)
		{
			uint num = mLengthTotal;
			uint num2 = mLengthHalf;
			double[] array = new double[num2];
			double[] array2 = new double[num2];
			Complex[] array3 = new Complex[num2];
			double num3 = Math.PI * 2.0 / (double)num;
			for (uint num4 = 0u; num4 < num2; num4++)
			{
				double num5 = (double)num4 * num3;
				for (uint num6 = 0u; num6 < num; num6++)
				{
					array[num4] += timeSeries[num6] * Math.Cos(num5 * (double)num6) * mDFTScale;
					array2[num4] -= timeSeries[num6] * Math.Sin(num5 * (double)num6) * mDFTScale;
				}
				array3[num4] = new Complex(array[num4], array2[num4]);
			}
			array3[0] = new Complex(array3[0].Real / Math.Sqrt(2.0), 0.0);
			array3[mLengthHalf - 1] = new Complex(array3[mLengthHalf - 1].Real / Math.Sqrt(2.0), 0.0);
			return array3;
		}

		private Complex[] DftCached(double[] timeSeries)
		{
			uint num = mLengthTotal;
			uint num2 = mLengthHalf;
			double[] array = new double[num2];
			double[] array2 = new double[num2];
			Complex[] array3 = new Complex[num2];
			for (uint num3 = 0u; num3 < num2; num3++)
			{
				for (uint num4 = 0u; num4 < num; num4++)
				{
					array[num3] += timeSeries[num4] * mCosTerm[num3, num4];
					array2[num3] -= timeSeries[num4] * mSinTerm[num3, num4];
				}
				array3[num3] = new Complex(array[num3], array2[num3]);
			}
			array3[0] = new Complex(array3[0].Real / Math.Sqrt(2.0), 0.0);
			array3[mLengthHalf - 1] = new Complex(array3[mLengthHalf - 1].Real / Math.Sqrt(2.0), 0.0);
			return array3;
		}

		public double[] FrequencySpan(double samplingFrequencyHz)
		{
			uint num = mLengthHalf;
			double[] array = new double[num];
			double num2 = samplingFrequencyHz / 2.0 / ((double)num - 1.0);
			for (uint num3 = 0u; num3 < num; num3++)
			{
				array[num3] += num2 * (double)num3;
			}
			return array;
		}
	}
	public class FFT
	{
		private class FFTElement
		{
			public double re;

			public double im;

			public FFTElement next;

			public uint revTgt;
		}

		private double mFFTScale = 1.0;

		private uint mLogN;

		private uint mN;

		private uint mLengthTotal;

		private uint mLengthHalf;

		private FFTElement[] mX;

		public void Initialize(uint inputDataLength, uint zeroPaddingLength = 0u)
		{
			mN = inputDataLength;
			bool flag = false;
			for (mLogN = 1u; mLogN <= 32; mLogN++)
			{
				double num = Math.Pow(2.0, mLogN);
				if ((double)(inputDataLength + zeroPaddingLength) == num)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				throw new ArgumentOutOfRangeException("inputDataLength + zeroPaddingLength was not an even power of 2! FFT cannot continue.");
			}
			mLengthTotal = inputDataLength + zeroPaddingLength;
			mLengthHalf = mLengthTotal / 2 + 1;
			mFFTScale = Math.Sqrt(2.0) / (double)mLengthTotal;
			mFFTScale *= (double)mLengthTotal / (double)inputDataLength;
			mX = new FFTElement[mLengthTotal];
			for (uint num2 = 0u; num2 < mLengthTotal; num2++)
			{
				mX[num2] = new FFTElement();
			}
			for (uint num3 = 0u; num3 < mLengthTotal - 1; num3++)
			{
				mX[num3].next = mX[num3 + 1];
			}
			for (uint num4 = 0u; num4 < mLengthTotal; num4++)
			{
				mX[num4].revTgt = BitReverse(num4, mLogN);
			}
		}

		public Complex[] Execute(double[] timeSeries)
		{
			uint num = mLengthTotal >> 1;
			uint num2 = mLengthTotal >> 1;
			uint num3 = mLengthTotal;
			uint num4 = 1u;
			FFTElement fFTElement = mX[0];
			uint num5 = 0u;
			for (uint num6 = 0u; num6 < mN; num6++)
			{
				fFTElement.re = timeSeries[num5];
				fFTElement.im = 0.0;
				fFTElement = fFTElement.next;
				num5++;
			}
			if (mN != mLengthTotal)
			{
				for (uint num7 = mN; num7 < mLengthTotal; num7++)
				{
					fFTElement.re = 0.0;
					fFTElement.im = 0.0;
					fFTElement = fFTElement.next;
				}
			}
			for (uint num8 = 0u; num8 < mLogN; num8++)
			{
				double num9 = (double)num4 * -2.0 * Math.PI / (double)mLengthTotal;
				double num10 = Math.Cos(num9);
				double num11 = Math.Sin(num9);
				for (uint num12 = 0u; num12 < mLengthTotal; num12 += num3)
				{
					FFTElement fFTElement2 = mX[num12];
					FFTElement fFTElement3 = mX[num12 + num2];
					double num13 = 1.0;
					double num14 = 0.0;
					for (uint num15 = 0u; num15 < num; num15++)
					{
						double re = fFTElement2.re;
						double im = fFTElement2.im;
						double re2 = fFTElement3.re;
						double im2 = fFTElement3.im;
						fFTElement2.re = re + re2;
						fFTElement2.im = im + im2;
						re2 = re - re2;
						im2 = im - im2;
						fFTElement3.re = re2 * num13 - im2 * num14;
						fFTElement3.im = re2 * num14 + im2 * num13;
						fFTElement2 = fFTElement2.next;
						fFTElement3 = fFTElement3.next;
						double num16 = num13;
						num13 = num13 * num10 - num14 * num11;
						num14 = num16 * num11 + num14 * num10;
					}
				}
				num >>= 1;
				num2 >>= 1;
				num3 >>= 1;
				num4 <<= 1;
			}
			fFTElement = mX[0];
			Complex[] array = new Complex[mLengthTotal];
			while (fFTElement != null)
			{
				uint revTgt = fFTElement.revTgt;
				array[revTgt] = new Complex(fFTElement.re * mFFTScale, fFTElement.im * mFFTScale);
				fFTElement = fFTElement.next;
			}
			Complex[] array2 = new Complex[mLengthHalf];
			Array.Copy(array, array2, mLengthHalf);
			array2[0] = new Complex(array2[0].Real / Math.Sqrt(2.0), 0.0);
			array2[mLengthHalf - 1] = new Complex(array2[mLengthHalf - 1].Real / Math.Sqrt(2.0), 0.0);
			return array2;
		}

		private uint BitReverse(uint x, uint numBits)
		{
			uint num = 0u;
			for (uint num2 = 0u; num2 < numBits; num2++)
			{
				num <<= 1;
				num |= x & 1u;
				x >>= 1;
			}
			return num;
		}

		public double[] FrequencySpan(double samplingFrequencyHz)
		{
			uint num = mLengthHalf;
			double[] array = new double[num];
			double num2 = samplingFrequencyHz / 2.0 / ((double)num - 1.0);
			for (int i = 0; i < num; i++)
			{
				array[i] += num2 * (double)i;
			}
			return array;
		}
	}
	public class DSP
	{
		public static class Generate
		{
			private static System.Random mRandom = new System.Random();

			public static double[] LinSpace(double startVal, double stopVal, uint points)
			{
				double[] array = new double[points];
				double num = (stopVal - startVal) / ((double)points - 1.0);
				for (uint num2 = 0u; num2 < points; num2++)
				{
					array[num2] = startVal + num * (double)num2;
				}
				return array;
			}

			public static double[] ToneSampling(double amplitudeVrms, double frequencyHz, double samplingFrequencyHz, uint points, double dcV = 0.0, double phaseDeg = 0.0)
			{
				double num = phaseDeg * System.Math.PI / 180.0;
				System.Math.Sqrt(2.0);
				double[] array = new double[points];
				for (uint num2 = 0u; num2 < points; num2++)
				{
					double num3 = (double)num2 / samplingFrequencyHz;
					array[num2] = System.Math.Sqrt(2.0) * amplitudeVrms * System.Math.Sin(System.Math.PI * 2.0 * num3 * frequencyHz + num) + dcV;
				}
				return array;
			}

			public static double[] ToneCycles(double amplitudeVrms, double cycles, uint points, double dcV = 0.0, double phaseDeg = 0.0)
			{
				double num = phaseDeg * System.Math.PI / 180.0;
				double num2 = System.Math.Sqrt(2.0) * amplitudeVrms;
				double[] array = new double[points];
				for (uint num3 = 0u; num3 < points; num3++)
				{
					array[num3] = num2 * System.Math.Sin(System.Math.PI * 2.0 * (double)num3 / (double)points * cycles + num) + dcV;
				}
				return array;
			}

			public static double[] NoisePsd(double amplitudePsd, double samplingFrequencyHz, uint points)
			{
				return NoiseRms(amplitudePsd * System.Math.Sqrt(samplingFrequencyHz / 2.0), points);
			}

			public static double[] NoiseRms(double amplitudeVrms, uint points, double dcV = 0.0)
			{
				_ = new double[points];
				return Math.Add(Noise(points, amplitudeVrms), dcV);
			}

			private static double[] Noise(uint size, double scaling_vrms)
			{
				double[] array = new double[size];
				double num = 0.0;
				for (uint num2 = 0u; num2 < size; num2++)
				{
					double num3;
					double num5;
					do
					{
						num3 = 2.0 * mRandom.NextDouble() - 1.0;
						double num4 = 2.0 * mRandom.NextDouble() - 1.0;
						num5 = num3 * num3 + num4 * num4;
					}
					while (num5 >= 1.0);
					if (num5 == 0.0)
					{
						array[num2] = 0.0;
					}
					else
					{
						array[num2] = num3 * System.Math.Sqrt(-2.0 * System.Math.Log(num5) / num5) * scaling_vrms;
					}
					num += array[num2];
				}
				double num6 = num / (double)size;
				for (uint num7 = 0u; num7 < size; num7++)
				{
					array[num7] -= num6;
				}
				return array;
			}
		}

		public static class Window
		{
			public enum Type
			{
				None,
				Rectangular,
				Welch,
				Bartlett,
				Hanning,
				Hann,
				Hamming,
				Nutall3,
				Nutall4,
				Nutall3A,
				Nutall3B,
				Nutall4A,
				BH92,
				Nutall4B,
				SFT3F,
				SFT3M,
				FTNI,
				SFT4F,
				SFT5F,
				SFT4M,
				FTHP,
				HFT70,
				FTSRS,
				SFT5M,
				HFT90D,
				HFT95,
				HFT116D,
				HFT144D,
				HFT169D,
				HFT196D,
				HFT223D,
				HFT248D
			}

			public static class ScaleFactor
			{
				public static double Signal(double[] windowCoefficients)
				{
					double num = 0.0;
					foreach (double num2 in windowCoefficients)
					{
						num += num2;
					}
					num /= (double)windowCoefficients.Length;
					return 1.0 / num;
				}

				public static double Noise(double[] windowCoefficients, double samplingFrequencyHz)
				{
					double num = 0.0;
					foreach (double num2 in windowCoefficients)
					{
						num += num2 * num2;
					}
					double num3 = windowCoefficients.Length;
					double num4 = samplingFrequencyHz / num3;
					return System.Math.Sqrt(1.0 / (num / num3 * num4));
				}

				public static double NENBW(double[] windowCoefficients)
				{
					double num = 0.0;
					double num2 = 0.0;
					foreach (double num3 in windowCoefficients)
					{
						num += num3;
						num2 += num3 * num3;
					}
					double num4 = windowCoefficients.Length;
					num /= num4;
					return num2 / (num * num) / num4;
				}
			}

			public static double[] Coefficients(Type windowName, uint points)
			{
				double[] array = new double[points];
				double num = points;
				switch (windowName)
				{
				case Type.None:
				case Type.Rectangular:
				{
					for (uint num3 = 0u; num3 < points; num3++)
					{
						array[num3] = 1.0;
					}
					break;
				}
				case Type.Bartlett:
				{
					for (uint num4 = 0u; num4 < points; num4++)
					{
						array[num4] = 2.0 / num * (num / 2.0 - System.Math.Abs((double)num4 - (num - 1.0) / 2.0));
					}
					break;
				}
				case Type.Welch:
				{
					for (uint num2 = 0u; num2 < points; num2++)
					{
						array[num2] = 1.0 - System.Math.Pow(2.0 * (double)num2 / num - 1.0, 2.0);
					}
					break;
				}
				case Type.Hanning:
				case Type.Hann:
					array = SineExpansion(points, 0.5, -0.5);
					break;
				case Type.Hamming:
					array = SineExpansion(points, 0.54, -0.46);
					break;
				case Type.BH92:
					array = SineExpansion(points, 287.0 / 800.0, -0.48829, 0.14128, -0.01168);
					break;
				case Type.Nutall3:
					array = SineExpansion(points, 0.375, -0.5, 0.125);
					break;
				case Type.Nutall3A:
					array = SineExpansion(points, 0.40897, -0.5, 0.09103);
					break;
				case Type.Nutall3B:
					array = SineExpansion(points, 0.4243801, -0.4973406, 0.0782793);
					break;
				case Type.Nutall4:
					array = SineExpansion(points, 0.3125, -15.0 / 32.0, 0.1875, -1.0 / 32.0);
					break;
				case Type.Nutall4A:
					array = SineExpansion(points, 0.338946, -0.481973, 0.161054, -0.018027);
					break;
				case Type.Nutall4B:
					array = SineExpansion(points, 0.355768, -0.487396, 0.144232, -0.012604);
					break;
				case Type.SFT3F:
					array = SineExpansion(points, 0.26526, -0.5, 0.23474);
					break;
				case Type.SFT4F:
					array = SineExpansion(points, 0.21706, -0.42103, 0.28294, -0.07897);
					break;
				case Type.SFT5F:
					array = SineExpansion(points, 0.1881, -0.36923, 0.28702, -0.13077, 0.02488);
					break;
				case Type.SFT3M:
					array = SineExpansion(points, 0.28235, -0.52105, 0.19659);
					break;
				case Type.SFT4M:
					array = SineExpansion(points, 0.241906, -0.460841, 0.255381, -0.041872);
					break;
				case Type.SFT5M:
					array = SineExpansion(points, 0.209671, -0.407331, 0.281225, -0.092669, 0.0091036);
					break;
				case Type.FTNI:
					array = SineExpansion(points, 0.2810639, -0.5208972, 0.1980399);
					break;
				case Type.FTHP:
					array = SineExpansion(points, 1.0, -1.912510941, 1.079173272, -0.1832630879);
					break;
				case Type.HFT70:
					array = SineExpansion(points, 1.0, -1.90796, 1.07349, -0.18199);
					break;
				case Type.FTSRS:
					array = SineExpansion(points, 1.0, -1.93, 1.29, -0.388, 0.028);
					break;
				case Type.HFT90D:
					array = SineExpansion(points, 1.0, -1.942604, 1.340318, -0.440811, 0.043097);
					break;
				case Type.HFT95:
					array = SineExpansion(points, 1.0, -1.9383379, 1.3045202, -0.402827, 0.0350665);
					break;
				case Type.HFT116D:
					array = SineExpansion(points, 1.0, -1.9575375, 1.4780705, -0.6367431, 0.1228389, -0.0066288);
					break;
				case Type.HFT144D:
					array = SineExpansion(points, 1.0, -1.96760033, 1.57983607, -0.81123644, 0.22583558, -0.02773848, 0.0009036);
					break;
				case Type.HFT169D:
					array = SineExpansion(points, 1.0, -1.97441842, 1.65409888, -0.95788186, 0.3367342, -0.06364621, 0.00521942, -0.00010599);
					break;
				case Type.HFT196D:
					array = SineExpansion(points, 1.0, -1.97928042, 1.710288951, -1.081629853, 0.448734314, -0.112376628, 0.015122992, -0.000871252, 1.1896E-05);
					break;
				case Type.HFT223D:
					array = SineExpansion(points, 1.0, -1.98298997309, 1.75556083063, -1.19037717712, 0.56155440797, -0.17296769663, 0.03233247087, -0.00324954578, 0.0001380104, -1.32725E-06);
					break;
				case Type.HFT248D:
					array = SineExpansion(points, 1.0, -1.985844164102, 1.791176438506, -1.282075284005, 0.667777530266, -0.240160796576, 0.056656381764, -0.008134974479, 0.00062454465, -1.9808998E-05, 1.32974E-07);
					break;
				}
				return array;
			}

			private static double[] SineExpansion(uint points, double c0, double c1 = 0.0, double c2 = 0.0, double c3 = 0.0, double c4 = 0.0, double c5 = 0.0, double c6 = 0.0, double c7 = 0.0, double c8 = 0.0, double c9 = 0.0, double c10 = 0.0)
			{
				double[] array = new double[points];
				for (uint num = 0u; num < points; num++)
				{
					array[num] = System.Math.PI * 2.0 * (double)num / (double)points;
				}
				double[] array2 = new double[points];
				for (uint num2 = 0u; num2 < points; num2++)
				{
					double num3 = c0;
					num3 += c1 * System.Math.Cos(array[num2]);
					num3 += c2 * System.Math.Cos(2.0 * array[num2]);
					num3 += c3 * System.Math.Cos(3.0 * array[num2]);
					num3 += c4 * System.Math.Cos(4.0 * array[num2]);
					num3 += c5 * System.Math.Cos(5.0 * array[num2]);
					num3 += c6 * System.Math.Cos(6.0 * array[num2]);
					num3 += c7 * System.Math.Cos(7.0 * array[num2]);
					num3 += c8 * System.Math.Cos(8.0 * array[num2]);
					num3 += c9 * System.Math.Cos(9.0 * array[num2]);
					num3 += c10 * System.Math.Cos(10.0 * array[num2]);
					array2[num2] = num3;
				}
				return array2;
			}
		}

		public static class ConvertMagnitude
		{
			public static double[] ToMagnitudeSquared(double[] magnitude)
			{
				uint num = (uint)magnitude.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = magnitude[num2] * magnitude[num2];
				}
				return array;
			}

			public static double[] ToMagnitudeDBV(double[] magnitude)
			{
				uint num = (uint)magnitude.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double num3 = magnitude[num2];
					if (num3 <= 0.0)
					{
						num3 = double.Epsilon;
					}
					array[num2] = 20.0 * System.Math.Log10(num3);
				}
				return array;
			}
		}

		public static class ConvertMagnitudeSquared
		{
			public static double[] ToMagnitude(double[] magSquared)
			{
				uint num = (uint)magSquared.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = System.Math.Sqrt(magSquared[num2]);
				}
				return array;
			}

			public static double[] ToMagnitudeDBV(double[] magSquared)
			{
				uint num = (uint)magSquared.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double num3 = magSquared[num2];
					if (num3 <= 0.0)
					{
						num3 = double.Epsilon;
					}
					array[num2] = 10.0 * System.Math.Log10(num3);
				}
				return array;
			}
		}

		public static class ConvertComplex
		{
			public static double[] ToMagnitudeSquared(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double magnitude = rawFFT[num2].Magnitude;
					array[num2] = magnitude * magnitude;
				}
				return array;
			}

			public static double[] ToMagnitude(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = rawFFT[num2].Magnitude;
				}
				return array;
			}

			public static double[] ToMagnitudeDBV(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					double num3 = rawFFT[num2].Magnitude;
					if (num3 <= 0.0)
					{
						num3 = double.Epsilon;
					}
					array[num2] = 20.0 * System.Math.Log10(num3);
				}
				return array;
			}

			public static double[] ToPhaseDegrees(Complex[] rawFFT)
			{
				double num = 180.0 / System.Math.PI;
				uint num2 = (uint)rawFFT.Length;
				double[] array = new double[num2];
				for (uint num3 = 0u; num3 < num2; num3++)
				{
					array[num3] = rawFFT[num3].Phase * num;
				}
				return array;
			}

			public static double[] ToPhaseRadians(Complex[] rawFFT)
			{
				uint num = (uint)rawFFT.Length;
				double[] array = new double[num];
				for (uint num2 = 0u; num2 < num; num2++)
				{
					array[num2] = rawFFT[num2].Phase;
				}
				return array;
			}
		}

		public static class Analyze
		{
			public static double FindRms(double[] a, uint startBin = 10u, uint stopBin = 10u)
			{
				double num = 0.0;
				uint num2 = 0u;
				uint num3 = (uint)a.Length;
				for (uint num4 = 0u; num4 < num3; num4++)
				{
					if (num4 > startBin - 1 && num4 <= num3 - 1 - stopBin)
					{
						num += a[num4] * a[num4];
						num2++;
					}
				}
				return System.Math.Sqrt(num / (double)num2);
			}

			public static double FindMean(double[] inData, uint startBin = 10u, uint stopBin = 10u)
			{
				double num = 0.0;
				double num2 = inData.Length;
				uint num3 = 0u;
				for (uint num4 = 0u; (double)num4 < num2; num4++)
				{
					if (num4 > startBin - 1 && !((double)num4 > num2 - 1.0 - (double)stopBin))
					{
						num += inData[num4];
						num3++;
					}
				}
				return num / (double)num3;
			}

			public static double FindMaxAmplitude(double[] inData)
			{
				double num = inData.Length;
				double num2 = -1E+300;
				for (uint num3 = 0u; (double)num3 < num; num3++)
				{
					if (inData[num3] > num2)
					{
						num2 = inData[num3];
					}
				}
				return num2;
			}

			public static uint FindMaxPosition(double[] inData)
			{
				double num = inData.Length;
				double num2 = -1E+300;
				uint result = 0u;
				for (uint num3 = 0u; (double)num3 < num; num3++)
				{
					if (inData[num3] > num2)
					{
						result = num3;
						num2 = inData[num3];
					}
				}
				return result;
			}

			public static double FindMaxFrequency(double[] inData, double[] fSpan)
			{
				double num = inData.Length;
				double num2 = -1E+300;
				uint num3 = 0u;
				for (uint num4 = 0u; (double)num4 < num; num4++)
				{
					if (inData[num4] > num2)
					{
						num3 = num4;
						num2 = inData[num4];
					}
				}
				return fSpan[num3];
			}

			public static double[] UnwrapPhaseDegrees(double[] inPhaseDeg)
			{
				uint num = (uint)inPhaseDeg.Length;
				double[] array = new double[num];
				double[] array2 = new double[num];
				inPhaseDeg.CopyTo(array2, 0);
				array[0] = array2[0];
				for (uint num2 = 1u; num2 < num; num2++)
				{
					if (System.Math.Abs(array2[num2 - 1] - array2[num2]) >= 180.0)
					{
						if (array2[num2 - 1] < 0.0)
						{
							for (uint num3 = num2; num3 < num; num3++)
							{
								array2[num3] += -360.0;
							}
						}
						else
						{
							for (uint num4 = num2; num4 < num; num4++)
							{
								array2[num4] += 360.0;
							}
						}
					}
					array[num2] = array2[num2];
				}
				return array;
			}

			public static double[] UnwrapPhaseRadians(double[] inPhaseRad)
			{
				double num = System.Math.PI;
				double num2 = System.Math.PI * 2.0;
				uint num3 = (uint)inPhaseRad.Length;
				double[] array = new double[num3];
				inPhaseRad.CopyTo(array, 0);
				double[] array2 = new double[num3];
				array2[0] = array[0];
				for (uint num4 = 1u; num4 < num3; num4++)
				{
					if (System.Math.Abs(array[num4 - 1] - array[num4]) >= num)
					{
						if (array[num4 - 1] < 0.0)
						{
							for (uint num5 = num4; num5 < num3; num5++)
							{
								array[num5] += 0.0 - num2;
							}
						}
						else
						{
							for (uint num6 = num4; num6 < num3; num6++)
							{
								array[num6] += num2;
							}
						}
					}
					array2[num4] = array[num4];
				}
				return array2;
			}
		}

		public static class Math
		{
			public static double[] Multiply(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] * b[num];
				}
				return array;
			}

			public static double[] Multiply(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] * b;
				}
				return array;
			}

			public static double[] Add(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] + b[num];
				}
				return array;
			}

			public static double[] Add(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] + b;
				}
				return array;
			}

			public static double[] Subtract(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] - b[num];
				}
				return array;
			}

			public static double[] Subtract(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] - b;
				}
				return array;
			}

			public static double[] Divide(double[] a, double[] b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] / b[num];
				}
				return array;
			}

			public static double[] Divide(double[] a, double b)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] / b;
				}
				return array;
			}

			public static double[] Sqrt(double[] a)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = System.Math.Sqrt(a[num]);
				}
				return array;
			}

			public static double[] Square(double[] a)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					array[num] = a[num] * a[num];
				}
				return array;
			}

			public static double[] Log10(double[] a)
			{
				double[] array = new double[a.Length];
				for (uint num = 0u; num < a.Length; num++)
				{
					double num2 = a[num];
					if (num2 <= 0.0)
					{
						num2 = double.Epsilon;
					}
					array[num] = System.Math.Log10(num2);
				}
				return array;
			}

			public static double[] RemoveMean(double[] a)
			{
				double num = 0.0;
				for (uint num2 = 0u; num2 < a.Length; num2++)
				{
					num += a[num2];
				}
				double b = num / (double)a.Length;
				return Subtract(a, b);
			}
		}
	}
}
namespace UnityStandardAssets.SceneUtils
{
	public class ParticleSceneControls : MonoBehaviour
	{
		public enum Mode
		{
			Activate,
			Instantiate,
			Trail
		}

		public enum AlignMode
		{
			Normal,
			Up
		}

		[Serializable]
		public class DemoParticleSystem
		{
			public Transform transform;

			public Mode mode;

			public AlignMode align;

			public int maxCount;

			public float minDist;

			public int camOffset = 15;

			public string instructionText;
		}

		[Serializable]
		public class DemoParticleSystemList
		{
			public DemoParticleSystem[] items;
		}

		public DemoParticleSystemList demoParticles;

		public float spawnOffset = 0.5f;

		public float multiply = 1f;

		public bool clearOnChange;

		public Text titleText;

		public Transform sceneCamera;

		public Text instructionText;

		public Button previousButton;

		public Button nextButton;

		public GraphicRaycaster graphicRaycaster;

		public EventSystem eventSystem;

		private ParticleSystemMultiplier m_ParticleMultiplier;

		private List<Transform> m_CurrentParticleList = new List<Transform>();

		private Transform m_Instance;

		private static int s_SelectedIndex;

		private UnityEngine.Vector3 m_CamOffsetVelocity = UnityEngine.Vector3.zero;

		private UnityEngine.Vector3 m_LastPos;

		private static DemoParticleSystem s_Selected;

		private void Awake()
		{
			Select(s_SelectedIndex);
			previousButton.onClick.AddListener(Previous);
			nextButton.onClick.AddListener(Next);
		}

		private void OnDisable()
		{
			previousButton.onClick.RemoveListener(Previous);
			nextButton.onClick.RemoveListener(Next);
		}

		private void Previous()
		{
			s_SelectedIndex--;
			if (s_SelectedIndex == -1)
			{
				s_SelectedIndex = demoParticles.items.Length - 1;
			}
			Select(s_SelectedIndex);
		}

		public void Next()
		{
			s_SelectedIndex++;
			if (s_SelectedIndex == demoParticles.items.Length)
			{
				s_SelectedIndex = 0;
			}
			Select(s_SelectedIndex);
		}

		private void Update()
		{
			sceneCamera.localPosition = UnityEngine.Vector3.SmoothDamp(sceneCamera.localPosition, UnityEngine.Vector3.forward * -s_Selected.camOffset, ref m_CamOffsetVelocity, 1f);
			if (s_Selected.mode == Mode.Activate || CheckForGuiCollision())
			{
				return;
			}
			bool num = Input.GetMouseButtonDown(0) && s_Selected.mode == Mode.Instantiate;
			bool flag = Input.GetMouseButton(0) && s_Selected.mode == Mode.Trail;
			if (!(num || flag) || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
			{
				return;
			}
			UnityEngine.Quaternion rotation = UnityEngine.Quaternion.LookRotation(hitInfo.normal);
			if (s_Selected.align == AlignMode.Up)
			{
				rotation = UnityEngine.Quaternion.identity;
			}
			UnityEngine.Vector3 vector = hitInfo.point + hitInfo.normal * spawnOffset;
			if (!((vector - m_LastPos).magnitude > s_Selected.minDist))
			{
				return;
			}
			if (s_Selected.mode != Mode.Trail || m_Instance == null)
			{
				m_Instance = UnityEngine.Object.Instantiate(s_Selected.transform, vector, rotation);
				if (m_ParticleMultiplier != null)
				{
					m_Instance.GetComponent<ParticleSystemMultiplier>().multiplier = multiply;
				}
				m_CurrentParticleList.Add(m_Instance);
				if (s_Selected.maxCount > 0 && m_CurrentParticleList.Count > s_Selected.maxCount)
				{
					if (m_CurrentParticleList[0] != null)
					{
						UnityEngine.Object.Destroy(m_CurrentParticleList[0].gameObject);
					}
					m_CurrentParticleList.RemoveAt(0);
				}
			}
			else
			{
				m_Instance.position = vector;
				m_Instance.rotation = rotation;
			}
			if (s_Selected.mode == Mode.Trail)
			{
				ParticleSystem.EmissionModule emission = m_Instance.transform.GetComponent<ParticleSystem>().emission;
				emission.enabled = false;
				m_Instance.transform.GetComponent<ParticleSystem>().Emit(1);
			}
			m_Instance.parent = hitInfo.transform;
			m_LastPos = vector;
		}

		private bool CheckForGuiCollision()
		{
			PointerEventData pointerEventData = new PointerEventData(eventSystem);
			pointerEventData.pressPosition = Input.mousePosition;
			pointerEventData.position = Input.mousePosition;
			List<RaycastResult> list = new List<RaycastResult>();
			graphicRaycaster.Raycast(pointerEventData, list);
			return list.Count > 0;
		}

		private void Select(int i)
		{
			s_Selected = demoParticles.items[i];
			m_Instance = null;
			DemoParticleSystem[] items = demoParticles.items;
			foreach (DemoParticleSystem demoParticleSystem in items)
			{
				if (demoParticleSystem != s_Selected && demoParticleSystem.mode == Mode.Activate)
				{
					demoParticleSystem.transform.gameObject.SetActive(value: false);
				}
			}
			if (s_Selected.mode == Mode.Activate)
			{
				s_Selected.transform.gameObject.SetActive(value: true);
			}
			m_ParticleMultiplier = s_Selected.transform.GetComponent<ParticleSystemMultiplier>();
			multiply = 1f;
			if (clearOnChange)
			{
				while (m_CurrentParticleList.Count > 0)
				{
					UnityEngine.Object.Destroy(m_CurrentParticleList[0].gameObject);
					m_CurrentParticleList.RemoveAt(0);
				}
			}
			instructionText.text = s_Selected.instructionText;
			titleText.text = s_Selected.transform.name;
		}
	}
	public class PlaceTargetWithMouse : MonoBehaviour
	{
		public float surfaceOffset = 1.5f;

		public GameObject setTargetOn;

		private void Update()
		{
			if (Input.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
			{
				base.transform.position = hitInfo.point + hitInfo.normal * surfaceOffset;
				if (setTargetOn != null)
				{
					setTargetOn.SendMessage("SetTarget", base.transform);
				}
			}
		}
	}
	public class SlowMoButton : MonoBehaviour
	{
		public Sprite FullSpeedTex;

		public Sprite SlowSpeedTex;

		public float fullSpeed = 1f;

		public float slowSpeed = 0.3f;

		public Button button;

		private bool m_SlowMo;

		private void Start()
		{
			m_SlowMo = false;
		}

		private void OnDestroy()
		{
			Time.timeScale = 1f;
		}

		public void ChangeSpeed()
		{
			m_SlowMo = !m_SlowMo;
			Image image = button.targetGraphic as Image;
			if (image != null)
			{
				image.sprite = (m_SlowMo ? SlowSpeedTex : FullSpeedTex);
			}
			button.targetGraphic = image;
			Time.timeScale = (m_SlowMo ? slowSpeed : fullSpeed);
		}
	}
}
namespace RayFire
{
	[Serializable]
	public class RFActivation
	{
		[Space(2f)]
		[Tooltip("Inactive object will be activated when it's velocity will be higher than By Velocity value when pushed by other dynamic objects.")]
		public float byVelocity;

		[Space(1f)]
		[Tooltip("Inactive object will be activated if will be pushed from it's original position farther than By Offset value.")]
		public float byOffset;

		[Space(1f)]
		[Tooltip("Inactive object will be activated if will get total damage higher than this value.")]
		public float byDamage;

		[Space(1f)]
		[Tooltip("Inactive object will be activated by overlapping with object with RayFire Activator component.")]
		public bool byActivator;

		[Space(1f)]
		[Tooltip("Inactive object will be activated when it will be shot by RayFireGun component.")]
		public bool byImpact;

		[Space(1f)]
		[Tooltip("Inactive object will be activated by Connectivity component if it will not be connected with Unyielding zone.")]
		public bool byConnectivity;

		[Space(3f)]
		public bool unyielding;

		[HideInInspector]
		public bool activated;

		[NonSerialized]
		public RayfireConnectivity connect;

		public RFActivation()
		{
			byVelocity = 0f;
			byOffset = 0f;
			byDamage = 0f;
			byActivator = false;
			byImpact = false;
			byConnectivity = false;
			unyielding = false;
			Reset();
		}

		public void CopyFrom(RFActivation act)
		{
			byActivator = act.byActivator;
			byImpact = act.byImpact;
			byVelocity = act.byVelocity;
			byOffset = act.byOffset;
			byDamage = act.byDamage;
			byConnectivity = act.byConnectivity;
			unyielding = act.unyielding;
		}

		public void Reset()
		{
			activated = false;
		}

		public void CheckConnectivity()
		{
			if (byConnectivity && connect != null)
			{
				connect.checkNeed = true;
				connect = null;
			}
		}

		public IEnumerator ActivationVelocityCor(RayfireRigid scr)
		{
			while (!scr.activation.activated && scr.activation.byVelocity > 0f)
			{
				if (scr.physics.rigidBody.velocity.magnitude > byVelocity)
				{
					scr.Activate();
				}
				yield return null;
			}
		}

		public IEnumerator ActivationOffsetCor(RayfireRigid scr)
		{
			while (!scr.activation.activated && scr.activation.byOffset > 0f)
			{
				if (UnityEngine.Vector3.Distance(scr.transForm.position, scr.physics.initPosition) > scr.activation.byOffset)
				{
					scr.Activate();
				}
				yield return null;
			}
		}

		public IEnumerator InactiveCor(RayfireRigid scr)
		{
			while (scr.simulationType == SimType.Inactive)
			{
				scr.physics.rigidBody.velocity = UnityEngine.Vector3.zero;
				scr.physics.rigidBody.angularVelocity = UnityEngine.Vector3.zero;
				yield return null;
			}
		}

		public static void Activate(RayfireRigid scr)
		{
			if (scr.physics.exclude)
			{
				return;
			}
			if (!scr.initialized)
			{
				scr.Initialize();
			}
			if (scr.simulationType == SimType.Kinematic)
			{
				MeshCollider meshCollider = scr.physics.meshCollider as MeshCollider;
				if (meshCollider != null)
				{
					meshCollider.convex = true;
				}
				if (scr.physics.recorder)
				{
					scr.simulationType = SimType.Dynamic;
					scr.physics.rigidBody.isKinematic = false;
					scr.physics.rigidBody.useGravity = scr.physics.useGravity;
					GameObject gameObject = scr.InstantiateGo(scr.gameObject);
					gameObject.transform.position = scr.transForm.position;
					gameObject.transform.rotation = scr.transForm.rotation;
					Rigidbody component = gameObject.GetComponent<Rigidbody>();
					if (component != null)
					{
						component.velocity = scr.physics.rigidBody.velocity;
						component.angularVelocity = scr.physics.rigidBody.angularVelocity;
					}
					scr.gameObject.SetActive(value: false);
				}
			}
			scr.activation.CheckConnectivity();
			scr.activation.activated = true;
			scr.simulationType = SimType.Dynamic;
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
			if (scr.fading.onActivation)
			{
				scr.Fade();
			}
			RFParticles.InitActivationParticles(scr);
			scr.activationEvent.InvokeLocalEvent(scr);
			RFActivationEvent.InvokeGlobalEvent(scr);
		}
	}
	[Serializable]
	public class RFCluster : IComparable<RFCluster>
	{
		public int id;

		public Transform tm;

		public Transform rootParent;

		public int depth;

		[NonSerialized]
		public UnityEngine.Vector3 pos;

		[NonSerialized]
		public Bounds bound;

		[NonSerialized]
		public List<RFShard> shards = new List<RFShard>();

		[NonSerialized]
		public List<RFCluster> childClusters = new List<RFCluster>();

		[NonSerialized]
		public List<RFCluster> neibClusters = new List<RFCluster>();

		[NonSerialized]
		public List<float> neibArea = new List<float>();

		[NonSerialized]
		private List<float> neibPerc = new List<float>();

		public int CompareTo(RFCluster otherCluster)
		{
			float magnitude = bound.size.magnitude;
			float magnitude2 = otherCluster.bound.size.magnitude;
			if (magnitude > magnitude2)
			{
				return -1;
			}
			if (magnitude < magnitude2)
			{
				return 1;
			}
			return 0;
		}

		private List<RFShard> GetNestedShards(bool OwnShards = false)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFCluster> list2 = new List<RFCluster>();
			list2.AddRange(childClusters);
			if (OwnShards)
			{
				list.AddRange(shards);
			}
			while (list2.Count > 0)
			{
				list.AddRange(list2[0].shards);
				list2.AddRange(list2[0].childClusters);
				list2.RemoveAt(0);
			}
			return list;
		}

		public List<RFCluster> GetNestedClusters()
		{
			List<RFCluster> list = new List<RFCluster>();
			list.AddRange(childClusters);
			List<RFCluster> list2 = new List<RFCluster>();
			list2.AddRange(childClusters);
			while (list2.Count > 0)
			{
				list.AddRange(list2[0].childClusters);
				list2.RemoveAt(0);
			}
			return list;
		}

		private bool TrisNeib(RFCluster otherCluster)
		{
			foreach (RFShard shard in shards)
			{
				for (int i = 0; i < shard.neibShards.Count; i++)
				{
					if (otherCluster.shards.Contains(shard.neibShards[i]))
					{
						return true;
					}
				}
			}
			List<RFShard> nestedShards = GetNestedShards();
			List<RFShard> nestedShards2 = otherCluster.GetNestedShards();
			foreach (RFShard item in nestedShards)
			{
				for (int j = 0; j < item.neibShards.Count; j++)
				{
					if (nestedShards2.Contains(item.neibShards[j]))
					{
						return true;
					}
				}
			}
			return false;
		}

		private float NeibArea(RFCluster otherCluster)
		{
			float num = 0f;
			foreach (RFShard shard in shards)
			{
				for (int i = 0; i < shard.neibShards.Count; i++)
				{
					if (otherCluster.shards.Contains(shard.neibShards[i]))
					{
						num += shard.neibArea[i];
					}
				}
			}
			List<RFShard> nestedShards = GetNestedShards();
			List<RFShard> nestedShards2 = otherCluster.GetNestedShards();
			foreach (RFShard item in nestedShards)
			{
				for (int j = 0; j < item.neibShards.Count; j++)
				{
					if (nestedShards2.Contains(item.neibShards[j]))
					{
						num += item.neibArea[j];
					}
				}
			}
			return num;
		}

		public int GetNeibIndArea(List<RFCluster> clusterList = null)
		{
			float num = 0f;
			int result = 0;
			for (int i = 0; i < neibClusters.Count; i++)
			{
				if ((clusterList == null || clusterList.Contains(neibClusters[i])) && neibArea[i] > num)
				{
					num = neibArea[i];
					result = i;
				}
			}
			if (num > 0f)
			{
				return result;
			}
			return -1;
		}

		public static void SetClusterNeib(List<RFCluster> clusters, bool connectivity)
		{
			foreach (RFCluster cluster in clusters)
			{
				cluster.neibClusters = new List<RFCluster>();
				cluster.neibArea = new List<float>();
				cluster.neibPerc = new List<float>();
			}
			for (int i = 0; i < clusters.Count; i++)
			{
				for (int j = 0; j < clusters.Count; j++)
				{
					if (j != i && !clusters[j].neibClusters.Contains(clusters[i]) && clusters[i].bound.Intersects(clusters[j].bound))
					{
						if (!connectivity)
						{
							float magnitude = clusters[i].bound.size.magnitude;
							clusters[i].neibClusters.Add(clusters[j]);
							clusters[i].neibArea.Add(magnitude);
							clusters[j].neibClusters.Add(clusters[i]);
							clusters[j].neibArea.Add(magnitude);
						}
						else if (clusters[i].TrisNeib(clusters[j]))
						{
							float item = clusters[i].NeibArea(clusters[j]);
							clusters[i].neibClusters.Add(clusters[j]);
							clusters[i].neibArea.Add(item);
							clusters[j].neibClusters.Add(clusters[i]);
							clusters[j].neibArea.Add(item);
						}
					}
				}
				float num = Mathf.Max(clusters[i].neibArea.ToArray());
				foreach (float item2 in clusters[i].neibArea)
				{
					if (num > 0f)
					{
						clusters[i].neibPerc.Add(item2 / num);
					}
					else
					{
						clusters[i].neibPerc.Add(0f);
					}
				}
			}
		}

		public static RFCluster GetNeibClusterArea(List<RFCluster> clusters, List<RFCluster> clusterList)
		{
			if (clusterList.Count == 0)
			{
				return null;
			}
			List<RFCluster> list = new List<RFCluster>();
			float num = 0f;
			RFCluster result = null;
			foreach (RFCluster cluster in clusters)
			{
				for (int i = 0; i < cluster.neibClusters.Count; i++)
				{
					if (!(cluster.neibPerc[i] < 0.5f) && !(num >= cluster.neibArea[i]) && !list.Contains(cluster.neibClusters[i]) && clusterList.Contains(cluster.neibClusters[i]))
					{
						list.Add(cluster.neibClusters[i]);
						num = cluster.neibArea[i];
						result = cluster.neibClusters[i];
					}
				}
			}
			return result;
		}

		public static List<RFCluster> ConnectivityCheck(List<RFShard> shards)
		{
			int count = shards.Count;
			List<RFCluster> list = new List<RFCluster>();
			while (shards.Count > 0)
			{
				List<RFShard> list2 = new List<RFShard>();
				List<RFShard> list3 = new List<RFShard>();
				list2.Add(shards[0]);
				list3.Add(shards[0]);
				while (list2.Count > 0)
				{
					foreach (RFShard neibShard in list2[0].neibShards)
					{
						if (shards.Contains(neibShard) && !list3.Contains(neibShard))
						{
							list2.Add(neibShard);
							list3.Add(neibShard);
						}
					}
					list2.RemoveAt(0);
				}
				if (count == list3.Count)
				{
					break;
				}
				RFCluster rFCluster = new RFCluster();
				rFCluster.shards = list3;
				list.Add(rFCluster);
				for (int num = shards.Count - 1; num >= 0; num--)
				{
					if (list3.Contains(shards[num]))
					{
						shards.RemoveAt(num);
					}
				}
			}
			return list;
		}

		public static void ConnectivityCheckUny(RFCluster cluster)
		{
			cluster.childClusters = new List<RFCluster>();
			if (cluster.shards.Count == 0)
			{
				return;
			}
			for (int num = cluster.shards.Count - 1; num >= 0; num--)
			{
				if (cluster.shards[num].rigid == null || cluster.shards[num].rigid.activation.connect == null || cluster.shards[num].rigid.limitations.demolished)
				{
					cluster.shards.RemoveAt(num);
				}
			}
			List<RFShard> list = new List<RFShard>();
			List<RFShard> list2 = new List<RFShard>();
			foreach (RFShard shard in cluster.shards)
			{
				if (shard.rigid.activation.unyielding)
				{
					list2.Add(shard);
				}
				else
				{
					list.Add(shard);
				}
			}
			if (list.Count == 0)
			{
				cluster.shards.Clear();
				return;
			}
			while (list2.Count > 0)
			{
				foreach (RFShard neibShard in list2[0].neibShards)
				{
					if (list.Contains(neibShard))
					{
						list.Remove(neibShard);
						list2.Add(neibShard);
					}
				}
				list2.RemoveAt(0);
			}
			foreach (RFShard item in list)
			{
				cluster.shards.Remove(item);
			}
			if (list.Count != 0)
			{
				RFCluster rFCluster = new RFCluster();
				rFCluster.shards = list;
				cluster.childClusters.Add(rFCluster);
			}
		}

		public static RFCluster SetCluster(Transform transform, ConnectivityType connectivity)
		{
			RFCluster obj = new RFCluster
			{
				tm = transform,
				rootParent = null,
				depth = 0,
				pos = transform.position,
				id = 0
			};
			obj.shards = RFShard.GetShards(obj.tm, connectivity);
			return obj;
		}

		public static Bounds GetChildrenBound(Transform tm)
		{
			List<Renderer> list = tm.GetComponentsInChildren<Renderer>().ToList();
			List<Bounds> list2 = new List<Bounds>();
			foreach (Renderer item in list)
			{
				list2.Add(item.bounds);
			}
			return GetBoundsBound(list2);
		}

		public static Bounds GetBoundsBound(List<Bounds> bounds)
		{
			Bounds result = default(Bounds);
			if (bounds.Count == 0)
			{
				UnityEngine.Debug.Log("GetBoundsBound error");
				return result;
			}
			float x = bounds[0].min.x;
			float y = bounds[0].min.y;
			float z = bounds[0].min.z;
			float x2 = bounds[0].max.x;
			float y2 = bounds[0].max.y;
			float z2 = bounds[0].max.z;
			if (bounds.Count > 1)
			{
				for (int i = 1; i < bounds.Count; i++)
				{
					if (bounds[i].min.x < x)
					{
						x = bounds[i].min.x;
					}
					if (bounds[i].min.y < y)
					{
						y = bounds[i].min.y;
					}
					if (bounds[i].min.z < z)
					{
						z = bounds[i].min.z;
					}
					if (bounds[i].max.x > x2)
					{
						x2 = bounds[i].max.x;
					}
					if (bounds[i].max.y > y2)
					{
						y2 = bounds[i].max.y;
					}
					if (bounds[i].max.z > z2)
					{
						z2 = bounds[i].max.z;
					}
				}
			}
			result.center = new UnityEngine.Vector3((x2 - x) / 2f, (y2 - y) / 2f, (z2 - z) / 2f);
			result.min = new UnityEngine.Vector3(x, y, z);
			result.max = new UnityEngine.Vector3(x2, y2, z2);
			return result;
		}
	}
	[Serializable]
	public class RFTriangle
	{
		public int id;

		public float area;

		public UnityEngine.Vector3 normal;

		public UnityEngine.Vector3 pos;

		public List<int> verts;

		public List<int> neibs;

		public RFTriangle(int Id, float Area, UnityEngine.Vector3 Normal, UnityEngine.Vector3 Pos, List<int> Verts)
		{
			id = Id;
			area = Area;
			normal = Normal;
			pos = Pos;
			verts = Verts;
			neibs = new List<int>();
		}

		public static List<RFTriangle> SetTriangles(Transform tm, MeshFilter mf)
		{
			return GetTriangles(mf.sharedMesh, tm);
		}

		public static List<RFTriangle> GetTriangles(Mesh mesh, Transform tm)
		{
			List<RFTriangle> list = new List<RFTriangle>();
			for (int i = 0; i < mesh.triangles.Length; i += 3)
			{
				int num = mesh.triangles[i];
				int num2 = mesh.triangles[i + 1];
				int num3 = mesh.triangles[i + 2];
				UnityEngine.Vector3 vector = tm.TransformPoint(mesh.vertices[num]);
				UnityEngine.Vector3 vector2 = tm.TransformPoint(mesh.vertices[num2]);
				UnityEngine.Vector3 vector3 = tm.TransformPoint(mesh.vertices[num3]);
				float num4 = UnityEngine.Vector3.Cross(vector - vector2, vector - vector3).magnitude * 0.5f;
				UnityEngine.Vector3 vector4 = (vector + vector2 + vector3) / 3f;
				RFTriangle item = new RFTriangle(i / 3, num4, mesh.normals[num], vector4, new List<int> { num, num2, num3 });
				list.Add(item);
			}
			return list;
		}
	}
	[Serializable]
	public class RFFace
	{
		public int id;

		public float area;

		public UnityEngine.Vector3 pos;

		public UnityEngine.Vector3 normal;

		public List<int> tris;

		public RFFace(int Id, float Area, UnityEngine.Vector3 Normal)
		{
			id = Id;
			area = Area;
			normal = Normal;
			tris = new List<int>();
		}

		private List<RFFace> GetFaces(List<RFTriangle> Triangles)
		{
			List<int> list = new List<int>();
			List<RFFace> list2 = new List<RFFace>();
			int num = 0;
			foreach (RFTriangle Triangle in Triangles)
			{
				if (list.Contains(Triangle.id))
				{
					continue;
				}
				list.Add(Triangle.id);
				RFFace rFFace = new RFFace(num, Triangle.area, Triangle.normal);
				rFFace.pos = Triangle.pos;
				num++;
				rFFace.tris.Add(Triangle.id);
				List<RFTriangle> list3 = new List<RFTriangle>();
				list3.Add(Triangle);
				while (list3.Count > 0)
				{
					foreach (int neib in list3[0].neibs)
					{
						if (!list.Contains(neib))
						{
							RFTriangle rFTriangle = Triangles[neib];
							if (Triangle.normal == rFTriangle.normal)
							{
								rFFace.area += rFTriangle.area;
								rFFace.pos += rFTriangle.pos;
								rFFace.tris.Add(neib);
								list.Add(neib);
								list3.Add(rFTriangle);
							}
						}
					}
					list3.RemoveAt(0);
				}
				rFFace.pos /= (float)rFFace.tris.Count;
				list2.Add(rFFace);
			}
			return list2;
		}
	}
	[Serializable]
	public class RFCustom
	{
		public enum RFPointCloudSourceType
		{
			ChildrenTransform = 4,
			TransformArray = 8,
			Vector3Array = 12
		}

		public enum RFPointCloudUseType
		{
			VolumePoints = 4,
			PointCloud = 12
		}

		public enum RFModifierType
		{
			None = 0,
			Splinters = 3,
			Slabs = 6
		}

		[Header("  Point Cloud")]
		[Space(2f)]
		public RFPointCloudSourceType source = RFPointCloudSourceType.ChildrenTransform;

		[Space(2f)]
		public RFPointCloudUseType useAs = RFPointCloudUseType.PointCloud;

		[Space(2f)]
		[Header("  Volume")]
		[Space(2f)]
		[Range(3f, 1000f)]
		public int amount = 100;

		[Range(0.01f, 4f)]
		public float radius = 1f;

		[Header("  Preview")]
		[Space(2f)]
		public bool enable = true;

		[Range(0.01f, 0.4f)]
		public float size = 0.05f;

		[Header("  Arrays")]
		[Space(2f)]
		public Transform[] transform;

		public UnityEngine.Vector3[] vector3;

		[HideInInspector]
		public bool noPoints;
	}
	[Serializable]
	public class RFDamage
	{
		[Header("  Properties")]
		[Space(2f)]
		[Tooltip("Allows to demolish object by it's own floating Damage value.")]
		public bool enable;

		[Tooltip("Defines maximum allowed damage for object before it will be demolished.")]
		public float maxDamage;

		[Tooltip("Shows current damage value. Can be increased by public method: \nApplyDamage(float damageValue, Vector3 damagePosition)")]
		public float currentDamage;

		[Header("  Collisions")]
		[Space(2f)]
		[Tooltip("Allows to accumulate damage value by collisions during dynamic simulation.")]
		public bool collect;

		[Tooltip("Defines maximum allowed damage for object before it will be demolished.")]
		[Range(0.01f, 5f)]
		public float multiplier;

		public RFDamage()
		{
			enable = false;
			maxDamage = 100f;
			collect = false;
			multiplier = 1f;
			Reset();
		}

		public void CopyFrom(RFDamage damage)
		{
			enable = damage.enable;
			maxDamage = damage.maxDamage;
			collect = damage.collect;
			multiplier = damage.multiplier;
			Reset();
		}

		public void Reset()
		{
			currentDamage = 0f;
		}

		private bool Apply(float damageValue)
		{
			currentDamage += damageValue;
			if (enable && currentDamage >= maxDamage)
			{
				return true;
			}
			return false;
		}

		public static bool ApplyDamage(RayfireRigid scr, float damageValue, UnityEngine.Vector3 damagePoint, float damageRadius = 0f)
		{
			if (!scr.initialized)
			{
				scr.Initialize();
			}
			if (scr.limitations.demolished || scr.limitations.demolitionShould)
			{
				return false;
			}
			if (scr.damage.Apply(damageValue))
			{
				if (!scr.DemolitionState())
				{
					return false;
				}
				scr.limitations.contactPoint = damagePoint;
				scr.clusterDemolition.damageRadius = damageRadius;
				scr.limitations.demolitionShould = true;
				scr.Demolish();
				if (scr.limitations.demolished)
				{
					return true;
				}
			}
			if (scr.activation.byDamage > 0f && scr.damage.currentDamage > scr.activation.byDamage)
			{
				scr.Activate();
			}
			return false;
		}
	}
	[Serializable]
	public class RFDemolitionCluster
	{
		[Header("  Properties")]
		[Space(1f)]
		[Tooltip("Set Runtime Demolition type for released fragments")]
		public bool meshDemolition;

		[Header("  Connected Cluster")]
		[Space(1f)]
		[Tooltip("Defines Connectivity algorithm for clusters.")]
		public ConnectivityType connectivity;

		[Space(1f)]
		[Tooltip("Defines distance from contact point in percentage relative to object's size which will be detached at contact.")]
		[Range(1f, 100f)]
		public int contactRadius;

		[HideInInspector]
		public RFCluster cluster;

		[HideInInspector]
		public float damageRadius;

		public RFDemolitionCluster()
		{
			meshDemolition = false;
			connectivity = ConnectivityType.ByBoundingBox;
			contactRadius = 15;
			cluster = null;
			Reset();
		}

		public void CopyFrom(RFDemolitionCluster demolition)
		{
			meshDemolition = demolition.meshDemolition;
			connectivity = demolition.connectivity;
			contactRadius = demolition.contactRadius;
			Reset();
		}

		public void Reset()
		{
			damageRadius = 0f;
		}

		public static bool Clusterize(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.NestedCluster)
			{
				return ClusterizeNested(scr);
			}
			if (scr.objectType == ObjectType.ConnectedCluster)
			{
				return ClusterizeConnected(scr);
			}
			return false;
		}

		private static bool ClusterizeNested(RayfireRigid scr)
		{
			MeshFilter[] componentsInChildren = scr.gameObject.GetComponentsInChildren<MeshFilter>();
			if (componentsInChildren.Length == 0)
			{
				return false;
			}
			RFPhysic.SetClusterColliders(scr, componentsInChildren);
			return true;
		}

		private static bool ClusterizeConnected(RayfireRigid scr)
		{
			if (scr.clusterDemolition.cluster == null || scr.clusterDemolition.cluster.id == 0)
			{
				scr.clusterDemolition.cluster = RFCluster.SetCluster(scr.transForm, scr.clusterDemolition.connectivity);
				scr.clusterDemolition.cluster.id = 1;
				RFShard.SetShardNeibs(scr.clusterDemolition.cluster.shards, scr.clusterDemolition.connectivity);
			}
			List<MeshFilter> list = new List<MeshFilter>();
			for (int i = 0; i < scr.transForm.childCount; i++)
			{
				MeshFilter component = scr.transForm.GetChild(i).GetComponent<MeshFilter>();
				if (component != null)
				{
					list.Add(component);
				}
			}
			if (list.Count == 0)
			{
				return false;
			}
			RFPhysic.SetClusterColliders(scr, list.ToArray());
			return true;
		}

		public static void DemolishCluster(RayfireRigid scr)
		{
			if (scr.demolitionType == DemolitionType.Runtime)
			{
				if (scr.objectType == ObjectType.NestedCluster)
				{
					DemolishClusterNested(scr);
				}
				else if (scr.objectType == ObjectType.ConnectedCluster)
				{
					DemolishClusterConnected(scr);
				}
			}
		}

		private static void DemolishClusterNested(RayfireRigid scr)
		{
			scr.limitations.demolished = true;
			scr.fragments = new List<RayfireRigid>();
			List<Transform> list = new List<Transform>();
			for (int i = 0; i < scr.transform.childCount; i++)
			{
				list.Add(scr.transform.GetChild(i));
			}
			AddRigidComponent(scr, list);
			GameObject gameObject = new GameObject(scr.gameObject.name + "_root");
			gameObject.transform.parent = RayfireMan.inst.transForm;
			scr.rootChild = gameObject.transform;
			scr.rootChild.position = scr.transForm.position;
			scr.rootChild.rotation = scr.transForm.rotation;
			if (!scr.clusterDemolition.meshDemolition)
			{
				foreach (RayfireRigid fragment in scr.fragments)
				{
					if (fragment.objectType == ObjectType.Mesh)
					{
						fragment.demolitionType = DemolitionType.None;
					}
				}
			}
			for (int j = 0; j < scr.fragments.Count; j++)
			{
				scr.fragments[j].transform.parent = gameObject.transform;
			}
		}

		private static void DemolishClusterConnected(RayfireRigid scr)
		{
			float radius = scr.limitations.bboxSize / 100f * (float)scr.clusterDemolition.contactRadius;
			if (scr.clusterDemolition.damageRadius > 0f)
			{
				radius = scr.clusterDemolition.damageRadius;
			}
			List<RFShard> list = new List<RFShard>();
			List<Collider> list2 = Physics.OverlapSphere(scr.limitations.contactPoint, radius).ToList();
			if (list2.Count == 0)
			{
				return;
			}
			for (int num = scr.physics.clusterColliders.Count - 1; num >= 0; num--)
			{
				if (list2.Contains(scr.physics.clusterColliders[num]))
				{
					list.Add(scr.clusterDemolition.cluster.shards[num]);
					scr.clusterDemolition.cluster.shards.RemoveAt(num);
					scr.DestroyCollider(scr.physics.clusterColliders[num]);
					scr.physics.clusterColliders.RemoveAt(num);
				}
			}
			if (list.Count == 0)
			{
				return;
			}
			scr.fragments = new List<RayfireRigid>();
			GameObject gameObject = new GameObject(scr.gameObject.name + "_root");
			gameObject.transform.parent = RayfireMan.inst.transForm;
			scr.rootChild = gameObject.transform;
			scr.rootChild.position = scr.transForm.position;
			scr.rootChild.rotation = scr.transForm.rotation;
			List<Transform> list3 = list.Select((RFShard t) => t.tm).ToList();
			AddRigidComponent(scr, list3);
			for (int i = 0; i < list3.Count; i++)
			{
				list3[i].parent = gameObject.transform;
			}
			if (scr.clusterDemolition.cluster.shards.Count == 0)
			{
				scr.limitations.demolished = true;
				return;
			}
			scr.clusterDemolition.cluster.childClusters = RFCluster.ConnectivityCheck(scr.clusterDemolition.cluster.shards);
			scr.limitations.demolished = true;
			if (scr.clusterDemolition.cluster.childClusters.Count == 0)
			{
				CreateClusterRuntime(scr, scr.clusterDemolition.cluster);
			}
			else
			{
				foreach (RFCluster childCluster in scr.clusterDemolition.cluster.childClusters)
				{
					CreateClusterRuntime(scr, childCluster);
				}
			}
			if (scr.clusterDemolition.meshDemolition)
			{
				return;
			}
			foreach (RayfireRigid fragment in scr.fragments)
			{
				if (fragment.objectType == ObjectType.Mesh)
				{
					fragment.demolitionType = DemolitionType.None;
				}
			}
		}

		private static void CreateClusterRuntime(RayfireRigid source, RFCluster cls)
		{
			if (cls.shards.Count == 1)
			{
				AddRigidComponent(source, new List<Transform>(1) { cls.shards[0].tm });
				cls.shards[0].tm.parent = RayfireMan.inst.transForm;
				return;
			}
			GameObject gameObject = new GameObject();
			gameObject.SetActive(value: false);
			gameObject.name = source.gameObject.name + "_cls";
			gameObject.transform.position = source.transForm.position;
			gameObject.transform.rotation = source.transForm.rotation;
			gameObject.transform.parent = RayfireMan.inst.transForm;
			for (int i = 0; i < cls.shards.Count; i++)
			{
				cls.shards[i].tm.parent = gameObject.transform;
			}
			RayfireRigid rayfireRigid = gameObject.gameObject.AddComponent<RayfireRigid>();
			rayfireRigid.initialization = RayfireRigid.InitType.AtStart;
			source.fragments.Add(rayfireRigid);
			source.CopyPropertiesTo(rayfireRigid);
			RFParticles.CopyParticles(source, rayfireRigid);
			rayfireRigid.objectType = ObjectType.ConnectedCluster;
			rayfireRigid.physics.colliderType = RFColliderType.Mesh;
			rayfireRigid.clusterDemolition.cluster = cls;
			rayfireRigid.clusterDemolition.cluster.id = 2;
			gameObject.SetActive(value: true);
		}

		private static void AddRigidComponent(RayfireRigid scr, List<Transform> tmList)
		{
			for (int i = 0; i < tmList.Count; i++)
			{
				tmList[i].gameObject.SetActive(value: false);
				RayfireRigid rayfireRigid = tmList[i].gameObject.AddComponent<RayfireRigid>();
				rayfireRigid.initialization = RayfireRigid.InitType.AtStart;
				if (!rayfireRigid.physics.exclude)
				{
					scr.fragments.Add(rayfireRigid);
					scr.CopyPropertiesTo(rayfireRigid);
					RFParticles.CopyParticles(scr, rayfireRigid);
					rayfireRigid.objectType = ObjectType.Mesh;
					rayfireRigid.physics.colliderType = RFColliderType.Mesh;
					if (rayfireRigid.transform.childCount > 0)
					{
						rayfireRigid.objectType = ObjectType.NestedCluster;
					}
					else
					{
						rayfireRigid.simulationType = SimType.Dynamic;
					}
					rayfireRigid.limitations.currentDepth = scr.limitations.currentDepth + 1;
					tmList[i].gameObject.SetActive(value: true);
					if (rayfireRigid.objectType == ObjectType.Mesh && rayfireRigid.physics.meshCollider != null)
					{
						((MeshCollider)rayfireRigid.physics.meshCollider).convex = true;
					}
				}
			}
		}

		private void SetMeshCollidersTest0(RayfireRigid scr, MeshFilter[] childMeshes)
		{
			MeshCollider[] components = scr.gameObject.GetComponents<MeshCollider>();
			if (components.Length != 0)
			{
				MeshCollider[] array = components;
				foreach (MeshCollider item in array)
				{
					scr.physics.clusterColliders.Add(item);
				}
				return;
			}
			for (int j = 0; j < childMeshes.Length; j++)
			{
				if (!(childMeshes[j].sharedMesh == null))
				{
					MeshCollider meshCollider = childMeshes[j].gameObject.GetComponent<MeshCollider>();
					if (meshCollider == null)
					{
						meshCollider = childMeshes[j].gameObject.AddComponent<MeshCollider>();
						meshCollider.sharedMesh = childMeshes[j].sharedMesh;
						meshCollider.convex = true;
					}
					meshCollider.enabled = false;
					List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>();
					meshCollider.sharedMesh.GetVertices(list);
					for (int k = 0; k < list.Count; k++)
					{
						list[k] = scr.transform.InverseTransformPoint(childMeshes[j].transform.TransformPoint(list[k]));
					}
					Mesh mesh = new Mesh();
					mesh.SetVertices(list);
					mesh.triangles = childMeshes[j].sharedMesh.triangles;
					MeshCollider meshCollider2 = scr.gameObject.AddComponent<MeshCollider>();
					meshCollider2.convex = true;
					meshCollider2.sharedMesh = mesh;
					scr.physics.clusterColliders.Add(meshCollider2);
				}
			}
		}
	}
	[Serializable]
	public class RFDemolitionMesh
	{
		public enum MeshInputType
		{
			AtStart = 3,
			AtInitialization = 6,
			AtDemolition = 9
		}

		[Header("  Fragments")]
		[Space(2f)]
		[Tooltip("Defines amount of new fragments after demolition.")]
		[Range(3f, 300f)]
		public int amount;

		[Tooltip("Defines additional amount variation for object in percents.")]
		[Range(0f, 100f)]
		public int variation;

		[Tooltip("Amount multiplier for next Depth level. Allows to decrease fragments amount of every next demolition level.")]
		[Range(0.01f, 1f)]
		public float depthFade;

		[Space(3f)]
		[Tooltip("Higher value allows to create more tiny fragments closer to collision contact point and bigger fragments far from it.")]
		[Range(0f, 1f)]
		public float contactBias;

		[Tooltip("Defines Seed for fragmentation algorithm. Same Seed will produce same fragments for same object every time.")]
		[Range(1f, 50f)]
		public int seed;

		[Tooltip("Allows to use RayFire Shatter properties for fragmentation. Works only if object has RayFire Shatter component.")]
		public bool useShatter;

		[Header("  Advanced")]
		[Space(2f)]
		[Tooltip("Allows to decrease runtime demolition time for mid and hi poly objects.")]
		public MeshInputType meshInput;

		public RFFragmentProperties properties;

		public RFRuntimeCaching runtimeCaching;

		[HideInInspector]
		public int badMesh;

		[HideInInspector]
		public int shatterMode;

		[HideInInspector]
		public int totalAmount;

		[HideInInspector]
		public int innerSubId;

		[HideInInspector]
		public bool compressPrefab;

		[HideInInspector]
		public UnityEngine.Quaternion cacheRotationStart;

		[HideInInspector]
		public Mesh mesh;

		[HideInInspector]
		public RFShatter rfShatter;

		[HideInInspector]
		public RayfireShatter scrShatter;

		public RFDemolitionMesh()
		{
			amount = 15;
			variation = 0;
			depthFade = 0.5f;
			contactBias = 0f;
			seed = 1;
			useShatter = false;
			meshInput = MeshInputType.AtDemolition;
			properties = new RFFragmentProperties();
			runtimeCaching = new RFRuntimeCaching();
			Reset();
			shatterMode = 1;
			innerSubId = 0;
			compressPrefab = true;
			cacheRotationStart = UnityEngine.Quaternion.identity;
			mesh = null;
			rfShatter = null;
		}

		public void CopyFrom(RFDemolitionMesh demolition)
		{
			amount = demolition.amount;
			variation = demolition.variation;
			depthFade = demolition.depthFade;
			seed = demolition.seed;
			contactBias = demolition.contactBias;
			useShatter = false;
			meshInput = demolition.meshInput;
			meshInput = MeshInputType.AtDemolition;
			properties.CopyFrom(demolition.properties);
			runtimeCaching = new RFRuntimeCaching();
			Reset();
			shatterMode = 1;
			innerSubId = 0;
			compressPrefab = true;
			cacheRotationStart = UnityEngine.Quaternion.identity;
			mesh = null;
			rfShatter = null;
		}

		public void Reset()
		{
			badMesh = 0;
			totalAmount = 0;
		}

		public static bool DemolishMesh(RayfireRigid scr)
		{
			if (scr.objectType != 0 && scr.objectType != ObjectType.SkinnedMesh)
			{
				return true;
			}
			if (scr.demolitionType == DemolitionType.ReferenceDemolition)
			{
				return true;
			}
			if (scr.HasFragments)
			{
				scr.rootChild.position = scr.transForm.position;
				scr.rootChild.rotation = scr.transForm.rotation;
				scr.rootChild.transform.parent = RayfireMan.inst.transForm;
				scr.rootChild.gameObject.SetActive(value: true);
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					scr.fragments[i].StartAllCoroutines();
				}
				scr.limitations.demolished = true;
				return true;
			}
			if (scr.HasRfMeshes && !scr.HasMeshes)
			{
				RFMesh.ConvertRfMeshes(scr);
			}
			if (scr.HasMeshes)
			{
				scr.fragments = CreateFragments(scr);
				scr.limitations.demolished = true;
				return true;
			}
			if (!scr.HasMeshes)
			{
				CacheRuntime(scr);
				if (scr.meshDemolition.runtimeCaching.inProgress)
				{
					return false;
				}
				if (scr.HasMeshes)
				{
					scr.fragments = CreateFragments(scr);
					scr.limitations.demolished = true;
					return true;
				}
			}
			return false;
		}

		public static List<RayfireRigid> CreateFragments(RayfireRigid scr)
		{
			List<RayfireRigid> list = new List<RayfireRigid>();
			if (scr.meshes == null)
			{
				return list;
			}
			RayfireMan.RayFireManInit();
			RFLimitations.CreateRoot(scr);
			int layer = scr.meshDemolition.GetLayer(scr);
			string tag = scr.gameObject.tag;
			string text = scr.gameObject.name + "_fr_";
			if (scr.demolitionType == DemolitionType.AwakePrecache || scr.demolitionType == DemolitionType.ManualPrecache || scr.demolitionType == DemolitionType.ManualPrefabPrecache)
			{
				scr.rootChild.transform.rotation = scr.cacheRotation;
			}
			Material[] sharedMaterials = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < scr.meshes.Length; i++)
			{
				RayfireRigid rayfireRigid = ((RayfireMan.inst == null) ? RayfireMan.CreateRigidInstance() : RayfireMan.inst.GetPoolObject());
				rayfireRigid.transform.position = scr.transForm.position + scr.pivots[i];
				rayfireRigid.transform.parent = scr.rootChild;
				rayfireRigid.name = text + i;
				rayfireRigid.gameObject.tag = tag;
				rayfireRigid.gameObject.layer = layer;
				rayfireRigid.meshFilter.sharedMesh = scr.meshes[i];
				rayfireRigid.rootParent = scr.rootChild;
				scr.CopyPropertiesTo(rayfireRigid);
				RFParticles.CopyParticles(scr, rayfireRigid);
				RFPhysic.SetFragmentMeshCollider(rayfireRigid, scr.meshes[i]);
				if (RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > 0f && RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > scr.meshes[i].bounds.size.magnitude)
				{
					rayfireRigid.meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
				}
				rayfireRigid.gameObject.SetActive(value: true);
				RFSurface.SetMaterial(scr.subIds, sharedMaterials, scr.materials, rayfireRigid.meshRenderer, i, scr.meshes.Length);
				rayfireRigid.limitations.currentDepth = scr.limitations.currentDepth + 1;
				rayfireRigid.meshDemolition.amount = (int)((float)rayfireRigid.meshDemolition.amount * rayfireRigid.meshDemolition.depthFade);
				if (rayfireRigid.meshDemolition.amount < 2)
				{
					rayfireRigid.meshDemolition.amount = 2;
				}
				list.Add(rayfireRigid);
			}
			if (scr.demolitionType == DemolitionType.AwakePrecache || scr.demolitionType == DemolitionType.ManualPrecache || scr.demolitionType == DemolitionType.ManualPrefabPrecache)
			{
				scr.rootChild.rotation = scr.transForm.rotation;
			}
			if (scr.demolitionType == DemolitionType.Runtime && scr.meshDemolition.runtimeCaching.type != 0)
			{
				UnityEngine.Quaternion quaternion = scr.transForm.rotation * UnityEngine.Quaternion.Inverse(scr.meshDemolition.cacheRotationStart);
				scr.rootChild.rotation = quaternion * scr.rootChild.rotation;
			}
			return list;
		}

		private static void CacheRuntime(RayfireRigid scr)
		{
			if (scr.reset.action != RFReset.PostDemolitionType.DeactivateToReset || scr.reset.mesh != RFReset.MeshResetType.ReuseFragmentMeshes || !scr.HasMeshes)
			{
				scr.DeleteCache();
				if (scr.meshDemolition.runtimeCaching.type == CachingType.Disable)
				{
					CacheInstant(scr);
				}
				else
				{
					scr.CacheFrames();
				}
			}
		}

		public static void CacheInstant(RayfireRigid scr)
		{
			_ = Time.realtimeSinceStartup;
			if (RFFragment.InputMesh(scr))
			{
				_ = Time.realtimeSinceStartup;
				RFFragment.CacheMeshesInst(ref scr.meshes, ref scr.pivots, ref scr.subIds, scr);
				_ = Time.realtimeSinceStartup;
			}
		}

		public int GetLayer(RayfireRigid scr)
		{
			if (properties.layer.Length == 0)
			{
				return scr.gameObject.layer;
			}
			if (!RayfireMan.inst.layers.Contains(properties.layer))
			{
				return 0;
			}
			return LayerMask.NameToLayer(properties.layer);
		}

		public IEnumerator RuntimeCachingCor(RayfireRigid scr)
		{
			bool demolitionShouldLocal = scr.limitations.demolitionShould;
			scr.limitations.demolitionShould = false;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (!RFFragment.InputMesh(scr))
			{
				yield break;
			}
			List<int> batchAmount = ((runtimeCaching.type == CachingType.ByFrames) ? RFRuntimeCaching.GetBatchByFrames(runtimeCaching.frames, totalAmount) : RFRuntimeCaching.GetBatchByFragments(runtimeCaching.fragments, totalAmount));
			runtimeCaching.inProgress = true;
			if (Time.realtimeSinceStartup - realtimeSinceStartup > 0.025f || batchAmount.Count > 5)
			{
				yield return null;
			}
			GameObject tmRefGo = RFRuntimeCaching.CreateTmRef(scr);
			cacheRotationStart = scr.transForm.rotation;
			List<Mesh> meshesList = new List<Mesh>();
			List<UnityEngine.Vector3> pivotsList = new List<UnityEngine.Vector3>();
			List<RFDictionary> subList = new List<RFDictionary>();
			for (int i = 0; i < batchAmount.Count; i++)
			{
				if (runtimeCaching.stop)
				{
					ResetRuntimeCaching(scr, tmRefGo);
					yield break;
				}
				RFFragment.CacheMeshesMult(tmRefGo.transform, ref meshesList, ref pivotsList, ref subList, scr, batchAmount, i);
				yield return null;
			}
			scr.meshes = meshesList.ToArray();
			scr.pivots = pivotsList.ToArray();
			scr.subIds = subList;
			scr.DestroyObject(tmRefGo);
			scr.meshDemolition.scrShatter = null;
			if (!runtimeCaching.skipFirstDemolition && demolitionShouldLocal)
			{
				scr.limitations.demolitionShould = true;
			}
			if (runtimeCaching.skipFirstDemolition && demolitionShouldLocal)
			{
				scr.damage.Reset();
			}
			runtimeCaching.inProgress = false;
			runtimeCaching.wasUsed = true;
		}

		public void StopRuntimeCaching()
		{
			if (runtimeCaching.inProgress)
			{
				runtimeCaching.stop = true;
			}
		}

		private void ResetRuntimeCaching(RayfireRigid scr, GameObject tmRefGo)
		{
			scr.DestroyObject(tmRefGo);
			runtimeCaching.stop = false;
			runtimeCaching.inProgress = false;
			scr.meshDemolition.rfShatter = null;
			scr.DeleteCache();
		}
	}
	public class RFEvent
	{
		public delegate void EventAction(RayfireRigid rigid);

		public event EventAction LocalEvent;

		public void InvokeLocalEvent(RayfireRigid rigid)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(rigid);
			}
		}
	}
	public class RFDemolitionEvent : RFEvent
	{
		public static event EventAction GlobalEvent;

		public static void InvokeGlobalEvent(RayfireRigid rigid)
		{
			if (RFDemolitionEvent.GlobalEvent != null)
			{
				RFDemolitionEvent.GlobalEvent(rigid);
			}
		}
	}
	public class RFActivationEvent : RFEvent
	{
		public static event EventAction GlobalEvent;

		public static void InvokeGlobalEvent(RayfireRigid rigid)
		{
			if (RFActivationEvent.GlobalEvent != null)
			{
				RFActivationEvent.GlobalEvent(rigid);
			}
		}
	}
	public class RFRestrictionEvent : RFEvent
	{
		public static event EventAction GlobalEvent;

		public static void InvokeGlobalEvent(RayfireRigid rigid)
		{
			if (RFRestrictionEvent.GlobalEvent != null)
			{
				RFRestrictionEvent.GlobalEvent(rigid);
			}
		}
	}
	public class RFShotEvent
	{
		public delegate void EventAction(RayfireGun gun);

		public static event EventAction GlobalEvent;

		public event EventAction LocalEvent;

		public static void InvokeGlobalEvent(RayfireGun gun)
		{
			if (RFShotEvent.GlobalEvent != null)
			{
				RFShotEvent.GlobalEvent(gun);
			}
		}

		public void InvokeLocalEvent(RayfireGun gun)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(gun);
			}
		}
	}
	public class RFExplosionEvent
	{
		public delegate void EventAction(RayfireBomb bomb);

		public static event EventAction GlobalEvent;

		public event EventAction LocalEvent;

		public static void InvokeGlobalEvent(RayfireBomb bomb)
		{
			if (RFExplosionEvent.GlobalEvent != null)
			{
				RFExplosionEvent.GlobalEvent(bomb);
			}
		}

		public void InvokeLocalEvent(RayfireBomb bomb)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(bomb);
			}
		}
	}
	public class RFSliceEvent
	{
		public delegate void EventAction(RayfireBlade blade);

		public static event EventAction GlobalEvent;

		public event EventAction LocalEvent;

		public static void InvokeGlobalEvent(RayfireBlade blade)
		{
			if (RFSliceEvent.GlobalEvent != null)
			{
				RFSliceEvent.GlobalEvent(blade);
			}
		}

		public void InvokeLocalEvent(RayfireBlade blade)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(blade);
			}
		}
	}
	[Serializable]
	public class RFFade
	{
		public enum RFFadeLifeType
		{
			ByLifeTime = 4,
			BySimulationAndLifeTime = 8
		}

		[Header("  Initiate")]
		[Space(2f)]
		public bool onDemolition;

		public bool onActivation;

		[Header("  Life")]
		[Space(2f)]
		public RFFadeLifeType lifeType;

		[Range(0f, 90f)]
		public float lifeTime;

		[Range(0f, 20f)]
		public float lifeVariation;

		[Header("  Fade")]
		[Space(2f)]
		public FadeType fadeType;

		[Range(1f, 20f)]
		public float fadeTime;

		[Range(0f, 20f)]
		public float sizeFilter;

		[HideInInspector]
		public int state;

		[HideInInspector]
		public bool stop;

		[HideInInspector]
		public UnityEngine.Vector3 position;

		public RFFade()
		{
			onDemolition = true;
			onActivation = false;
			lifeType = RFFadeLifeType.ByLifeTime;
			lifeTime = 7f;
			lifeVariation = 3f;
			fadeType = FadeType.None;
			fadeTime = 5f;
			sizeFilter = 0f;
			Reset();
		}

		public void CopyFrom(RFFade fade)
		{
			onDemolition = fade.onDemolition;
			onActivation = fade.onActivation;
			lifeType = fade.lifeType;
			lifeTime = fade.lifeTime;
			lifeVariation = fade.lifeVariation;
			fadeType = fade.fadeType;
			fadeTime = fade.fadeTime;
			sizeFilter = fade.sizeFilter;
			Reset();
		}

		public void Reset()
		{
			state = 0;
			stop = false;
		}

		public void DemolitionFade(List<RayfireRigid> fadeObjects)
		{
			if (fadeType == FadeType.None || fadeObjects.Count == 0)
			{
				return;
			}
			if (lifeTime < 1f)
			{
				lifeTime = 1f;
			}
			for (int i = 0; i < fadeObjects.Count; i++)
			{
				if (!(fadeObjects[i] == null) && (!(sizeFilter > 0f) || !(fadeObjects[i].limitations.bboxSize > sizeFilter)))
				{
					Fade(fadeObjects[i]);
				}
			}
		}

		public static void Fade(RayfireRigid scr)
		{
			if (!scr.initialized)
			{
				scr.Initialize();
			}
			if (scr.fading.fadeType != 0 && scr.gameObject.activeSelf && scr.fading.state <= 0)
			{
				scr.StartCoroutine(scr.fading.LivingCor(scr));
			}
		}

		private IEnumerator LivingCor(RayfireRigid scr)
		{
			if (scr.fading.lifeType == RFFadeLifeType.BySimulationAndLifeTime)
			{
				yield return scr.StartCoroutine(SimulationCor(scr));
			}
			scr.fading.state = 1;
			float num = scr.fading.lifeTime;
			if (scr.fading.lifeVariation > 0f)
			{
				num += UnityEngine.Random.Range(0f, scr.fading.lifeVariation);
			}
			if (num > 0f)
			{
				yield return new WaitForSeconds(num);
			}
			if (stop)
			{
				scr.fading.Reset();
				yield break;
			}
			scr.fading.state = 2;
			if (scr.fading.fadeType == FadeType.SimExclude)
			{
				FadeExclude(scr);
			}
			else if (scr.fading.fadeType == FadeType.MoveDown)
			{
				scr.StartCoroutine(FadeMoveDown(scr));
			}
			else if (scr.fading.fadeType == FadeType.ScaleDown)
			{
				scr.StartCoroutine(FadeScaleDownCor(scr));
			}
			else if (scr.fading.fadeType == FadeType.Destroy)
			{
				RayfireMan.DestroyFragment(scr, scr.rootParent);
			}
		}

		private static void FadeExclude(RayfireRigid scr)
		{
			scr.fading.state = 2;
			if (scr.reset.action == RFReset.PostDemolitionType.DestroyWithDelay)
			{
				scr.DestroyRb(scr.physics.rigidBody);
				scr.DestroyCollider(scr.physics.meshCollider);
				scr.DestroyRigid(scr);
			}
			else if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset)
			{
				scr.physics.rigidBody.isKinematic = true;
				scr.physics.meshCollider.enabled = false;
				scr.StopAllCoroutines();
			}
		}

		private static IEnumerator FadeMoveDown(RayfireRigid scr)
		{
			if (scr.simulationType == SimType.Inactive)
			{
				scr.Activate();
			}
			scr.physics.rigidBody.WakeUp();
			scr.physics.meshCollider.enabled = false;
			yield return new WaitForSeconds(scr.fading.fadeTime);
			RayfireMan.DestroyFragment(scr, scr.rootParent);
		}

		private static IEnumerator FadeScaleDownCor(RayfireRigid scr)
		{
			float waitStep = 0.04f;
			int steps = (int)(scr.fading.fadeTime / waitStep);
			UnityEngine.Vector3 vectorStep = scr.transForm.localScale / steps;
			while (steps > 0)
			{
				steps--;
				scr.transForm.localScale -= vectorStep;
				yield return new WaitForSeconds(waitStep);
				if (steps < 4)
				{
					RayfireMan.DestroyFragment(scr, scr.rootParent);
				}
			}
		}

		private static IEnumerator SimulationCor(RayfireRigid scr)
		{
			float timeStep = UnityEngine.Random.Range(2.5f, 3.5f);
			float distanceThreshold = 0.15f;
			bool check = true;
			while (check)
			{
				scr.fading.position = scr.transForm.position;
				yield return new WaitForSeconds(timeStep);
				if (UnityEngine.Vector3.Distance(scr.fading.position, scr.transForm.position) < distanceThreshold)
				{
					check = false;
				}
			}
		}
	}
	public static class RFFragment
	{
		public static void CacheMeshes(ref Mesh[] meshes, ref UnityEngine.Vector3[] pivots, ref List<RFDictionary> origSubMeshIdsRf, RayfireShatter scrShatter)
		{
			int shatterMode = GetShatterMode(scrShatter);
			Mesh demolitionMesh = GetDemolitionMesh(scrShatter);
			FragmentMode mode = scrShatter.mode;
			if (scrShatter.type == FragType.Decompose)
			{
				mode = FragmentMode.Editor;
			}
			if (scrShatter.type == FragType.Slices)
			{
				mode = FragmentMode.Runtime;
			}
			RFShatter rFShatter = SetShatter(shatterMode, demolitionMesh, scrShatter.transform, scrShatter.material, scrShatter.advanced.decompose, scrShatter.advanced.removeCollinear, scrShatter.advanced.seed, mode, scrShatter.advanced.inputPrecap, scrShatter.advanced.outputPrecap, scrShatter.advanced.removeDoubleFaces, scrShatter.advanced.excludeInnerFragments, scrShatter.advanced.elementSizeThreshold);
			if (rFShatter == null)
			{
				meshes = null;
				pivots = null;
				return;
			}
			int innerSubId = RFSurface.SetInnerSubId(scrShatter);
			SetFragmentProperties(rFShatter, scrShatter, null);
			if (scrShatter.type == FragType.Custom && scrShatter.custom.noPoints)
			{
				meshes = null;
				pivots = null;
				UnityEngine.Debug.Log("No custom ponts");
				return;
			}
			List<Dictionary<int, int>> subIds = new List<Dictionary<int, int>>();
			bool flag = Compute(shatterMode, rFShatter, scrShatter.transform, ref meshes, ref pivots, demolitionMesh, innerSubId, ref subIds, scrShatter);
			origSubMeshIdsRf = new List<RFDictionary>();
			for (int i = 0; i < subIds.Count; i++)
			{
				origSubMeshIdsRf.Add(new RFDictionary(subIds[i]));
			}
			if (!flag)
			{
				UnityEngine.Debug.Log("Bad shatter output mesh: " + scrShatter.name);
				return;
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				meshes[j].name = scrShatter.name + "_" + j;
			}
		}

		public static bool InputMesh(RayfireRigid scr)
		{
			if (!SetRigidShatter(scr))
			{
				return false;
			}
			scr.meshDemolition.innerSubId = RFSurface.SetInnerSubId(scr);
			SetFragmentProperties(scr.meshDemolition.rfShatter, scr.meshDemolition.scrShatter, scr);
			return true;
		}

		private static bool SetRigidShatter(RayfireRigid scr)
		{
			if (scr.meshDemolition.rfShatter == null)
			{
				scr.cacheRotation = scr.transForm.rotation;
				scr.meshDemolition.shatterMode = GetShatterMode(scr.meshDemolition.scrShatter);
				scr.meshDemolition.mesh = GetDemolitionMesh(scr);
				scr.meshDemolition.rfShatter = SetShatter(scr.meshDemolition.shatterMode, scr.meshDemolition.mesh, scr.transform, scr.materials, scr.meshDemolition.properties.decompose, scr.meshDemolition.properties.removeCollinear, scr.meshDemolition.seed, FragmentMode.Runtime, preCap: false, remCap: false, remDbl: false);
			}
			if (scr.meshDemolition.rfShatter == null)
			{
				scr.meshDemolition.badMesh += 10;
				scr.meshDemolition.mesh = null;
				return false;
			}
			return true;
		}

		public static void CacheMeshesInst(ref Mesh[] meshes, ref UnityEngine.Vector3[] pivots, ref List<RFDictionary> origSubMeshIdsRf, RayfireRigid scrRigid)
		{
			List<Dictionary<int, int>> subIds = new List<Dictionary<int, int>>();
			bool successState = Compute(scrRigid.meshDemolition.shatterMode, scrRigid.meshDemolition.rfShatter, scrRigid.transform, ref meshes, ref pivots, scrRigid.meshDemolition.mesh, scrRigid.meshDemolition.innerSubId, ref subIds, scrRigid);
			origSubMeshIdsRf.Clear();
			for (int i = 0; i < subIds.Count; i++)
			{
				origSubMeshIdsRf.Add(new RFDictionary(subIds[i]));
			}
			FinalCacheMeshes(ref meshes, scrRigid, successState);
		}

		public static void CacheMeshesMult(Transform tmSaved, ref List<Mesh> meshesList, ref List<UnityEngine.Vector3> pivotsList, ref List<RFDictionary> subList, RayfireRigid scrRigid, List<int> batchAmount, int batchInd)
		{
			List<int> markedElements = RFRuntimeCaching.GetMarkedElements(batchInd, batchAmount);
			Mesh[] out_mesh = new Mesh[batchAmount.Count];
			UnityEngine.Vector3[] pivots = new UnityEngine.Vector3[batchAmount.Count];
			List<Dictionary<int, int>> OrigSubMeshIDs = new List<Dictionary<int, int>>();
			if (scrRigid.meshDemolition.rfShatter.SimpleCompute(tmSaved, ref out_mesh, ref pivots, scrRigid.meshDemolition.mesh, scrRigid.meshDemolition.innerSubId, ref OrigSubMeshIDs, markedElements, batchInd == 0) && out_mesh != null && out_mesh.Length != 0)
			{
				for (int i = 0; i < out_mesh.Length; i++)
				{
					out_mesh[i].RecalculateTangents();
					out_mesh[i].name = scrRigid.name + "_" + markedElements[i];
				}
				for (int j = 0; j < OrigSubMeshIDs.Count; j++)
				{
					subList.Add(new RFDictionary(OrigSubMeshIDs[j]));
				}
				meshesList.AddRange(out_mesh);
				pivotsList.AddRange(pivots);
			}
		}

		private static void FinalCacheMeshes(ref Mesh[] meshes, RayfireRigid scrRigid, bool successState)
		{
			if (!successState)
			{
				scrRigid.meshDemolition.badMesh++;
				UnityEngine.Debug.Log("Bad mesh: " + scrRigid.name);
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				meshes[i].name = scrRigid.name + "_" + i;
			}
		}

		private static Mesh GetDemolitionMesh(RayfireRigid scr)
		{
			if (scr.skinnedMeshRend != null)
			{
				return RFMesh.BakeMesh(scr.skinnedMeshRend);
			}
			return scr.meshFilter.sharedMesh;
		}

		private static Mesh GetDemolitionMesh(RayfireShatter scr)
		{
			if (scr.skinnedMeshRend != null)
			{
				return RFMesh.BakeMesh(scr.skinnedMeshRend);
			}
			return scr.meshFilter.sharedMesh;
		}

		public static void SliceMeshes(ref Mesh[] meshes, ref UnityEngine.Vector3[] pivots, ref List<RFDictionary> origSubMeshIdsRf, RayfireRigid scr, List<UnityEngine.Vector3> sliceData)
		{
			scr.meshDemolition.mesh = GetDemolitionMesh(scr);
			RFShatter rFShatter = SetShatter(2, scr.meshDemolition.mesh, scr.transform, scr.materials, decompose: true, scr.meshDemolition.properties.removeCollinear, scr.meshDemolition.seed, FragmentMode.Runtime, preCap: false, remCap: false, remDbl: false);
			if (rFShatter == null)
			{
				scr.meshDemolition.badMesh++;
				return;
			}
			int innerSubId = RFSurface.SetInnerSubId(scr);
			List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>();
			List<UnityEngine.Vector3> list2 = new List<UnityEngine.Vector3>();
			int num;
			for (num = 0; num < sliceData.Count; num++)
			{
				list.Add(sliceData[num]);
				list2.Add(sliceData[num + 1]);
				num++;
			}
			rFShatter.SetBricksParams(list.ToArray(), list2.ToArray(), scr.transform);
			List<Dictionary<int, int>> subIds = new List<Dictionary<int, int>>();
			bool flag = Compute(2, rFShatter, scr.transform, ref meshes, ref pivots, scr.meshDemolition.mesh, innerSubId, ref subIds, scr.gameObject);
			origSubMeshIdsRf = new List<RFDictionary>();
			for (int i = 0; i < subIds.Count; i++)
			{
				origSubMeshIdsRf.Add(new RFDictionary(subIds[i]));
			}
			if (!flag)
			{
				scr.meshDemolition.badMesh++;
				UnityEngine.Debug.Log("Bad mesh: " + scr.name, scr.gameObject);
				return;
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				meshes[j].name = scr.name + "_" + j;
			}
		}

		private static bool Compute(int shatterMode, RFShatter shatter, Transform tm, ref Mesh[] meshes, ref UnityEngine.Vector3[] pivots, Mesh mesh, int innerSubId, ref List<Dictionary<int, int>> subIds, UnityEngine.Object obj, List<int> markedElements = null)
		{
			if (!((shatterMode == 0) ? shatter.Compute(tm, ref meshes, ref pivots, mesh, innerSubId, ref subIds) : shatter.SimpleCompute(tm, ref meshes, ref pivots, mesh, innerSubId, ref subIds, markedElements)))
			{
				meshes = null;
				pivots = null;
				subIds = new List<Dictionary<int, int>>();
				return false;
			}
			if (meshes == null)
			{
				UnityEngine.Debug.Log("Null mesh", obj);
				meshes = null;
				pivots = null;
				subIds = new List<Dictionary<int, int>>();
				return false;
			}
			if (EmptyMeshState(meshes))
			{
				List<Mesh> list = new List<Mesh>();
				List<UnityEngine.Vector3> list2 = new List<UnityEngine.Vector3>();
				List<Dictionary<int, int>> list3 = new List<Dictionary<int, int>>();
				for (int i = 0; i < meshes.Length; i++)
				{
					if (meshes[i].vertexCount > 2)
					{
						list.Add(meshes[i]);
						list2.Add(pivots[i]);
						list3.Add(subIds[i]);
					}
				}
				pivots = list2.ToArray();
				meshes = list.ToArray();
				subIds = list3;
				UnityEngine.Debug.Log("Empty Mesh", obj);
			}
			if (meshes.Length <= 1)
			{
				UnityEngine.Debug.Log("Mesh amount " + meshes.Length, obj);
				meshes = null;
				pivots = null;
				subIds = new List<Dictionary<int, int>>();
				return false;
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				meshes[j].RecalculateTangents();
			}
			return true;
		}

		private static int GetShatterMode(RayfireShatter scrShatter = null)
		{
			if (scrShatter == null)
			{
				return 1;
			}
			if (scrShatter.type == FragType.Slices)
			{
				return 2;
			}
			if (scrShatter.type == FragType.Decompose)
			{
				return 1;
			}
			int result = scrShatter.shatterMode;
			if (scrShatter.type == FragType.Custom)
			{
				result = 0;
			}
			if (scrShatter.type == FragType.Tets)
			{
				result = 0;
			}
			if (scrShatter.clusters.enable)
			{
				result = 0;
			}
			return result;
		}

		private static bool EmptyMeshState(Mesh[] meshes)
		{
			return meshes.Any((Mesh t) => t.vertexCount <= 2);
		}

		private static void SetFragmentProperties(RFShatter shatter, RayfireShatter scrSh, RayfireRigid scrRigid)
		{
			if (scrRigid != null && scrSh == null)
			{
				int num = UnityEngine.Random.Range(0, scrRigid.meshDemolition.amount * scrRigid.meshDemolition.variation / 100);
				scrRigid.meshDemolition.totalAmount = scrRigid.meshDemolition.amount + num;
				SetVoronoi(shatter, scrRigid.meshDemolition.totalAmount, scrRigid.transform, scrRigid.limitations.contactPoint, scrRigid.meshDemolition.contactBias);
				return;
			}
			if (scrRigid != null && scrSh != null)
			{
				scrSh.centerPosition = scrRigid.transForm.InverseTransformPoint(scrRigid.limitations.contactPoint);
				if (scrSh.type == FragType.Voronoi)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.voronoi.Amount;
				}
				else if (scrSh.type == FragType.Splinters)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.splinters.Amount;
				}
				else if (scrSh.type == FragType.Slabs)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.slabs.Amount;
				}
				else if (scrSh.type == FragType.Radial)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.radial.rings * scrSh.radial.rays;
				}
			}
			if (scrSh != null)
			{
				UnityEngine.Vector3 centerPos = scrSh.transform.TransformPoint(scrSh.centerPosition);
				if (scrSh.type == FragType.Voronoi)
				{
					SetVoronoi(shatter, scrSh.voronoi.Amount, scrSh.transform, centerPos, scrSh.voronoi.centerBias);
				}
				else if (scrSh.type == FragType.Splinters)
				{
					SetSplinters(shatter, scrSh.splinters, scrSh.transform, centerPos, scrSh.splinters.centerBias);
				}
				else if (scrSh.type == FragType.Slabs)
				{
					SetSlabs(shatter, scrSh.slabs, scrSh.transform, centerPos, scrSh.splinters.centerBias);
				}
				else if (scrSh.type == FragType.Radial)
				{
					SetRadial(shatter, scrSh.radial, scrSh.transform, centerPos, scrSh.centerDirection);
				}
				else if (scrSh.type == FragType.Custom)
				{
					SetCustom(shatter, scrSh.custom, scrSh.transform, scrSh.meshFilter, scrSh.bound, scrSh.splinters, scrSh.slabs, scrSh.advanced.seed);
				}
				else if (scrSh.type == FragType.Slices)
				{
					SetSlices(shatter, scrSh.transform, scrSh.slice);
				}
				else if (scrSh.type == FragType.Tets)
				{
					SetTet(shatter, scrSh.bound, scrSh.tets);
				}
				else if (scrSh.type == FragType.Decompose)
				{
					SetDecompose(shatter);
				}
				if (scrSh.clusters.enable)
				{
					SetClusters(shatter, scrSh.clusters);
				}
			}
		}

		private static RFShatter SetShatter(int shatterMode, Mesh mesh, Transform transform, RFSurface interior, bool decompose, bool deleteCol, int seed = 1, FragmentMode mode = FragmentMode.Runtime, bool preCap = true, bool remCap = false, bool remDbl = true, bool exInside = false, int percSize = 3)
		{
			RFShatter rFShatter = new RFShatter((RFShatter.RFShatterMode)shatterMode, enable_fragmenting: true);
			if (mode == FragmentMode.Editor)
			{
				float sizeFilter = mesh.bounds.size.magnitude * (float)percSize / 100f;
				SetShatterEditorMode(rFShatter, sizeFilter, preCap, remCap, remDbl, exInside);
			}
			else
			{
				SetShatterRuntimeMode(rFShatter);
			}
			rFShatter.DecomposeResultMesh(decompose);
			rFShatter.SetFragmentParameter(RFShatter.FragmentParams.seed, seed);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.pre_weld_threshold, 0.001f);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.delete_collinear, deleteCol);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.maping_scale, interior.mappingScale);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.restore_normals, value: true);
			if (!rFShatter.SetInputMesh(transform, mesh))
			{
				UnityEngine.Debug.Log("Bad input mesh: " + transform.name, transform.gameObject);
				return null;
			}
			return rFShatter;
		}

		private static void SetShatterEditorMode(RFShatter shatter, float sizeFilter, bool preCap, bool remCap, bool remDbl, bool exInside)
		{
			shatter.EditorMode(enable: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_pre_cap, preCap);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_remove_cap_faces, remCap);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_separate_only, value: false);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_elliminateCollinears_maxIterFuse, 150);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_min_bbox_diag_size_filter, sizeFilter);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_exclude_inside, exInside);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_remove_double_faces, remDbl);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_remove_inversed_double_faces, remDbl);
		}

		private static void SetShatterRuntimeMode(RFShatter shatter)
		{
			shatter.EditorMode(enable: false);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.pre_shatter, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.pre_cap, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.pre_weld, value: true);
		}

		private static void SetVoronoi(RFShatter shatter, int numFragments, Transform tm, UnityEngine.Vector3 centerPos, float centerBias)
		{
			int num = numFragments;
			if (num < 1)
			{
				num = 1;
			}
			if (num > 20000)
			{
				num = 2;
			}
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_num, num);
			if (centerBias > 0f)
			{
				shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_bias, centerBias);
				shatter.SetCenterParameter(centerPos, tm, UnityEngine.Vector3.forward);
			}
		}

		private static void SetSplinters(RFShatter shatter, RFSplinters splint, Transform tm, UnityEngine.Vector3 centerPos, float centerBias)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_num, splint.Amount);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_bias, centerBias);
			shatter.SetCenterParameter(centerPos, tm, UnityEngine.Vector3.forward);
			SetStretching(shatter, splint.axis, splint.strength, FragType.Splinters);
		}

		private static void SetSlabs(RFShatter shatter, RFSplinters slabs, Transform tm, UnityEngine.Vector3 centerPos, float centerBias)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_num, slabs.Amount);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_bias, centerBias);
			shatter.SetCenterParameter(centerPos, tm, UnityEngine.Vector3.forward);
			SetStretching(shatter, slabs.axis, slabs.strength, FragType.Slabs);
		}

		private static void SetRadial(RFShatter shatter, RFRadial radial, Transform tm, UnityEngine.Vector3 centerPos, UnityEngine.Quaternion centerDirection)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 2);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_radius, radial.radius);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_divergence, radial.divergence);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_restrict, radial.restrictToPlane);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_count, radial.rings);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_focus, radial.focus);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_strenght, radial.focusStr);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_random, radial.randomRings);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rays_count, radial.rays);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rays_random, radial.randomRays);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rays_twist, radial.twist);
			UnityEngine.Vector3 vector = DirectionAxis(radial.centerAxis);
			UnityEngine.Vector3 normal = tm.rotation * centerDirection * vector;
			shatter.SetCenterParameter(centerPos, tm, normal);
		}

		private static void SetCustom(RFShatter shatter, RFCustom custom, Transform tm, MeshFilter mf, Bounds bound, RFSplinters splint, RFSplinters slabs, int seed)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 1);
			List<UnityEngine.Vector3> customPointCLoud = GetCustomPointCLoud(custom, tm, seed, bound);
			shatter.SetVoroCustomPoints(customPointCLoud.ToArray(), tm);
		}

		private static void SetSlices(RFShatter shatter, Transform tm, RFSlice slices)
		{
			List<Transform> list = new List<Transform>();
			for (int i = 0; i < slices.sliceList.Count; i++)
			{
				if (slices.sliceList[i] != null)
				{
					list.Add(slices.sliceList[i]);
				}
			}
			if (list.Count != 0)
			{
				UnityEngine.Vector3[] points = list.Select((Transform t) => t.position).ToArray();
				UnityEngine.Vector3[] normals = list.Select((Transform t) => slices.Axis(t)).ToArray();
				shatter.SetBricksParams(points, normals, tm);
			}
		}

		private static void SetTet(RFShatter shatter, Bounds bounds, RFTets tets)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.tetra_type, (int)tets.lattice);
			float num = bounds.size.x;
			if (bounds.size.y > num)
			{
				num = bounds.size.y;
			}
			if (bounds.size.z > num)
			{
				num = bounds.size.z;
			}
			if (num == 0f)
			{
				num = 0.01f;
			}
			Vector3Int vector3Int = new Vector3Int((int)Mathf.Ceil(bounds.size.x / num * (float)tets.density), (int)Mathf.Ceil(bounds.size.y / num * (float)tets.density), (int)Mathf.Ceil(bounds.size.z / num * (float)tets.density));
			if (vector3Int.x > 30)
			{
				vector3Int.x = 30;
			}
			else if (vector3Int.x < 1)
			{
				vector3Int.x = 1;
			}
			if (vector3Int.y > 30)
			{
				vector3Int.y = 30;
			}
			else if (vector3Int.y < 1)
			{
				vector3Int.y = 1;
			}
			if (vector3Int.z > 30)
			{
				vector3Int.z = 30;
			}
			else if (vector3Int.z < 1)
			{
				vector3Int.z = 1;
			}
			shatter.SetFragmentParameter(RFShatter.FragmentParams.tetra_noise, tets.noise);
		}

		private static void SetDecompose(RFShatter shatter)
		{
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_separate_only, value: true);
		}

		public static List<UnityEngine.Vector3> GetCustomPointCLoud(RFCustom custom, Transform tm, int seed, Bounds bound)
		{
			List<UnityEngine.Vector3> customInputCloud = GetCustomInputCloud(custom, tm);
			List<UnityEngine.Vector3> customBoundPoints = GetCustomBoundPoints(GetCustomOutputCloud(custom, customInputCloud, seed, bound), bound);
			if (customBoundPoints.Count <= 1)
			{
				custom.noPoints = true;
			}
			return customBoundPoints;
		}

		private static List<UnityEngine.Vector3> GetCustomInputCloud(RFCustom custom, Transform tm)
		{
			custom.noPoints = false;
			List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>();
			if (custom.source == RFCustom.RFPointCloudSourceType.ChildrenTransform)
			{
				if (tm.childCount > 0)
				{
					for (int i = 0; i < tm.childCount; i++)
					{
						list.Add(tm.GetChild(i).position);
					}
				}
			}
			else if (custom.source == RFCustom.RFPointCloudSourceType.TransformArray)
			{
				if (custom.transform != null && custom.transform.Length != 0)
				{
					for (int j = 0; j < custom.transform.Length; j++)
					{
						if (custom.transform[j] != null)
						{
							list.Add(custom.transform[j].position);
						}
					}
				}
			}
			else if (custom.source == RFCustom.RFPointCloudSourceType.Vector3Array && custom.vector3 != null && custom.vector3.Length != 0)
			{
				for (int k = 0; k < custom.vector3.Length; k++)
				{
					list.Add(custom.vector3[k]);
				}
			}
			return list;
		}

		private static List<UnityEngine.Vector3> GetCustomOutputCloud(RFCustom custom, List<UnityEngine.Vector3> inputPoints, int seed, Bounds bound)
		{
			if (custom.useAs == RFCustom.RFPointCloudUseType.PointCloud)
			{
				return inputPoints;
			}
			if (custom.useAs == RFCustom.RFPointCloudUseType.VolumePoints)
			{
				if (inputPoints.Count == 0)
				{
					return inputPoints;
				}
				int num = custom.amount / inputPoints.Count;
				int num2 = seed;
				List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>();
				{
					foreach (UnityEngine.Vector3 inputPoint in inputPoints)
					{
						num2++;
						UnityEngine.Random.InitState(num2);
						for (int i = 0; i < num; i++)
						{
							UnityEngine.Vector3 vector = RandomPointInRadius(inputPoint, custom.radius);
							if (!bound.Contains(vector))
							{
								vector = RandomPointInRadius(inputPoint, custom.radius);
								if (!bound.Contains(vector))
								{
									vector = RandomPointInRadius(inputPoint, custom.radius);
								}
							}
							list.Add(vector);
						}
					}
					return list;
				}
			}
			return inputPoints;
		}

		private static List<UnityEngine.Vector3> GetCustomBoundPoints(List<UnityEngine.Vector3> inputPoints, Bounds bound)
		{
			for (int num = inputPoints.Count - 1; num >= 0; num--)
			{
				if (!bound.Contains(inputPoints[num]))
				{
					inputPoints.RemoveAt(num);
				}
			}
			return inputPoints;
		}

		private static UnityEngine.Vector3 RandomVector()
		{
			return new UnityEngine.Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
		}

		private static UnityEngine.Vector3 RandomPointInRadius(UnityEngine.Vector3 point, float radius)
		{
			return RandomVector() * UnityEngine.Random.Range(0f, radius) + point;
		}

		private static void SetClusters(RFShatter shatter, RFShatterCluster gluing)
		{
			shatter.InitClustering(enable: true);
			shatter.SetClusterParameter(RFShatter.ClusterParams.enabled, value: true);
			shatter.SetClusterParameter(RFShatter.ClusterParams.by_pcloud_count, gluing.count);
			shatter.SetClusterParameter(RFShatter.ClusterParams.options_seed, gluing.seed);
			shatter.SetClusterParameter(RFShatter.ClusterParams.preview_scale, 100f);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_layers_count, gluing.layers);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_count, gluing.amount);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_scale, gluing.scale);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_min, gluing.min);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_max, gluing.max);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_tessellate, value: false);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_remove, value: false);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.glue, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.glue_weld_threshold, 0.001f);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.relax, gluing.relax);
		}

		private static void SetStretching(RFShatter shatter, AxisType axis, float strength, FragType fragType)
		{
			UnityEngine.Vector3 vector = DirectionAxis(axis);
			if (fragType == FragType.Slabs)
			{
				UnityEngine.Vector3 vector2 = default(UnityEngine.Vector3);
				if (vector.x <= 0f)
				{
					vector2.x = 1f;
				}
				if (vector.x >= 1f)
				{
					vector2.x = 0f;
				}
				if (vector.y <= 0f)
				{
					vector2.y = 1f;
				}
				if (vector.y >= 1f)
				{
					vector2.y = 0f;
				}
				if (vector.z <= 0f)
				{
					vector2.z = 1f;
				}
				if (vector.z >= 1f)
				{
					vector2.z = 0f;
				}
				vector = vector2;
			}
			shatter.SetPoint3Parameter(10008, vector * Mathf.Lerp(40f, 99f, strength));
		}

		private static UnityEngine.Vector3 DirectionAxis(AxisType axisType)
		{
			return axisType switch
			{
				AxisType.YGreen => UnityEngine.Vector3.up, 
				AxisType.ZBlue => UnityEngine.Vector3.forward, 
				_ => UnityEngine.Vector3.right, 
			};
		}

		public static void RescaleMesh(Mesh mesh, float scale)
		{
			UnityEngine.Vector3[] vertices = mesh.vertices;
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] /= scale;
			}
			mesh.SetVertices(vertices.ToList());
		}
	}
	[Serializable]
	public class RFFragmentProperties
	{
		[Header("  Collider")]
		[Space(2f)]
		public RFColliderType colliderType;

		[Tooltip("Fragments with size less than this value will not get collider")]
		[Range(0f, 10f)]
		public float sizeFilter;

		[Header("  Mesh Ops")]
		[Space(2f)]
		[Tooltip("Detach all not connected with each other faces into separate meshes.")]
		public bool decompose;

		[Tooltip("Remove collier vertices to decrease amount of triangles")]
		public bool removeCollinear;

		[Header("  Custom Layer")]
		[Space(2f)]
		[Tooltip("Custom layer for fragments")]
		public string layer;

		public RFFragmentProperties()
		{
			colliderType = RFColliderType.Mesh;
			sizeFilter = 0f;
			decompose = false;
			removeCollinear = true;
			layer = "";
		}

		public void CopyFrom(RFFragmentProperties fragmentProperties)
		{
			colliderType = fragmentProperties.colliderType;
			sizeFilter = fragmentProperties.sizeFilter;
			decompose = false;
			removeCollinear = fragmentProperties.removeCollinear;
			layer = fragmentProperties.layer;
		}
	}
	[Serializable]
	public class RFLimitations
	{
		[Tooltip("Local Object solidity multiplier for object. Low Solidity makes object more fragile.")]
		[Range(0f, 10f)]
		public float solidity;

		[Tooltip("Defines how deep object can be demolished. Depth is limitless if set to 0.")]
		[Range(0f, 7f)]
		public int depth;

		[Tooltip("Safe time. Measures in seconds and allows to prevent fragments from being demolished right after they were just created.")]
		[Range(0.05f, 10f)]
		public float time;

		[Tooltip("Prevent objects with bounding box size less than defined value to be demolished.")]
		[Range(0.01f, 5f)]
		public float size;

		[Tooltip("Allows object to be sliced by object with RayFire Blade component.")]
		public bool sliceByBlade;

		[Header("Hidden")]
		[HideInInspector]
		public List<UnityEngine.Vector3> slicePlanes;

		[HideInInspector]
		public UnityEngine.Vector3 contactPoint;

		[HideInInspector]
		public bool demolitionShould;

		[HideInInspector]
		public bool demolished;

		[HideInInspector]
		public float birthTime;

		[HideInInspector]
		public float bboxSize;

		[HideInInspector]
		public int currentDepth;

		[HideInInspector]
		public Bounds bound;

		[HideInInspector]
		public RayfireRigid ancestor;

		[HideInInspector]
		public List<RayfireRigid> descendants;

		public RFLimitations()
		{
			solidity = 0.1f;
			depth = 1;
			time = 0.2f;
			size = 0.1f;
			sliceByBlade = false;
			currentDepth = 0;
			birthTime = 0f;
			bboxSize = 0f;
			ancestor = null;
			descendants = new List<RayfireRigid>();
			Reset();
		}

		public void CopyFrom(RFLimitations limitations)
		{
			solidity = limitations.solidity;
			depth = limitations.depth;
			time = limitations.time;
			size = limitations.size;
			sliceByBlade = limitations.sliceByBlade;
			Reset();
		}

		public void Reset()
		{
			slicePlanes = new List<UnityEngine.Vector3>();
			contactPoint = UnityEngine.Vector3.zero;
			demolitionShould = false;
			demolished = false;
		}

		public IEnumerator DemolishableCor(RayfireRigid scr)
		{
			while (scr.demolitionType != 0)
			{
				if (scr.limitations.depth > 0 && scr.limitations.currentDepth >= scr.limitations.depth)
				{
					scr.demolitionType = DemolitionType.None;
				}
				if (scr.limitations.demolitionShould)
				{
					scr.Demolish();
				}
				else if (scr.limitations.sliceByBlade && scr.limitations.slicePlanes.Count > 1)
				{
					scr.SliceObjectByPlanes();
				}
				yield return null;
			}
		}

		public static void Checks(RayfireRigid scr)
		{
			_ = scr.objectType;
			if (scr.simulationType == SimType.Static && scr.demolitionType != 0)
			{
				UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Simulation Type set to " + scr.simulationType.ToString() + " but Demolition Type is not None. Static object can not be demolished. Demolition Type set to None.", scr.gameObject);
				scr.demolitionType = DemolitionType.None;
			}
			if (scr.objectType == ObjectType.Mesh)
			{
				if (scr.meshFilter == null || scr.meshFilter.sharedMesh == null)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but object has no mesh. Object Excluded from simulation.", scr.gameObject);
					scr.physics.exclude = true;
				}
				if (scr.demolitionType != 0 && scr.meshFilter != null && !scr.meshFilter.sharedMesh.isReadable)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Mesh is not readable. Demolition type set to None. Open Import Settings and turn On Read/Write Enabled property", scr.meshFilter.gameObject);
					scr.demolitionType = DemolitionType.None;
					scr.meshDemolition.badMesh = 10;
				}
			}
			else if (scr.objectType == ObjectType.NestedCluster || scr.objectType == ObjectType.ConnectedCluster)
			{
				if (scr.transForm.childCount == 0)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but object has no children. Object Excluded from simulation.", scr.gameObject);
					scr.physics.exclude = true;
				}
			}
			else if (scr.objectType == ObjectType.SkinnedMesh)
			{
				if (scr.skinnedMeshRend == null)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but object has no SkinnedMeshRenderer. Object Excluded from simulation.", scr.gameObject);
				}
				scr.physics.exclude = true;
			}
			if (scr.demolitionType != 0)
			{
				if ((scr.objectType == ObjectType.SkinnedMesh || scr.objectType == ObjectType.NestedCluster || scr.objectType == ObjectType.ConnectedCluster) && scr.demolitionType != DemolitionType.Runtime && scr.demolitionType != DemolitionType.ReferenceDemolition)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but Demolition Type is " + scr.demolitionType.ToString() + ". Demolition Type set to Runtime.", scr.gameObject);
					scr.demolitionType = DemolitionType.Runtime;
				}
				if (scr.meshDemolition.scrShatter == null && scr.meshDemolition.useShatter && (scr.demolitionType == DemolitionType.Runtime || scr.demolitionType == DemolitionType.AwakePrecache || scr.demolitionType == DemolitionType.AwakePrefragment))
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + "Demolition Type is " + scr.demolitionType.ToString() + ". Has no Shatter component, but Use Shatter property is On. Use Shatter property was turned Off.", scr.gameObject);
					scr.meshDemolition.useShatter = false;
				}
			}
			if (scr.demolitionType == DemolitionType.None)
			{
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to None. Had manually precached meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to None. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to None. Had manually precached serialized meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
			}
			else if (scr.demolitionType == DemolitionType.Runtime)
			{
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Runtime. Had manually precached meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Runtime. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Runtime. Had manually precached serialized meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
				if (scr.meshDemolition.useShatter && scr.meshDemolition.runtimeCaching.type != 0 && (scr.meshDemolition.scrShatter.type == FragType.Decompose || scr.meshDemolition.scrShatter.type == FragType.Tets || scr.meshDemolition.scrShatter.type == FragType.Slices || scr.meshDemolition.scrShatter.clusters.enable))
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type is Runtime, Use Shatter is On. Unsupported fragments type. Runtime Caching supports only Voronoi, Splinters, Slabs and Radial fragmentation types. Runtime Caching was Disabled.", scr.gameObject);
					scr.meshDemolition.runtimeCaching.type = CachingType.Disable;
				}
			}
			else if (scr.demolitionType == DemolitionType.AwakePrecache)
			{
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Precache. Had manually precached Unity meshes which were overwritten.", scr.gameObject);
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Precache. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Awake Precache. Has manually precached serialized meshes.", scr.gameObject);
				}
			}
			else if (scr.demolitionType == DemolitionType.AwakePrefragment)
			{
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Prefragment. Has manually prefragmented objects", scr.gameObject);
				}
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Prefragment. Has manually precached Unity meshes.", scr.gameObject);
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Awake Prefragment. Has manually precached serialized meshes.", scr.gameObject);
				}
			}
			else if (scr.demolitionType == DemolitionType.ManualPrefabPrecache)
			{
				if (!scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Prefab Precache. Has no precached serialized meshes, Demolition Type set to None.", scr.gameObject);
					scr.demolitionType = DemolitionType.None;
				}
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Prefab Precache. Has manually precached meshes.", scr.gameObject);
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Prefab Precache. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
			}
			else if (scr.demolitionType == DemolitionType.ManualPrecache)
			{
				if (!scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Manual Precache. Has no manually precached Unity meshes, Demolition Type set to None.", scr.gameObject);
					scr.demolitionType = DemolitionType.None;
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Manual Precache. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Manual Precache. Has manually precached serialized meshes.", scr.gameObject);
				}
			}
			else if (scr.demolitionType == DemolitionType.ManualPrefragment)
			{
				if (!scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Manual Prefragment. Has no manually prefragmented objects, Demolition Type set to None.", scr.gameObject);
					scr.demolitionType = DemolitionType.None;
				}
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Manual Prefragment. Has manually precached Unity meshes.", scr.gameObject);
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Manual Prefragment. Has manually precached serialized meshes.", scr.gameObject);
				}
			}
		}

		public static void SetBound(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.Mesh)
			{
				scr.limitations.bound = scr.meshRenderer.bounds;
			}
			else if (scr.objectType == ObjectType.Mesh)
			{
				scr.limitations.bound = scr.skinnedMeshRend.bounds;
			}
			else if (scr.objectType == ObjectType.NestedCluster || scr.objectType == ObjectType.ConnectedCluster)
			{
				scr.limitations.bound = RFCluster.GetChildrenBound(scr.transForm);
			}
			scr.limitations.bboxSize = scr.limitations.bound.size.magnitude;
		}

		public static void SetAncestor(RayfireRigid scr)
		{
			if (scr.limitations.ancestor == null)
			{
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					scr.fragments[i].limitations.ancestor = scr;
				}
			}
			else
			{
				for (int j = 0; j < scr.fragments.Count; j++)
				{
					scr.fragments[j].limitations.ancestor = scr.limitations.ancestor;
				}
			}
		}

		public static void SetDescendants(RayfireRigid scr)
		{
			if (scr.limitations.ancestor == null)
			{
				scr.limitations.descendants.AddRange(scr.fragments);
			}
			else
			{
				scr.limitations.ancestor.limitations.descendants.AddRange(scr.fragments);
			}
		}

		public static void CreateRoot(RayfireRigid rfScr)
		{
			GameObject gameObject = new GameObject();
			gameObject.transform.parent = RayfireMan.inst.transForm;
			gameObject.name = rfScr.gameObject.name + "_root";
			rfScr.rootChild = gameObject.transform;
			rfScr.rootChild.position = rfScr.transForm.position;
			rfScr.rootChild.rotation = rfScr.transForm.rotation;
		}
	}
	[Serializable]
	public class RFManDemolition
	{
		public enum FragmentParentType
		{
			Manager,
			Parent
		}

		[Header("  Fragments")]
		[Space(2f)]
		public FragmentParentType parent;

		public int maximumAmount = 1000;

		[HideInInspector]
		public int currentAmount;

		[Range(1f, 10f)]
		public int badMeshTry = 3;

		[Header("  Shadow Casting")]
		[Range(0f, 1f)]
		public float sizeThreshold = 0.05f;
	}
	[Serializable]
	public class RFMaterial
	{
		private string name;

		[Header("  Demolition")]
		[Space(2f)]
		public bool destructible;

		[Range(0.01f, 100f)]
		public int solidity;

		[Header("  Rigid Body")]
		[Space(2f)]
		[Range(0.01f, 100f)]
		public float density;

		[Range(0f, 1f)]
		public float drag;

		[Range(0f, 1f)]
		public float angularDrag;

		[Header("  Physic Material")]
		[Space(2f)]
		public PhysicMaterial material;

		[Range(0.01f, 1f)]
		public float dynamicFriction;

		[Range(0.01f, 1f)]
		public float staticFriction;

		[Range(0.01f, 1f)]
		public float bounciness;

		public PhysicMaterial Material => new PhysicMaterial
		{
			name = name,
			dynamicFriction = dynamicFriction,
			staticFriction = staticFriction,
			bounciness = bounciness,
			frictionCombine = PhysicMaterialCombine.Minimum
		};

		public RFMaterial(string Name, float Density, float Drag, float AngularDrag, int Solidity, bool Destructible, float DynFriction, float StFriction, float Bounce)
		{
			name = Name;
			density = Density;
			drag = Drag;
			angularDrag = AngularDrag;
			solidity = Solidity;
			destructible = Destructible;
			dynamicFriction = DynFriction;
			staticFriction = StFriction;
			bounciness = Bounce;
		}
	}
	[Serializable]
	public class RFMaterialPresets
	{
		public RFMaterial heavyMetal;

		public RFMaterial lightMetal;

		public RFMaterial denseRock;

		public RFMaterial porousRock;

		public RFMaterial concrete;

		public RFMaterial brick;

		public RFMaterial glass;

		public RFMaterial rubber;

		public RFMaterial ice;

		public RFMaterial wood;

		public RFMaterialPresets()
		{
			heavyMetal = new RFMaterial("HeavyMetal", 11f, 0f, 0.05f, 80, Destructible: false, 0.75f, 0.7f, 0.17f);
			lightMetal = new RFMaterial("LightMetal", 8f, 0f, 0.05f, 50, Destructible: false, 0.71f, 0.72f, 0.14f);
			denseRock = new RFMaterial("DenseRock", 4f, 0f, 0.05f, 22, Destructible: true, 0.88f, 0.87f, 0.14f);
			porousRock = new RFMaterial("PorousRock", 2.5f, 0f, 0.05f, 12, Destructible: true, 0.84f, 0.82f, 0.16f);
			concrete = new RFMaterial("Concrete", 3f, 0f, 0.05f, 18, Destructible: true, 0.81f, 0.83f, 0.15f);
			brick = new RFMaterial("Brick", 2.3f, 0f, 0.05f, 10, Destructible: true, 0.76f, 0.75f, 0.13f);
			glass = new RFMaterial("Glass", 1.8f, 0f, 0.05f, 3, Destructible: true, 0.53f, 0.53f, 0.2f);
			rubber = new RFMaterial("Rubber", 1.4f, 0f, 0.05f, 1, Destructible: false, 0.95f, 0.98f, 0.93f);
			ice = new RFMaterial("Ice", 1f, 0f, 0.05f, 2, Destructible: true, 0.07f, 0.07f, 0f);
			wood = new RFMaterial("Wood", 0.7f, 0f, 0.05f, 4, Destructible: true, 0.75f, 0.73f, 0.22f);
		}

		public void SetMaterials()
		{
			if (heavyMetal.material == null)
			{
				heavyMetal.material = heavyMetal.Material;
			}
			if (lightMetal.material == null)
			{
				lightMetal.material = lightMetal.Material;
			}
			if (denseRock.material == null)
			{
				denseRock.material = denseRock.Material;
			}
			if (porousRock.material == null)
			{
				porousRock.material = porousRock.Material;
			}
			if (concrete.material == null)
			{
				concrete.material = concrete.Material;
			}
			if (brick.material == null)
			{
				brick.material = brick.Material;
			}
			if (glass.material == null)
			{
				glass.material = glass.Material;
			}
			if (rubber.material == null)
			{
				rubber.material = rubber.Material;
			}
			if (ice.material == null)
			{
				ice.material = ice.Material;
			}
			if (wood.material == null)
			{
				wood.material = wood.Material;
			}
		}

		public float Density(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.density, 
				MaterialType.LightMetal => lightMetal.density, 
				MaterialType.DenseRock => denseRock.density, 
				MaterialType.PorousRock => porousRock.density, 
				MaterialType.Concrete => concrete.density, 
				MaterialType.Brick => brick.density, 
				MaterialType.Glass => glass.density, 
				MaterialType.Rubber => rubber.density, 
				MaterialType.Ice => ice.density, 
				MaterialType.Wood => wood.density, 
				_ => 2f, 
			};
		}

		public float Drag(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.drag, 
				MaterialType.LightMetal => lightMetal.drag, 
				MaterialType.DenseRock => denseRock.drag, 
				MaterialType.PorousRock => porousRock.drag, 
				MaterialType.Concrete => concrete.drag, 
				MaterialType.Brick => brick.drag, 
				MaterialType.Glass => glass.drag, 
				MaterialType.Rubber => rubber.drag, 
				MaterialType.Ice => ice.drag, 
				MaterialType.Wood => wood.drag, 
				_ => 0f, 
			};
		}

		public float AngularDrag(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.angularDrag, 
				MaterialType.LightMetal => lightMetal.angularDrag, 
				MaterialType.DenseRock => denseRock.angularDrag, 
				MaterialType.PorousRock => porousRock.angularDrag, 
				MaterialType.Concrete => concrete.angularDrag, 
				MaterialType.Brick => brick.angularDrag, 
				MaterialType.Glass => glass.angularDrag, 
				MaterialType.Rubber => rubber.angularDrag, 
				MaterialType.Ice => ice.angularDrag, 
				MaterialType.Wood => wood.angularDrag, 
				_ => 0.05f, 
			};
		}

		public int Solidity(MaterialType materialType)
		{
			int num = 1;
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.solidity, 
				MaterialType.LightMetal => lightMetal.solidity, 
				MaterialType.DenseRock => denseRock.solidity, 
				MaterialType.PorousRock => porousRock.solidity, 
				MaterialType.Concrete => concrete.solidity, 
				MaterialType.Brick => brick.solidity, 
				MaterialType.Glass => glass.solidity, 
				MaterialType.Rubber => rubber.solidity, 
				MaterialType.Ice => ice.solidity, 
				MaterialType.Wood => wood.solidity, 
				_ => num, 
			};
		}

		public bool Destructible(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.destructible, 
				MaterialType.LightMetal => lightMetal.destructible, 
				MaterialType.DenseRock => denseRock.destructible, 
				MaterialType.PorousRock => porousRock.destructible, 
				MaterialType.Concrete => concrete.destructible, 
				MaterialType.Brick => brick.destructible, 
				MaterialType.Glass => glass.destructible, 
				MaterialType.Rubber => rubber.destructible, 
				MaterialType.Ice => ice.destructible, 
				MaterialType.Wood => wood.destructible, 
				_ => true, 
			};
		}

		public static PhysicMaterial Material(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => RayfireMan.inst.materialPresets.heavyMetal.material, 
				MaterialType.LightMetal => RayfireMan.inst.materialPresets.lightMetal.material, 
				MaterialType.DenseRock => RayfireMan.inst.materialPresets.denseRock.material, 
				MaterialType.PorousRock => RayfireMan.inst.materialPresets.porousRock.material, 
				MaterialType.Concrete => RayfireMan.inst.materialPresets.concrete.material, 
				MaterialType.Brick => RayfireMan.inst.materialPresets.brick.material, 
				MaterialType.Glass => RayfireMan.inst.materialPresets.glass.material, 
				MaterialType.Rubber => RayfireMan.inst.materialPresets.rubber.material, 
				MaterialType.Ice => RayfireMan.inst.materialPresets.ice.material, 
				MaterialType.Wood => RayfireMan.inst.materialPresets.wood.material, 
				_ => RayfireMan.inst.materialPresets.concrete.material, 
			};
		}
	}
	[Serializable]
	public class RFMesh
	{
		[Serializable]
		public class RFSubMeshTris
		{
			public List<int> triangles;

			public RFSubMeshTris()
			{
				triangles = new List<int>();
			}

			public RFSubMeshTris(List<int> tris)
			{
				triangles = tris;
			}
		}

		public bool compress;

		public int subMeshCount;

		public Bounds bounds;

		public int[] triangles;

		public List<RFSubMeshTris> subTriangles;

		public UnityEngine.Vector2[] uv;

		public UnityEngine.Vector3[] vertices;

		public UnityEngine.Vector4[] tangents;

		public List<int> uvComp;

		public List<int> verticesComp;

		public List<int> tangentsComp;

		public RFMesh(Mesh mesh, bool comp = false)
		{
			compress = comp;
			subMeshCount = mesh.subMeshCount;
			bounds = mesh.bounds;
			subTriangles = new List<RFSubMeshTris>();
			if (subMeshCount <= 1)
			{
				triangles = mesh.triangles;
			}
			else if (subMeshCount > 1)
			{
				for (int i = 0; i < subMeshCount; i++)
				{
					subTriangles.Add(new RFSubMeshTris(mesh.GetTriangles(i).ToList()));
				}
			}
			if (!comp)
			{
				uv = mesh.uv;
				vertices = mesh.vertices;
				tangents = mesh.tangents;
				return;
			}
			uvComp = new List<int>();
			verticesComp = new List<int>();
			tangentsComp = new List<int>();
			UnityEngine.Vector2[] array = mesh.uv;
			for (int j = 0; j < array.Length; j++)
			{
				UnityEngine.Vector2 vector = array[j];
				uvComp.Add(Mathf.RoundToInt(vector.x * 1000f));
				uvComp.Add(Mathf.RoundToInt(vector.y * 1000f));
			}
			UnityEngine.Vector3[] array2 = mesh.vertices;
			for (int j = 0; j < array2.Length; j++)
			{
				UnityEngine.Vector3 vector2 = array2[j];
				verticesComp.Add(Mathf.RoundToInt(vector2.x * 1000f));
				verticesComp.Add(Mathf.RoundToInt(vector2.y * 1000f));
				verticesComp.Add(Mathf.RoundToInt(vector2.z * 1000f));
			}
			UnityEngine.Vector4[] array3 = mesh.tangents;
			for (int j = 0; j < array3.Length; j++)
			{
				UnityEngine.Vector4 vector3 = array3[j];
				tangentsComp.Add(Mathf.RoundToInt(vector3.x * 1000f));
				tangentsComp.Add(Mathf.RoundToInt(vector3.y * 1000f));
				tangentsComp.Add(Mathf.RoundToInt(vector3.z * 1000f));
			}
		}

		public Mesh GetMesh()
		{
			Mesh mesh = new Mesh();
			mesh.subMeshCount = subMeshCount;
			if (!compress)
			{
				mesh.vertices = vertices;
				LoadTriangles(mesh);
				mesh.uv = uv;
				mesh.tangents = tangents;
			}
			else
			{
				mesh.vertices = SetCompressedVertices(verticesComp);
				LoadTriangles(mesh);
				mesh.uv = SetCompressedUv(uvComp);
				mesh.tangents = SetCompressedTangents(tangentsComp);
			}
			mesh.RecalculateNormals();
			mesh.RecalculateTangents();
			mesh.RecalculateBounds();
			return mesh;
		}

		private void LoadTriangles(Mesh mesh)
		{
			if (subMeshCount == 1)
			{
				mesh.triangles = triangles;
			}
			else if (subMeshCount > 1)
			{
				for (int i = 0; i < subMeshCount; i++)
				{
					mesh.SetTriangles(subTriangles[i].triangles, i);
				}
			}
		}

		public static Mesh BakeMesh(SkinnedMeshRenderer skin)
		{
			Mesh mesh = new Mesh();
			skin.BakeMesh(mesh);
			mesh.name = skin.name + "_bake";
			return mesh;
		}

		public static void ConvertRfMeshes(RayfireRigid rigid)
		{
			rigid.meshes = new Mesh[rigid.rfMeshes.Length];
			for (int i = 0; i < rigid.rfMeshes.Length; i++)
			{
				rigid.meshes[i] = rigid.rfMeshes[i].GetMesh();
			}
			rigid.rfMeshes = null;
		}

		private static UnityEngine.Vector2[] SetCompressedUv(List<int> uvComp)
		{
			UnityEngine.Vector2[] array = new UnityEngine.Vector2[uvComp.Count / 2];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new UnityEngine.Vector2((float)uvComp[i * 2] / 1000f, (float)uvComp[i * 2 + 1] / 1000f);
			}
			return array;
		}

		private static UnityEngine.Vector3[] SetCompressedVertices(List<int> verticesComp)
		{
			UnityEngine.Vector3[] array = new UnityEngine.Vector3[verticesComp.Count / 3];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new UnityEngine.Vector3((float)verticesComp[i * 3] / 1000f, (float)verticesComp[i * 3 + 1] / 1000f, (float)verticesComp[i * 3 + 2] / 1000f);
			}
			return array;
		}

		private static UnityEngine.Vector4[] SetCompressedTangents(List<int> tangentsComp)
		{
			UnityEngine.Vector4[] array = new UnityEngine.Vector4[tangentsComp.Count / 3];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new UnityEngine.Vector3((float)tangentsComp[i * 3] / 1000f, (float)tangentsComp[i * 3 + 1] / 1000f, (float)tangentsComp[i * 3 + 2] / 1000f);
			}
			return array;
		}
	}
	[Serializable]
	public class RFParticleNoise
	{
		[Header("  Main")]
		[Space(3f)]
		public bool enabled;

		[Space(1f)]
		public ParticleSystemNoiseQuality quality;

		[Header("  Strength")]
		[Space(3f)]
		[Range(0f, 3f)]
		public float strengthMin;

		[Space(1f)]
		[Range(0f, 3f)]
		public float strengthMax;

		[Header("  Other")]
		[Space(3f)]
		[Range(0.001f, 3f)]
		public float frequency;

		[Space(1f)]
		[Range(0f, 2f)]
		public float scrollSpeed;

		[Space(1f)]
		public bool damping;

		public RFParticleNoise()
		{
			enabled = false;
			strengthMin = 0.3f;
			strengthMax = 0.6f;
			frequency = 0.3f;
			scrollSpeed = 0.7f;
			damping = true;
			quality = ParticleSystemNoiseQuality.High;
		}

		public void CopyFrom(RFParticleNoise source)
		{
			enabled = source.enabled;
			strengthMin = source.strengthMin;
			strengthMax = source.strengthMax;
			frequency = source.frequency;
			scrollSpeed = source.scrollSpeed;
			damping = source.damping;
			quality = source.quality;
		}
	}
	[Serializable]
	public class RFParticleRendering
	{
		[Header("  Shadows")]
		[Space(3f)]
		public bool castShadows;

		[Space(1f)]
		public bool receiveShadows;

		public RFParticleRendering()
		{
			castShadows = true;
			receiveShadows = true;
		}

		public void CopyFrom(RFParticleRendering source)
		{
			castShadows = source.castShadows;
			receiveShadows = source.receiveShadows;
		}
	}
	[Serializable]
	public class RFParticleDynamicDebris
	{
		[Header("  Speed")]
		[Space(3f)]
		[Range(0f, 10f)]
		public float speedMin;

		[Space(1f)]
		[Range(0f, 10f)]
		public float speedMax;

		[Header("  Inherit Velocity")]
		[Space(3f)]
		[Range(0f, 3f)]
		public float velocityMin;

		[Space(1f)]
		[Range(0f, 3f)]
		public float velocityMax;

		[Header("  Gravity Modifier")]
		[Space(3f)]
		[Range(-2f, 2f)]
		public float gravityMin;

		[Space(1f)]
		[Range(-2f, 2f)]
		public float gravityMax;

		[Header("  Rotation")]
		[Space(3f)]
		[Range(0f, 1f)]
		public float rotationSpeed;

		public RFParticleDynamicDebris()
		{
			speedMin = 1f;
			speedMax = 4f;
			velocityMin = 0.5f;
			velocityMax = 1.5f;
			rotationSpeed = 0.5f;
			gravityMin = 0.8f;
			gravityMax = 1.1f;
		}

		public void CopyFrom(RFParticleDynamicDebris source)
		{
			speedMin = source.speedMin;
			speedMax = source.speedMax;
			velocityMin = source.velocityMin;
			velocityMax = source.velocityMax;
			rotationSpeed = source.rotationSpeed;
			gravityMin = source.gravityMin;
			gravityMax = source.gravityMax;
		}
	}
	[Serializable]
	public class RFParticleDynamicDust
	{
		[Header("  Velocity")]
		[Space(3f)]
		[Range(0f, 10f)]
		public float speedMin;

		[Space(1f)]
		[Range(0f, 10f)]
		public float speedMax;

		[Header("  Gravity Modifier")]
		[Space(3f)]
		[Range(-2f, 2f)]
		public float gravityMin;

		[Space(1f)]
		[Range(-2f, 2f)]
		public float gravityMax;

		public RFParticleDynamicDust()
		{
			speedMin = 0f;
			speedMax = 0.5f;
			gravityMin = -0.1f;
			gravityMax = 0.7f;
		}

		public void CopyFrom(RFParticleDynamicDust source)
		{
			speedMin = source.speedMin;
			speedMax = source.speedMax;
			gravityMin = source.gravityMin;
			gravityMax = source.gravityMax;
		}
	}
	[Serializable]
	public class RFParticleEmission
	{
		[Header("  Burst")]
		[Space(3f)]
		public RFParticles.BurstType burstType;

		[Space(1f)]
		[Range(0f, 500f)]
		public int burstAmount;

		[Header("  Distance")]
		[Space(3f)]
		[Range(0f, 5f)]
		public float distanceRate;

		[Space(1f)]
		[Range(0.5f, 10f)]
		public float duration;

		[Header("  Lifetime")]
		[Space(3f)]
		[Range(1f, 60f)]
		public float lifeMin;

		[Space(1f)]
		[Range(1f, 60f)]
		public float lifeMax;

		[Header("  Size")]
		[Space(3f)]
		[Range(0.1f, 10f)]
		public float sizeMin;

		[Space(1f)]
		[Range(0.1f, 10f)]
		public float sizeMax;

		public RFParticleEmission()
		{
			burstType = RFParticles.BurstType.PerOneUnitSize;
			burstAmount = 20;
			duration = 4f;
			distanceRate = 1f;
			lifeMin = 2f;
			lifeMax = 13f;
			sizeMin = 0.5f;
			sizeMax = 2.5f;
		}

		public void CopyFrom(RFParticleEmission source)
		{
			burstType = source.burstType;
			burstAmount = source.burstAmount;
			distanceRate = source.distanceRate;
			lifeMin = source.lifeMin;
			lifeMax = source.lifeMax;
			sizeMin = source.sizeMin;
			sizeMax = source.sizeMax;
		}
	}
	[Serializable]
	public class RFParticleLimitations
	{
		[Header("  Particle system")]
		[Space(3f)]
		[Range(3f, 100f)]
		public int minParticles;

		[Space(1f)]
		[Range(5f, 100f)]
		public int maxParticles;

		[Header("  Fragments")]
		[Space(3f)]
		[Range(10f, 100f)]
		public int percentage;

		[Space(1f)]
		[Range(0.05f, 5f)]
		public float sizeThreshold;

		[Space(1f)]
		[Range(0f, 5f)]
		public int demolitionDepth;

		public RFParticleLimitations()
		{
			minParticles = 3;
			maxParticles = 20;
			percentage = 50;
			sizeThreshold = 0.5f;
			demolitionDepth = 2;
		}

		public void CopyFrom(RFParticleLimitations source)
		{
			minParticles = source.minParticles;
			maxParticles = source.maxParticles;
			percentage = source.percentage;
			sizeThreshold = source.sizeThreshold;
			demolitionDepth = source.demolitionDepth;
		}
	}
	[Serializable]
	public class RFParticleCollisionDebris
	{
		public enum RFParticleCollisionWithType
		{
			Everything,
			Nothing
		}

		public enum RFParticleCollisionMatType
		{
			ByPhysicalMaterial,
			ByProperties
		}

		[Header("  Common")]
		[Space(3f)]
		public RFParticleCollisionWithType collidesWith;

		[Space(1f)]
		public ParticleSystemCollisionQuality quality;

		[Space(1f)]
		[Range(0.1f, 2f)]
		public float radiusScale;

		[Header("  Dampen")]
		[Space(3f)]
		public RFParticleCollisionMatType dampenType;

		[Space(1f)]
		[Range(0f, 1f)]
		public float dampenMin;

		[Space(1f)]
		[Range(0f, 1f)]
		public float dampenMax;

		[Header("  Bounce")]
		[Space(3f)]
		public RFParticleCollisionMatType bounceType;

		[Space(1f)]
		[Range(0f, 1f)]
		public float bounceMin;

		[Space(1f)]
		[Range(0f, 1f)]
		public float bounceMax;

		[HideInInspector]
		public bool propertiesSet;

		public RFParticleCollisionDebris()
		{
			collidesWith = RFParticleCollisionWithType.Everything;
			quality = ParticleSystemCollisionQuality.High;
			radiusScale = 0.1f;
			dampenType = RFParticleCollisionMatType.ByProperties;
			dampenMin = 0.1f;
			dampenMax = 0.4f;
			bounceType = RFParticleCollisionMatType.ByProperties;
			bounceMin = 0.2f;
			bounceMax = 0.4f;
		}

		public void CopyFrom(RFParticleCollisionDebris source)
		{
			collidesWith = source.collidesWith;
			quality = source.quality;
			radiusScale = source.radiusScale;
			dampenType = source.dampenType;
			dampenMin = source.dampenMin;
			dampenMax = source.dampenMax;
			bounceType = source.bounceType;
			bounceMin = source.bounceMin;
			bounceMax = source.bounceMax;
			propertiesSet = source.propertiesSet;
		}

		public void SetMaterialProps(RayfireDebris debris)
		{
			if (propertiesSet)
			{
				return;
			}
			propertiesSet = true;
			if (debris.collision.collidesWith == RFParticleCollisionWithType.Nothing || (dampenType == RFParticleCollisionMatType.ByProperties && bounceType == RFParticleCollisionMatType.ByProperties))
			{
				return;
			}
			Collider collider = ((!(debris.rigid == null) && !(debris.rigid.physics.meshCollider == null)) ? debris.rigid.physics.meshCollider : debris.GetComponent<Collider>());
			if (!(collider == null) && !(collider.sharedMaterial == null))
			{
				if (dampenType == RFParticleCollisionMatType.ByPhysicalMaterial)
				{
					dampenMin = collider.sharedMaterial.dynamicFriction;
					dampenMax = dampenMin * 0.05f + dampenMin;
				}
				if (bounceType == RFParticleCollisionMatType.ByPhysicalMaterial)
				{
					bounceMin = collider.sharedMaterial.bounciness;
					bounceMax = bounceMin * 0.05f + bounceMin;
				}
			}
		}
	}
	[Serializable]
	public class RFParticleCollisionDust
	{
		[Header("  Common")]
		[Space(3f)]
		public RFParticles.RFParticleCollisionWithType collidesWith;

		[Space(1f)]
		public ParticleSystemCollisionQuality quality;

		[Space(1f)]
		[Range(0.1f, 2f)]
		public float radiusScale;

		public RFParticleCollisionDust()
		{
			collidesWith = RFParticles.RFParticleCollisionWithType.Everything;
			quality = ParticleSystemCollisionQuality.High;
			radiusScale = 1f;
		}

		public void CopyFrom(RFParticleCollisionDust source)
		{
			collidesWith = source.collidesWith;
			quality = source.quality;
			radiusScale = source.radiusScale;
		}
	}
	[Serializable]
	public class RFParticles
	{
		public enum RFParticleCollisionWithType
		{
			Everything,
			Nothing
		}

		public enum RFParticleCollisionMatType
		{
			ByPhysicalMaterial,
			ByProperties
		}

		public enum BurstType
		{
			None,
			TotalAmount,
			PerOneUnitSize,
			FragmentAmount
		}

		public static void InitDemolitionParticles(RayfireRigid source)
		{
			if (source.HasFragments)
			{
				if (source.HasDebris)
				{
					CreateDemolitionDebris(source);
				}
				if (source.HasDust)
				{
					CreateDemolitionDust(source);
				}
				DetachParticles(source);
			}
		}

		public static void CreateDemolitionDebris(RayfireRigid source)
		{
			for (int i = 0; i < source.debrisList.Count; i++)
			{
				if (!source.debrisList[i].onDemolition || !source.debrisList[i].HasChildren)
				{
					continue;
				}
				List<RayfireDebris> debrisTargets = GetDebrisTargets(source.debrisList[i].children, source.debrisList[i].limitations.sizeThreshold, source.debrisList[i].limitations.percentage, 0);
				if (debrisTargets.Count != 0)
				{
					SetDebrisFinalAmount(debrisTargets, source.debrisList[i].emission.burstType, source.debrisList[i].emission.burstAmount);
					int num = 0;
					for (int j = 0; j < debrisTargets.Count; j++)
					{
						UnityEngine.Random.InitState(num++);
						CreateDebrisRigid(debrisTargets[j]);
					}
				}
			}
		}

		public static void CreateDemolitionDust(RayfireRigid source)
		{
			for (int i = 0; i < source.dustList.Count; i++)
			{
				if (source.dustList[i].onDemolition && source.dustList[i].HasChildren)
				{
					List<RayfireDust> dustTargets = GetDustTargets(source.dustList[i].children, source.dustList[i].limitations.sizeThreshold, source.dustList[i].limitations.percentage, 1);
					SetDustFinalAmount(dustTargets, source.dustList[i].emission.burstType, source.dustList[i].emission.burstAmount);
					int num = 0;
					for (int j = 0; j < dustTargets.Count; j++)
					{
						UnityEngine.Random.InitState(num++);
						CreateDustRigid(dustTargets[j]);
					}
				}
			}
		}

		public static void CreateDebrisRigid(RayfireDebris target)
		{
			if (target.amountFinal >= target.limitations.minParticles || target.emission.distanceRate != 0f)
			{
				ParticleSystem ps = target.CreateParticleSystem(target);
				int emissionMatIndex = GetEmissionMatIndex(target.rigid.meshRenderer, target.emissionMaterial);
				target.CreateDebris(target.rigid.transForm, target, target.rigid.meshFilter, emissionMatIndex, ps);
			}
		}

		public static void CreateDustRigid(RayfireDust target)
		{
			if (target.amountFinal >= target.limitations.minParticles || target.emission.distanceRate != 0f)
			{
				ParticleSystem ps = target.CreateParticleSystem(target);
				int emissionMatIndex = GetEmissionMatIndex(target.rigid.meshRenderer, target.emissionMaterial);
				target.CreateDust(target.rigid.transForm, target, target.rigid.meshFilter, emissionMatIndex, ps);
			}
		}

		public static void InitActivationParticles(RayfireRigid source)
		{
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					if (source.debrisList[i].onActivation)
					{
						CreateDebrisRigid(source.debrisList[i]);
					}
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int j = 0; j < source.dustList.Count; j++)
			{
				if (source.dustList[j].onActivation)
				{
					CreateDustRigid(source.dustList[j]);
				}
			}
		}

		public static void CreateDebrisImpact(RayfireDebris debris, UnityEngine.Vector3 impactPos, UnityEngine.Vector3 impactNormal)
		{
			ParticleSystem ps = debris.CreateParticleSystem(debris);
			debris.hostTm.position = impactPos;
			debris.hostTm.LookAt(impactPos + impactNormal);
			debris.amountFinal = debris.emission.burstAmount;
			debris.CreateDebris(debris.rigid.transForm, debris, null, -1, ps);
		}

		public static void CreateDustImpact(RayfireDust dust, UnityEngine.Vector3 impactPos, UnityEngine.Vector3 impactNormal)
		{
			ParticleSystem ps = dust.CreateParticleSystem(dust);
			dust.hostTm.position = impactPos;
			dust.hostTm.LookAt(impactPos + impactNormal);
			dust.amountFinal = dust.emission.burstAmount;
			dust.CreateDust(dust.rigid.transForm, dust, null, -1, ps);
		}

		private static void DetachParticles(RayfireRigid source)
		{
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					if (source.debrisList[i].hostTm != null)
					{
						source.debrisList[i].hostTm.parent = null;
						source.debrisList[i].hostTm.localScale = UnityEngine.Vector3.one;
					}
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int j = 0; j < source.dustList.Count; j++)
			{
				if (source.dustList[j].hostTm != null)
				{
					source.dustList[j].hostTm.parent = null;
					source.dustList[j].hostTm.localScale = UnityEngine.Vector3.one;
				}
			}
		}

		public static void CopyParticles(RayfireRigid source, RayfireRigid target)
		{
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					RayfireDebris rayfireDebris = target.gameObject.AddComponent<RayfireDebris>();
					rayfireDebris.CopyFrom(source.debrisList[i]);
					if (source.debrisList[i].children == null)
					{
						source.debrisList[i].children = new List<RayfireDebris>();
					}
					source.debrisList[i].children.Add(rayfireDebris);
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int j = 0; j < source.dustList.Count; j++)
			{
				RayfireDust rayfireDust = target.gameObject.AddComponent<RayfireDust>();
				rayfireDust.CopyFrom(source.dustList[j]);
				if (source.dustList[j].children == null)
				{
					source.dustList[j].children = new List<RayfireDust>();
				}
				source.dustList[j].children.Add(rayfireDust);
			}
		}

		public static void CopyRootMeshParticles(RayfireRigid source, List<RayfireRigid> targets)
		{
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					int num = targets.Count;
					if (source.debrisList[i].limitations.percentage < 100)
					{
						num = targets.Count * source.debrisList[i].limitations.percentage / 100;
					}
					for (int j = 0; j < targets.Count; j++)
					{
						if (num <= 0)
						{
							break;
						}
						if (UnityEngine.Random.Range(0, 100) <= source.debrisList[i].limitations.percentage)
						{
							RayfireDebris rayfireDebris = targets[j].gameObject.AddComponent<RayfireDebris>();
							rayfireDebris.CopyFrom(source.debrisList[i]);
							rayfireDebris.rigid = targets[j];
							if (targets[j].debrisList == null)
							{
								targets[j].debrisList = new List<RayfireDebris>();
							}
							targets[j].debrisList.Add(rayfireDebris);
							if (source.debrisList[i].children == null)
							{
								source.debrisList[i].children = new List<RayfireDebris>();
							}
							source.debrisList[i].children.Add(rayfireDebris);
							num--;
						}
					}
					SetDebrisFinalAmount(source.debrisList[i].children, source.debrisList[i].emission.burstType, source.debrisList[i].emission.burstAmount);
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int k = 0; k < source.dustList.Count; k++)
			{
				int num2 = targets.Count;
				if (source.dustList[k].limitations.percentage < 100)
				{
					num2 = targets.Count * source.dustList[k].limitations.percentage / 100;
				}
				for (int l = 0; l < targets.Count; l++)
				{
					if (num2 <= 0)
					{
						break;
					}
					if (UnityEngine.Random.Range(0, 100) <= source.dustList[k].limitations.percentage)
					{
						RayfireDust rayfireDust = targets[l].gameObject.AddComponent<RayfireDust>();
						rayfireDust.CopyFrom(source.dustList[k]);
						rayfireDust.rigid = targets[l];
						if (targets[l].dustList == null)
						{
							targets[l].dustList = new List<RayfireDust>();
						}
						targets[l].dustList.Add(rayfireDust);
						if (source.dustList[k].children == null)
						{
							source.dustList[k].children = new List<RayfireDust>();
						}
						source.dustList[k].children.Add(rayfireDust);
						num2--;
					}
				}
				SetDustFinalAmount(source.dustList[k].children, source.dustList[k].emission.burstType, source.dustList[k].emission.burstAmount);
			}
		}

		public static void SetMain(ParticleSystem.MainModule main, float lifeMin, float lifeMax, float sizeMin, float sizeMax, float gravityMin, float gravityMax, float speedMin, float speedMax, float divergence, int maxParticles, float duration)
		{
			main.duration = duration;
			main.loop = false;
			main.simulationSpace = ParticleSystemSimulationSpace.World;
			main.maxParticles = maxParticles;
			main.emitterVelocityMode = ParticleSystemEmitterVelocityMode.Transform;
			main.startLifetime = new ParticleSystem.MinMaxCurve(lifeMin, lifeMax);
			main.startSpeed = new ParticleSystem.MinMaxCurve(speedMin, speedMax);
			main.startSize = new ParticleSystem.MinMaxCurve(sizeMin, sizeMax);
			main.startRotation = new ParticleSystem.MinMaxCurve(0f - divergence, divergence);
			main.gravityModifier = new ParticleSystem.MinMaxCurve(gravityMin, gravityMax);
		}

		public static void SetEmission(ParticleSystem.EmissionModule emissionModule, float distanceRate, int burstAmount)
		{
			emissionModule.enabled = true;
			emissionModule.rateOverTimeMultiplier = 0f;
			emissionModule.rateOverDistanceMultiplier = distanceRate;
			if (burstAmount > 0)
			{
				ParticleSystem.Burst burst = new ParticleSystem.Burst(0f, (short)burstAmount, (short)burstAmount, 1, 999f);
				ParticleSystem.Burst[] bursts = new ParticleSystem.Burst[1] { burst };
				emissionModule.SetBursts(bursts);
			}
		}

		public static void SetShapeMesh(ParticleSystem.ShapeModule shapeModule, Mesh mesh, int emitMatIndex, UnityEngine.Vector3 shapeScale)
		{
			shapeModule.normalOffset = 0f;
			shapeModule.shapeType = ParticleSystemShapeType.Mesh;
			shapeModule.meshShapeType = ParticleSystemMeshShapeType.Triangle;
			shapeModule.mesh = mesh;
			shapeModule.scale = shapeScale;
			if (emitMatIndex > 0)
			{
				shapeModule.useMeshMaterialIndex = true;
				shapeModule.meshMaterialIndex = emitMatIndex;
			}
		}

		public static void SetShapeObject(ParticleSystem.ShapeModule shapeModule)
		{
			shapeModule.shapeType = ParticleSystemShapeType.Hemisphere;
			shapeModule.radius = 0.2f;
			shapeModule.radiusThickness = 0f;
		}

		public static int GetEmissionMatIndex(Renderer renderer, Material mat)
		{
			if (mat != null)
			{
				for (int i = 0; i < renderer.sharedMaterials.Length; i++)
				{
					if (renderer.sharedMaterials[i] == mat)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public static void SetVelocity(ParticleSystem.InheritVelocityModule velocity, RFParticleDynamicDebris dynamic)
		{
			if (dynamic.velocityMin > 0f || dynamic.velocityMax > 0f)
			{
				velocity.enabled = true;
				velocity.mode = ParticleSystemInheritVelocityMode.Initial;
				velocity.curve = new ParticleSystem.MinMaxCurve(dynamic.velocityMin, dynamic.velocityMax);
			}
		}

		public static void SetSizeOverLifeTime(ParticleSystem.SizeOverLifetimeModule sizeOverLifeTime, float size)
		{
			sizeOverLifeTime.enabled = true;
			sizeOverLifeTime.size = GetCurveSizeOverLifeTime(size);
		}

		public static void SetSizeOverLifeTime(ParticleSystem.SizeOverLifetimeModule sizeOverLifeTime, UnityEngine.Vector3 size)
		{
			sizeOverLifeTime.enabled = true;
			sizeOverLifeTime.separateAxes = true;
			sizeOverLifeTime.x = GetCurveSizeOverLifeTime(size.x);
			sizeOverLifeTime.y = GetCurveSizeOverLifeTime(size.y);
			sizeOverLifeTime.z = GetCurveSizeOverLifeTime(size.z);
		}

		public static ParticleSystem.MinMaxCurve GetCurveSizeOverLifeTime(float val)
		{
			AnimationCurve curve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.01f, val), new Keyframe(0.95f, val), new Keyframe(1f, 0f));
			return new ParticleSystem.MinMaxCurve(1f, curve);
		}

		public static void SetRotationBySpeed(ParticleSystem.RotationBySpeedModule rotationBySpeed, float rotationSpeed)
		{
			if (rotationSpeed > 0f)
			{
				rotationBySpeed.enabled = true;
				rotationBySpeed.range = new UnityEngine.Vector2(1f, 0f);
				rotationBySpeed.z = GetCurveRotationBySpeed(rotationSpeed);
			}
		}

		public static ParticleSystem.MinMaxCurve GetCurveRotationBySpeed(float rotationSpeed)
		{
			float num = rotationSpeed * 40f;
			Keyframe[] obj = new Keyframe[2]
			{
				new Keyframe(0f, num),
				new Keyframe(0.5f, 0f)
			};
			AnimationCurve max = new AnimationCurve(obj);
			obj[0] = new Keyframe(0f, 0f - num);
			AnimationCurve min = new AnimationCurve(obj);
			return new ParticleSystem.MinMaxCurve(1f, min, max);
		}

		public static void SetColorOverLife(ParticleSystem.ColorOverLifetimeModule colorLife, float opacity)
		{
			colorLife.enabled = true;
			GradientAlphaKey[] alphaKeys = new GradientAlphaKey[4]
			{
				new GradientAlphaKey(0f, 0f),
				new GradientAlphaKey(opacity, 0.1f),
				new GradientAlphaKey(opacity, 0.2f),
				new GradientAlphaKey(0f, 1f)
			};
			Gradient gradient = new Gradient();
			gradient.alphaKeys = alphaKeys;
			colorLife.color = new ParticleSystem.MinMaxGradient(gradient);
		}

		public static void SetNoise(ParticleSystem.NoiseModule psNoise, RFParticleNoise scrNoise)
		{
			if (scrNoise.enabled)
			{
				psNoise.enabled = true;
				psNoise.strength = new ParticleSystem.MinMaxCurve(scrNoise.strengthMin, scrNoise.strengthMax);
				psNoise.frequency = scrNoise.frequency;
				psNoise.scrollSpeed = scrNoise.scrollSpeed;
				psNoise.damping = scrNoise.damping;
				psNoise.quality = scrNoise.quality;
				psNoise.separateAxes = true;
				psNoise.strengthX = new ParticleSystem.MinMaxCurve(scrNoise.strengthMin, scrNoise.strengthMax);
				psNoise.strengthY = new ParticleSystem.MinMaxCurve(scrNoise.strengthMin * 0.3f, scrNoise.strengthMax * 0.3f);
				psNoise.strengthZ = new ParticleSystem.MinMaxCurve(scrNoise.strengthMin, scrNoise.strengthMax);
			}
		}

		public static void SetCollisionDebris(ParticleSystem.CollisionModule psCollision, RFParticleCollisionDebris coll)
		{
			psCollision.enabled = true;
			psCollision.type = ParticleSystemCollisionType.World;
			psCollision.collidesWith = (int)(coll.collidesWith - 1);
			psCollision.quality = coll.quality;
			psCollision.radiusScale = coll.radiusScale;
			psCollision.dampen = new ParticleSystem.MinMaxCurve(coll.dampenMin, coll.dampenMax);
			psCollision.bounce = new ParticleSystem.MinMaxCurve(coll.bounceMin, coll.bounceMax);
		}

		public static void SetCollisionDust(ParticleSystem.CollisionModule psCollision, RFParticleCollisionDust coll)
		{
			psCollision.enabled = true;
			psCollision.type = ParticleSystemCollisionType.World;
			psCollision.collidesWith = (int)(coll.collidesWith - 1);
			psCollision.quality = coll.quality;
			psCollision.radiusScale = coll.radiusScale;
			psCollision.dampenMultiplier = 0f;
			psCollision.bounceMultiplier = 0f;
			psCollision.enableDynamicColliders = false;
		}

		public static List<RayfireDebris> GetDebrisTargets(List<RayfireDebris> targets, float sizeThreshold, int percentage, int pType)
		{
			List<RayfireDebris> list = new List<RayfireDebris>();
			int num = targets.Count;
			if (percentage < 100)
			{
				num = targets.Count * percentage / 100;
			}
			for (int i = 0; i < targets.Count; i++)
			{
				if (list.Count >= num)
				{
					break;
				}
				if (!(targets[i].rigid.limitations.bboxSize < sizeThreshold) && UnityEngine.Random.Range(0, 100) <= percentage)
				{
					list.Add(targets[i]);
				}
			}
			return list;
		}

		public static List<RayfireDust> GetDustTargets(List<RayfireDust> targets, float sizeThreshold, int percentage, int pType)
		{
			List<RayfireDust> list = new List<RayfireDust>();
			int num = targets.Count;
			if (percentage < 100)
			{
				num = targets.Count * percentage / 100;
			}
			for (int i = 0; i < targets.Count; i++)
			{
				if (list.Count >= num)
				{
					break;
				}
				if (!(targets[i].rigid.limitations.bboxSize < sizeThreshold) && UnityEngine.Random.Range(0, 100) <= percentage)
				{
					list.Add(targets[i]);
				}
			}
			return list;
		}

		public static void SetDebrisFinalAmount(List<RayfireDebris> targets, BurstType burstType, int burstAmount)
		{
			if (burstType == BurstType.None)
			{
				for (int i = 0; i < targets.Count; i++)
				{
					targets[i].amountFinal = 0;
				}
			}
			switch (burstType)
			{
			case BurstType.FragmentAmount:
			{
				for (int l = 0; l < targets.Count; l++)
				{
					targets[l].amountFinal = burstAmount;
				}
				break;
			}
			case BurstType.PerOneUnitSize:
			{
				for (int m = 0; m < targets.Count; m++)
				{
					targets[m].amountFinal = (int)((float)burstAmount * targets[m].rigid.limitations.bboxSize);
				}
				break;
			}
			case BurstType.TotalAmount:
			{
				float num = 0f;
				for (int j = 0; j < targets.Count; j++)
				{
					num += targets[j].rigid.limitations.bboxSize;
				}
				float num2 = num / (float)burstAmount;
				for (int k = 0; k < targets.Count; k++)
				{
					targets[k].amountFinal = (int)(targets[k].rigid.limitations.bboxSize / num2);
				}
				break;
			}
			}
		}

		public static void SetDustFinalAmount(List<RayfireDust> targets, BurstType burstType, int burstAmount)
		{
			if (burstType == BurstType.None)
			{
				for (int i = 0; i < targets.Count; i++)
				{
					targets[i].amountFinal = 0;
				}
			}
			switch (burstType)
			{
			case BurstType.FragmentAmount:
			{
				for (int l = 0; l < targets.Count; l++)
				{
					targets[l].amountFinal = burstAmount;
				}
				break;
			}
			case BurstType.PerOneUnitSize:
			{
				for (int m = 0; m < targets.Count; m++)
				{
					targets[m].amountFinal = (int)((float)burstAmount * targets[m].rigid.limitations.bboxSize);
				}
				break;
			}
			case BurstType.TotalAmount:
			{
				float num = 0f;
				for (int j = 0; j < targets.Count; j++)
				{
					num += targets[j].rigid.limitations.bboxSize;
				}
				float num2 = num / (float)burstAmount;
				for (int k = 0; k < targets.Count; k++)
				{
					targets[k].amountFinal = (int)(targets[k].rigid.limitations.bboxSize / num2);
				}
				break;
			}
			}
		}

		public static bool AmountCheck(RayfireRigid source, int pType)
		{
			if (pType == 0)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					if (source.debrisList[i].emission.burstType == BurstType.None && source.debrisList[i].emission.distanceRate == 0f)
					{
						UnityEngine.Debug.Log(source.name + " has debris enabled but has no amount");
						return false;
					}
				}
			}
			if (pType == 1)
			{
				for (int j = 0; j < source.dustList.Count; j++)
				{
					if (source.dustList[j].emission.burstType == BurstType.None && source.dustList[j].emission.distanceRate == 0f)
					{
						UnityEngine.Debug.Log(source.name + " has dust enabled but has no amount");
						return false;
					}
				}
			}
			return true;
		}
	}
	[Serializable]
	public class RFImpulse
	{
		public bool previewLinear;

		public bool enableLinear;

		public UnityEngine.Vector3 linearVelocity;

		public float linearVelocityVariation;

		public int angularVelocityDivergence;

		public bool enableAngular;

		public UnityEngine.Vector3 angularVelocity;

		public int angularVelocityVariation;
	}
	[Serializable]
	public class RFPhysic
	{
		[Header("  Physic Material")]
		[Space(3f)]
		[Tooltip("Material preset with predefined density, friction, elasticity and solidity. Can be edited in Rayfire Man component.")]
		public MaterialType materialType;

		[Space(1f)]
		[Tooltip("Allows to define own Physic Material.")]
		public PhysicMaterial material;

		[Header("  Mass")]
		[Space(3f)]
		public MassType massBy;

		[Space(1f)]
		[Range(0.1f, 100f)]
		public float mass;

		[Header("  Other")]
		[Space(3f)]
		public RFColliderType colliderType;

		public bool useGravity;

		[Header("  Fragments")]
		[Space(3f)]
		[Tooltip("Multiplier for demolished fragments velocity.")]
		[Range(0f, 5f)]
		public float dampening;

		[HideInInspector]
		public bool recorder;

		[HideInInspector]
		public bool exclude;

		[HideInInspector]
		public bool destructible;

		[HideInInspector]
		public int materialSolidity = 1;

		[HideInInspector]
		public UnityEngine.Quaternion rotation;

		[HideInInspector]
		public UnityEngine.Vector3 position;

		[HideInInspector]
		public UnityEngine.Vector3 velocity;

		[HideInInspector]
		public UnityEngine.Vector3 initScale;

		[HideInInspector]
		public UnityEngine.Vector3 initPosition;

		[HideInInspector]
		public UnityEngine.Quaternion initRotation;

		[HideInInspector]
		public Rigidbody rigidBody;

		[HideInInspector]
		public Collider meshCollider;

		[HideInInspector]
		public List<Collider> clusterColliders;

		public bool Destructible => RayfireMan.inst.materialPresets.Destructible(materialType);

		public int Solidity => RayfireMan.inst.materialPresets.Solidity(materialType);

		private PhysicMaterial PhysMaterial
		{
			get
			{
				if (material != null)
				{
					return material;
				}
				return RFMaterialPresets.Material(materialType);
			}
		}

		public RFPhysic()
		{
			materialType = MaterialType.Concrete;
			material = null;
			massBy = MassType.MaterialDensity;
			mass = 1f;
			colliderType = RFColliderType.Mesh;
			useGravity = true;
			dampening = 0.8f;
			Reset();
			rotation = UnityEngine.Quaternion.identity;
			position = UnityEngine.Vector3.zero;
			velocity = UnityEngine.Vector3.zero;
			initScale = UnityEngine.Vector3.one;
			initPosition = UnityEngine.Vector3.zero;
			initRotation = UnityEngine.Quaternion.identity;
		}

		public void CopyFrom(RFPhysic physics)
		{
			materialType = physics.materialType;
			material = physics.material;
			massBy = physics.massBy;
			mass = physics.mass;
			colliderType = physics.colliderType;
			useGravity = physics.useGravity;
			dampening = physics.dampening;
			Reset();
		}

		public void Reset()
		{
			recorder = false;
			exclude = false;
		}

		public static void SetSimulationType(RayfireRigid scr)
		{
			if (scr.simulationType == SimType.Dynamic)
			{
				SetDynamic(scr);
			}
			else if (scr.simulationType == SimType.Sleeping)
			{
				SetSleeping(scr);
			}
			else if (scr.simulationType == SimType.Inactive)
			{
				SetInactive(scr);
			}
			else if (scr.simulationType == SimType.Kinematic)
			{
				SetKinematic(scr);
			}
			else if (scr.simulationType == SimType.Static)
			{
				SetStatic(scr);
			}
		}

		private static void SetDynamic(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
		}

		private static void SetSleeping(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
			scr.physics.rigidBody.Sleep();
		}

		private static void SetInactive(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = false;
			scr.physics.rigidBody.Sleep();
		}

		private static void SetKinematic(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = true;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
		}

		private static void SetStatic(RayfireRigid scr)
		{
		}

		public static void SetDensity(RayfireRigid scr)
		{
			if (!scr.physics.rigidBody.isKinematic)
			{
				float num = scr.physics.mass;
				if (scr.physics.massBy == MassType.MaterialDensity)
				{
					scr.physics.rigidBody.SetDensity(RayfireMan.inst.materialPresets.Density(scr.physics.materialType));
					num = scr.physics.rigidBody.mass;
				}
				if (RayfireMan.inst.minimumMass > 0f && num < RayfireMan.inst.minimumMass)
				{
					num = RayfireMan.inst.minimumMass;
				}
				if (RayfireMan.inst.maximumMass > 0f && num > RayfireMan.inst.maximumMass)
				{
					num = RayfireMan.inst.maximumMass;
				}
				scr.physics.rigidBody.mass = num;
			}
		}

		public static void SetDrag(RayfireRigid scr)
		{
			scr.physics.rigidBody.drag = RayfireMan.inst.materialPresets.Drag(scr.physics.materialType);
			scr.physics.rigidBody.angularDrag = RayfireMan.inst.materialPresets.AngularDrag(scr.physics.materialType);
		}

		public static void SetFragmentsVelocity(RayfireRigid scr)
		{
			if (scr.meshDemolition.runtimeCaching.wasUsed && !scr.meshDemolition.runtimeCaching.skipFirstDemolition)
			{
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					if (scr.fragments[i] != null)
					{
						scr.fragments[i].physics.rigidBody.velocity = scr.physics.rigidBody.GetPointVelocity(scr.fragments[i].transForm.position) * scr.physics.dampening;
					}
				}
				return;
			}
			UnityEngine.Vector3 vector = scr.physics.velocity * scr.physics.dampening;
			for (int j = 0; j < scr.fragments.Count; j++)
			{
				if (scr.fragments[j].physics.rigidBody != null)
				{
					scr.fragments[j].physics.rigidBody.velocity = vector;
				}
			}
		}

		public static void SetFragmentMeshCollider(RayfireRigid scr, Mesh mesh)
		{
			scr.physics.colliderType = scr.meshDemolition.properties.colliderType;
			if (scr.meshDemolition.properties.sizeFilter > 0f && mesh.bounds.size.magnitude < scr.meshDemolition.properties.sizeFilter)
			{
				scr.physics.colliderType = RFColliderType.None;
			}
			SetMeshCollider(scr, mesh);
		}

		public static void SetMeshCollider(RayfireRigid scr, Mesh mesh = null)
		{
			if (scr.physics.colliderType == RFColliderType.None)
			{
				return;
			}
			if (scr.physics.meshCollider != null && scr.physics.meshCollider.isTrigger)
			{
				scr.physics.meshCollider = null;
			}
			if (!(scr.physics.meshCollider == null))
			{
				return;
			}
			if (scr.physics.colliderType == RFColliderType.Mesh)
			{
				MeshCollider meshCollider = scr.gameObject.AddComponent<MeshCollider>();
				if (mesh != null)
				{
					meshCollider.sharedMesh = mesh;
				}
				if (scr.simulationType == SimType.Dynamic || scr.simulationType == SimType.Inactive || scr.simulationType == SimType.Sleeping)
				{
					meshCollider.convex = true;
				}
				scr.physics.meshCollider = meshCollider;
			}
			else if (scr.physics.colliderType == RFColliderType.Box)
			{
				BoxCollider boxCollider = scr.gameObject.AddComponent<BoxCollider>();
				scr.physics.meshCollider = boxCollider;
			}
			else if (scr.physics.colliderType == RFColliderType.Sphere)
			{
				SphereCollider sphereCollider = scr.gameObject.AddComponent<SphereCollider>();
				scr.physics.meshCollider = sphereCollider;
			}
		}

		public static void SetClusterColliders(RayfireRigid scr, MeshFilter[] childMeshes)
		{
			scr.physics.clusterColliders = new List<Collider>();
			if (scr.physics.colliderType == RFColliderType.None)
			{
				scr.physics.clusterColliders = scr.gameObject.GetComponents<Collider>().ToList();
				return;
			}
			for (int i = 0; i < childMeshes.Length; i++)
			{
				if (!(childMeshes[i].sharedMesh == null))
				{
					List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>();
					childMeshes[i].sharedMesh.GetVertices(list);
					for (int j = 0; j < list.Count; j++)
					{
						list[j] = scr.transform.InverseTransformPoint(childMeshes[i].transform.TransformPoint(list[j]));
					}
					Mesh mesh = new Mesh();
					mesh.name = childMeshes[i].sharedMesh.name;
					mesh.SetVertices(list);
					mesh.triangles = childMeshes[i].sharedMesh.triangles;
					MeshCollider meshCollider = scr.gameObject.AddComponent<MeshCollider>();
					meshCollider.convex = true;
					meshCollider.sharedMesh = mesh;
					scr.physics.clusterColliders.Add(meshCollider);
				}
			}
		}

		public static void SetColliderMaterial(RayfireRigid scr)
		{
			if (scr.physics.material == null)
			{
				scr.physics.material = scr.physics.PhysMaterial;
			}
			if (scr.physics.meshCollider != null)
			{
				scr.physics.meshCollider.sharedMaterial = scr.physics.material;
				if (!scr.HasDebris)
				{
					return;
				}
				{
					foreach (RayfireDebris debris in scr.debrisList)
					{
						debris.collision.SetMaterialProps(debris);
					}
					return;
				}
			}
			if (scr.physics.clusterColliders == null || scr.physics.clusterColliders.Count <= 0)
			{
				return;
			}
			foreach (Collider clusterCollider in scr.physics.clusterColliders)
			{
				clusterCollider.sharedMaterial = scr.physics.material;
			}
		}

		public static void SetColliderConvex(RayfireRigid scr)
		{
			if (scr.physics.meshCollider != null && scr.physics.meshCollider is MeshCollider)
			{
				MeshCollider meshCollider = (MeshCollider)scr.physics.meshCollider;
				if (!scr.physics.rigidBody.isKinematic)
				{
					meshCollider.convex = true;
				}
			}
		}

		public IEnumerator PhysicsDataCor(RayfireRigid scr)
		{
			while (!exclude)
			{
				velocity = scr.physics.rigidBody.velocity;
				position = scr.transForm.position;
				rotation = scr.transForm.rotation;
				yield return null;
			}
		}
	}
	[Serializable]
	public class RFReferenceDemolition
	{
		[Header("  Source")]
		[Space(1f)]
		public GameObject reference;

		public List<GameObject> randomList;

		[Header("  Properties")]
		[Space(1f)]
		[Tooltip("Add RayFire Rigid component to reference with mesh")]
		public bool addRigid;

		public RFReferenceDemolition()
		{
			reference = null;
			randomList = new List<GameObject>();
			addRigid = true;
		}

		public void CopyFrom(RFReferenceDemolition referenceDemolitionDml)
		{
			reference = referenceDemolitionDml.reference;
			randomList = referenceDemolitionDml.randomList;
			addRigid = referenceDemolitionDml.addRigid;
		}

		public GameObject GetReference()
		{
			if (reference != null && randomList.Count == 0)
			{
				return reference;
			}
			List<GameObject> list = new List<GameObject>();
			if (randomList.Count > 0)
			{
				for (int i = 0; i < randomList.Count; i++)
				{
					if (randomList[i] != null)
					{
						list.Add(randomList[i]);
					}
				}
				if (list.Count > 0)
				{
					return list[UnityEngine.Random.Range(0, list.Count)];
				}
			}
			return null;
		}

		public static bool DemolishReference(RayfireRigid scr)
		{
			if (scr.demolitionType == DemolitionType.ReferenceDemolition)
			{
				GameObject gameObject = scr.referenceDemolition.GetReference();
				if (gameObject != null)
				{
					bool activeSelf = gameObject.activeSelf;
					gameObject.SetActive(value: false);
					GameObject gameObject2 = scr.InstantiateGo(gameObject);
					gameObject.SetActive(activeSelf);
					gameObject2.name = gameObject.name;
					scr.rootChild = gameObject2.transform;
					scr.rootChild.position = scr.transForm.position;
					scr.rootChild.rotation = scr.transForm.rotation;
					scr.rootChild.transform.parent = RayfireMan.inst.transForm;
					scr.fragments = new List<RayfireRigid>();
					RayfireRigid rayfireRigid = gameObject2.gameObject.GetComponent<RayfireRigid>();
					if (rayfireRigid == null && scr.referenceDemolition.addRigid)
					{
						rayfireRigid = gameObject2.gameObject.AddComponent<RayfireRigid>();
						rayfireRigid.initialization = RayfireRigid.InitType.AtStart;
						scr.CopyPropertiesTo(rayfireRigid);
						RFParticles.CopyParticles(scr, rayfireRigid);
						if (gameObject2.transform.childCount == 0)
						{
							rayfireRigid.objectType = ObjectType.Mesh;
						}
						if (gameObject2.transform.childCount > 0)
						{
							rayfireRigid.objectType = ObjectType.MeshRoot;
						}
					}
					scr.rootChild.gameObject.SetActive(value: true);
					if (rayfireRigid != null)
					{
						if (rayfireRigid.objectType == ObjectType.MeshRoot)
						{
							for (int i = 0; i < rayfireRigid.fragments.Count; i++)
							{
								rayfireRigid.fragments[i].limitations.currentDepth++;
							}
							scr.fragments.AddRange(rayfireRigid.fragments);
							scr.DestroyRigid(rayfireRigid);
						}
						else if (rayfireRigid.objectType == ObjectType.Mesh || rayfireRigid.objectType == ObjectType.SkinnedMesh)
						{
							rayfireRigid.meshDemolition.runtimeCaching.type = CachingType.Disable;
							RFDemolitionMesh.DemolishMesh(rayfireRigid);
							scr.fragments.AddRange(rayfireRigid.fragments);
							RayfireMan.DestroyFragment(rayfireRigid, rayfireRigid.rootParent, 1f);
						}
						else if (rayfireRigid.objectType == ObjectType.NestedCluster || rayfireRigid.objectType == ObjectType.ConnectedCluster)
						{
							rayfireRigid.Default();
							rayfireRigid.limitations.contactPoint = scr.limitations.contactPoint;
							RFDemolitionCluster.DemolishCluster(rayfireRigid);
							rayfireRigid.physics.exclude = true;
							scr.fragments.AddRange(rayfireRigid.fragments);
							RayfireMan.DestroyFragment(rayfireRigid, rayfireRigid.rootParent, 1f);
						}
						if (!scr.HasFragments)
						{
							scr.demolitionType = DemolitionType.None;
							return false;
						}
					}
				}
				scr.limitations.demolished = true;
			}
			return true;
		}
	}
	[Serializable]
	public class RFReset
	{
		public enum PostDemolitionType
		{
			DestroyWithDelay,
			DeactivateToReset
		}

		public enum MeshResetType
		{
			Destroy = 0,
			ReuseInputMesh = 2,
			ReuseFragmentMeshes = 4
		}

		public enum FragmentsResetType
		{
			Destroy = 0,
			Reuse = 2,
			Preserve = 4
		}

		[Header("  Reset")]
		[Space(2f)]
		public bool transform;

		public bool damage;

		[Header("  Post Demolition")]
		[Space(2f)]
		public PostDemolitionType action;

		[Range(1f, 60f)]
		public int destroyDelay;

		[Header("  Reuse")]
		[Space(2f)]
		public MeshResetType mesh;

		public FragmentsResetType fragments;

		[HideInInspector]
		public bool toBeDestroyed;

		[HideInInspector]
		public int counter;

		public RFReset()
		{
			action = PostDemolitionType.DestroyWithDelay;
			destroyDelay = 1;
			transform = true;
			damage = true;
			mesh = MeshResetType.ReuseFragmentMeshes;
			fragments = FragmentsResetType.Destroy;
			toBeDestroyed = false;
		}

		public void CopyFrom(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.MeshRoot)
			{
				action = scr.reset.action;
				transform = scr.reset.transform;
				damage = scr.reset.damage;
				mesh = scr.reset.mesh;
				fragments = scr.reset.fragments;
			}
			else
			{
				action = ((scr.reset.fragments == FragmentsResetType.Reuse) ? PostDemolitionType.DeactivateToReset : PostDemolitionType.DestroyWithDelay);
				transform = false;
				damage = false;
				mesh = MeshResetType.Destroy;
				fragments = FragmentsResetType.Destroy;
			}
			destroyDelay = scr.reset.destroyDelay;
		}

		public static void ResetRigid(RayfireRigid scr)
		{
			if (ObjectReuseState(scr))
			{
				int state = scr.fading.state;
				bool demolished = scr.limitations.demolished;
				if (scr.reset.transform)
				{
					RestoreTransform(scr);
				}
				if (scr.activation.activated)
				{
					scr.simulationType = SimType.Inactive;
				}
				Reset(scr);
				scr.StopAllCoroutines();
				if (state >= 1)
				{
					ResetFade(scr);
				}
				if (demolished)
				{
					ResetDemolition(scr);
				}
				if (!scr.gameObject.activeSelf)
				{
					scr.gameObject.SetActive(value: true);
				}
				scr.StartAllCoroutines();
			}
		}

		private static void ResetFade(RayfireRigid scr)
		{
			if (scr.fading.fadeType == FadeType.SimExclude)
			{
				scr.physics.meshCollider.enabled = true;
			}
			else if (scr.fading.fadeType == FadeType.MoveDown)
			{
				scr.physics.meshCollider.enabled = true;
				scr.gameObject.SetActive(value: true);
			}
			else if (scr.fading.fadeType == FadeType.ScaleDown)
			{
				scr.transForm.localScale = scr.physics.initScale;
				scr.gameObject.SetActive(value: true);
			}
			else if (scr.fading.fadeType == FadeType.Destroy)
			{
				scr.gameObject.SetActive(value: true);
			}
		}

		private static void ResetDemolition(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.Mesh)
			{
				if (scr.reset.mesh != MeshResetType.ReuseInputMesh)
				{
					scr.meshDemolition.rfShatter = null;
				}
				if (scr.reset.mesh != MeshResetType.ReuseFragmentMeshes)
				{
					scr.meshes = null;
				}
				if (scr.reset.fragments == FragmentsResetType.Reuse)
				{
					if (FragmentReuseState(scr))
					{
						ReuseFragments(scr);
					}
					else
					{
						DestroyFragments(scr);
					}
				}
				else if (scr.reset.fragments == FragmentsResetType.Destroy)
				{
					DestroyFragments(scr);
				}
				else if (scr.reset.fragments == FragmentsResetType.Preserve)
				{
					PreserveFragments(scr);
				}
			}
			scr.gameObject.SetActive(value: true);
		}

		private static void DestroyFragments(RayfireRigid scr)
		{
			if (!scr.HasFragments)
			{
				return;
			}
			int num = scr.fragments.Count((RayfireRigid t) => t != null);
			for (int num2 = scr.fragments.Count - 1; num2 >= 0; num2--)
			{
				if (scr.fragments[num2] != null)
				{
					RayfireMan.DestroyGo(scr.fragments[num2].gameObject);
					if (scr.fragments[num2].rootParent != null)
					{
						RayfireMan.DestroyGo(scr.fragments[num2].rootParent.gameObject);
					}
				}
			}
			scr.fragments = null;
			RayfireMan.inst.advancedDemolitionProperties.currentAmount -= num;
			if (scr.limitations.descendants.Count <= 0)
			{
				return;
			}
			int num3 = scr.limitations.descendants.Count((RayfireRigid t) => t != null);
			for (int i = 0; i < scr.limitations.descendants.Count; i++)
			{
				if (scr.limitations.descendants[i] != null)
				{
					RayfireMan.DestroyGo(scr.limitations.descendants[i].gameObject);
					if (scr.limitations.descendants[i].rootParent != null)
					{
						RayfireMan.DestroyGo(scr.limitations.descendants[i].rootParent.gameObject);
					}
				}
			}
			scr.limitations.descendants = new List<RayfireRigid>();
			RayfireMan.inst.advancedDemolitionProperties.currentAmount -= num3;
		}

		private static void ReuseFragments(RayfireRigid scr)
		{
			if (scr.rootChild != null)
			{
				scr.rootChild.gameObject.SetActive(value: false);
				scr.rootChild.position = scr.transForm.position;
				scr.rootChild.rotation = scr.transForm.rotation;
			}
			for (int num = scr.fragments.Count - 1; num >= 0; num--)
			{
				scr.fragments[num].transForm.localScale = scr.fragments[num].physics.initScale;
				scr.fragments[num].transForm.position = scr.transForm.position + scr.pivots[num];
				scr.fragments[num].transForm.rotation = UnityEngine.Quaternion.identity;
				if (scr.fragments[num].activation.activated)
				{
					scr.fragments[num].simulationType = SimType.Inactive;
				}
				if (scr.fragments[num].fading.state >= 1)
				{
					ResetFade(scr.fragments[num]);
				}
				Reset(scr.fragments[num]);
			}
			scr.limitations.descendants = new List<RayfireRigid>();
		}

		private static void PreserveFragments(RayfireRigid scr)
		{
			scr.fragments = null;
			scr.rootChild = null;
			scr.limitations.descendants = new List<RayfireRigid>();
		}

		private static bool ObjectReuseState(RayfireRigid scr)
		{
			if (scr.physics.exclude)
			{
				UnityEngine.Debug.Log("Demolished " + scr.objectType.ToString() + " reset not supported yet.");
				return false;
			}
			if (scr.objectType != 0)
			{
				return false;
			}
			return true;
		}

		private static bool FragmentReuseState(RayfireRigid scr)
		{
			if (scr.demolitionType == DemolitionType.ReferenceDemolition)
			{
				return false;
			}
			if (!scr.HasFragments)
			{
				return false;
			}
			if (scr.fragments.Any((RayfireRigid t) => t == null))
			{
				return false;
			}
			if (scr.fragments.Any((RayfireRigid t) => t.reset.toBeDestroyed))
			{
				return false;
			}
			if (scr.fragments.Any((RayfireRigid t) => t.limitations.demolished))
			{
				return false;
			}
			return true;
		}

		private static void RestoreTransform(RayfireRigid scr)
		{
			scr.transForm.localScale = scr.physics.initScale;
			scr.transForm.position = scr.physics.initPosition;
			scr.transForm.rotation = scr.physics.initRotation;
			if (scr.physics.rigidBody != null)
			{
				scr.physics.velocity = UnityEngine.Vector3.zero;
				scr.physics.rigidBody.velocity = UnityEngine.Vector3.zero;
				scr.physics.rigidBody.angularVelocity = UnityEngine.Vector3.zero;
			}
		}

		private static void Reset(RayfireRigid scr)
		{
			scr.meshDemolition.StopRuntimeCaching();
			scr.activation.Reset();
			scr.restriction.Reset();
			scr.limitations.Reset();
			scr.meshDemolition.Reset();
			scr.clusterDemolition.Reset();
			scr.fading.Reset();
			if (scr.reset.damage)
			{
				scr.damage.Reset();
			}
			RFPhysic.SetSimulationType(scr);
		}
	}
	[Serializable]
	public class RFRestriction
	{
		public enum RFBoundActionType
		{
			Fade = 2,
			Reset = 4,
			PostDemolitionAction = 9
		}

		public enum RFDistanceType
		{
			InitializePosition = 0,
			TargetPosition = 2
		}

		public enum RFBoundTriggerType
		{
			Inside = 0,
			Outside = 2
		}

		[Header("  Properties")]
		[Space(3f)]
		public bool enable;

		[Space(1f)]
		public RFBoundActionType breakAction;

		[Space(1f)]
		[Range(0f, 60f)]
		public float actionDelay;

		[Range(0.1f, 60f)]
		public float checkInterval;

		[Header("  Distance Restriction")]
		[Space(3f)]
		[Range(0f, 99f)]
		public float distance;

		[Space(1f)]
		public RFDistanceType position;

		[Space(1f)]
		public Transform target;

		[Header("  Trigger Restriction")]
		[Space(3f)]
		public Collider collider;

		[Space(1f)]
		public RFBoundTriggerType region;

		[HideInInspector]
		public bool broke;

		public RFRestriction()
		{
			enable = false;
			checkInterval = 5f;
			breakAction = RFBoundActionType.PostDemolitionAction;
			distance = 30f;
			position = RFDistanceType.InitializePosition;
			target = null;
			collider = null;
			region = RFBoundTriggerType.Inside;
			Reset();
		}

		public void CopyFrom(RFRestriction rest)
		{
			enable = rest.enable;
			checkInterval = rest.checkInterval;
			breakAction = rest.breakAction;
			distance = rest.distance;
			position = rest.position;
			target = rest.target;
			collider = rest.collider;
			region = rest.region;
			Reset();
		}

		public void Reset()
		{
			broke = false;
		}

		public static void InitRestriction(RayfireRigid scr)
		{
			if (!scr.restriction.enable || scr.restriction.broke)
			{
				return;
			}
			if (scr.restriction.distance > 0f)
			{
				if (scr.restriction.position == RFDistanceType.InitializePosition)
				{
					scr.StartCoroutine(RestrictionDistanceCor(scr));
				}
				else if (scr.restriction.target != null)
				{
					scr.StartCoroutine(RestrictionDistanceCor(scr));
				}
				else
				{
					UnityEngine.Debug.Log("Target is not defined", scr.gameObject);
				}
			}
			if (scr.restriction.collider != null)
			{
				if (!scr.restriction.collider.isTrigger)
				{
					UnityEngine.Debug.Log("Collider is not trigger", scr.gameObject);
				}
				scr.StartCoroutine(RestrictionTriggerCor(scr));
			}
		}

		private static void BrokeRestriction(RayfireRigid scr)
		{
			scr.restriction.broke = true;
			scr.restrictionEvent.InvokeLocalEvent(scr);
			RFRestrictionEvent.InvokeGlobalEvent(scr);
			if (scr.restriction.breakAction == RFBoundActionType.PostDemolitionAction)
			{
				RayfireMan.DestroyFragment(scr, scr.rootParent);
			}
			else if (scr.restriction.breakAction == RFBoundActionType.Fade)
			{
				RFFade.Fade(scr);
			}
			else if (scr.restriction.breakAction == RFBoundActionType.Reset)
			{
				RFReset.ResetRigid(scr);
			}
		}

		private static IEnumerator RestrictionDistanceCor(RayfireRigid scr)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.2f));
			WaitForSeconds intervalDelay = new WaitForSeconds(scr.restriction.checkInterval);
			WaitForSeconds actionDelay = new WaitForSeconds(scr.restriction.actionDelay);
			UnityEngine.Vector3 checkPosition = scr.physics.initPosition;
			while (!scr.restriction.broke)
			{
				yield return intervalDelay;
				if (scr.restriction.position == RFDistanceType.TargetPosition && scr.restriction.target != null)
				{
					checkPosition = scr.restriction.target.position;
				}
				if (UnityEngine.Vector3.Distance(checkPosition, scr.transForm.position) > scr.restriction.distance)
				{
					if (scr.restriction.actionDelay > 0f)
					{
						yield return actionDelay;
					}
					BrokeRestriction(scr);
				}
			}
		}

		private static IEnumerator RestrictionTriggerCor(RayfireRigid scr)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.2f));
			WaitForSeconds intervalDelay = new WaitForSeconds(scr.restriction.checkInterval);
			WaitForSeconds actionDelay = new WaitForSeconds(scr.restriction.actionDelay);
			bool brokeState = false;
			while (!scr.restriction.broke)
			{
				yield return intervalDelay;
				if (scr.restriction.collider == null)
				{
					break;
				}
				UnityEngine.Vector3 direction;
				float num;
				bool flag = Physics.ComputePenetration(scr.restriction.collider, scr.restriction.collider.transform.position, scr.restriction.collider.transform.rotation, scr.physics.meshCollider, scr.transForm.position, scr.transForm.rotation, out direction, out num);
				if (!flag && scr.restriction.region == RFBoundTriggerType.Inside)
				{
					brokeState = true;
				}
				else if (flag && scr.restriction.region == RFBoundTriggerType.Outside)
				{
					brokeState = true;
				}
				if (brokeState)
				{
					if (scr.restriction.actionDelay > 0f)
					{
						yield return actionDelay;
					}
					BrokeRestriction(scr);
				}
			}
		}
	}
	[Serializable]
	public class RFRuntimeCaching
	{
		public CachingType type;

		[Range(2f, 300f)]
		public int frames;

		[Range(1f, 20f)]
		public int fragments;

		public bool skipFirstDemolition;

		[HideInInspector]
		public bool inProgress;

		[HideInInspector]
		public bool wasUsed;

		[HideInInspector]
		public bool stop;

		public RFRuntimeCaching()
		{
			type = CachingType.Disable;
			frames = 3;
			fragments = 4;
			skipFirstDemolition = false;
			inProgress = false;
			wasUsed = false;
			stop = false;
		}

		public static List<int> GetBatchByFrames(int frames, int amount)
		{
			int item = amount / frames;
			List<int> list = new List<int>();
			for (int i = 0; i < frames; i++)
			{
				list.Add(item);
			}
			int num = amount % frames;
			if (num > 0)
			{
				for (int j = 0; j < num; j++)
				{
					list[j]++;
				}
			}
			if (frames > amount)
			{
				for (int num2 = list.Count - 1; num2 >= 0; num2--)
				{
					if (list[num2] == 0)
					{
						list.RemoveAt(num2);
					}
				}
			}
			return list;
		}

		public static List<int> GetBatchByFragments(int fragments, int amount)
		{
			int num = amount / fragments;
			List<int> list = new List<int>();
			if (num > 0)
			{
				for (int i = 0; i < num; i++)
				{
					list.Add(fragments);
				}
			}
			int num2 = amount % fragments;
			if (num2 > 0)
			{
				list.Add(num2);
			}
			return list;
		}

		public static List<int> GetMarkedElements(int batchInd, List<int> batchAmount)
		{
			int num = 0;
			if (batchInd > 0)
			{
				for (int i = 0; i < batchInd; i++)
				{
					num += batchAmount[i];
				}
			}
			List<int> list = new List<int>();
			for (int j = 0; j < batchAmount[batchInd]; j++)
			{
				list.Add(j + num);
			}
			return list;
		}

		public static GameObject CreateTmRef(RayfireRigid rfScr)
		{
			GameObject gameObject = new GameObject("RFTempGo");
			gameObject.SetActive(value: false);
			gameObject.transform.position = rfScr.transForm.position;
			gameObject.transform.rotation = rfScr.transForm.rotation;
			gameObject.transform.localScale = rfScr.transForm.localScale;
			gameObject.transform.parent = RayfireMan.inst.transform;
			return gameObject;
		}
	}
	[Serializable]
	public class RFShard : IComparable<RFShard>
	{
		public int id;

		public Transform tm;

		[HideInInspector]
		public Bounds bound;

		[HideInInspector]
		public float dist = -1f;

		[HideInInspector]
		public List<float> neibArea;

		[HideInInspector]
		public List<float> neibPerc;

		[NonSerialized]
		public RFCluster cluster;

		[NonSerialized]
		public List<RFShard> neibShards;

		[NonSerialized]
		private List<RFTriangle> tris;

		[NonSerialized]
		public RayfireRigid rigid;

		public RFShard(Transform Tm, int Id)
		{
			tm = Tm;
			id = Id;
			Renderer component = Tm.GetComponent<Renderer>();
			if (component != null)
			{
				bound = component.bounds;
			}
		}

		public int CompareTo(RFShard otherShard)
		{
			float magnitude = bound.size.magnitude;
			float magnitude2 = otherShard.bound.size.magnitude;
			if (magnitude > magnitude2)
			{
				return -1;
			}
			if (magnitude < magnitude2)
			{
				return 1;
			}
			return 0;
		}

		public static List<RFShard> GetShards(Transform tm, ConnectivityType connectivity)
		{
			List<Transform> list = new List<Transform>();
			for (int i = 0; i < tm.childCount; i++)
			{
				list.Add(tm.GetChild(i));
			}
			return GetShards(list, connectivity);
		}

		public static List<RFShard> GetShards(List<RayfireRigid> rigidList, ConnectivityType connectivity)
		{
			List<RFShard> list = new List<RFShard>();
			for (int i = 0; i < rigidList.Count; i++)
			{
				MeshFilter component = rigidList[i].GetComponent<MeshFilter>();
				if (!(component == null))
				{
					RFShard rFShard = new RFShard(rigidList[i].transform, i);
					rFShard.rigid = rigidList[i];
					if (connectivity == ConnectivityType.ByMesh)
					{
						rFShard.tris = RFTriangle.SetTriangles(rFShard.tm, component);
					}
					list.Add(rFShard);
				}
			}
			return list;
		}

		private static List<RFShard> GetShards(List<Transform> tmList, ConnectivityType connectivity)
		{
			List<RFShard> list = new List<RFShard>();
			for (int i = 0; i < tmList.Count; i++)
			{
				MeshFilter component = tmList[i].GetComponent<MeshFilter>();
				if (!(component == null))
				{
					RFShard rFShard = new RFShard(tmList[i], i);
					if (connectivity == ConnectivityType.ByMesh)
					{
						rFShard.tris = RFTriangle.SetTriangles(rFShard.tm, component);
					}
					list.Add(rFShard);
				}
			}
			return list;
		}

		private bool TrisNeib(RFShard otherShard)
		{
			foreach (RFTriangle tri in tris)
			{
				foreach (RFTriangle tri2 in otherShard.tris)
				{
					if (Mathf.Abs(tri.area - tri2.area) < 0.001f && UnityEngine.Vector3.Distance(tri.pos, tri2.pos) < 0.02f)
					{
						return true;
					}
				}
			}
			return false;
		}

		private float NeibArea(RFShard otherShard)
		{
			float num = 0f;
			foreach (RFTriangle tri in tris)
			{
				foreach (RFTriangle tri2 in otherShard.tris)
				{
					if (Mathf.Abs(tri.area - tri2.area) < 0.001f && UnityEngine.Vector3.Distance(tri.pos, tri2.pos) < 0.02f)
					{
						num += tri.area;
					}
				}
			}
			return num;
		}

		public int GetNeibIndArea(List<RFShard> shardList = null)
		{
			float num = 0f;
			int result = 0;
			for (int i = 0; i < neibShards.Count; i++)
			{
				if ((shardList == null || shardList.Contains(neibShards[i])) && neibArea[i] > num)
				{
					num = neibArea[i];
					result = i;
				}
			}
			if (num > 0f)
			{
				return result;
			}
			return -1;
		}

		public static void SetShardNeibs(List<RFShard> shards, ConnectivityType connectivity)
		{
			foreach (RFShard shard in shards)
			{
				shard.neibShards = new List<RFShard>();
				shard.neibArea = new List<float>();
				shard.neibPerc = new List<float>();
			}
			for (int i = 0; i < shards.Count; i++)
			{
				for (int j = 0; j < shards.Count; j++)
				{
					if (j != i && !shards[j].neibShards.Contains(shards[i]) && shards[i].bound.Intersects(shards[j].bound))
					{
						if (connectivity == ConnectivityType.ByBoundingBox)
						{
							float magnitude = shards[i].bound.size.magnitude;
							shards[i].neibShards.Add(shards[j]);
							shards[i].neibArea.Add(magnitude);
							shards[j].neibShards.Add(shards[i]);
							shards[j].neibArea.Add(magnitude);
						}
						else if (shards[i].TrisNeib(shards[j]))
						{
							float item = shards[i].NeibArea(shards[j]);
							shards[i].neibShards.Add(shards[j]);
							shards[i].neibArea.Add(item);
							shards[j].neibShards.Add(shards[i]);
							shards[j].neibArea.Add(item);
						}
					}
				}
				float num = Mathf.Max(shards[i].neibArea.ToArray());
				foreach (float item2 in shards[i].neibArea)
				{
					if (num > 0f)
					{
						shards[i].neibPerc.Add(item2 / num);
					}
					else
					{
						shards[i].neibPerc.Add(0f);
					}
				}
			}
		}

		public static RFShard GetNeibShardArea(List<RFShard> shardGroup, List<RFShard> shardList)
		{
			if (shardList.Count == 0)
			{
				return null;
			}
			List<RFShard> list = new List<RFShard>();
			float num = 0f;
			RFShard result = null;
			foreach (RFShard item in shardGroup)
			{
				for (int i = 0; i < item.neibShards.Count; i++)
				{
					if (!(item.neibPerc[i] < 0.6f) && !(num >= item.neibArea[i]) && !list.Contains(item.neibShards[i]) && shardList.Contains(item.neibShards[i]))
					{
						list.Add(item.neibShards[i]);
						num = item.neibArea[i];
						result = item.neibShards[i];
					}
				}
			}
			list = null;
			return result;
		}
	}
	[Serializable]
	public class RFMeshExport
	{
		public enum MeshExportType
		{
			LastFragments = 0,
			Children = 3
		}

		public MeshExportType source;

		public string suffix = "_frags";
	}
	[Serializable]
	public class RFShatterAdvanced
	{
		[Header("  Common")]
		[Space(2f)]
		[Range(0f, 100f)]
		public int seed;

		public bool decompose;

		public bool removeCollinear;

		public bool copyComponents;

		[Header("  Editor Mode")]
		[Space(2f)]
		[Tooltip("Create extra triangles to connect open edges and close mesh volume.")]
		public bool inputPrecap;

		[Tooltip("Keep or Delete fragment's faces created by Input Precap.")]
		public bool outputPrecap;

		[Tooltip("Delete faces which overlap with each other.")]
		public bool removeDoubleFaces;

		[Tooltip("Delete all inner fragments which has no outer surface.")]
		public bool excludeInnerFragments;

		[Tooltip("Measures in percents relative to original object size. Do not fragment elements with size less than this value.")]
		[Range(1f, 100f)]
		public int elementSizeThreshold;

		public RFShatterAdvanced()
		{
			seed = 1;
			decompose = false;
			removeCollinear = true;
			copyComponents = false;
			inputPrecap = true;
			outputPrecap = false;
			removeDoubleFaces = true;
			excludeInnerFragments = false;
			elementSizeThreshold = 5;
		}
	}
	[Serializable]
	public class RFSound
	{
		public float multiplier = 1f;

		public bool cameraCheck = true;

		public bool playOnCollision;

		public List<RFCollisionAudio> collisions;

		public bool playOnDemolition = true;

		public List<RFDemolitionAudio> demolition;

		public float minSize;

		public float minDistanceToCamera;
	}
	[Serializable]
	public class RFCollisionAudio
	{
		public bool byMaterial;

		public MaterialType collisionMaterial;

		public float collisionStrength;

		public float volume;

		public float range;

		public AudioClip clip;
	}
	[Serializable]
	public class RFDemolitionAudio
	{
		public float size;

		public int amount;

		public float volume;

		public float range;

		public AudioClip clip;
	}
	[Serializable]
	public class RFSurface
	{
		[Header("  Inner surface")]
		[Space(1f)]
		[Tooltip("Defines material for fragment's inner surface.")]
		public Material innerMaterial;

		[Space(1f)]
		[Tooltip("Defines mapping scale for inner surface.")]
		[Range(0.01f, 2f)]
		public float mappingScale;

		[Header("  Outer surface")]
		[Space(1f)]
		public Material outerMaterial;

		[HideInInspector]
		public bool needNewMat;

		public RFSurface()
		{
			innerMaterial = null;
			mappingScale = 0.1f;
			needNewMat = false;
			outerMaterial = null;
		}

		public void CopyFrom(RFSurface interior)
		{
			innerMaterial = interior.innerMaterial;
			mappingScale = interior.mappingScale;
			needNewMat = interior.needNewMat;
			outerMaterial = interior.outerMaterial;
		}

		public static void SetMaterial(List<RFDictionary> origSubMeshIdsRF, Material[] sharedMaterials, RFSurface interior, MeshRenderer targetRend, int i, int amount)
		{
			if (origSubMeshIdsRF == null || origSubMeshIdsRF.Count != amount)
			{
				return;
			}
			Material[] array = new Material[origSubMeshIdsRF[i].values.Count];
			if (interior.outerMaterial != null)
			{
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = interior.outerMaterial;
				}
			}
			else
			{
				for (int k = 0; k < origSubMeshIdsRF[i].values.Count; k++)
				{
					int num = origSubMeshIdsRF[i].values[k];
					if (num < sharedMaterials.Length)
					{
						array[k] = sharedMaterials[num];
					}
					else
					{
						array[k] = interior.innerMaterial;
					}
				}
			}
			targetRend.sharedMaterials = array;
		}

		public static int SetInnerSubId(RayfireRigid scr)
		{
			if (scr.materials.innerMaterial == null)
			{
				return 0;
			}
			Material[] array = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == scr.materials.innerMaterial)
				{
					return i;
				}
			}
			return -1;
		}

		public static int SetInnerSubId(RayfireShatter scr)
		{
			if (scr.material.innerMaterial == null)
			{
				return 0;
			}
			Material[] array = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == scr.material.innerMaterial)
				{
					return i;
				}
			}
			return -1;
		}
	}
	public enum AxisType
	{
		XRed,
		YGreen,
		ZBlue
	}
	public enum PlaneType
	{
		XY,
		XZ,
		YZ
	}
	public enum FragType
	{
		Voronoi = 0,
		Splinters = 1,
		Slabs = 2,
		Radial = 3,
		Custom = 5,
		Slices = 7,
		Tets = 11,
		Decompose = 15
	}
	public enum DemolitionType
	{
		None = 0,
		Runtime = 1,
		AwakePrecache = 2,
		AwakePrefragment = 3,
		ManualPrefabPrecache = 4,
		ManualPrecache = 5,
		ManualPrefragment = 6,
		ReferenceDemolition = 9
	}
	public enum CachingType
	{
		Disable,
		ByFrames,
		ByFragmentsPerFrame
	}
	public enum FadeType
	{
		None = 0,
		SimExclude = 1,
		MoveDown = 2,
		ScaleDown = 3,
		Destroy = 5
	}
	public enum MaterialType
	{
		HeavyMetal,
		LightMetal,
		DenseRock,
		PorousRock,
		Concrete,
		Brick,
		Glass,
		Rubber,
		Ice,
		Wood
	}
	public enum MassType
	{
		MaterialDensity,
		MassProperty
	}
	public enum ObjectType
	{
		Mesh = 0,
		MeshRoot = 1,
		SkinnedMesh = 2,
		NestedCluster = 4,
		ConnectedCluster = 5
	}
	public enum SimType
	{
		Dynamic,
		Sleeping,
		Inactive,
		Kinematic,
		Static
	}
	public enum ConnectivityType
	{
		ByBoundingBox,
		ByMesh
	}
	public enum FragmentMode
	{
		Runtime,
		Editor
	}
	public enum RFColliderType
	{
		Mesh = 0,
		Box = 1,
		Sphere = 2,
		None = 4
	}
	public class RFFrag
	{
		public Mesh mesh;

		public UnityEngine.Vector3 pivot;

		public RFDictionary subId;

		public RayfireRigid fragment;
	}
	public class RFTri
	{
		public int meshId;

		public int subMeshId = -1;

		public List<int> ids = new List<int>();

		public List<UnityEngine.Vector3> vpos = new List<UnityEngine.Vector3>();

		public List<UnityEngine.Vector3> vnormal = new List<UnityEngine.Vector3>();

		public List<UnityEngine.Vector2> uvs = new List<UnityEngine.Vector2>();

		public List<UnityEngine.Vector4> tangents = new List<UnityEngine.Vector4>();

		public List<RFTri> neibTris = new List<RFTri>();
	}
	[Serializable]
	public class RFDictionary
	{
		public List<int> keys;

		public List<int> values;

		public RFDictionary(Dictionary<int, int> dictionary)
		{
			keys = new List<int>();
			values = new List<int>();
			keys = dictionary.Keys.ToList();
			values = dictionary.Values.ToList();
		}
	}
	[Serializable]
	public class RFShatterCluster
	{
		[Header("  Main")]
		[Space(2f)]
		public bool enable;

		[Tooltip("Amount of clusters defined by random point cloud.")]
		[Range(2f, 200f)]
		public int count;

		[Tooltip("Random seed for clusters point cloud generator.")]
		[Range(0f, 100f)]
		public int seed;

		[Tooltip("Smooth strength for cluster inner surface.")]
		[Range(0f, 1f)]
		public float relax;

		[Header("  Debris")]
		[Space(2f)]
		[Tooltip("Amount of debris in last layer in percents relative to amount of fragments in cluster.")]
		[Range(0f, 100f)]
		public int amount;

		[Tooltip("Amount of debris layers at cluster border.")]
		[Range(0f, 5f)]
		public int layers;

		[Tooltip("Scale variation for inner debris.")]
		[Range(0.1f, 1f)]
		public float scale;

		[Tooltip("Minimum amount of fragments in debris cluster.")]
		[Range(1f, 20f)]
		public int min;

		[Tooltip("Maximum amount of fragments in debris cluster.")]
		[Range(1f, 20f)]
		public int max;

		public RFShatterCluster()
		{
			enable = false;
			count = 10;
			seed = 1;
			relax = 0.5f;
			layers = 0;
			amount = 0;
			scale = 1f;
			min = 1;
			max = 3;
		}
	}
	[Serializable]
	public class RFVoronoi
	{
		public int amount = 30;

		[Range(0f, 1f)]
		public float centerBias;

		public int Amount
		{
			get
			{
				if (amount < 1)
				{
					return 1;
				}
				if (amount > 20000)
				{
					return 2;
				}
				return amount;
			}
		}
	}
	[Serializable]
	public class RFSplinters
	{
		public AxisType axis = AxisType.YGreen;

		public int amount = 30;

		[Range(0f, 1f)]
		public float strength = 0.7f;

		[Range(0f, 1f)]
		public float centerBias;

		public int Amount
		{
			get
			{
				if (amount < 2)
				{
					return 2;
				}
				if (amount > 20000)
				{
					return 2;
				}
				return amount;
			}
		}
	}
	[Serializable]
	public class RFRadial
	{
		[Header("  Common")]
		[Space(2f)]
		public AxisType centerAxis = AxisType.YGreen;

		[Range(0.01f, 30f)]
		public float radius = 1f;

		[Range(0f, 1f)]
		public float divergence = 1f;

		public bool restrictToPlane = true;

		[Header("  Rings")]
		[Space(2f)]
		[Range(3f, 60f)]
		public int rings = 10;

		[Range(0f, 100f)]
		public int focus;

		[Range(0f, 100f)]
		public int focusStr = 50;

		[Range(0f, 100f)]
		public int randomRings = 50;

		[Header("  Rays")]
		[Space(2f)]
		[Range(3f, 60f)]
		public int rays = 10;

		[Range(0f, 100f)]
		public int randomRays;

		[Range(-90f, 90f)]
		public int twist;
	}
	[Serializable]
	public class RFSlice
	{
		public PlaneType plane = PlaneType.XZ;

		public List<Transform> sliceList;

		public UnityEngine.Vector3 Axis(Transform tm)
		{
			if (plane == PlaneType.YZ)
			{
				return tm.right;
			}
			if (plane == PlaneType.XZ)
			{
				return tm.up;
			}
			return tm.forward;
		}
	}
	[Serializable]
	public class RFTets
	{
		public enum TetType
		{
			Uniform,
			Curved
		}

		[HideInInspector]
		public TetType lattice;

		[Range(1f, 30f)]
		public int density = 7;

		[Range(0f, 100f)]
		public int noise = 100;
	}
	[AddComponentMenu("RayFire/Rayfire Activator")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-activator-component/")]
	public class RayfireActivator : MonoBehaviour
	{
		public enum ActivationType
		{
			OnEnter,
			OnExit
		}

		public enum AnimationType
		{
			ByPositionList,
			ByStaticLine,
			ByDynamicLine
		}

		public enum GizmoType
		{
			Sphere,
			Box,
			Collider
		}

		[Header("  Gizmo")]
		[Space(2f)]
		public bool showGizmo = true;

		public GizmoType gizmoType;

		[Range(0.1f, 100f)]
		public float sphereRadius = 5f;

		public UnityEngine.Vector3 boxSize = new UnityEngine.Vector3(5f, 2f, 5f);

		[Header("  Activation")]
		[Space(2f)]
		public ActivationType type;

		[Range(0f, 100f)]
		public float delay;

		[Header("  Animation")]
		[Space(2f)]
		[Range(0.1f, 100f)]
		public float duration = 3f;

		[Range(1f, 50f)]
		public float scaleAnimation = 1f;

		public AnimationType positionAnimation;

		public LineRenderer line;

		public List<UnityEngine.Vector3> positionList;

		private bool animating;

		private float pathRatio;

		private float lineLength;

		private List<float> checkpoints = new List<float>();

		private float delta;

		private float deltaRatioStep;

		private float distDeltaStep;

		private float distRatio;

		private float timePassed;

		private int activeSegment;

		private UnityEngine.Vector3 positionStart;

		private UnityEngine.Vector3 scaleStart;

		private void Awake()
		{
			ColliderCheck();
			positionStart = base.transform.position;
			scaleStart = base.transform.localScale;
		}

		private void OnTriggerEnter(Collider coll)
		{
			if (type == ActivationType.OnEnter)
			{
				ActivationCheck(coll);
			}
		}

		private void OnTriggerExit(Collider coll)
		{
			if (type == ActivationType.OnExit)
			{
				ActivationCheck(coll);
			}
		}

		private void ActivationCheck(Collider coll)
		{
			RayfireRigid component = coll.gameObject.GetComponent<RayfireRigid>();
			if (component != null && component.activation.byActivator && (component.simulationType == SimType.Inactive || component.simulationType == SimType.Kinematic))
			{
				if (delay <= 0f)
				{
					component.Activate();
				}
				else
				{
					StartCoroutine(DelayedActivationCor(component));
				}
			}
		}

		private IEnumerator DelayedActivationCor(RayfireRigid scrRigid)
		{
			yield return new WaitForSeconds(delay);
			if (scrRigid != null)
			{
				scrRigid.Activate();
			}
		}

		private void ColliderCheck()
		{
			if (gizmoType == GizmoType.Sphere)
			{
				SphereCollider sphereCollider = base.gameObject.AddComponent<SphereCollider>();
				sphereCollider.isTrigger = true;
				sphereCollider.radius = sphereRadius;
			}
			if (gizmoType == GizmoType.Box)
			{
				BoxCollider boxCollider = base.gameObject.AddComponent<BoxCollider>();
				boxCollider.isTrigger = true;
				boxCollider.size = boxSize;
			}
			if (gizmoType == GizmoType.Collider)
			{
				Collider[] components = GetComponents<Collider>();
				if (components.Length == 0)
				{
					UnityEngine.Debug.Log(base.gameObject.name + " has no activation collider", base.gameObject);
				}
				Collider[] array = components;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].isTrigger = true;
				}
			}
		}

		public void TriggerAnimation()
		{
			if (!animating)
			{
				SetAnimation();
				if (positionList.Count < 2 && scaleAnimation == 1f)
				{
					UnityEngine.Debug.Log("Position list is empty and scale is not animated");
				}
				else
				{
					StartCoroutine(AnimationCor());
				}
			}
		}

		private void SetAnimation()
		{
			if (positionAnimation == AnimationType.ByStaticLine || positionAnimation == AnimationType.ByDynamicLine)
			{
				SetWorldPointsByLine();
			}
			SetCheckPoints();
		}

		private void SetWorldPointsByLine()
		{
			if (line == null)
			{
				UnityEngine.Debug.Log("Path line is not defined");
				return;
			}
			positionList = new List<UnityEngine.Vector3>();
			for (int i = 0; i < line.positionCount; i++)
			{
				positionList.Add(line.transform.TransformPoint(line.GetPosition(i)));
			}
			if (line.loop)
			{
				positionList.Add(positionList[0]);
			}
		}

		private void SetCheckPoints()
		{
			if (positionList.Count < 2)
			{
				return;
			}
			lineLength = 0f;
			List<float> list = new List<float>();
			if (positionList.Count >= 2)
			{
				for (int i = 0; i < positionList.Count - 1; i++)
				{
					float num = UnityEngine.Vector3.Distance(positionList[i], positionList[i + 1]);
					list.Add(num);
					lineLength += num;
				}
			}
			float num2 = 0f;
			checkpoints = new List<float>();
			for (int j = 0; j < list.Count; j++)
			{
				float num3 = list[j] / lineLength * 100f;
				checkpoints.Add(num2);
				num2 += num3;
			}
			checkpoints.Add(100f);
		}

		private IEnumerator AnimationCor()
		{
			if (animating)
			{
				yield break;
			}
			animating = true;
			if (positionList.Count >= 2)
			{
				base.transform.position = positionList[0];
			}
			while (timePassed < duration)
			{
				if (!animating)
				{
					yield break;
				}
				if (positionAnimation == AnimationType.ByDynamicLine)
				{
					SetAnimation();
				}
				delta = Time.deltaTime;
				timePassed += delta;
				if (positionList.Count >= 2)
				{
					deltaRatioStep = delta / duration;
					distDeltaStep = lineLength * deltaRatioStep;
					distRatio = distDeltaStep / lineLength * 100f;
					pathRatio += distRatio;
					activeSegment = GetSegment(pathRatio);
					float t = (checkpoints[activeSegment + 1] - pathRatio) / (checkpoints[activeSegment + 1] - checkpoints[activeSegment]);
					UnityEngine.Vector3 position = UnityEngine.Vector3.Lerp(positionList[activeSegment + 1], positionList[activeSegment], t);
					base.transform.position = position;
				}
				if (scaleAnimation > 1f)
				{
					float t2 = timePassed / duration;
					UnityEngine.Vector3 localScale = UnityEngine.Vector3.Lerp(b: new UnityEngine.Vector3(scaleAnimation, scaleAnimation, scaleAnimation), a: scaleStart, t: t2);
					base.transform.localScale = localScale;
				}
				yield return null;
			}
			ResetData();
		}

		private int GetSegment(float ration)
		{
			if (checkpoints.Count > 2)
			{
				for (int i = 0; i < checkpoints.Count - 1; i++)
				{
					if (ration > checkpoints[i] && ration < checkpoints[i + 1])
					{
						return i;
					}
				}
				return checkpoints.Count - 2;
			}
			return 0;
		}

		private void ResetData()
		{
			animating = false;
			pathRatio = 0f;
			lineLength = 0f;
			checkpoints.Clear();
			delta = 0f;
			deltaRatioStep = 0f;
			distDeltaStep = 0f;
			distRatio = 0f;
			timePassed = 0f;
			activeSegment = 0;
		}

		public void StopAnimation()
		{
			animating = false;
		}

		public void ResetAnimation()
		{
			ResetData();
			base.transform.position = positionStart;
		}

		public void AddPosition(UnityEngine.Vector3 newPos)
		{
			if (positionList == null)
			{
				positionList = new List<UnityEngine.Vector3>();
			}
			if (positionList.Count > 0 && newPos == positionList[positionList.Count - 1])
			{
				UnityEngine.Debug.Log("Activator at the same position");
			}
			else if (positionList.Count == 0 || newPos != positionList[positionList.Count - 1])
			{
				positionList.Add(newPos);
			}
		}
	}
	[AddComponentMenu("RayFire/Rayfire Blade")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-blade-component/")]
	public class RayfireBlade : MonoBehaviour
	{
		public enum CutType
		{
			Enter,
			Exit,
			EnterExit
		}

		public enum ActionType
		{
			Slice,
			Demolish
		}

		[Header("  Properties")]
		[Space(2f)]
		public ActionType actionType;

		public CutType onTrigger = CutType.Exit;

		[Header("  Slicing")]
		[Space(2f)]
		public PlaneType sliceType;

		[HideInInspector]
		public UnityEngine.Vector3[] enterPlane;

		[HideInInspector]
		public UnityEngine.Vector3[] exitPlane;

		[HideInInspector]
		public Collider colLider;

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		public RFSliceEvent sliceEvent = new RFSliceEvent();

		private void Awake()
		{
			DefineComponents();
		}

		private void OnTriggerEnter(Collider col)
		{
			TriggerEnter(col);
			MonoBehaviour.print("enter");
		}

		private void OnTriggerExit(Collider col)
		{
			TriggerExit(col);
			MonoBehaviour.print("exit");
		}

		private void TriggerEnter(Collider col)
		{
			if (onTrigger == CutType.Enter)
			{
				if (actionType == ActionType.Slice)
				{
					Slice(col.gameObject, GetSlicePlane());
				}
				else
				{
					Demolish(col.gameObject);
				}
			}
			else if (onTrigger == CutType.EnterExit && actionType == ActionType.Slice)
			{
				enterPlane = GetSlicePlane();
			}
		}

		private void TriggerExit(Collider col)
		{
			if (onTrigger == CutType.Exit)
			{
				if (actionType == ActionType.Slice)
				{
					Slice(col.gameObject, GetSlicePlane());
				}
				else
				{
					Demolish(col.gameObject);
				}
			}
			else if (onTrigger == CutType.EnterExit)
			{
				if (actionType == ActionType.Slice)
				{
					exitPlane = GetSlicePlane();
					Slice(slicePlane: new UnityEngine.Vector3[2]
					{
						(enterPlane[0] + exitPlane[0]) / 2f,
						(enterPlane[1] + exitPlane[1]) / 2f
					}, targetObject: col.gameObject);
				}
				else
				{
					Demolish(col.gameObject);
				}
			}
		}

		private void Demolish(GameObject targetObject)
		{
			if ((!(tagFilter != "Untagged") || !(targetObject.tag != tagFilter)) && LayerCheck(targetObject.layer))
			{
				RayfireRigid component = targetObject.GetComponent<RayfireRigid>();
				if (!(component == null) && component.demolitionType != 0 && component.State())
				{
					component.Demolish();
				}
			}
		}

		private void Slice(GameObject targetObject, UnityEngine.Vector3[] slicePlane)
		{
			if ((!(tagFilter != "Untagged") || !(targetObject.tag != tagFilter)) && LayerCheck(targetObject.layer))
			{
				RayfireRigid component = targetObject.GetComponent<RayfireRigid>();
				if (!(component == null) && component.demolitionType != 0 && component.limitations.sliceByBlade && component.State())
				{
					component.AddSlicePlane(slicePlane);
					sliceEvent.InvokeLocalEvent(this);
					RFSliceEvent.InvokeGlobalEvent(this);
				}
			}
		}

		private UnityEngine.Vector3[] GetSlicePlane()
		{
			UnityEngine.Vector3[] array = new UnityEngine.Vector3[2]
			{
				base.transform.position,
				default(UnityEngine.Vector3)
			};
			if (sliceType == PlaneType.XY)
			{
				array[1] = base.transform.forward;
			}
			else if (sliceType == PlaneType.XZ)
			{
				array[1] = base.transform.up;
			}
			else if (sliceType == PlaneType.YZ)
			{
				array[1] = base.transform.right;
			}
			return array;
		}

		private bool LayerCheck(int layerId)
		{
			return mask == (mask | (1 << layerId));
		}

		private void DefineComponents()
		{
			colLider = GetComponent<Collider>();
			if (colLider == null)
			{
				colLider = base.gameObject.AddComponent<MeshCollider>();
				((MeshCollider)colLider).convex = true;
			}
			colLider.isTrigger = true;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Bomb")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-bomb-component/")]
	public class RayfireBomb : MonoBehaviour
	{
		public enum RangeType
		{
			Spherical
		}

		public enum FadeType
		{
			Linear,
			Exponential,
			None
		}

		[Serializable]
		public class Projectile
		{
			public UnityEngine.Vector3 positionPivot;

			public UnityEngine.Vector3 positionClosest;

			public float fade;

			public Rigidbody rb;

			public RayfireRigid scrRigid;

			public UnityEngine.Quaternion rotation;
		}

		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public UnityEngine.Vector3 bombPosition;

		[HideInInspector]
		public UnityEngine.Vector3 explPosition;

		[HideInInspector]
		public Collider[] colliders;

		[HideInInspector]
		public List<Projectile> projectiles = new List<Projectile>();

		[HideInInspector]
		public List<Rigidbody> rigidbodies = new List<Rigidbody>();

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		[Header("  Range")]
		public RangeType rangeType;

		public FadeType fadeType;

		public float range = 5f;

		[Header("  Impulse")]
		[Range(0f, 10f)]
		public float strength = 1f;

		[Range(0f, 100f)]
		public int variation = 50;

		[Range(0f, 90f)]
		public int chaos = 30;

		public bool forceByMass = true;

		public bool affectKinematic;

		[Header("  Detonation")]
		public float heightOffset;

		public float delay;

		[Header("  Damage")]
		public bool applyDamage = true;

		public float damageValue = 1f;

		[Header("  Audio")]
		public bool play;

		[Range(0.01f, 30f)]
		public float volume = 1f;

		public AudioClip clip;

		public RFExplosionEvent explosionEvent = new RFExplosionEvent();

		private void Awake()
		{
			DefineComponents();
			ClearLists();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
		}

		public void CopyFrom(RayfireBomb scr)
		{
			rangeType = scr.rangeType;
			fadeType = scr.fadeType;
			range = scr.range;
			strength = scr.strength;
			variation = scr.variation;
			chaos = scr.chaos;
			forceByMass = scr.forceByMass;
			affectKinematic = scr.affectKinematic;
			heightOffset = scr.heightOffset;
			delay = scr.delay;
			applyDamage = scr.applyDamage;
			damageValue = scr.damageValue;
			clip = scr.clip;
			volume = scr.volume;
		}

		public void Explode(float delayLoc)
		{
			if (delayLoc == 0f)
			{
				Explode();
			}
			else if (delayLoc > 0f)
			{
				StartCoroutine(ExplodeCor());
			}
		}

		private IEnumerator ExplodeCor()
		{
			yield return new WaitForSeconds(delay);
			Explode();
		}

		private void Explode()
		{
			SetPositions();
			if (Setup() && (!SetRigidDamage() || Setup()))
			{
				SetForce();
				explosionEvent.InvokeLocalEvent(this);
				RFExplosionEvent.InvokeGlobalEvent(this);
				PlayAudio();
				if (!Application.isEditor)
				{
					ClearLists();
				}
			}
		}

		private void PlayAudio()
		{
			if (play && clip != null)
			{
				if (volume < 0f)
				{
					volume = 1f;
				}
				AudioSource.PlayClipAtPoint(clip, base.transform.position, volume);
			}
		}

		private bool Setup()
		{
			ClearLists();
			SetColliders();
			SetProjectiles();
			if (projectiles.Count == 0)
			{
				return false;
			}
			return true;
		}

		public void Restore()
		{
			foreach (Projectile projectile in projectiles)
			{
				if (projectile.rb != null)
				{
					projectile.rb.velocity = UnityEngine.Vector3.zero;
					projectile.rb.angularVelocity = UnityEngine.Vector3.zero;
					projectile.rb.transform.position = projectile.positionPivot;
					projectile.rb.transform.rotation = projectile.rotation;
				}
			}
		}

		private void ClearLists()
		{
			colliders = null;
			rigidbodies.Clear();
			projectiles.Clear();
		}

		private void SetPositions()
		{
			bombPosition = base.transform.position;
			explPosition = base.transform.position;
			if (heightOffset != 0f)
			{
				explPosition.y = bombPosition.y + heightOffset;
			}
		}

		private void SetColliders()
		{
			if (rangeType == RangeType.Spherical)
			{
				colliders = Physics.OverlapSphere(bombPosition, range, mask);
			}
		}

		private void SetProjectiles()
		{
			projectiles.Clear();
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				if (!(tagFilter != "Untagged") || !(collider.tag != tagFilter))
				{
					Rigidbody attachedRigidbody = collider.attachedRigidbody;
					if (!(attachedRigidbody == null) && !rigidbodies.Contains(attachedRigidbody))
					{
						Projectile projectile = new Projectile();
						projectile.rb = attachedRigidbody;
						projectile.positionPivot = attachedRigidbody.transform.position;
						projectile.rotation = attachedRigidbody.transform.rotation;
						projectile.positionClosest = collider.bounds.ClosestPoint(transForm.position);
						projectile.fade = Fade(transForm.position, projectile.positionClosest);
						projectile.scrRigid = projectile.rb.GetComponent<RayfireRigid>();
						projectiles.Add(projectile);
						rigidbodies.Add(attachedRigidbody);
					}
				}
			}
		}

		private bool SetRigidDamage()
		{
			bool result = false;
			if (applyDamage && damageValue > 0f)
			{
				foreach (Projectile projectile in projectiles)
				{
					if (projectile.scrRigid != null && projectile.scrRigid.damage.enable)
					{
						result = projectile.scrRigid.ApplyDamage(damageValue * projectile.fade, base.transform.position);
					}
				}
			}
			return result;
		}

		private void SetForce()
		{
			UnityEngine.Random.InitState(1);
			foreach (Projectile projectile in projectiles)
			{
				ForceMode mode = ForceMode.Impulse;
				if (!forceByMass)
				{
					mode = ForceMode.VelocityChange;
				}
				UnityEngine.Vector3 vector = Vector(projectile);
				SetKinematic(projectile);
				float max = strength * (float)variation / 100f + strength;
				float num = UnityEngine.Random.Range(strength, max);
				float num2 = projectile.fade * num * 10f;
				projectile.rb.AddForce(vector * num2, mode);
				UnityEngine.Vector3 angularVelocity = new UnityEngine.Vector3(UnityEngine.Random.Range(-chaos, chaos), UnityEngine.Random.Range(-chaos, chaos), UnityEngine.Random.Range(-chaos, chaos));
				projectile.rb.angularVelocity = angularVelocity;
			}
		}

		private void SetKinematic(Projectile projectile)
		{
			if (!affectKinematic || !(projectile.fade > 0f) || !projectile.rb.isKinematic)
			{
				return;
			}
			if (projectile.scrRigid != null)
			{
				projectile.scrRigid.simulationType = SimType.Dynamic;
				RFPhysic.SetSimulationType(projectile.scrRigid);
				if (projectile.scrRigid.physics.meshCollider is MeshCollider)
				{
					((MeshCollider)projectile.scrRigid.physics.meshCollider).convex = true;
				}
			}
			else
			{
				projectile.rb.isKinematic = false;
				MeshCollider component = projectile.rb.gameObject.GetComponent<MeshCollider>();
				if (component != null && !component.convex)
				{
					component.convex = true;
				}
			}
		}

		private float Fade(UnityEngine.Vector3 bombPos, UnityEngine.Vector3 fragPos)
		{
			float num = 1f;
			if (fadeType == FadeType.Linear)
			{
				num = 1f - UnityEngine.Vector3.Distance(bombPos, fragPos) / range;
			}
			else if (fadeType == FadeType.Exponential)
			{
				num = 1f - UnityEngine.Vector3.Distance(bombPos, fragPos) / range;
				num *= num;
			}
			if (num < 0f)
			{
				num = 0f;
			}
			return num;
		}

		private UnityEngine.Vector3 Vector(Projectile projectile)
		{
			UnityEngine.Vector3 result = UnityEngine.Vector3.up;
			if (rangeType == RangeType.Spherical)
			{
				result = UnityEngine.Vector3.Normalize(projectile.positionPivot - explPosition);
			}
			return result;
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Cluster")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-cluster-component/")]
	public class RayfireCluster : MonoBehaviour
	{
		public enum ClusterType
		{
			ByPointCloud,
			BySharedArea
		}

		[Space(2f)]
		[Header("  Properties")]
		[Space(2f)]
		public ClusterType type;

		[Range(1f, 7f)]
		public int depth = 1;

		[Range(0f, 100f)]
		public int seed = 1;

		[Range(0f, 4f)]
		public int smoothPass = 1;

		[Header("  By Point Cloud")]
		[Space(2f)]
		[Range(2f, 100f)]
		public int baseAmount = 5;

		[Range(2f, 50f)]
		public int depthAmount = 2;

		public ConnectivityType connectivity;

		[Header("  By Shared Area")]
		[Space(2f)]
		[Range(2f, 8f)]
		public int minimumAmount = 2;

		[Range(2f, 8f)]
		public int maximumAmount = 5;

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public bool colorPreview;

		[HideInInspector]
		public bool scalePreview;

		[HideInInspector]
		public Color wireColor = new Color(0.58f, 0.77f, 1f);

		[HideInInspector]
		public float previewScale;

		[HideInInspector]
		public List<RFCluster> allClusters = new List<RFCluster>();

		[HideInInspector]
		public List<RFShard> allShards = new List<RFShard>();

		private int clusterId;

		public void Extract()
		{
			previewScale = 0f;
			allShards.Clear();
			allClusters.Clear();
			List<Transform> list = GetComponentsInChildren<Transform>().ToList();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				if (list[num].GetComponents(typeof(UnityEngine.Component)).Length == 1)
				{
					UnityEngine.Object.DestroyImmediate(list[num].gameObject);
					list.RemoveAt(num);
				}
				else
				{
					list[num].parent = base.transform;
				}
			}
		}

		public void Clusterize()
		{
			Extract();
			allShards.Clear();
			allClusters.Clear();
			ClusterizeVoronoi();
			ClusterizeRange();
		}

		private void ClusterizeVoronoi()
		{
			if (type != 0)
			{
				return;
			}
			RFCluster rFCluster = SetupMainCluster(connectivity);
			if (baseAmount >= rFCluster.shards.Count)
			{
				return;
			}
			RFShard.SetShardNeibs(rFCluster.shards, connectivity);
			List<RFCluster> list = new List<RFCluster> { rFCluster };
			allClusters.Add(rFCluster);
			while (list.Count > 0)
			{
				RFCluster rFCluster2 = list[0];
				list.RemoveAt(0);
				if (rFCluster2.shards.Count >= 4)
				{
					int amount = baseAmount;
					if (rFCluster2.depth > 0)
					{
						amount = depthAmount;
					}
					rFCluster2.childClusters = ClusterizeClusterByAmount(rFCluster2, amount);
					allClusters.AddRange(rFCluster2.childClusters);
					if (rFCluster2.childClusters.Count > 0 && depth > rFCluster2.depth + 1)
					{
						list.AddRange(rFCluster2.childClusters);
					}
				}
			}
			SetClusterNames();
		}

		private List<RFCluster> ClusterizeClusterByAmount(RFCluster parentCluster, int amount)
		{
			List<RFCluster> list = new List<RFCluster>();
			if (parentCluster.tm.childCount <= 2)
			{
				return list;
			}
			if (amount >= parentCluster.shards.Count)
			{
				return list;
			}
			Bounds childrenBound = RFCluster.GetChildrenBound(parentCluster.tm);
			foreach (UnityEngine.Vector3 item in VoronoiPointCloud(childrenBound, amount))
			{
				RFCluster rFCluster = new RFCluster();
				rFCluster.pos = item;
				rFCluster.depth = parentCluster.depth + 1;
				clusterId++;
				rFCluster.id = clusterId;
				list.Add(rFCluster);
			}
			foreach (RFShard shard in parentCluster.shards)
			{
				float num = (shard.dist = UnityEngine.Vector3.Distance(shard.tm.position, list[0].pos));
				shard.cluster = list[0];
				if (list.Count > 1)
				{
					for (int i = 1; i < list.Count; i++)
					{
						float num2 = UnityEngine.Vector3.Distance(shard.tm.position, list[i].pos);
						if (num2 < num)
						{
							num = num2;
							shard.dist = num2;
							shard.cluster = list[i];
						}
					}
				}
				shard.cluster.shards.Add(shard);
				shard.cluster = null;
			}
			List<RFShard> list2 = new List<RFShard>();
			for (int num3 = list.Count - 1; num3 >= 0; num3--)
			{
				if (list[num3].shards.Count < 2)
				{
					list2.AddRange(list[num3].shards);
					list.RemoveAt(num3);
				}
			}
			SetSoloShardToCluster(list2, list);
			SetSoloShardToCluster(list2, list);
			if (smoothPass > 0 && connectivity == ConnectivityType.ByMesh)
			{
				for (int j = 0; j < smoothPass; j++)
				{
					RoughnessPassShards(list);
				}
			}
			if (connectivity == ConnectivityType.ByMesh)
			{
				ConnectivityCheck(list);
			}
			if (list.Count == 1)
			{
				list.Clear();
				return list;
			}
			foreach (RFCluster item2 in list)
			{
				CreateRoot(item2, parentCluster.tm);
			}
			return list;
		}

		private void ConnectivityCheck(List<RFCluster> childClusters)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFCluster> list2 = new List<RFCluster>();
			foreach (RFCluster childCluster in childClusters)
			{
				for (int num = childCluster.shards.Count - 1; num >= 0; num--)
				{
					if (childCluster.shards[num].neibShards.Count == 0)
					{
						list.Add(childCluster.shards[num]);
					}
				}
				List<RFShard> list3 = new List<RFShard>();
				foreach (RFShard shard in childCluster.shards)
				{
					list3.Add(shard);
				}
				int count = list3.Count;
				List<RFCluster> list4 = new List<RFCluster>();
				while (list3.Count > 0)
				{
					List<RFShard> list5 = new List<RFShard>();
					List<RFShard> list6 = new List<RFShard>();
					list6.Add(list3[0]);
					list5.Add(list3[0]);
					while (list6.Count > 0)
					{
						foreach (RFShard neibShard in list6[0].neibShards)
						{
							if (list3.Contains(neibShard) && !list5.Contains(neibShard))
							{
								list6.Add(neibShard);
								list5.Add(neibShard);
							}
						}
						list6.RemoveAt(0);
					}
					if (count == list5.Count)
					{
						list3.Clear();
						continue;
					}
					RFCluster rFCluster = new RFCluster();
					rFCluster.pos = childCluster.pos;
					rFCluster.depth = childCluster.depth;
					rFCluster.shards = list5;
					clusterId++;
					rFCluster.id = clusterId;
					list4.Add(rFCluster);
					for (int num2 = list3.Count - 1; num2 >= 0; num2--)
					{
						if (list5.Contains(list3[num2]))
						{
							list3.RemoveAt(num2);
						}
					}
				}
				if (list4.Count > 0)
				{
					childCluster.shards.Clear();
					list2.AddRange(list4);
				}
			}
			for (int num3 = childClusters.Count - 1; num3 >= 0; num3--)
			{
				if (childClusters[num3].shards.Count == 0)
				{
					childClusters.RemoveAt(num3);
				}
			}
			childClusters.AddRange(list2);
			RFCluster.SetClusterNeib(childClusters, connectivity: true);
			SetSoloShardToCluster(list, childClusters);
			if (smoothPass > 0)
			{
				RoughnessPassShards(childClusters);
			}
		}

		private void ClusterizeRange()
		{
			if (type != ClusterType.BySharedArea)
			{
				return;
			}
			UnityEngine.Random.InitState(seed);
			RFCluster rFCluster = SetupMainCluster(ConnectivityType.ByMesh);
			allClusters.Add(rFCluster);
			RFShard.SetShardNeibs(rFCluster.shards, ConnectivityType.ByMesh);
			List<RFCluster> list = ClusterizeRangeShards(rFCluster);
			foreach (RFCluster item in list)
			{
				CreateRoot(item, base.transform);
			}
			allClusters.AddRange(list);
			if (depth > 1)
			{
				for (int i = 1; i < depth; i++)
				{
					RFCluster.SetClusterNeib(rFCluster.childClusters, connectivity: true);
					List<RFCluster> list2 = ClusterizeRangeClusters(rFCluster);
					if (list2.Count <= 1)
					{
						continue;
					}
					foreach (RFCluster item2 in list2)
					{
						CreateRoot(item2, rFCluster.tm);
						foreach (RFCluster childCluster in item2.childClusters)
						{
							childCluster.tm.parent = item2.tm;
						}
					}
					rFCluster.childClusters = list2;
					allClusters.AddRange(list2);
					foreach (RFCluster allCluster in allClusters)
					{
						if (allCluster.id != 0)
						{
							allCluster.depth++;
						}
					}
				}
			}
			SetClusterNames();
		}

		private List<RFCluster> ClusterizeRangeShards(RFCluster mainCluster)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFCluster> list2 = new List<RFCluster>();
			mainCluster.shards.Sort();
			while (mainCluster.shards.Count > 0)
			{
				int num = UnityEngine.Random.Range(minimumAmount, maximumAmount);
				RFShard item = mainCluster.shards[0];
				mainCluster.shards.RemoveAt(0);
				List<RFShard> list3 = new List<RFShard>();
				list3.Add(item);
				for (int i = 0; i < num - 1; i++)
				{
					RFShard biggestShard = RFShard.GetNeibShardArea(list3, mainCluster.shards);
					if (biggestShard == null)
					{
						break;
					}
					list3.Add(biggestShard);
					mainCluster.shards.RemoveAll((RFShard t) => t.id == biggestShard.id);
				}
				if (list3.Count == 1)
				{
					list.Add(item);
				}
				else if (list3.Count > 1)
				{
					RFCluster rFCluster = new RFCluster();
					rFCluster.shards.AddRange(list3);
					rFCluster.depth = 1;
					clusterId++;
					rFCluster.id = clusterId;
					list2.Add(rFCluster);
					mainCluster.childClusters.Add(rFCluster);
				}
			}
			SetSoloShardToCluster(list, list2);
			SetSoloShardToCluster(list, list2);
			if (smoothPass > 0)
			{
				for (int j = 0; j < smoothPass; j++)
				{
					RoughnessPassShards(list2);
				}
			}
			int num2 = 1;
			for (int k = 0; k < list2.Count; k++)
			{
				list2[k].id = num2 + k;
			}
			mainCluster.shards.Clear();
			mainCluster.shards.AddRange(list);
			return list2;
		}

		private List<RFCluster> ClusterizeRangeClusters(RFCluster parentCluster)
		{
			List<RFCluster> list = new List<RFCluster>();
			List<RFCluster> list2 = new List<RFCluster>();
			parentCluster.childClusters.Sort();
			while (parentCluster.childClusters.Count > 0)
			{
				int num = UnityEngine.Random.Range(minimumAmount, maximumAmount);
				RFCluster item = parentCluster.childClusters[0];
				parentCluster.childClusters.RemoveAt(0);
				List<RFCluster> list3 = new List<RFCluster>();
				list3.Add(item);
				for (int i = 0; i < num - 1; i++)
				{
					RFCluster biggestCluster = RFCluster.GetNeibClusterArea(list3, parentCluster.childClusters);
					if (biggestCluster == null)
					{
						break;
					}
					list3.Add(biggestCluster);
					parentCluster.childClusters.RemoveAll((RFCluster t) => t.id == biggestCluster.id);
				}
				if (list3.Count == 1)
				{
					list.Add(item);
					continue;
				}
				RFCluster rFCluster = new RFCluster();
				rFCluster.childClusters.AddRange(list3);
				rFCluster.depth = 0;
				clusterId++;
				rFCluster.id = clusterId;
				list2.Add(rFCluster);
			}
			SetSoloClusterToCluster(list, list2);
			SetSoloClusterToCluster(list, list2);
			if (smoothPass > 0)
			{
				for (int j = 0; j < smoothPass; j++)
				{
					RoughnessPassClusters(list2);
				}
			}
			return list2;
		}

		private static void RoughnessPassShards(List<RFCluster> clusters)
		{
			RFCluster.SetClusterNeib(clusters, connectivity: true);
			for (int num = clusters.Count - 1; num >= 0; num--)
			{
				RFCluster rFCluster = clusters[num];
				if (rFCluster.shards.Count != 2 && rFCluster.neibClusters.Count != 0)
				{
					List<RFShard> list = new List<RFShard>();
					List<RFCluster> list2 = new List<RFCluster>();
					foreach (RFShard shard in rFCluster.shards)
					{
						float num2 = 0f;
						for (int i = 0; i < shard.neibShards.Count; i++)
						{
							if (rFCluster.shards.Contains(shard.neibShards[i]))
							{
								num2 += shard.neibArea[i];
							}
						}
						List<float> list3 = new List<float>();
						foreach (RFCluster neibCluster in rFCluster.neibClusters)
						{
							float num3 = 0f;
							for (int j = 0; j < shard.neibShards.Count; j++)
							{
								if (neibCluster.shards.Contains(shard.neibShards[j]))
								{
									num3 += shard.neibArea[j];
								}
							}
							list3.Add(num3);
						}
						float num4 = list3.Max();
						if (num2 >= num4)
						{
							continue;
						}
						for (int k = 0; k < list3.Count; k++)
						{
							if (num4 == list3[k])
							{
								list.Add(shard);
								list2.Add(rFCluster.neibClusters[k]);
							}
						}
					}
					if (list.Count > 0)
					{
						for (int l = 0; l < list.Count; l++)
						{
							for (int num5 = rFCluster.shards.Count - 1; num5 >= 0; num5--)
							{
								if (rFCluster.shards[num5] == list[l])
								{
									rFCluster.shards.RemoveAt(num5);
								}
							}
							list2[l].shards.Add(list[l]);
						}
					}
				}
			}
			for (int num6 = clusters.Count - 1; num6 >= 0; num6--)
			{
				if (clusters[num6].shards.Count == 1)
				{
					clusters[num6].shards.Clear();
				}
				if (clusters[num6].shards.Count == 0)
				{
					clusters.RemoveAt(num6);
				}
			}
		}

		private void RoughnessPassClusters(List<RFCluster> clusters)
		{
			RFCluster.SetClusterNeib(clusters, connectivity: true);
			foreach (RFCluster cluster in clusters)
			{
				if (cluster.childClusters.Count <= 2 || cluster.neibClusters.Count == 0)
				{
					continue;
				}
				List<RFCluster> list = new List<RFCluster>();
				List<RFCluster> list2 = new List<RFCluster>();
				foreach (RFCluster childCluster in cluster.childClusters)
				{
					float num = 0f;
					for (int i = 0; i < childCluster.neibClusters.Count; i++)
					{
						if (cluster.childClusters.Contains(childCluster.neibClusters[i]))
						{
							num += childCluster.neibArea[i];
						}
					}
					List<float> list3 = new List<float>();
					foreach (RFCluster neibCluster in cluster.neibClusters)
					{
						float num2 = 0f;
						for (int j = 0; j < childCluster.neibClusters.Count; j++)
						{
							if (neibCluster.childClusters.Contains(childCluster.neibClusters[j]))
							{
								num2 += childCluster.neibArea[j];
							}
						}
						list3.Add(num2);
					}
					float num3 = list3.Max();
					if (num >= num3)
					{
						continue;
					}
					for (int k = 0; k < list3.Count; k++)
					{
						if (num3 == list3[k])
						{
							list.Add(childCluster);
							list2.Add(cluster.neibClusters[k]);
						}
					}
				}
				if (list.Count + 1 >= cluster.childClusters.Count || list.Count <= 0)
				{
					continue;
				}
				for (int l = 0; l < list.Count; l++)
				{
					for (int num4 = cluster.shards.Count - 1; num4 >= 0; num4--)
					{
						if (cluster.childClusters[num4] == list[l])
						{
							cluster.childClusters.RemoveAt(num4);
						}
					}
					list2[l].childClusters.Add(list[l]);
				}
			}
		}

		private void SetSoloShardToCluster(List<RFShard> soloShards, List<RFCluster> childClusters)
		{
			if (soloShards.Count == 0)
			{
				return;
			}
			for (int num = soloShards.Count - 1; num >= 0; num--)
			{
				int neibIndArea = soloShards[num].GetNeibIndArea();
				if (neibIndArea >= 0)
				{
					RFShard item = soloShards[num].neibShards[neibIndArea];
					for (int i = 0; i < childClusters.Count; i++)
					{
						if (childClusters[i].shards.Contains(item))
						{
							childClusters[i].shards.Add(soloShards[num]);
							soloShards.RemoveAt(num);
						}
					}
				}
			}
		}

		private void SetSoloClusterToCluster(List<RFCluster> soloClusters, List<RFCluster> childClusters)
		{
			if (soloClusters.Count == 0)
			{
				return;
			}
			for (int num = soloClusters.Count - 1; num >= 0; num--)
			{
				int neibIndArea = soloClusters[num].GetNeibIndArea();
				if (neibIndArea >= 0)
				{
					RFCluster item = soloClusters[num].neibClusters[neibIndArea];
					for (int i = 0; i < childClusters.Count; i++)
					{
						if (childClusters[i].childClusters.Contains(item))
						{
							childClusters[i].childClusters.Add(soloClusters[num]);
							soloClusters.RemoveAt(num);
						}
					}
				}
			}
		}

		private RFCluster SetupMainCluster(ConnectivityType connect)
		{
			RFCluster rFCluster = RFCluster.SetCluster(base.transform, connect);
			clusterId = 0;
			allShards.Clear();
			allShards.AddRange(rFCluster.shards);
			return rFCluster;
		}

		private void SetClusterNames()
		{
			foreach (RFCluster allCluster in allClusters)
			{
				if (allCluster.id > 0 && allCluster.tm != null)
				{
					allCluster.tm.name = base.gameObject.name + "_cls_" + allCluster.id;
				}
			}
		}

		private void CreateRoot(RFCluster childCluster, Transform parentTm)
		{
			Bounds bounds = (childCluster.bound = GetShardsBound(childCluster.shards, childCluster.childClusters));
			GameObject gameObject = new GameObject();
			childCluster.tm = gameObject.transform;
			childCluster.pos = bounds.center;
			childCluster.tm.position = bounds.center;
			childCluster.tm.parent = parentTm;
			childCluster.rootParent = parentTm;
			foreach (RFShard shard in childCluster.shards)
			{
				shard.tm.parent = childCluster.tm;
			}
		}

		private Bounds GetShardsBound(List<RFShard> shards, List<RFCluster> clusters = null)
		{
			List<Bounds> list = new List<Bounds>();
			foreach (RFShard shard in shards)
			{
				list.Add(shard.bound);
			}
			if (clusters != null)
			{
				foreach (RFCluster cluster in clusters)
				{
					list.Add(cluster.bound);
				}
			}
			return RFCluster.GetBoundsBound(list);
		}

		private List<UnityEngine.Vector3> VoronoiPointCloud(Bounds bound, int am)
		{
			UnityEngine.Random.InitState(seed + clusterId);
			List<UnityEngine.Vector3> list = new List<UnityEngine.Vector3>();
			for (int i = 0; i < am; i++)
			{
				float x = UnityEngine.Random.Range(bound.min.x, bound.max.x);
				float y = UnityEngine.Random.Range(bound.min.y, bound.max.y);
				float z = UnityEngine.Random.Range(bound.min.z, bound.max.z);
				UnityEngine.Vector3 item = new UnityEngine.Vector3(x, y, z);
				list.Add(item);
			}
			return list;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Combine")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-combine-component/")]
	public class RayfireCombine : MonoBehaviour
	{
		public enum CombType
		{
			Children,
			ObjectsList
		}

		public CombType type;

		public List<GameObject> objects;

		private Transform transForm;

		private MeshFilter meshFilter;

		private MeshRenderer meshRenderer;

		private List<bool> invertNormals;

		private List<Transform> transForms;

		private List<MeshFilter> meshFilters;

		private List<SkinnedMeshRenderer> skinnedMeshRends;

		private List<Mesh> meshes;

		private List<List<int>> matIdList;

		private List<List<Material>> matList;

		private List<Material> allMaterials;

		private List<int> combTrianglesSubId;

		private List<List<int>> combTriangles;

		private List<UnityEngine.Vector3> combVertices;

		private List<UnityEngine.Vector3> combNormals;

		private List<UnityEngine.Vector2> combUvs;

		private List<UnityEngine.Vector4> combTangents;

		public void Combine()
		{
			SetData();
			SetCombinedMesh();
			CreateMesh();
		}

		private void SetData()
		{
			transForm = GetComponent<Transform>();
			meshFilter = GetComponent<MeshFilter>();
			if (meshFilter == null)
			{
				meshFilter = base.gameObject.AddComponent<MeshFilter>();
			}
			meshFilter.sharedMesh = null;
			meshRenderer = GetComponent<MeshRenderer>();
			if (meshRenderer == null)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			meshRenderer.sharedMaterials = new Material[0];
			if (type == CombType.Children)
			{
				meshFilters = GetComponentsInChildren<MeshFilter>().ToList();
				skinnedMeshRends = GetComponentsInChildren<SkinnedMeshRenderer>().ToList();
			}
			if (type == CombType.ObjectsList)
			{
				meshFilters = new List<MeshFilter>();
				foreach (GameObject @object in objects)
				{
					MeshFilter component = @object.GetComponent<MeshFilter>();
					if (component != null)
					{
						meshFilters.Add(component);
					}
				}
				skinnedMeshRends = new List<SkinnedMeshRenderer>();
				foreach (GameObject object2 in objects)
				{
					SkinnedMeshRenderer component2 = object2.GetComponent<SkinnedMeshRenderer>();
					if (component2 != null)
					{
						skinnedMeshRends.Add(component2);
					}
				}
			}
			for (int num = meshFilters.Count - 1; num >= 0; num--)
			{
				if (meshFilters[num].sharedMesh == null)
				{
					meshFilters.RemoveAt(num);
				}
			}
			for (int num2 = skinnedMeshRends.Count - 1; num2 >= 0; num2--)
			{
				if (skinnedMeshRends[num2].sharedMesh == null)
				{
					skinnedMeshRends.RemoveAt(num2);
				}
			}
			meshes = new List<Mesh>();
			transForms = new List<Transform>();
			matList = new List<List<Material>>();
			foreach (MeshFilter meshFilter in meshFilters)
			{
				meshes.Add(meshFilter.sharedMesh);
				transForms.Add(meshFilter.transform);
				MeshRenderer component3 = meshFilter.GetComponent<MeshRenderer>();
				List<Material> item = new List<Material>();
				if (component3 != null)
				{
					item = component3.sharedMaterials.ToList();
				}
				matList.Add(item);
			}
			foreach (SkinnedMeshRenderer skinnedMeshRend in skinnedMeshRends)
			{
				meshes.Add(RFMesh.BakeMesh(skinnedMeshRend));
				transForms.Add(skinnedMeshRend.transform);
				matList.Add(skinnedMeshRend.sharedMaterials.ToList());
			}
			if (meshes.Count == 0)
			{
				UnityEngine.Debug.Log("No meshes to combine");
				return;
			}
			invertNormals = new List<bool>();
			allMaterials = new List<Material>();
			matIdList = new List<List<int>>();
			for (int i = 0; i < transForms.Count; i++)
			{
				foreach (Material item2 in matList[i])
				{
					if (!allMaterials.Contains(item2))
					{
						allMaterials.Add(item2);
					}
				}
				matIdList.Add(matList[i].Select((Material t) => allMaterials.IndexOf(t)).ToList());
				bool flag = false;
				if (transForms[i].localScale.x < 0f)
				{
					flag = !flag;
				}
				if (transForms[i].localScale.y < 0f)
				{
					flag = !flag;
				}
				if (transForms[i].localScale.z < 0f)
				{
					flag = !flag;
				}
				invertNormals.Add(flag);
			}
		}

		private void SetCombinedMesh()
		{
			int num = 0;
			combTrianglesSubId = new List<int>();
			combTriangles = new List<List<int>>();
			combVertices = new List<UnityEngine.Vector3>();
			combNormals = new List<UnityEngine.Vector3>();
			combUvs = new List<UnityEngine.Vector2>();
			combTangents = new List<UnityEngine.Vector4>();
			int i;
			for (i = 0; i < meshes.Count; i++)
			{
				Mesh mesh = meshes[i];
				combVertices.AddRange(mesh.vertices.Select((UnityEngine.Vector3 t) => transForm.InverseTransformPoint(transForms[i].TransformPoint(t))));
				combNormals.AddRange(invertNormals[i] ? mesh.normals.Select((UnityEngine.Vector3 o) => -o).ToList() : mesh.normals.ToList());
				combUvs.AddRange(mesh.uv.ToList());
				combTangents.AddRange(mesh.tangents.ToList());
				for (int j = 0; j < mesh.subMeshCount; j++)
				{
					int[] array = mesh.GetTriangles(j);
					if (invertNormals[i])
					{
						array = array.Reverse().ToArray();
					}
					for (int k = 0; k < array.Length; k++)
					{
						array[k] += num;
					}
					if (combTrianglesSubId.Contains(matIdList[i][j]))
					{
						int index = combTrianglesSubId.IndexOf(matIdList[i][j]);
						combTriangles[index].AddRange(array.ToList());
					}
					else
					{
						combTriangles.Add(array.ToList());
						combTrianglesSubId.Add(matIdList[i][j]);
					}
				}
				num += mesh.vertices.Length;
			}
		}

		private void CreateMesh()
		{
			Mesh mesh = new Mesh();
			mesh.name = base.name + "_Comb";
			mesh.SetVertices(combVertices);
			mesh.SetNormals(combNormals);
			mesh.SetUVs(0, combUvs);
			mesh.SetTangents(combTangents);
			mesh.subMeshCount = combTrianglesSubId.Count;
			for (int i = 0; i < combTriangles.Count; i++)
			{
				mesh.SetTriangles(combTriangles[i], combTrianglesSubId[i]);
			}
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			mesh.RecalculateTangents();
			meshFilter.sharedMesh = mesh;
			meshRenderer.sharedMaterials = allMaterials.ToArray();
		}
	}
	[AddComponentMenu("RayFire/Rayfire Connectivity")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-connectivity-component/")]
	public class RayfireConnectivity : MonoBehaviour
	{
		public enum ConnTargetType
		{
			Gizmo,
			Children
		}

		[Space(2f)]
		[Header("Properties")]
		[Space(1f)]
		public ConnTargetType source;

		[Space(1f)]
		public ConnectivityType connectivityType;

		[Space(2f)]
		[Header("Connections")]
		[Space(1f)]
		public bool showConnections;

		[Space(1f)]
		[Range(0f, 1f)]
		public float sphereSize = 1f;

		[Space(2f)]
		[Header("Gizmo")]
		[Space(1f)]
		public bool showGizmo = true;

		public UnityEngine.Vector3 size = new UnityEngine.Vector3(1f, 1f, 1f);

		[HideInInspector]
		public bool checkConnectivity;

		[HideInInspector]
		public bool checkNeed;

		private List<RayfireRigid> rigidList;

		[NonSerialized]
		public RFCluster cluster;

		private void Awake()
		{
			SetByChildren();
		}

		private void Start()
		{
			SetByGizmo();
			if (rigidList.Count == 0)
			{
				UnityEngine.Debug.Log("RayFire Connectivity: " + base.name + " has no objects to check for connectivity. Object Excluded from simulation.", base.gameObject);
			}
			else
			{
				StartCoroutine(ConnectivityCor());
			}
		}

		private void SetByGizmo()
		{
			if (source != 0)
			{
				return;
			}
			Collider[] array = Physics.OverlapBox(base.transform.position, size / 2f, base.transform.rotation);
			List<Transform> list = new List<Transform>();
			Collider[] array2 = array;
			foreach (Collider collider in array2)
			{
				if (!list.Contains(collider.transform))
				{
					list.Add(collider.transform);
				}
			}
			SetConnectivity(list);
		}

		private void SetByChildren()
		{
			if (source == ConnTargetType.Children)
			{
				List<Transform> list = new List<Transform>();
				for (int i = 0; i < base.transform.childCount; i++)
				{
					list.Add(base.transform.GetChild(i));
				}
				SetConnectivity(list);
			}
		}

		private void SetConnectivity(List<Transform> tmList)
		{
			if (tmList.Count == 0)
			{
				return;
			}
			rigidList = new List<RayfireRigid>();
			foreach (Transform tm in tmList)
			{
				RayfireRigid component = tm.GetComponent<RayfireRigid>();
				if (component != null && (component.simulationType == SimType.Inactive || component.simulationType == SimType.Kinematic) && component.activation.byConnectivity)
				{
					rigidList.Add(component);
				}
			}
			if (rigidList.Count == 0)
			{
				return;
			}
			foreach (RayfireRigid rigid in rigidList)
			{
				rigid.activation.connect = this;
			}
			SetCluster();
		}

		private void SetCluster()
		{
			cluster = new RFCluster();
			cluster.shards = RFShard.GetShards(rigidList, connectivityType);
			RFShard.SetShardNeibs(cluster.shards, connectivityType);
		}

		private void Check()
		{
			RFCluster.ConnectivityCheckUny(cluster);
		}

		private IEnumerator ConnectivityCor()
		{
			checkConnectivity = true;
			while (checkConnectivity)
			{
				if (checkNeed)
				{
					checkNeed = false;
					CheckConnectivity();
				}
				yield return null;
			}
		}

		private void CheckConnectivity()
		{
			Check();
			if (cluster.shards.Count == 0)
			{
				checkConnectivity = false;
			}
			Activate();
		}

		private void Activate()
		{
			if (cluster.childClusters.Count == 0)
			{
				return;
			}
			foreach (RFShard shard in cluster.childClusters[0].shards)
			{
				shard.rigid.Activate();
			}
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Debris")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-debris-component/")]
	public class RayfireDebris : MonoBehaviour
	{
		[Header("  Emit Debris")]
		[Space(3f)]
		public bool onDemolition;

		[Space(1f)]
		public bool onActivation;

		[Space(1f)]
		public bool onImpact;

		[Header("  Main")]
		[Space(3f)]
		public GameObject debrisReference;

		[Space(2f)]
		public Material debrisMaterial;

		[Space(2f)]
		public Material emissionMaterial;

		[Header("  Properties")]
		[Space(3f)]
		public RFParticleEmission emission;

		[Space(2f)]
		public RFParticleDynamicDebris dynamic;

		[Space(2f)]
		public RFParticleNoise noise;

		[Space(2f)]
		public RFParticleCollisionDebris collision;

		[Space(2f)]
		public RFParticleLimitations limitations;

		[Space(2f)]
		public RFParticleRendering rendering;

		[HideInInspector]
		public RayfireRigid rigid;

		[HideInInspector]
		public ParticleSystem pSystem;

		[HideInInspector]
		public Transform hostTm;

		[HideInInspector]
		public bool initialized;

		[HideInInspector]
		public List<Mesh> debrisMeshList;

		[HideInInspector]
		public UnityEngine.Vector3 refScale = UnityEngine.Vector3.one;

		[HideInInspector]
		public List<RayfireDebris> children;

		[HideInInspector]
		public int amountFinal;

		public bool HasChildren
		{
			get
			{
				if (children != null)
				{
					return children.Count > 0;
				}
				return false;
			}
		}

		public RayfireDebris()
		{
			onDemolition = false;
			onActivation = false;
			onImpact = false;
			debrisReference = null;
			debrisMaterial = null;
			emissionMaterial = null;
			emission = new RFParticleEmission();
			dynamic = new RFParticleDynamicDebris();
			noise = new RFParticleNoise();
			collision = new RFParticleCollisionDebris();
			limitations = new RFParticleLimitations();
			rendering = new RFParticleRendering();
			debrisMeshList = new List<Mesh>();
			pSystem = null;
			hostTm = null;
			initialized = false;
			amountFinal = 0;
		}

		public void CopyFrom(RayfireDebris source)
		{
			onDemolition = source.onDemolition;
			onActivation = source.onActivation;
			onImpact = source.onImpact;
			debrisReference = source.debrisReference;
			debrisMaterial = source.debrisMaterial;
			emissionMaterial = source.emissionMaterial;
			emission.CopyFrom(source.emission);
			dynamic.CopyFrom(source.dynamic);
			noise.CopyFrom(source.noise);
			collision.CopyFrom(source.collision);
			limitations.CopyFrom(source.limitations);
			rendering.CopyFrom(source.rendering);
			debrisMeshList = source.debrisMeshList;
			initialized = source.initialized;
		}

		public void Initialize()
		{
			if (!initialized)
			{
				SetReferenceMeshes(debrisReference);
			}
		}

		public void Emit()
		{
			Initialize();
			if (initialized)
			{
				collision.SetMaterialProps(this);
				ParticleSystem ps = CreateParticleSystem(this);
				MeshFilter component = GetComponent<MeshFilter>();
				int emissionMatIndex = RFParticles.GetEmissionMatIndex(GetComponent<MeshRenderer>(), emissionMaterial);
				amountFinal = 30;
				CreateDebris(base.transform, this, component, emissionMatIndex, ps);
			}
		}

		public ParticleSystem CreateParticleSystem(RayfireDebris scr)
		{
			GameObject gameObject = new GameObject(scr.name + "_debris");
			gameObject.transform.position = scr.transform.position;
			gameObject.transform.rotation = scr.transform.rotation;
			gameObject.transform.parent = scr.transform;
			gameObject.transform.localScale = UnityEngine.Vector3.one;
			ParticleSystem particleSystem = (scr.pSystem = gameObject.AddComponent<ParticleSystem>());
			scr.hostTm = gameObject.transform;
			UnityEngine.Object.Destroy(gameObject, scr.emission.lifeMax + particleSystem.main.duration);
			particleSystem.Stop();
			return particleSystem;
		}

		public void CreateDebris(Transform host, RayfireDebris scr, MeshFilter emitMeshFilter, int emitMatIndex, ParticleSystem ps)
		{
			RFParticles.SetMain(ps.main, scr.emission.lifeMin, scr.emission.lifeMax, scr.emission.sizeMin, scr.emission.sizeMax, scr.dynamic.gravityMin, scr.dynamic.gravityMax, scr.dynamic.speedMin, scr.dynamic.speedMax, 3.1f, scr.limitations.maxParticles, scr.emission.duration);
			RFParticles.SetEmission(ps.emission, scr.emission.distanceRate, scr.amountFinal);
			if (emitMeshFilter != null)
			{
				RFParticles.SetShapeMesh(ps.shape, emitMeshFilter.sharedMesh, emitMatIndex, emitMeshFilter.transform.localScale);
			}
			else
			{
				RFParticles.SetShapeObject(ps.shape);
			}
			RFParticles.SetVelocity(ps.inheritVelocity, scr.dynamic);
			RFParticles.SetSizeOverLifeTime(ps.sizeOverLifetime, scr.refScale);
			RFParticles.SetRotationBySpeed(ps.rotationBySpeed, scr.dynamic.rotationSpeed);
			RFParticles.SetCollisionDebris(ps.collision, scr.collision);
			RFParticles.SetNoise(ps.noise, scr.noise);
			SetParticleRendererDebris(ps.GetComponent<ParticleSystemRenderer>(), scr);
			ps.Play();
		}

		public void SetParticleRendererDebris(ParticleSystemRenderer rend, RayfireDebris scr)
		{
			rend.renderMode = ParticleSystemRenderMode.Mesh;
			rend.alignment = ParticleSystemRenderSpace.World;
			if (scr.debrisMeshList.Count > 0)
			{
				if (scr.debrisMeshList.Count <= 4)
				{
					rend.SetMeshes(scr.debrisMeshList.ToArray());
					rend.mesh = scr.debrisMeshList[0];
				}
				else
				{
					List<Mesh> list = new List<Mesh>();
					for (int i = 0; i < 4; i++)
					{
						list.Add(scr.debrisMeshList[UnityEngine.Random.Range(0, scr.debrisMeshList.Count)]);
					}
					rend.SetMeshes(list.ToArray());
					rend.mesh = list[0];
				}
			}
			rend.sharedMaterial = scr.debrisMaterial;
			rend.shadowCastingMode = (scr.rendering.castShadows ? ShadowCastingMode.On : ShadowCastingMode.Off);
			rend.receiveShadows = scr.rendering.receiveShadows;
		}

		private void SetReferenceMeshes(GameObject refs)
		{
			debrisMeshList = new List<Mesh>();
			if (refs == null)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Debris reference not defined.", base.gameObject);
				return;
			}
			List<MeshFilter> list = new List<MeshFilter>();
			MeshFilter component = refs.GetComponent<MeshFilter>();
			if (component != null)
			{
				list.Add(component);
			}
			if (refs.transform.childCount > 0)
			{
				list.AddRange(refs.GetComponentsInChildren<MeshFilter>().ToList());
			}
			if (list.Count == 0)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Debris reference mesh is not defined.", base.gameObject);
				return;
			}
			debrisMeshList = (from mf in list
				where mf.sharedMesh != null && mf.sharedMesh.vertexCount > 3
				select mf.sharedMesh).ToList();
			if (debrisMeshList.Count == 0)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Debris reference mesh is not defined.", base.gameObject);
				return;
			}
			SetDebrisMaterial(list);
			refScale = list[0].transform.lossyScale;
			initialized = true;
		}

		private void SetDebrisMaterial(List<MeshFilter> mfs)
		{
			if (debrisMaterial != null)
			{
				return;
			}
			for (int i = 0; i < mfs.Count; i++)
			{
				Renderer component = mfs[i].GetComponent<Renderer>();
				if (component != null && component.sharedMaterial != null)
				{
					debrisMaterial = component.sharedMaterial;
					return;
				}
			}
			if (debrisMaterial == null)
			{
				debrisMaterial = GetComponent<Renderer>().sharedMaterial;
			}
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Dust")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-dust-component/")]
	public class RayfireDust : MonoBehaviour
	{
		[Header("  Emit Dust")]
		[Space(3f)]
		public bool onDemolition;

		[Space(1f)]
		public bool onActivation;

		[Space(1f)]
		public bool onImpact;

		[Header("  Main")]
		[Space(3f)]
		[Range(0.01f, 1f)]
		public float opacity;

		[Space(2f)]
		public Material dustMaterial;

		[Space(2f)]
		public Material emissionMaterial;

		[Header("  Properties")]
		[Space(3f)]
		public RFParticleEmission emission;

		[Space(2f)]
		public RFParticleDynamicDust dynamic;

		[Space(2f)]
		public RFParticleNoise noise;

		[Space(2f)]
		public RFParticleCollisionDust collision;

		[Space(2f)]
		public RFParticleLimitations limitations;

		[Space(2f)]
		public RFParticleRendering rendering;

		[HideInInspector]
		public RayfireRigid rigid;

		[HideInInspector]
		public ParticleSystem pSystem;

		[HideInInspector]
		public Transform hostTm;

		[HideInInspector]
		public bool initialized;

		[HideInInspector]
		public List<RayfireDust> children;

		[HideInInspector]
		public int amountFinal;

		public bool HasChildren
		{
			get
			{
				if (children != null)
				{
					return children.Count > 0;
				}
				return false;
			}
		}

		public RayfireDust()
		{
			onDemolition = true;
			onActivation = false;
			onImpact = false;
			dustMaterial = null;
			opacity = 0.25f;
			emissionMaterial = null;
			emission = new RFParticleEmission();
			dynamic = new RFParticleDynamicDust();
			noise = new RFParticleNoise();
			collision = new RFParticleCollisionDust();
			limitations = new RFParticleLimitations();
			rendering = new RFParticleRendering();
			pSystem = null;
			hostTm = null;
			initialized = false;
			amountFinal = 5;
		}

		public void CopyFrom(RayfireDust source)
		{
			onDemolition = source.onDemolition;
			onActivation = source.onActivation;
			onImpact = source.onImpact;
			dustMaterial = source.dustMaterial;
			opacity = source.opacity;
			emissionMaterial = source.emissionMaterial;
			emission.CopyFrom(source.emission);
			dynamic.CopyFrom(source.dynamic);
			noise.CopyFrom(source.noise);
			collision.CopyFrom(source.collision);
			limitations.CopyFrom(source.limitations);
			rendering.CopyFrom(source.rendering);
			initialized = source.initialized;
		}

		public void Initialize()
		{
			if (dustMaterial == null)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Dust material not defined.", base.gameObject);
				initialized = false;
			}
			else
			{
				initialized = true;
			}
		}

		public void Emit()
		{
			Initialize();
			if (initialized)
			{
				ParticleSystem ps = CreateParticleSystem(this);
				MeshFilter component = GetComponent<MeshFilter>();
				int emissionMatIndex = RFParticles.GetEmissionMatIndex(GetComponent<MeshRenderer>(), emissionMaterial);
				amountFinal = 30;
				CreateDust(base.transform, this, component, emissionMatIndex, ps);
			}
		}

		public void CreateDustImpact(RayfireRigid target, UnityEngine.Vector3 impactPos, UnityEngine.Vector3 impactNormal, short amount)
		{
			for (int i = 0; i < target.dustList.Count; i++)
			{
				ParticleSystem ps = CreateParticleSystem(target.dustList[i]);
				target.dustList[i].hostTm.position = impactPos;
				target.dustList[i].hostTm.LookAt(impactPos + impactNormal);
				CreateDust(target.transform, target.dustList[i], null, -1, ps);
			}
		}

		public ParticleSystem CreateParticleSystem(RayfireDust scr)
		{
			GameObject gameObject = new GameObject(scr.name + "_dust");
			gameObject.transform.position = scr.transform.position;
			gameObject.transform.rotation = scr.transform.rotation;
			gameObject.transform.parent = scr.transform;
			gameObject.transform.localScale = UnityEngine.Vector3.one;
			ParticleSystem particleSystem = (scr.pSystem = gameObject.AddComponent<ParticleSystem>());
			scr.hostTm = gameObject.transform;
			UnityEngine.Object.Destroy(gameObject, scr.emission.lifeMax + particleSystem.main.duration);
			particleSystem.Stop();
			return particleSystem;
		}

		public void CreateDust(Transform host, RayfireDust scr, MeshFilter emitMeshFilter, int emitMatIndex, ParticleSystem ps)
		{
			RFParticles.SetMain(ps.main, scr.emission.lifeMin, scr.emission.lifeMax, scr.emission.sizeMin, scr.emission.sizeMax, scr.dynamic.gravityMin, scr.dynamic.gravityMax, scr.dynamic.speedMin, scr.dynamic.speedMax, 0f, scr.limitations.maxParticles, scr.emission.duration);
			RFParticles.SetEmission(ps.emission, scr.emission.distanceRate, (short)scr.amountFinal);
			if (emitMeshFilter != null)
			{
				RFParticles.SetShapeMesh(ps.shape, emitMeshFilter.sharedMesh, emitMatIndex, emitMeshFilter.transform.localScale);
			}
			else
			{
				RFParticles.SetShapeObject(ps.shape);
			}
			RFParticles.SetCollisionDust(ps.collision, scr.collision);
			RFParticles.SetColorOverLife(ps.colorOverLifetime, scr.opacity);
			RFParticles.SetNoise(ps.noise, scr.noise);
			SetParticleRendererDust(ps.GetComponent<ParticleSystemRenderer>(), scr.dustMaterial, scr.rendering.castShadows, scr.rendering.receiveShadows);
			ps.Play();
		}

		public void SetParticleRendererDust(ParticleSystemRenderer rend, Material material, bool cast, bool receive)
		{
			rend.renderMode = ParticleSystemRenderMode.Billboard;
			rend.alignment = ParticleSystemRenderSpace.World;
			rend.normalDirection = 1f;
			rend.sharedMaterial = material;
			rend.shadowCastingMode = (cast ? ShadowCastingMode.On : ShadowCastingMode.Off);
			rend.receiveShadows = receive;
			rend.sortMode = ParticleSystemSortMode.OldestInFront;
			rend.minParticleSize = 0.0001f;
			rend.maxParticleSize = 999999f;
			rend.alignment = ParticleSystemRenderSpace.Facing;
		}

		private void SetMaterialDust(ParticleSystemRenderer rend, List<Material> mats)
		{
			if (mats.Count == 0)
			{
				UnityEngine.Debug.Log("Define dust material");
			}
			else if (mats.Count == 1)
			{
				rend.sharedMaterial = mats[0];
			}
			else
			{
				rend.sharedMaterial = mats[UnityEngine.Random.Range(0, mats.Count - 1)];
			}
		}
	}
	[AddComponentMenu("RayFire/Rayfire Gun")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-gun-component/")]
	public class RayfireGun : MonoBehaviour
	{
		[HideInInspector]
		public bool showRay = true;

		[HideInInspector]
		public bool showHit = true;

		[HideInInspector]
		public bool shooting;

		[Header("  Properties")]
		[Space(2f)]
		public AxisType axis;

		[Range(0f, 100f)]
		public float maxDistance = 50f;

		public Transform target;

		[Header("  Burst")]
		[Space(2f)]
		[Range(2f, 20f)]
		public int rounds = 1;

		[Range(0.01f, 5f)]
		public float rate = 0.3f;

		[Header("  Impact")]
		[Space(2f)]
		[Range(0f, 5f)]
		public float strength = 1f;

		[Range(0f, 3f)]
		public float radius = 1f;

		public bool affectInactive = true;

		[Header("  Damage")]
		[Space(2f)]
		[Range(0f, 100f)]
		public float damage = 1f;

		[Header("  Impact particles")]
		[Space(2f)]
		public bool debris = true;

		public bool dust = true;

		[Header("  Impact flash")]
		[Space(2f)]
		public bool enableImpactFlash = true;

		[Range(0.1f, 5f)]
		public float flashStrength = 0.6f;

		[Range(0.01f, 10f)]
		public float flashRange = 6f;

		[Range(0.01f, 2f)]
		public float flashDistance = 0.4f;

		public Color flashColor = new Color(1f, 1f, 0.8f);

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		public RFShotEvent shotEvent = new RFShotEvent();

		public UnityEngine.Vector3 ShootVector
		{
			get
			{
				if (target != null)
				{
					return (target.position - base.transform.position).normalized;
				}
				if (axis == AxisType.XRed)
				{
					return base.transform.right;
				}
				if (axis == AxisType.YGreen)
				{
					return base.transform.up;
				}
				if (axis == AxisType.ZBlue)
				{
					return base.transform.forward;
				}
				return base.transform.up;
			}
		}

		public void StartShooting()
		{
			if (!shooting)
			{
				StartCoroutine(StartShootCor());
			}
		}

		private IEnumerator StartShootCor()
		{
			int shootId = 0;
			shooting = true;
			while (shooting)
			{
				Shoot(shootId);
				shootId++;
				yield return new WaitForSeconds(rate);
			}
		}

		public void StopShooting()
		{
			shooting = false;
		}

		public void Shoot(int shootId = 1)
		{
			UnityEngine.Vector3 shootVector = ShootVector;
			if (shootId > 1)
			{
				shootVector = ShootVector;
			}
			UnityEngine.Vector3 position = base.transform.position;
			Shoot(position, shootVector);
		}

		public void Shoot(UnityEngine.Vector3 shootPosition, UnityEngine.Vector3 shootVector)
		{
			QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.Ignore;
			RaycastHit hitInfo;
			bool num = Physics.Raycast(shootPosition, shootVector, out hitInfo, maxDistance, mask, queryTriggerInteraction);
			UnityEngine.Vector3 point = hitInfo.point;
			UnityEngine.Vector3 normal = hitInfo.normal;
			if (!num || (tagFilter != "Untagged" && base.tag != hitInfo.transform.tag))
			{
				return;
			}
			if (enableImpactFlash)
			{
				ImpactFlash(hitInfo.point, hitInfo.normal);
			}
			RayfireRigid component = hitInfo.transform.GetComponent<RayfireRigid>();
			if (!(component == null) && (!component.damage.enable || !component.ApplyDamage(damage, point, radius) || !component.HasFragments || Physics.Raycast(shootPosition, shootVector, out hitInfo, maxDistance, mask, queryTriggerInteraction)))
			{
				point = hitInfo.point;
				normal = hitInfo.normal;
				component = hitInfo.transform.GetComponent<RayfireRigid>();
				if (!(component == null))
				{
					List<RayfireRigid> rigidList = ActivationCheck(component, point, radius);
					ImpactHit(rigidList, point, shootVector, hitInfo.normal);
					ImpactDebris(component, point, normal);
					ImpactDust(component, point, normal);
					shotEvent.InvokeLocalEvent(this);
					RFShotEvent.InvokeGlobalEvent(this);
				}
			}
		}

		public void Burst()
		{
			if (!shooting)
			{
				StartCoroutine(BurstCor());
			}
		}

		private IEnumerator BurstCor()
		{
			shooting = true;
			for (int i = 0; i < rounds; i++)
			{
				if (!shooting)
				{
					break;
				}
				Shoot(i);
				yield return new WaitForSeconds(rate);
			}
		}

		private void ImpactFlash(UnityEngine.Vector3 position, UnityEngine.Vector3 normal)
		{
			UnityEngine.Vector3 position2 = normal * flashDistance + position;
			GameObject obj = new GameObject("impactFlash");
			obj.transform.position = position2;
			Light light = obj.AddComponent<Light>();
			light.color = flashColor;
			light.intensity = flashStrength;
			light.range = flashRange;
			light.shadows = LightShadows.Hard;
			UnityEngine.Object.Destroy(obj, 0.2f);
		}

		private void ImpactDebris(RayfireRigid source, UnityEngine.Vector3 impactPos, UnityEngine.Vector3 impactNormal)
		{
			if (!debris || !source.HasDebris)
			{
				return;
			}
			foreach (RayfireDebris debris in source.debrisList)
			{
				if (debris.onImpact)
				{
					RFParticles.CreateDebrisImpact(debris, impactPos, impactNormal);
				}
			}
		}

		private void ImpactDust(RayfireRigid source, UnityEngine.Vector3 impactPos, UnityEngine.Vector3 impactNormal)
		{
			if (!dust || !source.HasDust)
			{
				return;
			}
			foreach (RayfireDust dust in source.dustList)
			{
				if (dust.onImpact)
				{
					RFParticles.CreateDustImpact(dust, impactPos, impactNormal);
				}
			}
		}

		private List<RayfireRigid> ActivationCheck(RayfireRigid scrTarget, UnityEngine.Vector3 position, float radius)
		{
			List<RayfireRigid> list = new List<RayfireRigid>();
			if (scrTarget != null)
			{
				list.Add(scrTarget);
			}
			if (radius > 0f)
			{
				Collider[] array = Physics.OverlapSphere(position, radius, mask);
				foreach (Collider collider in array)
				{
					if (!(tagFilter != "Untagged") || !(collider.tag != tagFilter))
					{
						RayfireRigid component = collider.gameObject.GetComponent<RayfireRigid>();
						if (component != null && !list.Contains(component))
						{
							list.Add(component);
						}
					}
				}
			}
			foreach (RayfireRigid item in list)
			{
				ActivationCheck(item);
			}
			return list;
		}

		private static void ActivationCheck(RayfireRigid scrRigid)
		{
			if ((scrRigid.simulationType == SimType.Inactive || scrRigid.simulationType == SimType.Kinematic) && scrRigid.activation.byImpact)
			{
				scrRigid.Activate();
			}
		}

		private void ImpactHit(List<RayfireRigid> rigidList, UnityEngine.Vector3 impactPos, UnityEngine.Vector3 shootVector, UnityEngine.Vector3 impactNormal)
		{
			if (!(strength > 0f))
			{
				return;
			}
			foreach (RayfireRigid rigid in rigidList)
			{
				if ((affectInactive || rigid.simulationType != SimType.Inactive) && rigid.physics.rigidBody != null && !rigid.physics.rigidBody.isKinematic)
				{
					UnityEngine.Vector3 force = shootVector * strength;
					rigid.physics.rigidBody.AddForceAtPosition(force, impactPos, ForceMode.VelocityChange);
				}
			}
		}
	}
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Man")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-man-component/")]
	public class RayfireMan : MonoBehaviour
	{
		public static RayfireMan inst;

		[Space(2f)]
		[Header("  Gravity")]
		[Space(2f)]
		public bool setGravity;

		[Range(0f, 1f)]
		public float multiplier = 1f;

		[Header("  Materials")]
		[Space(2f)]
		[Range(0f, 1f)]
		public float minimumMass = 0.1f;

		[Range(0f, 400f)]
		public float maximumMass = 400f;

		public RFMaterialPresets materialPresets = new RFMaterialPresets();

		[Header("  Demolition")]
		[Space(2f)]
		[Range(0f, 5f)]
		public float globalSolidity = 1f;

		[Tooltip("Maximum time in milliseconds per frame allowed to be used for demolitions. Off if 0.")]
		[Range(0f, 0.1f)]
		public float timeQuota = 0.033f;

		[HideInInspector]
		public float maxTimeThisFrame;

		[Space(1f)]
		public RFManDemolition advancedDemolitionProperties = new RFManDemolition();

		[Header("  Fragment pooling")]
		[Space(2f)]
		public bool enablePooling = true;

		[Range(1f, 500f)]
		public int poolLimit = 60;

		[HideInInspector]
		public int poolRate = 2;

		[HideInInspector]
		public List<RayfireRigid> poolList = new List<RayfireRigid>();

		[HideInInspector]
		public Transform poolRoot;

		[HideInInspector]
		public RayfireRigid poolInstance;

		[Header("  About")]
		[HideInInspector]
		public Transform transForm;

		public static int buildMajor = 1;

		public static int buildMinor = 20;

		[HideInInspector]
		public List<string> layers;

		public static bool MaxAmountCheck => inst.advancedDemolitionProperties.currentAmount < inst.advancedDemolitionProperties.maximumAmount;

		private void Awake()
		{
			SetInstance();
		}

		private void LateUpdate()
		{
			maxTimeThisFrame = 0f;
		}

		private void SetInstance()
		{
			if (inst == null)
			{
				inst = this;
			}
			if (inst != null)
			{
				if (inst == this)
				{
					SetVariables();
					StartPooling();
				}
				if (inst != this)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		private void SetVariables()
		{
			transForm = GetComponent<Transform>();
			advancedDemolitionProperties.currentAmount = 0;
			SetGravity();
			materialPresets.SetMaterials();
			SetLayers();
		}

		private void SetGravity()
		{
			if (setGravity)
			{
				Physics.gravity = -9.81f * multiplier * UnityEngine.Vector3.up;
			}
		}

		public static void RayFireManInit()
		{
			if (inst == null)
			{
				inst = new GameObject("RayFireMan").AddComponent<RayfireMan>();
			}
			EditorCreate();
		}

		private static void EditorCreate()
		{
			if (!Application.isPlaying)
			{
				inst.SetInstance();
			}
		}

		private void SetLayers()
		{
			layers = new List<string>();
			for (int i = 0; i < 32; i++)
			{
				string text = LayerMask.LayerToName(i);
				if (text.Length > 0)
				{
					layers.Add(text);
				}
			}
		}

		private void StartPooling()
		{
			CreatePoolRoot();
			CreateInstance();
			if (Application.isPlaying && enablePooling)
			{
				StartCoroutine(StartPoolingCor());
			}
		}

		private void CreatePoolRoot()
		{
			if (poolRoot == null)
			{
				GameObject gameObject = new GameObject("Pool");
				poolRoot = gameObject.transform;
				poolRoot.position = base.transform.position;
				poolRoot.parent = base.transform;
			}
		}

		private IEnumerator StartPoolingCor()
		{
			poolList.Clear();
			WaitForSeconds delay = new WaitForSeconds(0.5f);
			while (enablePooling)
			{
				if (poolList.Count < poolLimit)
				{
					for (int i = 0; i < poolRate; i++)
					{
						poolList.Add(CreatePoolObject());
					}
				}
				yield return delay;
			}
		}

		private RayfireRigid CreatePoolObject()
		{
			if (poolInstance == null)
			{
				CreateInstance();
			}
			return UnityEngine.Object.Instantiate(poolInstance, poolRoot);
		}

		private void CreateInstance()
		{
			if (!(poolInstance != null))
			{
				poolInstance = CreateRigidInstance();
				poolInstance.transForm.position = base.transform.position;
				poolInstance.transForm.rotation = base.transform.rotation;
				poolInstance.transForm.parent = poolRoot;
			}
		}

		public static RayfireRigid CreateRigidInstance()
		{
			GameObject gameObject = new GameObject("Instance");
			gameObject.SetActive(value: false);
			MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
			MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
			RayfireRigid rayfireRigid = gameObject.AddComponent<RayfireRigid>();
			rayfireRigid.initialization = RayfireRigid.InitType.AtStart;
			Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rayfireRigid.transForm = gameObject.transform;
			rayfireRigid.meshFilter = meshFilter;
			rayfireRigid.meshRenderer = meshRenderer;
			rayfireRigid.physics.rigidBody = rigidbody;
			return rayfireRigid;
		}

		public RayfireRigid GetPoolObject()
		{
			RayfireRigid result;
			if (poolList.Count > 0)
			{
				result = poolList[poolList.Count - 1];
				poolList.RemoveAt(poolList.Count - 1);
			}
			else
			{
				result = CreatePoolObject();
			}
			return result;
		}

		public static void DestroyFragment(RayfireRigid scr, Transform tm, float time = 0f)
		{
			if (Application.isPlaying)
			{
				inst.advancedDemolitionProperties.currentAmount--;
			}
			scr.gameObject.SetActive(value: false);
			if (scr.reset.action == RFReset.PostDemolitionType.DestroyWithDelay)
			{
				DestroyOp(scr, tm, time);
			}
		}

		public static void DestroyGo(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		public static void DestroyOp(RayfireRigid scr, Transform tm, float time = 0f)
		{
			if (time == 0f)
			{
				time = scr.reset.destroyDelay;
			}
			scr.reset.toBeDestroyed = true;
			if (time <= 0f)
			{
				UnityEngine.Object.Destroy(scr.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(scr.gameObject, time);
			}
			if (tm != null && tm.childCount == 0)
			{
				UnityEngine.Object.Destroy(tm.gameObject);
			}
		}
	}
	[Serializable]
	public class RFCache
	{
		public string name;

		public List<bool> act;

		public List<UnityEngine.Vector3> pos;

		public List<UnityEngine.Quaternion> rot;

		public Transform transform;

		public RFCache(Transform parent, Transform tm)
		{
			act = new List<bool>();
			pos = new List<UnityEngine.Vector3>();
			rot = new List<UnityEngine.Quaternion>();
			transform = tm;
			name = tm.name;
			if (tm.parent != parent)
			{
				Transform parent2 = tm.parent;
				while (parent != parent2)
				{
					name = name.Insert(0, "/");
					name = name.Insert(0, parent2.name);
					parent2 = parent2.parent;
				}
			}
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Recorder")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-recorder-component/")]
	public class RayfireRecorder : MonoBehaviour
	{
		public enum AnimatorType
		{
			None = 0,
			Record = 2,
			Play = 8
		}

		[Space(5f)]
		public AnimatorType mode;

		[Header("Record Properties")]
		public bool recordOnStart = true;

		public string clipName;

		[Range(0f, 60f)]
		public float duration = 5f;

		[Range(1f, 60f)]
		public int rate = 15;

		[Space(5f)]
		public bool reduceKeys = true;

		[Range(0f, 0.5f)]
		public float threshold = 0.1f;

		[Header("Playback Properties")]
		public bool playOnStart;

		public AnimationClip animationClip;

		public RuntimeAnimatorController controller;

		[Header("Rigid Playback")]
		public bool setToKinematic = true;

		[Header("Private")]
		[HideInInspector]
		public bool recorder;

		[HideInInspector]
		public float recordedTime;

		private int stateNameHash;

		private string assetFolder;

		private string clipFolder = "RayFireRecords/";

		private float stepTime;

		private Animator animator;

		private List<Transform> tmList;

		private List<RFCache> cacheList;

		private List<float> timeList;

		private void Awake()
		{
			SetVariables();
		}

		private void Start()
		{
			SetRigid();
			if (mode == AnimatorType.Record && recordOnStart)
			{
				StartRecord();
			}
			else if (mode == AnimatorType.Play && playOnStart)
			{
				StartPlay();
			}
		}

		private void SetRigid()
		{
			if (mode != AnimatorType.Play)
			{
				return;
			}
			foreach (RayfireRigid item in base.gameObject.GetComponentsInChildren<RayfireRigid>().ToList())
			{
				if (!item.physics.exclude)
				{
					item.physics.recorder = true;
					if (setToKinematic && (item.simulationType != SimType.Static || item.simulationType == SimType.Kinematic))
					{
						item.simulationType = SimType.Kinematic;
						RFPhysic.SetSimulationType(item);
					}
				}
			}
		}

		private void SetVariables()
		{
			if (mode != 0)
			{
				animator = GetComponent<Animator>();
				tmList = base.gameObject.GetComponentsInChildren<Transform>(includeInactive: false).ToList();
				tmList.Remove(base.transform);
				if (tmList.Count == 0)
				{
					UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but object has no children. Mode set to None.", base.gameObject);
					mode = AnimatorType.None;
				}
				else
				{
					SetModeRecord();
					SetModePlay();
				}
			}
		}

		private void SetModeRecord()
		{
			if (mode != AnimatorType.Record)
			{
				return;
			}
			if (animator != null)
			{
				animator.runtimeAnimatorController = null;
			}
			cacheList = new List<RFCache>();
			if (tmList.Count > 0)
			{
				for (int i = 0; i < tmList.Count; i++)
				{
					cacheList.Add(new RFCache(base.transform, tmList[i]));
				}
			}
			timeList = new List<float>();
			stepTime = 1f / (float)rate;
			assetFolder = "Assets/" + clipFolder;
		}

		private void SetModePlay()
		{
			if (mode != AnimatorType.Play)
			{
				return;
			}
			if (controller == null)
			{
				UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but controller is not defined. Mode set to None.", base.gameObject);
				mode = AnimatorType.None;
				return;
			}
			if (animationClip == null)
			{
				UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but animation clip is not defined. Mode set to None.", base.gameObject);
				mode = AnimatorType.None;
				return;
			}
			bool flag = false;
			AnimationClip[] animationClips = controller.animationClips;
			for (int i = 0; i < animationClips.Length; i++)
			{
				if (animationClips[i] == animationClip)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but animation clip is not defined in controller. Mode set to None.", base.gameObject);
				mode = AnimatorType.None;
			}
			else
			{
				if (animator == null)
				{
					animator = base.gameObject.AddComponent<Animator>();
				}
				animator.updateMode = AnimatorUpdateMode.AnimatePhysics;
				animator.runtimeAnimatorController = controller;
			}
		}

		private void Reset()
		{
			clipName = base.gameObject.name;
		}

		public void StartRecord()
		{
			if (cacheList.Count != 0)
			{
				StartCoroutine(RecordCor());
			}
		}

		private IEnumerator RecordCor()
		{
			recorder = true;
			while (recorder)
			{
				timeList.Add(recordedTime);
				for (int i = 0; i < tmList.Count; i++)
				{
					if (tmList[i] != null)
					{
						cacheList[i].act.Add(tmList[i].gameObject.activeSelf);
						cacheList[i].pos.Add(tmList[i].localPosition);
						cacheList[i].rot.Add(tmList[i].localRotation);
					}
				}
				recordedTime += stepTime;
				yield return new WaitForSeconds(stepTime);
				if (duration > 0f && recordedTime > duration)
				{
					StopRecord();
				}
			}
		}

		public void StopRecord()
		{
			recorder = false;
		}

		public void StartPlay()
		{
			if (mode == AnimatorType.Play)
			{
				animator.Play(animationClip.name);
			}
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Rigid")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-rigid-component/")]
	public class RayfireRigid : MonoBehaviour
	{
		public enum InitType
		{
			ByMethod,
			AtStart
		}

		[Space(2f)]
		public InitType initialization;

		[HideInInspector]
		public bool initialized;

		[Header("  Main")]
		[Space(3f)]
		[Tooltip("Defines behaviour of object during simulation.")]
		public SimType simulationType;

		[Space(2f)]
		public ObjectType objectType;

		[Space(2f)]
		public DemolitionType demolitionType;

		[Header("  Simulation")]
		[Space(3f)]
		public RFPhysic physics = new RFPhysic();

		[Space(2f)]
		public RFActivation activation = new RFActivation();

		[Space(2f)]
		public RFRestriction restriction = new RFRestriction();

		[Header("  Demolition")]
		[Space(3f)]
		public RFLimitations limitations = new RFLimitations();

		[Space(2f)]
		public RFDemolitionMesh meshDemolition = new RFDemolitionMesh();

		[Space(2f)]
		public RFDemolitionCluster clusterDemolition = new RFDemolitionCluster();

		[Space(2f)]
		public RFReferenceDemolition referenceDemolition = new RFReferenceDemolition();

		[Space(2f)]
		public RFSurface materials = new RFSurface();

		[Space(2f)]
		public RFDamage damage = new RFDamage();

		[Header("  Common")]
		[Space(3f)]
		public RFFade fading = new RFFade();

		[Space(2f)]
		public RFReset reset = new RFReset();

		[Header("  Info")]
		[HideInInspector]
		public Mesh[] meshes;

		[HideInInspector]
		public UnityEngine.Vector3[] pivots;

		[HideInInspector]
		public RFMesh[] rfMeshes;

		[HideInInspector]
		public List<RFDictionary> subIds;

		[HideInInspector]
		public List<RayfireRigid> fragments;

		[HideInInspector]
		public UnityEngine.Quaternion cacheRotation;

		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public Transform rootChild;

		[HideInInspector]
		public Transform rootParent;

		[HideInInspector]
		public MeshFilter meshFilter;

		[HideInInspector]
		public MeshRenderer meshRenderer;

		[HideInInspector]
		public SkinnedMeshRenderer skinnedMeshRend;

		[HideInInspector]
		public List<RayfireDebris> debrisList;

		[HideInInspector]
		public List<RayfireDust> dustList;

		public RFDemolitionEvent demolitionEvent = new RFDemolitionEvent();

		public RFActivationEvent activationEvent = new RFActivationEvent();

		public RFRestrictionEvent restrictionEvent = new RFRestrictionEvent();

		public bool HasFragments
		{
			get
			{
				if (fragments != null)
				{
					return fragments.Count > 0;
				}
				return false;
			}
		}

		public bool HasMeshes
		{
			get
			{
				if (meshes != null)
				{
					return meshes.Length != 0;
				}
				return false;
			}
		}

		public bool HasRfMeshes
		{
			get
			{
				if (rfMeshes != null)
				{
					return rfMeshes.Length != 0;
				}
				return false;
			}
		}

		public bool HasDebris
		{
			get
			{
				if (debrisList != null)
				{
					return debrisList.Count > 0;
				}
				return false;
			}
		}

		public bool HasDust
		{
			get
			{
				if (dustList != null)
				{
					return dustList.Count > 0;
				}
				return false;
			}
		}

		private void Awake()
		{
			if (demolitionType == DemolitionType.Runtime && meshDemolition.meshInput == RFDemolitionMesh.MeshInputType.AtStart)
			{
				MeshInput();
			}
			if (initialization == InitType.AtStart)
			{
				AwakeMethods();
				StartMethods();
			}
		}

		private void AwakeMethods()
		{
			RayfireMan.RayFireManInit();
			SetComponentsBasic();
			if (!SetRootMesh())
			{
				RFLimitations.Checks(this);
				SetComponentsPhysics();
				if (meshDemolition.meshInput == RFDemolitionMesh.MeshInputType.AtInitialization)
				{
					MeshInput();
				}
				AwakePrecache();
				AwakePrefragment();
			}
		}

		private void StartMethods()
		{
			if (!physics.exclude)
			{
				SetObjectType();
				StartAllCoroutines();
				initialized = true;
			}
		}

		public void Initialize()
		{
			if (!initialized)
			{
				AwakeMethods();
				StartMethods();
			}
		}

		public void Default()
		{
			limitations.Reset();
			meshDemolition.Reset();
			clusterDemolition.Reset();
			limitations.birthTime = Time.time + UnityEngine.Random.Range(0f, 0.3f);
			physics.initScale = transForm.localScale;
			physics.initPosition = transForm.position;
			physics.initRotation = transForm.rotation;
			RFLimitations.SetBound(this);
		}

		private bool SetRootMesh()
		{
			if (objectType == ObjectType.MeshRoot)
			{
				if (limitations.demolished || physics.exclude)
				{
					return true;
				}
				List<Transform> list = new List<Transform>();
				for (int i = 0; i < base.transform.childCount; i++)
				{
					list.Add(base.transform.GetChild(i));
				}
				fragments = new List<RayfireRigid>();
				for (int j = 0; j < list.Count; j++)
				{
					if (list[j].GetComponent<MeshFilter>() != null)
					{
						RayfireRigid rayfireRigid = list[j].gameObject.GetComponent<RayfireRigid>();
						if (rayfireRigid == null)
						{
							rayfireRigid = list[j].gameObject.AddComponent<RayfireRigid>();
						}
						fragments.Add(rayfireRigid);
						CopyPropertiesTo(rayfireRigid);
						rayfireRigid.Initialize();
					}
				}
				RFParticles.CopyRootMeshParticles(this, fragments);
				demolitionType = DemolitionType.None;
				physics.exclude = true;
				return true;
			}
			return false;
		}

		private void SetComponentsBasic()
		{
			meshDemolition.scrShatter = (meshDemolition.useShatter ? GetComponent<RayfireShatter>() : null);
			transForm = GetComponent<Transform>();
			meshFilter = GetComponent<MeshFilter>();
			meshRenderer = GetComponent<MeshRenderer>();
			skinnedMeshRend = GetComponent<SkinnedMeshRenderer>();
			SetParticleComponents();
			if (meshFilter != null && meshRenderer == null)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
		}

		public void SetParticleComponents()
		{
			RayfireDebris[] components = GetComponents<RayfireDebris>();
			if (components.Length != 0)
			{
				for (int i = 0; i < components.Length; i++)
				{
					components[i].Initialize();
				}
				debrisList = new List<RayfireDebris>();
				for (int j = 0; j < components.Length; j++)
				{
					if (components[j].initialized)
					{
						debrisList.Add(components[j]);
						components[j].rigid = this;
					}
				}
			}
			RayfireDust[] components2 = GetComponents<RayfireDust>();
			if (components2.Length == 0)
			{
				return;
			}
			for (int k = 0; k < components2.Length; k++)
			{
				components2[k].Initialize();
			}
			dustList = new List<RayfireDust>();
			for (int l = 0; l < components2.Length; l++)
			{
				if (components2[l].initialized)
				{
					dustList.Add(components2[l]);
					components2[l].rigid = this;
				}
			}
		}

		private void SetComponentsPhysics()
		{
			if (!physics.exclude)
			{
				physics.rigidBody = GetComponent<Rigidbody>();
				physics.meshCollider = GetComponent<Collider>();
				if (objectType == ObjectType.Mesh)
				{
					RFPhysic.SetMeshCollider(this);
				}
				if ((objectType == ObjectType.NestedCluster || objectType == ObjectType.ConnectedCluster) && !RFDemolitionCluster.Clusterize(this))
				{
					physics.exclude = true;
					UnityEngine.Debug.Log("RayFire Rigid: " + base.name + " has no children with mesh. Object Excluded from simulation.", base.gameObject);
				}
				else if (simulationType != SimType.Static && physics.rigidBody == null)
				{
					physics.rigidBody = base.gameObject.AddComponent<Rigidbody>();
					physics.rigidBody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
				}
			}
		}

		private void SetObjectType()
		{
			if (objectType == ObjectType.Mesh || objectType == ObjectType.NestedCluster || objectType == ObjectType.ConnectedCluster)
			{
				Default();
				SetPhysics();
			}
		}

		private void SetPhysics()
		{
			if (!physics.exclude)
			{
				RFPhysic.SetColliderMaterial(this);
				RFPhysic.SetSimulationType(this);
				if (simulationType != SimType.Static)
				{
					RFPhysic.SetColliderConvex(this);
					RFPhysic.SetDensity(this);
					RFPhysic.SetDrag(this);
					physics.materialSolidity = physics.Solidity;
					physics.destructible = physics.Destructible;
				}
			}
		}

		public void StartAllCoroutines()
		{
			if (simulationType == SimType.Static || physics.exclude || !base.gameObject.activeSelf)
			{
				return;
			}
			if (demolitionType != 0)
			{
				StartCoroutine(limitations.DemolishableCor(this));
			}
			StartCoroutine(physics.PhysicsDataCor(this));
			if (simulationType == SimType.Inactive || simulationType == SimType.Kinematic)
			{
				if (activation.byVelocity > 0f)
				{
					StartCoroutine(activation.ActivationVelocityCor(this));
				}
				if (activation.byOffset > 0f)
				{
					StartCoroutine(activation.ActivationOffsetCor(this));
				}
			}
			if (simulationType == SimType.Inactive)
			{
				StartCoroutine(activation.InactiveCor(this));
			}
			RFRestriction.InitRestriction(this);
		}

		public void MeshInput()
		{
			if (objectType == ObjectType.Mesh)
			{
				SetComponentsBasic();
				RFFragment.InputMesh(this);
			}
		}

		private void AwakePrecache()
		{
			if (demolitionType == DemolitionType.AwakePrecache && objectType == ObjectType.Mesh)
			{
				RFDemolitionMesh.CacheInstant(this);
			}
		}

		private void AwakePrefragment()
		{
			if (demolitionType == DemolitionType.AwakePrefragment && objectType == ObjectType.Mesh)
			{
				RFDemolitionMesh.CacheInstant(this);
				Prefragment();
			}
		}

		public void PrefabPrecache()
		{
			if (demolitionType != DemolitionType.ManualPrefabPrecache || objectType != 0)
			{
				return;
			}
			SetComponentsBasic();
			RFDemolitionMesh.CacheInstant(this);
			if (HasMeshes)
			{
				rfMeshes = new RFMesh[meshes.Length];
				for (int i = 0; i < meshes.Length; i++)
				{
					rfMeshes[i] = new RFMesh(meshes[i], meshDemolition.compressPrefab);
				}
			}
			meshes = null;
		}

		public void ManualPrecache()
		{
			if (demolitionType == DemolitionType.ManualPrecache && objectType == ObjectType.Mesh)
			{
				SetComponentsBasic();
				SetComponentsPhysics();
				RFDemolitionMesh.CacheInstant(this);
			}
			else if (demolitionType == DemolitionType.ManualPrecache && objectType != 0)
			{
				UnityEngine.Debug.Log("RayFire Rigid: " + base.name + " Object Type is not Mesh. Set to Mesh type to Precache.", base.gameObject);
			}
		}

		public void ManualPrefragment()
		{
			if (demolitionType == DemolitionType.ManualPrefragment && objectType == ObjectType.Mesh)
			{
				SetComponentsBasic();
				SetComponentsPhysics();
				DeleteCache();
				RFDemolitionMesh.CacheInstant(this);
				Prefragment();
			}
			else if (demolitionType == DemolitionType.ManualPrefragment && objectType != 0)
			{
				UnityEngine.Debug.Log("RayFire Rigid: " + base.name + " Object Type is not Mesh. Set to Mesh type to Prefragment.", base.gameObject);
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (DemolitionState() && CollisionDemolition(collision))
			{
				limitations.demolitionShould = true;
			}
		}

		private bool CollisionDemolition(Collision collision)
		{
			if (collision.rigidbody != null && collision.rigidbody.isKinematic && collision.impulse.magnitude > (float)physics.materialSolidity * limitations.solidity * RayfireMan.inst.globalSolidity * 7f)
			{
				limitations.contactPoint = collision.contacts[0].point;
				return true;
			}
			for (int i = 0; i < collision.contacts.Length; i++)
			{
				limitations.contactPoint = collision.contacts[i].point;
				if (collision.relativeVelocity.magnitude > (float)physics.materialSolidity * limitations.solidity * RayfireMan.inst.globalSolidity)
				{
					return true;
				}
				if (damage.enable && damage.collect && ApplyDamage(collision.relativeVelocity.magnitude * damage.multiplier, limitations.contactPoint))
				{
					return true;
				}
			}
			return false;
		}

		public bool State()
		{
			if (limitations.demolished)
			{
				return false;
			}
			if (meshDemolition.runtimeCaching.inProgress)
			{
				return false;
			}
			if (meshDemolition.badMesh > RayfireMan.inst.advancedDemolitionProperties.badMeshTry)
			{
				return false;
			}
			if (!RayfireMan.MaxAmountCheck)
			{
				return false;
			}
			if (limitations.depth > 0 && limitations.currentDepth >= limitations.depth)
			{
				return false;
			}
			if (limitations.bboxSize < limitations.size)
			{
				return false;
			}
			if (Time.time - limitations.birthTime < limitations.time)
			{
				return false;
			}
			if (fading.state == 2)
			{
				return false;
			}
			return true;
		}

		public bool DemolitionState()
		{
			if (demolitionType == DemolitionType.None)
			{
				return false;
			}
			if (!physics.destructible)
			{
				return false;
			}
			if (!State())
			{
				return false;
			}
			if (RayfireMan.inst.timeQuota > 0f && RayfireMan.inst.maxTimeThisFrame > RayfireMan.inst.timeQuota)
			{
				return false;
			}
			return true;
		}

		public void Demolish()
		{
			if (!initialized)
			{
				Initialize();
			}
			if (simulationType == SimType.Static)
			{
				return;
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			transForm.position = physics.position;
			transForm.rotation = physics.rotation;
			if (RFReferenceDemolition.DemolishReference(this) && RFDemolitionMesh.DemolishMesh(this))
			{
				RFDemolitionCluster.DemolishCluster(this);
				if (!limitations.demolished)
				{
					demolitionType = DemolitionType.None;
					UnityEngine.Debug.Log("Demolish Object error: " + base.gameObject.name, base.gameObject);
					return;
				}
				activation.CheckConnectivity();
				InitFragments();
				RayfireMan.inst.maxTimeThisFrame += Time.realtimeSinceStartup - realtimeSinceStartup;
				RFParticles.InitDemolitionParticles(this);
				demolitionEvent.InvokeLocalEvent(this);
				RFDemolitionEvent.InvokeGlobalEvent(this);
				RayfireMan.DestroyFragment(this, rootParent);
			}
		}

		public void CopyPropertiesTo(RayfireRigid toScr)
		{
			toScr.objectType = objectType;
			if (objectType == ObjectType.MeshRoot || objectType == ObjectType.SkinnedMesh)
			{
				toScr.objectType = ObjectType.Mesh;
			}
			toScr.simulationType = simulationType;
			toScr.demolitionType = demolitionType;
			if (objectType != ObjectType.MeshRoot && demolitionType != 0)
			{
				toScr.demolitionType = DemolitionType.Runtime;
			}
			toScr.physics.CopyFrom(physics);
			if (objectType != ObjectType.MeshRoot && simulationType == SimType.Sleeping)
			{
				toScr.simulationType = SimType.Dynamic;
			}
			toScr.activation.CopyFrom(activation);
			toScr.restriction.CopyFrom(restriction);
			toScr.limitations.CopyFrom(limitations);
			toScr.meshDemolition.CopyFrom(meshDemolition);
			toScr.clusterDemolition.CopyFrom(clusterDemolition);
			if (objectType == ObjectType.MeshRoot)
			{
				toScr.referenceDemolition.CopyFrom(referenceDemolition);
			}
			toScr.materials.CopyFrom(materials);
			toScr.damage.CopyFrom(damage);
			toScr.fading.CopyFrom(fading);
			toScr.reset.CopyFrom(this);
		}

		private void InitFragments()
		{
			if (HasFragments)
			{
				RFPhysic.SetFragmentsVelocity(this);
				RayfireMan.inst.advancedDemolitionProperties.currentAmount += fragments.Count;
				RFLimitations.SetAncestor(this);
				RFLimitations.SetDescendants(this);
				if (fading.onDemolition)
				{
					fading.DemolitionFade(fragments);
				}
			}
		}

		private void Prefragment()
		{
			DeleteFragments();
			fragments = RFDemolitionMesh.CreateFragments(this);
			if (!HasFragments)
			{
				demolitionType = DemolitionType.None;
				return;
			}
			for (int i = 0; i < fragments.Count; i++)
			{
				fragments[i].SetComponentsBasic();
				fragments[i].SetComponentsPhysics();
				fragments[i].SetObjectType();
			}
			if (rootChild != null)
			{
				rootChild.gameObject.SetActive(value: false);
			}
		}

		public void DeleteCache()
		{
			meshes = null;
			pivots = null;
			rfMeshes = null;
			subIds = new List<RFDictionary>();
		}

		public void DeleteFragments()
		{
			if (rootChild != null)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(rootChild.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(rootChild.gameObject);
				}
				rootChild = null;
			}
			fragments = null;
		}

		public void AddSlicePlane(UnityEngine.Vector3[] slicePlane)
		{
			if (slicePlane.Length % 2 != 1)
			{
				limitations.slicePlanes.AddRange(slicePlane);
			}
		}

		public void SliceObjectByPlanes()
		{
			DeleteCache();
			DeleteFragments();
			RFFragment.SliceMeshes(ref meshes, ref pivots, ref subIds, this, limitations.slicePlanes);
			limitations.slicePlanes.Clear();
			if (HasMeshes)
			{
				fragments = CreateSlices();
				limitations.demolished = true;
				InitFragments();
				demolitionEvent.InvokeLocalEvent(this);
				RFDemolitionEvent.InvokeGlobalEvent(this);
				RayfireMan.DestroyFragment(this, rootParent);
			}
		}

		private List<RayfireRigid> CreateSlices()
		{
			RFLimitations.CreateRoot(this);
			List<RayfireRigid> list = new List<RayfireRigid>();
			int layer = meshDemolition.GetLayer(this);
			string text = base.gameObject.tag;
			string text2 = base.gameObject.name + "_sl_";
			for (int i = 0; i < meshes.Length; i++)
			{
				RayfireRigid poolObject = RayfireMan.inst.GetPoolObject();
				poolObject.transform.position = transForm.position + pivots[i];
				poolObject.transform.parent = rootChild;
				poolObject.name = text2 + i;
				poolObject.gameObject.tag = text;
				poolObject.gameObject.layer = layer;
				poolObject.meshFilter.sharedMesh = meshes[i];
				poolObject.meshFilter.sharedMesh.name = text2 + i;
				poolObject.rootParent = rootChild;
				CopyPropertiesTo(poolObject);
				RFParticles.CopyParticles(this, poolObject);
				if (RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > 0f && RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > meshes[i].bounds.size.magnitude)
				{
					poolObject.meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
				}
				poolObject.gameObject.SetActive(value: true);
				RFSurface.SetMaterial(subIds, meshRenderer.sharedMaterials, materials, poolObject.meshRenderer, i, meshes.Length);
				poolObject.limitations.currentDepth = limitations.currentDepth + 1;
				MeshCollider meshCollider = poolObject.physics.meshCollider as MeshCollider;
				if (meshCollider != null)
				{
					meshCollider.sharedMesh = meshes[i];
					meshCollider.name = meshes[i].name;
				}
				list.Add(poolObject);
			}
			DeleteCache();
			return list;
		}

		public void CacheFrames()
		{
			StartCoroutine(meshDemolition.RuntimeCachingCor(this));
		}

		public bool ApplyDamage(float damageValue, UnityEngine.Vector3 damagePoint, float damageRadius = 0f)
		{
			return RFDamage.ApplyDamage(this, damageValue, damagePoint, damageRadius);
		}

		public void Activate()
		{
			RFActivation.Activate(this);
		}

		public void Fade()
		{
			RFFade.Fade(this);
		}

		public void ResetRigid()
		{
			RFReset.ResetRigid(this);
		}

		public void DestroyCollider(Collider col)
		{
			UnityEngine.Object.Destroy(col);
		}

		public void DestroyObject(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		public void DestroyRigid(RayfireRigid rigid)
		{
			UnityEngine.Object.Destroy(rigid);
		}

		public void DestroyRb(Rigidbody rb)
		{
			UnityEngine.Object.Destroy(rb);
		}

		public GameObject InstantiateGo(GameObject go)
		{
			return UnityEngine.Object.Instantiate(go);
		}

		public Mesh InstantiateMesh(Mesh mesh)
		{
			return UnityEngine.Object.Instantiate(mesh);
		}
	}
	[AddComponentMenu("RayFire/Rayfire Shatter")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-shatter-component/")]
	public class RayfireShatter : MonoBehaviour
	{
		public enum PrefabMode
		{
			Scene,
			Asset,
			PrefabEditingMode
		}

		[Header("  Fragments")]
		[Space(2f)]
		public FragType type;

		[Space(2f)]
		public RFVoronoi voronoi = new RFVoronoi();

		[Space(2f)]
		public RFSplinters splinters = new RFSplinters();

		[Space(2f)]
		public RFSplinters slabs = new RFSplinters();

		[Space(2f)]
		public RFRadial radial = new RFRadial();

		[Space(2f)]
		public RFCustom custom = new RFCustom();

		[Space(2f)]
		public RFSlice slice = new RFSlice();

		[Space(2f)]
		public RFTets tets = new RFTets();

		[Header("  Properties")]
		[Space(2f)]
		[Tooltip("Editor: Allows to fragment complex multi element hi poly meshes with topology issues like open edges and unwelded vertices.")]
		public FragmentMode mode = FragmentMode.Editor;

		[Space(2f)]
		public RFSurface material = new RFSurface();

		public RFShatterCluster clusters = new RFShatterCluster();

		public RFShatterAdvanced advanced = new RFShatterAdvanced();

		[Header("  Export to asset")]
		[Space(2f)]
		public RFMeshExport export = new RFMeshExport();

		[Header("Center")]
		[HideInInspector]
		public bool showCenter;

		[HideInInspector]
		public UnityEngine.Vector3 centerPosition;

		[HideInInspector]
		public UnityEngine.Quaternion centerDirection;

		[Header("Components")]
		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public MeshFilter meshFilter;

		[HideInInspector]
		public MeshRenderer meshRenderer;

		[HideInInspector]
		public SkinnedMeshRenderer skinnedMeshRend;

		[Header("Variables")]
		[HideInInspector]
		public Mesh[] meshes;

		[HideInInspector]
		public UnityEngine.Vector3[] pivots;

		[HideInInspector]
		public List<Transform> rootChildList = new List<Transform>();

		[HideInInspector]
		public List<GameObject> fragmentsAll = new List<GameObject>();

		[HideInInspector]
		public List<GameObject> fragmentsLast = new List<GameObject>();

		[HideInInspector]
		public List<RFDictionary> origSubMeshIdsRF = new List<RFDictionary>();

		[HideInInspector]
		public int shatterMode = 1;

		[HideInInspector]
		public bool colorPreview;

		[HideInInspector]
		public bool scalePreview = true;

		[HideInInspector]
		public float previewScale;

		[HideInInspector]
		public float size;

		[HideInInspector]
		public float rescaleFix = 1f;

		[HideInInspector]
		public UnityEngine.Vector3 originalScale;

		[HideInInspector]
		public Bounds bound;

		private static float minSize = 0.01f;

		[HideInInspector]
		public bool resetState;

		private void Reset()
		{
			ResetCenter();
		}

		private void SetVariables()
		{
			size = 0f;
			rescaleFix = 1f;
			originalScale = transForm.localScale;
		}

		private bool DefineComponents()
		{
			if (base.gameObject.scene.rootCount == 0)
			{
				UnityEngine.Debug.Log("Shatter component unable to fragment prefab because prefab unable to store Unity mesh. Fragment prefab in scene.");
				return false;
			}
			meshFilter = GetComponent<MeshFilter>();
			skinnedMeshRend = GetComponent<SkinnedMeshRenderer>();
			if (meshFilter == null && skinnedMeshRend == null)
			{
				UnityEngine.Debug.Log("No mesh");
				return false;
			}
			if (meshFilter != null && meshFilter.sharedMesh == null)
			{
				UnityEngine.Debug.Log("No mesh");
				return false;
			}
			if (skinnedMeshRend != null && skinnedMeshRend.sharedMesh == null)
			{
				UnityEngine.Debug.Log("No mesh");
				return false;
			}
			if (meshFilter != null && !meshFilter.sharedMesh.isReadable)
			{
				UnityEngine.Debug.Log("Mesh is not readable. Open Import Settings and turn On Read/Write Enabled", meshFilter.gameObject);
				return false;
			}
			transForm = GetComponent<Transform>();
			origSubMeshIdsRF = new List<RFDictionary>();
			if (skinnedMeshRend == null)
			{
				meshRenderer = GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
				}
				bound = meshRenderer.bounds;
			}
			if (skinnedMeshRend != null)
			{
				bound = skinnedMeshRend.bounds;
			}
			return true;
		}

		public Bounds GetBound()
		{
			if (meshRenderer == null)
			{
				meshRenderer = GetComponent<MeshRenderer>();
				if (meshRenderer != null)
				{
					return meshRenderer.bounds;
				}
				if (skinnedMeshRend == null)
				{
					skinnedMeshRend = GetComponent<SkinnedMeshRenderer>();
					if (skinnedMeshRend != null)
					{
						return skinnedMeshRend.bounds;
					}
				}
				return default(Bounds);
			}
			return meshRenderer.bounds;
		}

		private static PrefabMode GetPrefabMode(GameObject go)
		{
			if (go.scene.path.EndsWith(".prefab"))
			{
				return PrefabMode.Asset;
			}
			if (string.IsNullOrEmpty(go.scene.path))
			{
				return PrefabMode.PrefabEditingMode;
			}
			return PrefabMode.Scene;
		}

		public void Fragment()
		{
			if (DefineComponents())
			{
				SetVariables();
				ScaleCheck();
				RFFragment.CacheMeshes(ref meshes, ref pivots, ref origSubMeshIdsRF, this);
				if (meshes != null)
				{
					fragmentsLast = CreateFragments();
					fragmentsAll.AddRange(fragmentsLast);
					transForm.localScale = originalScale;
				}
			}
		}

		private List<GameObject> CreateFragments()
		{
			if (meshes == null)
			{
				return null;
			}
			GameObject[] array = new GameObject[meshes.Length];
			string text = base.gameObject.name;
			string text2 = text + "_sh_";
			GameObject gameObject = new GameObject(text + "_root");
			gameObject.transform.position = transForm.position;
			gameObject.transform.rotation = transForm.rotation;
			gameObject.transform.parent = transForm.parent;
			rootChildList.Add(gameObject.transform);
			GameObject gameObject2;
			if (advanced.copyComponents)
			{
				gameObject2 = UnityEngine.Object.Instantiate(base.gameObject);
				gameObject2.transform.rotation = UnityEngine.Quaternion.identity;
				gameObject2.transform.localScale = UnityEngine.Vector3.one;
				UnityEngine.Object.DestroyImmediate(gameObject2.GetComponent<RayfireShatter>());
			}
			else
			{
				gameObject2 = new GameObject();
				gameObject2.AddComponent<MeshFilter>();
				gameObject2.AddComponent<MeshRenderer>();
			}
			Material[] sharedMaterials = ((skinnedMeshRend != null) ? skinnedMeshRend.sharedMaterials : meshRenderer.sharedMaterials);
			for (int i = 0; i < meshes.Length; i++)
			{
				if (rescaleFix != 1f)
				{
					RFFragment.RescaleMesh(meshes[i], rescaleFix);
				}
				GameObject gameObject3 = UnityEngine.Object.Instantiate(gameObject2);
				gameObject3.transform.localScale = UnityEngine.Vector3.one;
				MeshRenderer component = gameObject3.GetComponent<MeshRenderer>();
				RFSurface.SetMaterial(origSubMeshIdsRF, sharedMaterials, material, component, i, meshes.Length);
				gameObject3.name = text2 + (i + 1);
				gameObject3.transform.position = transForm.position + pivots[i] / rescaleFix;
				gameObject3.transform.parent = gameObject.transform;
				MeshFilter component2 = gameObject3.GetComponent<MeshFilter>();
				component2.sharedMesh = meshes[i];
				component2.sharedMesh.name = gameObject3.name;
				MeshCollider component3 = gameObject3.GetComponent<MeshCollider>();
				if (component3 != null)
				{
					component3.sharedMesh = meshes[i];
				}
				array[i] = gameObject3;
			}
			UnityEngine.Object.DestroyImmediate(gameObject2);
			meshes = null;
			pivots = null;
			origSubMeshIdsRF = new List<RFDictionary>();
			return array.ToList();
		}

		public void DeleteFragmentsLast()
		{
			fragmentsLast.Clear();
			for (int num = fragmentsAll.Count - 1; num >= 0; num--)
			{
				if (fragmentsAll[num] == null)
				{
					fragmentsAll.RemoveAt(num);
				}
			}
			for (int num2 = rootChildList.Count - 1; num2 >= 0; num2--)
			{
				if (rootChildList[num2] == null)
				{
					rootChildList.RemoveAt(num2);
				}
			}
			if (rootChildList.Count == 0)
			{
				return;
			}
			UnityEngine.Object.DestroyImmediate(rootChildList[rootChildList.Count - 1].gameObject);
			rootChildList.RemoveAt(rootChildList.Count - 1);
			for (int num3 = fragmentsAll.Count - 1; num3 >= 0; num3--)
			{
				if (fragmentsAll[num3] == null)
				{
					fragmentsAll.RemoveAt(num3);
				}
			}
		}

		public void DeleteFragmentsAll()
		{
			fragmentsLast.Clear();
			fragmentsAll.Clear();
			for (int num = rootChildList.Count - 1; num >= 0; num--)
			{
				if (rootChildList[num] != null)
				{
					UnityEngine.Object.DestroyImmediate(rootChildList[num].gameObject);
				}
			}
			rootChildList.Clear();
		}

		public void ResetCenter()
		{
			centerPosition = UnityEngine.Vector3.zero;
			centerDirection = UnityEngine.Quaternion.identity;
		}

		private void ScaleCheck()
		{
			if (meshRenderer != null)
			{
				size = meshRenderer.bounds.size.magnitude;
			}
			if (skinnedMeshRend != null)
			{
				size = skinnedMeshRend.bounds.size.magnitude;
			}
			if (size != 0f && size < minSize)
			{
				rescaleFix = 1f / size;
				UnityEngine.Vector3 localScale = transForm.localScale * rescaleFix;
				transForm.localScale = localScale;
				UnityEngine.Debug.Log("Warning. Object " + base.name + " is too small.");
			}
		}

		public void ResetScale(float scaleValue)
		{
			if (!resetState || scaleValue != 0f)
			{
				return;
			}
			if (skinnedMeshRend != null)
			{
				skinnedMeshRend.enabled = true;
			}
			if (meshRenderer != null)
			{
				meshRenderer.enabled = true;
			}
			if (fragmentsLast.Count > 0)
			{
				foreach (GameObject item in fragmentsLast)
				{
					if (item != null)
					{
						item.transform.localScale = UnityEngine.Vector3.one;
					}
				}
			}
			resetState = false;
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Snapshot")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-snapshot-component/")]
	public class RayfireSnapshot : MonoBehaviour
	{
		[Header("  Save Properties")]
		[Space(2f)]
		public string assetName;

		public bool compress;

		[Header("  Load Properties")]
		[Space(2f)]
		public UnityEngine.Object snapshotAsset;

		[Range(0f, 1f)]
		public float sizeFilter;

		private void Reset()
		{
			assetName = base.gameObject.name;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Unyielding")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-unyielding-component/")]
	public class RayfireUnyielding : MonoBehaviour
	{
		[Header("Gizmo")]
		public bool showGizmo = true;

		public UnityEngine.Vector3 size = new UnityEngine.Vector3(1f, 1f, 1f);

		private List<RayfireRigid> rigidList;

		private void Start()
		{
			SetUnyState();
		}

		private void SetUnyState()
		{
			Collider[] array = Physics.OverlapBox(base.transform.position, size / 2f, base.transform.rotation);
			List<Transform> list = new List<Transform>();
			Collider[] array2 = array;
			foreach (Collider collider in array2)
			{
				if (!list.Contains(collider.transform))
				{
					list.Add(collider.transform);
				}
			}
			rigidList = new List<RayfireRigid>();
			foreach (Transform item in list)
			{
				RayfireRigid component = item.GetComponent<RayfireRigid>();
				if (component != null)
				{
					rigidList.Add(component);
				}
			}
			if (rigidList.Count == 0)
			{
				UnityEngine.Debug.Log("RayFire Unyielding: " + base.name + " was not used", base.gameObject);
				return;
			}
			foreach (RayfireRigid rigid in rigidList)
			{
				rigid.activation.unyielding = true;
			}
		}
	}
	[AddComponentMenu("RayFire/Rayfire Vortex")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-vortex-component/")]
	public class RayfireVortex : MonoBehaviour
	{
		[Header("Hidden")]
		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public Collider[] colliders;

		[HideInInspector]
		public List<Rigidbody> rigidbodies = new List<Rigidbody>();

		[HideInInspector]
		public List<Rigidbody> myRigidbodies = new List<Rigidbody>();

		private UnityEngine.Vector3 bot;

		private UnityEngine.Vector3 top;

		private UnityEngine.Vector3 normal;

		private UnityEngine.Vector3 direction;

		private UnityEngine.Vector3 rbPos;

		private UnityEngine.Vector3 linePoint;

		private UnityEngine.Vector3 vectorUp;

		private UnityEngine.Vector3 centerOutVector;

		private UnityEngine.Vector3 vectorCenter;

		private UnityEngine.Vector3 perpend;

		private UnityEngine.Vector3 vectorSwirl;

		private UnityEngine.Vector3 forceVector;

		private float distancePerpend;

		private float distanceBottom;

		private float upRateNow;

		private float localRadius;

		private float upRateOwn;

		private float centerRateOwn;

		private float centerRateNow;

		private float upRateDif;

		private float centerRateDif;

		private float maxRadius;

		private float axisDistance;

		private UnityEngine.Plane bottomPlane;

		private float torqueVal;

		[Header("Anchor points")]
		public UnityEngine.Vector3 topAnchor = new UnityEngine.Vector3(3f, 30f, 2f);

		public UnityEngine.Vector3 bottomAnchor = new UnityEngine.Vector3(0f, 0f, 0f);

		[Header("Gizmo")]
		[Range(0.1f, 50f)]
		public float topRadius = 15f;

		[Range(0f, 50f)]
		public float bottomRadius = 3f;

		[Header("Eye")]
		[Range(0.05f, 0.9f)]
		public float eye = 0.1f;

		[Header("Strength")]
		public bool forceByMass = true;

		[Range(1f, 10f)]
		public float stiffness = 1f;

		[Range(-40f, 40f)]
		public float swirlStrength = 10f;

		[Header("Torque")]
		public bool enableTorque = true;

		[Range(-1f, 1f)]
		public float torqueStrength = 0.5f;

		[Range(0f, 1f)]
		public float torqueVariation = 0.5f;

		[Header("Height bias")]
		public bool enableHeightBias = true;

		[Range(0f, 1f)]
		public float biasSpeed = 0.025f;

		[Range(0f, 1f)]
		public float biasSpread = 1f;

		[Header("Seed")]
		[Range(0f, 100f)]
		public int seed;

		[Header("Preview")]
		[Range(2f, 10f)]
		public int circles = 3;

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public bool topHandle;

		[Header("Filters")]
		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		private void Awake()
		{
			DefineComponents();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
			colliders = new Collider[10];
		}

		private IEnumerator VortexForceCor()
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.95f));
			while (base.enabled)
			{
				SetForce();
				yield return new WaitForSeconds(0.066f);
			}
		}

		private IEnumerator SetCollidersCor()
		{
			SetColliderGizmo();
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.95f));
			while (base.enabled)
			{
				SetColliders();
				SetRigidBodies();
				yield return new WaitForSeconds(0.3f);
			}
		}

		private void OnEnable()
		{
			StartCoroutine(SetCollidersCor());
			StartCoroutine(VortexForceCor());
		}

		private void SetColliders()
		{
			int num = Physics.OverlapCapsuleNonAlloc(bot, top, maxRadius, colliders, mask);
			if (num == colliders.Length)
			{
				colliders = new Collider[num + 30];
				Physics.OverlapCapsuleNonAlloc(bot, top, maxRadius, colliders, mask);
			}
			if (colliders.Length > num + 50)
			{
				colliders = new Collider[num - 30];
				Physics.OverlapCapsuleNonAlloc(bot, top, maxRadius, colliders, mask);
			}
		}

		private void SetColliderGizmo()
		{
			bot = transForm.TransformPoint(bottomAnchor);
			top = transForm.TransformPoint(topAnchor);
			direction = top - bot;
			normal = base.transform.up;
			axisDistance = topAnchor.y - bottomAnchor.y;
			maxRadius = topRadius;
			if (bottomRadius > topRadius)
			{
				maxRadius = bottomRadius;
			}
			bottomPlane = new UnityEngine.Plane(base.transform.up, bot);
		}

		private void SetRigidBodies()
		{
			rigidbodies.Clear();
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				if (!(collider == null) && (!(tagFilter != "Untagged") || !(collider.tag != tagFilter)))
				{
					Rigidbody attachedRigidbody = collider.attachedRigidbody;
					if (attachedRigidbody != null && !attachedRigidbody.isKinematic && !rigidbodies.Contains(attachedRigidbody))
					{
						rigidbodies.Add(attachedRigidbody);
					}
				}
			}
		}

		private void SetForce()
		{
			SetColliderGizmo();
			ForceMode mode = ForceMode.Impulse;
			if (!forceByMass)
			{
				mode = ForceMode.VelocityChange;
			}
			foreach (Rigidbody rigidbody in rigidbodies)
			{
				if (rigidbody == null)
				{
					continue;
				}
				UnityEngine.Random.InitState(rigidbody.GetInstanceID() + seed);
				rbPos = rigidbody.transform.position;
				linePoint = GetClosetLinePoint(rbPos);
				distancePerpend = UnityEngine.Vector3.Distance(linePoint, rbPos);
				distanceBottom = bottomPlane.GetDistanceToPoint(linePoint);
				upRateNow = distanceBottom / axisDistance;
				if (!bottomPlane.GetSide(linePoint))
				{
					upRateNow = 0f - upRateNow;
				}
				localRadius = Mathf.Lerp(bottomRadius, topRadius, upRateNow);
				if (!(localRadius < distancePerpend))
				{
					upRateOwn = UnityEngine.Random.Range(0.03f, 0.97f);
					centerRateOwn = UnityEngine.Random.Range(eye, 0.9f);
					if (enableHeightBias)
					{
						upRateOwn = HeightBias(upRateOwn, centerRateOwn);
					}
					centerRateNow = distancePerpend / localRadius;
					upRateDif = (upRateOwn - upRateNow) * stiffness;
					centerRateDif = (centerRateOwn - centerRateNow) * stiffness;
					vectorUp = upRateDif * (stiffness + 2f) * normal;
					centerOutVector = (rbPos - linePoint).normalized;
					vectorCenter = Mathf.Abs(swirlStrength) * centerRateDif * centerOutVector;
					perpend = UnityEngine.Vector3.Cross(normal, centerOutVector);
					vectorSwirl = swirlStrength * perpend.normalized;
					forceVector = vectorUp + vectorCenter + vectorSwirl;
					rigidbody.velocity = UnityEngine.Vector3.zero;
					rigidbody.AddForce(forceVector, mode);
					if (enableTorque)
					{
						torqueVal = (torqueStrength + UnityEngine.Random.Range(0f - torqueVariation, torqueVariation)) * 10f;
						rigidbody.AddTorque(torqueVal * swirlStrength * UnityEngine.Random.Range(0f, 1f) * transForm.up, mode);
					}
				}
			}
		}

		private UnityEngine.Vector3 GetClosetLinePoint(UnityEngine.Vector3 worldPos)
		{
			return UnityEngine.Vector3.Project(worldPos - bot, direction) + bot;
		}

		private UnityEngine.Vector3 GetParallelLinePoint(UnityEngine.Vector3 worldPos)
		{
			return UnityEngine.Vector3.Project(worldPos - bot, direction) + bot;
		}

		public static bool LinePlaneIntersection(out UnityEngine.Vector3 intersection, UnityEngine.Vector3 linePoint, UnityEngine.Vector3 lineVec, UnityEngine.Vector3 planeNormal, UnityEngine.Vector3 planePoint)
		{
			intersection = UnityEngine.Vector3.zero;
			float num = UnityEngine.Vector3.Dot(planePoint - linePoint, planeNormal);
			float num2 = UnityEngine.Vector3.Dot(lineVec, planeNormal);
			if (num2 != 0f)
			{
				float size = num / num2;
				UnityEngine.Vector3 vector = SetVectorLength(lineVec, size);
				intersection = linePoint + vector;
				return true;
			}
			return false;
		}

		private static UnityEngine.Vector3 SetVectorLength(UnityEngine.Vector3 vector, float size)
		{
			return UnityEngine.Vector3.Normalize(vector) * size;
		}

		private float HeightBias(float upRateOwnLoc, float centerRateOwnLoc)
		{
			if (biasSpread > 0f)
			{
				float num = Mathf.PerlinNoise(Time.time * biasSpeed * centerRateOwnLoc, upRateOwnLoc) * biasSpread;
				int num2 = 1;
				if ((double)UnityEngine.Random.value >= 0.5)
				{
					num2 = -1;
				}
				float num3 = num * (float)num2;
				upRateOwnLoc += num3;
				if (upRateOwnLoc > 1f)
				{
					upRateOwnLoc = ((!(upRateOwnLoc > 2f)) ? (1f - (upRateOwnLoc - 1f)) : (upRateOwnLoc - 2f));
				}
				else if (upRateOwnLoc < 0f)
				{
					upRateOwnLoc = ((!(upRateOwnLoc < -1f)) ? (0f - upRateOwnLoc) : (upRateOwnLoc + 2f));
				}
			}
			return upRateOwnLoc;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Wind")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-wind-component/")]
	public class RayfireWind : MonoBehaviour
	{
		public enum DirType
		{
			Directional,
			Point
		}

		private Transform transForm;

		private Collider[] colliders;

		private UnityEngine.Vector3 halfExtents;

		private UnityEngine.Vector3 center;

		private float offset;

		[Header("  Gizmo")]
		public UnityEngine.Vector3 gizmoSize = new UnityEngine.Vector3(30f, 2f, 50f);

		[HideInInspector]
		public bool showGizmo = true;

		[Header("  Noise")]
		[Range(1f, 100f)]
		public float globalScale = 10f;

		[Range(1f, 300f)]
		public float lengthScale = 100f;

		[Range(1f, 300f)]
		public float widthScale = 100f;

		[Range(-200f, 200f)]
		public float speed = 15f;

		[HideInInspector]
		public bool showNoise;

		[Header("  Strength")]
		[Range(-5f, 5f)]
		public float minimum;

		[Range(-5f, 5f)]
		public float maximum = 1f;

		[Range(0f, 10f)]
		public float torque = 2f;

		public bool forceByMass = true;

		[Header("  Direction")]
		[Range(0f, 180f)]
		public float divergency = 120f;

		[Range(0.01f, 2f)]
		public float turbulence = 0.5f;

		[Header("  Preview")]
		[Range(0.5f, 5f)]
		public float previewDensity = 1f;

		[Range(0.1f, 5f)]
		public float previewSize = 1f;

		[Header("  Affected Rigid Bodies")]
		[HideInInspector]
		public List<Rigidbody> rigidbodies = new List<Rigidbody>();

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		private void Awake()
		{
			DefineComponents();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
			colliders = new Collider[10];
		}

		private IEnumerator WindForceCor()
		{
			while (base.enabled)
			{
				SetColliders();
				SetRigidBodies();
				SetForce();
				yield return new WaitForSeconds(0.05f);
			}
		}

		private void OnEnable()
		{
			StartCoroutine(WindForceCor());
		}

		private void Reset()
		{
			globalScale = 10f;
		}

		private void SetColliders()
		{
			SetColliderGizmo();
			int num = Physics.OverlapBoxNonAlloc(center, halfExtents, colliders, transForm.rotation, mask);
			if (num == colliders.Length)
			{
				colliders = new Collider[num + 30];
				Physics.OverlapBoxNonAlloc(center, halfExtents, colliders, transForm.rotation, mask);
			}
			if (colliders.Length > num + 50)
			{
				colliders = new Collider[num - 30];
				Physics.OverlapBoxNonAlloc(center, halfExtents, colliders, transForm.rotation, mask);
			}
		}

		private void SetColliderGizmo()
		{
			halfExtents = gizmoSize / 2f;
			center = transForm.position;
			center.y += halfExtents.y;
		}

		private void SetRigidBodies()
		{
			rigidbodies.Clear();
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				if (!(collider == null) && (!(tagFilter != "Untagged") || !(collider.tag != tagFilter)))
				{
					Rigidbody attachedRigidbody = collider.attachedRigidbody;
					if (attachedRigidbody != null && !attachedRigidbody.isKinematic && !rigidbodies.Contains(attachedRigidbody))
					{
						rigidbodies.Add(attachedRigidbody);
					}
				}
			}
		}

		private void SetForce()
		{
			UnityEngine.Random.InitState(1);
			SetSpeed();
			ForceMode mode = ForceMode.Acceleration;
			if (forceByMass)
			{
				mode = ForceMode.Force;
			}
			foreach (Rigidbody rigidbody in rigidbodies)
			{
				UnityEngine.Vector3 position = rigidbody.transform.position;
				float val = PerlinFixedGlobal(position);
				float num = WindStrength(val) * 10f;
				UnityEngine.Vector3 vectorGlobal = GetVectorGlobal(position);
				rigidbody.AddForce(vectorGlobal * num, mode);
				if (torque > 0f)
				{
					rigidbody.AddTorque(num * torque * transForm.right, mode);
				}
			}
		}

		private UnityEngine.Vector3 GetVectorGlobal(UnityEngine.Vector3 worldPos)
		{
			return GetVectorLocal(transForm.InverseTransformPoint(worldPos));
		}

		public UnityEngine.Vector3 GetVectorLocal(UnityEngine.Vector3 localPos)
		{
			UnityEngine.Vector3 vector = base.transform.forward;
			if (divergency > 0f)
			{
				float t = PerlinCustomLocal(localPos, gizmoSize.x, gizmoSize.z, widthScale, lengthScale, globalScale * turbulence, offset + gizmoSize.z);
				float y = Mathf.Lerp(0f - divergency, divergency, t);
				vector = UnityEngine.Quaternion.Euler(0f, y, 0f) * vector;
			}
			return vector;
		}

		private float PerlinFixedGlobal(UnityEngine.Vector3 worldPos)
		{
			return PerlinFixedLocal(transForm.InverseTransformPoint(worldPos));
		}

		public float PerlinFixedLocal(UnityEngine.Vector3 localPos)
		{
			localPos.z += offset;
			float x = (localPos.x + gizmoSize.x / 2f) / widthScale * globalScale;
			float y = (localPos.z + gizmoSize.z / 2f) / lengthScale * globalScale;
			return Mathf.PerlinNoise(x, y);
		}

		public float PerlinCustomGlobal(UnityEngine.Vector3 worldPos, float SizeX, float SizeZ, float WidthScale, float LengthScale, float GlobalScale, float Offset)
		{
			return PerlinCustomLocal(transForm.InverseTransformPoint(worldPos), SizeX, SizeZ, WidthScale, LengthScale, GlobalScale, Offset);
		}

		public float PerlinCustomLocal(UnityEngine.Vector3 localPos, float SizeX, float SizeZ, float WidthScale, float LengthScale, float GlobalScale, float Offset)
		{
			localPos.z += Offset;
			float x = (localPos.x + SizeX / 2f) / WidthScale * GlobalScale;
			float y = (localPos.z + SizeZ / 2f) / LengthScale * GlobalScale;
			return Mathf.PerlinNoise(x, y);
		}

		public float WindStrength(float val)
		{
			return Mathf.Lerp(minimum, maximum, val);
		}

		private void SetSpeed()
		{
			if (speed != 0f)
			{
				offset -= 0.015f * speed;
				if (offset < -100000f || offset > 100000f)
				{
					offset = 0f;
				}
			}
		}
	}
}
namespace GlowingSwords.Scripts
{
	public static class GameObjectExtensions
	{
		public static void SetXZero(this GameObject gameObject)
		{
			if (!(gameObject == null))
			{
				UnityEngine.Vector3 localPosition = gameObject.transform.localPosition;
				localPosition.x = 0f;
				gameObject.transform.localPosition = localPosition;
			}
		}

		public static IEnumerable<GameObject> FindChildrenOnNextHierarchyEdge(this GameObject gameObject, bool isActive = true)
		{
			if (gameObject == null)
			{
				return null;
			}
			List<GameObject> list = new List<GameObject>();
			foreach (Transform item in gameObject.transform)
			{
				if (isActive && item.gameObject.activeInHierarchy)
				{
					list.Add(item.gameObject);
				}
			}
			return list;
		}

		private static List<GameObject> GetChildren(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			List<GameObject> list = new List<GameObject>();
			foreach (Transform item in go.transform)
			{
				list.Add(item.gameObject);
				foreach (Transform item2 in item)
				{
					list.Add(item2.gameObject);
					foreach (Transform item3 in item2)
					{
						list.Add(item3.gameObject);
						foreach (Transform item4 in item3)
						{
							list.Add(item4.gameObject);
							foreach (Transform item5 in item4)
							{
								list.Add(item5.gameObject);
								foreach (Transform item6 in item5)
								{
									list.Add(item6.gameObject);
								}
							}
						}
					}
				}
			}
			return list;
		}

		public static GameObject[] GetAllChildren(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			List<GameObject> children = GetChildren(go);
			for (int i = 0; i < children.Count; i++)
			{
				List<GameObject> children2 = GetChildren(children[i]);
				children.AddRange(children2);
			}
			return children.ToArray();
		}

		public static GameObject[] FindChildrenByName(this GameObject go, string nam)
		{
			if (go == null)
			{
				return null;
			}
			GameObject[] allChildren = GetAllChildren(go);
			List<GameObject> list = new List<GameObject>();
			GameObject[] array = allChildren;
			foreach (GameObject gameObject in array)
			{
				if (nam == gameObject.name && gameObject != null)
				{
					list.Add(gameObject);
				}
			}
			return list.ToArray();
		}

		public static T FindChildByType<T>(this GameObject go)
		{
			if (go == null)
			{
				return default(T);
			}
			List<T> list = go.FindChildrenByType<T>();
			if (list.Count <= 0)
			{
				return default(T);
			}
			return list[0];
		}

		public static T FindChildrenByTypeAndName<T>(this GameObject go, string name, bool onlyStartsWithName = false)
		{
			if (go == null)
			{
				return default(T);
			}
			GameObject[] allChildren = GetAllChildren(go);
			T result = default(T);
			GameObject[] array = allChildren;
			foreach (GameObject gameObject in array)
			{
				T component = gameObject.GetComponent<T>();
				if (component != null && (onlyStartsWithName ? gameObject.name.StartsWith(name) : (gameObject.name == name)))
				{
					return component;
				}
			}
			return result;
		}

		public static List<T> FindChildrenByType<T>(this GameObject go, bool needToBeActiveInHierarchy = false)
		{
			if (go == null)
			{
				return null;
			}
			GameObject[] allChildren = GetAllChildren(go);
			List<T> list = new List<T>();
			GameObject[] array = allChildren;
			foreach (GameObject gameObject in array)
			{
				if (!needToBeActiveInHierarchy || gameObject.activeInHierarchy)
				{
					T component = gameObject.GetComponent<T>();
					if (component != null && !list.Contains(component))
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public static List<Tuple<TFirst, TSecond>> FindChildrenByTypes<TFirst, TSecond>(this GameObject go, bool needToBeActiveInHierarchy = false) where TFirst : UnityEngine.Component where TSecond : UnityEngine.Component
		{
			if (go == null)
			{
				return null;
			}
			GameObject[] allChildren = GetAllChildren(go);
			List<Tuple<TFirst, TSecond>> list = new List<Tuple<TFirst, TSecond>>();
			GameObject[] array = allChildren;
			foreach (GameObject gameObject in array)
			{
				if (!needToBeActiveInHierarchy || gameObject.activeInHierarchy)
				{
					TFirst component = gameObject.GetComponent<TFirst>();
					TSecond component2 = gameObject.GetComponent<TSecond>();
					if (component != null && component2 != null && !list.Contains(new Tuple<TFirst, TSecond>(component, component2)))
					{
						list.Add(new Tuple<TFirst, TSecond>(component, component2));
					}
				}
			}
			return list;
		}

		public static GameObject[] FindChildrenStartName(this GameObject go, string nam)
		{
			if (go == null)
			{
				return null;
			}
			GameObject[] allChildren = GetAllChildren(go);
			List<GameObject> list = new List<GameObject>();
			GameObject[] array = allChildren;
			foreach (GameObject gameObject in array)
			{
				if (gameObject.name.StartsWith(nam) && gameObject != null)
				{
					list.Add(gameObject);
				}
			}
			return list.ToArray();
		}

		public static GameObject[] FindChildrenByName(this GameObject go, string[] names)
		{
			if (go == null)
			{
				return null;
			}
			List<GameObject> list = new List<GameObject>();
			foreach (string nam in names)
			{
				list.AddRange(go.FindChildrenByName(nam));
			}
			return list.ToArray();
		}

		public static IEnumerable<Image> FindImageChildrenByName(this GameObject go, string name, bool startsOnlyWithName)
		{
			if (go == null)
			{
				return null;
			}
			GameObject[] allChildren = GetAllChildren(go);
			List<Image> list = new List<Image>();
			GameObject[] array = allChildren;
			foreach (GameObject gameObject in array)
			{
				if (!((!startsOnlyWithName) ? (name != gameObject.name) : (!gameObject.name.StartsWith(name))))
				{
					Image component = gameObject.GetComponent<Image>();
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list.ToArray();
		}

		public static GameObject FindChildByName(this GameObject go, string nam)
		{
			if (go == null)
			{
				return null;
			}
			GameObject[] array = go.FindChildrenByName(nam);
			if (array.Length != 0)
			{
				return array[0];
			}
			return null;
		}

		public static Image[] FindImageChildrenByName(this GameObject go, string[] names, bool startsOnlyWithName)
		{
			if (go == null)
			{
				return null;
			}
			List<Image> list = new List<Image>();
			foreach (string name in names)
			{
				list.AddRange(go.FindImageChildrenByName(name, startsOnlyWithName));
			}
			return list.ToArray();
		}

		public static Sprite[] FindChildrenBySpriteType(this GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			return go.FindChildrenByType<Sprite>().ToArray();
		}

		public static void SetActiveRecursivelyNew(this GameObject go, bool active)
		{
			if (go == null)
			{
				return;
			}
			go.SetActive(active);
			foreach (Transform item in go.transform)
			{
				item.gameObject.SetActiveRecursivelyNew(active);
			}
		}

		public static void DestroyComponentIfPossible(this GameObject go, Type type, bool destroyImmediate = false)
		{
			if (go == null)
			{
				return;
			}
			UnityEngine.Component component = go.GetComponent(type);
			if (!(component == null))
			{
				if (destroyImmediate)
				{
					UnityEngine.Object.Destroy(component);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
			}
		}

		public static void DestroyComponentsIfPossible(this GameObject go, Type[] types, bool destroyImmediate = false)
		{
			if (types != null)
			{
				foreach (Type type in types)
				{
					go.DestroyComponentIfPossible(type, destroyImmediate);
				}
			}
		}

		public static UnityEngine.Vector3? GetMaxChildrenMeshSize(this GameObject gameObject)
		{
			List<MeshFilter> list = gameObject.FindChildrenByType<MeshFilter>();
			if (list == null)
			{
				return null;
			}
			float x2 = list.Select((MeshFilter x) => x.mesh.bounds.size.x).Max();
			float y = list.Select((MeshFilter x) => x.mesh.bounds.size.y).Max();
			float z = list.Select((MeshFilter x) => x.mesh.bounds.size.z).Max();
			return new UnityEngine.Vector3(x2, y, z);
		}
	}
	[ExecuteInEditMode]
	public class GlowingSword : MonoBehaviour
	{
		[Tooltip("Truth value which indicates whether the glowing sword is active or inactive.")]
		[SerializeField]
		private bool saberActive = true;

		private bool _lastSaberActiveStatus;

		[Tooltip("The color of the glowing sword")]
		[SerializeField]
		private Color bladeColor = Color.red;

		private List<GlowingSwordBlade> _blades;

		private Color _lastColor;

		[Tooltip("The speed at which the blade is retracted or extended when the glowing sword is activated or deactivated.")]
		public float BladeExtendSpeed = 0.4f;

		public Color BladeColor
		{
			get
			{
				return bladeColor;
			}
			set
			{
				bladeColor = (_lastColor = value);
				UpdateLightSaber();
			}
		}

		public bool SaberActive
		{
			get
			{
				return saberActive;
			}
			set
			{
				if (!saberActive.Equals(value) || _lastSaberActiveStatus != saberActive)
				{
					_lastSaberActiveStatus = (saberActive = value);
					UpdateLightSaber();
				}
			}
		}

		private void Awake()
		{
			if (!FindSetupBlades())
			{
				Setup();
			}
		}

		private void LateUpdate()
		{
			if (Time.frameCount % 3 == 0)
			{
				if (_lastSaberActiveStatus != saberActive)
				{
					SaberActive = saberActive;
				}
				if (_lastColor != bladeColor)
				{
					BladeColor = bladeColor;
				}
			}
		}

		private bool FindSetupBlades()
		{
			_blades = base.gameObject.FindChildrenByType<GlowingSwordBlade>();
			if (_blades != null && _blades.Any())
			{
				return false;
			}
			UnityEngine.Debug.LogWarning("No light saber blades found. Please add some blade children by adding a GlowingSwordBlade script.The light saber Must have at least 1 blade.");
			return true;
		}

		private void Setup()
		{
			_blades.ForEach(delegate(GlowingSwordBlade x)
			{
				x.Setup(BladeExtendSpeed, SaberActive);
			});
			UpdateLightSaber();
		}

		private void UpdateColor()
		{
			bladeColor.a = Mathf.Clamp(bladeColor.a, 0.1f, 1f);
			_blades?.ForEach(delegate(GlowingSwordBlade x)
			{
				x.Color = bladeColor;
			});
		}

		private void UpdateBlades()
		{
			_blades?.ForEach(delegate(GlowingSwordBlade glowingSwordBlade)
			{
				glowingSwordBlade.BladeActive = SaberActive;
				glowingSwordBlade.UpdateLighting();
				glowingSwordBlade.UpdateSaberSize();
			});
		}

		public void UpdateLightSaber()
		{
			UpdateColor();
			UpdateBlades();
		}

		public void ToggleActive()
		{
			SaberActive = !SaberActive;
		}
	}
	public class GlowingSwordBlade : MonoBehaviour
	{
		private bool _animationRunning;

		private Color _color = Color.red;

		private Light _light;

		private bool _bladeActive;

		private float _extendDelta;

		private float _localXScale;

		private float _localZScale;

		private float _minScale;

		private float _maxScale;

		private float _scaleCurrent;

		private static readonly int ColorPropertyIndex = Shader.PropertyToID("_Color");

		private MeshRenderer _meshRenderer;

		private MeshRenderer MeshRenderer
		{
			get
			{
				if (_meshRenderer == null)
				{
					_meshRenderer = base.gameObject.GetComponent<MeshRenderer>();
				}
				if (_meshRenderer != null)
				{
					return _meshRenderer;
				}
				UnityEngine.Debug.LogError("No mesh renderer found.");
				return null;
			}
		}

		public bool BladeActive
		{
			get
			{
				return _bladeActive;
			}
			set
			{
				if (!_bladeActive.Equals(value))
				{
					_bladeActive = value;
					_extendDelta = (_bladeActive ? Mathf.Abs(_extendDelta) : (0f - Mathf.Abs(_extendDelta)));
					if (!Application.isPlaying && Application.isEditor)
					{
						ForceSetActive(_bladeActive);
					}
					else
					{
						_animationRunning = true;
					}
				}
			}
		}

		public Color Color
		{
			get
			{
				return _color;
			}
			set
			{
				_color = value;
				UpdateLight();
				Material[] materials = GetMaterials();
				if (materials[0] == null)
				{
					UnityEngine.Debug.LogError("No material found. Please attach the glowing sword blade material.");
				}
				else
				{
					materials[0].SetColor(ColorPropertyIndex, _color);
				}
			}
		}

		public void Setup(float extendSpeed, bool active)
		{
			Material[] materials = GetMaterials();
			Material material = materials.FirstOrDefault();
			if (material == null)
			{
				UnityEngine.Debug.LogError("No material was set to glowing sword blade. Assign a blade material to the blade.");
				return;
			}
			materials[0] = new Material(material);
			_light = base.gameObject.GetComponentInChildren<Light>();
			_bladeActive = active;
			if (_light == null)
			{
				UnityEngine.Debug.LogWarning(new NullReferenceException("_light not found."));
				return;
			}
			UnityEngine.Vector3 localScale = base.gameObject.transform.localScale;
			_localXScale = localScale.x;
			_localZScale = localScale.z;
			_minScale = 0f;
			_maxScale = localScale.y;
			_extendDelta = _maxScale / extendSpeed;
			_extendDelta = (active ? Mathf.Abs(_extendDelta) : (0f - Mathf.Abs(_extendDelta)));
			ForceSetActive(active);
		}

		private void ForceSetActive(bool active)
		{
			UpdateBladeScaleHeight(active ? 1f : 0f);
			base.gameObject.SetActive(active);
		}

		private void Update()
		{
			if (_animationRunning)
			{
				UpdateSaberSize();
			}
		}

		private void UpdateBladeScaleHeight(float deltaScale)
		{
			_scaleCurrent = deltaScale;
			base.gameObject.transform.localScale = new UnityEngine.Vector3(_localXScale, _scaleCurrent, _localZScale);
		}

		private void UpdateLight()
		{
			if (_light != null)
			{
				_light.color = _color;
			}
		}

		public void UpdateSaberSize()
		{
			_scaleCurrent += _extendDelta * Time.deltaTime;
			_scaleCurrent = Mathf.Clamp(_scaleCurrent, _minScale, _maxScale);
			UpdateBladeScaleHeight(_scaleCurrent);
			_bladeActive = _scaleCurrent > 0f;
			if (_bladeActive && !base.gameObject.activeSelf)
			{
				base.gameObject.SetActive(value: true);
			}
			else if (!_bladeActive && base.gameObject.activeSelf)
			{
				base.gameObject.SetActive(value: false);
				_animationRunning = false;
			}
			if (_animationRunning && _scaleCurrent >= 1f)
			{
				_animationRunning = false;
			}
		}

		public void UpdateLighting()
		{
			if (_light == null)
			{
				UnityEngine.Debug.LogWarning("GlowingSword.UpdateLighting");
			}
			else
			{
				_light.intensity = _scaleCurrent;
			}
		}

		private Material[] GetMaterials()
		{
			if (Application.isPlaying || !Application.isEditor)
			{
				return MeshRenderer.materials;
			}
			return MeshRenderer.sharedMaterials;
		}
	}
	public class GameManager : MonoBehaviour
	{
		private List<GlowingSword> _lightSabers;

		private void Start()
		{
			_lightSabers = base.gameObject.FindChildrenByType<GlowingSword>();
		}

		public void ToggleLightSabers()
		{
			_lightSabers?.ForEach(delegate(GlowingSword s)
			{
				s.ToggleActive();
			});
		}
	}
	public class Spin : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.Vector3 _spinDirection;

		private void Update()
		{
			base.transform.Rotate(_spinDirection * Time.deltaTime);
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public UnityEngine.Vector3 lowerleft;

			public UnityEngine.Vector3 upperleft;

			public UnityEngine.Vector3 upperRight;

			public UnityEngine.Vector3 lowerRight;

			public UnityEngine.Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<UnityEngine.Vector3> boundaryPoints, List<List<UnityEngine.Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<UnityEngine.Vector3> rectPoints, List<UnityEngine.Vector3> boundaryPoints, List<List<UnityEngine.Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, UnityEngine.Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(UnityEngine.Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(UnityEngine.Vector3 point, bool isPlayArea, ref UnityEngine.Vector3 closestPoint, ref UnityEngine.Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<UnityEngine.Vector3> boundaryPoints = new List<UnityEngine.Vector3>();
				List<List<UnityEngine.Vector3>> list = new List<List<UnityEngine.Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<UnityEngine.Vector3> list2 = new List<UnityEngine.Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new UnityEngine.Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new UnityEngine.Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new UnityEngine.Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new UnityEngine.Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new UnityEngine.Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new UnityEngine.Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<UnityEngine.Vector3> boundaryPoints = new List<UnityEngine.Vector3>();
				List<List<UnityEngine.Vector3>> list = new List<List<UnityEngine.Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<UnityEngine.Vector3> list2 = new List<UnityEngine.Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new UnityEngine.Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<UnityEngine.Vector3> list3 = new List<UnityEngine.Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new UnityEngine.Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public UnityEngine.Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public UnityEngine.Quaternion Rotation;

		public UnityEngine.Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(UnityEngine.Vector2);
			Rotation = default(UnityEngine.Quaternion);
			Position = default(UnityEngine.Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static UnityEngine.Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new UnityEngine.Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static UnityEngine.Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != UnityEngine.Vector2.zero)
				{
					return new UnityEngine.Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return UnityEngine.Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != UnityEngine.Vector2.zero)
				{
					return new UnityEngine.Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return UnityEngine.Vector2.zero;
			default:
				return UnityEngine.Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static UnityEngine.Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new UnityEngine.Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static UnityEngine.Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new UnityEngine.Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static UnityEngine.Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static UnityEngine.Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static UnityEngine.Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public UnityEngine.Vector3 leftEyeGazePoint;

		public UnityEngine.Vector3 rightEyeGazePoint;

		public UnityEngine.Vector3 combinedEyeGazePoint;

		public UnityEngine.Vector3 leftEyeGazeVector;

		public UnityEngine.Vector3 rightEyeGazeVector;

		public UnityEngine.Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public UnityEngine.Vector3 leftEyePositionGuide;

		public UnityEngine.Vector3 rightEyePositionGuide;

		public UnityEngine.Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public UnityEngine.Vector3 Direction;

		public bool IsValid;

		public UnityEngine.Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public UnityEngine.Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(UnityEngine.Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid.ToString() + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(UnityEngine.Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, UnityEngine.Vector4 colorScale, UnityEngine.Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, UnityEngine.Matrix4x4 mvMatrix, UnityEngine.Vector3 modelS, UnityEngine.Quaternion modelR, UnityEngine.Vector3 modelT, UnityEngine.Quaternion cameraR, UnityEngine.Vector3 cameraT, UnityEngine.Vector4 colorScale, UnityEngine.Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.12";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.12";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			UnityEngine.Matrix4x4 matrix4x = UnityEngine.Matrix4x4.TRS(transform.position, transform.rotation, UnityEngine.Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static UnityEngine.Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return UnityEngine.Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return UnityEngine.Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public UnityEngine.Vector3 ClosestPoint;

			public UnityEngine.Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(UnityEngine.Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static UnityEngine.Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			UnityEngine.Vector3[] array2 = new UnityEngine.Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new UnityEngine.Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static UnityEngine.Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new UnityEngine.Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			int result = 100;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheckExtra " + result);
			return result;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace MagicArsenal
{
	public class MagicButtonScript : MonoBehaviour
	{
		public GameObject Button;

		private Text MyButtonText;

		private string projectileParticleName;

		private MagicFireProjectile effectScript;

		private MagicProjectileScript projectileScript;

		public float buttonsX;

		public float buttonsY;

		public float buttonsSizeX;

		public float buttonsSizeY;

		public float buttonsDistance;

		private void Start()
		{
			effectScript = GameObject.Find("MagicFireProjectile").GetComponent<MagicFireProjectile>();
			getProjectileNames();
			MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
			MyButtonText.text = projectileParticleName;
		}

		private void Update()
		{
			MyButtonText.text = projectileParticleName;
		}

		public void getProjectileNames()
		{
			projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<MagicProjectileScript>();
			projectileParticleName = projectileScript.projectileParticle.name;
		}

		public bool overButton()
		{
			Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
			Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
			if (rect.Contains(new UnityEngine.Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new UnityEngine.Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
			{
				return true;
			}
			return false;
		}
	}
	public class MagicDragMouseOrbit : MonoBehaviour
	{
		public Transform target;

		public float distance = 5f;

		public float xSpeed = 120f;

		public float ySpeed = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float distanceMin = 0.5f;

		public float distanceMax = 15f;

		public float smoothTime = 2f;

		private float rotationYAxis;

		private float rotationXAxis;

		private float velocityX;

		private float velocityY;

		private void Start()
		{
			UnityEngine.Vector3 eulerAngles = base.transform.eulerAngles;
			rotationYAxis = eulerAngles.y;
			rotationXAxis = eulerAngles.x;
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				if (Input.GetMouseButton(1))
				{
					velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
					velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
				}
				rotationYAxis += velocityX;
				rotationXAxis -= velocityY;
				rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
				UnityEngine.Quaternion quaternion = UnityEngine.Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
				distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
				if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
				{
					distance -= hitInfo.distance;
				}
				UnityEngine.Vector3 vector = new UnityEngine.Vector3(0f, 0f, 0f - distance);
				UnityEngine.Vector3 position = quaternion * vector + target.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
				velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
				velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
			}
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class MagicFireProjectile : MonoBehaviour
	{
		private RaycastHit hit;

		public GameObject[] projectiles;

		public Transform spawnPosition;

		[HideInInspector]
		public int currentProjectile;

		public float speed = 1000f;

		private MagicButtonScript selectedProjectileButton;

		private void Start()
		{
			selectedProjectileButton = GameObject.Find("Button").GetComponent<MagicButtonScript>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousEffect();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousEffect();
			}
			if (Input.GetKeyDown(KeyCode.Mouse0) && !EventSystem.current.IsPointerOverGameObject() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, UnityEngine.Quaternion.identity);
				gameObject.transform.LookAt(hit.point);
				gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
				gameObject.GetComponent<MagicProjectileScript>().impactNormal = hit.normal;
			}
			UnityEngine.Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
		}

		public void nextEffect()
		{
			if (currentProjectile < projectiles.Length - 1)
			{
				currentProjectile++;
			}
			else
			{
				currentProjectile = 0;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void previousEffect()
		{
			if (currentProjectile > 0)
			{
				currentProjectile--;
			}
			else
			{
				currentProjectile = projectiles.Length - 1;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void AdjustSpeed(float newSpeed)
		{
			speed = newSpeed;
		}
	}
	public class MagicLoopScript : MonoBehaviour
	{
		public GameObject chosenEffect;

		public float loopTimeLimit = 2f;

		private void Start()
		{
			PlayEffect();
		}

		public void PlayEffect()
		{
			StartCoroutine("EffectLoop");
		}

		private IEnumerator EffectLoop()
		{
			GameObject effectPlayer = UnityEngine.Object.Instantiate(chosenEffect, base.transform.position, base.transform.rotation);
			yield return new WaitForSeconds(loopTimeLimit);
			UnityEngine.Object.Destroy(effectPlayer);
			PlayEffect();
		}
	}
	public class MagicLightFade : MonoBehaviour
	{
		[Header("Seconds to dim the light")]
		public float life = 0.2f;

		public bool killAfterLife = true;

		private Light li;

		private float initIntensity;

		private void Start()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li = base.gameObject.GetComponent<Light>();
				initIntensity = li.intensity;
			}
			else
			{
				MonoBehaviour.print("No light object found on " + base.gameObject.name);
			}
		}

		private void Update()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li.intensity -= initIntensity * (Time.deltaTime / life);
				if (killAfterLife && li.intensity <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}
	public class MagicRotation : MonoBehaviour
	{
		public enum spaceEnum
		{
			Local,
			World
		}

		[Header("Rotate axises by degrees per second")]
		public UnityEngine.Vector3 rotateVector = UnityEngine.Vector3.zero;

		public spaceEnum rotateSpace;

		private void Start()
		{
		}

		private void Update()
		{
			if (rotateSpace == spaceEnum.Local)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime);
			}
			if (rotateSpace == spaceEnum.World)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime, Space.World);
			}
		}
	}
}
namespace UnityEngine.Rendering.Universal
{
	public class PostProcessUrp : ScriptableRendererFeature
	{
		[Serializable]
		public class PostProcessSettings
		{
			public RenderPassEvent Event = RenderPassEvent.AfterRenderingTransparents;

			public Material blitMaterial;

			public bool Blur;

			[Range(0f, 1f)]
			public float BlurAmount = 1f;

			public Texture2D BlurMask;

			public bool Bloom;

			public Color BloomColor = Color.white;

			[Range(0f, 5f)]
			public float BloomAmount = 1f;

			[Range(0f, 1f)]
			public float BloomDiffuse = 1f;

			[Range(0f, 1f)]
			public float BloomThreshold;

			[Range(0f, 1f)]
			public float BloomSoftness;

			public bool LUT;

			[Range(0f, 1f)]
			public float LutAmount;

			public Texture2D SourceLut;

			public bool ImageFiltering;

			public Color Color = Color.white;

			[Range(0f, 1f)]
			public float Contrast;

			[Range(-1f, 1f)]
			public float Brightness;

			[Range(-1f, 1f)]
			public float Saturation;

			[Range(-1f, 1f)]
			public float Exposure;

			[Range(-1f, 1f)]
			public float Gamma;

			[Range(0f, 1f)]
			public float Sharpness;

			public bool ChromaticAberration;

			public float Offset;

			[Range(-1f, 1f)]
			public float FishEyeDistortion;

			[Range(0f, 1f)]
			public float GlitchAmount;

			public bool Distortion;

			[Range(0f, 1f)]
			public float LensDistortion;

			public bool Vignette;

			public Color VignetteColor = Color.black;

			[Range(0f, 1f)]
			public float VignetteAmount;

			[Range(0.001f, 1f)]
			public float VignetteSoftness = 0.001f;
		}

		public PostProcessSettings settings = new PostProcessSettings();

		private PostProcessUrpPass ppsUrpPass;

		public static PostProcessUrp Instance { get; set; }

		public override void Create()
		{
			ppsUrpPass = new PostProcessUrpPass(settings.Event, settings.blitMaterial, settings.Blur, settings.BlurAmount, settings.BlurMask, settings.Bloom, settings.BloomColor, settings.BloomAmount, settings.BloomDiffuse, settings.BloomThreshold, settings.BloomSoftness, settings.LUT, settings.LutAmount, settings.SourceLut, settings.ImageFiltering, settings.Color, settings.Contrast, settings.Saturation, settings.Brightness, settings.Exposure, settings.Gamma, settings.Sharpness, settings.ChromaticAberration, settings.Offset, settings.FishEyeDistortion, settings.GlitchAmount, settings.Distortion, settings.LensDistortion, settings.Vignette, settings.VignetteColor, settings.VignetteAmount, settings.VignetteSoftness, base.name);
		}

		public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
		{
			if (Instance == null)
			{
				Instance = this;
			}
			ppsUrpPass.Setup(renderer.cameraColorTarget);
			renderer.EnqueuePass(ppsUrpPass);
		}
	}
	public class PostProcessUrpPass : ScriptableRenderPass
	{
		public Material material;

		private RenderTargetIdentifier source;

		private RenderTargetIdentifier blurTemp = new RenderTargetIdentifier(blurTempString);

		private RenderTargetIdentifier blurTemp1 = new RenderTargetIdentifier(blurTemp1String);

		private RenderTargetIdentifier blurTex = new RenderTargetIdentifier(blurTexString);

		private RenderTargetIdentifier tempCopy = new RenderTargetIdentifier(tempCopyString);

		private bool maskSet;

		private int numberOfPasses = 3;

		private readonly string tag;

		private readonly bool blur;

		private readonly float blurAmount;

		private readonly Texture2D blurMask;

		private readonly bool bloom;

		private readonly Color bloomColor;

		private readonly float bloomAmount;

		private readonly float bloomDiffuse;

		private readonly float bloomThreshold;

		private readonly float bloomSoftness;

		private readonly bool lut;

		private readonly Texture2D sourceLut;

		private readonly float lutAmount;

		private readonly bool imageFiltering;

		private readonly Color color;

		private readonly float contrast;

		private readonly float brightness;

		private readonly float saturation;

		private readonly float exposure;

		private readonly float gamma;

		private readonly float sharpness;

		private readonly bool chromaticAberration;

		private readonly float offset;

		private readonly float fishEyeDistortion;

		private readonly float glitchAmount;

		private readonly bool distortion;

		private readonly float lensDistortion;

		private readonly bool vignette;

		private readonly Color vignetteColor;

		private readonly float vignetteAmount;

		private readonly float vignetteSoftness;

		private static readonly int blurTexString = Shader.PropertyToID("_BlurTex");

		private static readonly int maskTextureString = Shader.PropertyToID("_MaskTex");

		private static readonly int blurAmountString = Shader.PropertyToID("_BlurAmount");

		private static readonly int bloomColorString = Shader.PropertyToID("_BloomColor");

		private static readonly int blDiffuseString = Shader.PropertyToID("_BloomDiffuse");

		private static readonly int blDataString = Shader.PropertyToID("_BloomData");

		private static readonly int lutTextureString = Shader.PropertyToID("_LutTex");

		private static readonly int lutAmountString = Shader.PropertyToID("_LutAmount");

		private static readonly int colorString = Shader.PropertyToID("_Color");

		private static readonly int contrastString = Shader.PropertyToID("_Contrast");

		private static readonly int brightnessString = Shader.PropertyToID("_Brightness");

		private static readonly int saturationString = Shader.PropertyToID("_Saturation");

		private static readonly int centralFactorString = Shader.PropertyToID("_CentralFactor");

		private static readonly int sideFactorString = Shader.PropertyToID("_SideFactor");

		private static readonly int offsetString = Shader.PropertyToID("_Offset");

		private static readonly int fishEyeString = Shader.PropertyToID("_FishEye");

		private static readonly int lensdistortionString = Shader.PropertyToID("_LensDistortion");

		private static readonly int vignetteColorString = Shader.PropertyToID("_VignetteColor");

		private static readonly int vignetteAmountString = Shader.PropertyToID("_VignetteAmount");

		private static readonly int vignetteSoftnessString = Shader.PropertyToID("_VignetteSoftness");

		private static readonly int blurTempString = Shader.PropertyToID("_BlurTemp");

		private static readonly int blurTemp1String = Shader.PropertyToID("_BlurTemp1");

		private static readonly int tempCopyString = Shader.PropertyToID("_TempCopy");

		private static readonly string bloomKeyword = "BLOOM";

		private static readonly string blurKeyword = "BLUR";

		private static readonly string chromaKeyword = "CHROMA";

		private static readonly string lutKeyword = "LUT";

		private static readonly string filterKeyword = "FILTER";

		private static readonly string shaprenKeyword = "SHARPEN";

		private static readonly string distortionKeyword = "DISTORTION";

		private Texture2D previous;

		private Texture3D converted3D;

		private float t;

		private float a;

		private float knee;

		public FilterMode filterMode { get; set; }

		public PostProcessUrpPass(RenderPassEvent renderPassEvent, Material material, bool blur, float blurAmount, Texture2D blurMask, bool bloom, Color bloomColor, float bloomAmount, float bloomDiffuse, float bloomThreshold, float bloomSoftness, bool lut, float lutAmount, Texture2D sourceLut, bool imageFiltering, Color color, float contrast, float saturation, float brightness, float exposure, float gamma, float sharpness, bool chromaticAberration, float offset, float fishEyeDistortion, float glitchAmount, bool distortion, float lensDistortion, bool vignette, Color vignetteColor, float vignetteAmount, float vignetteSoftness, string tag)
		{
			base.renderPassEvent = renderPassEvent;
			this.material = material;
			this.blur = blur;
			this.blurAmount = blurAmount;
			this.blurMask = ((blurMask == null) ? Texture2D.whiteTexture : blurMask);
			this.bloom = bloom;
			this.bloomColor = bloomColor;
			this.bloomDiffuse = bloomDiffuse;
			this.bloomAmount = bloomAmount;
			this.bloomThreshold = bloomThreshold;
			this.bloomSoftness = bloomSoftness;
			this.lut = lut;
			this.lutAmount = lutAmount;
			this.sourceLut = sourceLut;
			this.imageFiltering = imageFiltering;
			this.color = color;
			this.contrast = contrast;
			this.saturation = saturation;
			this.brightness = brightness;
			this.exposure = exposure;
			this.gamma = gamma;
			this.sharpness = sharpness;
			this.chromaticAberration = chromaticAberration;
			this.offset = offset;
			this.fishEyeDistortion = fishEyeDistortion;
			this.glitchAmount = glitchAmount;
			this.distortion = distortion;
			this.lensDistortion = lensDistortion;
			this.vignette = vignette;
			this.vignetteColor = vignetteColor;
			this.vignetteAmount = vignetteAmount;
			this.vignetteSoftness = vignetteSoftness;
			this.tag = tag;
		}

		public void Setup(RenderTargetIdentifier source)
		{
			this.source = source;
		}

		public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
		{
			CommandBuffer commandBuffer = CommandBufferPool.Get(tag);
			RenderTextureDescriptor cameraTargetDescriptor = renderingData.cameraData.cameraTargetDescriptor;
			cameraTargetDescriptor.depthBufferBits = 0;
			commandBuffer.GetTemporaryRT(tempCopyString, cameraTargetDescriptor, FilterMode.Bilinear);
			commandBuffer.CopyTexture(source, tempCopy);
			if (bloom || blur)
			{
				material.DisableKeyword(blurKeyword);
				material.DisableKeyword(bloomKeyword);
				if (bloom)
				{
					material.EnableKeyword(bloomKeyword);
					material.SetColor(bloomColorString, bloomColor * bloomAmount);
					material.SetFloat(blDiffuseString, bloomDiffuse);
					numberOfPasses = Mathf.Max(Mathf.CeilToInt(bloomDiffuse * 4f), 1);
					material.SetFloat(blDiffuseString, (numberOfPasses > 1) ? ((bloomDiffuse * 4f - (float)Mathf.FloorToInt(bloomDiffuse * 4f - 0.001f)) * 0.5f + 0.5f) : (bloomDiffuse * 4f));
					knee = bloomThreshold * bloomSoftness;
					material.SetVector(blDataString, new Vector4(bloomThreshold, bloomThreshold - knee, 2f * knee, 1f / (4f * knee + 1E-05f)));
				}
				if (blur)
				{
					material.EnableKeyword(blurKeyword);
					numberOfPasses = Mathf.Max(Mathf.CeilToInt(blurAmount * 4f), 1);
					material.SetFloat(blurAmountString, (numberOfPasses > 1) ? ((blurAmount * 4f - (float)Mathf.FloorToInt(blurAmount * 4f - 0.001f)) * 0.5f + 0.5f) : (blurAmount * 4f));
					if (!maskSet)
					{
						material.SetTexture(maskTextureString, blurMask);
						maskSet = true;
					}
				}
				if (blurAmount > 0f || !blur)
				{
					if (numberOfPasses == 1)
					{
						commandBuffer.GetTemporaryRT(blurTexString, Screen.width / 2, Screen.height / 2, 0, FilterMode.Bilinear);
						commandBuffer.Blit(tempCopy, blurTex, material, 0);
					}
					else if (numberOfPasses == 2)
					{
						commandBuffer.GetTemporaryRT(blurTexString, Screen.width / 2, Screen.height / 2, 0, FilterMode.Bilinear);
						commandBuffer.GetTemporaryRT(blurTempString, Screen.width / 4, Screen.height / 4, 0, FilterMode.Bilinear);
						commandBuffer.Blit(tempCopy, blurTemp, material, 0);
						commandBuffer.Blit(blurTemp, blurTex, material, 0);
					}
					else if (numberOfPasses == 3)
					{
						commandBuffer.GetTemporaryRT(blurTexString, Screen.width / 4, Screen.height / 4, 0, FilterMode.Bilinear);
						commandBuffer.GetTemporaryRT(blurTempString, Screen.width / 8, Screen.height / 8, 0, FilterMode.Bilinear);
						commandBuffer.Blit(tempCopy, blurTex, material, 0);
						commandBuffer.Blit(blurTex, blurTemp, material, 0);
						commandBuffer.Blit(blurTemp, blurTex, material, 0);
					}
					else if (numberOfPasses == 4)
					{
						commandBuffer.GetTemporaryRT(blurTexString, Screen.width / 4, Screen.height / 4, 0, FilterMode.Bilinear);
						commandBuffer.GetTemporaryRT(blurTempString, Screen.width / 8, Screen.height / 8, 0, FilterMode.Bilinear);
						commandBuffer.GetTemporaryRT(blurTemp1String, Screen.width / 16, Screen.height / 16, 0, FilterMode.Bilinear);
						commandBuffer.Blit(tempCopy, blurTex, material, 0);
						commandBuffer.Blit(blurTex, blurTemp, material, 0);
						commandBuffer.Blit(blurTemp, blurTemp1, material, 0);
						commandBuffer.Blit(blurTemp1, blurTemp, material, 0);
						commandBuffer.Blit(blurTemp, blurTex, material, 0);
					}
					commandBuffer.SetGlobalTexture(blurTexString, blurTex);
				}
				else
				{
					commandBuffer.SetGlobalTexture(blurTexString, tempCopy);
				}
			}
			else
			{
				material.DisableKeyword(blurKeyword);
				material.DisableKeyword(bloomKeyword);
			}
			if (lut)
			{
				isConverted();
				material.EnableKeyword(lutKeyword);
				material.SetFloat(lutAmountString, lutAmount);
				material.SetTexture(lutTextureString, converted3D);
			}
			else
			{
				material.DisableKeyword(lutKeyword);
			}
			if (imageFiltering)
			{
				material.EnableKeyword(filterKeyword);
				material.SetColor(colorString, (Mathf.Pow(2f, exposure) - gamma) * color);
				material.SetFloat(contrastString, contrast + 1f);
				material.SetFloat(brightnessString, brightness * 0.5f - contrast);
				material.SetFloat(saturationString, saturation + 1f);
				if (sharpness > 0f)
				{
					material.EnableKeyword(shaprenKeyword);
					material.SetFloat(centralFactorString, 1f + 3.2f * sharpness);
					material.SetFloat(sideFactorString, 0.8f * sharpness);
				}
				else
				{
					material.DisableKeyword(shaprenKeyword);
				}
			}
			else
			{
				material.DisableKeyword(filterKeyword);
				material.DisableKeyword(shaprenKeyword);
			}
			if (chromaticAberration)
			{
				material.EnableKeyword(chromaKeyword);
				if (glitchAmount > 0f)
				{
					t = Time.realtimeSinceStartup;
					a = (1f + Mathf.Sin(t * 6f)) * (0.5f + Mathf.Sin(t * 16f) * 0.25f) * (0.5f + Mathf.Sin(t * 19f) * 0.25f) * (0.5f + Mathf.Sin(t * 27f) * 0.25f);
					material.SetFloat(offsetString, 10f * offset + glitchAmount * Mathf.Pow(a, 3f) * 200f);
				}
				else
				{
					material.SetFloat(offsetString, 10f * offset);
				}
				material.SetFloat(fishEyeString, 0.1f * fishEyeDistortion);
			}
			else
			{
				material.DisableKeyword(chromaKeyword);
			}
			if (distortion)
			{
				material.SetFloat(lensdistortionString, 0f - lensDistortion);
				material.EnableKeyword(distortionKeyword);
			}
			else
			{
				material.DisableKeyword(distortionKeyword);
			}
			if (vignette)
			{
				material.SetColor(vignetteColorString, vignetteColor);
				material.SetFloat(vignetteAmountString, 1f - vignetteAmount);
				material.SetFloat(vignetteSoftnessString, 1f - vignetteSoftness - vignetteAmount);
			}
			else
			{
				material.SetFloat(vignetteAmountString, 1f);
				material.SetFloat(vignetteSoftnessString, 0.999f);
			}
			commandBuffer.Blit(tempCopy, source, material, 1);
			context.ExecuteCommandBuffer(commandBuffer);
			CommandBufferPool.Release(commandBuffer);
		}

		public override void FrameCleanup(CommandBuffer cmd)
		{
			cmd.ReleaseTemporaryRT(tempCopyString);
			cmd.ReleaseTemporaryRT(blurTempString);
			cmd.ReleaseTemporaryRT(blurTemp1String);
			cmd.ReleaseTemporaryRT(blurTexString);
		}

		private void isConverted()
		{
			if (sourceLut != previous)
			{
				previous = sourceLut;
				Convert(sourceLut);
			}
		}

		private void Convert(Texture2D tempTex)
		{
			Color[] pixels = tempTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < 16; i++)
			{
				for (int j = 0; j < 16; j++)
				{
					for (int k = 0; k < 16; k++)
					{
						int num = 16 - j - 1;
						array[i + j * 16 + k * 256] = pixels[k * 16 + i + num * 256];
					}
				}
			}
			if ((bool)converted3D)
			{
				Object.DestroyImmediate(converted3D);
			}
			converted3D = new Texture3D(16, 16, 16, TextureFormat.ARGB32, mipChain: false)
			{
				hideFlags = HideFlags.HideAndDontSave,
				wrapMode = TextureWrapMode.Clamp
			};
			converted3D.SetPixels(array);
			converted3D.Apply();
		}
	}
}
namespace UnityEngine.PostProcessing
{
	public sealed class GetSetAttribute : PropertyAttribute
	{
		public readonly string name;

		public bool dirty;

		public GetSetAttribute(string name)
		{
			this.name = name;
		}
	}
	public sealed class MinAttribute : PropertyAttribute
	{
		public readonly float min;

		public MinAttribute(float min)
		{
			this.min = min;
		}
	}
	public sealed class TrackballAttribute : PropertyAttribute
	{
		public readonly string method;

		public TrackballAttribute(string method)
		{
			this.method = method;
		}
	}
	public sealed class TrackballGroupAttribute : PropertyAttribute
	{
	}
	public sealed class AmbientOcclusionComponent : PostProcessingComponentCommandBuffer<AmbientOcclusionModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Intensity = Shader.PropertyToID("_Intensity");

			internal static readonly int _Radius = Shader.PropertyToID("_Radius");

			internal static readonly int _FogParams = Shader.PropertyToID("_FogParams");

			internal static readonly int _Downsample = Shader.PropertyToID("_Downsample");

			internal static readonly int _SampleCount = Shader.PropertyToID("_SampleCount");

			internal static readonly int _OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

			internal static readonly int _OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

			internal static readonly int _OcclusionTexture = Shader.PropertyToID("_OcclusionTexture");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
		}

		private enum OcclusionSource
		{
			DepthTexture,
			DepthNormalsTexture,
			GBuffer
		}

		private const string k_BlitShaderString = "Hidden/Post FX/Blit";

		private const string k_ShaderString = "Hidden/Post FX/Ambient Occlusion";

		private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[2]
		{
			BuiltinRenderTextureType.GBuffer0,
			BuiltinRenderTextureType.CameraTarget
		};

		private OcclusionSource occlusionSource
		{
			get
			{
				if (context.isGBufferAvailable && !base.model.settings.forceForwardCompatibility)
				{
					return OcclusionSource.GBuffer;
				}
				if (base.model.settings.highPrecision && (!context.isGBufferAvailable || base.model.settings.forceForwardCompatibility))
				{
					return OcclusionSource.DepthTexture;
				}
				return OcclusionSource.DepthNormalsTexture;
			}
		}

		private bool ambientOnlySupported
		{
			get
			{
				if (context.isHdr && base.model.settings.ambientOnly && context.isGBufferAvailable)
				{
					return !base.model.settings.forceForwardCompatibility;
				}
				return false;
			}
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			DepthTextureMode depthTextureMode = DepthTextureMode.None;
			if (occlusionSource == OcclusionSource.DepthTexture)
			{
				depthTextureMode |= DepthTextureMode.Depth;
			}
			if (occlusionSource != OcclusionSource.GBuffer)
			{
				depthTextureMode |= DepthTextureMode.DepthNormals;
			}
			return depthTextureMode;
		}

		public override string GetName()
		{
			return "Ambient Occlusion";
		}

		public override CameraEvent GetCameraEvent()
		{
			if (!ambientOnlySupported || context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
			{
				return CameraEvent.BeforeImageEffectsOpaque;
			}
			return CameraEvent.BeforeReflections;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			AmbientOcclusionModel.Settings settings = base.model.settings;
			Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
			Material material = context.materialFactory.Get("Hidden/Post FX/Ambient Occlusion");
			material.shaderKeywords = null;
			material.SetFloat(Uniforms._Intensity, settings.intensity);
			material.SetFloat(Uniforms._Radius, settings.radius);
			material.SetFloat(Uniforms._Downsample, settings.downsampling ? 0.5f : 1f);
			material.SetInt(Uniforms._SampleCount, (int)settings.sampleCount);
			if (!context.isGBufferAvailable && RenderSettings.fog)
			{
				material.SetVector(Uniforms._FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
				switch (RenderSettings.fogMode)
				{
				case FogMode.Linear:
					material.EnableKeyword("FOG_LINEAR");
					break;
				case FogMode.Exponential:
					material.EnableKeyword("FOG_EXP");
					break;
				case FogMode.ExponentialSquared:
					material.EnableKeyword("FOG_EXP2");
					break;
				}
			}
			else
			{
				material.EnableKeyword("FOG_OFF");
			}
			int width = context.width;
			int height = context.height;
			int num = ((!settings.downsampling) ? 1 : 2);
			int occlusionTexture = Uniforms._OcclusionTexture1;
			cb.GetTemporaryRT(occlusionTexture, width / num, height / num, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.Blit(null, occlusionTexture, material, (int)occlusionSource);
			int occlusionTexture2 = Uniforms._OcclusionTexture2;
			cb.GetTemporaryRT(occlusionTexture2, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
			cb.Blit(occlusionTexture, occlusionTexture2, material, (occlusionSource == OcclusionSource.GBuffer) ? 4 : 3);
			cb.ReleaseTemporaryRT(occlusionTexture);
			occlusionTexture = Uniforms._OcclusionTexture;
			cb.GetTemporaryRT(occlusionTexture, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture2);
			cb.Blit(occlusionTexture2, occlusionTexture, material, 5);
			cb.ReleaseTemporaryRT(occlusionTexture2);
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
			{
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
				cb.Blit(occlusionTexture, BuiltinRenderTextureType.CameraTarget, material, 8);
				context.Interrupt();
			}
			else if (ambientOnlySupported)
			{
				cb.SetRenderTarget(m_MRT, BuiltinRenderTextureType.CameraTarget);
				cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 7);
			}
			else
			{
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				int tempRT = Uniforms._TempRT;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				cb.SetGlobalTexture(Uniforms._MainTex, tempRT);
				cb.Blit(tempRT, BuiltinRenderTextureType.CameraTarget, material, 6);
				cb.ReleaseTemporaryRT(tempRT);
			}
			cb.ReleaseTemporaryRT(occlusionTexture);
		}
	}
	public sealed class BloomComponent : PostProcessingComponentRenderTexture<BloomModel>
	{
		private static class Uniforms
		{
			internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

			internal static readonly int _Threshold = Shader.PropertyToID("_Threshold");

			internal static readonly int _Curve = Shader.PropertyToID("_Curve");

			internal static readonly int _PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");

			internal static readonly int _SampleScale = Shader.PropertyToID("_SampleScale");

			internal static readonly int _BaseTex = Shader.PropertyToID("_BaseTex");

			internal static readonly int _BloomTex = Shader.PropertyToID("_BloomTex");

			internal static readonly int _Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

			internal static readonly int _Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

			internal static readonly int _Bloom_DirtIntensity = Shader.PropertyToID("_Bloom_DirtIntensity");
		}

		private const int k_MaxPyramidBlurLevel = 16;

		private readonly RenderTexture[] m_BlurBuffer1 = new RenderTexture[16];

		private readonly RenderTexture[] m_BlurBuffer2 = new RenderTexture[16];

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.bloom.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void Prepare(RenderTexture source, Material uberMaterial, Texture autoExposure)
		{
			BloomModel.BloomSettings bloom = base.model.settings.bloom;
			BloomModel.LensDirtSettings lensDirt = base.model.settings.lensDirt;
			Material material = context.materialFactory.Get("Hidden/Post FX/Bloom");
			material.shaderKeywords = null;
			material.SetTexture(Uniforms._AutoExposure, autoExposure);
			int width = context.width / 2;
			int num = context.height / 2;
			RenderTextureFormat format = (Application.isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num2 = Mathf.Log(num, 2f) + bloom.radius - 8f;
			int num3 = (int)num2;
			int num4 = Mathf.Clamp(num3, 1, 16);
			float thresholdLinear = bloom.thresholdLinear;
			material.SetFloat(Uniforms._Threshold, thresholdLinear);
			float num5 = thresholdLinear * bloom.softKnee + 1E-05f;
			material.SetVector(value: new Vector3(thresholdLinear - num5, num5 * 2f, 0.25f / num5), nameID: Uniforms._Curve);
			material.SetFloat(Uniforms._PrefilterOffs, bloom.antiFlicker ? (-0.5f) : 0f);
			float num6 = 0.5f + num2 - (float)num3;
			material.SetFloat(Uniforms._SampleScale, num6);
			if (bloom.antiFlicker)
			{
				material.EnableKeyword("ANTI_FLICKER");
			}
			RenderTexture renderTexture = context.renderTextureFactory.Get(width, num, 0, format);
			Graphics.Blit(source, renderTexture, material, 0);
			RenderTexture renderTexture2 = renderTexture;
			for (int i = 0; i < num4; i++)
			{
				m_BlurBuffer1[i] = context.renderTextureFactory.Get(renderTexture2.width / 2, renderTexture2.height / 2, 0, format);
				int pass = ((i == 0) ? 1 : 2);
				Graphics.Blit(renderTexture2, m_BlurBuffer1[i], material, pass);
				renderTexture2 = m_BlurBuffer1[i];
			}
			for (int num7 = num4 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture3 = m_BlurBuffer1[num7];
				material.SetTexture(Uniforms._BaseTex, renderTexture3);
				m_BlurBuffer2[num7] = context.renderTextureFactory.Get(renderTexture3.width, renderTexture3.height, 0, format);
				Graphics.Blit(renderTexture2, m_BlurBuffer2[num7], material, 3);
				renderTexture2 = m_BlurBuffer2[num7];
			}
			RenderTexture renderTexture4 = renderTexture2;
			for (int j = 0; j < 16; j++)
			{
				if (m_BlurBuffer1[j] != null)
				{
					context.renderTextureFactory.Release(m_BlurBuffer1[j]);
				}
				if (m_BlurBuffer2[j] != null && m_BlurBuffer2[j] != renderTexture4)
				{
					context.renderTextureFactory.Release(m_BlurBuffer2[j]);
				}
				m_BlurBuffer1[j] = null;
				m_BlurBuffer2[j] = null;
			}
			context.renderTextureFactory.Release(renderTexture);
			uberMaterial.SetTexture(Uniforms._BloomTex, renderTexture4);
			uberMaterial.SetVector(Uniforms._Bloom_Settings, new Vector2(num6, bloom.intensity));
			if (lensDirt.intensity > 0f && lensDirt.texture != null)
			{
				uberMaterial.SetTexture(Uniforms._Bloom_DirtTex, lensDirt.texture);
				uberMaterial.SetFloat(Uniforms._Bloom_DirtIntensity, lensDirt.intensity);
				uberMaterial.EnableKeyword("BLOOM_LENS_DIRT");
			}
			else
			{
				uberMaterial.EnableKeyword("BLOOM");
			}
		}
	}
	public sealed class BuiltinDebugViewsComponent : PostProcessingComponentCommandBuffer<BuiltinDebugViewsModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DepthScale = Shader.PropertyToID("_DepthScale");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

			internal static readonly int _Opacity = Shader.PropertyToID("_Opacity");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _TempRT2 = Shader.PropertyToID("_TempRT2");

			internal static readonly int _Amplitude = Shader.PropertyToID("_Amplitude");

			internal static readonly int _Scale = Shader.PropertyToID("_Scale");
		}

		private enum Pass
		{
			Depth,
			Normals,
			MovecOpacity,
			MovecImaging,
			MovecArrows
		}

		private class ArrowArray
		{
			public Mesh mesh { get; private set; }

			public int columnCount { get; private set; }

			public int rowCount { get; private set; }

			public void BuildMesh(int columns, int rows)
			{
				Vector3[] array = new Vector3[6]
				{
					new Vector3(0f, 0f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(-1f, 1f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(1f, 1f, 0f)
				};
				int num = 6 * columns * rows;
				List<Vector3> list = new List<Vector3>(num);
				List<Vector2> list2 = new List<Vector2>(num);
				for (int i = 0; i < rows; i++)
				{
					for (int j = 0; j < columns; j++)
					{
						Vector2 item = new Vector2((0.5f + (float)j) / (float)columns, (0.5f + (float)i) / (float)rows);
						for (int k = 0; k < 6; k++)
						{
							list.Add(array[k]);
							list2.Add(item);
						}
					}
				}
				int[] array2 = new int[num];
				for (int l = 0; l < num; l++)
				{
					array2[l] = l;
				}
				mesh = new Mesh
				{
					hideFlags = HideFlags.DontSave
				};
				mesh.SetVertices(list);
				mesh.SetUVs(0, list2);
				mesh.SetIndices(array2, MeshTopology.Lines, 0);
				mesh.UploadMeshData(markNoLongerReadable: true);
				columnCount = columns;
				rowCount = rows;
			}

			public void Release()
			{
				GraphicsUtils.Destroy(mesh);
				mesh = null;
			}
		}

		private const string k_ShaderString = "Hidden/Post FX/Builtin Debug Views";

		private ArrowArray m_Arrows;

		public override bool active
		{
			get
			{
				if (!base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Depth) && !base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Normals))
				{
					return base.model.IsModeActive(BuiltinDebugViewsModel.Mode.MotionVectors);
				}
				return true;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			BuiltinDebugViewsModel.Mode mode = base.model.settings.mode;
			DepthTextureMode depthTextureMode = DepthTextureMode.None;
			switch (mode)
			{
			case BuiltinDebugViewsModel.Mode.Normals:
				depthTextureMode |= DepthTextureMode.DepthNormals;
				break;
			case BuiltinDebugViewsModel.Mode.MotionVectors:
				depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
				break;
			case BuiltinDebugViewsModel.Mode.Depth:
				depthTextureMode |= DepthTextureMode.Depth;
				break;
			}
			return depthTextureMode;
		}

		public override CameraEvent GetCameraEvent()
		{
			if (base.model.settings.mode != BuiltinDebugViewsModel.Mode.MotionVectors)
			{
				return CameraEvent.BeforeImageEffectsOpaque;
			}
			return CameraEvent.BeforeImageEffects;
		}

		public override string GetName()
		{
			return "Builtin Debug Views";
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			BuiltinDebugViewsModel.Settings settings = base.model.settings;
			Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			material.shaderKeywords = null;
			if (context.isGBufferAvailable)
			{
				material.EnableKeyword("SOURCE_GBUFFER");
			}
			switch (settings.mode)
			{
			case BuiltinDebugViewsModel.Mode.Depth:
				DepthPass(cb);
				break;
			case BuiltinDebugViewsModel.Mode.Normals:
				DepthNormalsPass(cb);
				break;
			case BuiltinDebugViewsModel.Mode.MotionVectors:
				MotionVectorsPass(cb);
				break;
			}
			context.Interrupt();
		}

		private void DepthPass(CommandBuffer cb)
		{
			Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			BuiltinDebugViewsModel.DepthSettings depth = base.model.settings.depth;
			cb.SetGlobalFloat(Uniforms._DepthScale, 1f / depth.scale);
			cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 0);
		}

		private void DepthNormalsPass(CommandBuffer cb)
		{
			Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 1);
		}

		private void MotionVectorsPass(CommandBuffer cb)
		{
			Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			BuiltinDebugViewsModel.MotionVectorsSettings motionVectors = base.model.settings.motionVectors;
			int num = Uniforms._TempRT;
			cb.GetTemporaryRT(num, context.width, context.height, 0, FilterMode.Bilinear);
			cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.sourceOpacity);
			cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, num, material, 2);
			if (motionVectors.motionImageOpacity > 0f && motionVectors.motionImageAmplitude > 0f)
			{
				int tempRT = Uniforms._TempRT2;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear);
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionImageOpacity);
				cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionImageAmplitude);
				cb.SetGlobalTexture(Uniforms._MainTex, num);
				cb.Blit(num, tempRT, material, 3);
				cb.ReleaseTemporaryRT(num);
				num = tempRT;
			}
			if (motionVectors.motionVectorsOpacity > 0f && motionVectors.motionVectorsAmplitude > 0f)
			{
				PrepareArrows();
				float num2 = 1f / (float)motionVectors.motionVectorsResolution;
				float x = num2 * (float)context.height / (float)context.width;
				cb.SetGlobalVector(Uniforms._Scale, new Vector2(x, num2));
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionVectorsOpacity);
				cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionVectorsAmplitude);
				cb.DrawMesh(m_Arrows.mesh, Matrix4x4.identity, material, 0, 4);
			}
			cb.SetGlobalTexture(Uniforms._MainTex, num);
			cb.Blit(num, BuiltinRenderTextureType.CameraTarget);
			cb.ReleaseTemporaryRT(num);
		}

		private void PrepareArrows()
		{
			int motionVectorsResolution = base.model.settings.motionVectors.motionVectorsResolution;
			int num = motionVectorsResolution * Screen.width / Screen.height;
			if (m_Arrows == null)
			{
				m_Arrows = new ArrowArray();
			}
			if (m_Arrows.columnCount != num || m_Arrows.rowCount != motionVectorsResolution)
			{
				m_Arrows.Release();
				m_Arrows.BuildMesh(num, motionVectorsResolution);
			}
		}

		public override void OnDisable()
		{
			if (m_Arrows != null)
			{
				m_Arrows.Release();
			}
			m_Arrows = null;
		}
	}
	public sealed class ChromaticAberrationComponent : PostProcessingComponentRenderTexture<ChromaticAberrationModel>
	{
		private static class Uniforms
		{
			internal static readonly int _ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

			internal static readonly int _ChromaticAberration_Spectrum = Shader.PropertyToID("_ChromaticAberration_Spectrum");
		}

		private Texture2D m_SpectrumLut;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_SpectrumLut);
			m_SpectrumLut = null;
		}

		public override void Prepare(Material uberMaterial)
		{
			ChromaticAberrationModel.Settings settings = base.model.settings;
			Texture2D texture2D = settings.spectralTexture;
			if (texture2D == null)
			{
				if (m_SpectrumLut == null)
				{
					m_SpectrumLut = new Texture2D(3, 1, TextureFormat.RGB24, mipChain: false)
					{
						name = "Chromatic Aberration Spectrum Lookup",
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0,
						hideFlags = HideFlags.DontSave
					};
					Color[] pixels = new Color[3]
					{
						new Color(1f, 0f, 0f),
						new Color(0f, 1f, 0f),
						new Color(0f, 0f, 1f)
					};
					m_SpectrumLut.SetPixels(pixels);
					m_SpectrumLut.Apply();
				}
				texture2D = m_SpectrumLut;
			}
			uberMaterial.EnableKeyword("CHROMATIC_ABERRATION");
			uberMaterial.SetFloat(Uniforms._ChromaticAberration_Amount, settings.intensity * 0.03f);
			uberMaterial.SetTexture(Uniforms._ChromaticAberration_Spectrum, texture2D);
		}
	}
	public sealed class ColorGradingComponent : PostProcessingComponentRenderTexture<ColorGradingModel>
	{
		private static class Uniforms
		{
			internal static readonly int _LutParams = Shader.PropertyToID("_LutParams");

			internal static readonly int _NeutralTonemapperParams1 = Shader.PropertyToID("_NeutralTonemapperParams1");

			internal static readonly int _NeutralTonemapperParams2 = Shader.PropertyToID("_NeutralTonemapperParams2");

			internal static readonly int _HueShift = Shader.PropertyToID("_HueShift");

			internal static readonly int _Saturation = Shader.PropertyToID("_Saturation");

			internal static readonly int _Contrast = Shader.PropertyToID("_Contrast");

			internal static readonly int _Balance = Shader.PropertyToID("_Balance");

			internal static readonly int _Lift = Shader.PropertyToID("_Lift");

			internal static readonly int _InvGamma = Shader.PropertyToID("_InvGamma");

			internal static readonly int _Gain = Shader.PropertyToID("_Gain");

			internal static readonly int _Slope = Shader.PropertyToID("_Slope");

			internal static readonly int _Power = Shader.PropertyToID("_Power");

			internal static readonly int _Offset = Shader.PropertyToID("_Offset");

			internal static readonly int _ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

			internal static readonly int _ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

			internal static readonly int _ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

			internal static readonly int _Curves = Shader.PropertyToID("_Curves");

			internal static readonly int _LogLut = Shader.PropertyToID("_LogLut");

			internal static readonly int _LogLut_Params = Shader.PropertyToID("_LogLut_Params");

			internal static readonly int _ExposureEV = Shader.PropertyToID("_ExposureEV");
		}

		private const int k_InternalLogLutSize = 32;

		private const int k_CurvePrecision = 128;

		private const float k_CurveStep = 1f / 128f;

		private Texture2D m_GradingCurves;

		private Color[] m_pixels = new Color[256];

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		private float StandardIlluminantY(float x)
		{
			return 2.87f * x - 3f * x * x - 0.27509508f;
		}

		private Vector3 CIExyToLMS(float x, float y)
		{
			float num = 1f;
			float num2 = num * x / y;
			float num3 = num * (1f - x - y) / y;
			float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
			float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
			float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
			return new Vector3(x2, y2, z);
		}

		private Vector3 CalculateColorBalance(float temperature, float tint)
		{
			float num = temperature / 55f;
			float num2 = tint / 55f;
			float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
			float y = StandardIlluminantY(x) + num2 * 0.05f;
			Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
			Vector3 vector2 = CIExyToLMS(x, y);
			return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
		}

		private static Color NormalizeColor(Color c)
		{
			float num = (c.r + c.g + c.b) / 3f;
			if (Mathf.Approximately(num, 0f))
			{
				return new Color(1f, 1f, 1f, c.a);
			}
			Color result = default(Color);
			result.r = c.r / num;
			result.g = c.g / num;
			result.b = c.b / num;
			result.a = c.a;
			return result;
		}

		private static Vector3 ClampVector(Vector3 v, float min, float max)
		{
			return new Vector3(Mathf.Clamp(v.x, min, max), Mathf.Clamp(v.y, min, max), Mathf.Clamp(v.z, min, max));
		}

		public static Vector3 GetLiftValue(Color lift)
		{
			Color color = NormalizeColor(lift);
			float num = (color.r + color.g + color.b) / 3f;
			float x = (color.r - num) * 0.1f + lift.a;
			float y = (color.g - num) * 0.1f + lift.a;
			float z = (color.b - num) * 0.1f + lift.a;
			return ClampVector(new Vector3(x, y, z), -1f, 1f);
		}

		public static Vector3 GetGammaValue(Color gamma)
		{
			Color color = NormalizeColor(gamma);
			float num = (color.r + color.g + color.b) / 3f;
			gamma.a *= ((gamma.a < 0f) ? 0.8f : 5f);
			float b = Mathf.Pow(2f, (color.r - num) * 0.5f) + gamma.a;
			float b2 = Mathf.Pow(2f, (color.g - num) * 0.5f) + gamma.a;
			float b3 = Mathf.Pow(2f, (color.b - num) * 0.5f) + gamma.a;
			float x = 1f / Mathf.Max(0.01f, b);
			float y = 1f / Mathf.Max(0.01f, b2);
			float z = 1f / Mathf.Max(0.01f, b3);
			return ClampVector(new Vector3(x, y, z), 0f, 5f);
		}

		public static Vector3 GetGainValue(Color gain)
		{
			Color color = NormalizeColor(gain);
			float num = (color.r + color.g + color.b) / 3f;
			gain.a *= ((gain.a > 0f) ? 3f : 1f);
			float x = Mathf.Pow(2f, (color.r - num) * 0.5f) + gain.a;
			float y = Mathf.Pow(2f, (color.g - num) * 0.5f) + gain.a;
			float z = Mathf.Pow(2f, (color.b - num) * 0.5f) + gain.a;
			return ClampVector(new Vector3(x, y, z), 0f, 4f);
		}

		public static void CalculateLiftGammaGain(Color lift, Color gamma, Color gain, out Vector3 outLift, out Vector3 outGamma, out Vector3 outGain)
		{
			outLift = GetLiftValue(lift);
			outGamma = GetGammaValue(gamma);
			outGain = GetGainValue(gain);
		}

		public static Vector3 GetSlopeValue(Color slope)
		{
			Color color = NormalizeColor(slope);
			float num = (color.r + color.g + color.b) / 3f;
			slope.a *= 0.5f;
			float x = (color.r - num) * 0.1f + slope.a + 1f;
			float y = (color.g - num) * 0.1f + slope.a + 1f;
			float z = (color.b - num) * 0.1f + slope.a + 1f;
			return ClampVector(new Vector3(x, y, z), 0f, 2f);
		}

		public static Vector3 GetPowerValue(Color power)
		{
			Color color = NormalizeColor(power);
			float num = (color.r + color.g + color.b) / 3f;
			power.a *= 0.5f;
			float b = (color.r - num) * 0.1f + power.a + 1f;
			float b2 = (color.g - num) * 0.1f + power.a + 1f;
			float b3 = (color.b - num) * 0.1f + power.a + 1f;
			float x = 1f / Mathf.Max(0.01f, b);
			float y = 1f / Mathf.Max(0.01f, b2);
			float z = 1f / Mathf.Max(0.01f, b3);
			return ClampVector(new Vector3(x, y, z), 0.5f, 2.5f);
		}

		public static Vector3 GetOffsetValue(Color offset)
		{
			Color color = NormalizeColor(offset);
			float num = (color.r + color.g + color.b) / 3f;
			offset.a *= 0.5f;
			float x = (color.r - num) * 0.05f + offset.a;
			float y = (color.g - num) * 0.05f + offset.a;
			float z = (color.b - num) * 0.05f + offset.a;
			return ClampVector(new Vector3(x, y, z), -0.8f, 0.8f);
		}

		public static void CalculateSlopePowerOffset(Color slope, Color power, Color offset, out Vector3 outSlope, out Vector3 outPower, out Vector3 outOffset)
		{
			outSlope = GetSlopeValue(slope);
			outPower = GetPowerValue(power);
			outOffset = GetOffsetValue(offset);
		}

		private TextureFormat GetCurveFormat()
		{
			if (SystemInfo.SupportsTextureFormat(TextureFormat.RGBAHalf))
			{
				return TextureFormat.RGBAHalf;
			}
			return TextureFormat.RGBA32;
		}

		private Texture2D GetCurveTexture()
		{
			if (m_GradingCurves == null)
			{
				m_GradingCurves = new Texture2D(128, 2, GetCurveFormat(), mipChain: false, linear: true)
				{
					name = "Internal Curves Texture",
					hideFlags = HideFlags.DontSave,
					anisoLevel = 0,
					wrapMode = TextureWrapMode.Clamp,
					filterMode = FilterMode.Bilinear
				};
			}
			ColorGradingModel.CurvesSettings curves = base.model.settings.curves;
			curves.hueVShue.Cache();
			curves.hueVSsat.Cache();
			for (int i = 0; i < 128; i++)
			{
				float t = (float)i * (1f / 128f);
				float r = curves.hueVShue.Evaluate(t);
				float g = curves.hueVSsat.Evaluate(t);
				float b = curves.satVSsat.Evaluate(t);
				float a = curves.lumVSsat.Evaluate(t);
				m_pixels[i] = new Color(r, g, b, a);
				float a2 = curves.master.Evaluate(t);
				float r2 = curves.red.Evaluate(t);
				float g2 = curves.green.Evaluate(t);
				float b2 = curves.blue.Evaluate(t);
				m_pixels[i + 128] = new Color(r2, g2, b2, a2);
			}
			m_GradingCurves.SetPixels(m_pixels);
			m_GradingCurves.Apply(updateMipmaps: false, makeNoLongerReadable: false);
			return m_GradingCurves;
		}

		private bool IsLogLutValid(RenderTexture lut)
		{
			if (lut != null && lut.IsCreated())
			{
				return lut.height == 32;
			}
			return false;
		}

		private RenderTextureFormat GetLutFormat()
		{
			if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				return RenderTextureFormat.ARGBHalf;
			}
			return RenderTextureFormat.ARGB32;
		}

		private void GenerateLut()
		{
			ColorGradingModel.Settings settings = base.model.settings;
			if (!IsLogLutValid(base.model.bakedLut))
			{
				GraphicsUtils.Destroy(base.model.bakedLut);
				base.model.bakedLut = new RenderTexture(1024, 32, 0, GetLutFormat())
				{
					name = "Color Grading Log LUT",
					hideFlags = HideFlags.DontSave,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					anisoLevel = 0
				};
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Lut Generator");
			material.SetVector(Uniforms._LutParams, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
			material.shaderKeywords = null;
			ColorGradingModel.TonemappingSettings tonemapping = settings.tonemapping;
			switch (tonemapping.tonemapper)
			{
			case ColorGradingModel.Tonemapper.Neutral:
			{
				material.EnableKeyword("TONEMAPPING_NEUTRAL");
				float num = tonemapping.neutralBlackIn * 20f + 1f;
				float num2 = tonemapping.neutralBlackOut * 10f + 1f;
				float num3 = tonemapping.neutralWhiteIn / 20f;
				float num4 = 1f - tonemapping.neutralWhiteOut / 20f;
				float t = num / num2;
				float t2 = num3 / num4;
				float y = Mathf.Max(0f, Mathf.LerpUnclamped(0.57f, 0.37f, t));
				float z = Mathf.LerpUnclamped(0.01f, 0.24f, t2);
				float w = Mathf.Max(0f, Mathf.LerpUnclamped(0.02f, 0.2f, t));
				material.SetVector(Uniforms._NeutralTonemapperParams1, new Vector4(0.2f, y, z, w));
				material.SetVector(Uniforms._NeutralTonemapperParams2, new Vector4(0.02f, 0.3f, tonemapping.neutralWhiteLevel, tonemapping.neutralWhiteClip / 10f));
				break;
			}
			case ColorGradingModel.Tonemapper.ACES:
				material.EnableKeyword("TONEMAPPING_FILMIC");
				break;
			}
			material.SetFloat(Uniforms._HueShift, settings.basic.hueShift / 360f);
			material.SetFloat(Uniforms._Saturation, settings.basic.saturation);
			material.SetFloat(Uniforms._Contrast, settings.basic.contrast);
			material.SetVector(Uniforms._Balance, CalculateColorBalance(settings.basic.temperature, settings.basic.tint));
			CalculateLiftGammaGain(settings.colorWheels.linear.lift, settings.colorWheels.linear.gamma, settings.colorWheels.linear.gain, out var outLift, out var outGamma, out var outGain);
			material.SetVector(Uniforms._Lift, outLift);
			material.SetVector(Uniforms._InvGamma, outGamma);
			material.SetVector(Uniforms._Gain, outGain);
			CalculateSlopePowerOffset(settings.colorWheels.log.slope, settings.colorWheels.log.power, settings.colorWheels.log.offset, out var outSlope, out var outPower, out var outOffset);
			material.SetVector(Uniforms._Slope, outSlope);
			material.SetVector(Uniforms._Power, outPower);
			material.SetVector(Uniforms._Offset, outOffset);
			material.SetVector(Uniforms._ChannelMixerRed, settings.channelMixer.red);
			material.SetVector(Uniforms._ChannelMixerGreen, settings.channelMixer.green);
			material.SetVector(Uniforms._ChannelMixerBlue, settings.channelMixer.blue);
			material.SetTexture(Uniforms._Curves, GetCurveTexture());
			Graphics.Blit(null, base.model.bakedLut, material, 0);
		}

		public override void Prepare(Material uberMaterial)
		{
			if (base.model.isDirty || !IsLogLutValid(base.model.bakedLut))
			{
				GenerateLut();
				base.model.isDirty = false;
			}
			uberMaterial.EnableKeyword(context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.PreGradingLog) ? "COLOR_GRADING_LOG_VIEW" : "COLOR_GRADING");
			RenderTexture bakedLut = base.model.bakedLut;
			uberMaterial.SetTexture(Uniforms._LogLut, bakedLut);
			uberMaterial.SetVector(Uniforms._LogLut_Params, new Vector3(1f / (float)bakedLut.width, 1f / (float)bakedLut.height, (float)bakedLut.height - 1f));
			float value = Mathf.Exp(base.model.settings.basic.postExposure * 0.6931472f);
			uberMaterial.SetFloat(Uniforms._ExposureEV, value);
		}

		public void OnGUI()
		{
			RenderTexture bakedLut = base.model.bakedLut;
			GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, bakedLut.width, bakedLut.height), bakedLut);
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_GradingCurves);
			GraphicsUtils.Destroy(base.model.bakedLut);
			m_GradingCurves = null;
			base.model.bakedLut = null;
		}
	}
	public sealed class DepthOfFieldComponent : PostProcessingComponentRenderTexture<DepthOfFieldModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

			internal static readonly int _DepthOfFieldCoCTex = Shader.PropertyToID("_DepthOfFieldCoCTex");

			internal static readonly int _Distance = Shader.PropertyToID("_Distance");

			internal static readonly int _LensCoeff = Shader.PropertyToID("_LensCoeff");

			internal static readonly int _MaxCoC = Shader.PropertyToID("_MaxCoC");

			internal static readonly int _RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

			internal static readonly int _RcpAspect = Shader.PropertyToID("_RcpAspect");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _CoCTex = Shader.PropertyToID("_CoCTex");

			internal static readonly int _TaaParams = Shader.PropertyToID("_TaaParams");

			internal static readonly int _DepthOfFieldParams = Shader.PropertyToID("_DepthOfFieldParams");
		}

		private const string k_ShaderString = "Hidden/Post FX/Depth Of Field";

		private RenderTexture m_CoCHistory;

		private const float k_FilmHeight = 0.024f;

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		private float CalculateFocalLength()
		{
			DepthOfFieldModel.Settings settings = base.model.settings;
			if (!settings.useCameraFov)
			{
				return settings.focalLength / 1000f;
			}
			float num = context.camera.fieldOfView * ((float)Math.PI / 180f);
			return 0.012f / Mathf.Tan(0.5f * num);
		}

		private float CalculateMaxCoCRadius(int screenHeight)
		{
			float num = (float)base.model.settings.kernelSize * 4f + 6f;
			return Mathf.Min(0.05f, num / (float)screenHeight);
		}

		private bool CheckHistory(int width, int height)
		{
			if (m_CoCHistory != null && m_CoCHistory.IsCreated() && m_CoCHistory.width == width)
			{
				return m_CoCHistory.height == height;
			}
			return false;
		}

		private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
		{
			if (SystemInfo.SupportsRenderTextureFormat(primary))
			{
				return primary;
			}
			if (SystemInfo.SupportsRenderTextureFormat(secondary))
			{
				return secondary;
			}
			return RenderTextureFormat.Default;
		}

		public void Prepare(RenderTexture source, Material uberMaterial, bool antialiasCoC, Vector2 taaJitter, float taaBlending)
		{
			DepthOfFieldModel.Settings settings = base.model.settings;
			RenderTextureFormat format = RenderTextureFormat.DefaultHDR;
			RenderTextureFormat format2 = SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf);
			float num = CalculateFocalLength();
			float num2 = Mathf.Max(settings.focusDistance, num);
			float num3 = (float)source.width / (float)source.height;
			float num4 = num * num / (settings.aperture * (num2 - num) * 0.024f * 2f);
			float num5 = CalculateMaxCoCRadius(source.height);
			Material material = context.materialFactory.Get("Hidden/Post FX/Depth Of Field");
			material.SetFloat(Uniforms._Distance, num2);
			material.SetFloat(Uniforms._LensCoeff, num4);
			material.SetFloat(Uniforms._MaxCoC, num5);
			material.SetFloat(Uniforms._RcpMaxCoC, 1f / num5);
			material.SetFloat(Uniforms._RcpAspect, 1f / num3);
			RenderTexture renderTexture = context.renderTextureFactory.Get(context.width, context.height, 0, format2, RenderTextureReadWrite.Linear);
			Graphics.Blit(null, renderTexture, material, 0);
			if (antialiasCoC)
			{
				material.SetTexture(Uniforms._CoCTex, renderTexture);
				float z = (CheckHistory(context.width, context.height) ? taaBlending : 0f);
				material.SetVector(Uniforms._TaaParams, new Vector3(taaJitter.x, taaJitter.y, z));
				RenderTexture temporary = RenderTexture.GetTemporary(context.width, context.height, 0, format2);
				Graphics.Blit(m_CoCHistory, temporary, material, 1);
				context.renderTextureFactory.Release(renderTexture);
				if (m_CoCHistory != null)
				{
					RenderTexture.ReleaseTemporary(m_CoCHistory);
				}
				renderTexture = (m_CoCHistory = temporary);
			}
			RenderTexture renderTexture2 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
			material.SetTexture(Uniforms._CoCTex, renderTexture);
			Graphics.Blit(source, renderTexture2, material, 2);
			RenderTexture renderTexture3 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
			Graphics.Blit(renderTexture2, renderTexture3, material, (int)(3 + settings.kernelSize));
			Graphics.Blit(renderTexture3, renderTexture2, material, 7);
			uberMaterial.SetVector(Uniforms._DepthOfFieldParams, new Vector3(num2, num4, num5));
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.FocusPlane))
			{
				uberMaterial.EnableKeyword("DEPTH_OF_FIELD_COC_VIEW");
				context.Interrupt();
			}
			else
			{
				uberMaterial.SetTexture(Uniforms._DepthOfFieldTex, renderTexture2);
				uberMaterial.SetTexture(Uniforms._DepthOfFieldCoCTex, renderTexture);
				uberMaterial.EnableKeyword("DEPTH_OF_FIELD");
			}
			context.renderTextureFactory.Release(renderTexture3);
		}

		public override void OnDisable()
		{
			if (m_CoCHistory != null)
			{
				RenderTexture.ReleaseTemporary(m_CoCHistory);
			}
			m_CoCHistory = null;
		}
	}
	public sealed class DitheringComponent : PostProcessingComponentRenderTexture<DitheringModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DitheringTex = Shader.PropertyToID("_DitheringTex");

			internal static readonly int _DitheringCoords = Shader.PropertyToID("_DitheringCoords");
		}

		private Texture2D[] noiseTextures;

		private int textureIndex;

		private const int k_TextureCount = 64;

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			noiseTextures = null;
		}

		private void LoadNoiseTextures()
		{
			noiseTextures = new Texture2D[64];
			for (int i = 0; i < 64; i++)
			{
				noiseTextures[i] = Resources.Load<Texture2D>("Bluenoise64/LDR_LLL1_" + i);
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			if (++textureIndex >= 64)
			{
				textureIndex = 0;
			}
			float value = Random.value;
			float value2 = Random.value;
			if (noiseTextures == null)
			{
				LoadNoiseTextures();
			}
			Texture2D texture2D = noiseTextures[textureIndex];
			uberMaterial.EnableKeyword("DITHERING");
			uberMaterial.SetTexture(Uniforms._DitheringTex, texture2D);
			uberMaterial.SetVector(Uniforms._DitheringCoords, new Vector4((float)context.width / (float)texture2D.width, (float)context.height / (float)texture2D.height, value, value2));
		}
	}
	public sealed class EyeAdaptationComponent : PostProcessingComponentRenderTexture<EyeAdaptationModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Params = Shader.PropertyToID("_Params");

			internal static readonly int _Speed = Shader.PropertyToID("_Speed");

			internal static readonly int _ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");

			internal static readonly int _ExposureCompensation = Shader.PropertyToID("_ExposureCompensation");

			internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

			internal static readonly int _DebugWidth = Shader.PropertyToID("_DebugWidth");
		}

		private ComputeShader m_EyeCompute;

		private ComputeBuffer m_HistogramBuffer;

		private readonly RenderTexture[] m_AutoExposurePool = new RenderTexture[2];

		private int m_AutoExposurePingPing;

		private RenderTexture m_CurrentAutoExposure;

		private RenderTexture m_DebugHistogram;

		private static uint[] s_EmptyHistogramBuffer;

		private bool m_FirstFrame = true;

		private const int k_HistogramBins = 64;

		private const int k_HistogramThreadX = 16;

		private const int k_HistogramThreadY = 16;

		public override bool active
		{
			get
			{
				if (base.model.enabled && SystemInfo.supportsComputeShaders)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void ResetHistory()
		{
			m_FirstFrame = true;
		}

		public override void OnEnable()
		{
			m_FirstFrame = true;
		}

		public override void OnDisable()
		{
			RenderTexture[] autoExposurePool = m_AutoExposurePool;
			for (int i = 0; i < autoExposurePool.Length; i++)
			{
				GraphicsUtils.Destroy(autoExposurePool[i]);
			}
			if (m_HistogramBuffer != null)
			{
				m_HistogramBuffer.Release();
			}
			m_HistogramBuffer = null;
			if (m_DebugHistogram != null)
			{
				m_DebugHistogram.Release();
			}
			m_DebugHistogram = null;
		}

		private Vector4 GetHistogramScaleOffsetRes()
		{
			EyeAdaptationModel.Settings settings = base.model.settings;
			float num = settings.logMax - settings.logMin;
			float num2 = 1f / num;
			float y = (float)(-settings.logMin) * num2;
			return new Vector4(num2, y, Mathf.Floor((float)context.width / 2f), Mathf.Floor((float)context.height / 2f));
		}

		public Texture Prepare(RenderTexture source, Material uberMaterial)
		{
			EyeAdaptationModel.Settings settings = base.model.settings;
			if (m_EyeCompute == null)
			{
				m_EyeCompute = Resources.Load<ComputeShader>("Shaders/EyeHistogram");
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Eye Adaptation");
			material.shaderKeywords = null;
			if (m_HistogramBuffer == null)
			{
				m_HistogramBuffer = new ComputeBuffer(64, 4);
			}
			if (s_EmptyHistogramBuffer == null)
			{
				s_EmptyHistogramBuffer = new uint[64];
			}
			Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes();
			RenderTexture renderTexture = context.renderTextureFactory.Get((int)histogramScaleOffsetRes.z, (int)histogramScaleOffsetRes.w, 0, source.format);
			Graphics.Blit(source, renderTexture);
			if (m_AutoExposurePool[0] == null || !m_AutoExposurePool[0].IsCreated())
			{
				m_AutoExposurePool[0] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
			}
			if (m_AutoExposurePool[1] == null || !m_AutoExposurePool[1].IsCreated())
			{
				m_AutoExposurePool[1] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
			}
			m_HistogramBuffer.SetData(s_EmptyHistogramBuffer);
			int kernelIndex = m_EyeCompute.FindKernel("KEyeHistogram");
			m_EyeCompute.SetBuffer(kernelIndex, "_Histogram", m_HistogramBuffer);
			m_EyeCompute.SetTexture(kernelIndex, "_Source", renderTexture);
			m_EyeCompute.SetVector("_ScaleOffsetRes", histogramScaleOffsetRes);
			m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt((float)renderTexture.width / 16f), Mathf.CeilToInt((float)renderTexture.height / 16f), 1);
			context.renderTextureFactory.Release(renderTexture);
			settings.highPercent = Mathf.Clamp(settings.highPercent, 1.01f, 99f);
			settings.lowPercent = Mathf.Clamp(settings.lowPercent, 1f, settings.highPercent - 0.01f);
			material.SetBuffer("_Histogram", m_HistogramBuffer);
			material.SetVector(Uniforms._Params, new Vector4(settings.lowPercent * 0.01f, settings.highPercent * 0.01f, Mathf.Exp(settings.minLuminance * 0.6931472f), Mathf.Exp(settings.maxLuminance * 0.6931472f)));
			material.SetVector(Uniforms._Speed, new Vector2(settings.speedDown, settings.speedUp));
			material.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
			material.SetFloat(Uniforms._ExposureCompensation, settings.keyValue);
			if (settings.dynamicKeyValue)
			{
				material.EnableKeyword("AUTO_KEY_VALUE");
			}
			if (m_FirstFrame || !Application.isPlaying)
			{
				m_CurrentAutoExposure = m_AutoExposurePool[0];
				Graphics.Blit(null, m_CurrentAutoExposure, material, 1);
				Graphics.Blit(m_AutoExposurePool[0], m_AutoExposurePool[1]);
			}
			else
			{
				int autoExposurePingPing = m_AutoExposurePingPing;
				RenderTexture source2 = m_AutoExposurePool[++autoExposurePingPing % 2];
				RenderTexture renderTexture2 = m_AutoExposurePool[++autoExposurePingPing % 2];
				Graphics.Blit(source2, renderTexture2, material, (int)settings.adaptationType);
				m_AutoExposurePingPing = ++autoExposurePingPing % 2;
				m_CurrentAutoExposure = renderTexture2;
			}
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
			{
				if (m_DebugHistogram == null || !m_DebugHistogram.IsCreated())
				{
					m_DebugHistogram = new RenderTexture(256, 128, 0, RenderTextureFormat.ARGB32)
					{
						filterMode = FilterMode.Point,
						wrapMode = TextureWrapMode.Clamp
					};
				}
				material.SetFloat(Uniforms._DebugWidth, m_DebugHistogram.width);
				Graphics.Blit(null, m_DebugHistogram, material, 2);
			}
			m_FirstFrame = false;
			return m_CurrentAutoExposure;
		}

		public void OnGUI()
		{
			if (!(m_DebugHistogram == null) && m_DebugHistogram.IsCreated())
			{
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, m_DebugHistogram.width, m_DebugHistogram.height), m_DebugHistogram);
			}
		}
	}
	public sealed class FogComponent : PostProcessingComponentCommandBuffer<FogModel>
	{
		private static class Uniforms
		{
			internal static readonly int _FogColor = Shader.PropertyToID("_FogColor");

			internal static readonly int _Density = Shader.PropertyToID("_Density");

			internal static readonly int _Start = Shader.PropertyToID("_Start");

			internal static readonly int _End = Shader.PropertyToID("_End");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
		}

		private const string k_ShaderString = "Hidden/Post FX/Fog";

		public override bool active
		{
			get
			{
				if (base.model.enabled && context.isGBufferAvailable && RenderSettings.fog)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override string GetName()
		{
			return "Fog";
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.AfterImageEffectsOpaque;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			FogModel.Settings settings = base.model.settings;
			Material material = context.materialFactory.Get("Hidden/Post FX/Fog");
			material.shaderKeywords = null;
			Color value = (GraphicsUtils.isLinearColorSpace ? RenderSettings.fogColor.linear : RenderSettings.fogColor);
			material.SetColor(Uniforms._FogColor, value);
			material.SetFloat(Uniforms._Density, RenderSettings.fogDensity);
			material.SetFloat(Uniforms._Start, RenderSettings.fogStartDistance);
			material.SetFloat(Uniforms._End, RenderSettings.fogEndDistance);
			switch (RenderSettings.fogMode)
			{
			case FogMode.Linear:
				material.EnableKeyword("FOG_LINEAR");
				break;
			case FogMode.Exponential:
				material.EnableKeyword("FOG_EXP");
				break;
			case FogMode.ExponentialSquared:
				material.EnableKeyword("FOG_EXP2");
				break;
			}
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			cb.GetTemporaryRT(Uniforms._TempRT, context.width, context.height, 24, FilterMode.Bilinear, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, Uniforms._TempRT);
			cb.Blit(Uniforms._TempRT, BuiltinRenderTextureType.CameraTarget, material, settings.excludeSkybox ? 1 : 0);
			cb.ReleaseTemporaryRT(Uniforms._TempRT);
		}
	}
	public sealed class FxaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
	{
		private static class Uniforms
		{
			internal static readonly int _QualitySettings = Shader.PropertyToID("_QualitySettings");

			internal static readonly int _ConsoleSettings = Shader.PropertyToID("_ConsoleSettings");
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Fxaa)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void Render(RenderTexture source, RenderTexture destination)
		{
			AntialiasingModel.FxaaSettings fxaaSettings = base.model.settings.fxaaSettings;
			Material material = context.materialFactory.Get("Hidden/Post FX/FXAA");
			AntialiasingModel.FxaaQualitySettings fxaaQualitySettings = AntialiasingModel.FxaaQualitySettings.presets[(int)fxaaSettings.preset];
			AntialiasingModel.FxaaConsoleSettings fxaaConsoleSettings = AntialiasingModel.FxaaConsoleSettings.presets[(int)fxaaSettings.preset];
			material.SetVector(Uniforms._QualitySettings, new Vector3(fxaaQualitySettings.subpixelAliasingRemovalAmount, fxaaQualitySettings.edgeDetectionThreshold, fxaaQualitySettings.minimumRequiredLuminance));
			material.SetVector(Uniforms._ConsoleSettings, new Vector4(fxaaConsoleSettings.subpixelSpreadAmount, fxaaConsoleSettings.edgeSharpnessAmount, fxaaConsoleSettings.edgeDetectionThreshold, fxaaConsoleSettings.minimumRequiredLuminance));
			Graphics.Blit(source, destination, material, 0);
		}
	}
	public sealed class GrainComponent : PostProcessingComponentRenderTexture<GrainModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

			internal static readonly int _Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

			internal static readonly int _GrainTex = Shader.PropertyToID("_GrainTex");

			internal static readonly int _Phase = Shader.PropertyToID("_Phase");
		}

		private RenderTexture m_GrainLookupRT;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f && SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_GrainLookupRT);
			m_GrainLookupRT = null;
		}

		public override void Prepare(Material uberMaterial)
		{
			GrainModel.Settings settings = base.model.settings;
			uberMaterial.EnableKeyword("GRAIN");
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float value = Random.value;
			float value2 = Random.value;
			if (m_GrainLookupRT == null || !m_GrainLookupRT.IsCreated())
			{
				GraphicsUtils.Destroy(m_GrainLookupRT);
				m_GrainLookupRT = new RenderTexture(192, 192, 0, RenderTextureFormat.ARGBHalf)
				{
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Repeat,
					anisoLevel = 0,
					name = "Grain Lookup Texture"
				};
				m_GrainLookupRT.Create();
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Grain Generator");
			material.SetFloat(Uniforms._Phase, realtimeSinceStartup / 20f);
			Graphics.Blit(null, m_GrainLookupRT, material, settings.colored ? 1 : 0);
			uberMaterial.SetTexture(Uniforms._GrainTex, m_GrainLookupRT);
			uberMaterial.SetVector(Uniforms._Grain_Params1, new Vector2(settings.luminanceContribution, settings.intensity * 20f));
			uberMaterial.SetVector(Uniforms._Grain_Params2, new Vector4((float)context.width / (float)m_GrainLookupRT.width / settings.size, (float)context.height / (float)m_GrainLookupRT.height / settings.size, value, value2));
		}
	}
	public sealed class MotionBlurComponent : PostProcessingComponentCommandBuffer<MotionBlurModel>
	{
		private static class Uniforms
		{
			internal static readonly int _VelocityScale = Shader.PropertyToID("_VelocityScale");

			internal static readonly int _MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

			internal static readonly int _RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

			internal static readonly int _VelocityTex = Shader.PropertyToID("_VelocityTex");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _Tile2RT = Shader.PropertyToID("_Tile2RT");

			internal static readonly int _Tile4RT = Shader.PropertyToID("_Tile4RT");

			internal static readonly int _Tile8RT = Shader.PropertyToID("_Tile8RT");

			internal static readonly int _TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

			internal static readonly int _TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

			internal static readonly int _TileVRT = Shader.PropertyToID("_TileVRT");

			internal static readonly int _NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

			internal static readonly int _LoopCount = Shader.PropertyToID("_LoopCount");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

			internal static readonly int _History1LumaTex = Shader.PropertyToID("_History1LumaTex");

			internal static readonly int _History2LumaTex = Shader.PropertyToID("_History2LumaTex");

			internal static readonly int _History3LumaTex = Shader.PropertyToID("_History3LumaTex");

			internal static readonly int _History4LumaTex = Shader.PropertyToID("_History4LumaTex");

			internal static readonly int _History1ChromaTex = Shader.PropertyToID("_History1ChromaTex");

			internal static readonly int _History2ChromaTex = Shader.PropertyToID("_History2ChromaTex");

			internal static readonly int _History3ChromaTex = Shader.PropertyToID("_History3ChromaTex");

			internal static readonly int _History4ChromaTex = Shader.PropertyToID("_History4ChromaTex");

			internal static readonly int _History1Weight = Shader.PropertyToID("_History1Weight");

			internal static readonly int _History2Weight = Shader.PropertyToID("_History2Weight");

			internal static readonly int _History3Weight = Shader.PropertyToID("_History3Weight");

			internal static readonly int _History4Weight = Shader.PropertyToID("_History4Weight");
		}

		private enum Pass
		{
			VelocitySetup,
			TileMax1,
			TileMax2,
			TileMaxV,
			NeighborMax,
			Reconstruction,
			FrameCompression,
			FrameBlendingChroma,
			FrameBlendingRaw
		}

		public class ReconstructionFilter
		{
			private RenderTextureFormat m_VectorRTFormat = RenderTextureFormat.RGHalf;

			private RenderTextureFormat m_PackedRTFormat = RenderTextureFormat.ARGB2101010;

			public ReconstructionFilter()
			{
				CheckTextureFormatSupport();
			}

			private void CheckTextureFormatSupport()
			{
				if (!SystemInfo.SupportsRenderTextureFormat(m_PackedRTFormat))
				{
					m_PackedRTFormat = RenderTextureFormat.ARGB32;
				}
			}

			public bool IsSupported()
			{
				return SystemInfo.supportsMotionVectors;
			}

			public void ProcessImage(PostProcessingContext context, CommandBuffer cb, ref MotionBlurModel.Settings settings, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
			{
				int num = (int)(5f * (float)context.height / 100f);
				int num2 = ((num - 1) / 8 + 1) * 8;
				float value = settings.shutterAngle / 360f;
				cb.SetGlobalFloat(Uniforms._VelocityScale, value);
				cb.SetGlobalFloat(Uniforms._MaxBlurRadius, num);
				cb.SetGlobalFloat(Uniforms._RcpMaxBlurRadius, 1f / (float)num);
				int velocityTex = Uniforms._VelocityTex;
				cb.GetTemporaryRT(velocityTex, context.width, context.height, 0, FilterMode.Point, m_PackedRTFormat, RenderTextureReadWrite.Linear);
				cb.Blit(null, velocityTex, material, 0);
				int tile2RT = Uniforms._Tile2RT;
				cb.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, velocityTex);
				cb.Blit(velocityTex, tile2RT, material, 1);
				int tile4RT = Uniforms._Tile4RT;
				cb.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile2RT);
				cb.Blit(tile2RT, tile4RT, material, 2);
				cb.ReleaseTemporaryRT(tile2RT);
				int tile8RT = Uniforms._Tile8RT;
				cb.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile4RT);
				cb.Blit(tile4RT, tile8RT, material, 2);
				cb.ReleaseTemporaryRT(tile4RT);
				Vector2 vector = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
				cb.SetGlobalVector(Uniforms._TileMaxOffs, vector);
				cb.SetGlobalFloat(Uniforms._TileMaxLoop, (int)((float)num2 / 8f));
				int tileVRT = Uniforms._TileVRT;
				cb.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile8RT);
				cb.Blit(tile8RT, tileVRT, material, 3);
				cb.ReleaseTemporaryRT(tile8RT);
				int neighborMaxTex = Uniforms._NeighborMaxTex;
				int width = context.width / num2;
				int height = context.height / num2;
				cb.GetTemporaryRT(neighborMaxTex, width, height, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tileVRT);
				cb.Blit(tileVRT, neighborMaxTex, material, 4);
				cb.ReleaseTemporaryRT(tileVRT);
				cb.SetGlobalFloat(Uniforms._LoopCount, Mathf.Clamp(settings.sampleCount / 2, 1, 64));
				cb.SetGlobalTexture(Uniforms._MainTex, source);
				cb.Blit(source, destination, material, 5);
				cb.ReleaseTemporaryRT(velocityTex);
				cb.ReleaseTemporaryRT(neighborMaxTex);
			}
		}

		public class FrameBlendingFilter
		{
			private struct Frame
			{
				public RenderTexture lumaTexture;

				public RenderTexture chromaTexture;

				private float m_Time;

				private RenderTargetIdentifier[] m_MRT;

				public float CalculateWeight(float strength, float currentTime)
				{
					if (Mathf.Approximately(m_Time, 0f))
					{
						return 0f;
					}
					float num = Mathf.Lerp(80f, 16f, strength);
					return Mathf.Exp((m_Time - currentTime) * num);
				}

				public void Release()
				{
					if (lumaTexture != null)
					{
						RenderTexture.ReleaseTemporary(lumaTexture);
					}
					if (chromaTexture != null)
					{
						RenderTexture.ReleaseTemporary(chromaTexture);
					}
					lumaTexture = null;
					chromaTexture = null;
				}

				public void MakeRecord(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
				{
					Release();
					lumaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
					chromaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
					lumaTexture.filterMode = FilterMode.Point;
					chromaTexture.filterMode = FilterMode.Point;
					if (m_MRT == null)
					{
						m_MRT = new RenderTargetIdentifier[2];
					}
					m_MRT[0] = lumaTexture;
					m_MRT[1] = chromaTexture;
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.SetRenderTarget(m_MRT, lumaTexture);
					cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 6);
					m_Time = Time.time;
				}

				public void MakeRecordRaw(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, RenderTextureFormat format)
				{
					Release();
					lumaTexture = RenderTexture.GetTemporary(width, height, 0, format);
					lumaTexture.filterMode = FilterMode.Point;
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, lumaTexture);
					m_Time = Time.time;
				}
			}

			private bool m_UseCompression;

			private RenderTextureFormat m_RawTextureFormat;

			private Frame[] m_FrameList;

			private int m_LastFrameCount;

			public FrameBlendingFilter()
			{
				m_UseCompression = CheckSupportCompression();
				m_RawTextureFormat = GetPreferredRenderTextureFormat();
				m_FrameList = new Frame[4];
			}

			public void Dispose()
			{
				Frame[] frameList = m_FrameList;
				foreach (Frame frame in frameList)
				{
					frame.Release();
				}
			}

			public void PushFrame(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
			{
				int frameCount = Time.frameCount;
				if (frameCount != m_LastFrameCount)
				{
					int num = frameCount % m_FrameList.Length;
					if (m_UseCompression)
					{
						m_FrameList[num].MakeRecord(cb, source, width, height, material);
					}
					else
					{
						m_FrameList[num].MakeRecordRaw(cb, source, width, height, m_RawTextureFormat);
					}
					m_LastFrameCount = frameCount;
				}
			}

			public void BlendFrames(CommandBuffer cb, float strength, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
			{
				float time = Time.time;
				Frame frameRelative = GetFrameRelative(-1);
				Frame frameRelative2 = GetFrameRelative(-2);
				Frame frameRelative3 = GetFrameRelative(-3);
				Frame frameRelative4 = GetFrameRelative(-4);
				cb.SetGlobalTexture(Uniforms._History1LumaTex, frameRelative.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History2LumaTex, frameRelative2.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History3LumaTex, frameRelative3.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History4LumaTex, frameRelative4.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History1ChromaTex, frameRelative.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History2ChromaTex, frameRelative2.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History3ChromaTex, frameRelative3.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History4ChromaTex, frameRelative4.chromaTexture);
				cb.SetGlobalFloat(Uniforms._History1Weight, frameRelative.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History2Weight, frameRelative2.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History3Weight, frameRelative3.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History4Weight, frameRelative4.CalculateWeight(strength, time));
				cb.SetGlobalTexture(Uniforms._MainTex, source);
				cb.Blit(source, destination, material, m_UseCompression ? 7 : 8);
			}

			private static bool CheckSupportCompression()
			{
				if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.R8))
				{
					return SystemInfo.supportedRenderTargetCount > 1;
				}
				return false;
			}

			private static RenderTextureFormat GetPreferredRenderTextureFormat()
			{
				RenderTextureFormat[] array = new RenderTextureFormat[3]
				{
					RenderTextureFormat.RGB565,
					RenderTextureFormat.ARGB1555,
					RenderTextureFormat.ARGB4444
				};
				foreach (RenderTextureFormat renderTextureFormat in array)
				{
					if (SystemInfo.SupportsRenderTextureFormat(renderTextureFormat))
					{
						return renderTextureFormat;
					}
				}
				return RenderTextureFormat.Default;
			}

			private Frame GetFrameRelative(int offset)
			{
				int num = (Time.frameCount + m_FrameList.Length + offset) % m_FrameList.Length;
				return m_FrameList[num];
			}
		}

		private ReconstructionFilter m_ReconstructionFilter;

		private FrameBlendingFilter m_FrameBlendingFilter;

		private bool m_FirstFrame = true;

		public ReconstructionFilter reconstructionFilter
		{
			get
			{
				if (m_ReconstructionFilter == null)
				{
					m_ReconstructionFilter = new ReconstructionFilter();
				}
				return m_ReconstructionFilter;
			}
		}

		public FrameBlendingFilter frameBlendingFilter
		{
			get
			{
				if (m_FrameBlendingFilter == null)
				{
					m_FrameBlendingFilter = new FrameBlendingFilter();
				}
				return m_FrameBlendingFilter;
			}
		}

		public override bool active
		{
			get
			{
				MotionBlurModel.Settings settings = base.model.settings;
				if (base.model.enabled && ((settings.shutterAngle > 0f && reconstructionFilter.IsSupported()) || settings.frameBlending > 0f) && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override string GetName()
		{
			return "Motion Blur";
		}

		public void ResetHistory()
		{
			if (m_FrameBlendingFilter != null)
			{
				m_FrameBlendingFilter.Dispose();
			}
			m_FrameBlendingFilter = null;
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.BeforeImageEffects;
		}

		public override void OnEnable()
		{
			m_FirstFrame = true;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			if (m_FirstFrame)
			{
				m_FirstFrame = false;
				return;
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Motion Blur");
			Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
			MotionBlurModel.Settings settings = base.model.settings;
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			int tempRT = Uniforms._TempRT;
			cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Point, format);
			if (settings.shutterAngle > 0f && settings.frameBlending > 0f)
			{
				reconstructionFilter.ProcessImage(context, cb, ref settings, BuiltinRenderTextureType.CameraTarget, tempRT, material);
				frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
			}
			else if (settings.shutterAngle > 0f)
			{
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				reconstructionFilter.ProcessImage(context, cb, ref settings, tempRT, BuiltinRenderTextureType.CameraTarget, material);
			}
			else if (settings.frameBlending > 0f)
			{
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
			}
			cb.ReleaseTemporaryRT(tempRT);
		}

		public override void OnDisable()
		{
			if (m_FrameBlendingFilter != null)
			{
				m_FrameBlendingFilter.Dispose();
			}
		}
	}
	public sealed class ScreenSpaceReflectionComponent : PostProcessingComponentCommandBuffer<ScreenSpaceReflectionModel>
	{
		private static class Uniforms
		{
			internal static readonly int _RayStepSize = Shader.PropertyToID("_RayStepSize");

			internal static readonly int _AdditiveReflection = Shader.PropertyToID("_AdditiveReflection");

			internal static readonly int _BilateralUpsampling = Shader.PropertyToID("_BilateralUpsampling");

			internal static readonly int _TreatBackfaceHitAsMiss = Shader.PropertyToID("_TreatBackfaceHitAsMiss");

			internal static readonly int _AllowBackwardsRays = Shader.PropertyToID("_AllowBackwardsRays");

			internal static readonly int _TraceBehindObjects = Shader.PropertyToID("_TraceBehindObjects");

			internal static readonly int _MaxSteps = Shader.PropertyToID("_MaxSteps");

			internal static readonly int _FullResolutionFiltering = Shader.PropertyToID("_FullResolutionFiltering");

			internal static readonly int _HalfResolution = Shader.PropertyToID("_HalfResolution");

			internal static readonly int _HighlightSuppression = Shader.PropertyToID("_HighlightSuppression");

			internal static readonly int _PixelsPerMeterAtOneMeter = Shader.PropertyToID("_PixelsPerMeterAtOneMeter");

			internal static readonly int _ScreenEdgeFading = Shader.PropertyToID("_ScreenEdgeFading");

			internal static readonly int _ReflectionBlur = Shader.PropertyToID("_ReflectionBlur");

			internal static readonly int _MaxRayTraceDistance = Shader.PropertyToID("_MaxRayTraceDistance");

			internal static readonly int _FadeDistance = Shader.PropertyToID("_FadeDistance");

			internal static readonly int _LayerThickness = Shader.PropertyToID("_LayerThickness");

			internal static readonly int _SSRMultiplier = Shader.PropertyToID("_SSRMultiplier");

			internal static readonly int _FresnelFade = Shader.PropertyToID("_FresnelFade");

			internal static readonly int _FresnelFadePower = Shader.PropertyToID("_FresnelFadePower");

			internal static readonly int _ReflectionBufferSize = Shader.PropertyToID("_ReflectionBufferSize");

			internal static readonly int _ScreenSize = Shader.PropertyToID("_ScreenSize");

			internal static readonly int _InvScreenSize = Shader.PropertyToID("_InvScreenSize");

			internal static readonly int _ProjInfo = Shader.PropertyToID("_ProjInfo");

			internal static readonly int _CameraClipInfo = Shader.PropertyToID("_CameraClipInfo");

			internal static readonly int _ProjectToPixelMatrix = Shader.PropertyToID("_ProjectToPixelMatrix");

			internal static readonly int _WorldToCameraMatrix = Shader.PropertyToID("_WorldToCameraMatrix");

			internal static readonly int _CameraToWorldMatrix = Shader.PropertyToID("_CameraToWorldMatrix");

			internal static readonly int _Axis = Shader.PropertyToID("_Axis");

			internal static readonly int _CurrentMipLevel = Shader.PropertyToID("_CurrentMipLevel");

			internal static readonly int _NormalAndRoughnessTexture = Shader.PropertyToID("_NormalAndRoughnessTexture");

			internal static readonly int _HitPointTexture = Shader.PropertyToID("_HitPointTexture");

			internal static readonly int _BlurTexture = Shader.PropertyToID("_BlurTexture");

			internal static readonly int _FilteredReflections = Shader.PropertyToID("_FilteredReflections");

			internal static readonly int _FinalReflectionTexture = Shader.PropertyToID("_FinalReflectionTexture");

			internal static readonly int _TempTexture = Shader.PropertyToID("_TempTexture");
		}

		private enum PassIndex
		{
			RayTraceStep,
			CompositeFinal,
			Blur,
			CompositeSSR,
			MinMipGeneration,
			HitPointToReflections,
			BilateralKeyPack,
			BlitDepthAsCSZ,
			PoissonBlur
		}

		private bool k_HighlightSuppression;

		private bool k_TraceBehindObjects = true;

		private bool k_TreatBackfaceHitAsMiss;

		private bool k_BilateralUpsample = true;

		private readonly int[] m_ReflectionTextures = new int[5];

		public override bool active
		{
			get
			{
				if (base.model.enabled && context.isGBufferAvailable)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public override void OnEnable()
		{
			m_ReflectionTextures[0] = Shader.PropertyToID("_ReflectionTexture0");
			m_ReflectionTextures[1] = Shader.PropertyToID("_ReflectionTexture1");
			m_ReflectionTextures[2] = Shader.PropertyToID("_ReflectionTexture2");
			m_ReflectionTextures[3] = Shader.PropertyToID("_ReflectionTexture3");
			m_ReflectionTextures[4] = Shader.PropertyToID("_ReflectionTexture4");
		}

		public override string GetName()
		{
			return "Screen Space Reflection";
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.AfterFinalPass;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			ScreenSpaceReflectionModel.Settings settings = base.model.settings;
			Camera camera = context.camera;
			int num = ((settings.reflection.reflectionQuality == ScreenSpaceReflectionModel.SSRResolution.High) ? 1 : 2);
			int num2 = context.width / num;
			int num3 = context.height / num;
			float num4 = context.width;
			float num5 = context.height;
			float num6 = num4 / 2f;
			float num7 = num5 / 2f;
			Material material = context.materialFactory.Get("Hidden/Post FX/Screen Space Reflection");
			material.SetInt(Uniforms._RayStepSize, settings.reflection.stepSize);
			material.SetInt(Uniforms._AdditiveReflection, (settings.reflection.blendType == ScreenSpaceReflectionModel.SSRReflectionBlendType.Additive) ? 1 : 0);
			material.SetInt(Uniforms._BilateralUpsampling, k_BilateralUpsample ? 1 : 0);
			material.SetInt(Uniforms._TreatBackfaceHitAsMiss, k_TreatBackfaceHitAsMiss ? 1 : 0);
			material.SetInt(Uniforms._AllowBackwardsRays, settings.reflection.reflectBackfaces ? 1 : 0);
			material.SetInt(Uniforms._TraceBehindObjects, k_TraceBehindObjects ? 1 : 0);
			material.SetInt(Uniforms._MaxSteps, settings.reflection.iterationCount);
			material.SetInt(Uniforms._FullResolutionFiltering, 0);
			material.SetInt(Uniforms._HalfResolution, (settings.reflection.reflectionQuality != 0) ? 1 : 0);
			material.SetInt(Uniforms._HighlightSuppression, k_HighlightSuppression ? 1 : 0);
			float value = num4 / (-2f * Mathf.Tan(camera.fieldOfView / 180f * (float)Math.PI * 0.5f));
			material.SetFloat(Uniforms._PixelsPerMeterAtOneMeter, value);
			material.SetFloat(Uniforms._ScreenEdgeFading, settings.screenEdgeMask.intensity);
			material.SetFloat(Uniforms._ReflectionBlur, settings.reflection.reflectionBlur);
			material.SetFloat(Uniforms._MaxRayTraceDistance, settings.reflection.maxDistance);
			material.SetFloat(Uniforms._FadeDistance, settings.intensity.fadeDistance);
			material.SetFloat(Uniforms._LayerThickness, settings.reflection.widthModifier);
			material.SetFloat(Uniforms._SSRMultiplier, settings.intensity.reflectionMultiplier);
			material.SetFloat(Uniforms._FresnelFade, settings.intensity.fresnelFade);
			material.SetFloat(Uniforms._FresnelFadePower, settings.intensity.fresnelFadePower);
			Matrix4x4 projectionMatrix = camera.projectionMatrix;
			Vector4 value2 = new Vector4(-2f / (num4 * projectionMatrix[0]), -2f / (num5 * projectionMatrix[5]), (1f - projectionMatrix[2]) / projectionMatrix[0], (1f + projectionMatrix[6]) / projectionMatrix[5]);
			Vector3 vector = (float.IsPositiveInfinity(camera.farClipPlane) ? new Vector3(camera.nearClipPlane, -1f, 1f) : new Vector3(camera.nearClipPlane * camera.farClipPlane, camera.nearClipPlane - camera.farClipPlane, camera.farClipPlane));
			material.SetVector(Uniforms._ReflectionBufferSize, new Vector2(num2, num3));
			material.SetVector(Uniforms._ScreenSize, new Vector2(num4, num5));
			material.SetVector(Uniforms._InvScreenSize, new Vector2(1f / num4, 1f / num5));
			material.SetVector(Uniforms._ProjInfo, value2);
			material.SetVector(Uniforms._CameraClipInfo, vector);
			Matrix4x4 matrix4x = default(Matrix4x4);
			matrix4x.SetRow(0, new Vector4(num6, 0f, 0f, num6));
			matrix4x.SetRow(1, new Vector4(0f, num7, 0f, num7));
			matrix4x.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
			matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
			Matrix4x4 value3 = matrix4x * projectionMatrix;
			material.SetMatrix(Uniforms._ProjectToPixelMatrix, value3);
			material.SetMatrix(Uniforms._WorldToCameraMatrix, camera.worldToCameraMatrix);
			material.SetMatrix(Uniforms._CameraToWorldMatrix, camera.worldToCameraMatrix.inverse);
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
			int normalAndRoughnessTexture = Uniforms._NormalAndRoughnessTexture;
			int hitPointTexture = Uniforms._HitPointTexture;
			int blurTexture = Uniforms._BlurTexture;
			int filteredReflections = Uniforms._FilteredReflections;
			int finalReflectionTexture = Uniforms._FinalReflectionTexture;
			int tempTexture = Uniforms._TempTexture;
			cb.GetTemporaryRT(normalAndRoughnessTexture, -1, -1, 0, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.GetTemporaryRT(hitPointTexture, num2, num3, 0, FilterMode.Bilinear, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
			for (int i = 0; i < 5; i++)
			{
				cb.GetTemporaryRT(m_ReflectionTextures[i], num2 >> i, num3 >> i, 0, FilterMode.Bilinear, format);
			}
			cb.GetTemporaryRT(filteredReflections, num2, num3, 0, (!k_BilateralUpsample) ? FilterMode.Bilinear : FilterMode.Point, format);
			cb.GetTemporaryRT(finalReflectionTexture, num2, num3, 0, FilterMode.Point, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, normalAndRoughnessTexture, material, 6);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, hitPointTexture, material, 0);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, filteredReflections, material, 5);
			cb.Blit(filteredReflections, m_ReflectionTextures[0], material, 8);
			for (int j = 1; j < 5; j++)
			{
				int num8 = m_ReflectionTextures[j - 1];
				int num9 = j;
				cb.GetTemporaryRT(blurTexture, num2 >> num9, num3 >> num9, 0, FilterMode.Bilinear, format);
				cb.SetGlobalVector(Uniforms._Axis, new Vector4(1f, 0f, 0f, 0f));
				cb.SetGlobalFloat(Uniforms._CurrentMipLevel, (float)j - 1f);
				cb.Blit(num8, blurTexture, material, 2);
				cb.SetGlobalVector(Uniforms._Axis, new Vector4(0f, 1f, 0f, 0f));
				num8 = m_ReflectionTextures[j];
				cb.Blit(blurTexture, num8, material, 2);
				cb.ReleaseTemporaryRT(blurTexture);
			}
			cb.Blit(m_ReflectionTextures[0], finalReflectionTexture, material, 3);
			cb.GetTemporaryRT(tempTexture, camera.pixelWidth, camera.pixelHeight, 0, FilterMode.Bilinear, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, tempTexture, material, 1);
			cb.Blit(tempTexture, BuiltinRenderTextureType.CameraTarget);
			cb.ReleaseTemporaryRT(tempTexture);
		}
	}
	public sealed class TaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
	{
		private static class Uniforms
		{
			internal static int _Jitter = Shader.PropertyToID("_Jitter");

			internal static int _SharpenParameters = Shader.PropertyToID("_SharpenParameters");

			internal static int _FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

			internal static int _HistoryTex = Shader.PropertyToID("_HistoryTex");

			internal static int _MainTex = Shader.PropertyToID("_MainTex");
		}

		private const string k_ShaderString = "Hidden/Post FX/Temporal Anti-aliasing";

		private const int k_SampleCount = 8;

		private readonly RenderBuffer[] m_MRT = new RenderBuffer[2];

		private int m_SampleIndex;

		private bool m_ResetHistory = true;

		private RenderTexture m_HistoryTexture;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Taa && SystemInfo.supportsMotionVectors && SystemInfo.supportedRenderTargetCount >= 2)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public Vector2 jitterVector { get; private set; }

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public void ResetHistory()
		{
			m_ResetHistory = true;
		}

		public void SetProjectionMatrix(Func<Vector2, Matrix4x4> jitteredFunc)
		{
			AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
			Vector2 vector = GenerateRandomOffset();
			vector *= taaSettings.jitterSpread;
			context.camera.nonJitteredProjectionMatrix = context.camera.projectionMatrix;
			if (jitteredFunc != null)
			{
				context.camera.projectionMatrix = jitteredFunc(vector);
			}
			else
			{
				context.camera.projectionMatrix = (context.camera.orthographic ? GetOrthographicProjectionMatrix(vector) : GetPerspectiveProjectionMatrix(vector));
			}
			context.camera.useJitteredProjectionMatrixForTransparentRendering = false;
			vector.x /= context.width;
			vector.y /= context.height;
			context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing").SetVector(Uniforms._Jitter, vector);
			jitterVector = vector;
		}

		public void Render(RenderTexture source, RenderTexture destination)
		{
			Material material = context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing");
			material.shaderKeywords = null;
			AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
			if (m_ResetHistory || m_HistoryTexture == null || m_HistoryTexture.width != source.width || m_HistoryTexture.height != source.height)
			{
				if ((bool)m_HistoryTexture)
				{
					RenderTexture.ReleaseTemporary(m_HistoryTexture);
				}
				m_HistoryTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				m_HistoryTexture.name = "TAA History";
				Graphics.Blit(source, m_HistoryTexture, material, 2);
			}
			material.SetVector(Uniforms._SharpenParameters, new Vector4(taaSettings.sharpen, 0f, 0f, 0f));
			material.SetVector(Uniforms._FinalBlendParameters, new Vector4(taaSettings.stationaryBlending, taaSettings.motionBlending, 6000f, 0f));
			material.SetTexture(Uniforms._MainTex, source);
			material.SetTexture(Uniforms._HistoryTex, m_HistoryTexture);
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
			temporary.name = "TAA History";
			m_MRT[0] = destination.colorBuffer;
			m_MRT[1] = temporary.colorBuffer;
			Graphics.SetRenderTarget(m_MRT, source.depthBuffer);
			GraphicsUtils.Blit(material, context.camera.orthographic ? 1 : 0);
			RenderTexture.ReleaseTemporary(m_HistoryTexture);
			m_HistoryTexture = temporary;
			m_ResetHistory = false;
		}

		private float GetHaltonValue(int index, int radix)
		{
			float num = 0f;
			float num2 = 1f / (float)radix;
			while (index > 0)
			{
				num += (float)(index % radix) * num2;
				index /= radix;
				num2 /= (float)radix;
			}
			return num;
		}

		private Vector2 GenerateRandomOffset()
		{
			Vector2 result = new Vector2(GetHaltonValue(m_SampleIndex & 0x3FF, 2), GetHaltonValue(m_SampleIndex & 0x3FF, 3));
			if (++m_SampleIndex >= 8)
			{
				m_SampleIndex = 0;
			}
			return result;
		}

		private Matrix4x4 GetPerspectiveProjectionMatrix(Vector2 offset)
		{
			float num = Mathf.Tan((float)Math.PI / 360f * context.camera.fieldOfView);
			float num2 = num * context.camera.aspect;
			offset.x *= num2 / (0.5f * (float)context.width);
			offset.y *= num / (0.5f * (float)context.height);
			float num3 = (offset.x - num2) * context.camera.nearClipPlane;
			float num4 = (offset.x + num2) * context.camera.nearClipPlane;
			float num5 = (offset.y + num) * context.camera.nearClipPlane;
			float num6 = (offset.y - num) * context.camera.nearClipPlane;
			Matrix4x4 result = default(Matrix4x4);
			result[0, 0] = 2f * context.camera.nearClipPlane / (num4 - num3);
			result[0, 1] = 0f;
			result[0, 2] = (num4 + num3) / (num4 - num3);
			result[0, 3] = 0f;
			result[1, 0] = 0f;
			result[1, 1] = 2f * context.camera.nearClipPlane / (num5 - num6);
			result[1, 2] = (num5 + num6) / (num5 - num6);
			result[1, 3] = 0f;
			result[2, 0] = 0f;
			result[2, 1] = 0f;
			result[2, 2] = (0f - (context.camera.farClipPlane + context.camera.nearClipPlane)) / (context.camera.farClipPlane - context.camera.nearClipPlane);
			result[2, 3] = (0f - 2f * context.camera.farClipPlane * context.camera.nearClipPlane) / (context.camera.farClipPlane - context.camera.nearClipPlane);
			result[3, 0] = 0f;
			result[3, 1] = 0f;
			result[3, 2] = -1f;
			result[3, 3] = 0f;
			return result;
		}

		private Matrix4x4 GetOrthographicProjectionMatrix(Vector2 offset)
		{
			float orthographicSize = context.camera.orthographicSize;
			float num = orthographicSize * context.camera.aspect;
			offset.x *= num / (0.5f * (float)context.width);
			offset.y *= orthographicSize / (0.5f * (float)context.height);
			float left = offset.x - num;
			float right = offset.x + num;
			float top = offset.y + orthographicSize;
			float bottom = offset.y - orthographicSize;
			return Matrix4x4.Ortho(left, right, bottom, top, context.camera.nearClipPlane, context.camera.farClipPlane);
		}

		public override void OnDisable()
		{
			if (m_HistoryTexture != null)
			{
				RenderTexture.ReleaseTemporary(m_HistoryTexture);
			}
			m_HistoryTexture = null;
			m_SampleIndex = 0;
			ResetHistory();
		}
	}
	public sealed class UserLutComponent : PostProcessingComponentRenderTexture<UserLutModel>
	{
		private static class Uniforms
		{
			internal static readonly int _UserLut = Shader.PropertyToID("_UserLut");

			internal static readonly int _UserLut_Params = Shader.PropertyToID("_UserLut_Params");
		}

		public override bool active
		{
			get
			{
				UserLutModel.Settings settings = base.model.settings;
				if (base.model.enabled && settings.lut != null && settings.contribution > 0f && settings.lut.height == (int)Mathf.Sqrt(settings.lut.width))
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			UserLutModel.Settings settings = base.model.settings;
			uberMaterial.EnableKeyword("USER_LUT");
			uberMaterial.SetTexture(Uniforms._UserLut, settings.lut);
			uberMaterial.SetVector(Uniforms._UserLut_Params, new Vector4(1f / (float)settings.lut.width, 1f / (float)settings.lut.height, (float)settings.lut.height - 1f, settings.contribution));
		}

		public void OnGUI()
		{
			UserLutModel.Settings settings = base.model.settings;
			GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, settings.lut.width, settings.lut.height), settings.lut);
		}
	}
	public sealed class VignetteComponent : PostProcessingComponentRenderTexture<VignetteModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Vignette_Color = Shader.PropertyToID("_Vignette_Color");

			internal static readonly int _Vignette_Center = Shader.PropertyToID("_Vignette_Center");

			internal static readonly int _Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

			internal static readonly int _Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

			internal static readonly int _Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			VignetteModel.Settings settings = base.model.settings;
			uberMaterial.SetColor(Uniforms._Vignette_Color, settings.color);
			if (settings.mode == VignetteModel.Mode.Classic)
			{
				uberMaterial.SetVector(Uniforms._Vignette_Center, settings.center);
				uberMaterial.EnableKeyword("VIGNETTE_CLASSIC");
				float z = (1f - settings.roundness) * 6f + settings.roundness;
				uberMaterial.SetVector(Uniforms._Vignette_Settings, new Vector4(settings.intensity * 3f, settings.smoothness * 5f, z, settings.rounded ? 1f : 0f));
			}
			else if (settings.mode == VignetteModel.Mode.Masked && settings.mask != null && settings.opacity > 0f)
			{
				uberMaterial.EnableKeyword("VIGNETTE_MASKED");
				uberMaterial.SetTexture(Uniforms._Vignette_Mask, settings.mask);
				uberMaterial.SetFloat(Uniforms._Vignette_Opacity, settings.opacity);
			}
		}
	}
	[Serializable]
	public class AmbientOcclusionModel : PostProcessingModel
	{
		public enum SampleCount
		{
			Lowest = 3,
			Low = 6,
			Medium = 10,
			High = 16
		}

		[Serializable]
		public struct Settings
		{
			[Range(0f, 4f)]
			[Tooltip("Degree of darkness produced by the effect.")]
			public float intensity;

			[Min(0.0001f)]
			[Tooltip("Radius of sample points, which affects extent of darkened areas.")]
			public float radius;

			[Tooltip("Number of sample points, which affects quality and performance.")]
			public SampleCount sampleCount;

			[Tooltip("Halves the resolution of the effect to increase performance at the cost of visual quality.")]
			public bool downsampling;

			[Tooltip("Forces compatibility with Forward rendered objects when working with the Deferred rendering path.")]
			public bool forceForwardCompatibility;

			[Tooltip("Enables the ambient-only mode in that the effect only affects ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering.")]
			public bool ambientOnly;

			[Tooltip("Toggles the use of a higher precision depth texture with the forward rendering path (may impact performances). Has no effect with the deferred rendering path.")]
			public bool highPrecision;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.intensity = 1f;
					result.radius = 0.3f;
					result.sampleCount = SampleCount.Medium;
					result.downsampling = true;
					result.forceForwardCompatibility = false;
					result.ambientOnly = false;
					result.highPrecision = false;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class AntialiasingModel : PostProcessingModel
	{
		public enum Method
		{
			Fxaa,
			Taa
		}

		public enum FxaaPreset
		{
			ExtremePerformance,
			Performance,
			Default,
			Quality,
			ExtremeQuality
		}

		[Serializable]
		public struct FxaaQualitySettings
		{
			[Tooltip("The amount of desired sub-pixel aliasing removal. Effects the sharpeness of the output.")]
			[Range(0f, 1f)]
			public float subpixelAliasingRemovalAmount;

			[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
			[Range(0.063f, 0.333f)]
			public float edgeDetectionThreshold;

			[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
			[Range(0f, 0.0833f)]
			public float minimumRequiredLuminance;

			public static FxaaQualitySettings[] presets = new FxaaQualitySettings[5]
			{
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0f,
					edgeDetectionThreshold = 0.333f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0.25f,
					edgeDetectionThreshold = 0.25f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0.75f,
					edgeDetectionThreshold = 0.166f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 1f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.0625f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 1f,
					edgeDetectionThreshold = 0.063f,
					minimumRequiredLuminance = 0.0312f
				}
			};
		}

		[Serializable]
		public struct FxaaConsoleSettings
		{
			[Tooltip("The amount of spread applied to the sampling coordinates while sampling for subpixel information.")]
			[Range(0.33f, 0.5f)]
			public float subpixelSpreadAmount;

			[Tooltip("This value dictates how sharp the edges in the image are kept; a higher value implies sharper edges.")]
			[Range(2f, 8f)]
			public float edgeSharpnessAmount;

			[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
			[Range(0.125f, 0.25f)]
			public float edgeDetectionThreshold;

			[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
			[Range(0.04f, 0.06f)]
			public float minimumRequiredLuminance;

			public static FxaaConsoleSettings[] presets = new FxaaConsoleSettings[5]
			{
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.33f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.25f,
					minimumRequiredLuminance = 0.06f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.33f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.06f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.05f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 4f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.04f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 2f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.04f
				}
			};
		}

		[Serializable]
		public struct FxaaSettings
		{
			public FxaaPreset preset;

			public static FxaaSettings defaultSettings
			{
				get
				{
					FxaaSettings result = default(FxaaSettings);
					result.preset = FxaaPreset.Default;
					return result;
				}
			}
		}

		[Serializable]
		public struct TaaSettings
		{
			[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable but blurrier output.")]
			[Range(0.1f, 1f)]
			public float jitterSpread;

			[Tooltip("Controls the amount of sharpening applied to the color buffer.")]
			[Range(0f, 3f)]
			public float sharpen;

			[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
			[Range(0f, 0.99f)]
			public float stationaryBlending;

			[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
			[Range(0f, 0.99f)]
			public float motionBlending;

			public static TaaSettings defaultSettings
			{
				get
				{
					TaaSettings result = default(TaaSettings);
					result.jitterSpread = 0.75f;
					result.sharpen = 0.3f;
					result.stationaryBlending = 0.95f;
					result.motionBlending = 0.85f;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public Method method;

			public FxaaSettings fxaaSettings;

			public TaaSettings taaSettings;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.method = Method.Fxaa;
					result.fxaaSettings = FxaaSettings.defaultSettings;
					result.taaSettings = TaaSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class BloomModel : PostProcessingModel
	{
		[Serializable]
		public struct BloomSettings
		{
			[Min(0f)]
			[Tooltip("Strength of the bloom filter.")]
			public float intensity;

			[Min(0f)]
			[Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[Range(0f, 1f)]
			[Tooltip("Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft threshold).")]
			public float softKnee;

			[Range(1f, 7f)]
			[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(threshold);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static BloomSettings defaultSettings
			{
				get
				{
					BloomSettings result = default(BloomSettings);
					result.intensity = 0.5f;
					result.threshold = 1.1f;
					result.softKnee = 0.5f;
					result.radius = 4f;
					result.antiFlicker = false;
					return result;
				}
			}
		}

		[Serializable]
		public struct LensDirtSettings
		{
			[Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture texture;

			[Min(0f)]
			[Tooltip("Amount of lens dirtiness.")]
			public float intensity;

			public static LensDirtSettings defaultSettings
			{
				get
				{
					LensDirtSettings result = default(LensDirtSettings);
					result.texture = null;
					result.intensity = 3f;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public BloomSettings bloom;

			public LensDirtSettings lensDirt;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.bloom = BloomSettings.defaultSettings;
					result.lensDirt = LensDirtSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class BuiltinDebugViewsModel : PostProcessingModel
	{
		[Serializable]
		public struct DepthSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Scales the camera far plane before displaying the depth map.")]
			public float scale;

			public static DepthSettings defaultSettings
			{
				get
				{
					DepthSettings result = default(DepthSettings);
					result.scale = 1f;
					return result;
				}
			}
		}

		[Serializable]
		public struct MotionVectorsSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Opacity of the source render.")]
			public float sourceOpacity;

			[Range(0f, 1f)]
			[Tooltip("Opacity of the per-pixel motion vector colors.")]
			public float motionImageOpacity;

			[Min(0f)]
			[Tooltip("Because motion vectors are mainly very small vectors, you can use this setting to make them more visible.")]
			public float motionImageAmplitude;

			[Range(0f, 1f)]
			[Tooltip("Opacity for the motion vector arrows.")]
			public float motionVectorsOpacity;

			[Range(8f, 64f)]
			[Tooltip("The arrow density on screen.")]
			public int motionVectorsResolution;

			[Min(0f)]
			[Tooltip("Tweaks the arrows length.")]
			public float motionVectorsAmplitude;

			public static MotionVectorsSettings defaultSettings
			{
				get
				{
					MotionVectorsSettings result = default(MotionVectorsSettings);
					result.sourceOpacity = 1f;
					result.motionImageOpacity = 0f;
					result.motionImageAmplitude = 16f;
					result.motionVectorsOpacity = 1f;
					result.motionVectorsResolution = 24;
					result.motionVectorsAmplitude = 64f;
					return result;
				}
			}
		}

		public enum Mode
		{
			None,
			Depth,
			Normals,
			MotionVectors,
			AmbientOcclusion,
			EyeAdaptation,
			FocusPlane,
			PreGradingLog,
			LogLut,
			UserLut
		}

		[Serializable]
		public struct Settings
		{
			public Mode mode;

			public DepthSettings depth;

			public MotionVectorsSettings motionVectors;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.mode = Mode.None;
					result.depth = DepthSettings.defaultSettings;
					result.motionVectors = MotionVectorsSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public bool willInterrupt
		{
			get
			{
				if (!IsModeActive(Mode.None) && !IsModeActive(Mode.EyeAdaptation) && !IsModeActive(Mode.PreGradingLog) && !IsModeActive(Mode.LogLut))
				{
					return !IsModeActive(Mode.UserLut);
				}
				return false;
			}
		}

		public override void Reset()
		{
			settings = Settings.defaultSettings;
		}

		public bool IsModeActive(Mode mode)
		{
			return m_Settings.mode == mode;
		}
	}
	[Serializable]
	public class ChromaticAberrationModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Shift the hue of chromatic aberrations.")]
			public Texture2D spectralTexture;

			[Range(0f, 1f)]
			[Tooltip("Amount of tangential distortion.")]
			public float intensity;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.spectralTexture = null;
					result.intensity = 0.1f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class ColorGradingModel : PostProcessingModel
	{
		public enum Tonemapper
		{
			None,
			ACES,
			Neutral
		}

		[Serializable]
		public struct TonemappingSettings
		{
			[Tooltip("Tonemapping algorithm to use at the end of the color grading process. Use \"Neutral\" if you need a customizable tonemapper or \"Filmic\" to give a standard filmic look to your scenes.")]
			public Tonemapper tonemapper;

			[Range(-0.1f, 0.1f)]
			public float neutralBlackIn;

			[Range(1f, 20f)]
			public float neutralWhiteIn;

			[Range(-0.09f, 0.1f)]
			public float neutralBlackOut;

			[Range(1f, 19f)]
			public float neutralWhiteOut;

			[Range(0.1f, 20f)]
			public float neutralWhiteLevel;

			[Range(1f, 10f)]
			public float neutralWhiteClip;

			public static TonemappingSettings defaultSettings
			{
				get
				{
					TonemappingSettings result = default(TonemappingSettings);
					result.tonemapper = Tonemapper.Neutral;
					result.neutralBlackIn = 0.02f;
					result.neutralWhiteIn = 10f;
					result.neutralBlackOut = 0f;
					result.neutralWhiteOut = 10f;
					result.neutralWhiteLevel = 5.3f;
					result.neutralWhiteClip = 10f;
					return result;
				}
			}
		}

		[Serializable]
		public struct BasicSettings
		{
			[Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
			public float postExposure;

			[Range(-100f, 100f)]
			[Tooltip("Sets the white balance to a custom color temperature.")]
			public float temperature;

			[Range(-100f, 100f)]
			[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
			public float tint;

			[Range(-180f, 180f)]
			[Tooltip("Shift the hue of all colors.")]
			public float hueShift;

			[Range(0f, 2f)]
			[Tooltip("Pushes the intensity of all colors.")]
			public float saturation;

			[Range(0f, 2f)]
			[Tooltip("Expands or shrinks the overall range of tonal values.")]
			public float contrast;

			public static BasicSettings defaultSettings
			{
				get
				{
					BasicSettings result = default(BasicSettings);
					result.postExposure = 0f;
					result.temperature = 0f;
					result.tint = 0f;
					result.hueShift = 0f;
					result.saturation = 1f;
					result.contrast = 1f;
					return result;
				}
			}
		}

		[Serializable]
		public struct ChannelMixerSettings
		{
			public Vector3 red;

			public Vector3 green;

			public Vector3 blue;

			[HideInInspector]
			public int currentEditingChannel;

			public static ChannelMixerSettings defaultSettings
			{
				get
				{
					ChannelMixerSettings result = default(ChannelMixerSettings);
					result.red = new Vector3(1f, 0f, 0f);
					result.green = new Vector3(0f, 1f, 0f);
					result.blue = new Vector3(0f, 0f, 1f);
					result.currentEditingChannel = 0;
					return result;
				}
			}
		}

		[Serializable]
		public struct LogWheelsSettings
		{
			[Trackball("GetSlopeValue")]
			public Color slope;

			[Trackball("GetPowerValue")]
			public Color power;

			[Trackball("GetOffsetValue")]
			public Color offset;

			public static LogWheelsSettings defaultSettings
			{
				get
				{
					LogWheelsSettings result = default(LogWheelsSettings);
					result.slope = Color.clear;
					result.power = Color.clear;
					result.offset = Color.clear;
					return result;
				}
			}
		}

		[Serializable]
		public struct LinearWheelsSettings
		{
			[Trackball("GetLiftValue")]
			public Color lift;

			[Trackball("GetGammaValue")]
			public Color gamma;

			[Trackball("GetGainValue")]
			public Color gain;

			public static LinearWheelsSettings defaultSettings
			{
				get
				{
					LinearWheelsSettings result = default(LinearWheelsSettings);
					result.lift = Color.clear;
					result.gamma = Color.clear;
					result.gain = Color.clear;
					return result;
				}
			}
		}

		public enum ColorWheelMode
		{
			Linear,
			Log
		}

		[Serializable]
		public struct ColorWheelsSettings
		{
			public ColorWheelMode mode;

			[TrackballGroup]
			public LogWheelsSettings log;

			[TrackballGroup]
			public LinearWheelsSettings linear;

			public static ColorWheelsSettings defaultSettings
			{
				get
				{
					ColorWheelsSettings result = default(ColorWheelsSettings);
					result.mode = ColorWheelMode.Log;
					result.log = LogWheelsSettings.defaultSettings;
					result.linear = LinearWheelsSettings.defaultSettings;
					return result;
				}
			}
		}

		[Serializable]
		public struct CurvesSettings
		{
			public ColorGradingCurve master;

			public ColorGradingCurve red;

			public ColorGradingCurve green;

			public ColorGradingCurve blue;

			public ColorGradingCurve hueVShue;

			public ColorGradingCurve hueVSsat;

			public ColorGradingCurve satVSsat;

			public ColorGradingCurve lumVSsat;

			[HideInInspector]
			public int e_CurrentEditingCurve;

			[HideInInspector]
			public bool e_CurveY;

			[HideInInspector]
			public bool e_CurveR;

			[HideInInspector]
			public bool e_CurveG;

			[HideInInspector]
			public bool e_CurveB;

			public static CurvesSettings defaultSettings
			{
				get
				{
					CurvesSettings result = default(CurvesSettings);
					result.master = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.red = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.green = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.blue = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.hueVShue = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
					result.hueVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
					result.satVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
					result.lumVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
					result.e_CurrentEditingCurve = 0;
					result.e_CurveY = true;
					result.e_CurveR = false;
					result.e_CurveG = false;
					result.e_CurveB = false;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public TonemappingSettings tonemapping;

			public BasicSettings basic;

			public ChannelMixerSettings channelMixer;

			public ColorWheelsSettings colorWheels;

			public CurvesSettings curves;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.tonemapping = TonemappingSettings.defaultSettings;
					result.basic = BasicSettings.defaultSettings;
					result.channelMixer = ChannelMixerSettings.defaultSettings;
					result.colorWheels = ColorWheelsSettings.defaultSettings;
					result.curves = CurvesSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
				OnValidate();
			}
		}

		public bool isDirty { get; internal set; }

		public RenderTexture bakedLut { get; internal set; }

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
			OnValidate();
		}

		public override void OnValidate()
		{
			isDirty = true;
		}
	}
	[Serializable]
	public class DepthOfFieldModel : PostProcessingModel
	{
		public enum KernelSize
		{
			Small,
			Medium,
			Large,
			VeryLarge
		}

		[Serializable]
		public struct Settings
		{
			[Min(0.1f)]
			[Tooltip("Distance to the point of focus.")]
			public float focusDistance;

			[Range(0.05f, 32f)]
			[Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
			public float aperture;

			[Range(1f, 300f)]
			[Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
			public float focalLength;

			[Tooltip("Calculate the focal length automatically from the field-of-view value set on the camera. Using this setting isn't recommended.")]
			public bool useCameraFov;

			[Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects the performance (the larger the kernel is, the longer the GPU time is required).")]
			public KernelSize kernelSize;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.focusDistance = 10f;
					result.aperture = 5.6f;
					result.focalLength = 50f;
					result.useCameraFov = false;
					result.kernelSize = KernelSize.Medium;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class DitheringModel : PostProcessingModel
	{
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct Settings
		{
			public static Settings defaultSettings => default(Settings);
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class EyeAdaptationModel : PostProcessingModel
	{
		public enum EyeAdaptationType
		{
			Progressive,
			Fixed
		}

		[Serializable]
		public struct Settings
		{
			[Range(1f, 99f)]
			[Tooltip("Filters the dark part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
			public float lowPercent;

			[Range(1f, 99f)]
			[Tooltip("Filters the bright part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
			public float highPercent;

			[Tooltip("Minimum average luminance to consider for auto exposure (in EV).")]
			public float minLuminance;

			[Tooltip("Maximum average luminance to consider for auto exposure (in EV).")]
			public float maxLuminance;

			[Min(0f)]
			[Tooltip("Exposure bias. Use this to offset the global exposure of the scene.")]
			public float keyValue;

			[Tooltip("Set this to true to let Unity handle the key value automatically based on average luminance.")]
			public bool dynamicKeyValue;

			[Tooltip("Use \"Progressive\" if you want the auto exposure to be animated. Use \"Fixed\" otherwise.")]
			public EyeAdaptationType adaptationType;

			[Min(0f)]
			[Tooltip("Adaptation speed from a dark to a light environment.")]
			public float speedUp;

			[Min(0f)]
			[Tooltip("Adaptation speed from a light to a dark environment.")]
			public float speedDown;

			[Range(-16f, -1f)]
			[Tooltip("Lower bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
			public int logMin;

			[Range(1f, 16f)]
			[Tooltip("Upper bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
			public int logMax;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.lowPercent = 45f;
					result.highPercent = 95f;
					result.minLuminance = -5f;
					result.maxLuminance = 1f;
					result.keyValue = 0.25f;
					result.dynamicKeyValue = true;
					result.adaptationType = EyeAdaptationType.Progressive;
					result.speedUp = 2f;
					result.speedDown = 1f;
					result.logMin = -8;
					result.logMax = 4;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class FogModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Should the fog affect the skybox?")]
			public bool excludeSkybox;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.excludeSkybox = true;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class GrainModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Enable the use of colored grain.")]
			public bool colored;

			[Range(0f, 1f)]
			[Tooltip("Grain strength. Higher means more visible grain.")]
			public float intensity;

			[Range(0.3f, 3f)]
			[Tooltip("Grain particle size.")]
			public float size;

			[Range(0f, 1f)]
			[Tooltip("Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas.")]
			public float luminanceContribution;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.colored = true;
					result.intensity = 0.5f;
					result.size = 1f;
					result.luminanceContribution = 0.8f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class MotionBlurModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Range(0f, 360f)]
			[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
			public float shutterAngle;

			[Range(4f, 32f)]
			[Tooltip("The amount of sample points, which affects quality and performances.")]
			public int sampleCount;

			[Range(0f, 1f)]
			[Tooltip("The strength of multiple frame blending. The opacity of preceding frames are determined from this coefficient and time differences.")]
			public float frameBlending;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.shutterAngle = 270f;
					result.sampleCount = 10;
					result.frameBlending = 0f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class ScreenSpaceReflectionModel : PostProcessingModel
	{
		public enum SSRResolution
		{
			High = 0,
			Low = 2
		}

		public enum SSRReflectionBlendType
		{
			PhysicallyBased,
			Additive
		}

		[Serializable]
		public struct IntensitySettings
		{
			[Tooltip("Nonphysical multiplier for the SSR reflections. 1.0 is physically based.")]
			[Range(0f, 2f)]
			public float reflectionMultiplier;

			[Tooltip("How far away from the maxDistance to begin fading SSR.")]
			[Range(0f, 1000f)]
			public float fadeDistance;

			[Tooltip("Amplify Fresnel fade out. Increase if floor reflections look good close to the surface and bad farther 'under' the floor.")]
			[Range(0f, 1f)]
			public float fresnelFade;

			[Tooltip("Higher values correspond to a faster Fresnel fade as the reflection changes from the grazing angle.")]
			[Range(0.1f, 10f)]
			public float fresnelFadePower;
		}

		[Serializable]
		public struct ReflectionSettings
		{
			[Tooltip("How the reflections are blended into the render.")]
			public SSRReflectionBlendType blendType;

			[Tooltip("Half resolution SSRR is much faster, but less accurate.")]
			public SSRResolution reflectionQuality;

			[Tooltip("Maximum reflection distance in world units.")]
			[Range(0.1f, 300f)]
			public float maxDistance;

			[Tooltip("Max raytracing length.")]
			[Range(16f, 1024f)]
			public int iterationCount;

			[Tooltip("Log base 2 of ray tracing coarse step size. Higher traces farther, lower gives better quality silhouettes.")]
			[Range(1f, 16f)]
			public int stepSize;

			[Tooltip("Typical thickness of columns, walls, furniture, and other objects that reflection rays might pass behind.")]
			[Range(0.01f, 10f)]
			public float widthModifier;

			[Tooltip("Blurriness of reflections.")]
			[Range(0.1f, 8f)]
			public float reflectionBlur;

			[Tooltip("Disable for a performance gain in scenes where most glossy objects are horizontal, like floors, water, and tables. Leave on for scenes with glossy vertical objects.")]
			public bool reflectBackfaces;
		}

		[Serializable]
		public struct ScreenEdgeMask
		{
			[Tooltip("Higher = fade out SSRR near the edge of the screen so that reflections don't pop under camera motion.")]
			[Range(0f, 1f)]
			public float intensity;
		}

		[Serializable]
		public struct Settings
		{
			public ReflectionSettings reflection;

			public IntensitySettings intensity;

			public ScreenEdgeMask screenEdgeMask;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.reflection = new ReflectionSettings
					{
						blendType = SSRReflectionBlendType.PhysicallyBased,
						reflectionQuality = SSRResolution.Low,
						maxDistance = 100f,
						iterationCount = 256,
						stepSize = 3,
						widthModifier = 0.5f,
						reflectionBlur = 1f,
						reflectBackfaces = false
					};
					result.intensity = new IntensitySettings
					{
						reflectionMultiplier = 1f,
						fadeDistance = 100f,
						fresnelFade = 1f,
						fresnelFadePower = 1f
					};
					result.screenEdgeMask = new ScreenEdgeMask
					{
						intensity = 0.03f
					};
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class UserLutModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
			public Texture2D lut;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float contribution;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.lut = null;
					result.contribution = 1f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class VignetteModel : PostProcessingModel
	{
		public enum Mode
		{
			Classic,
			Masked
		}

		[Serializable]
		public struct Settings
		{
			[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
			public Mode mode;

			[ColorUsage(false)]
			[Tooltip("Vignette color. Use the alpha channel for transparency.")]
			public Color color;

			[Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
			public Vector2 center;

			[Range(0f, 1f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float intensity;

			[Range(0.01f, 1f)]
			[Tooltip("Smoothness of the vignette borders.")]
			public float smoothness;

			[Range(0f, 1f)]
			[Tooltip("Lower values will make a square-ish vignette.")]
			public float roundness;

			[Tooltip("A black and white mask to use as a vignette.")]
			public Texture mask;

			[Range(0f, 1f)]
			[Tooltip("Mask opacity.")]
			public float opacity;

			[Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
			public bool rounded;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.mode = Mode.Classic;
					result.color = new Color(0f, 0f, 0f, 1f);
					result.center = new Vector2(0.5f, 0.5f);
					result.intensity = 0.45f;
					result.smoothness = 0.2f;
					result.roundness = 1f;
					result.mask = null;
					result.opacity = 1f;
					result.rounded = false;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[ImageEffectAllowedInSceneView]
	[RequireComponent(typeof(Camera))]
	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	[AddComponentMenu("Effects/Post-Processing Behaviour", -1)]
	public class PostProcessingBehaviour : MonoBehaviour
	{
		public PostProcessingProfile profile;

		public Func<Vector2, Matrix4x4> jitteredMatrixFunc;

		private Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>> m_CommandBuffers;

		private List<PostProcessingComponentBase> m_Components;

		private Dictionary<PostProcessingComponentBase, bool> m_ComponentStates;

		private MaterialFactory m_MaterialFactory;

		private RenderTextureFactory m_RenderTextureFactory;

		private PostProcessingContext m_Context;

		private Camera m_Camera;

		private PostProcessingProfile m_PreviousProfile;

		private bool m_RenderingInSceneView;

		private BuiltinDebugViewsComponent m_DebugViews;

		private AmbientOcclusionComponent m_AmbientOcclusion;

		private ScreenSpaceReflectionComponent m_ScreenSpaceReflection;

		private FogComponent m_FogComponent;

		private MotionBlurComponent m_MotionBlur;

		private TaaComponent m_Taa;

		private EyeAdaptationComponent m_EyeAdaptation;

		private DepthOfFieldComponent m_DepthOfField;

		private BloomComponent m_Bloom;

		private ChromaticAberrationComponent m_ChromaticAberration;

		private ColorGradingComponent m_ColorGrading;

		private UserLutComponent m_UserLut;

		private GrainComponent m_Grain;

		private VignetteComponent m_Vignette;

		private DitheringComponent m_Dithering;

		private FxaaComponent m_Fxaa;

		private List<PostProcessingComponentBase> m_ComponentsToEnable = new List<PostProcessingComponentBase>();

		private List<PostProcessingComponentBase> m_ComponentsToDisable = new List<PostProcessingComponentBase>();

		private void OnEnable()
		{
			m_CommandBuffers = new Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>>();
			m_MaterialFactory = new MaterialFactory();
			m_RenderTextureFactory = new RenderTextureFactory();
			m_Context = new PostProcessingContext();
			m_Components = new List<PostProcessingComponentBase>();
			m_DebugViews = AddComponent(new BuiltinDebugViewsComponent());
			m_AmbientOcclusion = AddComponent(new AmbientOcclusionComponent());
			m_ScreenSpaceReflection = AddComponent(new ScreenSpaceReflectionComponent());
			m_FogComponent = AddComponent(new FogComponent());
			m_MotionBlur = AddComponent(new MotionBlurComponent());
			m_Taa = AddComponent(new TaaComponent());
			m_EyeAdaptation = AddComponent(new EyeAdaptationComponent());
			m_DepthOfField = AddComponent(new DepthOfFieldComponent());
			m_Bloom = AddComponent(new BloomComponent());
			m_ChromaticAberration = AddComponent(new ChromaticAberrationComponent());
			m_ColorGrading = AddComponent(new ColorGradingComponent());
			m_UserLut = AddComponent(new UserLutComponent());
			m_Grain = AddComponent(new GrainComponent());
			m_Vignette = AddComponent(new VignetteComponent());
			m_Dithering = AddComponent(new DitheringComponent());
			m_Fxaa = AddComponent(new FxaaComponent());
			m_ComponentStates = new Dictionary<PostProcessingComponentBase, bool>();
			foreach (PostProcessingComponentBase component in m_Components)
			{
				m_ComponentStates.Add(component, value: false);
			}
			base.useGUILayout = false;
		}

		private void OnPreCull()
		{
			m_Camera = GetComponent<Camera>();
			if (profile == null || m_Camera == null)
			{
				return;
			}
			PostProcessingContext postProcessingContext = m_Context.Reset();
			postProcessingContext.profile = profile;
			postProcessingContext.renderTextureFactory = m_RenderTextureFactory;
			postProcessingContext.materialFactory = m_MaterialFactory;
			postProcessingContext.camera = m_Camera;
			m_DebugViews.Init(postProcessingContext, profile.debugViews);
			m_AmbientOcclusion.Init(postProcessingContext, profile.ambientOcclusion);
			m_ScreenSpaceReflection.Init(postProcessingContext, profile.screenSpaceReflection);
			m_FogComponent.Init(postProcessingContext, profile.fog);
			m_MotionBlur.Init(postProcessingContext, profile.motionBlur);
			m_Taa.Init(postProcessingContext, profile.antialiasing);
			m_EyeAdaptation.Init(postProcessingContext, profile.eyeAdaptation);
			m_DepthOfField.Init(postProcessingContext, profile.depthOfField);
			m_Bloom.Init(postProcessingContext, profile.bloom);
			m_ChromaticAberration.Init(postProcessingContext, profile.chromaticAberration);
			m_ColorGrading.Init(postProcessingContext, profile.colorGrading);
			m_UserLut.Init(postProcessingContext, profile.userLut);
			m_Grain.Init(postProcessingContext, profile.grain);
			m_Vignette.Init(postProcessingContext, profile.vignette);
			m_Dithering.Init(postProcessingContext, profile.dithering);
			m_Fxaa.Init(postProcessingContext, profile.antialiasing);
			if (m_PreviousProfile != profile)
			{
				DisableComponents();
				m_PreviousProfile = profile;
			}
			CheckObservers();
			DepthTextureMode depthTextureMode = postProcessingContext.camera.depthTextureMode;
			foreach (PostProcessingComponentBase component in m_Components)
			{
				if (component.active)
				{
					depthTextureMode |= component.GetCameraFlags();
				}
			}
			postProcessingContext.camera.depthTextureMode = depthTextureMode;
			if (!m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
			{
				m_Taa.SetProjectionMatrix(jitteredMatrixFunc);
			}
		}

		private void OnPreRender()
		{
			if (!(profile == null))
			{
				TryExecuteCommandBuffer(m_DebugViews);
				TryExecuteCommandBuffer(m_AmbientOcclusion);
				TryExecuteCommandBuffer(m_ScreenSpaceReflection);
				TryExecuteCommandBuffer(m_FogComponent);
				if (!m_RenderingInSceneView)
				{
					TryExecuteCommandBuffer(m_MotionBlur);
				}
			}
		}

		private void OnPostRender()
		{
			if (!(profile == null) && !(m_Camera == null) && !m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
			{
				m_Context.camera.ResetProjectionMatrix();
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (profile == null || m_Camera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			bool flag = false;
			bool active = m_Fxaa.active;
			bool flag2 = m_Taa.active && !m_RenderingInSceneView;
			bool num = m_DepthOfField.active && !m_RenderingInSceneView;
			Material material = m_MaterialFactory.Get("Hidden/Post FX/Uber Shader");
			material.shaderKeywords = null;
			RenderTexture renderTexture = source;
			if (flag2)
			{
				RenderTexture renderTexture2 = m_RenderTextureFactory.Get(renderTexture);
				m_Taa.Render(renderTexture, renderTexture2);
				renderTexture = renderTexture2;
			}
			Texture texture = GraphicsUtils.whiteTexture;
			if (m_EyeAdaptation.active)
			{
				flag = true;
				texture = m_EyeAdaptation.Prepare(renderTexture, material);
			}
			material.SetTexture("_AutoExposure", texture);
			if (num)
			{
				flag = true;
				m_DepthOfField.Prepare(renderTexture, material, flag2, m_Taa.jitterVector, m_Taa.model.settings.taaSettings.motionBlending);
			}
			if (m_Bloom.active)
			{
				flag = true;
				m_Bloom.Prepare(renderTexture, material, texture);
			}
			flag |= TryPrepareUberImageEffect(m_ChromaticAberration, material);
			flag |= TryPrepareUberImageEffect(m_ColorGrading, material);
			flag |= TryPrepareUberImageEffect(m_Vignette, material);
			flag |= TryPrepareUberImageEffect(m_UserLut, material);
			Material material2 = (active ? m_MaterialFactory.Get("Hidden/Post FX/FXAA") : null);
			if (active)
			{
				material2.shaderKeywords = null;
				TryPrepareUberImageEffect(m_Grain, material2);
				TryPrepareUberImageEffect(m_Dithering, material2);
				if (flag)
				{
					RenderTexture renderTexture3 = m_RenderTextureFactory.Get(renderTexture);
					Graphics.Blit(renderTexture, renderTexture3, material, 0);
					renderTexture = renderTexture3;
				}
				m_Fxaa.Render(renderTexture, destination);
			}
			else
			{
				flag |= TryPrepareUberImageEffect(m_Grain, material);
				flag |= TryPrepareUberImageEffect(m_Dithering, material);
				if (flag)
				{
					if (!GraphicsUtils.isLinearColorSpace)
					{
						material.EnableKeyword("UNITY_COLORSPACE_GAMMA");
					}
					Graphics.Blit(renderTexture, destination, material, 0);
				}
			}
			if (!flag && !active)
			{
				Graphics.Blit(renderTexture, destination);
			}
			m_RenderTextureFactory.ReleaseAll();
		}

		private void OnGUI()
		{
			if (Event.current.type == EventType.Repaint && !(profile == null) && !(m_Camera == null))
			{
				if (m_EyeAdaptation.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
				{
					m_EyeAdaptation.OnGUI();
				}
				else if (m_ColorGrading.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.LogLut))
				{
					m_ColorGrading.OnGUI();
				}
				else if (m_UserLut.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.UserLut))
				{
					m_UserLut.OnGUI();
				}
			}
		}

		private void OnDisable()
		{
			foreach (KeyValuePair<CameraEvent, CommandBuffer> value in m_CommandBuffers.Values)
			{
				m_Camera.RemoveCommandBuffer(value.Key, value.Value);
				value.Value.Dispose();
			}
			m_CommandBuffers.Clear();
			if (profile != null)
			{
				DisableComponents();
			}
			m_Components.Clear();
			m_MaterialFactory.Dispose();
			m_RenderTextureFactory.Dispose();
			GraphicsUtils.Dispose();
		}

		public void ResetTemporalEffects()
		{
			m_Taa.ResetHistory();
			m_MotionBlur.ResetHistory();
			m_EyeAdaptation.ResetHistory();
		}

		private void CheckObservers()
		{
			foreach (KeyValuePair<PostProcessingComponentBase, bool> componentState in m_ComponentStates)
			{
				PostProcessingComponentBase key = componentState.Key;
				bool flag = key.GetModel().enabled;
				if (flag != componentState.Value)
				{
					if (flag)
					{
						m_ComponentsToEnable.Add(key);
					}
					else
					{
						m_ComponentsToDisable.Add(key);
					}
				}
			}
			for (int i = 0; i < m_ComponentsToDisable.Count; i++)
			{
				PostProcessingComponentBase postProcessingComponentBase = m_ComponentsToDisable[i];
				m_ComponentStates[postProcessingComponentBase] = false;
				postProcessingComponentBase.OnDisable();
			}
			for (int j = 0; j < m_ComponentsToEnable.Count; j++)
			{
				PostProcessingComponentBase postProcessingComponentBase2 = m_ComponentsToEnable[j];
				m_ComponentStates[postProcessingComponentBase2] = true;
				postProcessingComponentBase2.OnEnable();
			}
			m_ComponentsToDisable.Clear();
			m_ComponentsToEnable.Clear();
		}

		private void DisableComponents()
		{
			foreach (PostProcessingComponentBase component in m_Components)
			{
				PostProcessingModel model = component.GetModel();
				if (model != null && model.enabled)
				{
					component.OnDisable();
				}
			}
		}

		private CommandBuffer AddCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
		{
			CommandBuffer value = new CommandBuffer
			{
				name = name
			};
			KeyValuePair<CameraEvent, CommandBuffer> value2 = new KeyValuePair<CameraEvent, CommandBuffer>(evt, value);
			m_CommandBuffers.Add(typeof(T), value2);
			m_Camera.AddCommandBuffer(evt, value2.Value);
			return value2.Value;
		}

		private void RemoveCommandBuffer<T>() where T : PostProcessingModel
		{
			Type typeFromHandle = typeof(T);
			if (m_CommandBuffers.TryGetValue(typeFromHandle, out var value))
			{
				m_Camera.RemoveCommandBuffer(value.Key, value.Value);
				m_CommandBuffers.Remove(typeFromHandle);
				value.Value.Dispose();
			}
		}

		private CommandBuffer GetCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
		{
			if (!m_CommandBuffers.TryGetValue(typeof(T), out var value))
			{
				return AddCommandBuffer<T>(evt, name);
			}
			if (value.Key != evt)
			{
				RemoveCommandBuffer<T>();
				return AddCommandBuffer<T>(evt, name);
			}
			return value.Value;
		}

		private void TryExecuteCommandBuffer<T>(PostProcessingComponentCommandBuffer<T> component) where T : PostProcessingModel
		{
			if (component.active)
			{
				CommandBuffer commandBuffer = GetCommandBuffer<T>(component.GetCameraEvent(), component.GetName());
				commandBuffer.Clear();
				component.PopulateCommandBuffer(commandBuffer);
			}
			else
			{
				RemoveCommandBuffer<T>();
			}
		}

		private bool TryPrepareUberImageEffect<T>(PostProcessingComponentRenderTexture<T> component, Material material) where T : PostProcessingModel
		{
			if (!component.active)
			{
				return false;
			}
			component.Prepare(material);
			return true;
		}

		private T AddComponent<T>(T component) where T : PostProcessingComponentBase
		{
			m_Components.Add(component);
			return component;
		}
	}
	public abstract class PostProcessingComponentBase
	{
		public PostProcessingContext context;

		public abstract bool active { get; }

		public virtual DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.None;
		}

		public virtual void OnEnable()
		{
		}

		public virtual void OnDisable()
		{
		}

		public abstract PostProcessingModel GetModel();
	}
	public abstract class PostProcessingComponent<T> : PostProcessingComponentBase where T : PostProcessingModel
	{
		public T model { get; internal set; }

		public virtual void Init(PostProcessingContext pcontext, T pmodel)
		{
			context = pcontext;
			model = pmodel;
		}

		public override PostProcessingModel GetModel()
		{
			return model;
		}
	}
	public abstract class PostProcessingComponentCommandBuffer<T> : PostProcessingComponent<T> where T : PostProcessingModel
	{
		public abstract CameraEvent GetCameraEvent();

		public abstract string GetName();

		public abstract void PopulateCommandBuffer(CommandBuffer cb);
	}
	public abstract class PostProcessingComponentRenderTexture<T> : PostProcessingComponent<T> where T : PostProcessingModel
	{
		public virtual void Prepare(Material material)
		{
		}
	}
	public class PostProcessingContext
	{
		public PostProcessingProfile profile;

		public Camera camera;

		public MaterialFactory materialFactory;

		public RenderTextureFactory renderTextureFactory;

		public bool interrupted { get; private set; }

		public bool isGBufferAvailable => camera.actualRenderingPath == RenderingPath.DeferredShading;

		public bool isHdr => camera.allowHDR;

		public int width => camera.pixelWidth;

		public int height => camera.pixelHeight;

		public Rect viewport => camera.rect;

		public void Interrupt()
		{
			interrupted = true;
		}

		public PostProcessingContext Reset()
		{
			profile = null;
			camera = null;
			materialFactory = null;
			renderTextureFactory = null;
			interrupted = false;
			return this;
		}
	}
	[Serializable]
	public abstract class PostProcessingModel
	{
		[SerializeField]
		[GetSet("enabled")]
		private bool m_Enabled;

		public bool enabled
		{
			get
			{
				return m_Enabled;
			}
			set
			{
				m_Enabled = value;
				if (value)
				{
					OnValidate();
				}
			}
		}

		public abstract void Reset();

		public virtual void OnValidate()
		{
		}
	}
	public class PostProcessingProfile : ScriptableObject
	{
		public BuiltinDebugViewsModel debugViews = new BuiltinDebugViewsModel();

		public FogModel fog = new FogModel();

		public AntialiasingModel antialiasing = new AntialiasingModel();

		public AmbientOcclusionModel ambientOcclusion = new AmbientOcclusionModel();

		public ScreenSpaceReflectionModel screenSpaceReflection = new ScreenSpaceReflectionModel();

		public DepthOfFieldModel depthOfField = new DepthOfFieldModel();

		public MotionBlurModel motionBlur = new MotionBlurModel();

		public EyeAdaptationModel eyeAdaptation = new EyeAdaptationModel();

		public BloomModel bloom = new BloomModel();

		public ColorGradingModel colorGrading = new ColorGradingModel();

		public UserLutModel userLut = new UserLutModel();

		public ChromaticAberrationModel chromaticAberration = new ChromaticAberrationModel();

		public GrainModel grain = new GrainModel();

		public VignetteModel vignette = new VignetteModel();

		public DitheringModel dithering = new DitheringModel();
	}
	[Serializable]
	public sealed class ColorGradingCurve
	{
		public AnimationCurve curve;

		[SerializeField]
		private bool m_Loop;

		[SerializeField]
		private float m_ZeroValue;

		[SerializeField]
		private float m_Range;

		private AnimationCurve m_InternalLoopingCurve;

		public ColorGradingCurve(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
		{
			this.curve = curve;
			m_ZeroValue = zeroValue;
			m_Loop = loop;
			m_Range = bounds.magnitude;
		}

		public void Cache()
		{
			if (!m_Loop)
			{
				return;
			}
			int length = curve.length;
			if (length >= 2)
			{
				if (m_InternalLoopingCurve == null)
				{
					m_InternalLoopingCurve = new AnimationCurve();
				}
				Keyframe key = curve[length - 1];
				key.time -= m_Range;
				Keyframe key2 = curve[0];
				key2.time += m_Range;
				m_InternalLoopingCurve.keys = curve.keys;
				m_InternalLoopingCurve.AddKey(key);
				m_InternalLoopingCurve.AddKey(key2);
			}
		}

		public float Evaluate(float t)
		{
			if (curve.length == 0)
			{
				return m_ZeroValue;
			}
			if (!m_Loop || curve.length == 1)
			{
				return curve.Evaluate(t);
			}
			return m_InternalLoopingCurve.Evaluate(t);
		}
	}
	public static class GraphicsUtils
	{
		private static Texture2D s_WhiteTexture;

		private static Mesh s_Quad;

		public static bool isLinearColorSpace => QualitySettings.activeColorSpace == ColorSpace.Linear;

		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static Texture2D whiteTexture
		{
			get
			{
				if (s_WhiteTexture != null)
				{
					return s_WhiteTexture;
				}
				s_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: false);
				s_WhiteTexture.SetPixel(0, 0, new Color(1f, 1f, 1f, 1f));
				s_WhiteTexture.Apply();
				return s_WhiteTexture;
			}
		}

		public static Mesh quad
		{
			get
			{
				if (s_Quad != null)
				{
					return s_Quad;
				}
				Vector3[] vertices = new Vector3[4]
				{
					new Vector3(-1f, -1f, 0f),
					new Vector3(1f, 1f, 0f),
					new Vector3(1f, -1f, 0f),
					new Vector3(-1f, 1f, 0f)
				};
				Vector2[] uv = new Vector2[4]
				{
					new Vector2(0f, 0f),
					new Vector2(1f, 1f),
					new Vector2(1f, 0f),
					new Vector2(0f, 1f)
				};
				int[] triangles = new int[6] { 0, 1, 2, 1, 0, 3 };
				s_Quad = new Mesh
				{
					vertices = vertices,
					uv = uv,
					triangles = triangles
				};
				s_Quad.RecalculateNormals();
				s_Quad.RecalculateBounds();
				return s_Quad;
			}
		}

		public static void Blit(Material material, int pass)
		{
			GL.PushMatrix();
			GL.LoadOrtho();
			material.SetPass(pass);
			GL.Begin(5);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, 0.1f);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, 0.1f);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, 0.1f);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, 0.1f);
			GL.End();
			GL.PopMatrix();
		}

		public static void ClearAndBlit(Texture source, RenderTexture destination, Material material, int pass, bool clearColor = true, bool clearDepth = false)
		{
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = destination;
			GL.Clear(clearDepth: false, clearColor, Color.clear);
			GL.PushMatrix();
			GL.LoadOrtho();
			material.SetTexture("_MainTex", source);
			material.SetPass(pass);
			GL.Begin(5);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, 0.1f);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, 0.1f);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, 0.1f);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, 0.1f);
			GL.End();
			GL.PopMatrix();
			RenderTexture.active = active;
		}

		public static void Destroy(Object obj)
		{
			if (obj != null)
			{
				Object.Destroy(obj);
			}
		}

		public static void Dispose()
		{
			Destroy(s_Quad);
		}
	}
	public sealed class MaterialFactory : IDisposable
	{
		private Dictionary<string, Material> m_Materials;

		public MaterialFactory()
		{
			m_Materials = new Dictionary<string, Material>();
		}

		public Material Get(string shaderName)
		{
			if (!m_Materials.TryGetValue(shaderName, out var value))
			{
				Shader shader = Shader.Find(shaderName);
				if (shader == null)
				{
					throw new ArgumentException($"Shader not found ({shaderName})");
				}
				value = new Material(shader)
				{
					name = string.Format("PostFX - {0}", shaderName.Substring(shaderName.LastIndexOf("/") + 1)),
					hideFlags = HideFlags.DontSave
				};
				m_Materials.Add(shaderName, value);
			}
			return value;
		}

		public void Dispose()
		{
			Dictionary<string, Material>.Enumerator enumerator = m_Materials.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GraphicsUtils.Destroy(enumerator.Current.Value);
			}
			m_Materials.Clear();
		}
	}
	public sealed class RenderTextureFactory : IDisposable
	{
		private HashSet<RenderTexture> m_TemporaryRTs;

		public RenderTextureFactory()
		{
			m_TemporaryRTs = new HashSet<RenderTexture>();
		}

		public RenderTexture Get(RenderTexture baseRenderTexture)
		{
			return Get(baseRenderTexture.width, baseRenderTexture.height, baseRenderTexture.depth, baseRenderTexture.format, (!baseRenderTexture.sRGB) ? RenderTextureReadWrite.Linear : RenderTextureReadWrite.sRGB, baseRenderTexture.filterMode, baseRenderTexture.wrapMode);
		}

		public RenderTexture Get(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, RenderTextureReadWrite rw = RenderTextureReadWrite.Default, FilterMode filterMode = FilterMode.Bilinear, TextureWrapMode wrapMode = TextureWrapMode.Clamp, string name = "FactoryTempTexture")
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format, rw);
			temporary.filterMode = filterMode;
			temporary.wrapMode = wrapMode;
			temporary.name = name;
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void Release(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					throw new ArgumentException($"Attempting to remove a RenderTexture that was not allocated: {rt}");
				}
				m_TemporaryRTs.Remove(rt);
				RenderTexture.ReleaseTemporary(rt);
			}
		}

		public void ReleaseAll()
		{
			HashSet<RenderTexture>.Enumerator enumerator = m_TemporaryRTs.GetEnumerator();
			while (enumerator.MoveNext())
			{
				RenderTexture.ReleaseTemporary(enumerator.Current);
			}
			m_TemporaryRTs.Clear();
		}

		public void Dispose()
		{
			ReleaseAll();
		}
	}
}
namespace Animmal.Kubikos
{
	public class LoadSceneByName : MonoBehaviour
	{
		public string SceneName;

		public void LoadLevel()
		{
			SceneManager.LoadScene(SceneName);
		}
	}
}
namespace Assets.MoveableLineRenderer.Scripts
{
	internal sealed class MoveableLineRenderer : MonoBehaviour
	{
		public GameObject LineRendererPrefab;

		public float MinVertexDistance = 1f;

		public float LifeTime = 0.3f;

		public float Scale = 1f;

		public float Speed = 1f;

		public float Height = 1f;

		public float Gravity;

		private LineRenderer _lineRenderer;

		private Point[] _points;

		private int _pointsCount;

		private void Start()
		{
			_lineRenderer = UnityEngine.Object.Instantiate(LineRendererPrefab).GetComponent<LineRenderer>();
			_lineRenderer.enabled = true;
			_lineRenderer.transform.parent = base.transform;
			_points = new Point[100];
		}

		private void Update()
		{
			RemoveOutdatedPoints();
			if (_pointsCount == 0)
			{
				_points[_pointsCount++] = new Point(base.transform.position);
				_points[_pointsCount++] = new Point(base.transform.position);
			}
			bool flag = false;
			if (_points[1] == null)
			{
				return;
			}
			float sqrMagnitude = (_points[1].Position - base.transform.position).sqrMagnitude;
			if (sqrMagnitude > MinVertexDistance * MinVertexDistance && sqrMagnitude > MinVertexDistance * MinVertexDistance)
			{
				flag = true;
			}
			if (flag)
			{
				if (_pointsCount == _points.Length)
				{
					Array.Resize(ref _points, _points.Length + 50);
				}
				InsertPoint();
			}
			ApplyTurbulence();
			_lineRenderer.positionCount = _pointsCount;
			_lineRenderer.SetPositions((from t in _points
				where t != null
				select t.Position).ToArray());
		}

		private void InsertPoint()
		{
			for (int num = _pointsCount; num > 0; num--)
			{
				_points[num] = _points[num - 1];
			}
			_points[0] = new Point(base.transform.position);
			_pointsCount++;
		}

		private void RemoveOutdatedPoints()
		{
			if (_pointsCount == 0)
			{
				return;
			}
			for (int num = _pointsCount - 1; num >= 0; num--)
			{
				Point point = _points[num];
				if (point == null || point.TimeAlive >= LifeTime)
				{
					_points[num] = null;
					_pointsCount--;
				}
			}
		}

		private void ApplyTurbulence()
		{
			for (int num = _pointsCount - 1; num >= 0; num--)
			{
				if (_points[num] != null)
				{
					float num2 = Time.timeSinceLevelLoad * Speed;
					UnityEngine.Vector3 position = _points[num].Position;
					float x = position.x * Scale + num2;
					float num3 = position.y * Scale + num2;
					float y = position.z * Scale + num2;
					_points[num].Position.x += (Mathf.PerlinNoise(num3, y) - 0.5f) * Height;
					_points[num].Position.y += (Mathf.PerlinNoise(x, y) - 0.5f) * Height - Gravity;
					_points[num].Position.z += (Mathf.PerlinNoise(x, num3) - 0.5f) * Height;
				}
			}
		}
	}
	internal sealed class Point
	{
		public UnityEngine.Vector3 Position;

		private readonly float _timeCreated;

		public float TimeAlive => Time.time - _timeCreated;

		public Point(UnityEngine.Vector3 position)
		{
			Position = position;
			_timeCreated = Time.time;
		}
	}
}
namespace Assets.AbstractWiresEffect.Scripts
{
	internal sealed class CollisionDetector : MonoBehaviour
	{
		public float CollisionDistance;

		private Transform _transform;

		public event Action<UnityEngine.Vector3> CollisionDetected;

		private void Start()
		{
			_transform = base.transform;
		}

		private void FixedUpdate()
		{
			if (Physics.Raycast(_transform.position, -base.transform.up, out var hitInfo, CollisionDistance) && !(UnityEngine.Vector3.Distance(_transform.position, hitInfo.point) > CollisionDistance) && this.CollisionDetected != null)
			{
				this.CollisionDetected(hitInfo.point);
			}
		}
	}
	[RequireComponent(typeof(CollisionDetector))]
	internal sealed class CollisionSpawner : MonoBehaviour
	{
		public GameObject CollisionEffect;

		public float LifeTime = 1f;

		private bool _isAlreadySpawned;

		private CollisionDetector _collisionDetector;

		private void Start()
		{
			_collisionDetector = GetComponent<CollisionDetector>();
			_collisionDetector.CollisionDetected += OnCollisionDetected;
		}

		private void OnCollisionDetected(UnityEngine.Vector3 hit)
		{
			if (!_isAlreadySpawned)
			{
				InstantiateImpactEffect(hit);
			}
		}

		private void InstantiateImpactEffect(UnityEngine.Vector3 pos)
		{
			GameObject obj = UnityEngine.Object.Instantiate(CollisionEffect, pos, CollisionEffect.transform.rotation);
			obj.transform.position = pos;
			UnityEngine.Object.Destroy(obj, LifeTime);
			Invoke("Reset", LifeTime);
			_isAlreadySpawned = true;
		}

		private void Reset()
		{
			_isAlreadySpawned = false;
		}

		private void OnDestroy()
		{
			_collisionDetector.CollisionDetected -= OnCollisionDetected;
		}
	}
	internal sealed class WiresConnector : MonoBehaviour
	{
		public GameObject WiresParticles;

		public GameObject LineRendererPrefab;

		public bool UseSkinnedMeshRenderer;

		public SkinnedMeshRenderer TargetSkinnedMeshRenderer;

		public float MaxDistance;

		public int MaxConnections;

		public int MaxLineRenderers;

		private ParticleSystem _particleSystem;

		private ParticleSystem.MainModule _particleSystemMainModule;

		private ParticleSystem.Particle[] _particles;

		private LineRenderer[] _lineRenderers;

		private Transform _psTransform;

		private void Start()
		{
			_lineRenderers = new LineRenderer[MaxLineRenderers];
			GameObject gameObject = UnityEngine.Object.Instantiate(WiresParticles, base.transform.position, WiresParticles.transform.rotation);
			gameObject.transform.parent = base.transform;
			_particleSystem = gameObject.GetComponent<ParticleSystem>();
			ParticleSystem.ShapeModule shape = _particleSystem.shape;
			if (UseSkinnedMeshRenderer)
			{
				shape.skinnedMeshRenderer = TargetSkinnedMeshRenderer;
			}
			_particleSystemMainModule = _particleSystem.main;
			_psTransform = _particleSystem.GetComponent<Transform>();
			int maxParticles = _particleSystemMainModule.maxParticles;
			_particles = new ParticleSystem.Particle[maxParticles];
		}

		private void LateUpdate()
		{
			int particles = _particleSystem.GetParticles(_particles);
			int num = _lineRenderers.Length;
			int num2 = 0;
			for (int i = 0; i < particles; i++)
			{
				UnityEngine.Vector3 position = _particles[i].position;
				int num3 = 0;
				for (int j = i + 1; j < particles; j++)
				{
					if (num3 == MaxConnections)
					{
						break;
					}
					if (num2 == MaxLineRenderers)
					{
						break;
					}
					UnityEngine.Vector3 position2 = _particles[j].position;
					if (!(UnityEngine.Vector3.Distance(position2, position) > MaxDistance))
					{
						LineRenderer component;
						if (_lineRenderers[num2] == null)
						{
							component = UnityEngine.Object.Instantiate(LineRendererPrefab, _psTransform.position, _psTransform.rotation).GetComponent<LineRenderer>();
							component.transform.parent = _psTransform.transform;
							_lineRenderers[num2] = component;
						}
						component = _lineRenderers[num2];
						component.enabled = true;
						component.SetPosition(0, position);
						component.SetPosition(1, position2);
						num2++;
						num3++;
					}
				}
			}
			int num4 = num - num2;
			for (int k = num2; k < num4; k++)
			{
				if (_lineRenderers[k] != null)
				{
					_lineRenderers[k].enabled = false;
				}
			}
		}

		private void Stop()
		{
			DestroyAllLines();
		}

		private void OnDestroy()
		{
			DestroyAllLines();
		}

		private void DestroyAllLines()
		{
			if (_lineRenderers == null)
			{
				return;
			}
			LineRenderer[] lineRenderers = _lineRenderers;
			foreach (LineRenderer lineRenderer in lineRenderers)
			{
				if (lineRenderer != null)
				{
					UnityEngine.Object.Destroy(lineRenderer);
				}
			}
		}
	}
}
namespace EpicToonFX
{
	public class ETFXButtonScript : MonoBehaviour
	{
		public GameObject Button;

		private Text MyButtonText;

		private string projectileParticleName;

		private ETFXFireProjectile effectScript;

		private ETFXProjectileScript projectileScript;

		public float buttonsX;

		public float buttonsY;

		public float buttonsSizeX;

		public float buttonsSizeY;

		public float buttonsDistance;

		private void Start()
		{
			effectScript = GameObject.Find("ETFXFireProjectile").GetComponent<ETFXFireProjectile>();
			getProjectileNames();
			MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
			MyButtonText.text = projectileParticleName;
		}

		private void Update()
		{
			MyButtonText.text = projectileParticleName;
		}

		public void getProjectileNames()
		{
			projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<ETFXProjectileScript>();
			projectileParticleName = projectileScript.projectileParticle.name;
		}

		public bool overButton()
		{
			Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
			Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
			if (rect.Contains(new UnityEngine.Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new UnityEngine.Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
			{
				return true;
			}
			return false;
		}
	}
	public class ETFXFireProjectile : MonoBehaviour
	{
		private RaycastHit hit;

		public GameObject[] projectiles;

		public Transform spawnPosition;

		[HideInInspector]
		public int currentProjectile;

		public float speed = 1000f;

		private ETFXButtonScript selectedProjectileButton;

		private void Start()
		{
			selectedProjectileButton = GameObject.Find("Button").GetComponent<ETFXButtonScript>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextEffect();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousEffect();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousEffect();
			}
			if (Input.GetKeyDown(KeyCode.Mouse0) && !EventSystem.current.IsPointerOverGameObject() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, UnityEngine.Quaternion.identity);
				gameObject.transform.LookAt(hit.point);
				gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
				gameObject.GetComponent<ETFXProjectileScript>().impactNormal = hit.normal;
			}
			UnityEngine.Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
		}

		public void nextEffect()
		{
			if (currentProjectile < projectiles.Length - 1)
			{
				currentProjectile++;
			}
			else
			{
				currentProjectile = 0;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void previousEffect()
		{
			if (currentProjectile > 0)
			{
				currentProjectile--;
			}
			else
			{
				currentProjectile = projectiles.Length - 1;
			}
			selectedProjectileButton.getProjectileNames();
		}

		public void AdjustSpeed(float newSpeed)
		{
			speed = newSpeed;
		}
	}
	public class ETFXLoopScript : MonoBehaviour
	{
		public GameObject chosenEffect;

		public float loopTimeLimit = 2f;

		[Header("Spawn without")]
		public bool spawnWithoutLight = true;

		public bool spawnWithoutSound = true;

		private void Start()
		{
			PlayEffect();
		}

		public void PlayEffect()
		{
			StartCoroutine("EffectLoop");
		}

		private IEnumerator EffectLoop()
		{
			GameObject effectPlayer = UnityEngine.Object.Instantiate(chosenEffect, base.transform.position, base.transform.rotation);
			if (spawnWithoutLight = effectPlayer.GetComponent<Light>())
			{
				effectPlayer.GetComponent<Light>().enabled = false;
			}
			if (spawnWithoutSound = effectPlayer.GetComponent<AudioSource>())
			{
				effectPlayer.GetComponent<AudioSource>().enabled = false;
			}
			yield return new WaitForSeconds(loopTimeLimit);
			UnityEngine.Object.Destroy(effectPlayer);
			PlayEffect();
		}
	}
	public class ETFXMouseOrbit : MonoBehaviour
	{
		public Transform target;

		public float distance = 5f;

		public float xSpeed = 120f;

		public float ySpeed = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float distanceMin = 0.5f;

		public float distanceMax = 15f;

		public float smoothTime = 2f;

		private float rotationYAxis;

		private float rotationXAxis;

		private float velocityX;

		private float velocityY;

		private void Start()
		{
			UnityEngine.Vector3 eulerAngles = base.transform.eulerAngles;
			rotationYAxis = eulerAngles.y;
			rotationXAxis = eulerAngles.x;
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				if (Input.GetMouseButton(1))
				{
					velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
					velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
				}
				rotationYAxis += velocityX;
				rotationXAxis -= velocityY;
				rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
				UnityEngine.Quaternion quaternion = UnityEngine.Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
				distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
				if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
				{
					distance -= hitInfo.distance;
				}
				UnityEngine.Vector3 vector = new UnityEngine.Vector3(0f, 0f, 0f - distance);
				UnityEngine.Vector3 position = quaternion * vector + target.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
				velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
				velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
			}
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class ETFXLightFade : MonoBehaviour
	{
		[Header("Seconds to dim the light")]
		public float life = 0.2f;

		public bool killAfterLife = true;

		private Light li;

		private float initIntensity;

		private void Start()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li = base.gameObject.GetComponent<Light>();
				initIntensity = li.intensity;
			}
			else
			{
				MonoBehaviour.print("No light object found on " + base.gameObject.name);
			}
		}

		private void Update()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li.intensity -= initIntensity * (Time.deltaTime / life);
				if (killAfterLife && li.intensity <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject.GetComponent<Light>());
				}
			}
		}
	}
	public class ETFXPitchRandomizer : MonoBehaviour
	{
		public float randomPercent = 10f;

		private void Start()
		{
			base.transform.GetComponent<AudioSource>().pitch *= 1f + UnityEngine.Random.Range((0f - randomPercent) / 100f, randomPercent / 100f);
		}
	}
	public class ETFXRotation : MonoBehaviour
	{
		public enum spaceEnum
		{
			Local,
			World
		}

		[Header("Rotate axises by degrees per second")]
		public UnityEngine.Vector3 rotateVector = UnityEngine.Vector3.zero;

		public spaceEnum rotateSpace;

		private void Start()
		{
		}

		private void Update()
		{
			if (rotateSpace == spaceEnum.Local)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime);
			}
			if (rotateSpace == spaceEnum.World)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime, Space.World);
			}
		}
	}
}
namespace UnityTemplateProject
{
	public class SimpleCameraController : MonoBehaviour
	{
		private class CameraState
		{
			public float yaw;

			public float pitch;

			public float roll;

			public float x;

			public float y;

			public float z;

			public void SetFromTransform(Transform t)
			{
				pitch = t.eulerAngles.x;
				yaw = t.eulerAngles.y;
				roll = t.eulerAngles.z;
				x = t.position.x;
				y = t.position.y;
				z = t.position.z;
			}

			public void Translate(UnityEngine.Vector3 translation)
			{
				UnityEngine.Vector3 vector = UnityEngine.Quaternion.Euler(pitch, yaw, roll) * translation;
				x += vector.x;
				y += vector.y;
				z += vector.z;
			}

			public void LerpTowards(CameraState target, float positionLerpPct, float rotationLerpPct)
			{
				yaw = Mathf.Lerp(yaw, target.yaw, rotationLerpPct);
				pitch = Mathf.Lerp(pitch, target.pitch, rotationLerpPct);
				roll = Mathf.Lerp(roll, target.roll, rotationLerpPct);
				x = Mathf.Lerp(x, target.x, positionLerpPct);
				y = Mathf.Lerp(y, target.y, positionLerpPct);
				z = Mathf.Lerp(z, target.z, positionLerpPct);
			}

			public void UpdateTransform(Transform t)
			{
				t.eulerAngles = new UnityEngine.Vector3(pitch, yaw, roll);
				t.position = new UnityEngine.Vector3(x, y, z);
			}
		}

		private CameraState m_TargetCameraState = new CameraState();

		private CameraState m_InterpolatingCameraState = new CameraState();

		[Header("Movement Settings")]
		[Tooltip("Exponential boost factor on translation, controllable by mouse wheel.")]
		public float boost = 3.5f;

		[Tooltip("Time it takes to interpolate camera position 99% of the way to the target.")]
		[Range(0.001f, 1f)]
		public float positionLerpTime = 0.2f;

		[Header("Rotation Settings")]
		[Tooltip("X = Change in mouse position.\nY = Multiplicative factor for camera rotation.")]
		public AnimationCurve mouseSensitivityCurve = new AnimationCurve(new Keyframe(0f, 0.5f, 0f, 5f), new Keyframe(1f, 2.5f, 0f, 0f));

		[Tooltip("Time it takes to interpolate camera rotation 99% of the way to the target.")]
		[Range(0.001f, 1f)]
		public float rotationLerpTime = 0.01f;

		[Tooltip("Whether or not to invert our Y axis for mouse input to rotation.")]
		public bool invertY;

		private void OnEnable()
		{
			m_TargetCameraState.SetFromTransform(base.transform);
			m_InterpolatingCameraState.SetFromTransform(base.transform);
		}

		private UnityEngine.Vector3 GetInputTranslationDirection()
		{
			UnityEngine.Vector3 result = default(UnityEngine.Vector3);
			if (Input.GetKey(KeyCode.W))
			{
				result += UnityEngine.Vector3.forward;
			}
			if (Input.GetKey(KeyCode.S))
			{
				result += UnityEngine.Vector3.back;
			}
			if (Input.GetKey(KeyCode.A))
			{
				result += UnityEngine.Vector3.left;
			}
			if (Input.GetKey(KeyCode.D))
			{
				result += UnityEngine.Vector3.right;
			}
			if (Input.GetKey(KeyCode.Q))
			{
				result += UnityEngine.Vector3.down;
			}
			if (Input.GetKey(KeyCode.E))
			{
				result += UnityEngine.Vector3.up;
			}
			return result;
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.Escape))
			{
				Application.Quit();
			}
			if (Input.GetMouseButtonDown(1))
			{
				Cursor.lockState = CursorLockMode.Locked;
			}
			if (Input.GetMouseButtonUp(1))
			{
				Cursor.visible = true;
				Cursor.lockState = CursorLockMode.None;
			}
			if (Input.GetMouseButton(1))
			{
				UnityEngine.Vector2 vector = new UnityEngine.Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y") * (float)(invertY ? 1 : (-1)));
				float num = mouseSensitivityCurve.Evaluate(vector.magnitude);
				m_TargetCameraState.yaw += vector.x * num;
				m_TargetCameraState.pitch += vector.y * num;
			}
			UnityEngine.Vector3 translation = GetInputTranslationDirection() * Time.deltaTime;
			if (Input.GetKey(KeyCode.LeftShift))
			{
				translation *= 10f;
			}
			boost += Input.mouseScrollDelta.y * 0.2f;
			translation *= Mathf.Pow(2f, boost);
			m_TargetCameraState.Translate(translation);
			float positionLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / positionLerpTime * Time.deltaTime);
			float rotationLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / rotationLerpTime * Time.deltaTime);
			m_InterpolatingCameraState.LerpTowards(m_TargetCameraState, positionLerpPct, rotationLerpPct);
			m_InterpolatingCameraState.UpdateTransform(base.transform);
		}
	}
}
namespace AudioVisualizer
{
	[Serializable]
	public class OnFrequencyEvent : UnityEvent<float>
	{
	}
	[Serializable]
	public class OnFrequencyChanged
	{
		public OnFrequencyEvent onChange;

		public float minValue;

		public float maxValue = 1f;
	}
	public class AudioEventListener : MonoBehaviour
	{
		public delegate void BeatEvent();

		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public int sampleBufferSize = 40;

		public float beatThreshold = 1.3f;

		public bool automatic = true;

		public bool debug;

		public UnityEvent OnBeat;

		public OnFrequencyChanged onFrequencyChanged;

		public static BeatEvent BeatDetected;

		private bool canDetect = true;

		private float lastFreq;

		private float lastVariance;

		private float[] sampleBuffer;

		private int index;

		private float avgEnergy;

		private float variance;

		private float varyPercent;

		private float frequency;

		private void Awake()
		{
			sampleBuffer = new float[sampleBufferSize];
			for (int i = 0; i < sampleBuffer.Length; i++)
			{
				sampleBuffer[i] = 0f;
			}
		}

		private void FixedUpdate()
		{
			if (automatic)
			{
				AutomaticDetection();
			}
			else
			{
				CustomDetection();
			}
			HandleFrequencyEvents();
		}

		private void HandleFrequencyEvents()
		{
			if (onFrequencyChanged != null)
			{
				float num = onFrequencyChanged.maxValue - onFrequencyChanged.minValue;
				float arg = onFrequencyChanged.minValue + num * GetNormalizedFrequency();
				onFrequencyChanged.onChange.Invoke(arg);
			}
		}

		private void CustomDetection()
		{
			if (index >= sampleBuffer.Length)
			{
				index = 0;
			}
			frequency = AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange);
			sampleBuffer[index] = frequency;
			avgEnergy = GetAvgEnergy();
			if (frequency > beatThreshold * avgEnergy)
			{
				OnBeat.Invoke();
				if (BeatDetected != null)
				{
					BeatDetected();
					if (debug)
					{
						UnityEngine.Debug.Log("Beat Detected");
					}
				}
			}
			if (debug)
			{
				UnityEngine.Debug.Log("FreqVolume: " + frequency + " beatThreshold: " + beatThreshold * avgEnergy);
			}
			index++;
		}

		private void AutomaticDetection()
		{
			if (index >= sampleBuffer.Length)
			{
				index = 0;
			}
			frequency = AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange);
			sampleBuffer[index] = frequency;
			avgEnergy = GetAvgEnergy();
			variance = GetAvgVariance(avgEnergy);
			varyPercent = 1f - (avgEnergy - variance) / avgEnergy;
			beatThreshold = 1f + varyPercent;
			if (!canDetect && frequency < (2f - beatThreshold) * avgEnergy)
			{
				canDetect = true;
			}
			if (frequency > beatThreshold * avgEnergy && canDetect)
			{
				canDetect = false;
				lastFreq = frequency;
				lastVariance = varyPercent;
				OnBeat.Invoke();
				if (BeatDetected != null)
				{
					BeatDetected();
					if (debug)
					{
						UnityEngine.Debug.Log("Beat Detected");
					}
				}
			}
			if (debug)
			{
				UnityEngine.Debug.Log("Freq: " + frequency + " beatThreshold: " + beatThreshold * avgEnergy);
			}
			index++;
		}

		public float GetNormalizedFrequency()
		{
			float num = float.NegativeInfinity;
			float[] array = sampleBuffer;
			foreach (float b in array)
			{
				num = Mathf.Max(num, b);
			}
			return frequency / num;
		}

		private float GetAvgEnergy()
		{
			float num = 0f;
			for (int i = 0; i < sampleBuffer.Length; i++)
			{
				num += sampleBuffer[i];
			}
			return num / (float)sampleBuffer.Length;
		}

		private float GetAvgVariance(float avg)
		{
			float num = 0f;
			for (int i = 0; i < sampleBuffer.Length; i++)
			{
				float f = sampleBuffer[i] - avg;
				num += Mathf.Abs(f);
			}
			return num / (float)sampleBuffer.Length;
		}
	}
	public class AudioSampler : MonoBehaviour
	{
		public static AudioSampler instance;

		public List<AudioSource> audioSources;

		public bool debug;

		private Texture2D drawTexture;

		private Color startColor = Color.magenta;

		private Color endColor = Color.blue;

		private Gradient gradient;

		private float fMax;

		private List<string> debugLables = new List<string> { "SubBass", "Bass", "LowMid", "Mid", "UpperMid", "High", "VeryHigh", "Decibal" };

		private int samplesToTake = 1024;

		private void OnEnable()
		{
			if (instance == null)
			{
				instance = this;
			}
		}

		private void OnDisable()
		{
			instance = null;
		}

		private void Awake()
		{
			drawTexture = Texture2D.whiteTexture;
			gradient = PanelWaveform.GetColorGradient(startColor, endColor);
			if (audioSources.Count == 0)
			{
				if (GetComponent<AudioSource>() != null)
				{
					audioSources.Add(GetComponent<AudioSource>());
				}
				else
				{
					UnityEngine.Debug.LogError("Error! no audio sources attached to AudioSampler.css");
				}
			}
		}

		private void Start()
		{
			fMax = (float)AudioSettings.outputSampleRate / 2f;
		}

		private void OnGUI()
		{
			if (!debug)
			{
				return;
			}
			int num = 100;
			for (int i = 0; i < audioSources.Count; i++)
			{
				int num2 = (int)((float)Screen.width * 0.5f);
				int num3 = num * (i + 1);
				int num4 = (int)((float)num3 * 0.2f);
				int num5 = num2 / debugLables.Count;
				int width = 10;
				int num6 = num3 - num4;
				int num7 = 40;
				GUI.color = Color.white;
				GUI.Label(new Rect(0f, num6, 60f, 20f), "Source: " + i);
				for (int j = 0; j < debugLables.Count; j++)
				{
					float time = (float)j / (float)(debugLables.Count - 1);
					int num8 = num7 + num5 + num5 * j;
					UnityEngine.Vector2 start = new UnityEngine.Vector2(num8, num6);
					float num9 = Mathf.Clamp(GetFrequencyVol(i, (FrequencyRange)j) * 10f, 0f, 0.5f);
					float y = (float)num6 - (float)num * num9;
					UnityEngine.Vector2 end = new UnityEngine.Vector2(num8, y);
					DrawLine(start, end, width, gradient.Evaluate(time));
					GUI.Label(new Rect(num8, num6, 60f, 20f), debugLables[j]);
					GUI.Label(new Rect(num8, num6 + 20, 40f, 20f), num9.ToString("F3"));
				}
			}
		}

		private void DrawLine(UnityEngine.Vector2 start, UnityEngine.Vector2 end, int width, Color color)
		{
			GUI.color = color;
			UnityEngine.Vector2 vector = end - start;
			float num = 57.29578f * Mathf.Atan(vector.y / vector.x);
			if (vector.x < 0f)
			{
				num += 180f;
			}
			int num2 = (int)Mathf.Ceil(width / 2);
			if ((double)UnityEngine.Vector2.Distance(start, end) > 0.1)
			{
				GUIUtility.RotateAroundPivot(num, start);
				GUI.DrawTexture(new Rect(start.x, start.y - (float)num2, vector.magnitude, width), drawTexture);
				GUIUtility.RotateAroundPivot(0f - num, start);
			}
		}

		public float[] GetAudioSamples(int audioSourceIndex)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				float[] outputData = audioSources[audioSourceIndex].GetOutputData(samplesToTake, 0);
				float[] array = NormalizeArray(outputData);
				for (int i = 0; i < outputData.Length; i++)
				{
					array[i] *= audioSources[audioSourceIndex].volume;
				}
				return array;
			}
			return new float[samplesToTake];
		}

		public float[] GetAudioSamples(int audioSourceIndex, int numBins, bool absoluteVal)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				float[] outputData = audioSources[audioSourceIndex].GetOutputData(numBins, 0);
				float[] array = NormalizeArray(outputData);
				for (int i = 0; i < outputData.Length; i++)
				{
					if (absoluteVal)
					{
						array[i] = Mathf.Abs(outputData[i]) * audioSources[audioSourceIndex].volume;
					}
					else
					{
						array[i] = outputData[i] * audioSources[audioSourceIndex].volume;
					}
				}
				return array;
			}
			return new float[numBins];
		}

		public float GetInstantEnergy(int audioSourceIndex)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				float[] audioSamples = GetAudioSamples(audioSourceIndex);
				float num = 0f;
				float[] array = audioSamples;
				foreach (float num2 in array)
				{
					num += num2 * num2;
				}
				return num * audioSources[audioSourceIndex].volume;
			}
			return 0f;
		}

		public float GetRMS(int audioSourceIndex)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				float[] outputData = audioSources[audioSourceIndex].GetOutputData(samplesToTake, 0);
				float num = 0f;
				for (int i = 0; i < samplesToTake; i++)
				{
					num += outputData[i] * outputData[i];
				}
				return Mathf.Sqrt(num / (float)samplesToTake) * audioSources[audioSourceIndex].volume;
			}
			return 0f;
		}

		public float GetFrequencyVol(int audioSourceIndex, FrequencyRange freqRange)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				UnityEngine.Vector2 freqForRange = GetFreqForRange(freqRange);
				float x = freqForRange.x;
				float y = freqForRange.y;
				float[] array = new float[samplesToTake];
				audioSources[audioSourceIndex].GetSpectrumData(array, 0, FFTWindow.BlackmanHarris);
				int num = (int)Mathf.Floor(x * (float)samplesToTake / fMax);
				int num2 = (int)Mathf.Floor(y * (float)samplesToTake / fMax);
				float num3 = 0f;
				for (int i = num; i <= num2; i++)
				{
					if (i < array.Length)
					{
						num3 += Mathf.Abs(array[i]);
					}
				}
				num3 *= audioSources[audioSourceIndex].volume;
				return num3 / (float)(num2 - num + 1);
			}
			return 0f;
		}

		public float[] GetFrequencyData(int audioSourceIndex, FrequencyRange freqRange)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				UnityEngine.Vector2 freqForRange = GetFreqForRange(freqRange);
				float x = freqForRange.x;
				float y = freqForRange.y;
				float[] array = new float[samplesToTake];
				audioSources[audioSourceIndex].GetSpectrumData(array, 0, FFTWindow.BlackmanHarris);
				int num = (int)Mathf.Floor(x * (float)samplesToTake / fMax);
				int num2 = (int)Mathf.Floor(y * (float)samplesToTake / fMax);
				List<float> list = new List<float>();
				for (int i = num; i <= num2; i++)
				{
					list.Add(array[i] * audioSources[audioSourceIndex].volume);
				}
				return NormalizeArray(list.ToArray());
			}
			UnityEngine.Debug.LogWarning("warning: Audio Source: " + audioSourceIndex + " is muted");
			return new float[samplesToTake];
		}

		public float[] GetFrequencyData(int audioSourceIndex, FrequencyRange freqRange, int numBins, bool abs)
		{
			if (!audioSources[audioSourceIndex].mute)
			{
				UnityEngine.Vector2 freqForRange = GetFreqForRange(freqRange);
				float x = freqForRange.x;
				float y = freqForRange.y;
				float[] array = new float[samplesToTake];
				audioSources[audioSourceIndex].GetSpectrumData(array, 0, FFTWindow.BlackmanHarris);
				int num = (int)Mathf.Floor(x * (float)samplesToTake / fMax);
				int num2 = (int)Mathf.Floor(y * (float)samplesToTake / fMax);
				List<float> list = new List<float>();
				for (int i = num; i <= num2; i++)
				{
					float num3 = array[i];
					if (abs)
					{
						num3 = Mathf.Abs(array[i]);
					}
					list.Add(num3 * audioSources[audioSourceIndex].volume);
				}
				float[] binnedArray = GetBinnedArray(list.ToArray(), numBins);
				return NormalizeArray(binnedArray);
			}
			UnityEngine.Debug.LogWarning("warning: Audio Source: " + audioSourceIndex + " is muted");
			return new float[numBins];
		}

		private float[] GetBinnedArray(float[] input, int numBins)
		{
			float[] array = new float[numBins];
			if (numBins == input.Length)
			{
				return input;
			}
			if (numBins > input.Length)
			{
				int num = numBins / input.Length;
				for (int i = 0; i < numBins; i++)
				{
					int num2 = (i + 1) % num;
					array[i] = input[num2];
				}
			}
			if (numBins < input.Length)
			{
				int num3 = input.Length / numBins;
				for (int j = 0; j < numBins; j++)
				{
					float num4 = 0f;
					for (int k = 0; k < num3; k++)
					{
						int num5 = j * num3 + k;
						num4 += input[num5];
					}
					num4 /= (float)num3;
					array[j] = num4;
				}
			}
			return array;
		}

		private float[] NormalizeArray(float[] input)
		{
			float[] array = new float[input.Length];
			float num = float.NegativeInfinity;
			for (int i = 0; i < input.Length; i++)
			{
				num = Mathf.Max(num, Mathf.Abs(input[i]));
			}
			for (int j = 0; j < input.Length; j++)
			{
				array[j] = input[j] / num;
			}
			return array;
		}

		public static UnityEngine.Vector2 GetFreqForRange(FrequencyRange freqRange)
		{
			return freqRange switch
			{
				FrequencyRange.SubBase => new UnityEngine.Vector2(20f, 60f), 
				FrequencyRange.Bass => new UnityEngine.Vector2(60f, 250f), 
				FrequencyRange.LowMidrange => new UnityEngine.Vector2(250f, 500f), 
				FrequencyRange.Midrange => new UnityEngine.Vector2(500f, 2000f), 
				FrequencyRange.UpperMidrange => new UnityEngine.Vector2(2000f, 4000f), 
				FrequencyRange.High => new UnityEngine.Vector2(4000f, 6000f), 
				FrequencyRange.VeryHigh => new UnityEngine.Vector2(6000f, 20000f), 
				FrequencyRange.Decibal => new UnityEngine.Vector2(0f, 20000f), 
				_ => UnityEngine.Vector2.zero, 
			};
		}
	}
	public enum FrequencyRange
	{
		SubBase,
		Bass,
		LowMidrange,
		Midrange,
		UpperMidrange,
		High,
		VeryHigh,
		Decibal
	}
	public class CircleWaveform : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public List<GameObject> objects;

		public float rotationSpeed = 10f;

		public float radius = 10f;

		public float lerpSpeed = 10f;

		public bool useWaveform = true;

		private List<float> startAngles;

		private float angle;

		private float rotSpeed;

		private bool bumped;

		private float startRadius;

		private float sign = 1f;

		private void Awake()
		{
			startAngles = new List<float>();
			float num = 360f / (float)objects.Count;
			for (int i = 0; i < objects.Count; i++)
			{
				startAngles.Add((float)i * num);
			}
			rotSpeed = rotationSpeed;
			startRadius = radius;
		}

		private void Start()
		{
			PositionObjects();
		}

		private void Update()
		{
			PositionObjects();
		}

		private void OnDrawGizmos()
		{
			Gizmos.color = Color.white;
			Gizmos.DrawSphere(base.transform.position, 1f);
		}

		public void Boost(float multiplier)
		{
			Invoke("ResetSpeed", 0.1f);
			rotationSpeed *= multiplier;
		}

		private void ResetSpeed()
		{
			rotationSpeed = rotSpeed;
		}

		public void Bump(bool switchSign)
		{
			float num = ((frequencyRange != FrequencyRange.Decibal) ? (AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange) * sensitivity) : (AudioSampler.instance.GetRMS(audioSource) * sensitivity));
			if (switchSign)
			{
				sign = 0f - sign;
			}
			radius = startRadius * num * sign;
		}

		private void PositionObjects()
		{
			angle += Time.smoothDeltaTime * rotationSpeed;
			for (int i = 0; i < objects.Count; i++)
			{
				float f = (angle + startAngles[i]) * ((float)Math.PI / 180f);
				float num = radius;
				if (useWaveform)
				{
					float num2 = ((frequencyRange != FrequencyRange.Decibal) ? (AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange) * sensitivity) : (AudioSampler.instance.GetRMS(audioSource) * sensitivity));
					num = radius * num2;
				}
				float num3 = Mathf.Cos(f) * num;
				float num4 = Mathf.Sin(f) * num;
				UnityEngine.Vector3 b = base.transform.position + base.transform.right * num3 + base.transform.up * num4;
				objects[i].transform.position = UnityEngine.Vector3.Lerp(objects[i].transform.position, b, lerpSpeed * Time.smoothDeltaTime);
			}
		}
	}
	public class ColorChange : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public Color lowColor = Color.white;

		public Color highColor = Color.white;

		public float lerpSpeed = 10f;

		private Gradient gradient;

		private List<Material> materials;

		private float alpha;

		private void Awake()
		{
			gradient = PanelWaveform.GetColorGradient(lowColor, highColor);
			materials = new List<Material>();
			Material[] array = GetComponent<MeshRenderer>().materials;
			foreach (Material item in array)
			{
				materials.Add(item);
			}
			alpha = materials[0].color.a;
		}

		private void Update()
		{
			ColorPanel();
		}

		public void Reset()
		{
			gradient = PanelWaveform.GetColorGradient(lowColor, highColor);
		}

		private void ColorPanel()
		{
			float value = ((frequencyRange != FrequencyRange.Decibal) ? (AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange) * sensitivity) : (AudioSampler.instance.GetRMS(audioSource) * sensitivity));
			value = Mathf.Clamp(value, 0f, 1f);
			Color b = gradient.Evaluate(value);
			Color color = Color.Lerp(materials[0].color, b, lerpSpeed * Time.deltaTime);
			float b2 = lowColor.a + (highColor.a - lowColor.a) * value;
			alpha = Mathf.Lerp(alpha, b2, lerpSpeed * Time.deltaTime);
			color.a = alpha;
			foreach (Material material in materials)
			{
				material.color = color;
			}
		}
	}
	public class CurveWaveform : LineWaveform
	{
		public AnimationCurve shapeCurve;

		public float curveAmplitude = 5f;

		public UnityEngine.Vector3 curveDirection = UnityEngine.Vector3.up;

		private void Update()
		{
			DrawLines();
		}

		private void DrawLines()
		{
			for (int i = 0; i < points.Count - 1; i++)
			{
				UnityEngine.Vector3 position = points[i].position;
				UnityEngine.Vector3 position2 = points[i + 1].position;
				UnityEngine.Vector3 vector = position2 - position;
				int num = 0;
				int num2 = lineAtt.lineSegments;
				float[] array = ((frequencyRange != FrequencyRange.Decibal) ? AudioSampler.instance.GetFrequencyData(audioSource, frequencyRange, lineAtt.lineSegments, abs) : AudioSampler.instance.GetAudioSamples(audioSource, lineAtt.lineSegments, abs));
				if (snapEndpoints)
				{
					lines[i].SetPosition(0, position);
					lines[i].SetPosition(lineAtt.lineSegments - 1, position2);
					num = 1;
					num2 = lineAtt.lineSegments - 1;
				}
				for (int j = num; j < num2; j++)
				{
					float num3 = (float)j / (float)(lineAtt.lineSegments - 1);
					UnityEngine.Vector3 position3 = position + vector * num3;
					float num4 = array[j];
					if (abs)
					{
						num4 = Mathf.Abs(num4);
					}
					float num5;
					if (shapeCurve != null)
					{
						num5 = shapeCurve.Evaluate(num3) * curveAmplitude + num4 * waveformAmplitude;
					}
					else
					{
						UnityEngine.Debug.LogWarning("Warning: No Shape Curve set for CurveWaveform.cs on " + base.gameObject.name);
						num5 = num4 * waveformAmplitude;
					}
					position3 += points[i].transform.TransformDirection(curveDirection) * num5;
					lines[i].SetPosition(j, position3);
				}
			}
		}
	}
	public class LineWaveform : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public List<Transform> points;

		public LineAttributes lineAtt;

		public float waveformAmplitude = 5f;

		public float gizmosSize = 1f;

		public bool abs;

		public bool snapEndpoints = true;

		protected List<LineRenderer> lines;

		private void Start()
		{
			lines = new List<LineRenderer>();
			for (int i = 0; i < points.Count - 1; i++)
			{
				LineRenderer item = NewLine(lineAtt.startColor, lineAtt.endColor, lineAtt.startWidth, lineAtt.endWidth, lineAtt.lineSegments);
				lines.Add(item);
			}
		}

		private void Update()
		{
			DrawLines();
		}

		private void OnDrawGizmos()
		{
			Gizmos.color = Color.white;
			for (int i = 0; i < points.Count - 1; i++)
			{
				UnityEngine.Vector3 position = points[i].position;
				UnityEngine.Vector3 position2 = points[i + 1].position;
				Gizmos.DrawLine(position, position2);
			}
			for (int j = 0; j < points.Count; j++)
			{
				Gizmos.DrawSphere(points[j].position, gizmosSize);
			}
		}

		private void DrawLines()
		{
			for (int i = 0; i < points.Count - 1; i++)
			{
				UnityEngine.Vector3 position = points[i].position;
				UnityEngine.Vector3 position2 = points[i + 1].position;
				UnityEngine.Vector3 vector = position2 - position;
				int num = 0;
				int num2 = lineAtt.lineSegments;
				float[] array = ((frequencyRange != FrequencyRange.Decibal) ? AudioSampler.instance.GetFrequencyData(audioSource, frequencyRange, lineAtt.lineSegments, abs) : AudioSampler.instance.GetAudioSamples(audioSource, lineAtt.lineSegments, abs));
				if (snapEndpoints)
				{
					lines[i].SetPosition(0, position);
					lines[i].SetPosition(lineAtt.lineSegments - 1, position2);
					num = 1;
					num2 = lineAtt.lineSegments - 1;
				}
				for (int j = num; j < num2; j++)
				{
					float num3 = (float)j / (float)(lineAtt.lineSegments - 1);
					int num4 = (int)(num3 * (float)(array.Length - 1));
					UnityEngine.Vector3 position3 = position + vector * num3;
					float num5 = ((!abs) ? (array[num4] * waveformAmplitude) : (Mathf.Abs(array[num4]) * waveformAmplitude));
					position3 += points[i].up * num5;
					lines[i].SetPosition(j, position3);
				}
			}
		}

		public LineRenderer NewLine(Color color1, Color color2, float startWidth, float endWidth, int segments)
		{
			GameObject obj = new GameObject();
			obj.transform.SetParent(base.transform);
			obj.name = "Line";
			LineRenderer lineRenderer = obj.AddComponent<LineRenderer>();
			lineRenderer = obj.GetComponent<LineRenderer>();
			if (lineAtt.lineMat == null)
			{
				lineRenderer.material = new Material(Shader.Find("Particles/Additive"));
			}
			else
			{
				lineRenderer.material = lineAtt.lineMat;
			}
			lineRenderer.SetColors(color1, color2);
			lineRenderer.SetWidth(startWidth, endWidth);
			lineRenderer.SetVertexCount(segments);
			return lineRenderer;
		}

		public void OrientPoints()
		{
			for (int i = 0; i < points.Count - 1; i++)
			{
				points[i].LookAt(points[i + 1].position);
			}
		}

		public void RenamePoints(string name)
		{
			for (int i = 0; i < points.Count; i++)
			{
				points[i].gameObject.name = name + i;
			}
		}
	}
	[Serializable]
	public class LineAttributes
	{
		public Material lineMat;

		public Color startColor = Color.cyan;

		public Color endColor = Color.magenta;

		public float startWidth = 0.1f;

		public float endWidth = 0.1f;

		public int lineSegments = 36;
	}
	public class MaterialChange : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public Material lowMat;

		public Material highMat;

		public float lerpSpeed = 10f;

		private List<Material> materials;

		private Renderer renderer;

		private float lastAvg;

		private void Start()
		{
			renderer = GetComponent<Renderer>();
			materials = new List<Material>();
			Material[] array = GetComponent<MeshRenderer>().materials;
			foreach (Material item in array)
			{
				materials.Add(item);
			}
		}

		private void Update()
		{
			LerpMaterial();
		}

		private void LerpMaterial()
		{
			float value = ((frequencyRange != FrequencyRange.Decibal) ? (AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange) * sensitivity) : (AudioSampler.instance.GetRMS(audioSource) * sensitivity));
			value = Mathf.Clamp(value, 0f, 1f);
			float value2 = Mathf.Lerp(lastAvg, value, lerpSpeed * Time.deltaTime);
			foreach (Material material in materials)
			{
				material.GetFloat("_Blend");
				material.SetFloat("_Blend", value2);
			}
			lastAvg = value;
		}
	}
	public class ObjectPositionWaveform : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public List<GameObject> objects;

		public UnityEngine.Vector3 positionAxis = UnityEngine.Vector3.up;

		public float maxHeight = 10f;

		public float lerpSpeed = 1f;

		public bool absoluteVal = true;

		private List<UnityEngine.Vector3> startingPositions;

		private void Start()
		{
			startingPositions = new List<UnityEngine.Vector3>();
			foreach (GameObject @object in objects)
			{
				UnityEngine.Vector3 item = @object.transform.position - base.transform.position;
				startingPositions.Add(item);
			}
		}

		private void Update()
		{
			PositionObjects();
			for (int i = 0; i < objects.Count; i++)
			{
				UnityEngine.Debug.DrawLine(startingPositions[i], startingPositions[i] + objects[i].transform.up * maxHeight);
			}
		}

		private void PositionObjects()
		{
			float[] array = ((frequencyRange != FrequencyRange.Decibal) ? AudioSampler.instance.GetFrequencyData(audioSource, frequencyRange, objects.Count, absoluteVal) : AudioSampler.instance.GetAudioSamples(audioSource, objects.Count, absoluteVal));
			for (int i = 0; i < objects.Count; i++)
			{
				float num = Mathf.Min(array[i] * sensitivity, 1f) * maxHeight;
				UnityEngine.Vector3 vector = objects[i].transform.TransformDirection(positionAxis);
				UnityEngine.Vector3 b = base.transform.position + startingPositions[i] + num * vector;
				objects[i].transform.position = UnityEngine.Vector3.Lerp(objects[i].transform.position, b, Time.smoothDeltaTime * lerpSpeed);
			}
		}
	}
	public class ObjectScaleWaveform : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public List<GameObject> objects;

		public UnityEngine.Vector3 scaleAxis = UnityEngine.Vector3.up;

		public float maxHeight = 10f;

		public float lerpSpeed = 1f;

		public bool absoluteVal = true;

		private List<UnityEngine.Vector3> startingScales;

		private List<UnityEngine.Vector3> startingPositions;

		private void Start()
		{
			startingScales = new List<UnityEngine.Vector3>();
			startingPositions = new List<UnityEngine.Vector3>();
			foreach (GameObject @object in objects)
			{
				startingScales.Add(@object.transform.localScale);
				startingPositions.Add(@object.transform.position);
			}
		}

		private void Update()
		{
			ScaleObjects();
		}

		private void ScaleObjects()
		{
			float[] array = ((frequencyRange != FrequencyRange.Decibal) ? AudioSampler.instance.GetFrequencyData(audioSource, frequencyRange, objects.Count, absoluteVal) : AudioSampler.instance.GetAudioSamples(audioSource, objects.Count, absoluteVal));
			for (int i = 0; i < objects.Count; i++)
			{
				float num = Mathf.Min(array[i] * sensitivity, 1f) * maxHeight;
				UnityEngine.Vector3 b = startingScales[i] + num * base.transform.InverseTransformDirection(scaleAxis);
				objects[i].transform.localScale = UnityEngine.Vector3.Lerp(objects[i].transform.localScale, b, Time.smoothDeltaTime * lerpSpeed);
				float y = (objects[i].transform.localScale - startingScales[i]).y;
				UnityEngine.Vector3 vector = objects[i].transform.TransformDirection(scaleAxis);
				objects[i].transform.position = startingPositions[i] + y * vector * 0.5f;
			}
		}
	}
	public class PadWaveform : MonoBehaviour
	{
		public enum PadType
		{
			Ripple,
			DampWave,
			Wave,
			Bounce
		}

		public int audioSource;

		public int numLines = 20;

		public float radius = 10f;

		public float maxHeight = 3f;

		public int updateRate = 1;

		public PadType padType = PadType.Wave;

		public Color rippleColor = Color.white;

		public int rippleWidth = 3;

		public LineAttributes lineAttributes;

		public bool gizmos = true;

		private List<LineRenderer> lines = new List<LineRenderer>();

		private Gradient padGradient;

		private int updateCounter;

		private float fakeTimer;

		private void Start()
		{
			padGradient = PanelWaveform.GetColorGradient(lineAttributes.startColor, lineAttributes.endColor);
			for (int i = 0; i < numLines; i++)
			{
				float time = (float)i / (float)(numLines - 1);
				lines.Add(NewLine(padGradient.Evaluate(time)));
			}
			CreatePad();
			if (rippleWidth > numLines)
			{
				rippleWidth = numLines;
			}
		}

		private void FixedUpdate()
		{
			if (updateCounter >= updateRate)
			{
				switch (padType)
				{
				case PadType.Ripple:
					Ripple();
					break;
				case PadType.DampWave:
					DampWave();
					break;
				case PadType.Wave:
					Wave();
					break;
				case PadType.Bounce:
					Bounce();
					break;
				}
				updateCounter = 0;
			}
			updateCounter++;
		}

		public void SendRipple(float propegationTime)
		{
			float[] audioSamples = AudioSampler.instance.GetAudioSamples(audioSource, lineAttributes.lineSegments, absoluteVal: true);
			StartCoroutine(RipIt(propegationTime, audioSamples));
		}

		private IEnumerator RipIt(float propegationTime, float[] rippleSamples)
		{
			float timer = 0f;
			float radiusStep = radius / (float)(numLines - 1);
			float angle = 0f;
			float angleStep = 360f / (float)lineAttributes.lineSegments;
			int maxIndex = numLines - 1;
			int halfWidth = rippleWidth / 2;
			float heightStep = 1f / (float)(halfWidth + 1);
			Gradient colorGradient = PanelWaveform.GetColorGradient(lineAttributes.startColor, rippleColor);
			Color[] rippleColors = new Color[maxIndex];
			float num = 1f / (float)(rippleWidth - 1);
			for (int i = 0; i < rippleWidth; i++)
			{
				float time = (float)i * num;
				rippleColors[i] = colorGradient.Evaluate(time);
			}
			Color[] lineColors = new Color[numLines];
			float[] heightDamp = new float[numLines];
			float num2 = maxHeight / (float)(numLines - 1);
			num = 1f / (float)(numLines - 1);
			for (int j = 0; j < numLines; j++)
			{
				float time = (float)j * num;
				lineColors[j] = padGradient.Evaluate(time);
				heightDamp[j] = maxHeight - (float)j * num2;
			}
			while (timer <= propegationTime)
			{
				float time = timer / propegationTime;
				int num3 = (int)(time * (float)maxIndex);
				int b = num3 - rippleWidth - 1;
				b = Mathf.Max(0, b);
				int a = num3 + rippleWidth;
				a = Mathf.Min(a, numLines);
				UnityEngine.Vector3 position = UnityEngine.Vector3.zero;
				for (int k = b; k < a; k++)
				{
					int num4 = Mathf.Abs(num3 - k);
					int num5 = rippleWidth - num4;
					float num6 = ((num4 > halfWidth) ? 0f : (1f - heightStep * (float)num4));
					float num7 = radiusStep * (float)k;
					if (k == num3 - rippleWidth - 1)
					{
						lines[k].SetColors(lineColors[num3], lineColors[num3]);
					}
					else
					{
						lines[k].SetColors(rippleColors[num5], rippleColors[num5]);
					}
					for (int l = 0; l < lineAttributes.lineSegments - 1; l++)
					{
						float f = (float)Math.PI / 180f * angle;
						float num8 = Mathf.Cos(f) * num7;
						float num9 = rippleSamples[l] * heightDamp[num3] * num6;
						float num10 = Mathf.Sin(f) * num7;
						UnityEngine.Vector3 vector = base.transform.position + base.transform.right * num8 + base.transform.up * num9 + base.transform.forward * num10;
						lines[k].SetPosition(l, vector);
						angle += angleStep;
						if (l == 0)
						{
							position = vector;
						}
					}
					lines[k].SetPosition(lineAttributes.lineSegments - 1, position);
				}
				timer += Time.fixedDeltaTime;
				yield return null;
			}
		}

		private void Ripple()
		{
			float num = 360f / (float)lineAttributes.lineSegments;
			float[] audioSamples = AudioSampler.instance.GetAudioSamples(audioSource, lineAttributes.lineSegments, absoluteVal: true);
			float num2 = 0f;
			float num3 = radius / (float)(numLines - 1);
			UnityEngine.Vector3 position = UnityEngine.Vector3.zero;
			for (int i = 0; i < lineAttributes.lineSegments - 1; i++)
			{
				float f = (float)Math.PI / 180f * num2;
				float num4 = Mathf.Cos(f) * num3;
				float num5 = audioSamples[i] * maxHeight;
				float num6 = Mathf.Sin(f) * num3;
				UnityEngine.Vector3 vector = base.transform.position + base.transform.right * num4 + base.transform.up * num5 + base.transform.forward * num6;
				lines[0].SetPosition(i, vector);
				num2 += num;
				if (i == 0)
				{
					position = vector;
				}
			}
			lines[0].SetPosition(lineAttributes.lineSegments - 1, position);
		}

		private void Wave()
		{
			float num = radius / (float)(numLines - 1);
			float num2 = 360f / (float)lineAttributes.lineSegments;
			for (int i = 0; i < numLines; i++)
			{
				float num3 = 0f;
				float num4 = num * (float)i;
				float[] audioSamples = AudioSampler.instance.GetAudioSamples(audioSource, lineAttributes.lineSegments, absoluteVal: true);
				UnityEngine.Vector3 position = UnityEngine.Vector3.zero;
				for (int j = 0; j < lineAttributes.lineSegments - 1; j++)
				{
					float f = (float)Math.PI / 180f * num3;
					float num5 = Mathf.Cos(f) * num4;
					float num6 = audioSamples[j] * maxHeight;
					float num7 = Mathf.Sin(f) * num4;
					UnityEngine.Vector3 vector = base.transform.position + base.transform.right * num5 + base.transform.up * num6 + base.transform.forward * num7;
					lines[i].SetPosition(j, vector);
					num3 += num2;
					if (j == 0)
					{
						position = vector;
					}
				}
				lines[i].SetPosition(lineAttributes.lineSegments - 1, position);
			}
		}

		private void DampWave()
		{
			float num = radius / (float)(numLines - 1);
			float num2 = 360f / (float)lineAttributes.lineSegments;
			float[] audioSamples = AudioSampler.instance.GetAudioSamples(audioSource, lineAttributes.lineSegments, absoluteVal: true);
			for (int i = 0; i < numLines; i++)
			{
				float num3 = 0f;
				float num4 = num * (float)i;
				UnityEngine.Vector3 position = UnityEngine.Vector3.zero;
				float num5 = 1f - (float)i / (float)(numLines - 1);
				for (int j = 0; j < lineAttributes.lineSegments - 1; j++)
				{
					float f = (float)Math.PI / 180f * num3;
					float num6 = Mathf.Cos(f) * num4;
					float num7 = audioSamples[j] * maxHeight * num5;
					float num8 = Mathf.Sin(f) * num4;
					UnityEngine.Vector3 vector = base.transform.position + base.transform.right * num6 + base.transform.up * num7 + base.transform.forward * num8;
					lines[i].SetPosition(j, vector);
					num3 += num2;
					if (j == 0)
					{
						position = vector;
					}
				}
				lines[i].SetPosition(lineAttributes.lineSegments - 1, position);
			}
		}

		private void Bounce()
		{
			float num = radius / (float)(numLines - 1);
			float num2 = 360f / (float)(lineAttributes.lineSegments - 1);
			for (int i = 0; i < numLines; i++)
			{
				float num3 = 0f;
				float num4 = num * (float)i;
				float num5 = AudioSampler.instance.GetAudioSamples(audioSource, numLines, absoluteVal: true)[i] * maxHeight;
				for (int j = 0; j < lineAttributes.lineSegments; j++)
				{
					float f = (float)Math.PI / 180f * num3;
					float num6 = Mathf.Cos(f) * num4;
					float num7 = Mathf.Sin(f) * num4;
					UnityEngine.Vector3 position = base.transform.position + base.transform.right * num6 + base.transform.up * num5 + base.transform.forward * num7;
					lines[i].SetPosition(j, position);
					num3 += num2;
				}
			}
		}

		private void OnDrawGizmos()
		{
			if (gizmos)
			{
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(base.transform.position, 1f);
			}
		}

		private void CreatePad()
		{
			float num = radius / (float)(numLines - 1);
			float num2 = 360f / (float)(lineAttributes.lineSegments - 1);
			for (int i = 0; i < numLines; i++)
			{
				float num3 = 0f;
				float num4 = num * (float)i;
				for (int j = 0; j < lineAttributes.lineSegments; j++)
				{
					float f = (float)Math.PI / 180f * num3;
					float num5 = Mathf.Cos(f) * num4;
					float num6 = Mathf.Sin(f) * num4;
					UnityEngine.Vector3 position = base.transform.position + base.transform.right * num5 + base.transform.forward * num6;
					lines[i].SetPosition(j, position);
					num3 += num2;
				}
			}
		}

		private LineRenderer NewLine(Color c)
		{
			GameObject obj = new GameObject();
			obj.transform.position = base.transform.position;
			obj.transform.rotation = base.transform.rotation;
			obj.hideFlags = HideFlags.HideInHierarchy;
			LineRenderer lineRenderer = obj.AddComponent<LineRenderer>();
			if (lineAttributes.lineMat == null)
			{
				lineRenderer.material = new Material(Shader.Find("Particles/Additive"));
			}
			else
			{
				lineRenderer.material = lineAttributes.lineMat;
			}
			lineRenderer.SetColors(c, c);
			lineRenderer.SetWidth(lineAttributes.startWidth, lineAttributes.endWidth);
			lineRenderer.SetVertexCount(lineAttributes.lineSegments);
			return lineRenderer;
		}
	}
	[RequireComponent(typeof(RectTransform))]
	public class PanelWaveform : MonoBehaviour
	{
		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public Sprite sprite;

		public int numColumns = 10;

		public int numRows = 10;

		public int spacingX;

		public int spacingY;

		public Color bottomColor = Color.white;

		public Color topColor = Color.white;

		public int updateRate = 1;

		private int updateCounter;

		private List<GameObject> cells = new List<GameObject>();

		private Gradient colorGradient;

		private float widthPerImage;

		private float heightPerImage;

		private int lastCol;

		private int lastRow;

		private void Awake()
		{
			RectTransform component = GetComponent<RectTransform>();
			component.anchorMin = new UnityEngine.Vector2(0f, 0f);
			component.anchorMax = new UnityEngine.Vector2(1f, 1f);
			component.anchoredPosition = new UnityEngine.Vector2(1f, 1f);
			colorGradient = GetColorGradient(bottomColor, topColor);
		}

		private void Start()
		{
			CreateImages();
			SetWidthAndHeight();
		}

		private void FixedUpdate()
		{
			if (updateCounter >= updateRate)
			{
				DrawWaveform();
				updateCounter = 0;
			}
			if (lastCol != numColumns || lastRow != numRows)
			{
				Reset();
			}
			lastCol = numColumns;
			lastRow = numRows;
			updateCounter++;
		}

		public void Reset()
		{
			DestroyCells();
			CreateImages();
			SetWidthAndHeight();
		}

		private void DrawWaveform()
		{
			float[] array = ((frequencyRange != FrequencyRange.Decibal) ? AudioSampler.instance.GetFrequencyData(audioSource, frequencyRange, numColumns, abs: true) : AudioSampler.instance.GetAudioSamples(audioSource, numColumns, absoluteVal: true));
			int num = 0;
			for (int i = 0; i < numRows; i++)
			{
				for (int j = 0; j < numColumns; j++)
				{
					float num2 = Mathf.Abs(array[j]) * sensitivity;
					float num3 = (float)i / (float)numRows;
					GameObject gameObject = cells[num];
					if (num3 <= num2)
					{
						gameObject.SetActive(value: true);
					}
					else
					{
						gameObject.SetActive(value: false);
					}
					num++;
				}
			}
		}

		private void SetWidthAndHeight()
		{
			widthPerImage = GetComponent<RectTransform>().rect.width / (float)numColumns;
			heightPerImage = GetComponent<RectTransform>().rect.height / (float)numRows;
			if ((bool)base.transform.parent.GetComponent<VerticalLayoutGroup>())
			{
				heightPerImage /= base.transform.parent.childCount;
			}
			if ((bool)base.transform.parent.GetComponent<HorizontalLayoutGroup>())
			{
				widthPerImage /= base.transform.parent.childCount;
			}
			if ((bool)base.transform.parent.GetComponent<GridLayoutGroup>())
			{
				GridLayoutGroup component = base.transform.parent.GetComponent<GridLayoutGroup>();
				widthPerImage = component.cellSize.x / (float)numColumns;
				heightPerImage = component.cellSize.y / (float)numRows;
			}
		}

		private void CreateImages()
		{
			cells = new List<GameObject>();
			for (int i = 0; i < numRows; i++)
			{
				for (int j = 0; j < numColumns; j++)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = base.transform.position;
					gameObject.transform.rotation = base.transform.rotation;
					gameObject.SetActive(value: true);
					gameObject.name = "Image_" + i + "x" + j;
					gameObject.transform.SetParent(base.transform);
					Image image = gameObject.AddComponent<Image>();
					image.sprite = sprite;
					image.rectTransform.pivot = new UnityEngine.Vector2(0f, 0f);
					image.rectTransform.anchorMin = new UnityEngine.Vector2(0f, 0f);
					image.rectTransform.anchorMax = new UnityEngine.Vector2(0f, 0f);
					image.rectTransform.localScale = UnityEngine.Vector3.one;
					image.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, widthPerImage - (float)(spacingX * 2));
					image.rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, heightPerImage - (float)(spacingY * 2));
					float x = (float)j * widthPerImage;
					float y = (float)i * heightPerImage;
					image.rectTransform.anchoredPosition = new UnityEngine.Vector3(x, y, 0f);
					image.color = colorGradient.Evaluate((float)i / (float)numRows);
					cells.Add(gameObject);
				}
			}
		}

		public static Gradient GetColorGradient(Color startColor, Color endColor)
		{
			Gradient gradient = new Gradient();
			GradientColorKey[] array = new GradientColorKey[2];
			array[0].color = startColor;
			array[0].time = 0f;
			array[1].color = endColor;
			array[1].time = 1f;
			GradientAlphaKey[] array2 = new GradientAlphaKey[2];
			array2[0].alpha = startColor.a;
			array2[0].time = 0f;
			array2[1].alpha = endColor.a;
			array2[1].time = 1f;
			gradient.SetKeys(array, array2);
			return gradient;
		}

		private void DestroyCells()
		{
			foreach (GameObject cell in cells)
			{
				cell.SetActive(value: false);
			}
		}
	}
	public class SphereWaveform : MonoBehaviour
	{
		public enum RotationType
		{
			Uniform,
			Rand,
			Cross
		}

		public int audioSource;

		public FrequencyRange frequencyRange = FrequencyRange.Decibal;

		public float sensitivity = 2f;

		public List<GameObject> objects;

		public float rotationSpeed = 10f;

		public UnityEngine.Vector3 rotationAxis = UnityEngine.Vector3.up;

		public float radius = 10f;

		public float lerpSpeed = 1f;

		public bool useWaveform = true;

		public RotationType rotationType;

		private float rotSpeed;

		private float sign = 1f;

		private float startRadius;

		private List<UnityEngine.Vector3> axes;

		private void Start()
		{
			if (rotationAxis == UnityEngine.Vector3.zero)
			{
				UnityEngine.Debug.LogWarning("WARNING: rotation axis set to 0 on " + base.gameObject.name + " SphereWaveform.cs");
			}
			ObjectSphere.PlaceObjectsAroundSphere(objects, base.transform.position, radius);
			startRadius = radius;
			InitializeAxes();
			rotSpeed = rotationSpeed;
		}

		private void Update()
		{
			Rotate();
			if (useWaveform)
			{
				Waveform();
			}
			PositionObjects();
		}

		private void InitializeAxes()
		{
			axes = new List<UnityEngine.Vector3>();
			switch (rotationType)
			{
			case RotationType.Rand:
			{
				foreach (GameObject @object in objects)
				{
					_ = @object;
					axes.Add(UnityEngine.Random.onUnitSphere);
				}
				break;
			}
			case RotationType.Cross:
			{
				foreach (GameObject object2 in objects)
				{
					UnityEngine.Vector3 item = UnityEngine.Vector3.Cross((object2.transform.position - base.transform.position).normalized, rotationAxis);
					axes.Add(item);
				}
				break;
			}
			}
		}

		private void Rotate()
		{
			switch (rotationType)
			{
			case RotationType.Uniform:
			{
				UnityEngine.Vector3 axis = base.transform.TransformDirection(rotationAxis);
				base.transform.RotateAround(base.transform.position, axis, rotationSpeed * Time.smoothDeltaTime);
				break;
			}
			case RotationType.Rand:
			case RotationType.Cross:
			{
				float angle = Time.smoothDeltaTime * rotationSpeed;
				for (int i = 0; i < objects.Count; i++)
				{
					objects[i].transform.RotateAround(base.transform.position, axes[i], angle);
				}
				break;
			}
			}
		}

		public void Boost(float multiplier)
		{
			Invoke("ResetSpeed", 0.1f);
			rotationSpeed *= multiplier;
		}

		private void ResetSpeed()
		{
			rotationSpeed = rotSpeed;
		}

		public void Bump(bool switchSign)
		{
			float num = ((frequencyRange != FrequencyRange.Decibal) ? (AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange) * sensitivity) : (AudioSampler.instance.GetRMS(audioSource) * sensitivity));
			if (switchSign)
			{
				sign = 0f - sign;
			}
			radius = startRadius + num * sign;
		}

		private void Waveform()
		{
			float num = ((frequencyRange != FrequencyRange.Decibal) ? (AudioSampler.instance.GetFrequencyVol(audioSource, frequencyRange) * sensitivity) : (AudioSampler.instance.GetRMS(audioSource) * sensitivity));
			radius = startRadius + num;
		}

		private void PositionObjects()
		{
			foreach (GameObject @object in objects)
			{
				UnityEngine.Vector3 normalized = (@object.transform.position - base.transform.position).normalized;
				UnityEngine.Vector3 b = base.transform.position + normalized * radius;
				@object.transform.position = UnityEngine.Vector3.Lerp(@object.transform.position, b, Time.smoothDeltaTime * lerpSpeed);
			}
		}
	}
	public class CameraCircle : MonoBehaviour
	{
		public Transform target;

		public float rotationSpeed;

		public UnityEngine.Vector3 rotationAxis;

		private void Start()
		{
		}

		private void Update()
		{
			base.transform.RotateAround(target.transform.position, rotationAxis, rotationSpeed * Time.smoothDeltaTime);
			base.transform.LookAt(target);
		}
	}
	public class CameraMovement : MonoBehaviour
	{
		public float speed;

		public float lerpSpeed;

		private void Update()
		{
			UnityEngine.Vector3 vector = base.transform.right * speed;
			base.transform.position = UnityEngine.Vector3.Lerp(base.transform.position, base.transform.position + vector, lerpSpeed * Time.smoothDeltaTime);
		}
	}
	public class ObjectCircle : MonoBehaviour
	{
		public List<GameObject> objects;

		public float radius;

		private float angle;

		private void Awake()
		{
			PositionObjects();
		}

		private void PositionObjects()
		{
			foreach (GameObject @object in objects)
			{
				@object.transform.position = base.transform.position;
				@object.transform.rotation = base.transform.rotation;
			}
			angle = 0f;
			float num = 360f / (float)objects.Count;
			for (int i = 0; i < objects.Count; i++)
			{
				float f = angle * ((float)Math.PI / 180f);
				float num2 = Mathf.Cos(f) * radius;
				float num3 = Mathf.Sin(f) * radius;
				UnityEngine.Vector3 position = base.transform.position + base.transform.right * num2 + base.transform.up * num3;
				objects[i].transform.position = position;
				objects[i].transform.RotateAround(objects[i].transform.position, base.transform.forward, angle - 90f);
				angle += num;
			}
		}
	}
	public class ObjectSphere : MonoBehaviour
	{
		public List<GameObject> objectsToPlace;

		public float radius = 3f;

		private void Awake()
		{
			PlaceObjectsAroundSphere(objectsToPlace, base.transform.position, radius);
		}

		public static void PlaceObjectsAroundSphere(List<GameObject> objects, UnityEngine.Vector3 origin, float radius)
		{
			UnityEngine.Vector3[] pointsOnSphere = GetPointsOnSphere(objects.Count);
			for (int i = 0; i < objects.Count; i++)
			{
				UnityEngine.Vector3 vector = pointsOnSphere[i];
				UnityEngine.Vector3 vector2 = origin + vector.normalized * radius;
				UnityEngine.Vector3 vector3 = vector2 - origin;
				objects[i].transform.position = vector2;
				objects[i].transform.LookAt(vector2 + vector3);
			}
		}

		public static UnityEngine.Vector3[] GetPointsOnSphere(int numPoints)
		{
			UnityEngine.Vector3[] array = new UnityEngine.Vector3[numPoints];
			float num = (float)Math.PI * (3f - Mathf.Sqrt(5f));
			float num2 = 2f / (float)numPoints;
			for (int i = 0; i < numPoints; i++)
			{
				float num3 = (float)i * num2 - 1f + num2 / 2f;
				float num4 = Mathf.Sqrt(1f - num3 * num3);
				float f = (float)i * num;
				array[i] = new UnityEngine.Vector3(Mathf.Cos(f) * num4, num3, Mathf.Sin(f) * num4);
			}
			return array;
		}
	}
	public class ParticleController : MonoBehaviour
	{
		public List<ParticleSystem> particleSystems;

		public int updateRate;

		private int updateCounter;

		private void FixedUpdate()
		{
			updateCounter++;
			if (updateCounter <= updateRate)
			{
				return;
			}
			foreach (ParticleSystem particleSystem in particleSystems)
			{
				particleSystem.Play();
			}
			updateCounter = 0;
		}
	}
	public class Rotate : MonoBehaviour
	{
		public float speed;

		private void FixedUpdate()
		{
			base.transform.RotateAround(base.transform.position, base.transform.up, speed * Time.deltaTime);
		}
	}
}
namespace SciFiArsenal
{
	public class SciFiButtonScript : MonoBehaviour
	{
		public GameObject Button;

		private Text MyButtonText;

		private string projectileParticleName;

		private SciFiFireProjectile effectScript;

		private SciFiProjectileScript projectileScript;

		public float buttonsX;

		public float buttonsY;

		public float buttonsSizeX;

		public float buttonsSizeY;

		public float buttonsDistance;

		private void Start()
		{
			effectScript = GameObject.Find("SciFiFireProjectile").GetComponent<SciFiFireProjectile>();
			getProjectileNames();
			MyButtonText = Button.transform.Find("Text").GetComponent<Text>();
			MyButtonText.text = projectileParticleName;
		}

		private void Update()
		{
			MyButtonText.text = projectileParticleName;
		}

		public void getProjectileNames()
		{
			projectileScript = effectScript.projectiles[effectScript.currentProjectile].GetComponent<SciFiProjectileScript>();
			projectileParticleName = projectileScript.projectileParticle.name;
		}

		public bool overButton()
		{
			Rect rect = new Rect(buttonsX, buttonsY, buttonsSizeX, buttonsSizeY);
			Rect rect2 = new Rect(buttonsX + buttonsDistance, buttonsY, buttonsSizeX, buttonsSizeY);
			if (rect.Contains(new UnityEngine.Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)) || rect2.Contains(new UnityEngine.Vector2(Input.mousePosition.x, (float)Screen.height - Input.mousePosition.y)))
			{
				return true;
			}
			return false;
		}
	}
	public class SciFiDragMouseOrbit : MonoBehaviour
	{
		public Transform target;

		public float distance = 5f;

		public float xSpeed = 120f;

		public float ySpeed = 120f;

		public float yMinLimit = -20f;

		public float yMaxLimit = 80f;

		public float distanceMin = 0.5f;

		public float distanceMax = 15f;

		public float smoothTime = 2f;

		private float rotationYAxis;

		private float rotationXAxis;

		private float velocityX;

		private float velocityY;

		private void Start()
		{
			UnityEngine.Vector3 eulerAngles = base.transform.eulerAngles;
			rotationYAxis = eulerAngles.y;
			rotationXAxis = eulerAngles.x;
			if ((bool)GetComponent<Rigidbody>())
			{
				GetComponent<Rigidbody>().freezeRotation = true;
			}
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				if (Input.GetMouseButton(1))
				{
					velocityX += xSpeed * Input.GetAxis("Mouse X") * distance * 0.02f;
					velocityY += ySpeed * Input.GetAxis("Mouse Y") * 0.02f;
				}
				rotationYAxis += velocityX;
				rotationXAxis -= velocityY;
				rotationXAxis = ClampAngle(rotationXAxis, yMinLimit, yMaxLimit);
				UnityEngine.Quaternion quaternion = UnityEngine.Quaternion.Euler(rotationXAxis, rotationYAxis, 0f);
				distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
				if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
				{
					distance -= hitInfo.distance;
				}
				UnityEngine.Vector3 vector = new UnityEngine.Vector3(0f, 0f, 0f - distance);
				UnityEngine.Vector3 position = quaternion * vector + target.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
				velocityX = Mathf.Lerp(velocityX, 0f, Time.deltaTime * smoothTime);
				velocityY = Mathf.Lerp(velocityY, 0f, Time.deltaTime * smoothTime);
			}
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class SciFiFireProjectile : MonoBehaviour
	{
		private RaycastHit hit;

		public GameObject[] projectiles;

		public Transform spawnPosition;

		[HideInInspector]
		public int currentProjectile;

		public float speed = 1000f;

		private SciFiButtonScript selectedProjectileButton;

		private void Start()
		{
			selectedProjectileButton = GameObject.Find("Button").GetComponent<SciFiButtonScript>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				nextEffect();
				selectedProjectileButton.getProjectileNames();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				nextEffect();
				selectedProjectileButton.getProjectileNames();
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				previousEffect();
				selectedProjectileButton.getProjectileNames();
			}
			else if (Input.GetKeyDown(KeyCode.LeftArrow))
			{
				previousEffect();
				selectedProjectileButton.getProjectileNames();
			}
			if (Input.GetKeyDown(KeyCode.Mouse0) && !selectedProjectileButton.overButton() && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out hit, 100f))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(projectiles[currentProjectile], spawnPosition.position, UnityEngine.Quaternion.identity);
				gameObject.transform.LookAt(hit.point);
				gameObject.GetComponent<Rigidbody>().AddForce(gameObject.transform.forward * speed);
				gameObject.GetComponent<SciFiProjectileScript>().impactNormal = hit.normal;
			}
			UnityEngine.Debug.DrawRay(Camera.main.ScreenPointToRay(Input.mousePosition).origin, Camera.main.ScreenPointToRay(Input.mousePosition).direction * 100f, Color.yellow);
		}

		public void nextEffect()
		{
			if (currentProjectile < projectiles.Length - 1)
			{
				currentProjectile++;
			}
			else
			{
				currentProjectile = 0;
			}
		}

		public void previousEffect()
		{
			if (currentProjectile > 0)
			{
				currentProjectile--;
			}
			else
			{
				currentProjectile = projectiles.Length - 1;
			}
		}

		public void AdjustSpeed(float newSpeed)
		{
			speed = newSpeed;
		}
	}
	public class SciFiLoadSceneOnClick : MonoBehaviour
	{
		public void LoadSceneSciFiProjectiles()
		{
			SceneManager.LoadScene("scifi_projectiles");
		}

		public void LoadSceneSciFiBeamup()
		{
			SceneManager.LoadScene("scifi_beamup");
		}

		public void LoadSceneSciFiBuff()
		{
			SceneManager.LoadScene("scifi_buff");
		}

		public void LoadSceneSciFiFlamethrowers2()
		{
			SceneManager.LoadScene("scifi_flamethrowers");
		}

		public void LoadSceneSciFiQuestZone()
		{
			SceneManager.LoadScene("scifi_hexagonzone");
		}

		public void LoadSceneSciFiLightjump()
		{
			SceneManager.LoadScene("scifi_lightjump");
		}

		public void LoadSceneSciFiLoot()
		{
			SceneManager.LoadScene("scifi_loot");
		}

		public void LoadSceneSciFiBeams()
		{
			SceneManager.LoadScene("scifi_beams");
		}

		public void LoadSceneSciFiPortals()
		{
			SceneManager.LoadScene("scifi_portals");
		}

		public void LoadSceneSciFiRegenerate()
		{
			SceneManager.LoadScene("scifi_regenerate");
		}

		public void LoadSceneSciFiShields()
		{
			SceneManager.LoadScene("scifi_shields");
		}

		public void LoadSceneSciFiSwirlyAura()
		{
			SceneManager.LoadScene("scifi_swirlyaura");
		}

		public void LoadSceneSciFiWarpgates()
		{
			SceneManager.LoadScene("scifi_warpgates");
		}

		public void LoadSceneSciFiJetflame()
		{
			SceneManager.LoadScene("scifi_jetflame");
		}

		public void LoadSceneSciFiUltimateNova()
		{
			SceneManager.LoadScene("scifi_ultimatenova");
		}

		public void LoadSceneSciFiFire()
		{
			SceneManager.LoadScene("scifi_fire");
		}
	}
	public class SciFiLoadSceneOnClick2 : MonoBehaviour
	{
		public void LoadSceneSciFiUpdate1()
		{
			SceneManager.LoadScene("update_scifi_1");
		}

		public void LoadSceneSciFiUpdate2()
		{
			SceneManager.LoadScene("update_scifi_2");
		}

		public void LoadSceneSciFiUpdate3()
		{
			SceneManager.LoadScene("update_scifi_3");
		}

		public void LoadSceneSciFiUpdate4()
		{
			SceneManager.LoadScene("update_scifi_4");
		}

		public void LoadSceneSciFiUpdate5()
		{
			SceneManager.LoadScene("update_scifi_5");
		}

		public void LoadSceneSciFiUpdate6()
		{
			SceneManager.LoadScene("update_scifi_6");
		}

		public void LoadSceneSciFiUpdate7()
		{
			SceneManager.LoadScene("update_scifi_7");
		}
	}
	public class SciFiLoopScript : MonoBehaviour
	{
		public GameObject chosenEffect;

		public float loopTimeLimit = 2f;

		private void Start()
		{
			PlayEffect();
		}

		public void PlayEffect()
		{
			StartCoroutine("EffectLoop");
		}

		private IEnumerator EffectLoop()
		{
			GameObject effectPlayer = UnityEngine.Object.Instantiate(chosenEffect, base.transform.position, base.transform.rotation);
			yield return new WaitForSeconds(loopTimeLimit);
			UnityEngine.Object.Destroy(effectPlayer);
			PlayEffect();
		}
	}
	public class SciFiProjectileScript : MonoBehaviour
	{
		public GameObject impactParticle;

		public GameObject projectileParticle;

		public GameObject muzzleParticle;

		public GameObject[] trailParticles;

		[HideInInspector]
		public UnityEngine.Vector3 impactNormal;

		private bool hasCollided;

		private void Start()
		{
			projectileParticle = UnityEngine.Object.Instantiate(projectileParticle, base.transform.position, base.transform.rotation);
			projectileParticle.transform.parent = base.transform;
			if ((bool)muzzleParticle)
			{
				muzzleParticle = UnityEngine.Object.Instantiate(muzzleParticle, base.transform.position, base.transform.rotation);
				muzzleParticle.transform.rotation = base.transform.rotation * UnityEngine.Quaternion.Euler(180f, 0f, 0f);
				UnityEngine.Object.Destroy(muzzleParticle, 1.5f);
			}
		}

		private void OnCollisionEnter(Collision hit)
		{
			if (hasCollided)
			{
				return;
			}
			hasCollided = true;
			impactParticle = UnityEngine.Object.Instantiate(impactParticle, base.transform.position, UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3.up, impactNormal));
			if (hit.gameObject.tag == "Destructible")
			{
				UnityEngine.Object.Destroy(hit.gameObject);
			}
			GameObject[] array = trailParticles;
			foreach (GameObject gameObject in array)
			{
				GameObject obj = base.transform.Find(projectileParticle.name + "/" + gameObject.name).gameObject;
				obj.transform.parent = null;
				UnityEngine.Object.Destroy(obj, 3f);
			}
			UnityEngine.Object.Destroy(projectileParticle, 3f);
			UnityEngine.Object.Destroy(impactParticle, 5f);
			UnityEngine.Object.Destroy(base.gameObject);
			ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
			for (int j = 1; j < componentsInChildren.Length; j++)
			{
				ParticleSystem particleSystem = componentsInChildren[j];
				if (particleSystem.gameObject.name.Contains("Trail"))
				{
					particleSystem.transform.SetParent(null);
					UnityEngine.Object.Destroy(particleSystem.gameObject, 2f);
				}
			}
		}
	}
	public class SciFiLightFade : MonoBehaviour
	{
		[Header("Seconds to dim the light")]
		public float life = 0.2f;

		public bool killAfterLife = true;

		private Light li;

		private float initIntensity;

		private void Start()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li = base.gameObject.GetComponent<Light>();
				initIntensity = li.intensity;
			}
			else
			{
				MonoBehaviour.print("No light object found on " + base.gameObject.name);
			}
		}

		private void Update()
		{
			if ((bool)base.gameObject.GetComponent<Light>())
			{
				li.intensity -= initIntensity * (Time.deltaTime / life);
				if (killAfterLife && li.intensity <= 0f)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}
	}
	public class SciFiRotation : MonoBehaviour
	{
		public enum spaceEnum
		{
			Local,
			World
		}

		[Header("Rotate axises by degrees per second")]
		public UnityEngine.Vector3 rotateVector = UnityEngine.Vector3.zero;

		public spaceEnum rotateSpace;

		private void Start()
		{
		}

		private void Update()
		{
			if (rotateSpace == spaceEnum.Local)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime);
			}
			if (rotateSpace == spaceEnum.World)
			{
				base.transform.Rotate(rotateVector * Time.deltaTime, Space.World);
			}
		}
	}
}
