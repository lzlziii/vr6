using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using AOT;
using BoundarySystem_Ext;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using DigitalOpus.MB.Core;
using ExitGames.Client.Photon;
using ExitGames.SportShooting;
using Framework;
using InfinityEngine.Attributes;
using InfinityEngine.DesignPatterns;
using InfinityEngine.Localization;
using InfinityEngine.Utils;
using LitJson;
using Models;
using Photon.Pun;
using Photon.Realtime;
using Photon.Voice.PUN;
using Proyecto26;
using Proyecto26.Common;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using RSG;
using RSG.Exceptions;
using RSG.Promises;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Scripting;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor")]
[assembly: AssemblyVersion("0.0.0.0")]
public class MainScript : MonoBehaviour
{
	private readonly string basePath = "https://jsonplaceholder.typicode.com";

	private RequestHelper currentRequest;

	private void LogMessage(string title, string message)
	{
		UnityEngine.Debug.Log(message);
	}

	public void Get()
	{
		RestClient.DefaultRequestHeaders["Authorization"] = "Bearer ...";
		RequestHelper requestOptions = null;
		RestClient.GetArray<Post>(basePath + "/posts").Then(delegate(Post[] res)
		{
			LogMessage("Posts", JsonHelper.ArrayToJsonString(res, prettyPrint: true));
			return RestClient.GetArray<Todo>(basePath + "/todos");
		}).Then(delegate(Todo[] res)
		{
			LogMessage("Todos", JsonHelper.ArrayToJsonString(res, prettyPrint: true));
			return RestClient.GetArray<User>(basePath + "/users");
		})
			.Then(delegate(User[] res)
			{
				LogMessage("Users", JsonHelper.ArrayToJsonString(res, prettyPrint: true));
				requestOptions = new RequestHelper
				{
					Uri = basePath + "/photos",
					Headers = new Dictionary<string, string> { { "Authorization", "Other token..." } },
					EnableDebug = true
				};
				return RestClient.GetArray<Photo>(requestOptions);
			})
			.Then(delegate
			{
				LogMessage("Header", requestOptions.GetHeader("Authorization"));
				RestClient.CleanDefaultHeaders();
			})
			.Catch(delegate(Exception err)
			{
				LogMessage("Error", err.Message);
			});
	}

	public void Post()
	{
		currentRequest = new RequestHelper
		{
			Uri = basePath + "/posts",
			Body = new Post
			{
				title = "foo",
				body = "bar",
				userId = 1
			}
		};
		RestClient.Post<Post>(currentRequest).Then(delegate(Post res)
		{
			LogMessage("Success", JsonUtility.ToJson(res, prettyPrint: true));
		}).Catch(delegate(Exception err)
		{
			LogMessage("Error", err.Message);
		});
	}

	public void Put()
	{
		currentRequest = new RequestHelper
		{
			Uri = basePath + "/posts/1",
			Body = new Post
			{
				title = "foo",
				body = "bar",
				userId = 1
			},
			Retries = 5,
			RetrySecondsDelay = 1f,
			RetryCallback = delegate(RequestException err, int retries)
			{
				UnityEngine.Debug.Log($"Retry #{retries} Status {err.StatusCode}\nError: {err}");
			}
		};
		RestClient.Put(currentRequest, delegate(RequestException err, ResponseHelper res, Post body)
		{
			if (err != null)
			{
				LogMessage("Error", err.Message);
			}
			else
			{
				LogMessage("Success", JsonUtility.ToJson(body, prettyPrint: true));
			}
		});
	}

	public void Delete()
	{
		RestClient.Delete(basePath + "/posts/1", delegate(RequestException err, ResponseHelper res)
		{
			if (err != null)
			{
				LogMessage("Error", err.Message);
			}
			else
			{
				LogMessage("Success", "Status: " + res.StatusCode);
			}
		});
	}

	public void AbortRequest()
	{
		if (currentRequest != null)
		{
			currentRequest.Abort();
			currentRequest = null;
		}
	}

	public void DownloadFile()
	{
		string text = "https://raw.githubusercontent.com/IonDen/ion.sound/master/sounds/bell_ring.ogg";
		AudioType audioType = AudioType.OGGVORBIS;
		RestClient.Get(new RequestHelper
		{
			Uri = text,
			DownloadHandler = new DownloadHandlerAudioClip(text, audioType)
		}).Then(delegate(ResponseHelper res)
		{
			AudioSource component = GetComponent<AudioSource>();
			component.clip = ((DownloadHandlerAudioClip)res.Request.downloadHandler).audioClip;
			component.Play();
		}).Catch(delegate(Exception err)
		{
			LogMessage("Error", err.Message);
		});
	}
}
public class EditorSimulator : MonoBehaviour
{
	[Serializable]
	public class MouseEvent : UnityEvent
	{
	}

	public MouseEvent leftMouseDown;

	public MouseEvent rightMouseDown;

	private RaycastHit hit;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			leftMouseDown.Invoke();
			Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			if (Physics.Raycast(ray, out var hitInfo, 100f, 1 << LayerMask.NameToLayer("UI")))
			{
				hitInfo.collider.gameObject.GetComponent<Button>()?.onClick.Invoke();
			}
			if (Physics.Raycast(ray, out hitInfo, 100f, 1 << LayerMask.NameToLayer("Button")))
			{
				InteractableButton component = hitInfo.collider.gameObject.GetComponent<InteractableButton>();
				if (component.enabled)
				{
					component.onButtonDown?.Invoke();
				}
			}
			if (Physics.Raycast(ray, out hitInfo, 100f, 1 << LayerMask.NameToLayer("Distructable")))
			{
				GameController.Instance.RemoveBlock(hitInfo.collider.gameObject);
			}
		}
		if (Input.GetMouseButtonDown(1))
		{
			rightMouseDown.Invoke();
			if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo2, 10f, 1 << LayerMask.NameToLayer("Distructable")))
			{
				GameController.Instance.RemoveBlock(hitInfo2.collider.gameObject);
			}
		}
	}
}
public class BakeTexturesAtRuntime : MonoBehaviour
{
	public GameObject target;

	private float elapsedTime;

	private MB3_TextureBaker.CreateAtlasesCoroutineResult result = new MB3_TextureBaker.CreateAtlasesCoroutineResult();

	private void OnGUI()
	{
		GUILayout.Label("Time to bake textures: " + elapsedTime);
		if (GUILayout.Button("Combine textures & build combined mesh all at once"))
		{
			MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
			MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
			component.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component.resultMaterial = new Material(Shader.Find("Diffuse"));
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			component.CreateAtlases();
			elapsedTime = Time.realtimeSinceStartup - realtimeSinceStartup;
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		if (GUILayout.Button("Combine textures & build combined mesh using coroutine"))
		{
			UnityEngine.Debug.Log("Starting to bake textures on frame " + Time.frameCount);
			MB3_TextureBaker component2 = target.GetComponent<MB3_TextureBaker>();
			component2.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component2.resultMaterial = new Material(Shader.Find("Diffuse"));
			component2.onBuiltAtlasesSuccess = OnBuiltAtlasesSuccess;
			StartCoroutine(component2.CreateAtlasesCoroutine(null, result));
		}
	}

	private void OnBuiltAtlasesSuccess()
	{
		UnityEngine.Debug.Log("Calling success callback. baking meshes");
		MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
		MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
		if (result.isFinished && result.success)
		{
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		UnityEngine.Debug.Log("Completed baking textures on frame " + Time.frameCount);
	}
}
public class MB_BatchPrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene is set up to create a combined material and meshes with adjusted UVs so \n objects can share a material and be batched by Unity's static/dynamic batching.\n This scene has added a BatchPrefabBaker component to a Mesh and Material Baker which \n  can bake many prefabs (each of which can have several renderers) in one click.\n The batching tool accepts prefab assets instead of scene objects. \n");
	}
}
public class MB_SwapShirts : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public Renderer[] clothingAndBodyPartsBareTorso;

	public Renderer[] clothingAndBodyPartsBareTorsoDamagedArm;

	public Renderer[] clothingAndBodyPartsHoodie;

	private void Start()
	{
		GameObject[] array = new GameObject[clothingAndBodyPartsBareTorso.Length];
		for (int i = 0; i < clothingAndBodyPartsBareTorso.Length; i++)
		{
			array[i] = clothingAndBodyPartsBareTorso[i].gameObject;
		}
		meshBaker.ClearMesh();
		meshBaker.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		meshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Wear Hoodie"))
		{
			ChangeOutfit(clothingAndBodyPartsHoodie);
		}
		if (GUILayout.Button("Bare Torso"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorso);
		}
		if (GUILayout.Button("Damaged Arm"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorsoDamagedArm);
		}
	}

	private void ChangeOutfit(Renderer[] outfit)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (GameObject item in meshBaker.meshCombiner.GetObjectsInCombined())
		{
			Renderer component = item.GetComponent<Renderer>();
			bool flag = false;
			for (int i = 0; i < outfit.Length; i++)
			{
				if (component == outfit[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(component.gameObject);
				UnityEngine.Debug.Log("Removing " + component.gameObject);
			}
		}
		List<GameObject> list2 = new List<GameObject>();
		for (int j = 0; j < outfit.Length; j++)
		{
			if (!meshBaker.meshCombiner.GetObjectsInCombined().Contains(outfit[j].gameObject))
			{
				list2.Add(outfit[j].gameObject);
				UnityEngine.Debug.Log("Adding " + outfit[j].gameObject);
			}
		}
		meshBaker.AddDeleteGameObjects(list2.ToArray(), list.ToArray(), disableRendererInSource: true);
		meshBaker.Apply();
	}
}
public class MB_PrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene creates a combined material and meshes with adjusted UVs so objects \n can share a material and be batched by Unity's static/dynamic batching.\n Output has been set to 'bakeMeshAssetsInPlace' on the Mesh Baker\n Position, Scale and Rotation will be baked into meshes so place them appropriately.\n Dynamic batching requires objects with uniform scale. You can fix non-uniform scale here\n After baking you need to duplicate your source prefab assets and replace the  \n meshes and materials with the generated ones.\n");
	}
}
public class MB_DynamicAddDeleteExample : MonoBehaviour
{
	public GameObject prefab;

	private List<GameObject> objsInCombined = new List<GameObject>();

	private MB3_MultiMeshBaker mbd;

	private GameObject[] objs;

	private float GaussianValue()
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			float num2 = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		num3 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		return num * num3;
	}

	private void Start()
	{
		mbd = GetComponentInChildren<MB3_MultiMeshBaker>();
		int num = 10;
		GameObject[] array = new GameObject[num * num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
				array[i * num + j] = gameObject.GetComponentInChildren<MeshRenderer>().gameObject;
				float num2 = UnityEngine.Random.Range(-4f, 4f);
				float num3 = UnityEngine.Random.Range(-4f, 4f);
				gameObject.transform.position = new Vector3(3f * (float)i + num2, 0f, 3f * (float)j + num3);
				float y = UnityEngine.Random.Range(0, 360);
				gameObject.transform.rotation = Quaternion.Euler(0f, y, 0f);
				Vector3 localScale = Vector3.one + Vector3.one * GaussianValue() * 0.15f;
				gameObject.transform.localScale = localScale;
				if ((i * num + j) % 3 == 0)
				{
					objsInCombined.Add(array[i * num + j]);
				}
			}
		}
		mbd.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		mbd.Apply();
		objs = objsInCombined.ToArray();
		StartCoroutine(largeNumber());
	}

	private IEnumerator largeNumber()
	{
		while (true)
		{
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(null, objs, disableRendererInSource: true);
			mbd.Apply();
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(objs, null, disableRendererInSource: true);
			mbd.Apply();
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically instantiates game objects. \nRepeatedly adds and removes some of them\n from the combined mesh.");
	}
}
public class MB_Example : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public GameObject[] objsToCombine;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToCombine, null, disableRendererInSource: true);
		meshbaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToCombine);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: false, uv2: false, uv3: false, uv4: false, colors: false);
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically updates the vertices, normals and tangents in combined mesh every frame.\nThis is similar to dynamic batching. It is not recommended to do this every frame.\nAlso consider baking the mesh renderer objects into a skinned mesh renderer\nThe skinned mesh approach is faster for objects that need to move independently of each other every frame.");
	}
}
public class MB_ExampleMover : MonoBehaviour
{
	public int axis;

	private void Update()
	{
		Vector3 position = new Vector3(5f, 5f, 5f);
		position[axis] *= Mathf.Sin(Time.time);
		base.transform.position = position;
	}
}
public class MB_ExampleSkinnedMeshDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("Mesh Renderer objects have been baked into a skinned mesh. Each source object\n is still in the scene (with renderer disabled) and becomes a bone. Any scripts, animations,\n or physics that affect the invisible source objects will be visible in the\nSkinned Mesh. This approach is more efficient than either dynamic batching or updating every frame \n for many small objects that constantly and independently move. \n With this approach pay attention to the SkinnedMeshRenderer Bounds and Animation Culling\nsettings. You may need to write your own script to manage/update these or your object may vanish or stop animating.\n You can update the combined mesh at runtime as objects are added and deleted from the scene.");
	}
}
public class MB_SkinnedMeshSceneController : MonoBehaviour
{
	public GameObject swordPrefab;

	public GameObject hatPrefab;

	public GameObject glassesPrefab;

	public GameObject workerPrefab;

	public GameObject targetCharacter;

	public MB3_MeshBaker skinnedMeshBaker;

	private GameObject swordInstance;

	private GameObject glassesInstance;

	private GameObject hatInstance;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(workerPrefab);
		gameObject.transform.position = new Vector3(1.31f, 0.985f, -0.25f);
		Animation component = gameObject.GetComponent<Animation>();
		component.wrapMode = WrapMode.Loop;
		component.cullingType = AnimationCullingType.AlwaysAnimate;
		component.Play("run");
		GameObject[] gos = new GameObject[1] { gameObject.GetComponentInChildren<SkinnedMeshRenderer>().gameObject };
		skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		skinnedMeshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Add/Remove Sword"))
		{
			if (swordInstance == null)
			{
				Transform parent = SearchHierarchyForBone(targetCharacter.transform, "RightHandAttachPoint");
				swordInstance = UnityEngine.Object.Instantiate(swordPrefab);
				swordInstance.transform.parent = parent;
				swordInstance.transform.localPosition = Vector3.zero;
				swordInstance.transform.localRotation = Quaternion.identity;
				swordInstance.transform.localScale = Vector3.one;
				GameObject[] gos = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(swordInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(swordInstance);
				swordInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Hat"))
		{
			if (hatInstance == null)
			{
				Transform parent2 = SearchHierarchyForBone(targetCharacter.transform, "HeadAttachPoint");
				hatInstance = UnityEngine.Object.Instantiate(hatPrefab);
				hatInstance.transform.parent = parent2;
				hatInstance.transform.localPosition = Vector3.zero;
				hatInstance.transform.localRotation = Quaternion.identity;
				hatInstance.transform.localScale = Vector3.one;
				GameObject[] gos2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos2, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(hatInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs2, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(hatInstance);
				hatInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Glasses"))
		{
			if (glassesInstance == null)
			{
				Transform parent3 = SearchHierarchyForBone(targetCharacter.transform, "NoseAttachPoint");
				glassesInstance = UnityEngine.Object.Instantiate(glassesPrefab);
				glassesInstance.transform.parent = parent3;
				glassesInstance.transform.localPosition = Vector3.zero;
				glassesInstance.transform.localRotation = Quaternion.identity;
				glassesInstance.transform.localScale = Vector3.one;
				GameObject[] gos3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos3, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs3, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(glassesInstance);
				glassesInstance = null;
			}
		}
	}

	public Transform SearchHierarchyForBone(Transform current, string name)
	{
		if (current.name.Equals(name))
		{
			return current;
		}
		for (int i = 0; i < current.childCount; i++)
		{
			Transform transform = SearchHierarchyForBone(current.GetChild(i), name);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
public class MB2_TestShowHide : MonoBehaviour
{
	public MB3_MeshBaker mb;

	public GameObject[] objs;

	private void Update()
	{
		if (Time.frameCount == 100)
		{
			mb.ShowHide(null, objs);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should have disappeared");
		}
		if (Time.frameCount == 200)
		{
			mb.ShowHide(objs, null);
			mb.ApplyShowHide();
			UnityEngine.Debug.Log("should show");
		}
	}
}
public class MB2_TestUpdate : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public MB3_MultiMeshBaker multiMeshBaker;

	public GameObject[] objsToMove;

	public GameObject objWithChangingUVs;

	private Vector2[] uvs;

	private Mesh m;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		meshbaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		MeshFilter component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		meshbaker.Apply();
		multiMeshBaker.AddDeleteGameObjects(objsToMove, null, disableRendererInSource: true);
		multiMeshBaker.AddDeleteGameObjects(new GameObject[1] { objWithChangingUVs }, null, disableRendererInSource: true);
		component = objWithChangingUVs.GetComponent<MeshFilter>();
		m = component.sharedMesh;
		uvs = m.uv;
		multiMeshBaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		Vector2[] uv = m.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			uv[i] = Mathf.Sin(Time.time) * uvs[i];
		}
		m.uv = uv;
		meshbaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
		multiMeshBaker.UpdateGameObjects(objsToMove, recalcBounds: false);
		uv = m.uv;
		for (int j = 0; j < uv.Length; j++)
		{
			uv[j] = Mathf.Sin(Time.time) * uvs[j];
		}
		m.uv = uv;
		multiMeshBaker.UpdateGameObjects(new GameObject[1] { objWithChangingUVs }, recalcBounds: true, updateVertices: true, updateNormals: true, updateTangents: true, updateUV: true);
		multiMeshBaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: true, uv2: false, uv3: false, uv4: false, colors: false);
	}
}
public class MB3_TestAddingRemovingSkinnedMeshes : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public GameObject[] g;

	private void Start()
	{
		StartCoroutine(TestScript());
	}

	private IEnumerator TestScript()
	{
		UnityEngine.Debug.Log("Test 1 adding 0,1,2");
		GameObject[] gos = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 2 remove 1 and add 3,4,5");
		GameObject[] deleteGOs = new GameObject[1] { g[1] };
		gos = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove 0,2,5 and add 1");
		deleteGOs = new GameObject[3]
		{
			g[3],
			g[4],
			g[5]
		};
		gos = new GameObject[1] { g[1] };
		meshBaker.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 remove all remaining");
		deleteGOs = new GameObject[3]
		{
			g[0],
			g[1],
			g[2]
		};
		meshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(3f);
		UnityEngine.Debug.Log("Test 3 add all");
		meshBaker.AddDeleteGameObjects(g, null, disableRendererInSource: true);
		meshBaker.Apply();
		meshBaker.meshCombiner.CheckIntegrity();
		yield return new WaitForSeconds(1f);
		UnityEngine.Debug.Log("Done");
	}
}
public class MB3_TestBakeAllWithSameMaterial : MonoBehaviour
{
	public GameObject[] listOfObjsToCombineGood;

	public GameObject[] listOfObjsToCombineBad;

	private void Start()
	{
		testCombine();
	}

	private void testCombine()
	{
		MB3_MeshCombinerSingle mB3_MeshCombinerSingle = new MB3_MeshCombinerSingle();
		UnityEngine.Debug.Log("About to bake 1");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		mB3_MeshCombinerSingle.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 1");
		UnityEngine.Debug.Log("About to bake 2 should get error that one material doesn't match");
		mB3_MeshCombinerSingle.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MeshCombinerSingle.Apply();
		UnityEngine.Debug.Log("Did bake 2");
		UnityEngine.Debug.Log("Doing same with multi mesh combiner");
		MB3_MultiMeshCombiner mB3_MultiMeshCombiner = new MB3_MultiMeshCombiner();
		UnityEngine.Debug.Log("About to bake 3");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineGood, null);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.UpdateGameObjects(listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		mB3_MultiMeshCombiner.AddDeleteGameObjects(null, listOfObjsToCombineGood);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 3");
		UnityEngine.Debug.Log("About to bake 4  should get error that one material doesn't match");
		mB3_MultiMeshCombiner.AddDeleteGameObjects(listOfObjsToCombineBad, null);
		mB3_MultiMeshCombiner.Apply();
		UnityEngine.Debug.Log("Did bake 4");
	}
}
public class MB3_TestRenderTextureTestHarness : MonoBehaviour
{
	public Texture2D input;

	public bool doColor;

	public Color32 color;

	public Texture2D Create3x3Tex()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] array = new Color32[texture2D.width * texture2D.height];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = color;
		}
		texture2D.SetPixels32(array);
		texture2D.Apply();
		return texture2D;
	}

	public Texture2D Create3x3Clone()
	{
		Texture2D texture2D = new Texture2D(3, 3, TextureFormat.ARGB32, mipChain: false);
		Color32[] pixels = new Color32[9]
		{
			new Color32(54, 54, 201, byte.MaxValue),
			new Color32(128, 37, 218, byte.MaxValue),
			new Color32(201, 54, 201, byte.MaxValue),
			new Color32(37, 128, 218, byte.MaxValue),
			new Color32(128, 128, byte.MaxValue, byte.MaxValue),
			new Color32(218, 128, 218, byte.MaxValue),
			new Color32(54, 201, 201, byte.MaxValue),
			new Color32(128, 218, 218, byte.MaxValue),
			new Color32(201, 201, 201, byte.MaxValue)
		};
		texture2D.SetPixels32(pixels);
		texture2D.Apply();
		return texture2D;
	}

	public static void TestRender(Texture2D input, Texture2D output)
	{
		int num = 1;
		ShaderTextureProperty[] array = new ShaderTextureProperty[1]
		{
			new ShaderTextureProperty("_BumpMap", norm: false)
		};
		int width = input.width;
		int height = input.height;
		int padding = 0;
		Rect[] rects = new Rect[1]
		{
			new Rect(0f, 0f, 1f, 1f)
		};
		List<MB_TexSet> list = new List<MB_TexSet>();
		MB_TexSet item = new MB_TexSet(new MeshBakerMaterialTexture[1]
		{
			new MeshBakerMaterialTexture(input)
		}, Vector2.zero, Vector2.one, MB_TextureTilingTreatment.considerUVs);
		list.Add(item);
		GameObject obj = new GameObject("MBrenderAtlasesGO");
		MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = obj.AddComponent<MB3_AtlasPackerRenderTexture>();
		obj.AddComponent<Camera>();
		for (int i = 0; i < num; i++)
		{
			Texture2D texture2D = null;
			UnityEngine.Debug.Log("About to render " + array[i].name + " isNormal=" + array[i].isNormalMap);
			mB3_AtlasPackerRenderTexture.LOG_LEVEL = MB2_LogLevel.trace;
			mB3_AtlasPackerRenderTexture.width = width;
			mB3_AtlasPackerRenderTexture.height = height;
			mB3_AtlasPackerRenderTexture.padding = padding;
			mB3_AtlasPackerRenderTexture.rects = rects;
			mB3_AtlasPackerRenderTexture.textureSets = list;
			mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
			mB3_AtlasPackerRenderTexture.isNormalMap = array[i].isNormalMap;
			texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(null);
			UnityEngine.Debug.Log("Created atlas " + array[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
			UnityEngine.Debug.Log(string.Concat("Color ", texture2D.GetPixel(5, 5), " ", Color.red));
			byte[] bytes = texture2D.EncodeToPNG();
			File.WriteAllBytes(Application.dataPath + "/_Experiment/red.png", bytes);
		}
	}
}
public class MB3_KMeansClustering
{
	private class DataPoint
	{
		public Vector3 center;

		public GameObject gameObject;

		public int Cluster;

		public DataPoint(GameObject go)
		{
			gameObject = go;
			center = go.transform.position;
			if (go.GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("Object does not have a renderer " + go);
			}
		}
	}

	private List<DataPoint> _normalizedDataToCluster = new List<DataPoint>();

	private Vector3[] _clusters = new Vector3[0];

	private int _numberOfClusters;

	public MB3_KMeansClustering(List<GameObject> gos, int numClusters)
	{
		for (int i = 0; i < gos.Count; i++)
		{
			if (gos[i] != null)
			{
				DataPoint item = new DataPoint(gos[i]);
				_normalizedDataToCluster.Add(item);
			}
			else
			{
				UnityEngine.Debug.LogWarning($"Object {i} in list of objects to cluster was null.");
			}
		}
		if (numClusters <= 0)
		{
			UnityEngine.Debug.LogError("Number of clusters must be posititve.");
			numClusters = 1;
		}
		if (_normalizedDataToCluster.Count <= numClusters)
		{
			UnityEngine.Debug.LogError("There must be fewer clusters than objects to cluster");
			numClusters = _normalizedDataToCluster.Count - 1;
		}
		_numberOfClusters = numClusters;
		if (_numberOfClusters <= 0)
		{
			_numberOfClusters = 1;
		}
		_clusters = new Vector3[_numberOfClusters];
	}

	private void InitializeCentroids()
	{
		for (int i = 0; i < _numberOfClusters; i++)
		{
			_normalizedDataToCluster[i].Cluster = i;
		}
		for (int j = _numberOfClusters; j < _normalizedDataToCluster.Count; j++)
		{
			_normalizedDataToCluster[j].Cluster = UnityEngine.Random.Range(0, _numberOfClusters);
		}
	}

	private bool UpdateDataPointMeans(bool force)
	{
		if (AnyAreEmpty(_normalizedDataToCluster) && !force)
		{
			return false;
		}
		Vector3[] array = new Vector3[_numberOfClusters];
		int[] array2 = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			int cluster = _normalizedDataToCluster[i].Cluster;
			array[cluster] += _normalizedDataToCluster[i].center;
			array2[cluster]++;
		}
		for (int j = 0; j < _numberOfClusters; j++)
		{
			_clusters[j] = array[j] / array2[j];
		}
		return true;
	}

	private bool AnyAreEmpty(List<DataPoint> data)
	{
		int[] array = new int[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			array[_normalizedDataToCluster[i].Cluster]++;
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (array[j] == 0)
			{
				return true;
			}
		}
		return false;
	}

	private bool UpdateClusterMembership()
	{
		bool flag = false;
		float[] array = new float[_numberOfClusters];
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			for (int j = 0; j < _numberOfClusters; j++)
			{
				array[j] = ElucidanDistance(_normalizedDataToCluster[i], _clusters[j]);
			}
			int num = MinIndex(array);
			if (num != _normalizedDataToCluster[i].Cluster)
			{
				flag = true;
				_normalizedDataToCluster[i].Cluster = num;
			}
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	private float ElucidanDistance(DataPoint dataPoint, Vector3 mean)
	{
		return Vector3.Distance(dataPoint.center, mean);
	}

	private int MinIndex(float[] distances)
	{
		int result = 0;
		double num = distances[0];
		for (int i = 0; i < distances.Length; i++)
		{
			if ((double)distances[i] < num)
			{
				num = distances[i];
				result = i;
			}
		}
		return result;
	}

	public List<Renderer> GetCluster(int idx, out Vector3 mean, out float size)
	{
		if (idx < 0 || idx >= _numberOfClusters)
		{
			UnityEngine.Debug.LogError("idx is out of bounds");
			mean = Vector3.zero;
			size = 1f;
			return new List<Renderer>();
		}
		UpdateDataPointMeans(force: true);
		List<Renderer> list = new List<Renderer>();
		mean = _clusters[idx];
		float num = 0f;
		for (int i = 0; i < _normalizedDataToCluster.Count; i++)
		{
			if (_normalizedDataToCluster[i].Cluster == idx)
			{
				float num2 = Vector3.Distance(mean, _normalizedDataToCluster[i].center);
				if (num2 > num)
				{
					num = num2;
				}
				list.Add(_normalizedDataToCluster[i].gameObject.GetComponent<Renderer>());
			}
		}
		mean = _clusters[idx];
		size = num;
		return list;
	}

	public void Cluster()
	{
		bool flag = true;
		bool flag2 = true;
		InitializeCentroids();
		int num = _normalizedDataToCluster.Count * 1000;
		int num2 = 0;
		while (flag2 && flag && num2 < num)
		{
			num2++;
			flag2 = UpdateDataPointMeans(force: false);
			flag = UpdateClusterMembership();
		}
	}
}
public class MB_TextureCombinerRenderTexture
{
	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	private Material mat;

	private RenderTexture _destinationTexture;

	private Camera myCamera;

	private int _padding;

	private bool _isNormalMap;

	private bool _fixOutOfBoundsUVs;

	private bool _doRenderAtlas;

	private Rect[] rs;

	private List<MB_TexSet> textureSets;

	private int indexOfTexSetToRender;

	private ShaderTextureProperty _texPropertyName;

	private MB3_TextureCombinerNonTextureProperties _resultMaterialTextureBlender;

	private Texture2D targTex;

	public Texture2D DoRenderAtlas(GameObject gameObject, int width, int height, int padding, Rect[] rss, List<MB_TexSet> textureSetss, int indexOfTexSetToRenders, ShaderTextureProperty texPropertyname, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender, bool isNormalMap, bool fixOutOfBoundsUVs, bool considerNonTextureProperties, MB3_TextureCombiner texCombiner, MB2_LogLevel LOG_LEV)
	{
		LOG_LEVEL = LOG_LEV;
		textureSets = textureSetss;
		indexOfTexSetToRender = indexOfTexSetToRenders;
		_texPropertyName = texPropertyname;
		_padding = padding;
		_isNormalMap = isNormalMap;
		_fixOutOfBoundsUVs = fixOutOfBoundsUVs;
		_resultMaterialTextureBlender = resultMaterialTextureBlender;
		rs = rss;
		Shader shader = ((!_isNormalMap) ? Shader.Find("MeshBaker/AlbedoShader") : Shader.Find("MeshBaker/NormalMapShader"));
		if (shader == null)
		{
			UnityEngine.Debug.LogError("Could not find shader for RenderTexture. Try reimporting mesh baker");
			return null;
		}
		mat = new Material(shader);
		_destinationTexture = new RenderTexture(width, height, 24, RenderTextureFormat.ARGB32);
		_destinationTexture.filterMode = FilterMode.Point;
		myCamera = gameObject.GetComponent<Camera>();
		myCamera.orthographic = true;
		myCamera.orthographicSize = height >> 1;
		myCamera.aspect = (float)width / (float)height;
		myCamera.targetTexture = _destinationTexture;
		myCamera.clearFlags = CameraClearFlags.Color;
		Transform component = myCamera.GetComponent<Transform>();
		component.localPosition = new Vector3((float)width / 2f, (float)height / 2f, 3f);
		component.localRotation = Quaternion.Euler(0f, 180f, 180f);
		_doRenderAtlas = true;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log(string.Format("Begin Camera.Render destTex w={0} h={1} camPos={2} camSize={3} camAspect={4}", width, height, component.localPosition, myCamera.orthographicSize, myCamera.aspect.ToString("f5")));
		}
		myCamera.Render();
		_doRenderAtlas = false;
		MB_Utility.Destroy(mat);
		MB_Utility.Destroy(_destinationTexture);
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Finished Camera.Render ");
		}
		Texture2D result = targTex;
		targTex = null;
		return result;
	}

	public void OnRenderObject()
	{
		if (!_doRenderAtlas)
		{
			return;
		}
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int i = 0; i < rs.Length; i++)
		{
			MeshBakerMaterialTexture meshBakerMaterialTexture = textureSets[i].ts[indexOfTexSetToRender];
			Texture2D texture2D = meshBakerMaterialTexture.GetTexture2D();
			if (LOG_LEVEL >= MB2_LogLevel.trace && texture2D != null)
			{
				UnityEngine.Debug.Log(string.Concat("Added ", texture2D, " to atlas w=", texture2D.width, " h=", texture2D.height, " offset=", meshBakerMaterialTexture.matTilingRect.min, " scale=", meshBakerMaterialTexture.matTilingRect.size, " rect=", rs[i], " padding=", _padding));
			}
			CopyScaledAndTiledToAtlas(textureSets[i], meshBakerMaterialTexture, textureSets[i].obUVoffset, textureSets[i].obUVscale, rs[i], _texPropertyName, _resultMaterialTextureBlender);
		}
		stopwatch.Stop();
		stopwatch.Start();
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time for Graphics.DrawTexture calls " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Copying RenderTexture to Texture2D. destW" + _destinationTexture.width + " destH" + _destinationTexture.height);
		}
		Texture2D texture2D2 = new Texture2D(_destinationTexture.width, _destinationTexture.height, TextureFormat.ARGB32, mipChain: true);
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		int num = Mathf.CeilToInt((float)_destinationTexture.width / 512f);
		int num2 = Mathf.CeilToInt((float)_destinationTexture.height / 512f);
		if (num == 0 || num2 == 0)
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Copying all in one shot");
			}
			texture2D2.ReadPixels(new Rect(0f, 0f, _destinationTexture.width, _destinationTexture.height), 0, 0, recalculateMipMaps: true);
		}
		else
		{
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Not OpenGL copying blocks");
			}
			for (int j = 0; j < num; j++)
			{
				for (int k = 0; k < num2; k++)
				{
					int num3 = j * 512;
					int num4 = _destinationTexture.height - 512 - k * 512;
					texture2D2.ReadPixels(new Rect(num3, num4, 512f, 512f), j * 512, k * 512, recalculateMipMaps: true);
				}
			}
		}
		RenderTexture.active = active;
		texture2D2.Apply();
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("TempTexture ");
			if (texture2D2.height <= 16 && texture2D2.width <= 16)
			{
				_printTexture(texture2D2);
			}
		}
		myCamera.targetTexture = null;
		RenderTexture.active = null;
		targTex = texture2D2;
		if (LOG_LEVEL >= MB2_LogLevel.debug)
		{
			UnityEngine.Debug.Log("Total time to copy RenderTexture to Texture2D " + stopwatch.ElapsedMilliseconds.ToString("f5"));
		}
	}

	private Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
	{
		Vector3 zero = Vector3.zero;
		zero.x = (float)(int)c.a * 2f - 1f;
		zero.y = (float)(int)c.g * 2f - 1f;
		zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
		Color32 result = default(Color32);
		result.a = 1;
		result.r = (byte)((zero.x + 1f) * 0.5f);
		result.g = (byte)((zero.y + 1f) * 0.5f);
		result.b = (byte)((zero.z + 1f) * 0.5f);
		return result;
	}

	private bool IsOpenGL()
	{
		return SystemInfo.graphicsDeviceVersion.StartsWith("OpenGL");
	}

	private void CopyScaledAndTiledToAtlas(MB_TexSet texSet, MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, Rect rec, ShaderTextureProperty texturePropertyName, MB3_TextureCombinerNonTextureProperties resultMatTexBlender)
	{
		Rect rect = rec;
		myCamera.backgroundColor = resultMatTexBlender.GetColorForTemporaryTexture(texSet.matsAndGOs.mats[0].mat, texturePropertyName);
		rect.y = 1f - (rect.y + rect.height);
		rect.x *= _destinationTexture.width;
		rect.y *= _destinationTexture.height;
		rect.width *= _destinationTexture.width;
		rect.height *= _destinationTexture.height;
		Rect rect2 = rect;
		rect2.x -= _padding;
		rect2.y -= _padding;
		rect2.width += _padding * 2;
		rect2.height += _padding * 2;
		Rect screenRect = default(Rect);
		Rect rect3 = texSet.ts[indexOfTexSetToRender].GetEncapsulatingSamplingRect().GetRect();
		_ = _fixOutOfBoundsUVs;
		Texture2D texture2D = source.GetTexture2D();
		TextureWrapMode wrapMode = texture2D.wrapMode;
		if (rect3.width == 1f && rect3.height == 1f && rect3.x == 0f && rect3.y == 0f)
		{
			texture2D.wrapMode = TextureWrapMode.Clamp;
		}
		else
		{
			texture2D.wrapMode = TextureWrapMode.Repeat;
		}
		if (LOG_LEVEL >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log(string.Concat("DrawTexture tex=", texture2D.name, " destRect=", rect, " srcRect=", rect3, " Mat=", mat));
		}
		Rect sourceRect = default(Rect);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = rect3.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x;
		screenRect.y = rect2.y;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = _destinationTexture;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = rect3.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = rect.width;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = rect3.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = rect3.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y;
		screenRect.width = _padding;
		screenRect.height = rect.height;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect2.x;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y + 1f - 1f / (float)texture2D.height;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect2.y;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect2.x;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		sourceRect.x = rect3.x + 1f - 1f / (float)texture2D.width;
		sourceRect.y = rect3.y;
		sourceRect.width = 1f / (float)texture2D.width;
		sourceRect.height = 1f / (float)texture2D.height;
		screenRect.x = rect.x + rect.width;
		screenRect.y = rect.y + rect.height;
		screenRect.width = _padding;
		screenRect.height = _padding;
		Graphics.DrawTexture(screenRect, texture2D, sourceRect, 0, 0, 0, 0, mat);
		Graphics.DrawTexture(rect, texture2D, rect3, 0, 0, 0, 0, mat);
		RenderTexture.active = active;
		texture2D.wrapMode = wrapMode;
	}

	private void _printTexture(Texture2D t)
	{
		if (t.width * t.height > 100)
		{
			UnityEngine.Debug.Log("Not printing texture too large.");
			return;
		}
		try
		{
			Color32[] pixels = t.GetPixels32();
			string text = "";
			for (int i = 0; i < t.height; i++)
			{
				for (int j = 0; j < t.width; j++)
				{
					text = string.Concat(text, pixels[i * t.width + j], ", ");
				}
				text += "\n";
			}
			UnityEngine.Debug.Log(text);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("Could not print texture. texture may not be readable." + ex.ToString());
		}
	}
}
[ExecuteInEditMode]
public class MB3_AtlasPackerRenderTexture : MonoBehaviour
{
	private MB_TextureCombinerRenderTexture fastRenderer;

	private bool _doRenderAtlas;

	public int width;

	public int height;

	public int padding;

	public bool isNormalMap;

	public bool fixOutOfBoundsUVs;

	public bool considerNonTextureProperties;

	public MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender;

	public Rect[] rects;

	public Texture2D tex1;

	public List<MB_TexSet> textureSets;

	public int indexOfTexSetToRender;

	public ShaderTextureProperty texPropertyName;

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public Texture2D testTex;

	public Material testMat;

	public Texture2D OnRenderAtlas(MB3_TextureCombiner combiner)
	{
		fastRenderer = new MB_TextureCombinerRenderTexture();
		_doRenderAtlas = true;
		Texture2D result = fastRenderer.DoRenderAtlas(base.gameObject, width, height, padding, rects, textureSets, indexOfTexSetToRender, texPropertyName, resultMaterialTextureBlender, isNormalMap, fixOutOfBoundsUVs, considerNonTextureProperties, combiner, LOG_LEVEL);
		_doRenderAtlas = false;
		return result;
	}

	private void OnRenderObject()
	{
		if (_doRenderAtlas)
		{
			fastRenderer.OnRenderObject();
			_doRenderAtlas = false;
		}
	}
}
[Serializable]
public class MB_AtlasesAndRects
{
	public Texture2D[] atlases;

	[NonSerialized]
	public List<MB_MaterialAndUVRect> mat2rect_map;

	public string[] texPropertyNames;
}
[Serializable]
public class MB_MultiMaterial
{
	public Material combinedMaterial;

	public bool considerMeshUVs;

	public List<Material> sourceMaterials = new List<Material>();
}
[Serializable]
public class MB_MaterialAndUVRect
{
	public Material material;

	public Rect atlasRect;

	public string srcObjName;

	public bool allPropsUseSameTiling = true;

	[FormerlySerializedAs("sourceMaterialTiling")]
	public Rect allPropsUseSameTiling_sourceMaterialTiling;

	[FormerlySerializedAs("samplingEncapsulatinRect")]
	public Rect allPropsUseSameTiling_samplingEncapsulatinRect;

	public Rect propsUseDifferntTiling_srcUVsamplingRect;

	public MB_TextureTilingTreatment tilingTreatment = MB_TextureTilingTreatment.unknown;

	public MB_MaterialAndUVRect(Material mat, Rect destRect, bool allPropsUseSameTiling, Rect sourceMaterialTiling, Rect samplingEncapsulatingRect, Rect srcUVsamplingRect, MB_TextureTilingTreatment treatment, string objName)
	{
		material = mat;
		atlasRect = destRect;
		tilingTreatment = treatment;
		this.allPropsUseSameTiling = allPropsUseSameTiling;
		allPropsUseSameTiling_sourceMaterialTiling = sourceMaterialTiling;
		allPropsUseSameTiling_samplingEncapsulatinRect = samplingEncapsulatingRect;
		propsUseDifferntTiling_srcUVsamplingRect = srcUVsamplingRect;
		srcObjName = objName;
	}

	public override int GetHashCode()
	{
		return material.GetInstanceID() ^ allPropsUseSameTiling_samplingEncapsulatinRect.GetHashCode() ^ propsUseDifferntTiling_srcUVsamplingRect.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		if (!(obj is MB_MaterialAndUVRect))
		{
			return false;
		}
		MB_MaterialAndUVRect mB_MaterialAndUVRect = (MB_MaterialAndUVRect)obj;
		if (material == mB_MaterialAndUVRect.material && allPropsUseSameTiling_samplingEncapsulatinRect == mB_MaterialAndUVRect.allPropsUseSameTiling_samplingEncapsulatinRect && allPropsUseSameTiling_sourceMaterialTiling == mB_MaterialAndUVRect.allPropsUseSameTiling_sourceMaterialTiling && allPropsUseSameTiling == mB_MaterialAndUVRect.allPropsUseSameTiling)
		{
			return propsUseDifferntTiling_srcUVsamplingRect == mB_MaterialAndUVRect.propsUseDifferntTiling_srcUVsamplingRect;
		}
		return false;
	}

	public Rect GetEncapsulatingRect()
	{
		if (allPropsUseSameTiling)
		{
			return allPropsUseSameTiling_samplingEncapsulatinRect;
		}
		return propsUseDifferntTiling_srcUVsamplingRect;
	}

	public Rect GetMaterialTilingRect()
	{
		if (allPropsUseSameTiling)
		{
			return allPropsUseSameTiling_sourceMaterialTiling;
		}
		return new Rect(0f, 0f, 1f, 1f);
	}
}
public class MB2_TextureBakeResults : ScriptableObject
{
	public class Material2AtlasRectangleMapper
	{
		private MB2_TextureBakeResults tbr;

		private int[] numTimesMatAppearsInAtlas;

		private MB_MaterialAndUVRect[] matsAndSrcUVRect;

		public Material2AtlasRectangleMapper(MB2_TextureBakeResults res)
		{
			tbr = res;
			matsAndSrcUVRect = res.materialsAndUVRects;
			numTimesMatAppearsInAtlas = new int[matsAndSrcUVRect.Length];
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (numTimesMatAppearsInAtlas[i] > 1)
				{
					continue;
				}
				int num = 1;
				for (int j = i + 1; j < matsAndSrcUVRect.Length; j++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[j].material)
					{
						num++;
					}
				}
				numTimesMatAppearsInAtlas[i] = num;
				if (num <= 1)
				{
					continue;
				}
				for (int k = i + 1; k < matsAndSrcUVRect.Length; k++)
				{
					if (matsAndSrcUVRect[i].material == matsAndSrcUVRect[k].material)
					{
						numTimesMatAppearsInAtlas[k] = num;
					}
				}
			}
		}

		public bool TryMapMaterialToUVRect(Material mat, Mesh m, int submeshIdx, int idxInResultMats, MB3_MeshCombinerSingle.MeshChannelsCache meshChannelCache, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisCache, out MB_TextureTilingTreatment tilingTreatment, out Rect rectInAtlas, out Rect encapsulatingRectOut, out Rect sourceMaterialTilingOut, ref string errorMsg, MB2_LogLevel logLevel)
		{
			if (tbr.version < VERSION)
			{
				UpgradeToCurrentVersion(tbr);
			}
			tilingTreatment = MB_TextureTilingTreatment.unknown;
			if (tbr.materialsAndUVRects.Length == 0)
			{
				errorMsg = "The 'Texture Bake Result' needs to be re-baked to be compatible with this version of Mesh Baker. Please re-bake using the MB3_TextureBaker.";
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			if (mat == null)
			{
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Mesh {m.name} Had no material on submesh {submeshIdx} cannot map to a material in the atlas";
				return false;
			}
			if (submeshIdx >= m.subMeshCount)
			{
				errorMsg = "Submesh index is greater than the number of submeshes";
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				return false;
			}
			int num = -1;
			for (int i = 0; i < matsAndSrcUVRect.Length; i++)
			{
				if (mat == matsAndSrcUVRect[i].material)
				{
					num = i;
					break;
				}
			}
			if (num == -1)
			{
				rectInAtlas = default(Rect);
				encapsulatingRectOut = default(Rect);
				sourceMaterialTilingOut = default(Rect);
				errorMsg = $"Material {mat.name} could not be found in the Texture Bake Result";
				return false;
			}
			if (!tbr.resultMaterials[idxInResultMats].considerMeshUVs)
			{
				if (numTimesMatAppearsInAtlas[num] != 1)
				{
					UnityEngine.Debug.LogError("There is a problem with this TextureBakeResults. FixOutOfBoundsUVs is false and a material appears more than once.");
				}
				MB_MaterialAndUVRect mB_MaterialAndUVRect = matsAndSrcUVRect[num];
				rectInAtlas = mB_MaterialAndUVRect.atlasRect;
				tilingTreatment = mB_MaterialAndUVRect.tilingTreatment;
				encapsulatingRectOut = mB_MaterialAndUVRect.GetEncapsulatingRect();
				sourceMaterialTilingOut = mB_MaterialAndUVRect.GetMaterialTilingRect();
				return true;
			}
			if (!meshAnalysisCache.TryGetValue(m.GetInstanceID(), out var value))
			{
				value = new MB_Utility.MeshAnalysisResult[m.subMeshCount];
				for (int j = 0; j < m.subMeshCount; j++)
				{
					MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
				}
				meshAnalysisCache.Add(m.GetInstanceID(), value);
			}
			bool flag = false;
			Rect rect = new Rect(0f, 0f, 0f, 0f);
			Rect rect2 = new Rect(0f, 0f, 0f, 0f);
			if (logLevel >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log(string.Format("Trying to find a rectangle in atlas capable of holding tiled sampling rect for mesh {0} using material {1} meshUVrect={2}", m, mat, value[submeshIdx].uvRect.ToString("f5")));
			}
			for (int k = num; k < matsAndSrcUVRect.Length; k++)
			{
				MB_MaterialAndUVRect mB_MaterialAndUVRect2 = matsAndSrcUVRect[k];
				if (!(mB_MaterialAndUVRect2.material == mat))
				{
					continue;
				}
				if (mB_MaterialAndUVRect2.allPropsUseSameTiling)
				{
					rect = mB_MaterialAndUVRect2.allPropsUseSameTiling_samplingEncapsulatinRect;
					rect2 = mB_MaterialAndUVRect2.allPropsUseSameTiling_sourceMaterialTiling;
				}
				else
				{
					rect = mB_MaterialAndUVRect2.propsUseDifferntTiling_srcUVsamplingRect;
					rect2 = new Rect(0f, 0f, 1f, 1f);
				}
				if (IsMeshAndMaterialRectEnclosedByAtlasRect(mB_MaterialAndUVRect2.tilingTreatment, value[submeshIdx].uvRect, rect2, rect, logLevel))
				{
					if (logLevel >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log(string.Concat("Found rect in atlas capable of containing tiled sampling rect for mesh ", m, " at idx=", k));
					}
					num = k;
					flag = true;
					break;
				}
			}
			if (flag)
			{
				MB_MaterialAndUVRect mB_MaterialAndUVRect3 = matsAndSrcUVRect[num];
				rectInAtlas = mB_MaterialAndUVRect3.atlasRect;
				tilingTreatment = mB_MaterialAndUVRect3.tilingTreatment;
				encapsulatingRectOut = mB_MaterialAndUVRect3.GetEncapsulatingRect();
				sourceMaterialTilingOut = mB_MaterialAndUVRect3.GetMaterialTilingRect();
				return true;
			}
			rectInAtlas = default(Rect);
			encapsulatingRectOut = default(Rect);
			sourceMaterialTilingOut = default(Rect);
			errorMsg = $"Could not find a tiled rectangle in the atlas capable of containing the uv and material tiling on mesh {m.name} for material {mat}. Was this mesh included when atlases were baked?";
			return false;
		}

		private void UpgradeToCurrentVersion(MB2_TextureBakeResults tbr)
		{
			if (tbr.version < 3252)
			{
				for (int i = 0; i < tbr.materialsAndUVRects.Length; i++)
				{
					tbr.materialsAndUVRects[i].allPropsUseSameTiling = true;
				}
			}
		}
	}

	public int version;

	public MB_MaterialAndUVRect[] materialsAndUVRects;

	public MB_MultiMaterial[] resultMaterials;

	public bool doMultiMaterial;

	public static int VERSION => 3252;

	public MB2_TextureBakeResults()
	{
		version = VERSION;
	}

	private void OnEnable()
	{
		if (version < 3251)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				materialsAndUVRects[i].allPropsUseSameTiling = true;
			}
		}
		version = VERSION;
	}

	public static MB2_TextureBakeResults CreateForMaterialsOnRenderer(GameObject[] gos, List<Material> matsOnTargetRenderer)
	{
		HashSet<Material> hashSet = new HashSet<Material>(matsOnTargetRenderer);
		for (int i = 0; i < gos.Length; i++)
		{
			if (gos[i] == null)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add was null");
				return null;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(gos[i]);
			if (gOMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError($"Game object {i} in list of objects to add no renderer");
				return null;
			}
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (!hashSet.Contains(gOMaterials[j]))
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		Material[] array = new Material[hashSet.Count];
		hashSet.CopyTo(array);
		MB2_TextureBakeResults mB2_TextureBakeResults = (MB2_TextureBakeResults)ScriptableObject.CreateInstance(typeof(MB2_TextureBakeResults));
		List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
		for (int k = 0; k < array.Length; k++)
		{
			if (array[k] != null)
			{
				MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(array[k], new Rect(0f, 0f, 1f, 1f), allPropsUseSameTiling: true, new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 1f, 1f), new Rect(0f, 0f, 0f, 0f), MB_TextureTilingTreatment.none, "");
				if (!list.Contains(item))
				{
					list.Add(item);
				}
			}
		}
		mB2_TextureBakeResults.resultMaterials = new MB_MultiMaterial[list.Count];
		for (int l = 0; l < list.Count; l++)
		{
			mB2_TextureBakeResults.resultMaterials[l] = new MB_MultiMaterial();
			List<Material> list2 = new List<Material>();
			list2.Add(list[l].material);
			mB2_TextureBakeResults.resultMaterials[l].sourceMaterials = list2;
			mB2_TextureBakeResults.resultMaterials[l].combinedMaterial = list[l].material;
			mB2_TextureBakeResults.resultMaterials[l].considerMeshUVs = false;
		}
		if (array.Length == 1)
		{
			mB2_TextureBakeResults.doMultiMaterial = false;
		}
		else
		{
			mB2_TextureBakeResults.doMultiMaterial = true;
		}
		mB2_TextureBakeResults.materialsAndUVRects = list.ToArray();
		return mB2_TextureBakeResults;
	}

	public bool DoAnyResultMatsUseConsiderMeshUVs()
	{
		if (resultMaterials == null)
		{
			return false;
		}
		for (int i = 0; i < resultMaterials.Length; i++)
		{
			if (resultMaterials[i].considerMeshUVs)
			{
				return true;
			}
		}
		return false;
	}

	public bool ContainsMaterial(Material m)
	{
		for (int i = 0; i < materialsAndUVRects.Length; i++)
		{
			if (materialsAndUVRects[i].material == m)
			{
				return true;
			}
		}
		return false;
	}

	public string GetDescription()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("Shaders:\n");
		HashSet<Shader> hashSet = new HashSet<Shader>();
		if (materialsAndUVRects != null)
		{
			for (int i = 0; i < materialsAndUVRects.Length; i++)
			{
				if (materialsAndUVRects[i].material != null)
				{
					hashSet.Add(materialsAndUVRects[i].material.shader);
				}
			}
		}
		foreach (Shader item in hashSet)
		{
			stringBuilder.Append("  ").Append(item.name).AppendLine();
		}
		stringBuilder.Append("Materials:\n");
		if (materialsAndUVRects != null)
		{
			for (int j = 0; j < materialsAndUVRects.Length; j++)
			{
				if (materialsAndUVRects[j].material != null)
				{
					stringBuilder.Append("  ").Append(materialsAndUVRects[j].material.name).AppendLine();
				}
			}
		}
		return stringBuilder.ToString();
	}

	public static bool IsMeshAndMaterialRectEnclosedByAtlasRect(MB_TextureTilingTreatment tilingTreatment, Rect uvR, Rect sourceMaterialTiling, Rect samplingEncapsulatinRect, MB2_LogLevel logLevel)
	{
		Rect rect = default(Rect);
		rect = MB3_UVTransformUtility.CombineTransforms(ref uvR, ref sourceMaterialTiling);
		if (logLevel >= MB2_LogLevel.trace && logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("Rect in atlas uvR=" + uvR.ToString("f5") + " sourceMaterialTiling=" + sourceMaterialTiling.ToString("f5") + "Potential Rect " + rect.ToString("f5") + " encapsulating=" + samplingEncapsulatinRect.ToString("f5"));
		}
		if (logLevel >= MB2_LogLevel.trace && logLevel >= MB2_LogLevel.trace)
		{
			UnityEngine.Debug.Log("Potential Rect (must fit in encapsulating)  " + rect.ToString("f5") + " encapsulating=" + samplingEncapsulatinRect.ToString("f5"));
		}
		switch (tilingTreatment)
		{
		case MB_TextureTilingTreatment.edgeToEdgeX:
			if (MB3_UVTransformUtility.LineSegmentContainsShifted(samplingEncapsulatinRect.y, samplingEncapsulatinRect.height, rect.y, rect.height))
			{
				return true;
			}
			break;
		case MB_TextureTilingTreatment.edgeToEdgeY:
			if (MB3_UVTransformUtility.LineSegmentContainsShifted(samplingEncapsulatinRect.x, samplingEncapsulatinRect.width, rect.x, rect.width))
			{
				return true;
			}
			break;
		case MB_TextureTilingTreatment.edgeToEdgeXY:
			return true;
		default:
			if (MB3_UVTransformUtility.RectContainsShifted(ref samplingEncapsulatinRect, ref rect))
			{
				return true;
			}
			break;
		}
		return false;
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBones : MonoBehaviour
{
	private SkinnedMeshRenderer smr;

	private Transform[] bones;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBones script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		bones = smr.bones;
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, smr);
		}
	}
}
public class MB2_UpdateSkinnedMeshBoundsFromBounds : MonoBehaviour
{
	public List<GameObject> objects;

	private SkinnedMeshRenderer smr;

	private void Start()
	{
		smr = GetComponent<SkinnedMeshRenderer>();
		if (smr == null)
		{
			UnityEngine.Debug.LogError("Need to attach MB2_UpdateSkinnedMeshBoundsFromBounds script to an object with a SkinnedMeshRenderer component attached.");
			return;
		}
		if (objects == null || objects.Count == 0)
		{
			UnityEngine.Debug.LogWarning("The MB2_UpdateSkinnedMeshBoundsFromBounds had no Game Objects. It should have the same list of game objects that the MeshBaker does.");
			smr = null;
			return;
		}
		for (int i = 0; i < objects.Count; i++)
		{
			if (objects[i] == null || objects[i].GetComponent<Renderer>() == null)
			{
				UnityEngine.Debug.LogError("The list of objects had nulls or game objects without a renderer attached at position " + i);
				smr = null;
				return;
			}
		}
		bool updateWhenOffscreen = smr.updateWhenOffscreen;
		smr.updateWhenOffscreen = true;
		smr.updateWhenOffscreen = updateWhenOffscreen;
	}

	private void Update()
	{
		if (smr != null && objects != null)
		{
			MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objects, smr);
		}
	}
}
public class MB3_BatchPrefabBaker : MonoBehaviour
{
	[Serializable]
	public class MB3_PrefabBakerRow
	{
		public GameObject sourcePrefab;

		public GameObject resultPrefab;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	public MB3_PrefabBakerRow[] prefabRows;

	public string outputPrefabFolder;
}
public class MB3_BoneWeightCopier : MonoBehaviour
{
	public GameObject inputGameObject;

	public GameObject outputPrefab;

	public float radius = 0.01f;

	public SkinnedMeshRenderer seamMesh;

	public string outputFolder;
}
public class MB3_DisableHiddenAnimations : MonoBehaviour
{
	public List<Animation> animationsToCull = new List<Animation>();

	private void Start()
	{
		if (GetComponent<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogError("The MB3_CullHiddenAnimations script was placed on and object " + base.name + " which has no SkinnedMeshRenderer attached");
		}
	}

	private void OnBecameVisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = true;
			}
		}
	}

	private void OnBecameInvisible()
	{
		for (int i = 0; i < animationsToCull.Count; i++)
		{
			if (animationsToCull[i] != null)
			{
				animationsToCull[i].enabled = false;
			}
		}
	}
}
public class MB3_MeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MeshCombinerSingle _meshCombiner = new MB3_MeshCombinerSingle();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public void BuildSceneMeshObject()
	{
		_meshCombiner.BuildSceneMeshObject();
	}

	public virtual bool ShowHide(GameObject[] gos, GameObject[] deleteGOs)
	{
		return _meshCombiner.ShowHideGameObjects(gos, deleteGOs);
	}

	public virtual void ApplyShowHide()
	{
		_meshCombiner.ApplyShowHide();
	}

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
	{
		_meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOinstanceIDs, disableRendererInSource);
	}
}
public abstract class MB3_MeshBakerCommon : MB3_MeshBakerRoot
{
	public List<GameObject> objsToMesh;

	public bool useObjsToMeshFromTexBaker = true;

	public bool clearBuffersAfterBake = true;

	public string bakeAssetsInPlaceFolderPath;

	[HideInInspector]
	public GameObject resultPrefab;

	public abstract MB3_MeshCombiner meshCombiner { get; }

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return meshCombiner.textureBakeResults;
		}
		set
		{
			meshCombiner.textureBakeResults = value;
		}
	}

	public override List<GameObject> GetObjectsToCombine()
	{
		if (useObjsToMeshFromTexBaker)
		{
			MB3_TextureBaker component = base.gameObject.GetComponent<MB3_TextureBaker>();
			if (component == null)
			{
				component = base.gameObject.transform.parent.GetComponent<MB3_TextureBaker>();
			}
			if (component != null)
			{
				return component.GetObjectsToCombine();
			}
			UnityEngine.Debug.LogWarning("Use Objects To Mesh From Texture Baker was checked but no texture baker");
			return new List<GameObject>();
		}
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public void EnableDisableSourceObjectRenderers(bool show)
	{
		for (int i = 0; i < GetObjectsToCombine().Count; i++)
		{
			GameObject gameObject = GetObjectsToCombine()[i];
			if (!(gameObject != null))
			{
				continue;
			}
			Renderer renderer = MB_Utility.GetRenderer(gameObject);
			if (renderer != null)
			{
				renderer.enabled = show;
			}
			LODGroup componentInParent = renderer.GetComponentInParent<LODGroup>();
			if (!(componentInParent != null))
			{
				continue;
			}
			bool flag = true;
			LOD[] lODs = componentInParent.GetLODs();
			for (int j = 0; j < lODs.Length; j++)
			{
				for (int k = 0; k < lODs[j].renderers.Length; k++)
				{
					if (lODs[j].renderers[k] != renderer)
					{
						flag = false;
						break;
					}
				}
			}
			if (flag)
			{
				componentInParent.enabled = show;
			}
		}
	}

	public virtual void ClearMesh()
	{
		meshCombiner.ClearMesh();
	}

	public virtual void DestroyMesh()
	{
		meshCombiner.DestroyMesh();
	}

	public virtual void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
	{
		meshCombiner.DestroyMeshEditor(editorMethods);
	}

	public virtual int GetNumObjectsInCombined()
	{
		return meshCombiner.GetNumObjectsInCombined();
	}

	public virtual int GetNumVerticesFor(GameObject go)
	{
		return meshCombiner.GetNumVerticesFor(go);
	}

	public MB3_TextureBaker GetTextureBaker()
	{
		MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
		if (component != null)
		{
			return component;
		}
		if (base.transform.parent != null)
		{
			return base.transform.parent.GetComponent<MB3_TextureBaker>();
		}
		return null;
	}

	public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

	public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true);

	public virtual void Apply(MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(uv2GenerationMethod);
	}

	public virtual void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, MB3_MeshCombiner.GenerateUV2Delegate uv2GenerationMethod = null)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
	}

	public virtual bool CombinedMeshContains(GameObject go)
	{
		return meshCombiner.CombinedMeshContains(go);
	}

	public virtual void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV1 = false, bool updateUV2 = false, bool updateColors = false, bool updateSkinningInfo = false)
	{
		meshCombiner.name = base.name + "-mesh";
		meshCombiner.UpdateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV1, updateUV2, updateColors, updateSkinningInfo);
	}

	public virtual void UpdateSkinnedMeshApproximateBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBounds();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBones()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBones();
		}
	}

	public virtual void UpdateSkinnedMeshApproximateBoundsFromBounds()
	{
		if (_ValidateForUpdateSkinnedMeshBounds())
		{
			meshCombiner.UpdateSkinnedMeshApproximateBoundsFromBounds();
		}
	}

	protected virtual bool _ValidateForUpdateSkinnedMeshBounds()
	{
		if (meshCombiner.outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
		{
			UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
			return false;
		}
		if (meshCombiner.resultSceneObject == null)
		{
			UnityEngine.Debug.LogWarning("Result Scene Object does not exist. No point in calling UpdateSkinnedMeshApproximateBounds.");
			return false;
		}
		if (meshCombiner.resultSceneObject.GetComponentInChildren<SkinnedMeshRenderer>() == null)
		{
			UnityEngine.Debug.LogWarning("No SkinnedMeshRenderer on result scene object.");
			return false;
		}
		return true;
	}
}
public class MB3_MeshBakerGrouper : MonoBehaviour
{
	public enum ClusterType
	{
		none,
		grid,
		pie,
		agglomerative
	}

	public MB3_MeshBakerGrouperCore grouper;

	public ClusterType clusterType;

	public GrouperData data = new GrouperData();

	[HideInInspector]
	public Bounds sourceObjectBounds = new Bounds(Vector3.zero, Vector3.one);

	private void OnDrawGizmosSelected()
	{
		if (grouper == null)
		{
			grouper = CreateGrouper(clusterType, data);
		}
		if (grouper.d == null)
		{
			grouper.d = data;
		}
		grouper.DrawGizmos(sourceObjectBounds);
	}

	public MB3_MeshBakerGrouperCore CreateGrouper(ClusterType t, GrouperData data)
	{
		if (t == ClusterType.grid)
		{
			grouper = new MB3_MeshBakerGrouperGrid(data);
		}
		if (t == ClusterType.pie)
		{
			grouper = new MB3_MeshBakerGrouperPie(data);
		}
		if (t == ClusterType.agglomerative)
		{
			MB3_TextureBaker component = GetComponent<MB3_TextureBaker>();
			List<GameObject> gos = ((!(component != null)) ? new List<GameObject>() : component.GetObjectsToCombine());
			grouper = new MB3_MeshBakerGrouperCluster(data, gos);
		}
		if (t == ClusterType.none)
		{
			grouper = new MB3_MeshBakerGrouperNone(data);
		}
		return grouper;
	}
}
public abstract class MB3_MeshBakerRoot : MonoBehaviour
{
	public class ZSortObjects
	{
		public class Item
		{
			public GameObject go;

			public Vector3 point;
		}

		public class ItemComparer : IComparer<Item>
		{
			public int Compare(Item a, Item b)
			{
				return (int)Mathf.Sign(b.point.z - a.point.z);
			}
		}

		public Vector3 sortAxis;

		public void SortByDistanceAlongAxis(List<GameObject> gos)
		{
			if (sortAxis == Vector3.zero)
			{
				UnityEngine.Debug.LogError("The sort axis cannot be the zero vector.");
				return;
			}
			UnityEngine.Debug.Log("Z sorting meshes along axis numObjs=" + gos.Count);
			List<Item> list = new List<Item>();
			Quaternion quaternion = Quaternion.FromToRotation(sortAxis, Vector3.forward);
			for (int i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null)
				{
					Item item = new Item();
					item.point = gos[i].transform.position;
					item.go = gos[i];
					item.point = quaternion * item.point;
					list.Add(item);
				}
			}
			list.Sort(new ItemComparer());
			for (int j = 0; j < gos.Count; j++)
			{
				gos[j] = list[j].go;
			}
		}
	}

	public static bool DO_INTEGRITY_CHECKS;

	public Vector3 sortAxis;

	[HideInInspector]
	public abstract MB2_TextureBakeResults textureBakeResults { get; set; }

	public virtual List<GameObject> GetObjectsToCombine()
	{
		return null;
	}

	public static bool DoCombinedValidate(MB3_MeshBakerRoot mom, MB_ObjsToCombineTypes objToCombineType, MB2_EditorMethodsInterface editorMethods, MB2_ValidationLevel validationLevel)
	{
		if (mom.textureBakeResults == null)
		{
			UnityEngine.Debug.LogError("Need to set Texture Bake Result on " + mom);
			return false;
		}
		if (mom is MB3_MeshBakerCommon)
		{
			MB3_TextureBaker textureBaker = ((MB3_MeshBakerCommon)mom).GetTextureBaker();
			if (textureBaker != null && textureBaker.textureBakeResults != mom.textureBakeResults)
			{
				UnityEngine.Debug.LogWarning("Texture Bake Result on this component is not the same as the Texture Bake Result on the MB3_TextureBaker.");
			}
		}
		Dictionary<int, MB_Utility.MeshAnalysisResult> dictionary = null;
		if (validationLevel == MB2_ValidationLevel.robust)
		{
			dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult>();
		}
		List<GameObject> objectsToCombine = mom.GetObjectsToCombine();
		for (int i = 0; i < objectsToCombine.Count; i++)
		{
			GameObject gameObject = objectsToCombine[i];
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("The list of objects to combine contains a null at position." + i + " Select and use [shift] delete to remove");
				return false;
			}
			for (int j = i + 1; j < objectsToCombine.Count; j++)
			{
				if (objectsToCombine[i] == objectsToCombine[j])
				{
					UnityEngine.Debug.LogError("The list of objects to combine contains duplicates at " + i + " and " + j);
					return false;
				}
			}
			if (MB_Utility.GetGOMaterials(gameObject).Length == 0)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a material"));
				return false;
			}
			Mesh mesh = MB_Utility.GetMesh(gameObject);
			if (mesh == null)
			{
				UnityEngine.Debug.LogError(string.Concat("Object ", gameObject, " in the list of objects to be combined does not have a mesh"));
				return false;
			}
			if (mesh != null && !Application.isEditor && Application.isPlaying && mom.textureBakeResults.doMultiMaterial && validationLevel >= MB2_ValidationLevel.robust)
			{
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value);
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (value.hasOverlappingSubmeshVerts)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", objectsToCombine[i], " in the list of objects to combine has overlapping submeshes (submeshes share vertices). If the UVs associated with the shared vertices are important then this bake may not work. If you are using multiple materials then this object can only be combined with objects that use the exact same set of textures (each atlas contains one texture). There may be other undesirable side affects as well. Mesh Master, available in the asset store can fix overlapping submeshes."));
				}
			}
		}
		List<GameObject> list = objectsToCombine;
		if (mom is MB3_MeshBaker)
		{
			list = mom.GetObjectsToCombine();
			if (list == null || list.Count == 0)
			{
				UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
				return false;
			}
			if (mom is MB3_MeshBaker && ((MB3_MeshBaker)mom).meshCombiner.renderType == MB_RenderType.skinnedMeshRenderer && !editorMethods.ValidateSkinnedMeshes(list))
			{
				return false;
			}
		}
		editorMethods?.CheckPrefabTypes(objToCombineType, objectsToCombine);
		return true;
	}
}
public class MB3_MultiMeshBaker : MB3_MeshBakerCommon
{
	[SerializeField]
	protected MB3_MultiMeshCombiner _meshCombiner = new MB3_MultiMeshCombiner();

	public override MB3_MeshCombiner meshCombiner => _meshCombiner;

	public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjects(gos, deleteGOs, disableRendererInSource);
	}

	public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOs, bool disableRendererInSource)
	{
		if (_meshCombiner.resultSceneObject == null)
		{
			_meshCombiner.resultSceneObject = new GameObject("CombinedMesh-" + base.name);
		}
		meshCombiner.name = base.name + "-mesh";
		return _meshCombiner.AddDeleteGameObjectsByID(gos, deleteGOs, disableRendererInSource);
	}
}
public class MB3_TextureBaker : MB3_MeshBakerRoot
{
	public delegate void OnCombinedTexturesCoroutineSuccess();

	public delegate void OnCombinedTexturesCoroutineFail();

	public class CreateAtlasesCoroutineResult
	{
		public bool success = true;

		public bool isFinished;
	}

	public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

	[SerializeField]
	protected MB2_TextureBakeResults _textureBakeResults;

	[SerializeField]
	protected int _atlasPadding = 1;

	[SerializeField]
	protected int _maxAtlasSize = 4096;

	[SerializeField]
	protected bool _useMaxAtlasWidthOverride;

	[SerializeField]
	protected int _maxAtlasWidthOverride = 4096;

	[SerializeField]
	protected bool _useMaxAtlasHeightOverride;

	[SerializeField]
	protected int _maxAtlasHeightOverride = 4096;

	[SerializeField]
	protected bool _resizePowerOfTwoTextures;

	[SerializeField]
	protected bool _fixOutOfBoundsUVs;

	[SerializeField]
	protected int _maxTilingBakeSize = 1024;

	[SerializeField]
	protected MB2_PackingAlgorithmEnum _packingAlgorithm = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;

	[SerializeField]
	protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

	[SerializeField]
	protected List<ShaderTextureProperty> _customShaderProperties = new List<ShaderTextureProperty>();

	[SerializeField]
	protected List<string> _customShaderPropNames_Depricated = new List<string>();

	[SerializeField]
	protected bool _doMultiMaterial;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfTooBig = true;

	[SerializeField]
	protected bool _doMultiMaterialSplitAtlasesIfOBUVs = true;

	[SerializeField]
	protected Material _resultMaterial;

	[SerializeField]
	protected bool _considerNonTextureProperties;

	[SerializeField]
	protected bool _doSuggestTreatment = true;

	private CreateAtlasesCoroutineResult _coroutineResult;

	public MB_MultiMaterial[] resultMaterials = new MB_MultiMaterial[0];

	public List<GameObject> objsToMesh;

	public OnCombinedTexturesCoroutineSuccess onBuiltAtlasesSuccess;

	public OnCombinedTexturesCoroutineFail onBuiltAtlasesFail;

	public MB_AtlasesAndRects[] OnCombinedTexturesCoroutineAtlasesAndRects;

	public override MB2_TextureBakeResults textureBakeResults
	{
		get
		{
			return _textureBakeResults;
		}
		set
		{
			_textureBakeResults = value;
		}
	}

	public virtual int atlasPadding
	{
		get
		{
			return _atlasPadding;
		}
		set
		{
			_atlasPadding = value;
		}
	}

	public virtual int maxAtlasSize
	{
		get
		{
			return _maxAtlasSize;
		}
		set
		{
			_maxAtlasSize = value;
		}
	}

	public virtual bool useMaxAtlasWidthOverride
	{
		get
		{
			return _useMaxAtlasWidthOverride;
		}
		set
		{
			_useMaxAtlasWidthOverride = value;
		}
	}

	public virtual int maxAtlasWidthOverride
	{
		get
		{
			return _maxAtlasWidthOverride;
		}
		set
		{
			_maxAtlasWidthOverride = value;
		}
	}

	public virtual bool useMaxAtlasHeightOverride
	{
		get
		{
			return _useMaxAtlasHeightOverride;
		}
		set
		{
			_useMaxAtlasHeightOverride = value;
		}
	}

	public virtual int maxAtlasHeightOverride
	{
		get
		{
			return _maxAtlasHeightOverride;
		}
		set
		{
			_maxAtlasHeightOverride = value;
		}
	}

	public virtual bool resizePowerOfTwoTextures
	{
		get
		{
			return _resizePowerOfTwoTextures;
		}
		set
		{
			_resizePowerOfTwoTextures = value;
		}
	}

	public virtual bool fixOutOfBoundsUVs
	{
		get
		{
			return _fixOutOfBoundsUVs;
		}
		set
		{
			_fixOutOfBoundsUVs = value;
		}
	}

	public virtual int maxTilingBakeSize
	{
		get
		{
			return _maxTilingBakeSize;
		}
		set
		{
			_maxTilingBakeSize = value;
		}
	}

	public virtual MB2_PackingAlgorithmEnum packingAlgorithm
	{
		get
		{
			return _packingAlgorithm;
		}
		set
		{
			_packingAlgorithm = value;
		}
	}

	public bool meshBakerTexturePackerForcePowerOfTwo
	{
		get
		{
			return _meshBakerTexturePackerForcePowerOfTwo;
		}
		set
		{
			_meshBakerTexturePackerForcePowerOfTwo = value;
		}
	}

	public virtual List<ShaderTextureProperty> customShaderProperties
	{
		get
		{
			return _customShaderProperties;
		}
		set
		{
			_customShaderProperties = value;
		}
	}

	public virtual List<string> customShaderPropNames
	{
		get
		{
			return _customShaderPropNames_Depricated;
		}
		set
		{
			_customShaderPropNames_Depricated = value;
		}
	}

	public virtual bool doMultiMaterial
	{
		get
		{
			return _doMultiMaterial;
		}
		set
		{
			_doMultiMaterial = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfTooBig
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfTooBig;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfTooBig = value;
		}
	}

	public virtual bool doMultiMaterialSplitAtlasesIfOBUVs
	{
		get
		{
			return _doMultiMaterialSplitAtlasesIfOBUVs;
		}
		set
		{
			_doMultiMaterialSplitAtlasesIfOBUVs = value;
		}
	}

	public virtual Material resultMaterial
	{
		get
		{
			return _resultMaterial;
		}
		set
		{
			_resultMaterial = value;
		}
	}

	public bool considerNonTextureProperties
	{
		get
		{
			return _considerNonTextureProperties;
		}
		set
		{
			_considerNonTextureProperties = value;
		}
	}

	public bool doSuggestTreatment
	{
		get
		{
			return _doSuggestTreatment;
		}
		set
		{
			_doSuggestTreatment = value;
		}
	}

	public CreateAtlasesCoroutineResult CoroutineResult => _coroutineResult;

	public override List<GameObject> GetObjectsToCombine()
	{
		if (objsToMesh == null)
		{
			objsToMesh = new List<GameObject>();
		}
		return objsToMesh;
	}

	public MB_AtlasesAndRects[] CreateAtlases()
	{
		return CreateAtlases(null);
	}

	public IEnumerator CreateAtlasesCoroutine(ProgressUpdateDelegate progressInfo, CreateAtlasesCoroutineResult coroutineResult, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null, float maxTimePerFrame = 0.01f)
	{
		MBVersionConcrete mBVersionConcrete = new MBVersionConcrete();
		if (!MB3_TextureCombiner._RunCorutineWithoutPauseIsRunning && (mBVersionConcrete.GetMajorVersion() < 5 || (mBVersionConcrete.GetMajorVersion() == 5 && mBVersionConcrete.GetMinorVersion() < 3)))
		{
			UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
			coroutineResult.success = false;
			yield break;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = null;
		if (maxTimePerFrame <= 0f)
		{
			UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
			coroutineResult.isFinished = true;
			yield break;
		}
		MB2_ValidationLevel validationLevel = (Application.isPlaying ? MB2_ValidationLevel.quick : MB2_ValidationLevel.robust);
		if (!MB3_MeshBakerRoot.DoCombinedValidate(this, MB_ObjsToCombineTypes.dontCare, null, validationLevel))
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (_doMultiMaterial && !_ValidateResultMaterials())
		{
			coroutineResult.isFinished = true;
			yield break;
		}
		if (!_doMultiMaterial)
		{
			if (_resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				coroutineResult.isFinished = true;
				yield break;
			}
			Shader shader = _resultMaterial.shader;
			for (int j = 0; j < objsToMesh.Count; j++)
			{
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[j]);
				foreach (Material material in gOMaterials)
				{
					if (material != null && material.shader != shader)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Game object ", objsToMesh[j], " does not use shader ", shader, " it may not have the required textures. If not small solid color textures will be generated."));
					}
				}
			}
		}
		MB3_TextureCombiner combiner = CreateAndConfigureTextureCombiner();
		combiner.saveAtlasesAsAssets = saveAtlasesAsAssets;
		int num = 1;
		if (_doMultiMaterial)
		{
			num = resultMaterials.Length;
		}
		OnCombinedTexturesCoroutineAtlasesAndRects = new MB_AtlasesAndRects[num];
		for (int l = 0; l < OnCombinedTexturesCoroutineAtlasesAndRects.Length; l++)
		{
			OnCombinedTexturesCoroutineAtlasesAndRects[l] = new MB_AtlasesAndRects();
		}
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<Material> allowedMaterialsFilter = null;
			Material combinedMaterial;
			if (_doMultiMaterial)
			{
				allowedMaterialsFilter = resultMaterials[i].sourceMaterials;
				combinedMaterial = resultMaterials[i].combinedMaterial;
				combiner.fixOutOfBoundsUVs = resultMaterials[i].considerMeshUVs;
			}
			else
			{
				combinedMaterial = _resultMaterial;
			}
			MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult coroutineResult2 = new MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult();
			yield return combiner.CombineTexturesIntoAtlasesCoroutine(progressInfo, OnCombinedTexturesCoroutineAtlasesAndRects[i], combinedMaterial, objsToMesh, allowedMaterialsFilter, editorMethods, coroutineResult2, maxTimePerFrame);
			coroutineResult.success = coroutineResult2.success;
			if (!coroutineResult.success)
			{
				coroutineResult.isFinished = true;
				yield break;
			}
		}
		unpackMat2RectMap(textureBakeResults);
		textureBakeResults.doMultiMaterial = _doMultiMaterial;
		if (_doMultiMaterial)
		{
			textureBakeResults.resultMaterials = resultMaterials;
		}
		else
		{
			MB_MultiMaterial[] array = new MB_MultiMaterial[1]
			{
				new MB_MultiMaterial()
			};
			array[0].combinedMaterial = _resultMaterial;
			array[0].considerMeshUVs = _fixOutOfBoundsUVs;
			array[0].sourceMaterials = new List<Material>();
			for (int m = 0; m < textureBakeResults.materialsAndUVRects.Length; m++)
			{
				array[0].sourceMaterials.Add(textureBakeResults.materialsAndUVRects[m].material);
			}
			textureBakeResults.resultMaterials = array;
		}
		MB3_MeshBakerCommon[] componentsInChildren = GetComponentsInChildren<MB3_MeshBakerCommon>();
		for (int n = 0; n < componentsInChildren.Length; n++)
		{
			componentsInChildren[n].textureBakeResults = textureBakeResults;
		}
		if (LOG_LEVEL >= MB2_LogLevel.info)
		{
			UnityEngine.Debug.Log("Created Atlases");
		}
		coroutineResult.isFinished = true;
		if (coroutineResult.success && onBuiltAtlasesSuccess != null)
		{
			onBuiltAtlasesSuccess();
		}
		if (!coroutineResult.success && onBuiltAtlasesFail != null)
		{
			onBuiltAtlasesFail();
		}
	}

	public MB_AtlasesAndRects[] CreateAtlases(ProgressUpdateDelegate progressInfo, bool saveAtlasesAsAssets = false, MB2_EditorMethodsInterface editorMethods = null)
	{
		MB_AtlasesAndRects[] array = null;
		try
		{
			_coroutineResult = new CreateAtlasesCoroutineResult();
			MB3_TextureCombiner.RunCorutineWithoutPause(CreateAtlasesCoroutine(progressInfo, _coroutineResult, saveAtlasesAsAssets, editorMethods, 1000f), 0);
			if (_coroutineResult.success && textureBakeResults != null)
			{
				array = OnCombinedTexturesCoroutineAtlasesAndRects;
			}
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
		finally
		{
			if (saveAtlasesAsAssets && array != null)
			{
				foreach (MB_AtlasesAndRects mB_AtlasesAndRects in array)
				{
					if (mB_AtlasesAndRects == null || mB_AtlasesAndRects.atlases == null)
					{
						continue;
					}
					for (int j = 0; j < mB_AtlasesAndRects.atlases.Length; j++)
					{
						if (mB_AtlasesAndRects.atlases[j] != null)
						{
							if (editorMethods != null)
							{
								editorMethods.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
							else
							{
								MB_Utility.Destroy(mB_AtlasesAndRects.atlases[j]);
							}
						}
					}
				}
			}
		}
		return array;
	}

	private void unpackMat2RectMap(MB2_TextureBakeResults tbr)
	{
		List<Material> list = new List<Material>();
		List<MB_MaterialAndUVRect> list2 = new List<MB_MaterialAndUVRect>();
		List<Rect> list3 = new List<Rect>();
		for (int i = 0; i < OnCombinedTexturesCoroutineAtlasesAndRects.Length; i++)
		{
			List<MB_MaterialAndUVRect> mat2rect_map = OnCombinedTexturesCoroutineAtlasesAndRects[i].mat2rect_map;
			if (mat2rect_map != null)
			{
				for (int j = 0; j < mat2rect_map.Count; j++)
				{
					list2.Add(mat2rect_map[j]);
					list.Add(mat2rect_map[j].material);
					list3.Add(mat2rect_map[j].atlasRect);
				}
			}
		}
		tbr.version = MB2_TextureBakeResults.VERSION;
		tbr.materialsAndUVRects = list2.ToArray();
	}

	public MB3_TextureCombiner CreateAndConfigureTextureCombiner()
	{
		return new MB3_TextureCombiner
		{
			LOG_LEVEL = LOG_LEVEL,
			atlasPadding = _atlasPadding,
			maxAtlasSize = _maxAtlasSize,
			maxAtlasHeightOverride = _maxAtlasHeightOverride,
			maxAtlasWidthOverride = _maxAtlasWidthOverride,
			useMaxAtlasHeightOverride = _useMaxAtlasWidthOverride,
			useMaxAtlasWidthOverride = _useMaxAtlasHeightOverride,
			customShaderPropNames = _customShaderProperties,
			fixOutOfBoundsUVs = _fixOutOfBoundsUVs,
			maxTilingBakeSize = _maxTilingBakeSize,
			packingAlgorithm = _packingAlgorithm,
			meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo,
			resizePowerOfTwoTextures = _resizePowerOfTwoTextures,
			considerNonTextureProperties = _considerNonTextureProperties
		};
	}

	public static void ConfigureNewMaterialToMatchOld(Material newMat, Material original)
	{
		if (original == null)
		{
			UnityEngine.Debug.LogWarning(string.Concat("Original material is null, could not copy properties to ", newMat, ". Setting shader to ", newMat.shader));
			return;
		}
		newMat.shader = original.shader;
		newMat.CopyPropertiesFromMaterial(original);
		ShaderTextureProperty[] shaderTexPropertyNames = MB3_TextureCombinerPipeline.shaderTexPropertyNames;
		for (int i = 0; i < shaderTexPropertyNames.Length; i++)
		{
			Vector2 one = Vector2.one;
			Vector2 zero = Vector2.zero;
			if (newMat.HasProperty(shaderTexPropertyNames[i].name))
			{
				newMat.SetTextureOffset(shaderTexPropertyNames[i].name, zero);
				newMat.SetTextureScale(shaderTexPropertyNames[i].name, one);
			}
		}
	}

	private string PrintSet(HashSet<Material> s)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (Material item in s)
		{
			stringBuilder.Append(string.Concat(item, ","));
		}
		return stringBuilder.ToString();
	}

	private bool _ValidateResultMaterials()
	{
		HashSet<Material> hashSet = new HashSet<Material>();
		for (int i = 0; i < objsToMesh.Count; i++)
		{
			if (!(objsToMesh[i] != null))
			{
				continue;
			}
			Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
			for (int j = 0; j < gOMaterials.Length; j++)
			{
				if (gOMaterials[j] != null)
				{
					hashSet.Add(gOMaterials[j]);
				}
			}
		}
		HashSet<Material> hashSet2 = new HashSet<Material>();
		for (int k = 0; k < resultMaterials.Length; k++)
		{
			MB_MultiMaterial mB_MultiMaterial = resultMaterials[k];
			if (mB_MultiMaterial.combinedMaterial == null)
			{
				UnityEngine.Debug.LogError("Combined Material is null please create and assign a result material.");
				return false;
			}
			Shader shader = mB_MultiMaterial.combinedMaterial.shader;
			for (int l = 0; l < mB_MultiMaterial.sourceMaterials.Count; l++)
			{
				if (mB_MultiMaterial.sourceMaterials[l] == null)
				{
					UnityEngine.Debug.LogError("There are null entries in the list of Source Materials");
					return false;
				}
				if (shader != mB_MultiMaterial.sourceMaterials[l].shader)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Source material ", mB_MultiMaterial.sourceMaterials[l], " does not use shader ", shader, " it may not have the required textures. If not empty textures will be generated."));
				}
				if (hashSet2.Contains(mB_MultiMaterial.sourceMaterials[l]))
				{
					UnityEngine.Debug.LogError(string.Concat("A Material ", mB_MultiMaterial.sourceMaterials[l], " appears more than once in the list of source materials in the source material to combined mapping. Each source material must be unique."));
					return false;
				}
				hashSet2.Add(mB_MultiMaterial.sourceMaterials[l]);
			}
		}
		if (hashSet.IsProperSubsetOf(hashSet2))
		{
			hashSet2.ExceptWith(hashSet);
			UnityEngine.Debug.LogWarning("There are materials in the mapping that are not used on your source objects: " + PrintSet(hashSet2));
		}
		if (resultMaterials != null && resultMaterials.Length != 0 && hashSet2.IsProperSubsetOf(hashSet))
		{
			hashSet.ExceptWith(hashSet2);
			UnityEngine.Debug.LogError("There are materials on the objects to combine that are not in the mapping: " + PrintSet(hashSet));
			return false;
		}
		return true;
	}
}
public class MobileInputHandler : MonoBehaviour
{
	public Transform rotationAxis;

	private RaycastHit hit;

	private Touch oldTouch1;

	private Touch oldTouch2;

	private float offset;

	private Vector3 pos = Vector3.zero;

	private Camera camera;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.Escape))
		{
			Application.Quit();
		}
		if (Input.touchCount <= 0)
		{
			return;
		}
		if (Input.touchCount == 1)
		{
			Touch touch = Input.GetTouch(0);
			if (Input.GetTouch(0).phase == TouchPhase.Began)
			{
				Ray ray = Camera.main.ScreenPointToRay(touch.position);
				if (Physics.Raycast(ray, out var hitInfo, 100f, 1 << LayerMask.NameToLayer("UI")))
				{
					hitInfo.collider.gameObject.GetComponent<Button>()?.onClick.Invoke();
				}
				if (Physics.Raycast(ray, out hitInfo, 100f, 1 << LayerMask.NameToLayer("Distructable")))
				{
					GameController.Instance.RemoveBlock(hitInfo.collider.gameObject);
				}
			}
			if (touch.phase == TouchPhase.Moved)
			{
				float x = touch.deltaPosition.x;
				_ = touch.deltaPosition;
				Camera.main.transform.RotateAround(rotationAxis.position, Vector3.up, x * 0.1f);
			}
		}
		if (Input.touchCount != 2)
		{
			return;
		}
		Touch touch2 = Input.GetTouch(0);
		Touch touch3 = Input.GetTouch(1);
		if (touch3.phase == TouchPhase.Began)
		{
			oldTouch2 = touch3;
			oldTouch1 = touch2;
			return;
		}
		float num = Vector2.Distance(oldTouch1.position, oldTouch2.position);
		float num2 = Vector2.Distance(touch2.position, touch3.position) - num;
		UnityEngine.Debug.Log("offset:" + num2);
		if (camera == null)
		{
			camera = Camera.main;
		}
		pos.Set(camera.transform.position.x, camera.transform.position.y, camera.transform.position.z + num2 / 100f);
		camera.transform.position = pos;
		oldTouch1 = touch2;
		oldTouch2 = touch3;
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	private static string USER_NAME = "username";

	private static string DATA = "data";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		if (jsonData[IS_SUCCESS] != null && jsonData[IS_SUCCESS].ToString().Equals("true"))
		{
			PicoLogin.GetUserAPI();
		}
		UnityEngine.Debug.Log("login:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("pay:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(userInfo);
		UnityEngine.Debug.Log("userInfo:" + userInfo);
		if (jsonData["data"] != null && jsonData[DATA][USER_NAME] != null)
		{
			UnityEngine.Debug.Log("UserName:" + jsonData[DATA][USER_NAME]);
			LobbyMgr.Instance.GetUserInfo(jsonData[DATA][USER_NAME].ToString());
		}
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("Message");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class Grabber : MonoBehaviour
{
	public float grabBegin = 0.55f;

	public float grabEnd = 0.35f;

	[SerializeField]
	protected bool m_parentHeldObject;

	[SerializeField]
	protected Transform m_gripTransform;

	[SerializeField]
	protected Collider[] m_grabVolumes;

	[SerializeField]
	public ControllerVariety hand;

	[SerializeField]
	protected Transform m_parentTransform;

	protected bool m_grabVolumeEnabled = true;

	protected Vector3 m_lastPos;

	protected Quaternion m_lastRot;

	protected Quaternion m_anchorOffsetRotation;

	protected Vector3 m_anchorOffsetPosition;

	protected float m_prevFlex;

	protected Grabbable m_grabbedObj;

	protected Vector3 m_grabbedObjectPosOff;

	protected Quaternion m_grabbedObjectRotOff;

	protected Dictionary<Grabbable, int> m_grabCandidates = new Dictionary<Grabbable, int>();

	protected bool operatingWithoutOVRCameraRig = true;

	public Grabbable grabbedObject => m_grabbedObj;

	public void ForceRelease(Grabbable grabbable)
	{
		if (m_grabbedObj != null && m_grabbedObj == grabbable)
		{
			GrabEnd();
		}
	}

	protected virtual void Awake()
	{
		m_anchorOffsetPosition = base.transform.localPosition;
		m_anchorOffsetRotation = base.transform.localRotation;
	}

	protected virtual void Start()
	{
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_parentTransform == null)
		{
			if (base.gameObject.transform.parent != null)
			{
				m_parentTransform = base.gameObject.transform.parent.transform;
				return;
			}
			m_parentTransform = new GameObject().transform;
			m_parentTransform.position = Vector3.zero;
			m_parentTransform.rotation = Quaternion.identity;
		}
	}

	private void FixedUpdate()
	{
		if (operatingWithoutOVRCameraRig)
		{
			OnUpdatedAnchors();
		}
	}

	private void OnUpdatedAnchors()
	{
		Vector3 vector = m_parentTransform.TransformPoint(Controller.UPvr_GetControllerPOS((int)hand));
		Quaternion rot = m_parentTransform.rotation * Controller.UPvr_GetControllerQUA((int)hand).normalized;
		GetComponent<Rigidbody>().MovePosition(vector);
		GetComponent<Rigidbody>().MoveRotation(rot);
		if (!m_parentHeldObject)
		{
			MoveGrabbedObject(vector, rot);
		}
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		float prevFlex = m_prevFlex;
		m_prevFlex = (float)Controller.UPvr_GetControllerTriggerValue((int)hand) / 255f;
		CheckForGrabOrRelease(prevFlex);
	}

	private void OnDestroy()
	{
		if (m_grabbedObj != null)
		{
			GrabEnd();
		}
	}

	private void OnTriggerEnter(Collider otherCollider)
	{
		Grabbable grabbable = otherCollider.GetComponent<Grabbable>() ?? otherCollider.GetComponentInParent<Grabbable>();
		if (!(grabbable == null))
		{
			int value = 0;
			m_grabCandidates.TryGetValue(grabbable, out value);
			m_grabCandidates[grabbable] = value + 1;
		}
	}

	private void OnTriggerExit(Collider otherCollider)
	{
		Grabbable grabbable = otherCollider.GetComponent<Grabbable>() ?? otherCollider.GetComponentInParent<Grabbable>();
		if (grabbable == null)
		{
			return;
		}
		int value = 0;
		if (m_grabCandidates.TryGetValue(grabbable, out value))
		{
			if (value > 1)
			{
				m_grabCandidates[grabbable] = value - 1;
			}
			else
			{
				m_grabCandidates.Remove(grabbable);
			}
		}
	}

	protected void CheckForGrabOrRelease(float prevFlex)
	{
		if (m_prevFlex >= grabBegin && prevFlex < grabBegin)
		{
			GrabBegin();
		}
		else if (m_prevFlex <= grabEnd && prevFlex > grabEnd)
		{
			GrabEnd();
		}
	}

	protected virtual void GrabBegin()
	{
		float num = float.MaxValue;
		Grabbable grabbable = null;
		Collider grabPoint = null;
		foreach (Grabbable key in m_grabCandidates.Keys)
		{
			if (key.isGrabbed && !key.allowOffhandGrab)
			{
				continue;
			}
			for (int i = 0; i < key.grabPoints.Length; i++)
			{
				Collider collider = key.grabPoints[i];
				if (!(collider == null))
				{
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						grabbable = key;
						grabPoint = collider;
					}
				}
			}
		}
		GrabVolumeEnable(enabled: false);
		if (!(grabbable != null))
		{
			return;
		}
		if (grabbable.isGrabbed)
		{
			grabbable.grabbedBy.OffhandGrabbed(grabbable);
		}
		m_grabbedObj = grabbable;
		m_grabbedObj.GrabBegin(this, grabPoint);
		m_lastPos = base.transform.position;
		m_lastRot = base.transform.rotation;
		if (m_grabbedObj.snapPosition)
		{
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (hand == ControllerVariety.Controller0)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
		}
		else
		{
			Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
			vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
			m_grabbedObjectPosOff = vector2;
		}
		if (m_grabbedObj.snapOrientation)
		{
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}
		else
		{
			Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
			m_grabbedObjectRotOff = grabbedObjectRotOff;
		}
		MoveGrabbedObject(m_lastPos, m_lastRot, forceTeleport: true);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = base.transform;
		}
	}

	protected virtual void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
	{
		if (!(m_grabbedObj == null))
		{
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 position = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (forceTeleport)
			{
				grabbedRigidbody.transform.position = position;
				grabbedRigidbody.transform.rotation = quaternion;
			}
			else
			{
				grabbedRigidbody.MovePosition(position);
				grabbedRigidbody.MoveRotation(quaternion);
			}
		}
	}

	protected void GrabEnd()
	{
		if (m_grabbedObj != null)
		{
			Vector3 vector = Controller.UPvr_GetVelocity((int)hand) / 1000f;
			UnityEngine.Debug.Log("linearVelocity:" + vector);
			vector.Set(vector.x, vector.y, 0f - vector.z);
			vector = m_parentTransform.TransformVector(vector);
			Vector3 vector2 = Controller.UPvr_GetAngularVelocity((int)hand) / 100f;
			UnityEngine.Debug.Log("angularVelocity:" + vector2);
			vector2.Set(vector2.x, 0f - vector2.y, 0f - vector2.z);
			vector2 = m_parentTransform.TransformVector(vector2);
			Vector3 vector3 = m_grabbedObj.grabbedTransform.TransformPoint(m_grabbedObj.grabbedRigidbody.centerOfMass) - Controller.UPvr_GetControllerPOS((int)hand);
			vector += Vector3.Cross(vector2, 1f * vector3);
			GrabbableRelease(vector, vector2);
		}
		GrabVolumeEnable(enabled: true);
	}

	protected void GrabbableRelease(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		m_grabbedObj.GrabEnd(linearVelocity, angularVelocity);
		if (m_parentHeldObject)
		{
			m_grabbedObj.transform.parent = null;
		}
		m_grabbedObj = null;
	}

	protected virtual void GrabVolumeEnable(bool enabled)
	{
		if (m_grabVolumeEnabled != enabled)
		{
			m_grabVolumeEnabled = enabled;
			for (int i = 0; i < m_grabVolumes.Length; i++)
			{
				m_grabVolumes[i].enabled = m_grabVolumeEnabled;
			}
			if (!m_grabVolumeEnabled)
			{
				m_grabCandidates.Clear();
			}
		}
	}

	protected virtual void OffhandGrabbed(Grabbable grabbable)
	{
		if (m_grabbedObj == grabbable)
		{
			GrabbableRelease(Vector3.zero, Vector3.zero);
		}
	}
}
public class Interactor : MonoBehaviour
{
	[SerializeField]
	[Tooltip("The attach transform that is used as an attach point for interactables.")]
	private Transform m_AttachTransform;

	public float grabBegin = 0.55f;

	public float grabEnd = 0.35f;

	[SerializeField]
	protected Collider[] m_grabVolumes;

	[SerializeField]
	protected Transform m_gripTransform;

	[SerializeField]
	internal InputHandler.ControllerType m_controller;

	protected bool m_VolumeEnabled = true;

	protected float m_prevFlex;

	protected Interactable m_interactedObj;

	protected Interactable m_hoveredObj;

	protected Dictionary<Interactable, int> m_Candidates = new Dictionary<Interactable, int>();

	private Renderer render;

	public Transform attachTransform => m_AttachTransform;

	public Interactable interactedObject => m_interactedObj;

	protected virtual void Awake()
	{
	}

	protected virtual void Start()
	{
		render = GetInteractorRendering();
	}

	private void FixedUpdate()
	{
		float prevFlex = m_prevFlex;
		m_prevFlex = MonoSingleton<InputHandler>.Instance().GetHandTriggerValue(m_controller);
		CheckForGrabOrRelease(prevFlex);
		CheckForActivateOrDeactivate();
	}

	private void CheckForActivateOrDeactivate()
	{
		bool activateButtonDown = MonoSingleton<InputHandler>.Instance().GetActivateButtonDown(m_controller);
		bool activateButtonUp = MonoSingleton<InputHandler>.Instance().GetActivateButtonUp(m_controller);
		if (m_interactedObj != null)
		{
			if (activateButtonDown)
			{
				m_interactedObj.OnActivate(this);
			}
			if (activateButtonUp)
			{
				m_interactedObj.OnDeactivate(this);
			}
		}
	}

	private void OnDestroy()
	{
		if (m_interactedObj != null)
		{
			GrabEnd();
		}
	}

	private void OnTriggerEnter(Collider otherCollider)
	{
		UnityEngine.Debug.Log("OnTriggerEnter:" + otherCollider.name);
		Interactable component = otherCollider.GetComponent<Interactable>();
		if (component == null)
		{
			return;
		}
		UnityEngine.Debug.Log("Interactable:" + component.name);
		component.OnHoverEnter(this);
		int value = 0;
		m_Candidates.TryGetValue(component, out value);
		m_Candidates[component] = value + 1;
		Interactable closestInteractable = GetClosestInteractable();
		if (closestInteractable != null)
		{
			if (m_hoveredObj != null)
			{
				m_hoveredObj.Highlight(on: false);
			}
			m_hoveredObj = closestInteractable;
			m_hoveredObj.Highlight(on: true);
		}
	}

	private void OnTriggerExit(Collider otherCollider)
	{
		UnityEngine.Debug.Log("OnTriggerExit:" + otherCollider.name);
		Interactable component = otherCollider.GetComponent<Interactable>();
		if (component == null)
		{
			return;
		}
		if (m_hoveredObj == component)
		{
			m_hoveredObj = null;
		}
		UnityEngine.Debug.Log("Interactable:" + component.name);
		int value = 0;
		if (m_Candidates.TryGetValue(component, out value))
		{
			if (value > 1)
			{
				m_Candidates[component] = value - 1;
			}
			else
			{
				m_Candidates.Remove(component);
			}
			component.OnHoverExit(this);
		}
	}

	protected void CheckForGrabOrRelease(float prevFlex)
	{
		if (m_prevFlex >= grabBegin && prevFlex < grabBegin)
		{
			GrabBegin();
		}
		else if (m_prevFlex <= grabEnd && prevFlex > grabEnd)
		{
			GrabEnd();
		}
	}

	protected virtual void GrabBegin()
	{
		Interactable closestInteractable = GetClosestInteractable();
		GrabVolumeEnable(enabled: false);
		if (closestInteractable != null)
		{
			UnityEngine.Debug.Log("closestInteractable:" + closestInteractable.name);
			if (closestInteractable.isInteracted)
			{
				closestInteractable.interactedBy.Offhand(closestInteractable);
			}
			m_interactedObj = closestInteractable;
			m_interactedObj.GrabBegin(this);
			m_interactedObj.OnSelectEnter(this);
			if (render == null)
			{
				render = GetInteractorRendering();
			}
			UnityEngine.Debug.Log("grab begin render:" + render);
			render.enabled = false;
		}
	}

	private Renderer GetInteractorRendering()
	{
		MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer meshRenderer in componentsInChildren)
		{
			if (meshRenderer.name.Equals("Neo"))
			{
				return meshRenderer;
			}
		}
		return null;
	}

	private Interactable GetClosestInteractable()
	{
		float num = float.MaxValue;
		Interactable result = null;
		foreach (Interactable key in m_Candidates.Keys)
		{
			for (int i = 0; i < key.interactablePoints.Length; i++)
			{
				Collider collider = key.interactablePoints[i];
				if (!(collider == null))
				{
					UnityEngine.Debug.Log("grabbableCollider:" + collider.name);
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					UnityEngine.Debug.Log("grabbableMagSq:" + sqrMagnitude);
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						result = key;
					}
				}
			}
		}
		return result;
	}

	public void Offhand(Interactable interactable)
	{
		if (m_interactedObj == interactable)
		{
			m_interactedObj.OnSelectExit(this);
			Release();
		}
	}

	private void Release()
	{
		m_interactedObj.GrabEnd();
		m_interactedObj = null;
		if (render == null)
		{
			render = GetComponentInChildren<Renderer>();
		}
		render.enabled = true;
	}

	protected void GrabEnd()
	{
		if (m_interactedObj != null)
		{
			m_interactedObj.OnSelectExit(this);
			Release();
		}
		GrabVolumeEnable(enabled: true);
	}

	protected virtual void GrabVolumeEnable(bool enabled)
	{
		if (m_VolumeEnabled != enabled)
		{
			m_VolumeEnabled = enabled;
			for (int i = 0; i < m_grabVolumes.Length; i++)
			{
				m_grabVolumes[i].enabled = m_VolumeEnabled;
			}
			if (!m_VolumeEnabled)
			{
				m_Candidates.Clear();
			}
		}
	}
}
public class ObjectHaptics : MonoBehaviour
{
	public ControllerVariety hand;

	private Interactor grabber;

	private bool isOn;

	private void Start()
	{
		grabber = GetComponent<Interactor>();
	}

	private void Update()
	{
		if (grabber.interactedObject != null)
		{
			Controller.UPvr_VibrateNeo2Controller(0.1f, (int)(1000f * Time.deltaTime), (int)hand);
			isOn = true;
		}
		if (isOn && grabber.interactedObject == null)
		{
			Controller.UPvr_VibrateNeo2Controller(0f, (int)(1000f * Time.deltaTime), (int)hand);
			isOn = false;
		}
	}
}
public class PicoInputHandler : InputHandler
{
	internal override Vector3 GetControllerVelocity(ControllerType hand)
	{
		Vector3 result = Controller.UPvr_GetVelocity((int)hand) / 1000f;
		result.z *= -1f;
		return result;
	}

	internal override bool IsMenuKeyDown()
	{
		bool num = Controller.UPvr_GetKey(0, Pvr_KeyCode.APP);
		if (num)
		{
			Action action = onMenuKeyDown;
			if (action == null)
			{
				return num;
			}
			action();
		}
		return num;
	}

	internal override bool IsChangeLevelKeyDown()
	{
		return Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X);
	}

	internal override bool IsQuitKeyDown()
	{
		return Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.APP);
	}

	internal override Interactor GetInteractor(ControllerType hand)
	{
		if (hand.Equals(ControllerType.Left))
		{
			return GameObject.Find("PvrController0").GetComponent<Interactor>();
		}
		return GameObject.Find("PvrController1").GetComponent<Interactor>();
	}

	internal override float GetIndexTriggerValue(ControllerType hand)
	{
		return (float)Controller.UPvr_GetControllerTriggerValue((int)hand) / 255f;
	}

	internal override float GetHandTriggerValue(ControllerType hand)
	{
		return (float)Controller.UPvr_GetControllerTriggerValue((int)hand) / 255f;
	}

	internal override Vector2 GetThumbstickValue(ControllerType hand)
	{
		return Controller.UPvr_GetAxis2D((int)hand);
	}

	internal override void SetContollerVibration(float frequency, float amplitude, ControllerType hand)
	{
		Controller.UPvr_VibrateNeo2Controller(amplitude, 1000, (int)hand);
	}

	internal override bool GetAButtonDown(ControllerType hand)
	{
		return Controller.UPvr_GetKey(1, Pvr_KeyCode.A);
	}

	internal override bool GetActivateButtonDown(ControllerType m_controller)
	{
		return Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A);
	}

	internal override bool GetActivateButtonUp(ControllerType m_controller)
	{
		return Controller.UPvr_GetKeyUp(1, Pvr_KeyCode.A);
	}

	internal override bool IsBackKeyDown()
	{
		return Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.APP);
	}

	internal override bool GetIndexTriggerDown(ControllerType hand)
	{
		return Controller.UPvr_GetKeyDown((int)hand, Pvr_KeyCode.TRIGGER);
	}

	internal override bool GetUpKeyDown(ControllerType m_controller)
	{
		throw new NotImplementedException();
	}

	internal override bool GetDownKeyDown(ControllerType m_controller)
	{
		throw new NotImplementedException();
	}

	internal override bool GetLeftKeyDown(ControllerType m_controller)
	{
		throw new NotImplementedException();
	}

	internal override bool GetRightKeyDown(ControllerType m_controller)
	{
		throw new NotImplementedException();
	}
}
public class PicoLogin
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class Quit : MonoBehaviour
{
	public Transform panel;

	private float t;

	private float t1;

	private void Start()
	{
		panel.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (MonoSingleton<InputHandler>.Instance().IsQuitKeyDown() || Input.GetKeyDown(KeyCode.A))
		{
			t1 = Time.realtimeSinceStartup;
			panel.gameObject.SetActive(value: true);
			if (t1 - t < 0.5f)
			{
				Application.Quit();
			}
			t = t1;
		}
		if (panel.gameObject.activeSelf && Time.realtimeSinceStartup - t > 0.5f)
		{
			panel.gameObject.SetActive(value: false);
		}
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		ControllerDevice controllerDevice = currentDevice;
		if (controllerDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "");
		mydic.Add("10000", "");
		mydic.Add("10001", "");
		mydic.Add("10002", "");
		mydic.Add("10003", "");
		mydic.Add("11000", "");
		mydic.Add("11001", "");
		mydic.Add("11002", "");
		mydic.Add("11003", "");
		mydic.Add("12000", "");
		mydic.Add("12001", "");
		mydic.Add("12003", "P");
		mydic.Add("12004", "");
		mydic.Add("13000", "");
		mydic.Add("13001", "");
		mydic.Add("13002", "");
		mydic.Add("14000", "");
		mydic.Add("14001", "/");
		mydic.Add("14002", "");
		mydic.Add("15000", "");
		mydic.Add("15001", "ID");
		mydic.Add("15002", "Pico");
		mydic.Add("NOAUTH", "");
		mydic.Add("SYSTEMERROR", "");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID");
		mydic.Add("MCHID_NOT_EXIST", "MCHID");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_idmch_idID");
		mydic.Add("LACK_PARAMS", "");
		mydic.Add("SIGNERROR", "");
		mydic.Add("NO_DATA", "");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + neckOffset);
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering += MyPreRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipeline.beginCameraRendering -= MyPreRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			if (GraphicsSettings.renderPipelineAsset != null)
			{
				for (int i = 0; i < Eyes.Length; i++)
				{
					if (!Eyes[i].isActiveAndEnabled || !Eyes[i].eyecamera.enabled)
					{
						continue;
					}
					switch (Eyes[i].eyeSide)
					{
					case Eye.LeftEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.LeftEyeEndFrame;
						break;
					case Eye.RightEye:
						if (!Pvr_UnitySDKManager.SDK.Monoscopic)
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx + 3];
						}
						else
						{
							eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						}
						eventType = RenderEventType.RightEyeEndFrame;
						break;
					case Eye.BothEye:
						eyeTextureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx];
						eventType = RenderEventType.BothEyeEndFrame;
						break;
					}
					Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(eyeTextureId));
					Pvr_UnitySDKPluginEvent.Issue(eventType);
					Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
				}
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int j = 0; j < Pvr_UnitySDKEyeOverlay.Instances.Count; j++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[j];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		UnityEngine.Debug.Log(string.Concat("DISFT Customize RenderTexture:", vector, ", scaleFactor: ", RtScaleFactor));
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int num = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(num);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + num);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles);
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
public class AndroidPermissionCallback : AndroidJavaProxy
{
	private event Action<string> OnPermissionGrantedAction;

	private event Action<string> OnPermissionDeniedAction;

	public AndroidPermissionCallback(Action<string> onGrantedCallback, Action<string> onDeniedCallback)
		: base("com.unity3d.plugin.UnityAndroidPermissions$IPermissionRequestResult")
	{
		if (onGrantedCallback != null)
		{
			OnPermissionGrantedAction += onGrantedCallback;
		}
		if (onDeniedCallback != null)
		{
			OnPermissionDeniedAction += onDeniedCallback;
		}
	}

	public virtual void OnPermissionGranted(string permissionName)
	{
		if (this.OnPermissionGrantedAction != null)
		{
			this.OnPermissionGrantedAction(permissionName);
		}
	}

	public virtual void OnPermissionDenied(string permissionName)
	{
		if (this.OnPermissionDeniedAction != null)
		{
			this.OnPermissionDeniedAction(permissionName);
		}
	}
}
public class AndroidPermissionsManager
{
	private static AndroidJavaObject m_Activity;

	private static AndroidJavaObject m_PermissionService;

	private static AndroidJavaObject GetActivity()
	{
		if (m_Activity == null)
		{
			m_Activity = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}
		return m_Activity;
	}

	private static AndroidJavaObject GetPermissionsService()
	{
		return m_PermissionService ?? (m_PermissionService = new AndroidJavaObject("com.unity3d.plugin.UnityAndroidPermissions"));
	}

	public static bool IsPermissionGranted(string permissionName)
	{
		return GetPermissionsService().Call<bool>("IsPermissionGranted", new object[2]
		{
			GetActivity(),
			permissionName
		});
	}

	public static void RequestPermission(string[] permissionNames, AndroidPermissionCallback callback)
	{
		GetPermissionsService().Call("RequestPermissionAsync", GetActivity(), permissionNames, callback);
	}
}
public class UsageExample : MonoBehaviour
{
	private const string STORAGE_PERMISSION = "android.permission.READ_EXTERNAL_STORAGE";

	public void OnBrowseGalleryButtonPress()
	{
		if (!CheckPermissions())
		{
			UnityEngine.Debug.LogWarning("Missing permission to browse device gallery, please grant the permission first");
		}
		else
		{
			UnityEngine.Debug.Log("Browsing Gallery...");
		}
	}

	private bool CheckPermissions()
	{
		if (Application.platform != RuntimePlatform.Android)
		{
			return true;
		}
		return AndroidPermissionsManager.IsPermissionGranted("android.permission.READ_EXTERNAL_STORAGE");
	}

	public void OnGrantButtonPress()
	{
		AndroidPermissionsManager.RequestPermission(new string[1] { "android.permission.READ_EXTERNAL_STORAGE" }, new AndroidPermissionCallback(delegate
		{
			OnBrowseGalleryButtonPress();
		}, delegate
		{
		}));
	}
}
public class InteractableButton : MonoBehaviour
{
	[Serializable]
	public class ButtonEvent : UnityEvent
	{
	}

	public ButtonEvent onButtonDown;
}
public class SelectionButton : InteractableButton
{
	public float confirmInterval = 0.3f;

	public AudioClip enterSound;

	private float triggerTime;

	private void OnTriggerEnter(Collider other)
	{
		if ((other.transform.name.Contains("Finger") || other.transform.name.Contains("GrabVolume") || other.transform.name.Contains("PvrController")) && Time.time - triggerTime > confirmInterval)
		{
			triggerTime = Time.time;
			AudioSource.PlayClipAtPoint(enterSound, base.transform.position);
			onButtonDown?.Invoke();
		}
	}
}
public class StartButton : MonoBehaviour
{
	public LoadMenuPresenter presenter;

	public Material active;

	public AudioClip startSound;

	public Material inActive;

	private Renderer render;

	private MenuButton button;

	private bool isActive;

	private void Start()
	{
		render = GetComponent<Renderer>();
		button = GetComponent<MenuButton>();
		SetInactive();
	}

	private void SetInactive()
	{
		isActive = false;
		if (render != null)
		{
			render.material = inActive;
		}
		button.enabled = false;
	}

	private void SetActive()
	{
		isActive = true;
		if (render != null)
		{
			render.material = active;
		}
		button.enabled = true;
	}

	private void Update()
	{
		if (!isActive && presenter.selectedIndexes.Count == LevelMgr.Instance.count)
		{
			SetActive();
		}
		if (isActive && presenter.selectedIndexes.Count != LevelMgr.Instance.count)
		{
			SetInactive();
		}
	}

	public void OnButtonPressed()
	{
		LoadLevelContent();
		Invoke("PlayStartSound", 1.5f);
		GameController.Instance.StartNewGame();
	}

	private void PlayStartSound()
	{
		AudioSource.PlayClipAtPoint(startSound, base.transform.position);
	}

	private void LoadLevelContent()
	{
		LevelMgr.Instance.roundLevels.Clear();
		List<int> selectedIndexes = presenter.selectedIndexes;
		for (int i = 0; i < selectedIndexes.Count; i++)
		{
			LevelMgr.Instance.roundLevels.Add(GameRoundMgr.Instance.GetGameRound(selectedIndexes[i]));
		}
	}
}
public class Blink : MonoBehaviour
{
	public float speed = 0.1f;

	private Material material;

	private bool isArrived;

	private bool isEnabled;

	private Color color = Color.white;

	private void Start()
	{
		material = GetComponent<Renderer>().sharedMaterial;
		material.SetColor("_Color", Color.white);
	}

	private void Update()
	{
		SwitchAlpha();
	}

	public void Enable(bool on)
	{
		material.SetColor("_Color", Color.white);
		isEnabled = on;
	}

	private void SwitchAlpha()
	{
		color = material.GetColor("_Color");
		if (!isArrived)
		{
			color.a += speed * Time.deltaTime;
			if ((double)color.a > 0.99)
			{
				isArrived = true;
			}
		}
		else
		{
			color.a -= speed * Time.deltaTime;
			if ((double)color.a < 0.3)
			{
				isArrived = false;
			}
		}
		material.SetColor("_Color", color);
	}
}
public abstract class Container : MonoBehaviour
{
	protected List<Transform> objects;

	public Action<Collider> onEnter;

	public Action<Collider> onExit;

	public int index = -1;

	private void Awake()
	{
		objects = new List<Transform>();
	}

	public List<Transform> GetObjects()
	{
		return objects;
	}

	public void AddObjects(List<Transform> objs)
	{
		objects.AddRange(objs);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (IsTriggered(other) && !objects.Contains(other.gameObject.transform))
		{
			UnityEngine.Debug.Log("OnTriggerEnter:" + other.transform.name);
			objects.Add(other.gameObject.transform);
			if (onEnter != null)
			{
				onEnter(other);
			}
		}
	}

	protected abstract bool IsTriggered(Collider other);

	private void OnTriggerExit(Collider other)
	{
		if (objects.Contains(other.gameObject.transform))
		{
			UnityEngine.Debug.Log("OnTriggerExit:" + other.transform.name);
			objects.Remove(other.gameObject.transform);
			if (onExit != null)
			{
				onExit(other);
			}
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (IsTriggered(collision.collider) && !objects.Contains(collision.gameObject.transform))
		{
			UnityEngine.Debug.Log("OnCollisionEnter:" + collision.transform.name);
			objects.Add(collision.gameObject.transform);
			if (onEnter != null)
			{
				onEnter(collision.collider);
			}
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if (objects.Contains(collision.gameObject.transform))
		{
			UnityEngine.Debug.Log("OnCollisionExit:" + collision.transform.name);
			objects.Remove(collision.gameObject.transform);
			if (onExit != null)
			{
				onExit(collision.collider);
			}
		}
	}

	public void Restore()
	{
		objects.Clear();
	}
}
[Serializable]
public enum ContainerType
{
	Object,
	Symbol,
	Axis
}
internal class FileUtil
{
	internal static bool CreateFolder(string path)
	{
		try
		{
			if (!Directory.Exists(path) && Directory.CreateDirectory(path) == null)
			{
				return false;
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.Log("create folder failure:" + ex.Message);
			return false;
		}
	}

	internal static void DeleteFile(string fileName)
	{
		if (File.Exists(fileName))
		{
			File.Delete(fileName);
		}
	}

	internal static List<string> FindFiles(string folder, string name)
	{
		List<string> list = new List<string>();
		foreach (string item in Directory.EnumerateFiles(folder))
		{
			if (item.Contains(name))
			{
				list.Add(item);
			}
		}
		return list;
	}
}
public class GameTimer : MonoBehaviour
{
	public float countDownTime;

	private float timeLeft;

	private float interval;

	private TMP_Text leftTime;

	public static Action onTimeUp;

	private AudioSource timeover;

	private bool stopped;

	private void Start()
	{
		timeLeft = countDownTime;
		leftTime = GetComponent<TMP_Text>();
		timeover = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (stopped)
		{
			return;
		}
		int num = (int)(timeLeft / 60f);
		float num2 = timeLeft % 60f;
		if (num == 0 && num2 < 0f)
		{
			stopped = true;
			interval = 0f;
			onTimeUp?.Invoke();
			timeover.Play();
			GameController.Instance.RandomRemoveBlock();
			return;
		}
		interval += Time.deltaTime;
		if (interval >= 1f)
		{
			interval -= 1f;
			timeLeft -= 1f;
			leftTime.text = num + ":" + $"{num2:00}";
		}
	}
}
public class HintRender : MonoBehaviour
{
	public Transform target;

	public Transform startTransform;

	public Vector3 endOffset;

	public bool onFirst;

	private LineRenderer lr;

	private TMP_Text hint;

	private Canvas canvas;

	private Vector3[] positions;

	private Vector3 startPoint;

	private Vector3 endPoint;

	private Vector3 controlPoint;

	private void Awake()
	{
		lr = GetComponentInChildren<LineRenderer>();
		canvas = GetComponentInChildren<Canvas>();
		hint = GetComponentInChildren<TMP_Text>();
		controlPoint = default(Vector3);
		if (!onFirst)
		{
			TurnOff();
		}
	}

	private void Start()
	{
		if (onFirst)
		{
			Translate();
		}
	}

	private void Translate()
	{
		string text = hint.text;
		string valueOf = ISILocalization.GetValueOf(text);
		hint.text = (string.IsNullOrEmpty(valueOf) ? text : valueOf);
	}

	private void Update()
	{
		if (lr.enabled && !(startTransform == null))
		{
			startPoint = startTransform.position;
			endPoint = target.position + endOffset;
			controlPoint.Set(startPoint.x, startPoint.y, endPoint.z);
			positions = GetBeizerList(startPoint, controlPoint, endPoint, 20);
			lr.positionCount = positions.Length;
			lr.SetPositions(positions);
			base.transform.position = target.position + endOffset;
		}
	}

	private Vector3[] GetBeizerList(Vector3 startPoint, Vector3 controlPoint, Vector3 endPoint, int segmentNum)
	{
		Vector3[] array = new Vector3[segmentNum];
		for (int i = 1; i <= segmentNum; i++)
		{
			float t = (float)i / (float)segmentNum;
			Vector3 vector = CalculateCubicBezierPoint(t, startPoint, controlPoint, endPoint);
			array[i - 1] = vector;
		}
		return array;
	}

	private Vector3 CalculateCubicBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2)
	{
		float num = 1f - t;
		float num2 = t * t;
		return num * num * p0 + 2f * num * t * p1 + num2 * p2;
	}

	public void Display(string text)
	{
		lr.enabled = true;
		canvas.enabled = true;
		string valueOf = ISILocalization.GetValueOf(text);
		hint.text = (string.IsNullOrEmpty(valueOf) ? text : valueOf);
		MonoSingleton<VoiceMgr>.Instance().PlayVoice(ISILocalization.GetAudio(text));
	}

	public void TurnOff()
	{
		if (lr.enabled)
		{
			lr.enabled = false;
			canvas.enabled = false;
		}
	}
}
public abstract class InputHandler : MonoSingleton<InputHandler>
{
	internal enum ControllerType
	{
		Left,
		Right
	}

	public Action onMenuKeyDown;

	internal abstract bool IsBackKeyDown();

	internal abstract bool IsQuitKeyDown();

	internal abstract bool IsMenuKeyDown();

	internal abstract bool IsChangeLevelKeyDown();

	internal abstract Vector3 GetControllerVelocity(ControllerType hand);

	internal abstract Interactor GetInteractor(ControllerType hand);

	internal abstract float GetIndexTriggerValue(ControllerType hand);

	internal abstract bool GetIndexTriggerDown(ControllerType hand);

	internal abstract bool GetAButtonDown(ControllerType hand);

	internal abstract float GetHandTriggerValue(ControllerType hand);

	internal abstract Vector2 GetThumbstickValue(ControllerType hand);

	internal abstract void SetContollerVibration(float frequency, float amplitude, ControllerType hand);

	internal abstract bool GetActivateButtonDown(ControllerType m_controller);

	internal abstract bool GetActivateButtonUp(ControllerType m_controller);

	internal abstract bool GetUpKeyDown(ControllerType m_controller);

	internal abstract bool GetDownKeyDown(ControllerType m_controller);

	internal abstract bool GetLeftKeyDown(ControllerType m_controller);

	internal abstract bool GetRightKeyDown(ControllerType m_controller);
}
public class AxisDragInteractable : Interactable
{
	[Serializable]
	public class DragDistanceEvent : UnityEvent<float>
	{
	}

	[Serializable]
	public class DragStepEvent : UnityEvent<int>
	{
	}

	[Tooltip("The Rigidbody that will be moved. If null will try to grab one on that object or its children")]
	public Rigidbody MovingRigidbody;

	public Vector3 LocalAxis;

	public float AxisLength;

	[Tooltip("If 0, then this is a float [0,1] range slider, otherwise there is an integer slider")]
	public int Steps;

	public bool SnapOnlyOnRelease = true;

	public bool ReturnOnFree;

	public float ReturnSpeed;

	public AudioClip SnapAudioClip;

	public DragDistanceEvent OnDragDistance;

	public DragStepEvent OnDragStep;

	private Vector3 m_EndPoint;

	private Vector3 m_StartPoint;

	private Vector3 m_GrabbedOffset;

	private float m_CurrentDistance;

	private int m_CurrentStep;

	private Interactor m_GrabbingInteractor;

	private float m_StepLength;

	protected internal override void Start()
	{
		base.Start();
		LocalAxis.Normalize();
		if (AxisLength < 0f)
		{
			LocalAxis *= -1f;
			AxisLength *= -1f;
		}
		if (Steps == 0)
		{
			m_StepLength = 0f;
		}
		else
		{
			m_StepLength = AxisLength / (float)Steps;
		}
		m_StartPoint = base.transform.position;
		m_EndPoint = base.transform.position + base.transform.TransformDirection(LocalAxis) * AxisLength;
		if (MovingRigidbody == null)
		{
			MovingRigidbody = GetComponentInChildren<Rigidbody>();
		}
		m_CurrentStep = 0;
	}

	public override void ProcessInteractable()
	{
		if (base.isSelected)
		{
			Vector3 rhs = base.transform.TransformDirection(LocalAxis);
			float num = Vector3.Dot(m_GrabbingInteractor.transform.position - base.transform.position - m_GrabbedOffset, rhs);
			if (Steps != 0 && !SnapOnlyOnRelease)
			{
				num = (float)Mathf.RoundToInt(num / m_StepLength) * m_StepLength;
			}
			Vector3 vector = ((!(num > 0f)) ? Vector3.MoveTowards(base.transform.position, m_StartPoint, 0f - num) : Vector3.MoveTowards(base.transform.position, m_EndPoint, num));
			if (Steps > 0)
			{
				int num2 = Mathf.RoundToInt((vector - m_StartPoint).magnitude / m_StepLength);
				if (num2 != m_CurrentStep)
				{
					MonoSingleton<SoundMgr>.Instance().PlaySound(SnapAudioClip, base.transform.position);
					OnDragStep.Invoke(num2);
				}
				m_CurrentStep = num2;
			}
			OnDragDistance.Invoke((vector - m_StartPoint).magnitude);
			Vector3 vector2 = vector - base.transform.position;
			if (MovingRigidbody != null)
			{
				MovingRigidbody.MovePosition(MovingRigidbody.position + vector2);
			}
			else
			{
				base.transform.position = base.transform.position + vector2;
			}
		}
		else if (ReturnOnFree)
		{
			Vector3 vector3 = Vector3.MoveTowards(base.transform.position, m_StartPoint, ReturnSpeed * Time.deltaTime) - base.transform.position;
			if (MovingRigidbody != null)
			{
				MovingRigidbody.MovePosition(MovingRigidbody.position + vector3);
			}
			else
			{
				base.transform.position = base.transform.position + vector3;
			}
		}
	}

	protected internal override void OnSelectEnter(Interactor interactor)
	{
		base.OnSelectEnter(interactor);
		m_GrabbedOffset = interactor.transform.position - base.transform.position;
		m_GrabbingInteractor = interactor;
	}

	protected internal override void OnSelectExit(Interactor interactor)
	{
		base.OnSelectExit(interactor);
		if (SnapOnlyOnRelease && Steps != 0)
		{
			float magnitude = (base.transform.position - m_StartPoint).magnitude;
			int num = Mathf.RoundToInt(magnitude / m_StepLength);
			magnitude = (float)num * m_StepLength;
			base.transform.position = m_StartPoint + base.transform.TransformDirection(LocalAxis) * magnitude;
			if (num != m_CurrentStep)
			{
				MonoSingleton<SoundMgr>.Instance().PlaySound(SnapAudioClip, base.transform.position);
				OnDragStep.Invoke(num);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Vector3 vector = base.transform.position + base.transform.TransformDirection(LocalAxis.normalized) * AxisLength;
		Gizmos.DrawLine(base.transform.position, vector);
		Gizmos.DrawSphere(vector, 0.01f);
	}
}
public class DialInteractable : Interactable
{
	public enum InteractionType
	{
		ControllerRotation,
		ControllerPull
	}

	[Serializable]
	public class DialTurnedAngleEvent : UnityEvent<float>
	{
	}

	[Serializable]
	public class DialTurnedStepEvent : UnityEvent<int>
	{
	}

	[Serializable]
	public class DialChangedEvent : UnityEvent<DialInteractable>
	{
	}

	public InteractionType DialType;

	public Rigidbody RotatingRigidbody;

	public Vector3 LocalRotationAxis;

	public Vector3 LocalAxisStart;

	public float RotationAngleMaximum;

	[Tooltip("If 0, this is a float dial going from 0 to 1, if not 0, that dial is int with that many steps")]
	public int Steps;

	public bool SnapOnRelease = true;

	public AudioClip SnapAudioClip;

	public DialTurnedAngleEvent OnDialAngleChanged;

	public DialTurnedStepEvent OnDialStepChanged;

	public DialChangedEvent OnDialChanged;

	private Interactor m_GrabbingInteractor;

	private Quaternion m_GrabbedRotation;

	private Vector3 m_StartingWorldAxis;

	private float m_CurrentAngle;

	private int m_CurrentStep;

	private float m_StepSize;

	private Transform m_SyncTransform;

	private Transform m_OriginalTransform;

	public float CurrentAngle => m_CurrentAngle;

	public int CurrentStep => m_CurrentStep;

	protected internal override void Start()
	{
		base.Start();
		LocalAxisStart.Normalize();
		LocalRotationAxis.Normalize();
		if (RotatingRigidbody == null)
		{
			RotatingRigidbody = GetComponentInChildren<Rigidbody>();
		}
		m_CurrentAngle = 0f;
		GameObject gameObject = new GameObject("Dial_Start_Copy");
		m_OriginalTransform = gameObject.transform;
		m_OriginalTransform.SetParent(base.transform.parent);
		m_OriginalTransform.localRotation = base.transform.localRotation;
		m_OriginalTransform.localPosition = base.transform.localPosition;
		if (Steps > 0)
		{
			m_StepSize = RotationAngleMaximum / (float)Steps;
		}
		else
		{
			m_StepSize = 0f;
		}
	}

	public override void ProcessInteractable()
	{
		if (!base.isSelected)
		{
			return;
		}
		m_StartingWorldAxis = m_OriginalTransform.TransformDirection(LocalAxisStart);
		Vector3 vector = m_SyncTransform.TransformDirection(LocalAxisStart);
		Vector3 axis = m_SyncTransform.TransformDirection(LocalRotationAxis);
		float num = 0f;
		Vector3 vector2 = vector;
		if (DialType == InteractionType.ControllerRotation)
		{
			vector2 = m_GrabbingInteractor.transform.rotation * Quaternion.Inverse(m_GrabbedRotation) * vector;
			num = Vector3.SignedAngle(m_StartingWorldAxis, vector2, axis);
			if (num < 0f)
			{
				num = 360f + num;
			}
		}
		else
		{
			Vector3 vector3 = m_GrabbingInteractor.transform.position - base.transform.position;
			vector3.Normalize();
			vector2 = vector3;
			num = Vector3.SignedAngle(m_StartingWorldAxis, vector2, axis);
			if (num < 0f)
			{
				num = 360f + num;
			}
		}
		if (num > RotationAngleMaximum)
		{
			float num2 = 360f - num;
			float num3 = num - RotationAngleMaximum;
			num = ((!(num2 < num3)) ? RotationAngleMaximum : 0f);
		}
		float num4 = num;
		if (!SnapOnRelease && Steps > 0)
		{
			int num5 = Mathf.RoundToInt(num / m_StepSize);
			num4 = (float)num5 * m_StepSize;
			if (!Mathf.Approximately(num4, m_CurrentAngle))
			{
				MonoSingleton<SoundMgr>.Instance().PlaySound(SnapAudioClip, base.transform.position);
				OnDialStepChanged.Invoke(num5);
				OnDialChanged.Invoke(this);
				m_CurrentStep = num5;
			}
		}
		vector2 = Quaternion.AngleAxis(num, axis) * m_StartingWorldAxis;
		num = Vector3.SignedAngle(vector, vector2, axis);
		Quaternion rotation = Quaternion.AngleAxis(num, axis) * m_SyncTransform.rotation;
		vector2 = Quaternion.AngleAxis(num4, axis) * m_StartingWorldAxis;
		m_CurrentAngle = num4;
		OnDialAngleChanged.Invoke(num4);
		OnDialChanged.Invoke(this);
		num4 = Vector3.SignedAngle(vector, vector2, axis);
		Quaternion quaternion = Quaternion.AngleAxis(num4, axis) * m_SyncTransform.rotation;
		if (RotatingRigidbody != null)
		{
			RotatingRigidbody.MoveRotation(quaternion);
		}
		else
		{
			base.transform.rotation = quaternion;
		}
		m_SyncTransform.transform.rotation = rotation;
		m_GrabbedRotation = m_GrabbingInteractor.transform.rotation;
	}

	protected internal override void OnSelectEnter(Interactor interactor)
	{
		m_GrabbedRotation = interactor.transform.rotation;
		m_GrabbingInteractor = interactor;
		GameObject gameObject = new GameObject("TEMP_DialSyncTransform");
		m_SyncTransform = gameObject.transform;
		if (RotatingRigidbody != null)
		{
			m_SyncTransform.rotation = RotatingRigidbody.transform.rotation;
			m_SyncTransform.position = RotatingRigidbody.position;
		}
		else
		{
			m_SyncTransform.rotation = base.transform.rotation;
			m_SyncTransform.position = base.transform.position;
		}
		base.OnSelectEnter(interactor);
	}

	protected internal override void OnSelectExit(Interactor interactor)
	{
		base.OnSelectExit(interactor);
		if (SnapOnRelease && Steps > 0)
		{
			Vector3 vector = base.transform.TransformDirection(LocalAxisStart);
			Vector3 axis = base.transform.TransformDirection(LocalRotationAxis);
			float num = Vector3.SignedAngle(m_StartingWorldAxis, vector, axis);
			if (num < 0f)
			{
				num = 360f + num;
			}
			int num2 = Mathf.RoundToInt(num / m_StepSize);
			num = (float)num2 * m_StepSize;
			if (num != m_CurrentAngle)
			{
				MonoSingleton<SoundMgr>.Instance().PlaySound(SnapAudioClip, base.transform.position);
				OnDialStepChanged.Invoke(num2);
				OnDialChanged.Invoke(this);
				m_CurrentStep = num2;
			}
			Vector3 to = Quaternion.AngleAxis(num, axis) * m_StartingWorldAxis;
			num = (m_CurrentAngle = Vector3.SignedAngle(vector, to, axis));
			if (RotatingRigidbody != null)
			{
				Quaternion rot = Quaternion.AngleAxis(num, axis) * RotatingRigidbody.rotation;
				RotatingRigidbody.MoveRotation(rot);
			}
			else
			{
				Quaternion rotation = Quaternion.AngleAxis(num, axis) * base.transform.rotation;
				base.transform.rotation = rotation;
			}
		}
		UnityEngine.Object.Destroy(m_SyncTransform.gameObject);
	}
}
public class Grabbable : MonoBehaviour
{
	[SerializeField]
	protected bool m_allowOffhandGrab = true;

	[SerializeField]
	protected bool m_snapPosition;

	[SerializeField]
	protected bool m_snapOrientation;

	[SerializeField]
	protected Transform m_snapOffset;

	[SerializeField]
	protected Collider[] m_grabPoints;

	protected bool m_grabbedKinematic;

	protected Collider m_grabbedCollider;

	protected Grabber m_grabbedBy;

	public bool allowOffhandGrab
	{
		get
		{
			return m_allowOffhandGrab;
		}
		set
		{
			allowOffhandGrab = value;
		}
	}

	public bool isGrabbed => m_grabbedBy != null;

	public bool snapPosition => m_snapPosition;

	public bool snapOrientation => m_snapOrientation;

	public Transform snapOffset => m_snapOffset;

	public Grabber grabbedBy => m_grabbedBy;

	public Transform grabbedTransform => m_grabbedCollider.transform;

	public Rigidbody grabbedRigidbody => m_grabbedCollider.attachedRigidbody;

	public Collider[] grabPoints => m_grabPoints;

	public virtual void GrabBegin(Grabber hand, Collider grabPoint)
	{
		m_grabbedBy = hand;
		m_grabbedCollider = grabPoint;
		base.gameObject.GetComponent<Rigidbody>().isKinematic = true;
	}

	public virtual void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
	{
		Rigidbody component = base.gameObject.GetComponent<Rigidbody>();
		component.isKinematic = m_grabbedKinematic;
		component.velocity = linearVelocity;
		component.angularVelocity = angularVelocity;
		m_grabbedBy = null;
		m_grabbedCollider = null;
	}

	private void Awake()
	{
		if (m_grabPoints.Length == 0)
		{
			Collider component = GetComponent<Collider>();
			if (component == null)
			{
				throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
			}
			m_grabPoints = new Collider[1] { component };
		}
	}

	protected virtual void Start()
	{
		m_grabbedKinematic = GetComponent<Rigidbody>().isKinematic;
	}

	private void OnDestroy()
	{
		if (m_grabbedBy != null)
		{
			m_grabbedBy.ForceRelease(this);
		}
	}
}
public class GrabInteractable : Interactable
{
	private const float k_DefaultTighteningAmount = 0.5f;

	private const float k_DefaultSmoothingAmount = 5f;

	private const float k_VelocityPredictionFactor = 0.6f;

	private const float k_AngularVelocityDamping = 0.95f;

	private const int k_ThrowSmoothingFrameCount = 20;

	private const float k_DefaultAttachEaseInTime = 0.15f;

	private const float k_DefaultThrowSmoothingDuration = 0.25f;

	private const float k_DefaultThrowVelocityScale = 1.5f;

	private const float k_DefaultThrowAngularVelocityScale = 0.25f;

	[SerializeField]
	private Transform m_AttachTransform;

	[SerializeField]
	private float m_AttachEaseInTime = 0.15f;

	[SerializeField]
	private MovementType m_MovementType = MovementType.Kinematic;

	[SerializeField]
	private bool snapPosition;

	[SerializeField]
	private bool snapRotation;

	[SerializeField]
	private bool m_TrackPosition = true;

	[SerializeField]
	private bool m_SmoothPosition;

	[SerializeField]
	[Range(0f, 20f)]
	private float m_SmoothPositionAmount = 5f;

	[SerializeField]
	[Range(0f, 1f)]
	private float m_TightenPosition = 0.5f;

	[SerializeField]
	private bool m_TrackRotation = true;

	[SerializeField]
	private bool m_SmoothRotation;

	[SerializeField]
	[Range(0f, 20f)]
	private float m_SmoothRotationAmount = 5f;

	[SerializeField]
	[Range(0f, 1f)]
	private float m_TightenRotation = 0.5f;

	[SerializeField]
	private bool m_ThrowOnDetach = true;

	[SerializeField]
	private float m_ThrowSmoothingDuration = 0.25f;

	[SerializeField]
	[Tooltip("The curve to use to weight velocity smoothing (most recent frames to the right.")]
	private AnimationCurve m_ThrowSmoothingCurve = AnimationCurve.Linear(1f, 1f, 1f, 0f);

	[SerializeField]
	private float m_ThrowVelocityScale = 1.5f;

	[SerializeField]
	private float m_ThrowAngularVelocityScale = 0.25f;

	[SerializeField]
	private bool m_GravityOnDetach;

	[SerializeField]
	private bool m_RetainTransformParent = true;

	private bool m_WasKinematic;

	private bool m_UsedGravity;

	private Transform m_OriginalSceneParent;

	private Interactor m_SelectingInteractor;

	private Vector3 m_InteractorLocalPosition;

	private Quaternion m_InteractorLocalRotation;

	private Vector3 m_TargetWorldPosition;

	private Quaternion m_TargetWorldRotation;

	private float m_CurrentAttachEaseTime;

	private MovementType m_CurrentMovementType;

	private bool m_DetachInLateUpdate;

	private Vector3 m_DetachVelocity;

	private Vector3 m_DetachAngularVelocity;

	private int m_ThrowSmoothingCurrentFrame;

	private float[] m_ThrowSmoothingFrameTimes = new float[20];

	private Vector3[] m_ThrowSmoothingVelocityFrames = new Vector3[20];

	private Vector3[] m_ThrowSmoothingAngularVelocityFrames = new Vector3[20];

	private Rigidbody m_RigidBody;

	private Vector3 m_LastPosition;

	private Quaternion m_LastRotation;

	public Transform attachTransform
	{
		get
		{
			return m_AttachTransform;
		}
		set
		{
			m_AttachTransform = value;
		}
	}

	public float attachEaseInTime
	{
		get
		{
			return m_AttachEaseInTime;
		}
		set
		{
			m_AttachEaseInTime = value;
		}
	}

	public MovementType movementType
	{
		get
		{
			return m_MovementType;
		}
		set
		{
			m_MovementType = value;
		}
	}

	public bool trackPosition
	{
		get
		{
			return m_TrackPosition;
		}
		set
		{
			m_TrackPosition = value;
		}
	}

	public bool smoothPosition
	{
		get
		{
			return m_SmoothPosition;
		}
		set
		{
			m_SmoothPosition = value;
		}
	}

	public float smoothPositionAmount
	{
		get
		{
			return m_SmoothPositionAmount;
		}
		set
		{
			m_SmoothPositionAmount = value;
		}
	}

	public float tightenPosition
	{
		get
		{
			return m_TightenPosition;
		}
		set
		{
			m_TightenPosition = value;
		}
	}

	public bool trackRotation
	{
		get
		{
			return m_TrackRotation;
		}
		set
		{
			m_TrackRotation = value;
		}
	}

	public bool smoothRotation
	{
		get
		{
			return m_SmoothRotation;
		}
		set
		{
			m_SmoothRotation = value;
		}
	}

	public float smoothRotationAmount
	{
		get
		{
			return m_SmoothRotationAmount;
		}
		set
		{
			m_SmoothRotationAmount = value;
		}
	}

	public float tightenRotation
	{
		get
		{
			return m_TightenRotation;
		}
		set
		{
			m_TightenRotation = value;
		}
	}

	public bool throwOnDetach
	{
		get
		{
			return m_ThrowOnDetach;
		}
		set
		{
			m_ThrowOnDetach = value;
		}
	}

	public float throwSmoothingDuration
	{
		get
		{
			return m_ThrowSmoothingDuration;
		}
		set
		{
			m_ThrowSmoothingDuration = value;
		}
	}

	public float throwVelocityScale
	{
		get
		{
			return m_ThrowVelocityScale;
		}
		set
		{
			m_ThrowVelocityScale = value;
		}
	}

	public float throwAngularVelocityScale
	{
		get
		{
			return m_ThrowAngularVelocityScale;
		}
		set
		{
			m_ThrowAngularVelocityScale = value;
		}
	}

	public bool gravityOnDetach
	{
		get
		{
			return m_GravityOnDetach;
		}
		set
		{
			m_GravityOnDetach = value;
		}
	}

	public bool retainTransformParent
	{
		get
		{
			return m_RetainTransformParent;
		}
		set
		{
			m_RetainTransformParent = value;
		}
	}

	public Interactor selectingInteractor => m_SelectingInteractor;

	protected override void Awake()
	{
		base.Awake();
		m_CurrentMovementType = m_MovementType;
		if (m_RigidBody == null)
		{
			m_RigidBody = GetComponent<Rigidbody>();
		}
		if (m_RigidBody == null)
		{
			UnityEngine.Debug.LogWarning("Grab Interactable does not have a required RigidBody.", this);
		}
		m_WasKinematic = m_RigidBody.isKinematic;
		m_UsedGravity = m_RigidBody.useGravity;
	}

	private void Update()
	{
		if (base.isSelected)
		{
			UpdateTarget(Time.unscaledDeltaTime);
			SmoothVelocityUpdate();
			if (m_CurrentMovementType == MovementType.Instantaneous)
			{
				PerformInstantaneousUpdate(Time.unscaledDeltaTime);
			}
		}
	}

	private void LateUpdate()
	{
		if (m_DetachInLateUpdate)
		{
			if (!m_SelectingInteractor)
			{
				Detach();
			}
			m_DetachInLateUpdate = false;
		}
	}

	public override void ProcessInteractable()
	{
		if (base.isSelected)
		{
			if (m_CurrentMovementType == MovementType.Kinematic)
			{
				PerformKinematicUpdate(Time.unscaledDeltaTime);
			}
			else if (m_CurrentMovementType == MovementType.VelocityTracking)
			{
				PerformVelocityTrackingUpdate(Time.unscaledDeltaTime);
			}
		}
	}

	private Vector3 GetWorldAttachPosition(Interactor interactor)
	{
		return interactor.attachTransform.position + interactor.attachTransform.rotation * m_InteractorLocalPosition;
	}

	private Quaternion GetWorldAttachRotation(Interactor interactor)
	{
		return interactor.attachTransform.rotation * m_InteractorLocalRotation;
	}

	private void UpdateTarget(float timeDelta)
	{
		if (m_AttachEaseInTime > 0f && m_CurrentAttachEaseTime <= m_AttachEaseInTime)
		{
			float t = m_CurrentAttachEaseTime / m_AttachEaseInTime;
			m_TargetWorldPosition = Vector3.Lerp(m_TargetWorldPosition, GetWorldAttachPosition(m_SelectingInteractor), t);
			m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), t);
			m_CurrentAttachEaseTime += Time.unscaledDeltaTime;
			return;
		}
		if (m_SmoothPosition)
		{
			m_TargetWorldPosition = Vector3.Lerp(m_TargetWorldPosition, GetWorldAttachPosition(m_SelectingInteractor), m_SmoothPositionAmount * timeDelta);
			m_TargetWorldPosition = Vector3.Lerp(m_TargetWorldPosition, GetWorldAttachPosition(m_SelectingInteractor), m_TightenPosition);
		}
		else
		{
			m_TargetWorldPosition = GetWorldAttachPosition(m_SelectingInteractor);
		}
		if (m_SmoothRotation)
		{
			m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), m_SmoothRotationAmount * timeDelta);
			m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), m_TightenRotation);
		}
		else
		{
			m_TargetWorldRotation = GetWorldAttachRotation(m_SelectingInteractor);
		}
	}

	private void PerformKinematicUpdate(float timeDelta)
	{
		if (trackPosition)
		{
			Vector3 vector = m_TargetWorldPosition - m_RigidBody.worldCenterOfMass;
			m_RigidBody.velocity = Vector3.zero;
			m_RigidBody.MovePosition(m_RigidBody.position + vector);
		}
		if (trackRotation)
		{
			m_RigidBody.angularVelocity = Vector3.zero;
			m_RigidBody.MoveRotation(m_TargetWorldRotation.normalized);
		}
	}

	private void PerformVelocityTrackingUpdate(float timeDelta)
	{
		if (trackPosition)
		{
			m_RigidBody.velocity *= 0.6f;
			Vector3 vector = (m_TargetWorldPosition - m_RigidBody.worldCenterOfMass) / timeDelta;
			if (!float.IsNaN(vector.x))
			{
				m_RigidBody.velocity += vector;
			}
		}
		if (!trackRotation)
		{
			return;
		}
		m_RigidBody.angularVelocity *= 0.6f;
		(m_TargetWorldRotation * Quaternion.Inverse(m_RigidBody.rotation)).ToAngleAxis(out var angle, out var axis);
		if (angle > 180f)
		{
			angle -= 360f;
		}
		if (Mathf.Abs(angle) > Mathf.Epsilon)
		{
			Vector3 vector2 = axis * angle * ((float)Math.PI / 180f) / timeDelta;
			if (!float.IsNaN(vector2.x))
			{
				m_RigidBody.angularVelocity += vector2 * 0.95f;
			}
		}
	}

	private void PerformInstantaneousUpdate(float timeDelta)
	{
		if (trackPosition)
		{
			base.transform.position = m_TargetWorldPosition;
		}
		if (trackRotation)
		{
			base.transform.rotation = m_TargetWorldRotation;
		}
	}

	private void Teleport(Transform teleportTransform)
	{
		if (trackPosition)
		{
			Vector3 translation = teleportTransform.position - m_RigidBody.worldCenterOfMass;
			m_RigidBody.velocity = Vector3.zero;
			base.transform.Translate(translation, Space.World);
		}
		if (trackRotation)
		{
			m_RigidBody.angularVelocity = Vector3.zero;
			m_RigidBody.transform.rotation = teleportTransform.rotation;
		}
	}

	private void Detach()
	{
		if (m_ThrowOnDetach)
		{
			m_RigidBody.velocity = m_DetachVelocity;
			m_RigidBody.angularVelocity = m_DetachAngularVelocity;
		}
	}

	private void UpdateInteractorLocalPose(Interactor interactor)
	{
		Transform transform = (m_AttachTransform ? m_AttachTransform : base.transform);
		Vector3 vector = (m_AttachTransform ? m_AttachTransform.position : m_RigidBody.worldCenterOfMass);
		Vector3 direction = m_RigidBody.worldCenterOfMass - vector;
		Vector3 interactorLocalPosition = transform.InverseTransformDirection(direction);
		Vector3 lossyScale = interactor.attachTransform.lossyScale;
		lossyScale = new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z);
		interactorLocalPosition.Scale(lossyScale);
		m_InteractorLocalPosition = interactorLocalPosition;
		m_InteractorLocalRotation = Quaternion.Inverse(Quaternion.Inverse(m_RigidBody.rotation) * transform.rotation);
	}

	protected internal override void OnSelectEnter(Interactor interactor)
	{
		if ((bool)interactor)
		{
			base.OnSelectEnter(interactor);
			if (m_SelectingInteractor == null)
			{
				m_OriginalSceneParent = base.transform.parent;
				base.transform.parent = null;
			}
			m_SelectingInteractor = interactor;
			m_RigidBody.isKinematic = m_CurrentMovementType == MovementType.Kinematic;
			m_RigidBody.useGravity = false;
			m_RigidBody.drag = 0f;
			m_RigidBody.angularDrag = 0f;
			m_DetachVelocity = (m_DetachAngularVelocity = Vector3.zero);
			UpdateInteractorLocalPose(interactor);
			if (false)
			{
				Teleport(m_SelectingInteractor.attachTransform);
			}
			else if (m_AttachEaseInTime > 0f)
			{
				m_TargetWorldPosition = m_RigidBody.worldCenterOfMass;
				m_TargetWorldRotation = base.transform.rotation;
				m_CurrentAttachEaseTime = 0f;
			}
			SmoothVelocityStart();
		}
	}

	protected internal override void OnSelectExit(Interactor interactor)
	{
		base.OnSelectExit(interactor);
		if (m_RetainTransformParent)
		{
			base.transform.parent = m_OriginalSceneParent;
		}
		m_RigidBody.isKinematic = m_WasKinematic;
		m_RigidBody.useGravity = m_UsedGravity | m_GravityOnDetach;
		m_CurrentMovementType = m_MovementType;
		m_SelectingInteractor = null;
		m_DetachInLateUpdate = true;
		SmoothVelocityEnd();
	}

	private void SmoothVelocityStart()
	{
		if ((bool)m_SelectingInteractor)
		{
			m_LastPosition = m_SelectingInteractor.attachTransform.position;
			m_LastRotation = m_SelectingInteractor.attachTransform.rotation;
			Array.Clear(m_ThrowSmoothingFrameTimes, 0, m_ThrowSmoothingFrameTimes.Length);
			Array.Clear(m_ThrowSmoothingVelocityFrames, 0, m_ThrowSmoothingVelocityFrames.Length);
			Array.Clear(m_ThrowSmoothingAngularVelocityFrames, 0, m_ThrowSmoothingAngularVelocityFrames.Length);
			m_ThrowSmoothingCurrentFrame = 0;
		}
	}

	private void SmoothVelocityEnd()
	{
		if (m_ThrowOnDetach)
		{
			Vector3 smoothedVelocityValue = getSmoothedVelocityValue(m_ThrowSmoothingVelocityFrames);
			Vector3 smoothedVelocityValue2 = getSmoothedVelocityValue(m_ThrowSmoothingAngularVelocityFrames);
			m_DetachVelocity = smoothedVelocityValue * m_ThrowVelocityScale;
			m_DetachAngularVelocity = smoothedVelocityValue2 * m_ThrowAngularVelocityScale;
		}
	}

	private void SmoothVelocityUpdate()
	{
		if ((bool)m_SelectingInteractor)
		{
			m_ThrowSmoothingFrameTimes[m_ThrowSmoothingCurrentFrame] = Time.time;
			m_ThrowSmoothingVelocityFrames[m_ThrowSmoothingCurrentFrame] = (m_SelectingInteractor.attachTransform.position - m_LastPosition) / Time.deltaTime;
			Quaternion quaternion = m_SelectingInteractor.attachTransform.rotation * Quaternion.Inverse(m_LastRotation);
			m_ThrowSmoothingAngularVelocityFrames[m_ThrowSmoothingCurrentFrame] = new Vector3(Mathf.DeltaAngle(0f, quaternion.eulerAngles.x), Mathf.DeltaAngle(0f, quaternion.eulerAngles.y), Mathf.DeltaAngle(0f, quaternion.eulerAngles.z)) / Time.deltaTime * ((float)Math.PI / 180f);
			m_ThrowSmoothingCurrentFrame = (m_ThrowSmoothingCurrentFrame + 1) % 20;
			m_LastPosition = m_SelectingInteractor.attachTransform.position;
			m_LastRotation = m_SelectingInteractor.attachTransform.rotation;
		}
	}

	private Vector3 getSmoothedVelocityValue(Vector3[] velocityFrames)
	{
		Vector3 vector = default(Vector3);
		int i = 0;
		float num = 0f;
		for (; i < 20; i++)
		{
			int num2 = ((m_ThrowSmoothingCurrentFrame - i - 1) % 20 + 20) % 20;
			if (m_ThrowSmoothingFrameTimes[num2] == 0f)
			{
				break;
			}
			float num3 = (Time.time - m_ThrowSmoothingFrameTimes[num2]) / m_ThrowSmoothingDuration;
			float num4 = m_ThrowSmoothingCurve.Evaluate(Mathf.Clamp(1f - num3, 0f, 1f));
			vector += velocityFrames[num2] * num4;
			num += num4;
			if (Time.time - m_ThrowSmoothingFrameTimes[num2] > m_ThrowSmoothingDuration)
			{
				break;
			}
		}
		if (num > 0f)
		{
			return vector / num;
		}
		return Vector3.zero;
	}
}
public abstract class Interactable : MonoBehaviourPun
{
	public enum MovementType
	{
		VelocityTracking,
		Kinematic,
		Instantaneous
	}

	[Serializable]
	public class InteractorEvent : UnityEvent<Interactor>
	{
	}

	public InteractorEvent m_OnSelectEnter;

	public InteractorEvent m_OnSelectExit;

	public InteractorEvent m_OnHoverEnter;

	public InteractorEvent m_OnHoverExit;

	public InteractorEvent m_OnActivate;

	public InteractorEvent m_OnDeactivate;

	[SerializeField]
	protected Collider[] m_interactablePoints;

	protected Interactor m_interactedBy;

	protected bool m_Kinematic;

	protected Collider m_interactedCollider;

	private static AudioClip collisionSound;

	private Renderer[] renderes;

	private Color highlightColor = new Color(0.2f, 0.8f, 0.7f);

	private SoundMgr.PlayParameters soundPara;

	public Collider[] interactablePoints => m_interactablePoints;

	public Interactor interactedBy => m_interactedBy;

	public bool isHovered { get; private set; }

	public bool isSelected { get; private set; }

	public bool isInteracted => m_interactedBy != null;

	protected virtual void Awake()
	{
		if (m_interactablePoints.Length == 0)
		{
			Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
			if (componentsInChildren == null || componentsInChildren.Length == 0)
			{
				throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
			}
			m_interactablePoints = componentsInChildren;
		}
	}

	protected internal virtual void Start()
	{
		renderes = GetComponentsInChildren<Renderer>();
		Highlight(on: false);
		if (collisionSound == null)
		{
			collisionSound = Resources.Load<AudioClip>("hitobject");
		}
		soundPara = new SoundMgr.PlayParameters
		{
			Pitch = 1f,
			SourceID = 1000 + GetInstanceID(),
			Volume = 0.5f
		};
	}

	public void Highlight(bool on)
	{
		if (renderes == null)
		{
			return;
		}
		if (on)
		{
			Renderer[] array = renderes;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].material.SetColor("_EmissionColor", highlightColor);
			}
		}
		else
		{
			Renderer[] array = renderes;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].material.SetColor("_EmissionColor", Color.black);
			}
		}
	}

	private void FixedUpdate()
	{
		ProcessInteractable();
	}

	protected internal virtual void OnSelectEnter(Interactor interactor)
	{
		UnityEngine.Debug.Log("OnSelectEnter");
		isSelected = true;
		MonoSingleton<InputHandler>.Instance().SetContollerVibration(0.05f, 0.2f, interactor.m_controller);
		Highlight(on: false);
		m_OnSelectEnter?.Invoke(interactor);
	}

	protected internal virtual void OnSelectExit(Interactor interactor)
	{
		UnityEngine.Debug.Log("OnSelectExit");
		isSelected = false;
		MonoSingleton<InputHandler>.Instance().SetContollerVibration(0f, 0f, interactor.m_controller);
		Highlight(on: false);
		m_OnSelectExit?.Invoke(interactor);
	}

	protected internal virtual void OnHoverEnter(Interactor interactor)
	{
		UnityEngine.Debug.Log("OnHoverEnter");
		isHovered = true;
		m_OnHoverEnter?.Invoke(interactor);
	}

	private void OnCollisionEnter(Collision collision)
	{
		_ = Time.timeSinceLevelLoad;
		_ = 1f;
	}

	protected internal virtual void OnHoverExit(Interactor interactor)
	{
		UnityEngine.Debug.Log("OnHoverExit");
		isHovered = false;
		Highlight(on: false);
		m_OnHoverExit?.Invoke(interactor);
	}

	protected internal virtual void OnActivate(Interactor interactor)
	{
		UnityEngine.Debug.Log("OnActivate");
		m_OnActivate?.Invoke(interactor);
	}

	protected internal virtual void OnDeactivate(Interactor interactor)
	{
		UnityEngine.Debug.Log("OnDeactivate");
		m_OnDeactivate?.Invoke(interactor);
	}

	public virtual void ProcessInteractable()
	{
	}

	public virtual void GrabBegin(Interactor interactor)
	{
		m_interactedBy = interactor;
	}

	public virtual void GrabEnd()
	{
		m_interactedBy = null;
	}
}
public class OffsetGrabbable : GrabInteractable
{
	private class SavedTransform
	{
		public Vector3 OriginalPosition;

		public Quaternion OriginalRotation;
	}

	private Dictionary<Interactor, SavedTransform> m_SavedTransforms = new Dictionary<Interactor, SavedTransform>();

	private Rigidbody m_Rb;

	protected override void Awake()
	{
		base.Awake();
		m_Rb = GetComponent<Rigidbody>();
	}

	protected internal override void OnSelectEnter(Interactor interactor)
	{
		SavedTransform savedTransform = new SavedTransform();
		savedTransform.OriginalPosition = interactor.attachTransform.localPosition;
		savedTransform.OriginalRotation = interactor.attachTransform.localRotation;
		m_SavedTransforms[interactor] = savedTransform;
		bool flag = base.attachTransform != null;
		interactor.attachTransform.position = (flag ? base.attachTransform.position : m_Rb.worldCenterOfMass);
		interactor.attachTransform.rotation = (flag ? base.attachTransform.rotation : m_Rb.rotation);
		base.OnSelectEnter(interactor);
	}

	protected internal override void OnSelectExit(Interactor interactor)
	{
		SavedTransform value = null;
		if (m_SavedTransforms.TryGetValue(interactor, out value))
		{
			interactor.attachTransform.localPosition = value.OriginalPosition;
			interactor.attachTransform.localRotation = value.OriginalRotation;
			m_SavedTransforms.Remove(interactor);
		}
		base.OnSelectExit(interactor);
	}
}
public class RotationInteractable : Interactable
{
	public Rigidbody RotatingRigidbody;

	public Vector3 LocalRotationAxis;

	public Vector3 LocalAxisStart;

	public float RotationAngleMaximum;

	private Quaternion start;

	private float outAngle;

	private Vector3 lastHandProjected;

	private Interactor m_GrabbingInteractor;

	private Transform m_SyncTransform;

	private Transform m_OriginalTransform;

	private Vector3 m_StartingWorldAxis;

	private Vector3 worldPlaneNormal;

	protected internal override void Start()
	{
		base.Start();
		if (RotatingRigidbody == null)
		{
			RotatingRigidbody = GetComponentInChildren<Rigidbody>();
		}
		outAngle = 0f;
		start = RotatingRigidbody.rotation;
		if ((bool)RotatingRigidbody.transform.parent)
		{
			worldPlaneNormal = RotatingRigidbody.transform.parent.localToWorldMatrix.MultiplyVector(LocalRotationAxis).normalized;
		}
		GameObject gameObject = new GameObject("Rotation_Start_Copy");
		m_OriginalTransform = gameObject.transform;
		m_OriginalTransform.SetParent(base.transform.parent);
		m_OriginalTransform.localRotation = base.transform.localRotation;
		m_OriginalTransform.localPosition = base.transform.localPosition;
	}

	protected internal override void OnSelectEnter(Interactor interactor)
	{
		m_GrabbingInteractor = interactor;
		GameObject gameObject = new GameObject("TEMP_RotSyncTransform");
		m_SyncTransform = gameObject.transform;
		if (RotatingRigidbody != null)
		{
			m_SyncTransform.rotation = RotatingRigidbody.transform.rotation;
			m_SyncTransform.position = RotatingRigidbody.position;
		}
		else
		{
			m_SyncTransform.rotation = base.transform.rotation;
			m_SyncTransform.position = base.transform.position;
		}
		lastHandProjected = ComputeToTransformProjected(interactor.attachTransform);
		ComputeAngle(interactor);
		Quaternion quaternion = start * Quaternion.AngleAxis(outAngle, LocalRotationAxis);
		if (RotatingRigidbody != null)
		{
			RotatingRigidbody.MoveRotation(quaternion);
		}
		else
		{
			base.transform.rotation = quaternion;
		}
		base.OnSelectEnter(interactor);
	}

	private void ComputeAngle(Interactor interactor)
	{
		Vector3 vector = ComputeToTransformProjected(interactor.attachTransform);
		if (vector.Equals(lastHandProjected))
		{
			return;
		}
		float num = Vector3.Angle(lastHandProjected, vector);
		if (num > 0f)
		{
			Vector3 normalized = Vector3.Cross(lastHandProjected, vector).normalized;
			float num2 = Vector3.Dot(worldPlaneNormal, normalized);
			float num3 = num;
			if (num2 < 0f)
			{
				num3 = 0f - num3;
			}
			outAngle += num3;
			lastHandProjected = vector;
		}
	}

	protected internal override void OnSelectExit(Interactor interactor)
	{
		base.OnSelectExit(interactor);
		UnityEngine.Object.Destroy(m_SyncTransform.gameObject);
	}

	public override void ProcessInteractable()
	{
		if (base.isSelected)
		{
			ComputeAngle(m_GrabbingInteractor);
			UnityEngine.Debug.Log("outAngle:" + outAngle);
			Quaternion quaternion = start * Quaternion.AngleAxis(outAngle, LocalRotationAxis);
			if (RotatingRigidbody != null)
			{
				RotatingRigidbody.MoveRotation(quaternion);
			}
			else
			{
				base.transform.rotation = quaternion;
			}
		}
	}

	private Vector3 ComputeToTransformProjected(Transform xForm)
	{
		Vector3 normalized = (xForm.position - RotatingRigidbody.transform.position).normalized;
		Vector3 result = new Vector3(0f, 0f, 0f);
		if (normalized.sqrMagnitude > 0f)
		{
			return Vector3.ProjectOnPlane(normalized, worldPlaneNormal).normalized;
		}
		UnityEngine.Debug.LogFormat("The collider needs to be a minimum distance away from the CircularDrive GameObject {0}", base.gameObject.ToString());
		return result;
	}
}
public class Outline : MonoBehaviour
{
	public bool highlight;

	private static float t;

	private Material material;

	private float intensity;

	private float maximum = 1f;

	private float minimum = 0.3f;

	private float speed = 1f;

	private void Start()
	{
		material = GetComponent<Renderer>().material;
		intensity = material.GetFloat("_Intensity");
	}

	private void Update()
	{
		if (highlight)
		{
			SwitchAlpha();
		}
	}

	private void SwitchAlpha()
	{
		float num = Mathf.Lerp(minimum, maximum, t);
		intensity = num;
		material.SetFloat("_Intensity", intensity);
		t += speed * Time.deltaTime;
		if (t > 1f)
		{
			float num2 = maximum;
			maximum = minimum;
			minimum = num2;
			t = 0f;
		}
	}

	public void HighLight()
	{
		highlight = true;
		t = 0f;
	}

	public void UndoHighlight()
	{
		intensity = 0f;
		material.SetFloat("_Intensity", intensity);
		highlight = false;
	}
}
public class SoundMgr : MonoSingleton<SoundMgr>
{
	public struct PlayParameters
	{
		public float Pitch;

		public float Volume;

		public int SourceID;

		public bool Loop;
	}

	public class PlayEvent
	{
		public float Time;
	}

	public AudioSource referenceSource;

	public int sourceCount;

	private Dictionary<int, PlayEvent> m_PlayEvents = new Dictionary<int, PlayEvent>();

	private List<int> m_PlayingSources = new List<int>();

	private AudioSource[] sourcePool;

	private int m_UsedSource;

	private List<int> IDToRemove = new List<int>();

	private void Awake()
	{
		sourcePool = new AudioSource[sourceCount];
		for (int i = 0; i < sourceCount; i++)
		{
			sourcePool[i] = UnityEngine.Object.Instantiate(referenceSource, base.transform);
			sourcePool[i].gameObject.SetActive(value: false);
		}
	}

	private void Update()
	{
		IDToRemove.Clear();
		foreach (KeyValuePair<int, PlayEvent> playEvent in m_PlayEvents)
		{
			playEvent.Value.Time -= Time.deltaTime;
			if (playEvent.Value.Time <= 0f)
			{
				IDToRemove.Add(playEvent.Key);
			}
		}
		foreach (int item in IDToRemove)
		{
			m_PlayEvents.Remove(item);
		}
		int num;
		for (num = 0; num < m_PlayingSources.Count; num++)
		{
			int num2 = m_PlayingSources[num];
			if (!sourcePool[num2].isPlaying)
			{
				sourcePool[num2].gameObject.SetActive(value: false);
			}
			m_PlayingSources.RemoveAt(num);
			num--;
		}
	}

	public AudioSource GetNewSource()
	{
		return UnityEngine.Object.Instantiate(referenceSource);
	}

	public void PlaySound(AudioClip clip, Vector3 position, float delayedTime = 0f)
	{
		PlaySound(clip, position, delayedTime, new PlayParameters
		{
			Pitch = 1f,
			SourceID = 1000 + int.Parse(DateTime.Now.ToString("HHmmssfff")),
			Volume = 1f,
			Loop = false
		});
	}

	public void PlaySound(AudioClip clip)
	{
		PlaySound(clip, base.transform.position, 0f, new PlayParameters
		{
			Pitch = 1f,
			SourceID = 1000 + int.Parse(DateTime.Now.ToString("HHmmssfff")),
			Volume = 1f,
			Loop = false
		});
	}

	public void PauseSound(AudioClip clip)
	{
		if (clip == null)
		{
			return;
		}
		for (int i = 0; i < m_PlayingSources.Count; i++)
		{
			if (clip.name.Equals(sourcePool[i].clip.name))
			{
				sourcePool[i].Pause();
				break;
			}
		}
	}

	public void StopSound(AudioClip clip)
	{
		if (clip == null)
		{
			return;
		}
		for (int i = 0; i < m_PlayingSources.Count; i++)
		{
			if (clip.name.Equals(sourcePool[i].clip.name))
			{
				sourcePool[i].Stop();
			}
		}
	}

	public void PlaySound(AudioClip clip, Vector3 position, float delayedTime, PlayParameters parameters, float cooldownTime = 0.5f)
	{
		if (!(clip == null) && !m_PlayEvents.ContainsKey(parameters.SourceID))
		{
			AudioSource obj = sourcePool[m_UsedSource];
			m_PlayingSources.Add(m_UsedSource);
			m_UsedSource++;
			if (m_UsedSource >= sourcePool.Length)
			{
				m_UsedSource = 0;
			}
			obj.gameObject.SetActive(value: true);
			obj.transform.position = position;
			obj.clip = clip;
			obj.volume = parameters.Volume;
			obj.pitch = parameters.Pitch;
			obj.loop = parameters.Loop;
			m_PlayEvents.Add(parameters.SourceID, new PlayEvent
			{
				Time = cooldownTime
			});
			obj.PlayDelayed(delayedTime);
		}
	}
}
public class Statistics : MonoSingleton<Statistics>
{
	private class Round
	{
		public long start_ts;

		public long end_ts;

		public int level;

		public bool isCorrect;
	}

	private List<Round> rounds = new List<Round>();

	private Round currentRound;

	private void Awake()
	{
		Statistics statistics = UnityEngine.Object.FindObjectOfType<Statistics>();
		if (statistics != null && statistics != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void RoundStart(int level)
	{
		long timeStamp = GetTimeStamp();
		currentRound = new Round();
		currentRound.start_ts = timeStamp;
		currentRound.level = level;
		rounds.Add(currentRound);
	}

	public void RoundEnd(bool isCorrect)
	{
		long timeStamp = GetTimeStamp();
		if (currentRound != null)
		{
			currentRound.end_ts = timeStamp;
			currentRound.isCorrect = isCorrect;
		}
	}

	public int GetGrade()
	{
		int num = 0;
		int num2 = 3;
		double[] array = new double[3];
		int[] array2 = new int[3];
		foreach (Round round in rounds)
		{
			int num3 = round.level / num2;
			if (num3 > 2)
			{
				num3 = 2;
			}
			array2[num3]++;
			if (round.isCorrect)
			{
				array[num3] += 1.0;
			}
		}
		for (int i = 0; i < array.Length; i++)
		{
			if (array2[i] > 0)
			{
				array[i] /= array2[i];
			}
			UnityEngine.Debug.Log(">>> stage: " + i + ", correct rate: " + array[i]);
			if (array[i] > 0.9)
			{
				num = i + 1;
			}
		}
		UnityEngine.Debug.Log("score: " + num);
		return num;
	}

	private static long GetTimeStamp(bool useMilliSecond = false)
	{
		TimeSpan timeSpan = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);
		return Convert.ToInt64(useMilliSecond ? timeSpan.TotalMilliseconds : timeSpan.TotalSeconds);
	}
}
public class VoiceMgr : MonoSingleton<VoiceMgr>
{
	public AudioSource reference;

	private List<AudioSource> voices;

	private void Awake()
	{
		voices = new List<AudioSource>();
		GetComponents(voices);
	}

	public AudioSource PlayVoice(string name, float time = 0f)
	{
		if (string.IsNullOrEmpty(name))
		{
			return null;
		}
		AudioSource result = null;
		for (int i = 0; i < voices.Count; i++)
		{
			if (name.Equals(voices[i].clip.name))
			{
				voices[i].PlayDelayed(time);
				result = voices[i];
			}
			else if (voices[i].isPlaying)
			{
				voices[i].Stop();
			}
		}
		return result;
	}

	public void PlayVoice(AudioClip clip, float time = 0f)
	{
		if (!(clip == null) && PlayVoice(clip.name, time) == null)
		{
			AudioSource audioSource = UnityEngine.Object.Instantiate(reference, base.transform);
			audioSource.clip = clip;
			audioSource.PlayDelayed(time);
			voices.Add(audioSource);
		}
	}

	public AudioSource GetVoice(string name)
	{
		for (int i = 0; i < voices.Count; i++)
		{
			if (name.Equals(voices[i].clip.name))
			{
				return voices[i];
			}
		}
		return null;
	}
}
public class DropHandler : MonoBehaviour
{
	public bool reborn = true;

	private static ParticleSystem birth;

	private static ParticleSystem disappear;

	private Vector3 originPos;

	private Quaternion originRot;

	private static AudioClip disappearSound;

	public Action onBirth;

	public Transform spawnPoint;

	private void Awake()
	{
		if (birth == null)
		{
			GameObject gameObject = GameObject.Find("Light");
			if (gameObject != null)
			{
				birth = gameObject.GetComponent<ParticleSystem>();
			}
		}
		if (disappear == null)
		{
			GameObject gameObject2 = GameObject.Find("ZhaLie");
			if (gameObject2 != null)
			{
				disappear = gameObject2.GetComponent<ParticleSystem>();
			}
		}
	}

	private void Start()
	{
		RecordOrigin();
		if (disappearSound == null)
		{
			disappearSound = Resources.Load<AudioClip>("disappear");
		}
	}

	public void RecordOrigin()
	{
		originPos = base.transform.position;
		originRot = base.transform.rotation;
	}

	private void Update()
	{
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.gameObject.layer == LayerMask.NameToLayer("Ground"))
		{
			Invoke("Reset", 0.5f);
		}
	}

	public void Reset()
	{
		if (disappear != null)
		{
			disappear.transform.position = base.transform.position;
			disappear.Play();
			MonoSingleton<SoundMgr>.Instance().PlaySound(disappearSound, base.transform.position);
		}
		if (reborn)
		{
			Invoke("Birth", 0.5f);
		}
		else
		{
			UnityEngine.Object.Destroy(base.transform.gameObject, 0.5f);
		}
	}

	private void Birth()
	{
		base.transform.position = ((spawnPoint == null) ? originPos : spawnPoint.position);
		base.transform.rotation = originRot;
		if (birth != null)
		{
			birth.transform.position = base.transform.position;
			birth.Play();
			onBirth?.Invoke();
		}
	}

	public void RestoreTransform()
	{
		base.transform.position = originPos;
		base.transform.rotation = originRot;
	}
}
public class GameController : MonoBehaviour
{
	public bool releaseVersion;

	public static GameController Instance { get; private set; }

	private void Awake()
	{
		Instance = this;
		UnityEngine.Debug.unityLogger.logEnabled = !releaseVersion;
	}

	private void Start()
	{
		InitMainMenu();
		ISILocalization.ChangeLanguage(Language.Chinese);
		GameView.Instance.ShowTipPanel();
	}

	private void Update()
	{
		if (MonoSingleton<InputHandler>.Instance().IsMenuKeyDown() || Input.GetKeyDown(KeyCode.Space))
		{
			EndMatch();
		}
	}

	public void InitMainMenu()
	{
		GameModel.Instance.ChangeGameState(new MainMenuGameState());
	}

	public void StartMultiplayerGame(bool joinRandom = true)
	{
		GameModel.Instance.ChangeGameState(new ConnectingGameState());
		GameView.Instance.ShowNetworkPanel();
		if (joinRandom)
		{
			NetworkController.Instance.StartMultiplayerGame();
		}
		else
		{
			NetworkController.Instance.StartNewGame();
		}
	}

	public void StartNewGame()
	{
		StartMultiplayerGame(joinRandom: false);
	}

	public void InitSingleGame()
	{
		GameModel.Instance.CreateDummyPlayer();
		TurnMgr.Instance.ChangePlayerTo(PhotonNetwork.MasterClient);
		GameModel.Instance.InitRoundData();
	}

	public void RemoveBlock(GameObject block)
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("Wand");
		for (int i = 0; i < array.Length; i++)
		{
			if (PhotonView.Get(array[i]) != null && PhotonView.Get(array[i]).IsMine)
			{
				array[i].GetComponent<Wand>().RemoveBlockByPlayer(block);
			}
		}
	}

	public void RandomRemoveBlock()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("BlockItem");
		if (array != null && array.Length != 0)
		{
			RemoveBlock(array[UnityEngine.Random.Range(0, array.Length)]);
		}
	}

	public void OnMatchButtonPressed()
	{
		StartMultiplayerGame();
	}

	public void EndMatch()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			NetworkController.Instance.NotifyGameEnded();
		}
		else
		{
			LeaveMatch();
		}
	}

	public void LeaveMatch()
	{
		Cleanup();
		NetworkController.Instance.EndMultiplayerGame();
		GameModel.Instance.ChangeGameState(new MainMenuGameState());
	}

	public void RepeatMatch()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			GameModel.Instance.InitRoundData();
			GameModel.Instance.ChangeGameState(new PlayingGameState());
			NetworkController.Instance.NotifyChangeToPlayingState();
		}
		else
		{
			GameView.Instance.ShowGamePopupPanel("master");
		}
	}

	public void QuitGame()
	{
		Application.Quit();
	}

	private void Cleanup()
	{
		GameModel.Instance.isStarted = false;
		PhotonNetwork.LocalPlayer.CustomProperties.Clear();
		if (GameModel.Instance.CurrentPlayer != null)
		{
			PhotonNetwork.Destroy(GameModel.Instance.CurrentPlayer.GameObject);
		}
	}

	public void OnDisconnected(DisconnectCause cause)
	{
		UnityEngine.Debug.LogFormat("OnDisconnected() was called ({0}).", cause);
		if (GameModel.Instance.IsInGame())
		{
			UnityEngine.Debug.LogWarning("Trying to rejoin game...");
			if (!PhotonNetwork.ReconnectAndRejoin())
			{
				UnityEngine.Debug.LogWarning("Rejoining game failed, please start a new game!");
				GameView.Instance.ShowGamePopupPanel("", "");
				Cleanup();
				InitMainMenu();
			}
		}
	}
}
public class GameModel : MonoBehaviour
{
	[HideInInspector]
	public bool isStarted;

	private int currentLevel;

	[HideInInspector]
	public int _winnerBonus = 300;

	private bool _reloaded;

	[SerializeField]
	private PlayerFactory _playerFactory;

	private BaseGameState _activeGameState;

	public Dictionary<int, int> ScoreBoard { get; set; }

	public Dictionary<int, int> PlayersPositions { get; set; }

	public bool Reloaded
	{
		get
		{
			return _reloaded;
		}
		set
		{
			_reloaded = value;
		}
	}

	public Player WinningPlayer
	{
		get
		{
			if (Instance.IsSinglePlayer())
			{
				if (!TurnMgr.Instance.IsRobotTurn)
				{
					return TurnMgr.Instance.CurrentPlayer;
				}
				return null;
			}
			return TurnMgr.Instance.CurrentPlayer;
		}
	}

	public Player FinalWinningPlayer
	{
		get
		{
			int num = (LevelMgr.Instance.GetRoundLevelCount() + 1) / 2;
			Player[] playerList = PhotonNetwork.PlayerList;
			foreach (Player player in playerList)
			{
				if ((int)player.CustomProperties["roundScore"] >= num)
				{
					return player;
				}
			}
			return null;
		}
	}

	public Player SingleWinningPlayer { get; set; }

	public BaseGameState ActiveGameState => _activeGameState;

	public IPlayer CurrentPlayer { get; set; }

	public Wand DummyWand { get; set; }

	public bool IsDummyTurn { get; set; }

	public static GameModel Instance { get; set; }

	public int CurrentLevel => currentLevel;

	internal void CreateDummyPlayer()
	{
		if (!(DummyWand != null))
		{
			Wand component = PhotonNetwork.Instantiate("Wand", new Vector3(0f, 0f, 0f), default(Quaternion), 0).GetComponent<Wand>();
			component.player = Instance.CurrentPlayer;
			component.GunIndex = -1;
			DummyWand = component;
		}
	}

	internal void RemoveDummyPlayer()
	{
		if (DummyWand != null)
		{
			PhotonNetwork.Destroy(DummyWand.gameObject);
			DummyWand = null;
		}
	}

	private void Awake()
	{
		Instance = this;
	}

	private void Update()
	{
		if (_activeGameState != null)
		{
			_activeGameState.ExecuteState();
		}
	}

	public void ChangeGameState(BaseGameState newState)
	{
		if (_activeGameState != null)
		{
			_activeGameState.FinishState();
		}
		_activeGameState = newState;
		_activeGameState.InitState();
	}

	public void UpdateGameBonusPoint()
	{
		int num = (LevelMgr.Instance.GetRoundLevelCount() + 1) / 2;
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			if ((int)player.CustomProperties["roundScore"] >= num)
			{
				CountPointToPlayer(player.ActorNumber, _winnerBonus);
				break;
			}
		}
	}

	public void CountPointToPlayer(int playerID, int point)
	{
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			if (player.ActorNumber == playerID)
			{
				ExitGames.Client.Photon.Hashtable customProperties = player.CustomProperties;
				customProperties["roundPoint"] = (int)customProperties["roundPoint"] + point;
				player.SetCustomProperties(customProperties);
			}
		}
	}

	public void CountScoreToPlayer(int playerID, int scorePrice)
	{
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			if (player.ActorNumber == playerID)
			{
				ExitGames.Client.Photon.Hashtable customProperties = player.CustomProperties;
				customProperties["roundScore"] = (int)customProperties["roundScore"] + scorePrice;
				player.SetCustomProperties(customProperties);
			}
		}
		NetworkController.Instance.NotifyObjectHit(playerID, scorePrice > 0);
		NetworkController.Instance.NotifyToUpdateScore();
	}

	public void CountScoreToOtherPlayer(int playerID, int scorePrice)
	{
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			if (player.ActorNumber == playerID)
			{
				ExitGames.Client.Photon.Hashtable customProperties = player.CustomProperties;
				customProperties["roundScore"] = (int)customProperties["roundScore"] + scorePrice;
				player.SetCustomProperties(customProperties);
			}
		}
		NetworkController.Instance.NotifyToUpdateScore();
	}

	public void InitRoundData()
	{
		currentLevel = 0;
		Instance.isStarted = true;
		ResetPlayerRoundScore();
		NetworkController.Instance.NotifyToUpdateScore();
		LevelMgr.Instance.LoadLevel(currentLevel);
	}

	public void LoadNextRound()
	{
		Instance.isStarted = true;
		if (IsGameFinished())
		{
			UnityEngine.Debug.Log("LoadNextRound(): last round was reached, will start over from round #0");
			currentLevel = 0;
		}
		else
		{
			currentLevel++;
		}
		LevelMgr.Instance.LoadLevel(currentLevel);
	}

	public void RepeatRound()
	{
		InitRoundData();
		NetworkController.Instance.NotifyChangeToPlayingState();
	}

	public bool IsGameFinished()
	{
		int roundLevelCount = LevelMgr.Instance.GetRoundLevelCount();
		if (currentLevel >= roundLevelCount - 1)
		{
			return true;
		}
		return false;
	}

	public bool IsPlaying()
	{
		return ActiveGameState is PlayingGameState;
	}

	public bool IsInGame()
	{
		bool result = false;
		if (ActiveGameState is PlayingGameState)
		{
			result = true;
		}
		if (ActiveGameState is ScoringGameState)
		{
			result = true;
		}
		return result;
	}

	public bool IsSinglePlayer()
	{
		return PhotonNetwork.PlayerList.Length == 1;
	}

	public bool IsLocalPlayer(Player player)
	{
		if (player != null && player.ActorNumber == PhotonNetwork.LocalPlayer.ActorNumber)
		{
			return true;
		}
		return false;
	}

	public void BuildPlayer()
	{
		_playerFactory.Build();
	}

	public void DumpPlayerPoints()
	{
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			UnityEngine.Debug.LogFormat("DumpPlayerPoints(): Player ID {0}, points: {1}", player.ActorNumber, player.CustomProperties["roundPoint"]);
		}
	}

	private void ResetPlayerRoundScore()
	{
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player obj in playerList)
		{
			ExitGames.Client.Photon.Hashtable customProperties = obj.CustomProperties;
			customProperties["roundScore"] = 0;
			customProperties["roundPoint"] = 0;
			obj.SetCustomProperties(customProperties);
		}
	}

	public void UpdatePlayerStatistics()
	{
		int accountId = LobbyMgr.Instance.GetAccountId();
		UnityEngine.Debug.LogFormat("UpdatePlayerStatistics(): account_id={0}", accountId);
		if (accountId != -1)
		{
			DataSourceFactory.GetDataSource().GetStatisticService().GetStatistic(accountId, OnGetStatistic);
		}
	}

	private void OnGetStatistic(Statistic[] res)
	{
		Statistic statistic = null;
		if (res.Length != 0)
		{
			statistic = res[0];
		}
		if (statistic != null)
		{
			int num = (int)PhotonNetwork.LocalPlayer.CustomProperties["roundScore"];
			int num2 = (int)PhotonNetwork.LocalPlayer.CustomProperties["roundPoint"];
			UnityEngine.Debug.LogFormat("OnGetStatistic: score = {0}, points = {1}, stat_id = {2}", num, num2, statistic.stat_id);
			statistic.total_success += num;
			statistic.total_count += num2;
			DataSourceFactory.GetDataSource().GetStatisticService().UpdateStatistic(statistic);
		}
	}
}
public class GameView : MonoBehaviour
{
	[Header("Timeout Settings")]
	[SerializeField]
	private float _winScreenTimeout;

	[Header("Presenter Panels")]
	[SerializeField]
	private GameObject _MainMenuPanel;

	[SerializeField]
	private GameObject _UserProfilePanel;

	[SerializeField]
	private GameObject _leaderBoardPanel;

	[SerializeField]
	private GameObject _networkPanel;

	[SerializeField]
	private GameObject _scoringPanel;

	[SerializeField]
	private GameObject _winnerPanel;

	[SerializeField]
	private GameObject _gamePopupPanel;

	[SerializeField]
	private GameObject _timePopupPanel;

	[SerializeField]
	private GameObject _tipPanel;

	[SerializeField]
	private GameObject _scorePoints;

	[SerializeField]
	private ParticleSystem winningEffect;

	public float WinScreenTimeout => _winScreenTimeout;

	private Transform UIRoot => GameModel.Instance.CurrentPlayer.UiRoot;

	private Transform UIRootLeft => GameModel.Instance.CurrentPlayer.UiRootLeft;

	private Transform UIRootRight => GameModel.Instance.CurrentPlayer.UiRootRight;

	private Transform SideUIRoot => GameModel.Instance.CurrentPlayer.SideUiRoot;

	private Transform FrontUIRoot => GameModel.Instance.CurrentPlayer.FrontUiRoot;

	private Transform RightHandAnchor => GameModel.Instance.CurrentPlayer.RightHandAnchor;

	public static GameView Instance { get; private set; }

	internal void DestoryTimePanel()
	{
		foreach (Transform item in FrontUIRoot)
		{
			if (item != null && item.gameObject != null)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
	}

	private void Awake()
	{
		Instance = this;
	}

	public void ShowMainMenuPanel()
	{
		if (!(UIRoot == null))
		{
			ClearUIRoot();
			ClearTimePanel();
			UnityEngine.Object.Instantiate(_MainMenuPanel, UIRoot.position, Quaternion.identity).transform.SetParent(UIRoot, worldPositionStays: false);
			UnityEngine.Object.Instantiate(_UserProfilePanel, UIRootLeft.position, Quaternion.identity).transform.SetParent(UIRootLeft, worldPositionStays: false);
			UnityEngine.Object.Instantiate(_leaderBoardPanel, UIRootRight.position, Quaternion.identity).transform.SetParent(UIRootRight, worldPositionStays: false);
		}
	}

	internal void ShowRoundPoints(int roundPoints)
	{
		if (!(SideUIRoot == null))
		{
			GameObject obj = UnityEngine.Object.Instantiate(_scorePoints);
			obj.transform.SetParent(SideUIRoot, worldPositionStays: false);
			obj.GetComponent<PointsPresenter>().ShowNumber(roundPoints, 2f);
		}
	}

	public void ShowNetworkPanel()
	{
		if (!(UIRoot == null))
		{
			ClearUIRoot();
			UnityEngine.Object.Instantiate(_networkPanel, UIRoot.position, UIRoot.rotation).transform.SetParent(UIRoot, worldPositionStays: false);
		}
	}

	public void ShowTimePanel()
	{
		if (!(FrontUIRoot == null))
		{
			ClearTimePanel();
			UnityEngine.Object.Instantiate(_timePopupPanel).transform.SetParent(FrontUIRoot, worldPositionStays: false);
		}
	}

	private void ClearTimePanel()
	{
		foreach (Transform item in FrontUIRoot)
		{
			if (item.name.Contains("TimePanel"))
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
	}

	public void ShowGamePopupPanel(string message, string subMessage = "", float selfDestroyTime = 4f)
	{
		if (!(FrontUIRoot == null))
		{
			GameObject obj = UnityEngine.Object.Instantiate(_gamePopupPanel, UIRoot.position, Quaternion.identity);
			obj.transform.SetParent(FrontUIRoot, worldPositionStays: false);
			obj.GetComponent<GamePopupPresenter>().UpdateMessage(message, subMessage, selfDestroyTime);
		}
	}

	public void ShowScoringPopupPanel(float selfDestroyTime = 1f)
	{
		if (!(UIRoot == null))
		{
			ClearUIRoot();
			GameObject obj = UnityEngine.Object.Instantiate(_scoringPanel, UIRoot.position, UIRoot.rotation);
			obj.transform.SetParent(UIRoot, worldPositionStays: false);
			obj.GetComponent<ScoringPresenter>().UpdateScore(selfDestroyTime);
		}
	}

	public void ShowWinnerPopupPanel(string message, float selfDestroyTime = 1f)
	{
		if (!(UIRoot == null))
		{
			ClearUIRoot();
			GameObject obj = UnityEngine.Object.Instantiate(_winnerPanel, UIRoot.position, UIRoot.rotation);
			obj.transform.SetParent(UIRoot, worldPositionStays: false);
			obj.GetComponent<WinnerPresenter>().UpdateWinner(message, selfDestroyTime);
			winningEffect?.Play();
		}
	}

	private void ClearUIRoot()
	{
		foreach (Transform item in UIRoot)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		foreach (Transform item2 in UIRootRight)
		{
			UnityEngine.Object.Destroy(item2.gameObject);
		}
		foreach (Transform item3 in UIRootLeft)
		{
			UnityEngine.Object.Destroy(item3.gameObject);
		}
	}

	public void ShowTipPanel()
	{
		if (!(RightHandAnchor == null))
		{
			CLearTipPanel();
			GameObject obj = UnityEngine.Object.Instantiate(_tipPanel, RightHandAnchor.position, RightHandAnchor.rotation);
			obj.GetComponent<HintRender>().target = RightHandAnchor;
			obj.GetComponent<HintRender>().startTransform = RightHandAnchor;
			obj.transform.SetParent(RightHandAnchor, worldPositionStays: false);
		}
	}

	public void CLearTipPanel()
	{
		if (RightHandAnchor == null)
		{
			return;
		}
		foreach (Transform item in RightHandAnchor)
		{
			if (item.GetComponent<HintRender>() != null)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}
	}
}
public abstract class BaseGameState
{
	public virtual void InitState()
	{
		UnityEngine.Debug.Log("State Changed to: " + this);
	}

	public virtual void ExecuteState()
	{
	}

	public virtual void FinishState()
	{
	}
}
public class ConnectingGameState : BaseGameState
{
	private bool _isRetrying;

	private int _retryCount;

	private int _maxRetry = 3;

	private float _stateLifeTime;

	private float _retryDelay = 5f;

	public override void InitState()
	{
		base.InitState();
		_isRetrying = false;
		_retryCount = 0;
		_stateLifeTime = 0f;
		NetworkController.OnGameConnected += InitGame;
		NetworkController.onJoinRandomFailed += RetryJoinRandom;
	}

	public override void ExecuteState()
	{
		base.ExecuteState();
		if (_isRetrying)
		{
			_stateLifeTime += Time.deltaTime;
		}
		if (_retryCount >= _maxRetry)
		{
			UnityEngine.Debug.LogWarning("Reached max retry count, please start a new game!");
			MenuBar.Instance.ShowLoadMenuPanel();
			GameModel.Instance.ChangeGameState(new LoadingGameState());
		}
		if (_stateLifeTime > _retryDelay)
		{
			_isRetrying = false;
			_stateLifeTime = 0f;
			_retryCount++;
			NetworkController.Instance.ReConnect();
			UnityEngine.Debug.LogWarningFormat("Failed to join game, retrying #{0}", _retryCount);
		}
	}

	public override void FinishState()
	{
		base.FinishState();
		_isRetrying = false;
		NetworkController.OnGameConnected -= InitGame;
		NetworkController.onJoinRandomFailed -= RetryJoinRandom;
	}

	private void InitGame()
	{
		SetPlayerData();
		GameModel.Instance.ChangeGameState(new InitializingGameState());
	}

	private void RetryJoinRandom(short returnCode, string message)
	{
		_isRetrying = true;
	}

	private void SetPlayerData()
	{
		List<int> list = new List<int>();
		for (int i = 0; i < 2; i++)
		{
			list.Add(i);
		}
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			if (player.CustomProperties["position"] != null)
			{
				list.Remove((int)player.CustomProperties["position"]);
			}
		}
		string value = ((LobbyMgr.Instance.accounts.Count > 0) ? LobbyMgr.Instance.accounts[0].name : "YOU");
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable.Add("position", list[0]);
		hashtable.Add("roundScore", 0);
		hashtable.Add("roundPoint", 0);
		hashtable.Add("name", value);
		PhotonNetwork.LocalPlayer.SetCustomProperties(hashtable);
		UnityEngine.Debug.Log("CustomProperties[\"'position\"]: " + PhotonNetwork.LocalPlayer.CustomProperties["position"]);
		UnityEngine.Debug.Log("LocalPlayer.ActorNumber: " + PhotonNetwork.LocalPlayer.ActorNumber);
	}
}
public class FinishedGameState : BaseGameState
{
	public override void InitState()
	{
		base.InitState();
		Player finalWinningPlayer = GameModel.Instance.FinalWinningPlayer;
		string message = ((finalWinningPlayer == null) ? "" : finalWinningPlayer.CustomProperties["name"].ToString());
		GameView.Instance.ShowWinnerPopupPanel(message, 5f);
		MenuBar.Instance.ShowRoundEndPanel();
	}

	public override void FinishState()
	{
		base.FinishState();
	}

	public override void ExecuteState()
	{
		base.ExecuteState();
		_ = PhotonNetwork.IsMasterClient;
	}
}
public class InitializingGameState : BaseGameState
{
	public override void InitState()
	{
		base.InitState();
		GameModel.Instance.BuildPlayer();
		SpawnUI();
		if (PhotonNetwork.IsMasterClient)
		{
			GameController.Instance.InitSingleGame();
		}
		GameModel.Instance.ChangeGameState(new PlayingGameState());
	}

	private void SpawnUI()
	{
		if (PhotonNetwork.IsMasterClient)
		{
			GameView.Instance.ShowGamePopupPanel("!", "");
		}
		else
		{
			GameView.Instance.ShowGamePopupPanel("!");
		}
	}
}
public class LoadingGameState : BaseGameState
{
	public override void InitState()
	{
		base.InitState();
	}

	public override void FinishState()
	{
		base.FinishState();
	}
}
public class MainMenuGameState : BaseGameState
{
	public override void InitState()
	{
		base.InitState();
		GameModel.Instance.BuildPlayer();
	}
}
public class PlayingGameState : BaseGameState
{
	public override void InitState()
	{
		base.InitState();
		MenuBar.Instance.HideAll();
		TurnMgr.Instance.UpdateTimePanel();
		NetworkController.OnSomePlayerConnected += SomeoneConnectedMessage;
		NetworkController.OnSomePlayerDisconnected += SomeoneDisconnectedMessage;
	}

	public override void FinishState()
	{
		base.FinishState();
		NetworkController.OnSomePlayerConnected -= SomeoneConnectedMessage;
		NetworkController.OnSomePlayerDisconnected -= SomeoneDisconnectedMessage;
	}

	public override void ExecuteState()
	{
		base.ExecuteState();
		_ = PhotonNetwork.IsMasterClient;
	}

	private void SomeoneConnectedMessage(Player somePlayer)
	{
		GameView.Instance.ShowGamePopupPanel(string.Concat("", somePlayer.CustomProperties["name"], " "), "");
		GameObject.Find("Spawner")?.SetActive(value: false);
		if (PhotonNetwork.IsMasterClient)
		{
			GameModel.Instance.InitRoundData();
			GameModel.Instance.RemoveDummyPlayer();
		}
	}

	private void SomeoneDisconnectedMessage(Player somePlayer)
	{
		GameView.Instance.ShowGamePopupPanel(string.Concat("", somePlayer.CustomProperties["name"], " "));
		if (PhotonNetwork.IsMasterClient && LevelMgr.Instance.roundLevels.Count > 0)
		{
			GameController.Instance.InitSingleGame();
		}
		else
		{
			GameController.Instance.EndMatch();
		}
	}
}
public class ScoringGameState : BaseGameState
{
	private bool _isActive;

	private float _stateLifeTime;

	public override void InitState()
	{
		base.InitState();
		TurnMgr.Instance.UpdateTimePanel();
		NetworkController.OnRoundEnded += ActivateState;
		NetworkController.OnRoundEnded += SomeoneWonMessage;
	}

	public override void FinishState()
	{
		base.FinishState();
		NetworkController.OnRoundEnded -= ActivateState;
		NetworkController.OnRoundEnded -= SomeoneWonMessage;
	}

	public override void ExecuteState()
	{
		base.ExecuteState();
		if (!PhotonNetwork.IsMasterClient)
		{
			return;
		}
		if (_isActive)
		{
			_stateLifeTime += Time.deltaTime;
		}
		if (_stateLifeTime > GameView.Instance.WinScreenTimeout)
		{
			if (GameModel.Instance.IsGameFinished())
			{
				GameModel.Instance.ChangeGameState(new FinishedGameState());
				NetworkController.Instance.NotifyChangeToFinishedState();
			}
			else
			{
				GameModel.Instance.LoadNextRound();
				GameModel.Instance.ChangeGameState(new PlayingGameState());
				NetworkController.Instance.NotifyChangeToPlayingState();
			}
		}
	}

	private void ActivateState(Player winningPlayer)
	{
		_isActive = true;
	}

	private void SomeoneWonMessage(Player winningPlayer)
	{
		if (winningPlayer != null && PhotonNetwork.LocalPlayer.ActorNumber == winningPlayer.ActorNumber)
		{
			GameView.Instance.ShowRoundPoints(100);
		}
		if (GameModel.Instance.IsGameFinished())
		{
			GameModel.Instance.UpdatePlayerStatistics();
			if (PhotonNetwork.IsMasterClient)
			{
				GameModel.Instance.UpdateGameBonusPoint();
			}
		}
		GameView.Instance.ShowScoringPopupPanel(GameView.Instance.WinScreenTimeout);
	}
}
public class WinnerPresenter : MonoBehaviour
{
	[SerializeField]
	private TMP_Text _winnerField;

	[SerializeField]
	private AudioClip audioClip;

	public void UpdateWinner(string message, float selfDestroyTime)
	{
		_winnerField.text = message;
		AudioSource.PlayClipAtPoint(audioClip, base.transform.position);
		UnityEngine.Object.Destroy(base.gameObject, selfDestroyTime);
	}
}
public class GameRoundMgr : MonoBehaviour
{
	private GameRound[] gameRounds;

	private Texture[] textureCache;

	private string textureFilePath;

	public static GameRoundMgr Instance { get; private set; }

	public int TotalLevels
	{
		get
		{
			return _totalLevels;
		}
		private set
		{
		}
	}

	private int _totalLevels
	{
		get
		{
			if (gameRounds == null)
			{
				LoadGameRounds();
				return 0;
			}
			return gameRounds.Length;
		}
	}

	private void Start()
	{
		textureFilePath = Application.persistentDataPath + "/textures/";
		MediaMgr instance = Framework.Singleton<MediaMgr>.Instance;
		instance.onMediaLoaded = (Action<byte[], MediaContext>)Delegate.Combine(instance.onMediaLoaded, new Action<byte[], MediaContext>(OnDownloadMediaFile));
	}

	private void Awake()
	{
		Instance = this;
		if (gameRounds == null)
		{
			LoadGameRounds();
		}
	}

	private void LoadGameRounds()
	{
		DataSourceFactory.GetDataSource().GetGameRoundService().GetGameRound(0, OnGetGameRound);
	}

	private void OnGetGameRound(GameRound[] obj)
	{
		if (obj != null && obj.Length != 0)
		{
			gameRounds = obj;
			LoadGameRoundTextures(gameRounds);
		}
		else
		{
			UnityEngine.Debug.LogError("OnGetGameRound(): No game round records received from server.");
		}
	}

	private void LoadGameRoundTextures(GameRound[] gameRounds)
	{
		textureCache = new Texture[gameRounds.Length];
		int num = 0;
		foreach (GameRound gameRound in gameRounds)
		{
			if (!LoadTextureFromFile(num, gameRound))
			{
				LoadTextureRemote(num, gameRound);
			}
			num++;
		}
	}

	private bool LoadTextureFromFile(int index, GameRound gameRound)
	{
		bool result = false;
		string path = textureFilePath + GetTextureFileName(gameRound);
		if (File.Exists(path))
		{
			byte[] data = File.ReadAllBytes(path);
			textureCache[index] = Framework.Singleton<TextureUtil>.Instance.CreateTextureFromData(data);
			result = true;
		}
		return result;
	}

	private void LoadTextureRemote(int index, GameRound gameRound)
	{
		MediaContext context = new MediaContext
		{
			index = index,
			gameRound = gameRound,
			fileName = GetTextureFileName(gameRound)
		};
		Framework.Singleton<MediaMgr>.Instance.DownloadMediaFile(gameRound.media_id, context);
	}

	private string GetTextureFileName(GameRound gameRound)
	{
		return gameRound.round_id + ".png";
	}

	private void CreateGameRound(Media media)
	{
		LevelInfo levelInfo = new LevelInfo();
		GameObject[] array = GameObject.FindGameObjectsWithTag("BlockItem");
		UnityEngine.Debug.Log("blocks number:" + array.Length);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].layer == LayerMask.NameToLayer("Distructable"))
			{
				levelInfo.items.Add(new Item(array[i].GetInstanceID(), array[i].name, array[i].name, array[i].transform.position, array[i].transform.rotation.eulerAngles));
			}
		}
		GameObject[] array2 = GameObject.FindGameObjectsWithTag("Target");
		for (int j = 0; j < array2.Length; j++)
		{
			if (array2[j].layer == LayerMask.NameToLayer("Target"))
			{
				levelInfo.items.Add(new Item(array2[j].GetInstanceID(), array2[j].name, "BearToy", array2[j].transform.position, array2[j].transform.rotation.eulerAngles));
			}
		}
		UnityEngine.Debug.Log("levelinfo:" + levelInfo.ToString());
		GameRound gameRound = new GameRound(0, 0, media.media_id, shared: true, "0", levelInfo.ToString(), DateTime.Now.ToString("u"));
		DataSourceFactory.GetDataSource().GetGameRoundService().CreateGameRound(gameRound, OnCreateGameRound);
	}

	private void OnUploadMedia(Media obj)
	{
		if (obj != null && obj.media_id != 0)
		{
			CreateGameRound(obj);
		}
	}

	private void OnCreateGameRound(GameRound obj)
	{
		if (obj != null && obj.round_id != 0)
		{
			DestroyItems();
		}
	}

	private void OnDownloadMediaFile(byte[] data, MediaContext context)
	{
		if (data == null)
		{
			UnityEngine.Debug.LogWarning("Downloaded media file is null");
			return;
		}
		textureCache[context.index] = Framework.Singleton<TextureUtil>.Instance.CreateTextureFromData(data);
		StartCoroutine(SaveTextureFile(data, context));
	}

	private IEnumerator SaveTextureFile(byte[] data, MediaContext context)
	{
		yield return null;
		if (!Directory.Exists(textureFilePath))
		{
			FileUtil.CreateFolder(textureFilePath);
		}
		File.WriteAllBytes(textureFilePath + context.fileName, data);
	}

	public void RecordGameRound(LevelCamera levelCamera)
	{
		Texture2D texture2D = levelCamera.TakeAPhoto();
		string remote_path = "0";
		byte[] data = texture2D.EncodeToPNG();
		Framework.Singleton<MediaMgr>.Instance.UploadMediaFile(texture2D.name + ".png", remote_path, data, OnUploadMedia);
	}

	private void DestroyItems()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("BlockItem");
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].layer == LayerMask.NameToLayer("Distructable"))
			{
				UnityEngine.Object.Destroy(array[i].gameObject);
			}
		}
		GameObject[] array2 = GameObject.FindGameObjectsWithTag("Target");
		for (int j = 0; j < array2.Length; j++)
		{
			if (array2[j].layer == LayerMask.NameToLayer("Target"))
			{
				UnityEngine.Object.Destroy(array2[j].gameObject);
			}
		}
	}

	public GameRound GetGameRound(int level)
	{
		GameRound result = null;
		if (gameRounds != null && level >= 0 && level < gameRounds.Length)
		{
			result = gameRounds[level];
		}
		return result;
	}

	public Texture GetRoundTexture(int index)
	{
		Texture result = null;
		if (index >= 0 && index < textureCache.Length)
		{
			result = textureCache[index];
		}
		return result;
	}
}
public interface IPlayer
{
	GameObject GameObject { get; }

	Transform UiRoot { get; }

	Transform UiRootLeft { get; }

	Transform UiRootRight { get; }

	Transform SideUiRoot { get; }

	Transform FrontUiRoot { get; }

	Transform RightHandAnchor { get; }

	void GameSetup();

	void MenuSetup();

	bool GunTriggerPressed(int gunIndex);

	bool AimingLaserPressed(int gunIndex);

	Vector3 GetWandPosition(int gunIndex);

	Quaternion GetWandRotation(int gunIndex);
}
public class LevelCamera : MonoBehaviour
{
	private Camera handCamera;

	private void Start()
	{
		handCamera = GetComponent<Camera>();
	}

	public Texture2D TakeAPhoto()
	{
		RenderTexture active = RenderTexture.active;
		RenderTexture.active = handCamera.targetTexture;
		handCamera.Render();
		Texture2D texture2D = Framework.Singleton<TextureUtil>.Instance.CreateImageFromScreen(handCamera.targetTexture.width, handCamera.targetTexture.height);
		RenderTexture.active = active;
		string text = DateTime.Now.ToString("yyyyMMddHHmmssfff");
		texture2D.name = text;
		return texture2D;
	}
}
public class LevelMgr : MonoBehaviour
{
	public int count = 5;

	[HideInInspector]
	public List<GameRound> roundLevels;

	public static LevelMgr Instance { get; private set; }

	private void Start()
	{
		roundLevels = new List<GameRound>();
	}

	private void Awake()
	{
		Instance = this;
	}

	private void Update()
	{
	}

	public int GetRoundLevelCount()
	{
		return roundLevels.Count;
	}

	public void LoadLevel(int index)
	{
		if (roundLevels.Count == 0)
		{
			UnityEngine.Debug.LogError("LoadLevel(): game rounds were not loaded.");
		}
		else if (index >= 0 && index < roundLevels.Count)
		{
			DestoryLevelItems();
			DoLoadLevel(roundLevels[index].info);
		}
		else
		{
			UnityEngine.Debug.LogWarningFormat("LoadLevel(): index {0} is out of range. {1}", index, roundLevels.Count);
		}
	}

	private void DoLoadLevel(string info)
	{
		List<Item> items = JsonUtility.FromJson<LevelInfo>(info).items;
		for (int i = 0; i < items.Count; i++)
		{
			PhotonNetwork.Instantiate(items[i].type, items[i].pos, Quaternion.Euler(items[i].rot), 0);
		}
		TurnMgr.Instance.UpdateTimePanel();
	}

	public void DestroyLocalLevelItems()
	{
		DestoryLevelItems(isLocal: true);
	}

	public void DestoryLevelItems(bool isLocal = false)
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("BlockItem");
		if (array == null)
		{
			return;
		}
		for (int i = 0; i < array.Length; i++)
		{
			if (isLocal)
			{
				UnityEngine.Object.Destroy(array[i]);
			}
			else
			{
				PhotonNetwork.Destroy(array[i]);
			}
		}
		GameObject gameObject = GameObject.FindGameObjectWithTag("Target");
		if (!(gameObject == null))
		{
			if (isLocal)
			{
				UnityEngine.Object.Destroy(gameObject);
			}
			else
			{
				PhotonNetwork.Destroy(gameObject);
			}
		}
	}
}
public class LobbyMgr : MonoBehaviour
{
	private class AccountsInfo
	{
		public List<string> accounts;
	}

	private string serial;

	private string model;

	private Device device;

	private AccountsInfo accountsInfo;

	[HideInInspector]
	public List<Account> accounts;

	private string userName;

	public static LobbyMgr Instance { get; set; }

	public static event Action OnAccountGetted;

	private void Awake()
	{
		Instance = this;
		AndroidJavaObject androidJavaObject = new AndroidJavaObject("android.os.Build");
		if (PlayerPrefs.HasKey("serial"))
		{
			serial = PlayerPrefs.GetString("serial");
		}
		else
		{
			serial = androidJavaObject.GetStatic<string>("SERIAL");
			if (serial == null || serial.Equals("unknown"))
			{
				byte[] value = Guid.NewGuid().ToByteArray();
				serial = BitConverter.ToInt64(value, 0).ToString();
				UnityEngine.Debug.Log("serial:" + serial);
			}
			PlayerPrefs.SetString("serial", serial);
		}
		model = androidJavaObject.GetStatic<string>("MODEL");
		if (model == null)
		{
			model = "wholalo";
		}
		if (model.Contains("Pico"))
		{
			PicoLogin.Login();
		}
	}

	private void Start()
	{
		device = new Device(0, serial, model, "{}", "", DateTime.Now.ToString("u"));
		accountsInfo = new AccountsInfo
		{
			accounts = new List<string>()
		};
		accounts = new List<Account>();
		DataSourceFactory.GetDataSource().GetDeviceService().GetDevice(serial, OnGetDevice);
	}

	public void GetUserInfo(string userName)
	{
		this.userName = userName;
		UnityEngine.Debug.LogError("userName:" + userName);
	}

	public int GetAccountId()
	{
		int result = -1;
		if (accountsInfo != null && accountsInfo.accounts.Count > 0)
		{
			result = int.Parse(accountsInfo.accounts[0]);
		}
		return result;
	}

	public List<string> GetAccountIDs()
	{
		return accountsInfo.accounts;
	}

	private void CreateAccount()
	{
		Account account = new Account();
		account.info = "wholalo";
		account.name = ((userName == null) ? GetRandomName() : userName);
		UnityEngine.Debug.Log("account.name:" + account.name);
		account.created_time = DateTime.Now.ToString("u");
		DataSourceFactory.GetDataSource().GetAccountService().CreateAccount(account, OnCreateAccount);
	}

	private string GetRandomName()
	{
		string text = string.Empty;
		for (int i = 0; i < 9; i++)
		{
			int num = UnityEngine.Random.Range(0, 26) + 65;
			text += (char)num;
		}
		return text;
	}

	private void CreateAccess(int account_id)
	{
		Access access = new Access(account_id, 1, null, null, DateTime.Now.ToString("u"));
		DataSourceFactory.GetDataSource().GetAccessService().CreateAccess(access, OnCreateAccess);
	}

	private void OnCreateAccess(Access access)
	{
	}

	private void UpdateAccess(int account_id)
	{
		if (account_id > 0)
		{
			DataSourceFactory.GetDataSource().GetAccessService().GetAccess(account_id, onGetAccess);
		}
	}

	private void onGetAccess(Access obj)
	{
		if (obj == null)
		{
			CreateAccess(GetAccountId());
			return;
		}
		Access access = new Access(obj.account_id, obj.count + 1, obj.avg_duration, obj.total_time, DateTime.Now.ToString("u"));
		DataSourceFactory.GetDataSource().GetAccessService().UpdateAccess(access);
	}

	private void OnGetDevice(Device[] obj)
	{
		if (obj == null || obj.Length == 0)
		{
			CreateAccount();
			return;
		}
		device = obj[0];
		accountsInfo = JsonUtility.FromJson<AccountsInfo>(device.accounts_info);
		for (int i = 0; i < accountsInfo.accounts.Count; i++)
		{
			GetAccount(accountsInfo.accounts[i]);
		}
		UpdateAccess(GetAccountId());
	}

	private void GetAccount(string id)
	{
		DataSourceFactory.GetDataSource().GetAccountService().GetAccount(int.Parse(id), OnGetAccount);
	}

	private void OnGetAccount(Account obj)
	{
		accounts.Add(obj);
		LobbyMgr.OnAccountGetted?.Invoke();
	}

	private void OnCreateAccount(Account account)
	{
		if (account != null)
		{
			accounts.Add(account);
			accountsInfo.accounts.Add(account.account_id.ToString());
			Device device = new Device(0, serial, model, JsonUtility.ToJson(accountsInfo), "{}", DateTime.Now.ToString("u"));
			DataSourceFactory.GetDataSource().GetDeviceService().CreateDevice(device, OnCreateDevice);
			Statistic statistic = new Statistic
			{
				stat_id = 0,
				account_id = account.account_id,
				type_id = 0,
				total_count = 0,
				total_success = 0,
				total_time = "0",
				info = "{}",
				created_time = DateTime.Now.ToString("u")
			};
			DataSourceFactory.GetDataSource().GetStatisticService().CreateStatistic(statistic, OnCreateStatistic);
			CreateAccess(account.account_id);
			LobbyMgr.OnAccountGetted?.Invoke();
		}
	}

	private void OnCreateDevice(Device obj)
	{
		if (obj != null && obj.dev_id != 0)
		{
			device = obj;
		}
	}

	private void OnCreateStatistic(Statistic obj)
	{
		if (obj != null && obj.account_id != 0)
		{
			LobbyMgr.OnAccountGetted?.Invoke();
			UnityEngine.Debug.LogFormat("OnCreateStatistic(): account_id = {0}", obj.account_id);
		}
	}
}
public class MenuBar : MonoBehaviour
{
	public GameObject mainMenu;

	public GameObject loadMenu;

	public GameObject editMenu;

	public GameObject roundEndMenu;

	public static MenuBar Instance { get; private set; }

	private void Awake()
	{
		Instance = this;
	}

	public void ShowMainMenuPanel()
	{
		HideAll();
		mainMenu.SetActive(value: true);
	}

	public void ShowLoadMenuPanel()
	{
		HideAll();
		loadMenu.SetActive(value: true);
	}

	public void ShowEditMenuPanel()
	{
		HideAll();
		editMenu.SetActive(value: true);
	}

	public void ShowRoundEndPanel()
	{
		HideAll();
		roundEndMenu.SetActive(value: true);
	}

	public void HideAll()
	{
		mainMenu.SetActive(value: false);
		loadMenu.SetActive(value: false);
		editMenu.SetActive(value: false);
		roundEndMenu.SetActive(value: false);
	}
}
public class MenuButton : InteractableButton
{
	public AudioClip confirmSound;

	public AudioClip enterSound;

	public Color OriginColor;

	public Color HighlightColor;

	private bool isHovered;

	private Vector3 originalPos;

	private Vector3 newPos;

	private Transform colliderTransform;

	private TMP_Text textMesh;

	private void Awake()
	{
		originalPos = base.transform.localPosition;
		newPos = originalPos;
	}

	private void OnEnable()
	{
		isHovered = false;
		if (textMesh == null)
		{
			textMesh = GetComponentInChildren<TMP_Text>();
		}
		if (textMesh != null)
		{
			textMesh.color = OriginColor;
		}
		base.transform.localPosition = originalPos;
	}

	private void OnDisable()
	{
		isHovered = true;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!isHovered && (other.transform.name.Contains("Finger") || other.transform.name.Contains("GrabVolume")))
		{
			colliderTransform = other.transform;
			Highlight();
			AudioSource.PlayClipAtPoint(enterSound, base.transform.position);
			MonoSingleton<InputHandler>.Instance().SetContollerVibration(1f, 0.5f, other.transform.GetComponentInParent<Interactor>().m_controller);
			Invoke("TurnOffVibration", 0.1f);
		}
	}

	private void TurnOffVibration()
	{
		if (colliderTransform != null)
		{
			MonoSingleton<InputHandler>.Instance().SetContollerVibration(0f, 0f, colliderTransform.GetComponentInParent<Interactor>().m_controller);
		}
	}

	public void Highlight()
	{
		isHovered = true;
		textMesh.color = HighlightColor;
		newPos.Set(originalPos.x, originalPos.y, originalPos.z - 0.01f);
		base.transform.localPosition = newPos;
	}

	private void Update()
	{
		if (isHovered && (MonoSingleton<InputHandler>.Instance().GetIndexTriggerDown(InputHandler.ControllerType.Left) || MonoSingleton<InputHandler>.Instance().GetIndexTriggerDown(InputHandler.ControllerType.Right)))
		{
			AudioSource.PlayClipAtPoint(confirmSound, base.transform.position);
			onButtonDown?.Invoke();
		}
		if (colliderTransform != null && (double)Vector3.Distance(colliderTransform.position, base.transform.position) > 0.09)
		{
			isHovered = false;
			textMesh.color = OriginColor;
			base.transform.localPosition = originalPos;
			TurnOffVibration();
			colliderTransform = null;
		}
	}
}
public class Connection : MonoBehaviourPunCallbacks
{
	private bool toJoinRoom = true;

	public void Init()
	{
	}

	public void Connect(bool autoJoin = true)
	{
		toJoinRoom = autoJoin;
		if (PhotonNetwork.IsConnected)
		{
			OnConnectedToMaster();
			return;
		}
		PhotonNetwork.GameVersion = "1.0";
		PhotonNetwork.ConnectUsingSettings();
	}

	public void Disconnect()
	{
		PhotonNetwork.Disconnect();
	}

	public void Leave()
	{
		PhotonNetwork.LeaveRoom();
	}

	public override void OnConnectedToMaster()
	{
		if (PhotonNetwork.InRoom)
		{
			OnJoinedRoom();
			return;
		}
		if (toJoinRoom)
		{
			PhotonNetwork.JoinRandomRoom();
			return;
		}
		PhotonNetwork.CreateRoom(null, new RoomOptions
		{
			MaxPlayers = 2
		});
	}

	public override void OnJoinRandomFailed(short returnCode, string message)
	{
		NetworkController.Instance.OnJoinRandomFailed(returnCode, message);
	}

	public override void OnDisconnected(DisconnectCause cause)
	{
		base.OnDisconnected(cause);
		NetworkController.Instance.OnDisconnected(cause);
	}

	public override void OnLeftRoom()
	{
		base.OnLeftRoom();
		NetworkController.Instance.OnLeftRoom();
	}
}
public enum NetworkEvent
{
	UPDATE_SCORE,
	TRAP_HIT,
	ROUND_ENDED,
	GAME_ENDED,
	TO_PLAYING_STATE,
	TO_SCORING_STATE,
	TO_FINISHED_STATE
}
public class NetworkController : MonoBehaviour, IOnEventCallback, IInRoomCallbacks, IMatchmakingCallbacks
{
	public const string NETCODE_VERSION = "1.0";

	public const int MAX_PLAYERS = 2;

	private Connection _connection;

	public static NetworkController Instance { get; private set; }

	public static event Action OnGameConnected;

	public static event Action OnUpdateScore;

	public static event Action OnGameFinished;

	public static event Action<Player> OnSomePlayerConnected;

	public static event Action<Player> OnSomePlayerDisconnected;

	public static event Action<int, bool> OnPlayerObjectHit;

	public static event Action<Player> OnRoundEnded;

	public static event Action<short, string> onJoinRandomFailed;

	private void Awake()
	{
		Instance = this;
		_connection = GetComponent<Connection>();
	}

	private void OnEnable()
	{
		PhotonNetwork.AddCallbackTarget(this);
	}

	private void OnDisable()
	{
		PhotonNetwork.RemoveCallbackTarget(this);
	}

	public void StartMultiplayerGame()
	{
		_connection.Init();
		_connection.Connect();
	}

	public void StartNewGame()
	{
		_connection.Init();
		_connection.Connect(autoJoin: false);
	}

	public void EndMultiplayerGame()
	{
		_connection.Disconnect();
	}

	public void ReConnect()
	{
		_connection.Connect();
	}

	public void LeaveGame()
	{
		_connection.Leave();
	}

	public void NotifyToUpdateScore()
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.All;
		PhotonNetwork.RaiseEvent(0, null, raiseEventOptions, SendOptions.SendReliable);
	}

	public void NotifyObjectHit(int playerID, bool positive)
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.All;
		ExitGames.Client.Photon.Hashtable hashtable = new ExitGames.Client.Photon.Hashtable();
		hashtable[(byte)0] = playerID;
		hashtable[(byte)1] = positive;
		PhotonNetwork.RaiseEvent(1, hashtable, raiseEventOptions, SendOptions.SendReliable);
	}

	public void NotifyRoundEnded(Player winningPlayer)
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.All;
		PhotonNetwork.RaiseEvent(2, winningPlayer, raiseEventOptions, SendOptions.SendReliable);
	}

	public void NotifyGameEnded()
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.All;
		PhotonNetwork.RaiseEvent(3, null, raiseEventOptions, SendOptions.SendReliable);
	}

	public void NotifyChangeToPlayingState()
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.Others;
		PhotonNetwork.RaiseEvent(4, null, raiseEventOptions, SendOptions.SendReliable);
	}

	public void NotifyChangeToScoringingState()
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.Others;
		PhotonNetwork.RaiseEvent(5, null, raiseEventOptions, SendOptions.SendReliable);
	}

	public void NotifyChangeToFinishedState()
	{
		RaiseEventOptions raiseEventOptions = new RaiseEventOptions();
		raiseEventOptions.Receivers = ReceiverGroup.Others;
		PhotonNetwork.RaiseEvent(6, null, raiseEventOptions, SendOptions.SendReliable);
	}

	public void OnEvent(EventData photonEvent)
	{
		NetworkEvent code = (NetworkEvent)photonEvent.Code;
		object obj = photonEvent[245];
		switch (code)
		{
		case NetworkEvent.UPDATE_SCORE:
			NetworkController.OnUpdateScore?.Invoke();
			break;
		case NetworkEvent.TRAP_HIT:
			if (NetworkController.OnPlayerObjectHit != null)
			{
				ExitGames.Client.Photon.Hashtable hashtable = (ExitGames.Client.Photon.Hashtable)obj;
				NetworkController.OnPlayerObjectHit((int)hashtable[(byte)0], (bool)hashtable[(byte)1]);
			}
			break;
		case NetworkEvent.ROUND_ENDED:
			NetworkController.OnRoundEnded?.Invoke((Player)obj);
			break;
		case NetworkEvent.GAME_ENDED:
			GameController.Instance.LeaveMatch();
			break;
		case NetworkEvent.TO_PLAYING_STATE:
			GameModel.Instance.ChangeGameState(new PlayingGameState());
			break;
		case NetworkEvent.TO_SCORING_STATE:
			GameModel.Instance.ChangeGameState(new ScoringGameState());
			break;
		case NetworkEvent.TO_FINISHED_STATE:
			GameModel.Instance.ChangeGameState(new FinishedGameState());
			break;
		}
	}

	public void OnPlayerEnteredRoom(Player newPlayer)
	{
		if (NetworkController.OnSomePlayerConnected != null)
		{
			NetworkController.OnSomePlayerConnected(newPlayer);
		}
	}

	public void OnPlayerLeftRoom(Player otherPlayer)
	{
		NotifyToUpdateScore();
		if (NetworkController.OnSomePlayerDisconnected != null)
		{
			NetworkController.OnSomePlayerDisconnected(otherPlayer);
		}
	}

	public void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
	{
	}

	public void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
	{
	}

	public void OnMasterClientSwitched(Player newMasterClient)
	{
	}

	public void OnFriendListUpdate(List<FriendInfo> friendList)
	{
	}

	public void OnCreateRoomFailed(short returnCode, string message)
	{
	}

	public void OnCreatedRoom()
	{
		UnityEngine.Debug.Log("Called on created room");
	}

	public void OnJoinedRoom()
	{
		NetworkController.OnGameConnected?.Invoke();
		NotifyToUpdateScore();
	}

	public void OnJoinRoomFailed(short returnCode, string message)
	{
	}

	public void OnJoinRandomFailed(short returnCode, string message)
	{
		NetworkController.onJoinRandomFailed?.Invoke(returnCode, message);
	}

	public void OnLeftRoom()
	{
	}

	public void OnDisconnected(DisconnectCause cause)
	{
		GameController.Instance.OnDisconnected(cause);
	}
}
public class PICOPlayer : BasePlayer
{
	[Header("Player Specific")]
	private Transform rightHandPivot;

	private Transform rightController;

	public override Transform RightHandAnchor => rightHandPivot;

	private void Awake()
	{
		if (cameraRig == null)
		{
			cameraRig = GameObject.Find("Pvr_UnitySDK Variant");
			if (cameraRig != null)
			{
				rightHandPivot = cameraRig.transform.Find("ControllerManager/PvrController1/gripTrans");
				frontUiRoot = cameraRig.transform.Find("Head/BothEye/[FrontUI]");
				rightController = cameraRig.transform.Find("ControllerManager/PvrController1");
			}
		}
	}

	public override void GameSetup()
	{
		base.GameSetup();
		RenderRightController(visible: false);
	}

	private void RenderRightController(bool visible)
	{
		if (!(rightController == null))
		{
			Renderer[] componentsInChildren = rightController.GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = visible;
			}
		}
	}

	public override void MenuSetup()
	{
		base.MenuSetup();
		RenderRightController(visible: true);
	}

	public override bool GunTriggerPressed(int gunIndex)
	{
		return false;
	}

	public override bool AimingLaserPressed(int gunIndex)
	{
		return false;
	}

	public override Vector3 GetWandPosition(int gunIndex)
	{
		return rightHandPivot.position;
	}

	public override Quaternion GetWandRotation(int gunIndex)
	{
		return rightHandPivot.rotation;
	}
}
public class PlayerFactory : MonoBehaviour
{
	[SerializeField]
	private bool useNonVrPlayerInEditor;

	[SerializeField]
	private GameObject _picoPlayerPrefab;

	[SerializeField]
	private GameObject _questPlayerPrefab;

	[SerializeField]
	private GameObject _androidPlayerPrefab;

	[SerializeField]
	private GameObject _nonVrPlayerPrefab;

	[SerializeField]
	private Transform _playerSpawnPoints;

	private GameObject _playerPrefab;

	public Transform PlayerSpawnPoints => _playerSpawnPoints;

	private void Awake()
	{
		useNonVrPlayerInEditor = false;
		string @static = new AndroidJavaObject("android.os.Build").GetStatic<string>("MODEL");
		_playerPrefab = _picoPlayerPrefab;
		if (@static != null && @static.Contains("Pico"))
		{
			_playerPrefab = _picoPlayerPrefab;
		}
		else if (@static != null && @static.Contains("Quest"))
		{
			_playerPrefab = _questPlayerPrefab;
		}
	}

	public void Build()
	{
		if (GameModel.Instance.ActiveGameState is InitializingGameState)
		{
			BuildPlayerForGame();
		}
		else if (GameModel.Instance.ActiveGameState is MainMenuGameState)
		{
			BuildPlayerForMenu();
		}
	}

	public void BuildPlayerForGame()
	{
		if (GameModel.Instance.CurrentPlayer != null)
		{
			UnityEngine.Object.DestroyImmediate(GameModel.Instance.CurrentPlayer.GameObject);
		}
		int index = (int)PhotonNetwork.LocalPlayer.CustomProperties["position"];
		Vector3 position = PlayerSpawnPoints.GetChild(index).position;
		if (useNonVrPlayerInEditor)
		{
			position.y += 2f;
		}
		GameObject gameObject = PhotonNetwork.Instantiate(_playerPrefab.name, position, Quaternion.identity, 0);
		GameModel.Instance.CurrentPlayer = (IPlayer)gameObject.GetComponent(typeof(IPlayer));
		if (!useNonVrPlayerInEditor)
		{
			GameModel.Instance.CurrentPlayer.GameSetup();
		}
	}

	public void BuildPlayerForMenu()
	{
		if (GameModel.Instance.CurrentPlayer != null)
		{
			PhotonNetwork.Destroy(GameModel.Instance.CurrentPlayer.GameObject);
			LevelMgr.Instance.DestoryLevelItems();
		}
		Vector3 position = PlayerSpawnPoints.GetChild(0).position;
		if (useNonVrPlayerInEditor)
		{
			position.y += 2f;
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(_playerPrefab, position, Quaternion.identity);
		GameModel.Instance.CurrentPlayer = (IPlayer)gameObject.GetComponent(typeof(IPlayer));
		if (!useNonVrPlayerInEditor)
		{
			GameModel.Instance.CurrentPlayer.MenuSetup();
		}
		MenuBar.Instance.ShowMainMenuPanel();
		GameView.Instance.ShowMainMenuPanel();
	}

	public static Color GetColor(int position)
	{
		return position switch
		{
			0 => Color.red, 
			1 => Color.blue, 
			2 => Color.yellow, 
			3 => Color.green, 
			4 => Color.black, 
			_ => Color.grey, 
		};
	}
}
internal abstract class AbstractNetwork
{
	public const string address = "https://81.70.45.74:8000/";
}
[Serializable]
public class Access
{
	public int account_id;

	public int count;

	public string avg_duration;

	public string total_time;

	public string last_updated;

	public Access(int account_id, int count, string avg_duration, string total_time, string last_updated)
	{
		this.account_id = account_id;
		this.count = count;
		this.avg_duration = avg_duration;
		this.total_time = total_time;
		this.last_updated = last_updated;
	}

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class Account
{
	public int account_id;

	public string name;

	public int age;

	public int gender;

	public int grade;

	public string info;

	public int media_id;

	public int performance_id;

	public int inventory_id;

	public string created_time;

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
internal class ArrayUtil
{
}
public class CustomCertificateHandler : CertificateHandler
{
	private static readonly string PUB_KEY = "";

	protected override bool ValidateCertificate(byte[] certificateData)
	{
		return true;
	}
}
public static class DataSourceFactory
{
	public enum DataSourceType
	{
		Network,
		Database
	}

	private const DataSourceType DEFAULT_TYPE = DataSourceType.Network;

	private static IDataSourceService networkService = new NetworkService();

	public static IDataSourceService GetDataSource(DataSourceType type)
	{
		if (type.Equals(DataSourceType.Network))
		{
			return networkService;
		}
		return null;
	}

	public static IDataSourceService GetDataSource()
	{
		return GetDataSource(DataSourceType.Network);
	}
}
[Serializable]
public class Device
{
	public int dev_id;

	public string UUID;

	public string manufactor;

	public string accounts_info;

	public string extra;

	public string created_time;

	public Device(int dev_id, string UUID, string manufactor, string accounts_info, string extra, string created_time)
	{
		this.dev_id = dev_id;
		this.UUID = UUID;
		this.manufactor = manufactor;
		this.accounts_info = accounts_info;
		this.extra = extra;
		this.created_time = created_time;
	}

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class DeviceResponse
{
	public Device[] results;
}
[Serializable]
public class GameRound
{
	public int round_id;

	public int account_id;

	public int media_id;

	public bool shared;

	public string usage;

	public string info;

	public string created_time;

	public GameRound(int round_id, int account_id, int mediaID, bool shared, string usage, string info, string created_time)
	{
		this.round_id = round_id;
		this.account_id = account_id;
		media_id = mediaID;
		this.shared = shared;
		this.usage = usage;
		this.info = info;
		this.created_time = created_time;
	}

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class GameRoundResponse
{
	public GameRound[] results;
}
public interface IAccessService
{
	int CreateAccess(Access access, Action<Access> callback);

	void UpdateAccess(Access access);

	void GetAccess(int deviceID, Action<Access> callback);
}
public interface IAccountService
{
	int CreateAccount(Account account, Action<Account> callback);

	void UpdateAccount(Account account);

	void GetAccount(int accountID, Action<Account> callback);
}
public interface IDataSourceService
{
	IGameRoundService GetGameRoundService();

	IMediaService GetMediaService();

	IAccountService GetAccountService();

	IStatisticService GetStatisticService();

	IDeviceService GetDeviceService();

	IAccessService GetAccessService();

	IPromotionService GetPromotionService();
}
public interface IDeviceService
{
	int CreateDevice(Device device, Action<Device> callback);

	void UpdateDevice(Device device);

	void GetDevice(string UUID, Action<Device[]> callback);

	void GetDevice(int deviceID, Action<Device> callback);
}
public interface IGameRoundService
{
	int CreateGameRound(GameRound gameRound, Action<GameRound> callback);

	void GetGameRound(int accountID, Action<GameRound[]> callback);
}
public interface IMediaService
{
	int CreateMedia(MediaRequest media, Action<Media> callback);

	void GetMedia(int mediaID, Action<Media> callback);

	void DownloadMedia(int mediaID, MediaContext context, Action<object, MediaContext> callback);
}
public interface IPromotionService
{
	void GetPromotions(int typeID, Action<Promotion[]> callback);

	void GetPromotion(int id, Action<Promotion> callback);
}
public interface IStatisticService
{
	int CreateStatistic(Statistic statistic, Action<Statistic> callback);

	void UpdateStatistic(Statistic statistic);

	void GetStatistic(int accountID, Action<Statistic[]> callback);

	void GetTopStatistics(Action<Statistic[]> callback);
}
[Serializable]
public class LevelInfo
{
	public List<Item> items;

	public LevelInfo()
	{
		items = new List<Item>();
	}

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class Item
{
	public int id;

	public string name;

	public string type;

	public Vector3 pos;

	public Vector3 rot;

	public Item(int id, string name, string type, Vector3 pos, Vector3 rot)
	{
		this.id = id;
		this.name = name;
		this.type = type;
		this.pos = pos;
		this.rot = rot;
	}
}
[Serializable]
public class Media
{
	public int media_id;

	public int type_id;

	public string path;

	public string data;

	public string created_time;

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class MediaContext
{
	public int index;

	public string fileName;

	public GameRound gameRound;

	public Media media;

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
internal class MediaMgr : Framework.Singleton<MediaMgr>
{
	public Action<byte[], MediaContext> onMediaLoaded;

	public void LoadMediaFiles(string local_path, string remote_path, bool force_sync, Action<List<Texture>> callback)
	{
		string text = Application.persistentDataPath + "/" + local_path + "/";
		if (!Directory.Exists(text))
		{
			FileUtil.CreateFolder(text);
			DownloadMediaFiles(text, remote_path);
		}
		else if (force_sync)
		{
			DownloadMediaFiles(text, remote_path);
		}
	}

	private void DownloadMediaFiles(string local_path, string remote_path)
	{
		if (remote_path != null)
		{
			Directory.Exists(local_path);
		}
	}

	public void UploadMediaFile(string file_name, string remote_path, byte[] data, Action<Media> callback)
	{
		MediaRequest mediaRequest = new MediaRequest();
		mediaRequest.type_id = 0;
		mediaRequest.name = file_name;
		mediaRequest.path = remote_path;
		mediaRequest.data = data;
		DataSourceFactory.GetDataSource().GetMediaService().CreateMedia(mediaRequest, callback);
	}

	public void DownloadMediaFile(int media_id, MediaContext context)
	{
		DataSourceFactory.GetDataSource().GetMediaService().DownloadMedia(media_id, context, OnDownloadMedia);
	}

	private void OnDownloadMedia(object obj, MediaContext context)
	{
		if (obj != null)
		{
			byte[] data = ((ResponseHelper)obj).Data;
			onMediaLoaded?.Invoke(data, context);
		}
	}
}
[Serializable]
public class MediaRequest
{
	public int media_id;

	public int type_id;

	public string name;

	public string path;

	public byte[] data;

	public string created_time;

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
internal class NetworkAccessService : AbstractNetwork, IAccessService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public int CreateAccess(Access access, Action<Access> callback)
	{
		RestClient.Post<Access>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//access/",
			Body = access,
			CertificateHandler = certHandler,
			EnableDebug = true
		}).Then(delegate(Access res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
		return 0;
	}

	public void GetAccess(int accountID, Action<Access> callback)
	{
		RestClient.Get<Access>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//access/" + accountID,
			CertificateHandler = certHandler
		}).Then(delegate(Access res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			callback(null);
			UnityEngine.Debug.LogError(err.Message);
		});
	}

	public void UpdateAccess(Access access)
	{
		if (access != null)
		{
			RestClient.Put<Access>(new RequestHelper
			{
				Uri = "https://81.70.45.74:8000//access/" + access.account_id + "/",
				Body = access,
				CertificateHandler = certHandler,
				Retries = 5,
				RetrySecondsDelay = 1f,
				RetryCallback = delegate(RequestException err, int retries)
				{
					UnityEngine.Debug.Log($"Retry #{retries} Status {err.StatusCode}\nError: {err}");
				},
				EnableDebug = true
			}).Catch(delegate(Exception err)
			{
				UnityEngine.Debug.LogError(err.Message);
			});
		}
	}
}
[Serializable]
internal class NetworkAccountService : AbstractNetwork, IAccountService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public int CreateAccount(Account account, Action<Account> callback)
	{
		RestClient.Post<Account>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//accounts/",
			Body = account,
			CertificateHandler = certHandler,
			EnableDebug = true
		}).Then(delegate(Account res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
		return 0;
	}

	public void UpdateAccount(Account account)
	{
		if (account != null)
		{
			RestClient.Put<Account>(new RequestHelper
			{
				Uri = "https://81.70.45.74:8000//accounts/" + account.account_id + "/",
				Body = account,
				CertificateHandler = certHandler,
				Retries = 1,
				RetrySecondsDelay = 1f,
				RetryCallback = delegate(RequestException err, int retries)
				{
					UnityEngine.Debug.Log($"Retry #{retries} Status {err.StatusCode}\nError: {err}");
				},
				EnableDebug = true
			}).Catch(delegate(Exception err)
			{
				UnityEngine.Debug.LogError(err.Message);
			});
		}
	}

	public void GetAccount(int accountID, Action<Account> callback)
	{
		RestClient.Get<Account>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//accounts/" + accountID,
			Retries = 5,
			CertificateHandler = certHandler
		}).Then(delegate(Account res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}
}
internal class NetworkDeviceService : AbstractNetwork, IDeviceService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public int CreateDevice(Device device, Action<Device> callback)
	{
		RestClient.Post<Device>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//wholalodevices/",
			Body = device,
			CertificateHandler = certHandler,
			EnableDebug = true
		}).Then(delegate(Device res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
		return 0;
	}

	public void GetDevice(string UUID, Action<Device[]> callback)
	{
		RestClient.Get<DeviceResponse>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//wholalodevices/?UUID=" + UUID,
			CertificateHandler = certHandler
		}).Then(delegate(DeviceResponse res)
		{
			callback(res.results);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}

	public void GetDevice(int deviceID, Action<Device> callback)
	{
		RestClient.Get<Device>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//wholalodevices/" + deviceID,
			CertificateHandler = certHandler
		}).Then(delegate(Device res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
	}

	public void UpdateDevice(Device device)
	{
		if (device != null)
		{
			RestClient.Put<Device>(new RequestHelper
			{
				Uri = "https://81.70.45.74:8000//wholalodevices/" + device.dev_id + "/",
				Body = device,
				CertificateHandler = certHandler,
				Retries = 5,
				RetrySecondsDelay = 1f,
				RetryCallback = delegate(RequestException err, int retries)
				{
					UnityEngine.Debug.Log($"Retry #{retries} Status {err.StatusCode}\nError: {err}");
				},
				EnableDebug = true
			}).Catch(delegate(Exception err)
			{
				UnityEngine.Debug.LogError(err.Message);
			});
		}
	}
}
internal class NetworkGameRoundService : AbstractNetwork, IGameRoundService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public int CreateGameRound(GameRound gameRound, Action<GameRound> callback)
	{
		RestClient.Post<GameRound>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//gameround/",
			Body = gameRound,
			CertificateHandler = certHandler,
			EnableDebug = true
		}).Then(delegate(GameRound res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
		return 0;
	}

	public void GetGameRound(int accountID, Action<GameRound[]> callback)
	{
		RestClient.Get<GameRoundResponse>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//gameround/?account_id=" + accountID,
			Retries = 5,
			CertificateHandler = certHandler
		}).Then(delegate(GameRoundResponse res)
		{
			callback(res.results);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}
}
[Serializable]
internal class NetworkMediaService : AbstractNetwork, IMediaService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public int CreateMedia(MediaRequest media, Action<Media> callback)
	{
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		list.Add(new MultipartFormDataSection("type_id", media.type_id.ToString()));
		list.Add(new MultipartFormDataSection("path", media.path));
		list.Add(new MultipartFormFileSection("upload", media.data, media.name, "image/png"));
		RestClient.Post(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//uploads/",
			FormSections = list,
			CertificateHandler = certHandler,
			EnableDebug = true,
			Timeout = 120
		}).Then(delegate(ResponseHelper res)
		{
			Media obj = JsonUtility.FromJson<Media>(Encoding.Default.GetString(res.Data));
			callback(obj);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
		return 0;
	}

	public void GetMedia(int mediaID, Action<Media> callback)
	{
		RestClient.Get<Media>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//media/" + mediaID,
			Retries = 5,
			CertificateHandler = certHandler
		}).Then(delegate(Media res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}

	public void DownloadMedia(int mediaID, MediaContext context, Action<object, MediaContext> callback)
	{
		RestClient.Get(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//downloads/?media_id=" + mediaID,
			CertificateHandler = certHandler,
			Timeout = 120,
			Retries = 5,
			RetrySecondsDelay = 120f,
			RetryCallback = delegate(RequestException err, int retries)
			{
				UnityEngine.Debug.Log($"Retry #{retries} Status {err.StatusCode}\nError: {err}");
			}
		}).Then(delegate(ResponseHelper res)
		{
			UnityEngine.Debug.Log("HY response status code: " + res.StatusCode);
			callback(res, context);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}
}
internal class NetworkPromotionService : AbstractNetwork, IPromotionService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public void GetPromotions(int typeID, Action<Promotion[]> callback)
	{
		RestClient.Get<PromotionResponse>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//promotions/?valid=true&&type_id=" + typeID,
			Retries = 5,
			CertificateHandler = certHandler
		}).Then(delegate(PromotionResponse res)
		{
			UnityEngine.Debug.Log("GetPromotion" + JsonUtility.ToJson(res));
			callback(res.results);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
	}

	public void GetPromotion(int id, Action<Promotion> callback)
	{
		RestClient.Get<Promotion>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//promotions/" + id + "/",
			CertificateHandler = certHandler
		}).Then(delegate(Promotion res)
		{
			UnityEngine.Debug.Log("GetPromotion" + JsonUtility.ToJson(res));
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
	}
}
internal class NetworkService : IDataSourceService
{
	public IAccessService GetAccessService()
	{
		return new NetworkAccessService();
	}

	public IAccountService GetAccountService()
	{
		return new NetworkAccountService();
	}

	public IDeviceService GetDeviceService()
	{
		return new NetworkDeviceService();
	}

	public IGameRoundService GetGameRoundService()
	{
		return new NetworkGameRoundService();
	}

	public IMediaService GetMediaService()
	{
		return new NetworkMediaService();
	}

	public IPromotionService GetPromotionService()
	{
		return new NetworkPromotionService();
	}

	public IStatisticService GetStatisticService()
	{
		return new NetworkStatisticService();
	}
}
[Serializable]
internal class NetworkStatisticService : AbstractNetwork, IStatisticService
{
	private CustomCertificateHandler certHandler = new CustomCertificateHandler();

	public int CreateStatistic(Statistic statistic, Action<Statistic> callback)
	{
		RestClient.Post<Statistic>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//statistics/",
			Body = statistic,
			CertificateHandler = certHandler,
			EnableDebug = true
		}).Then(delegate(Statistic res)
		{
			callback(res);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.LogError(err.Message);
		});
		return 0;
	}

	public void GetStatistic(int accountID, Action<Statistic[]> callback)
	{
		RestClient.Get<StatisticResponse>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//statistics/?account_id=" + accountID,
			Retries = 5,
			CertificateHandler = certHandler
		}).Then(delegate(StatisticResponse res)
		{
			callback(res.results);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}

	public void GetTopStatistics(Action<Statistic[]> callback)
	{
		RestClient.Get<StatisticResponse>(new RequestHelper
		{
			Uri = "https://81.70.45.74:8000//statistics/?page=1",
			Retries = 5,
			CertificateHandler = certHandler
		}).Then(delegate(StatisticResponse res)
		{
			callback(res.results);
		}).Catch(delegate(Exception err)
		{
			UnityEngine.Debug.Log(err.Message);
		});
	}

	public void UpdateStatistic(Statistic statistic)
	{
		if (statistic != null)
		{
			RestClient.Put<Statistic>(new RequestHelper
			{
				Uri = "https://81.70.45.74:8000//statistics/" + statistic.stat_id + "/",
				Body = statistic,
				CertificateHandler = certHandler,
				Retries = 1,
				RetrySecondsDelay = 1f,
				RetryCallback = delegate(RequestException err, int retries)
				{
					UnityEngine.Debug.Log($"Retry #{retries} Status {err.StatusCode}\nError: {err}");
				},
				EnableDebug = true
			}).Catch(delegate(Exception err)
			{
				UnityEngine.Debug.LogError(err.Message);
			});
		}
	}
}
[Serializable]
public class Promotion
{
	public int prom_id;

	public string title;

	public int type_id;

	public bool valid;

	public string start_time;

	public string end_time;

	public string info;

	public string message;

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class PromotionResponse
{
	public Promotion[] results;
}
[Serializable]
public class Statistic
{
	public int stat_id;

	public int account_id;

	public int type_id;

	public int total_count;

	public int total_success;

	public string total_time;

	public string info;

	public string created_time;

	public override string ToString()
	{
		return JsonUtility.ToJson(this, prettyPrint: true);
	}
}
[Serializable]
public class StatisticResponse
{
	public Statistic[] results;
}
public class ShootingRangeCardboard : BasePlayer
{
	[Header("Player Specific")]
	public Transform rightHandPivot;

	public override void GameSetup()
	{
		base.GameSetup();
	}

	public override void MenuSetup()
	{
		base.MenuSetup();
	}

	public override bool GunTriggerPressed(int gunIndex)
	{
		if (gunIndex > 0)
		{
			return false;
		}
		return AnyButtonDown();
	}

	private bool AnyButtonDown()
	{
		return false;
	}

	public override bool AimingLaserPressed(int gunIndex)
	{
		return false;
	}

	public override Vector3 GetWandPosition(int gunIndex)
	{
		return rightHandPivot.position;
	}

	public override Quaternion GetWandRotation(int gunIndex)
	{
		return rightHandPivot.rotation;
	}
}
public class Spawner : MonoBehaviour
{
	[Serializable]
	public class SpawnEvent : UnityEvent<Transform>
	{
	}

	public Transform prefab;

	public Transform spawnPoint;

	public Material material;

	public Vector3 Axis = Vector3.one;

	public float distance;

	public Vector3 scale = Vector3.one;

	public float weight;

	public string objectName;

	private Transform currentSpawn;

	public SpawnEvent OnObjectSpawned;

	private void Start()
	{
	}

	private void OnEnable()
	{
		Invoke("SpawnObject", 0.1f);
	}

	private void Update()
	{
		if (!(currentSpawn == null) && Vector3.Distance(currentSpawn.position, base.transform.position) > distance)
		{
			SpawnObject();
		}
	}

	private void SpawnObject()
	{
		currentSpawn = UnityEngine.Object.Instantiate(prefab, base.transform.position, base.transform.rotation, spawnPoint);
		currentSpawn.gameObject.SetActive(value: true);
		currentSpawn.transform.localScale = scale;
		currentSpawn.name = objectName;
		currentSpawn.GetComponentInChildren<Rigidbody>().mass = weight;
		if (material != null)
		{
			currentSpawn.GetComponentInChildren<Renderer>().material = material;
		}
		OnObjectSpawned?.Invoke(currentSpawn);
	}
}
public class TextureUtil : Framework.Singleton<TextureUtil>
{
	private string path;

	private int width = 256;

	private int height = 256;

	private void Awake()
	{
		path = Application.persistentDataPath;
	}

	public void SaveTextureToFile(byte[] data, string folderName, string fileName)
	{
		string message = path + "/" + folderName + "/";
		UnityEngine.Debug.Log(message);
		if (FileUtil.CreateFolder(message))
		{
			File.WriteAllBytes(path + "/" + folderName + "/" + fileName + ".png", data);
		}
	}

	internal void DeleteTexture(Texture texture, string folder)
	{
		FileUtil.DeleteFile(path + "/" + folder + "/" + texture.name + ".png");
	}

	internal Texture2D CreateImageFromScreen(int width, int height)
	{
		this.width = width;
		this.height = height;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.ReadPixels(new Rect(0f, 0f, width, height), 0, 0);
		texture2D.Apply();
		return texture2D;
	}

	internal Texture2D CreateTextureFromData(byte[] data)
	{
		Texture2D texture2D = new Texture2D(width, height, TextureFormat.ARGB32, mipChain: false);
		texture2D.LoadImage(data);
		texture2D.Apply();
		return texture2D;
	}

	private IEnumerator LoadTextures(string fullFolderName, Action<List<Texture>> callback)
	{
		yield return null;
		List<Texture> list = new List<Texture>();
		if (Directory.Exists(fullFolderName))
		{
			foreach (string item in Directory.EnumerateFiles(fullFolderName))
			{
				if (item.Contains(".png"))
				{
					Texture2D texture2D = LoadTexture(item);
					if (texture2D != null)
					{
						list.Add(texture2D);
					}
				}
			}
		}
		callback(list);
	}

	private Texture2D LoadTexture(string fileName)
	{
		if (fileName == null)
		{
			return null;
		}
		byte[] array = File.ReadAllBytes(fileName);
		if (array != null)
		{
			Texture2D texture2D = new Texture2D(width, height, TextureFormat.ARGB32, mipChain: false);
			texture2D.LoadImage(array);
			texture2D.Apply();
			string text = fileName.Substring(fileName.LastIndexOf("/") + 1);
			text = text.Remove(text.LastIndexOf("."));
			texture2D.name = text;
			return texture2D;
		}
		return null;
	}
}
public class TurnMgr : MonoBehaviourPun
{
	private Player _currentPlayer;

	public static TurnMgr Instance { get; private set; }

	public Player CurrentPlayer
	{
		get
		{
			return _currentPlayer;
		}
		private set
		{
		}
	}

	public bool IsRobotTurn { get; set; }

	public Player GetNextPlayer()
	{
		if (_currentPlayer != null)
		{
			return _currentPlayer.GetNext();
		}
		return null;
	}

	private void Awake()
	{
		Instance = this;
		IsRobotTurn = false;
	}

	public bool ShouldPlay(Player player)
	{
		bool result = false;
		if (player != null && GameModel.Instance.ActiveGameState is PlayingGameState)
		{
			result = ((!GameModel.Instance.IsSinglePlayer()) ? (_currentPlayer != null && player.ActorNumber == _currentPlayer.ActorNumber) : (!IsRobotTurn));
		}
		return result;
	}

	public void GoNext()
	{
		Player nextPlayer = GetNextPlayer();
		if (nextPlayer != null)
		{
			ChangePlayerTo(nextPlayer);
			return;
		}
		IsRobotTurn = !IsRobotTurn;
		UpdateTimePanel();
	}

	internal void ChangePlayerTo(Player player)
	{
		base.photonView.RPC("SetPlayer", RpcTarget.All, player);
		base.photonView.RPC("UpdateTimePanel", RpcTarget.All);
	}

	[PunRPC]
	public void SetPlayer(Player player)
	{
		if (player == null)
		{
			UnityEngine.Debug.LogError("TurnMgr::SetPlayer(): Can not set current player to null!");
			return;
		}
		UnityEngine.Debug.LogFormat("SetPlayer(): setting player to {0}", player.ActorNumber);
		_currentPlayer = player;
	}

	[PunRPC]
	public void UpdateTimePanel()
	{
		if (ShouldPlay(PhotonNetwork.LocalPlayer))
		{
			GameView.Instance.ShowTimePanel();
		}
		else
		{
			GameView.Instance.DestoryTimePanel();
		}
	}
}
public class GamePopupPresenter : MonoBehaviour
{
	[SerializeField]
	private TMP_Text _message;

	[SerializeField]
	private TMP_Text _subMessage;

	public void UpdateMessage(string message, string subMessage, float selfDestroyTime)
	{
		if (message != null)
		{
			_message.text = message;
		}
		if (subMessage != null)
		{
			_subMessage.text = subMessage;
		}
		UnityEngine.Object.Destroy(base.gameObject, selfDestroyTime);
	}
}
public class LeaderBoardPresenter : MonoBehaviour
{
	[SerializeField]
	private TMP_Text[] _idFields;

	[SerializeField]
	private TMP_Text[] _scoreFields;

	private void OnEnable()
	{
	}

	private void OnDisable()
	{
	}

	private void Start()
	{
		UpdateScore();
	}

	private void Update()
	{
	}

	private void UpdateScore()
	{
		DataSourceFactory.GetDataSource().GetStatisticService().GetTopStatistics(OnGetTopStatistics);
	}

	private void OnGetTopStatistics(Statistic[] statistics)
	{
		if (statistics != null)
		{
			ClearTable(_idFields);
			ClearTable(_scoreFields);
			for (int i = 0; i < statistics.Length && i < 10; i++)
			{
				_idFields[i].text = statistics[i].account_id.ToString();
				_scoreFields[i].text = statistics[i].total_count.ToString();
				DataSourceFactory.GetDataSource().GetAccountService().GetAccount(statistics[i].account_id, OnGetAccount);
			}
		}
	}

	private void OnGetAccount(Account account)
	{
		for (int i = 0; i < _idFields.Length; i++)
		{
			if (_idFields[i].text.Equals(account.account_id.ToString()))
			{
				_idFields[i].text = account.name;
			}
		}
	}

	private void ClearTable(TMP_Text[] table)
	{
		for (int i = 0; i < table.Length; i++)
		{
			table[i].text = "";
		}
	}
}
public class LoadMenuPresenter : MonoBehaviour
{
	public Material[] pages;

	public GameObject[] selectSigns;

	public TMP_Text selectedCount;

	private int pageSize;

	private int startLevel;

	private int levelOffset;

	private int totalLevels;

	[HideInInspector]
	public List<int> selectedIndexes;

	private void Start()
	{
		selectedIndexes = new List<int>();
		startLevel = 0;
		levelOffset = 0;
		pageSize = pages.Length;
		totalLevels = GameRoundMgr.Instance.TotalLevels;
		LoadNextLevels();
	}

	private void OnEnable()
	{
		totalLevels = GameRoundMgr.Instance.TotalLevels;
		selectedCount.text = "0";
		for (int i = 0; i < selectSigns.Length; i++)
		{
			selectSigns[i].SetActive(value: false);
		}
		selectedIndexes.Clear();
	}

	private void Update()
	{
	}

	public void LoadNextLevels()
	{
		int num = levelOffset + pageSize;
		if (num > totalLevels)
		{
			UnityEngine.Debug.LogWarningFormat("LoadNextLevels(): No enough levels! startLevel={0}, endIndex={1}, totalLevels={2}", startLevel, num, totalLevels);
		}
		else
		{
			startLevel = levelOffset;
			LoadLevels();
			RefreshSelectionState();
		}
	}

	public void LoadPrevLevels()
	{
		startLevel -= pageSize;
		if (startLevel < 0)
		{
			startLevel = 0;
		}
		LoadLevels();
		RefreshSelectionState();
	}

	private void RefreshSelectionState()
	{
		for (int i = 0; i < selectSigns.Length; i++)
		{
			if (selectedIndexes.Contains(startLevel + i))
			{
				selectSigns[i].SetActive(value: true);
			}
			else
			{
				selectSigns[i].SetActive(value: false);
			}
		}
	}

	private void LoadLevels()
	{
		int num = startLevel + pageSize;
		if (num > totalLevels)
		{
			UnityEngine.Debug.LogErrorFormat("LoadLevels(): out of range! startLevel={0}, endIndex={1}, totalLevels={2}", startLevel, num, totalLevels);
			return;
		}
		int num2 = 0;
		for (int i = startLevel; i < num; i++)
		{
			if (GameRoundMgr.Instance.GetGameRound(i) != null)
			{
				Texture roundTexture = GameRoundMgr.Instance.GetRoundTexture(i);
				if (roundTexture != null)
				{
					pages[num2].mainTexture = roundTexture;
				}
				else
				{
					UnityEngine.Debug.LogWarningFormat("There is no texture for game round #{0}", i);
				}
			}
			num2++;
		}
		levelOffset = num;
	}

	public void OnRoundSelected(int index)
	{
		int item = startLevel + index;
		if (selectedIndexes.Contains(item))
		{
			selectedIndexes.Remove(item);
			selectSigns[index].SetActive(value: false);
		}
		else if (selectedIndexes.Count < LevelMgr.Instance.count)
		{
			selectedIndexes.Add(item);
			selectSigns[index].SetActive(value: true);
		}
		selectedCount.text = selectedIndexes.Count.ToString();
	}
}
public class MessagePresenter : MonoBehaviour
{
	private TMP_Text msg;

	private void Start()
	{
		msg = GetComponent<TMP_Text>();
	}

	private void Update()
	{
		if (LobbyMgr.Instance.GetAccountIDs().Count == 0)
		{
			msg.text = "";
		}
		else
		{
			msg.text = "";
		}
	}
}
public class PointsPresenter : MonoBehaviour
{
	public AudioClip pointsSound;

	private Vector3 pos;

	private float speed;

	private void Start()
	{
		pos = base.transform.localPosition;
		speed = 100f;
	}

	private void Update()
	{
		pos.Set(0f, pos.y + Time.deltaTime * speed, 0f);
		base.transform.localPosition = pos;
	}

	public void ShowNumber(int number, float selfDestroyTime)
	{
		GetComponent<Text>().text = "+" + number;
		AudioSource.PlayClipAtPoint(pointsSound, base.transform.position);
		UnityEngine.Object.Destroy(base.gameObject, selfDestroyTime);
	}
}
public class PromotionPresenter : MonoBehaviour
{
	private TMP_Text title;

	private TMP_Text message;

	private int typeID;

	private void Start()
	{
		title = GetComponent<TMP_Text>();
		message = base.transform.Find("Message").GetComponent<TMP_Text>();
		DataSourceFactory.GetDataSource().GetPromotionService().GetPromotions(typeID, OnGetPromotions);
	}

	private void OnGetPromotions(Promotion[] obj)
	{
		if (obj != null && obj.Length != 0)
		{
			title.text = obj[0].title;
			message.text = obj[0].message;
		}
	}

	private void OnGetPromotion(Promotion obj)
	{
		if (obj != null)
		{
			title.text = obj.title;
			message.text = obj.message;
		}
	}

	private void Update()
	{
	}
}
public class ScoreTextField : MonoBehaviour
{
	[Serializable]
	private struct ScoreFormat
	{
		public Color color;

		public string format;

		public void Apply(TextMesh text, int value)
		{
			text.color = color;
			text.text = string.Format(format, value);
		}
	}

	[SerializeField]
	private TextMesh _textField;

	[SerializeField]
	private ScoreFormat positiveScore;

	[SerializeField]
	private ScoreFormat negativeScore;

	private Vector3 _newPosition;

	private Quaternion _newRotation;

	public void SetValue(int value)
	{
		if (value >= 0)
		{
			positiveScore.Apply(_textField, value);
		}
		else
		{
			negativeScore.Apply(_textField, value);
		}
		_newRotation = Camera.main.transform.rotation;
		_newRotation.z = base.transform.rotation.z;
		base.transform.rotation = _newRotation;
	}

	private void Update()
	{
		_newPosition.y = Time.deltaTime;
		base.transform.position += _newPosition;
	}
}
public class ScoringPresenter : MonoBehaviour
{
	[SerializeField]
	private TMP_Text[] _idFields;

	[SerializeField]
	private Text[] _scoreFields;

	private void Update()
	{
	}

	public void UpdateScore(float selfDestroyTime)
	{
		Player[] playerList = PhotonNetwork.PlayerList;
		foreach (Player player in playerList)
		{
			object obj = player.CustomProperties["position"];
			if (obj != null)
			{
				int num = (int)obj;
				_idFields[num].text = player.CustomProperties["name"].ToString();
				_scoreFields[num].text = player.CustomProperties["roundScore"].ToString();
			}
		}
		if (PhotonNetwork.PlayerList.Length < 2)
		{
			_idFields[1].text = ISILocalization.GetValueOf(R3.strings.Robot.key);
			if (GameModel.Instance.ActiveGameState is ScoringGameState || GameModel.Instance.ActiveGameState is FinishedGameState)
			{
				_scoreFields[1].text = (GameModel.Instance.CurrentLevel + 1 - (int)PhotonNetwork.PlayerList[0].CustomProperties["roundScore"]).ToString();
			}
			else
			{
				_scoreFields[1].text = "0";
			}
		}
		UnityEngine.Object.Destroy(base.gameObject, selfDestroyTime);
	}

	private void ClearTable(TMP_Text[] table)
	{
		for (int i = 0; i < table.Length; i++)
		{
			table[i].text = "";
		}
	}
}
public class StatusPopupPresenter : MonoBehaviour
{
	[SerializeField]
	private TMP_Text _message;

	public void UpdateMessage(string message, float selfDestroyTime)
	{
		if (message != null)
		{
			_message.text = message;
		}
		UnityEngine.Object.Destroy(base.gameObject, selfDestroyTime);
	}
}
public class UserProfilePresenter : MonoBehaviour
{
	[SerializeField]
	private TMP_Text[] _idFields;

	[SerializeField]
	private TMP_Text[] _scoreFields;

	[SerializeField]
	private TMP_Text[] _medalFields;

	private List<int> accountIds;

	private void OnEnable()
	{
		NetworkController.OnUpdateScore += UpdateProfile;
		LobbyMgr.OnAccountGetted += UpdateProfile;
	}

	private void OnDisable()
	{
		NetworkController.OnUpdateScore -= UpdateProfile;
		LobbyMgr.OnAccountGetted -= UpdateProfile;
	}

	private void Start()
	{
		Invoke("UpdateProfile", 1f);
		accountIds = new List<int>();
	}

	private void Update()
	{
	}

	private void UpdateProfile()
	{
		List<Account> accounts = LobbyMgr.Instance.accounts;
		for (int i = 0; i < accounts.Count; i++)
		{
			accountIds.Add(accounts[i].account_id);
			_idFields[i].text = accounts[i].name;
			DataSourceFactory.GetDataSource().GetStatisticService().GetStatistic(accounts[i].account_id, OnGetStatistic);
		}
	}

	private void OnGetStatistic(Statistic[] obj)
	{
		if (obj != null)
		{
			int num = accountIds.IndexOf(obj[0].account_id);
			_scoreFields[num].text = obj[0].total_count.ToString();
			_medalFields[num].text = (obj[0].total_count / 10000).ToString();
		}
	}

	private void ClearTable(TMP_Text[] table)
	{
		for (int i = 0; i < table.Length; i++)
		{
			table[i].text = "";
		}
	}
}
public class VrGazeClicker : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler
{
	public float activationTime = 3f;

	public UnityEvent onAction;

	private float timer = -1f;

	public void OnPointerEnter(PointerEventData eventData)
	{
		timer = 0f;
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		timer = -1f;
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		ExecuteAction();
	}

	private void Update()
	{
		if (!(timer < 0f))
		{
			timer += Time.deltaTime;
			if (timer >= activationTime)
			{
				ExecuteAction();
			}
		}
	}

	private void ExecuteAction()
	{
		onAction.Invoke();
		timer = -1f;
	}
}
public class Wand : MonoBehaviour
{
	public bool IsActive;

	public GameObject magicFx;

	public ParticleSystem hitEffect;

	[SerializeField]
	protected PhotonView _photonView;

	private AudioSource _shotSound;

	private Player localPlayer;

	private bool _removeBlockByRobot;

	private float _interval;

	private Vector3 offset;

	public IPlayer player { get; set; }

	public int GunIndex { get; set; }

	private void Start()
	{
		_shotSound = GetComponent<AudioSource>();
		localPlayer = PhotonNetwork.LocalPlayer;
		if (GunIndex < 0)
		{
			GetComponent<Renderer>().enabled = false;
		}
		offset = new Vector3(0.001f, 0.001f, 0.001f);
	}

	private void Update()
	{
		if (!_photonView.IsMine)
		{
			return;
		}
		if (GunIndex >= 0)
		{
			base.transform.position = player.GetWandPosition(GunIndex);
			base.transform.rotation = player.GetWandRotation(GunIndex);
		}
		if (GameModel.Instance.IsSinglePlayer())
		{
			if (GunIndex != -1)
			{
				IsActive = TurnMgr.Instance.ShouldPlay(localPlayer);
			}
			else
			{
				IsActive = false;
				if (_removeBlockByRobot)
				{
					_interval += Time.deltaTime;
					if (_interval >= 2f)
					{
						_interval = 0f;
						RemoveBlockByRobot();
						_removeBlockByRobot = false;
						TurnMgr.Instance.GoNext();
					}
				}
				if (TurnMgr.Instance.IsRobotTurn)
				{
					_removeBlockByRobot = true;
				}
			}
		}
		else
		{
			IsActive = TurnMgr.Instance.ShouldPlay(localPlayer);
		}
		magicFx.SetActive(IsActive);
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag.Equals("BlockItem"))
		{
			RemoveBlockByPlayer(other.gameObject);
		}
	}

	public void RemoveBlockByPlayer(GameObject block)
	{
		if (_photonView.IsMine && GameModel.Instance.IsPlaying() && TurnMgr.Instance.ShouldPlay(localPlayer))
		{
			PhotonView photonView = PhotonView.Get(block);
			UnityEngine.Debug.LogFormat("Transfering ownership of {0} from {1} to {2}", photonView.ViewID, photonView.OwnerActorNr, PhotonNetwork.LocalPlayer.ActorNumber);
			photonView.TransferOwnership(PhotonNetwork.LocalPlayer);
			_photonView.RPC("PlayHitFeedback", RpcTarget.All, block.transform.position);
			PhotonNetwork.Destroy(block);
			TurnMgr.Instance.GoNext();
		}
	}

	public void RemoveBlockByRobot()
	{
		if (!GameModel.Instance.IsPlaying())
		{
			return;
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("BlockItem");
		if (array == null || array.Length == 0)
		{
			return;
		}
		GameObject gameObject = null;
		for (int i = 0; i < array.Length; i++)
		{
			BoxCollider component = array[i].GetComponent<BoxCollider>();
			if (Physics.OverlapBox(array[i].transform.position + component.center, Vector3.Scale(component.size, array[i].transform.lossyScale) / 2f + offset, array[i].transform.rotation, 1 << LayerMask.NameToLayer("Distructable")).Length < 2)
			{
				gameObject = array[i];
				break;
			}
		}
		if (gameObject == null)
		{
			gameObject = array[UnityEngine.Random.Range(0, array.Length)];
		}
		PhotonView photonView = PhotonView.Get(gameObject);
		UnityEngine.Debug.LogFormat("Transfering ownership of {0} from {1} to {2}", photonView.ViewID, photonView.OwnerActorNr, PhotonNetwork.LocalPlayer.ActorNumber);
		photonView.TransferOwnership(PhotonNetwork.LocalPlayer);
		UnityEngine.Debug.Log("Destroying networked game object");
		_photonView.RPC("PlayHitFeedback", RpcTarget.All, gameObject.transform.position);
		PhotonNetwork.Destroy(gameObject);
	}

	[PunRPC]
	public void PlayHitFeedback(Vector3 pos)
	{
		PlayShotSound();
		hitEffect.transform.position = pos;
		hitEffect.Play();
	}

	private void PlayShotSound()
	{
		_shotSound.PlayOneShot(_shotSound.clip);
	}
}
public class Target : MonoBehaviourPun
{
	private AudioSource sound;

	private void Start()
	{
		sound = GetComponent<AudioSource>();
	}

	private void Update()
	{
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((base.photonView.Owner == null || base.photonView.IsMine) && GameModel.Instance.isStarted && (collision.gameObject.layer == LayerMask.NameToLayer("Ground") || collision.gameObject.layer == LayerMask.NameToLayer("Desk")))
		{
			base.photonView.RPC("PlaySound", RpcTarget.All);
			UpdateRoundScore();
			GameModel.Instance.isStarted = false;
			GameModel.Instance.ChangeGameState(new ScoringGameState());
			NetworkController.Instance.NotifyChangeToScoringingState();
			NetworkController.Instance.NotifyRoundEnded(GameModel.Instance.WinningPlayer);
		}
	}

	private void UpdateRoundScore()
	{
		Player winningPlayer = GameModel.Instance.WinningPlayer;
		if (winningPlayer != null)
		{
			GameModel.Instance.CountScoreToPlayer(winningPlayer.ActorNumber, 1);
			GameModel.Instance.CountPointToPlayer(winningPlayer.ActorNumber, 100);
		}
	}

	[PunRPC]
	public void PlaySound()
	{
		sound.Play();
	}
}
public class ExplosionController : MonoBehaviour
{
	[SerializeField]
	private ParticleSystem _particleSystem;

	public void SetColor(Color color)
	{
		if (_particleSystem != null)
		{
			_particleSystem.startColor = color;
			_particleSystem.Play();
		}
	}
}
public class SpawnPoint : MonoBehaviour
{
	[SerializeField]
	private int spawnpointId;

	public void Awake()
	{
		GetComponent<MeshRenderer>().material.color = Color.grey;
	}

	public void OnPhotonPlayerPropertiesChanged(object[] playerAndUpdatedProps)
	{
		ExitGames.Client.Photon.Hashtable hashtable = (ExitGames.Client.Photon.Hashtable)playerAndUpdatedProps[1];
		if (hashtable.ContainsKey("position") && (int)hashtable["position"] == spawnpointId)
		{
			GetComponent<MeshRenderer>().material.color = PlayerFactory.GetColor(spawnpointId);
		}
	}

	public void OnPhotonPlayerDisconnected(Player player)
	{
		if (player.CustomProperties.ContainsKey("position") && (int)player.CustomProperties["position"] == spawnpointId)
		{
			GetComponent<MeshRenderer>().material.color = Color.grey;
		}
	}

	public void RestoreDefaults()
	{
		GetComponent<MeshRenderer>().material.color = Color.grey;
	}
}
public class PlaySoundEffect : MonoBehaviour
{
	private AudioSource soundEffect;

	public void Awake()
	{
		soundEffect = GetComponent<AudioSource>();
	}

	public void Update()
	{
		if (!soundEffect.isPlaying)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
namespace BitStrap
{
	public static class UnityWebRequestHelper
	{
		public static UnityEngine.AsyncOperation SendWebRequest(UnityWebRequest webRequest)
		{
			return webRequest.SendWebRequest();
		}

		public static bool IsSuccess(UnityWebRequest webRequest)
		{
			if (!webRequest.isNetworkError)
			{
				return !webRequest.isHttpError;
			}
			return false;
		}
	}
	public static class BitArrayExtensions
	{
	}
	public static class MemberInfoExtensions
	{
	}
	public static class TypeExtensions
	{
		public static bool IsByValue(this Type self)
		{
			return self.IsValueType;
		}
	}
	public static class ArrayExtensions
	{
		public static int Count<T>(this T[] collection, Predicate<T> predicate)
		{
			if (predicate == null)
			{
				return 0;
			}
			int num = 0;
			for (int i = 0; i < collection.Length; i++)
			{
				if (predicate(collection[i]))
				{
					num++;
				}
			}
			return num;
		}

		public static bool All<T>(this T[] collection, Predicate<T> predicate)
		{
			if (predicate == null)
			{
				return false;
			}
			for (int i = 0; i < collection.Length; i++)
			{
				if (!predicate(collection[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static bool Any<T>(this T[] collection)
		{
			return collection.Length != 0;
		}

		public static bool Any<T>(this T[] collection, Predicate<T> predicate)
		{
			if (predicate == null)
			{
				return false;
			}
			for (int i = 0; i < collection.Length; i++)
			{
				if (predicate(collection[i]))
				{
					return true;
				}
			}
			return false;
		}

		public static Option<T> First<T>(this T[] collection)
		{
			if (collection.Length != 0)
			{
				return new Option<T>(collection[0]);
			}
			return Functional.None;
		}

		public static Option<T> First<T>(this T[] collection, Predicate<T> predicate)
		{
			for (int i = 0; i < collection.Length; i++)
			{
				if (predicate(collection[i]))
				{
					return new Option<T>(collection[i]);
				}
			}
			return Functional.None;
		}

		public static string ToStringFull<T>(this T[] collection)
		{
			if (collection == null)
			{
				return "null";
			}
			if (collection.Length == 0)
			{
				return "[]";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("[ ");
			for (int i = 0; i < collection.Length - 1; i++)
			{
				stringBuilder.Append(collection[i].ToString());
				stringBuilder.Append(", ");
			}
			stringBuilder.Append(collection[^1].ToString());
			stringBuilder.Append(" ]");
			return stringBuilder.ToString();
		}
	}
	public static class Functional
	{
		public static readonly Unit Unit;

		public static readonly None None;

		public static object Ignore
		{
			set
			{
			}
		}

		public static Unit Do(Action callback)
		{
			callback();
			return Unit;
		}

		public static T Do<T>(Func<T> callback)
		{
			return callback();
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct None
	{
	}
	public static class Option
	{
		public sealed class UnwrapNoneException : Exception
		{
		}
	}
	public struct Option<A>
	{
		private static readonly Option<A> None;

		private readonly A value;

		private readonly bool isSome;

		public bool IsSome
		{
			get
			{
				if (isSome)
				{
					return value != null;
				}
				return false;
			}
		}

		public Option(A value)
		{
			this.value = value;
			isSome = value != null;
		}

		public static implicit operator Option<A>(A value)
		{
			return new Option<A>(value);
		}

		public static implicit operator Option<A>(None value)
		{
			return None;
		}

		public bool TryGet(out A value)
		{
			if (IsSome)
			{
				value = this.value;
				return true;
			}
			value = default(A);
			return false;
		}

		public B Match<B>(Func<A, B> some, Func<B> none)
		{
			if (IsSome)
			{
				return some(value);
			}
			return none();
		}

		public Unit Match(Action<A> some, Action none)
		{
			if (IsSome)
			{
				some(value);
			}
			else
			{
				none();
			}
			return Functional.Unit;
		}

		public Result<A, E> OkOr<E>(E error)
		{
			if (IsSome)
			{
				return new Result<A, E>(value);
			}
			return new Result<A, E>(error);
		}

		public Result<A, E> OkOrElse<E>(Func<E> onError)
		{
			if (IsSome)
			{
				return new Result<A, E>(value);
			}
			return new Result<A, E>(onError());
		}

		public A Unwrap()
		{
			if (IsSome)
			{
				return value;
			}
			throw new Option.UnwrapNoneException();
		}

		public A UnwrapOr(A noneValue)
		{
			if (IsSome)
			{
				return value;
			}
			return noneValue;
		}

		public A UnwrapOrElse(Func<A> onNone)
		{
			if (IsSome)
			{
				return value;
			}
			return onNone();
		}

		public bool IfSome(Action<A> onSome)
		{
			if (IsSome)
			{
				onSome(value);
				return true;
			}
			return false;
		}

		public Option<B> And<B>(Option<B> other)
		{
			if (IsSome)
			{
				return other;
			}
			return Option<B>.None;
		}

		public Option<B> AndThen<B>(Func<A, Option<B>> onOther)
		{
			if (IsSome)
			{
				return onOther(value);
			}
			return Option<B>.None;
		}

		public Option<A> Or(Option<A> other)
		{
			if (IsSome)
			{
				return this;
			}
			return other;
		}

		public Option<A> OrElse(Func<Option<A>> onOther)
		{
			if (IsSome)
			{
				return this;
			}
			return onOther();
		}

		public Option<B> Select<B>(Func<A, B> select)
		{
			if (IsSome)
			{
				return select(value);
			}
			return Option<B>.None;
		}

		public Option<A> Where(Predicate<A> predicate)
		{
			if (IsSome && predicate(value))
			{
				return this;
			}
			return None;
		}

		public Option<C> SelectMany<B, C>(Func<A, Option<B>> func, Func<A, B, C> select)
		{
			if (!IsSome)
			{
				return Option<C>.None;
			}
			Option<B> option = func(value);
			if (!option.IsSome)
			{
				return Option<C>.None;
			}
			return select(value, option.value);
		}
	}
	public sealed class Promise<A>
	{
		private Option<A> result;

		private readonly SafeAction<A> onComplete = new SafeAction<A>();

		public Option<A> Result => result;

		public void Then(Action<A> callback)
		{
			if (result.TryGet(out var value))
			{
				callback(value);
			}
			else
			{
				onComplete.Register(callback);
			}
		}

		public void Complete(A value)
		{
			result = value;
			onComplete.Call(value);
			onComplete.UnregisterAll();
		}

		public Promise<B> Select<B>(Func<A, B> select)
		{
			Promise<B> pb = new Promise<B>();
			Then(delegate(A a)
			{
				pb.Complete(select(a));
			});
			return pb;
		}

		public Promise<A> Where(Predicate<A> predicate)
		{
			Promise<A> p = new Promise<A>();
			Then(delegate(A a)
			{
				if (predicate(a))
				{
					p.Complete(a);
				}
			});
			return p;
		}

		public Promise<C> SelectMany<B, C>(Func<A, Promise<B>> func, Func<A, B, C> select)
		{
			Promise<C> pc = new Promise<C>();
			Then(delegate(A a)
			{
				func(a).Then(delegate(B b)
				{
					pc.Complete(select(a, b));
				});
			});
			return pc;
		}
	}
	public static class Result
	{
		public sealed class UnwrapErrorException : Exception
		{
		}
	}
	public struct Result<A, E>
	{
		private readonly A value;

		private readonly E error;

		public readonly bool isOk;

		public Option<A> Ok
		{
			get
			{
				if (!isOk)
				{
					return default(Option<A>);
				}
				return new Option<A>(value);
			}
		}

		public Option<E> Error
		{
			get
			{
				if (isOk)
				{
					return default(Option<E>);
				}
				return new Option<E>(error);
			}
		}

		public Result(A value)
		{
			this.value = value;
			error = default(E);
			isOk = true;
		}

		public Result(E error)
		{
			value = default(A);
			this.error = error;
			isOk = false;
		}

		public static implicit operator Result<A, E>(A value)
		{
			return new Result<A, E>(value);
		}

		public static implicit operator Result<A, E>(E error)
		{
			return new Result<A, E>(error);
		}

		public B Match<B>(Func<A, B> ok, Func<E, B> error)
		{
			if (isOk)
			{
				return ok(value);
			}
			return error(this.error);
		}

		public Unit Match(Action<A> ok, Action<E> error)
		{
			if (isOk)
			{
				ok(value);
			}
			else
			{
				error(this.error);
			}
			return Functional.Unit;
		}

		public A Unwrap()
		{
			if (isOk)
			{
				return value;
			}
			throw new Result.UnwrapErrorException();
		}

		public A UnwrapOr(A errorValue)
		{
			if (isOk)
			{
				return value;
			}
			return errorValue;
		}

		public A UnwrapOrElse(Func<E, A> onError)
		{
			if (isOk)
			{
				return value;
			}
			return onError(error);
		}

		public Unit IfOk(Action<A> onOk)
		{
			if (isOk)
			{
				onOk(value);
			}
			return Functional.Unit;
		}

		public Result<B, E> And<B>(Result<B, E> other)
		{
			if (isOk)
			{
				return other;
			}
			return new Result<B, E>(error);
		}

		public Result<B, E> AndThen<B>(Func<A, Result<B, E>> onOther)
		{
			if (isOk)
			{
				return onOther(value);
			}
			return new Result<B, E>(error);
		}

		public Result<A, E> Or(Result<A, E> other)
		{
			if (isOk)
			{
				return this;
			}
			return other;
		}

		public Result<A, E> OrElse(Func<E, Result<A, E>> onOther)
		{
			if (isOk)
			{
				return this;
			}
			return onOther(error);
		}

		public Result<B, E> Select<B>(Func<A, B> select)
		{
			if (isOk)
			{
				return select(value);
			}
			return new Result<B, E>(error);
		}

		public Result<A, E> Where(Predicate<A> predicate)
		{
			if (isOk && predicate(value))
			{
				return this;
			}
			return new Result<A, E>(error);
		}

		public Result<C, E> SelectMany<B, C>(Func<A, Result<B, E>> func, Func<A, B, C> select)
		{
			if (!isOk)
			{
				return new Result<C, E>(error);
			}
			Result<B, E> result = func(value);
			if (!result.isOk)
			{
				return new Result<C, E>(error);
			}
			return select(value, result.value);
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Unit
	{
	}
	public sealed class SafeAction
	{
		private readonly List<Action> actions = new List<Action>();

		public int Count => actions.Count;

		public void Register(Action a)
		{
			if (!actions.Contains(a))
			{
				actions.Add(a);
			}
		}

		public void Unregister(Action a)
		{
			actions.Remove(a);
		}

		public void UnregisterAll()
		{
			actions.Clear();
		}

		public void Call()
		{
			for (int i = 0; i < actions.Count; i++)
			{
				try
				{
					if (actions[i] != null)
					{
						actions[i]();
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
		}
	}
	public sealed class SafeAction<T>
	{
		private List<Action<T>> actions = new List<Action<T>>();

		public int Count => actions.Count;

		public void Register(Action<T> a)
		{
			if (!actions.Contains(a))
			{
				actions.Add(a);
			}
		}

		public void Unregister(Action<T> a)
		{
			actions.Remove(a);
		}

		public void UnregisterAll()
		{
			actions.Clear();
		}

		public void Call(T p1)
		{
			for (int i = 0; i < actions.Count; i++)
			{
				try
				{
					if (actions[i] != null)
					{
						actions[i](p1);
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
		}
	}
	public sealed class SafeAction<T1, T2>
	{
		private List<Action<T1, T2>> actions = new List<Action<T1, T2>>();

		public int Count => actions.Count;

		public void Register(Action<T1, T2> a)
		{
			if (!actions.Contains(a))
			{
				actions.Add(a);
			}
		}

		public void Unregister(Action<T1, T2> a)
		{
			actions.Remove(a);
		}

		public void UnregisterAll()
		{
			actions.Clear();
		}

		public void Call(T1 p1, T2 p2)
		{
			for (int i = 0; i < actions.Count; i++)
			{
				try
				{
					if (actions[i] != null)
					{
						actions[i](p1, p2);
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
			}
		}
	}
}
namespace Framework
{
	public abstract class MonoSingleton<T> : MonoBehaviour where T : MonoSingleton<T>
	{
		protected static T instance = null;

		private static object Singleton_Lock = new object();

		public static T Instance()
		{
			if (instance == null)
			{
				T[] array = UnityEngine.Object.FindObjectsOfType<T>();
				if (array.Length >= 1)
				{
					instance = array[0];
				}
			}
			return instance;
		}

		protected virtual void OnDestroy()
		{
			instance = null;
		}
	}
	public class Singleton<T> where T : class
	{
		private static T _instance;

		private static readonly object SyncObject = new object();

		public static T Instance
		{
			get
			{
				if (_instance == null)
				{
					lock (SyncObject)
					{
						if (_instance == null)
						{
							_instance = (T)Activator.CreateInstance(typeof(T), nonPublic: true);
						}
					}
				}
				return _instance;
			}
		}
	}
}
namespace HoloToolkit.Unity
{
	public enum PivotAxis
	{
		Free,
		Y
	}
	public class Billboard : MonoBehaviour
	{
		[Tooltip("Specifies the axis about which the object will rotate.")]
		public PivotAxis PivotAxis;

		[Tooltip("Specifies the target we will orient to. If no Target is specified the main camera will be used.")]
		private Transform TargetTransform;

		private void OnEnable()
		{
			if (TargetTransform == null)
			{
				TargetTransform = Camera.main.transform;
			}
			Update();
		}

		private void Update()
		{
			if (!(TargetTransform == null))
			{
				Vector3 vector = TargetTransform.position - base.transform.position;
				PivotAxis pivotAxis = PivotAxis;
				if (pivotAxis != 0 && pivotAxis == PivotAxis.Y)
				{
					vector.y = 0f;
				}
				if (!(vector.sqrMagnitude < 0.001f))
				{
					base.transform.rotation = Quaternion.LookRotation(-vector);
				}
			}
		}
	}
}
namespace ExitGames.SportShooting
{
	public class BasePlayer : MonoBehaviour, IPlayer, IPunInstantiateMagicCallback
	{
		[SerializeField]
		protected GameObject cameraRig;

		[SerializeField]
		protected Transform uiRoot;

		[SerializeField]
		protected Transform uiRootRight;

		[SerializeField]
		protected Transform uiRootLeft;

		[SerializeField]
		protected Transform sideUiRoot;

		[SerializeField]
		protected Transform frontUiRoot;

		[SerializeField]
		protected int numberOfGuns = 1;

		[SerializeField]
		protected GameObject speakingFeedback;

		[SerializeField]
		protected PhotonView photonView;

		protected PhotonVoiceView voiceView;

		protected List<Wand> wands = new List<Wand>();

		public virtual GameObject GameObject => base.gameObject;

		public virtual Transform UiRoot => uiRoot;

		public virtual Transform UiRootLeft => uiRootLeft;

		public virtual Transform UiRootRight => uiRootRight;

		public virtual Transform SideUiRoot => sideUiRoot;

		public virtual Transform FrontUiRoot => frontUiRoot;

		public virtual Transform RightHandAnchor => null;

		public virtual void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			voiceView = GetComponent<PhotonVoiceView>();
			if (photonView.IsMine)
			{
				for (int i = 0; i < numberOfGuns; i++)
				{
					Wand component = PhotonNetwork.Instantiate("Wand", base.transform.position, base.transform.rotation, 0).GetComponent<Wand>();
					component.player = this;
					component.GunIndex = i;
					wands.Add(component);
				}
			}
		}

		private void Update()
		{
			speakingFeedback.SetActive(voiceView != null && !photonView.IsMine && voiceView.SpeakerInUse.IsPlaying);
		}

		public virtual void GameSetup()
		{
			UiRoot.gameObject.SetActive(value: true);
			SideUiRoot.gameObject.SetActive(value: true);
			foreach (Wand wand in wands)
			{
				wand.gameObject.SetActive(value: true);
			}
		}

		public virtual void MenuSetup()
		{
			UiRoot.gameObject.SetActive(value: true);
			UiRootLeft.gameObject.SetActive(value: true);
			UiRootRight.gameObject.SetActive(value: true);
			SideUiRoot.gameObject.SetActive(value: true);
			foreach (Wand wand in wands)
			{
				wand.gameObject.SetActive(value: false);
			}
		}

		public virtual bool GunTriggerPressed(int gunIndex)
		{
			return false;
		}

		public virtual bool AimingLaserPressed(int gunIndex)
		{
			return false;
		}

		public virtual Vector3 GetWandPosition(int gunIndex)
		{
			return base.transform.position;
		}

		public virtual Quaternion GetWandRotation(int gunIndex)
		{
			return Quaternion.identity;
		}

		public virtual List<Wand> GetWands()
		{
			return wands;
		}

		private void OnDestroy()
		{
			List<Wand> list = GetWands();
			if (list == null)
			{
				return;
			}
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i] != null)
				{
					PhotonNetwork.Destroy(list[i].gameObject);
				}
			}
		}
	}
	public class MainMenuPresenter : MonoBehaviour
	{
		public void OnStartButtonClick()
		{
			UnityEngine.Debug.Log("MainMenuPresenter OnStartButtonClick() was called.");
		}
	}
	public class VrAnchor : MonoBehaviour
	{
		private static Dictionary<string, VrAnchor> anchors = new Dictionary<string, VrAnchor>();

		public string anchorName;

		private void OnEnable()
		{
			anchors[anchorName] = this;
		}

		private void OnDisable()
		{
			anchors[anchorName] = null;
		}

		public static VrAnchor FindAnchor(string s)
		{
			return anchors[s];
		}
	}
	public class VrUi : MonoBehaviour
	{
		public string anchorName;

		public bool followRotation;

		public bool followLocalPlayer;

		private RectTransform rectTransform;

		private VrAnchor activeAnchor;

		private bool forceUpdate;

		private void Awake()
		{
			rectTransform = GetComponent<RectTransform>();
		}

		private void OnEnable()
		{
			activeAnchor = VrAnchor.FindAnchor(anchorName);
			if (!(activeAnchor == null))
			{
				forceUpdate = true;
			}
		}

		private void UpdatePosition()
		{
			rectTransform.position = activeAnchor.transform.position;
			if (followRotation)
			{
				rectTransform.rotation = activeAnchor.transform.rotation;
			}
			else
			{
				rectTransform.forward = activeAnchor.transform.forward;
			}
		}

		private void LateUpdate()
		{
			if (!(activeAnchor == null) && (followLocalPlayer || forceUpdate))
			{
				UpdatePosition();
				forceUpdate = false;
			}
		}
	}
	public class AimingLaser : MonoBehaviour
	{
		private float _maxRayDistance = 100f;

		[SerializeField]
		private LayerMask _hitLayer;

		private RaycastHit _hitInfo;

		private LineRenderer _lineRenderer;

		protected virtual void Awake()
		{
			_lineRenderer = GetComponent<LineRenderer>();
		}

		protected virtual void Update()
		{
			if (_lineRenderer.enabled && Physics.Raycast(base.transform.position, base.transform.forward, out _hitInfo, _maxRayDistance, _hitLayer))
			{
				_lineRenderer.SetPosition(0, base.transform.position);
				_lineRenderer.SetPosition(1, _hitInfo.point);
			}
			else
			{
				_lineRenderer.SetPosition(0, base.transform.position);
				_lineRenderer.SetPosition(1, base.transform.position + base.transform.forward * _maxRayDistance);
			}
		}

		protected void ToggleLaser()
		{
			_lineRenderer.enabled = !_lineRenderer.enabled;
		}
	}
	public class AutoRotation : MonoBehaviour
	{
		public Vector3 rotationSpeed;

		private void Update()
		{
			Vector3 eulerAngles = base.transform.localRotation.eulerAngles;
			eulerAngles += rotationSpeed * Time.deltaTime;
			base.transform.localRotation = Quaternion.Euler(eulerAngles);
		}
	}
	public class Destructible : MonoBehaviourPun
	{
		[SerializeField]
		private GameObject _explosionPrefab;

		[SerializeField]
		private GameObject _scorePrefab;

		[SerializeField]
		private float _autoDestructTime;

		public TrapThrowingConfiguration throwConfiguration;

		[SerializeField]
		private Color _color;

		[SerializeField]
		private Renderer _destructibleRenderer;

		[SerializeField]
		private bool _colorRenderer;

		[SerializeField]
		private int _hitValue;

		[SerializeField]
		private bool _distructableByHit = true;

		private bool _isHit;

		private float _timeAlive;

		private void Start()
		{
			if (_colorRenderer)
			{
				_destructibleRenderer.material.color = _color;
			}
		}

		private void Update()
		{
			if (base.photonView.IsMine)
			{
				_timeAlive += Time.deltaTime;
				if (_timeAlive >= _autoDestructTime)
				{
					PhotonNetwork.Destroy(base.gameObject);
					base.enabled = false;
				}
			}
		}

		private void OnCollisionEnter(Collision col)
		{
			base.photonView.RPC("DestroyByCollision", RpcTarget.All);
		}

		public void MarkToDestroy()
		{
			base.photonView.RPC("DestroyByHit", RpcTarget.AllViaServer, PhotonNetwork.LocalPlayer.ActorNumber);
		}

		[PunRPC]
		private void DestroyByCollision()
		{
			if (base.photonView.IsMine)
			{
				PhotonNetwork.Destroy(base.gameObject);
			}
		}

		[PunRPC]
		private void DestroyByHit(int hitPlayerId)
		{
			CalculateScore(hitPlayerId);
			ExplodeByHit(hitPlayerId);
			if (_distructableByHit)
			{
				UnityEngine.Object.Instantiate(Resources.Load("Helper/TargetHit"), base.transform.position, base.transform.rotation);
				if (base.photonView.IsMine)
				{
					PhotonNetwork.Destroy(base.gameObject);
				}
			}
			else if (hitPlayerId == PhotonNetwork.LocalPlayer.ActorNumber)
			{
				UnityEngine.Object.Instantiate(Resources.Load("Helper/BadTarget"), base.transform.position, base.transform.rotation);
			}
		}

		private void CalculateScore(int hitPlayerId)
		{
			if (hitPlayerId >= 0 && PhotonNetwork.IsMasterClient && !_isHit)
			{
				_isHit = _distructableByHit;
				GameModel.Instance.CountScoreToPlayer(hitPlayerId, _hitValue);
			}
		}

		private void ExplodeByHit(int hitPlayerId)
		{
			if (_distructableByHit && _explosionPrefab != null)
			{
				GameObject obj = UnityEngine.Object.Instantiate(_explosionPrefab, base.transform.position, Quaternion.identity);
				Rigidbody component = obj.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.velocity = GetComponent<Rigidbody>().velocity;
				}
				ExplosionController component2 = obj.GetComponent<ExplosionController>();
				if (component2 != null)
				{
					component2.SetColor(_color);
				}
			}
			if (_scorePrefab != null && hitPlayerId == PhotonNetwork.LocalPlayer.ActorNumber)
			{
				ScoreTextField component3 = UnityEngine.Object.Instantiate(_scorePrefab, base.transform.position, Quaternion.identity).GetComponent<ScoreTextField>();
				if (component3 != null)
				{
					component3.SetValue(_hitValue);
				}
			}
		}
	}
	[RequireComponent(typeof(PhotonView))]
	public class Holder : MonoBehaviour
	{
		protected virtual void Awake()
		{
			if (!GetComponent<PhotonView>().IsMine)
			{
				UnityEngine.Object.Destroy(this);
			}
		}
	}
	public class LaserPointer : MonoBehaviour
	{
		private float _maxRayDistance = 100f;

		[SerializeField]
		private LayerMask _hitLayer;

		private RaycastHit _hitInfo;

		private LineRenderer _lineRenderer;

		private void Awake()
		{
			_lineRenderer = GetComponent<LineRenderer>();
		}

		protected virtual void Update()
		{
			if (Physics.Raycast(base.transform.position, base.transform.forward, out _hitInfo, _maxRayDistance, _hitLayer))
			{
				_lineRenderer.SetPosition(0, base.transform.position);
				_lineRenderer.SetPosition(1, _hitInfo.point);
			}
			else
			{
				_lineRenderer.SetPosition(0, base.transform.position);
				_lineRenderer.SetPosition(1, base.transform.position + base.transform.forward * _maxRayDistance);
			}
		}

		protected void ClickOnHitObject()
		{
			if (Physics.Raycast(base.transform.position, base.transform.forward, out _hitInfo, _maxRayDistance, _hitLayer))
			{
				Button component = _hitInfo.collider.GetComponent<Button>();
				if (component != null)
				{
					component.onClick.Invoke();
				}
			}
		}
	}
	public class MiniButton
	{
		private bool pressed;

		private bool previous;

		public bool Pressed
		{
			set
			{
				previous = pressed;
				pressed = value;
			}
		}

		public bool IsDown()
		{
			if (pressed)
			{
				return !previous;
			}
			return false;
		}

		public bool IsUp()
		{
			if (!pressed)
			{
				return previous;
			}
			return false;
		}
	}
	public class NetItemsSynchronizer : MonoBehaviourPun, IPunObservable
	{
		[SerializeField]
		private GameObject[] _syncState;

		[SerializeField]
		private PhotonView _view;

		void IPunObservable.OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				for (int i = 0; i < _syncState.Length; i++)
				{
					stream.SendNext(_syncState[i].activeSelf);
				}
				return;
			}
			for (int j = 0; j < _syncState.Length; j++)
			{
				bool flag = (bool)stream.ReceiveNext();
				if (flag != _syncState[j].activeSelf)
				{
					_syncState[j].SetActive(flag);
				}
			}
		}

		public void ForceUpdate()
		{
			bool[] array = new bool[_syncState.Length];
			for (int i = 0; i < _syncState.Length; i++)
			{
				array[i] = _syncState[i].activeSelf;
			}
			base.photonView.RPC("ForceUpdateItem", RpcTarget.Others, array);
		}

		[PunRPC]
		private void ForceUpdateItem(bool[] parameters)
		{
			for (int i = 0; i < parameters.Length; i++)
			{
				_syncState[i].SetActive(parameters[i]);
			}
		}
	}
	public class PlayerColor : MonoBehaviour, IInRoomCallbacks, IPunInstantiateMagicCallback
	{
		private PhotonView photonView;

		private BasePlayer player;

		private void Awake()
		{
			photonView = base.transform.root.GetComponentInChildren<PhotonView>();
			player = GetComponent<BasePlayer>();
		}

		private void UpdatePlayerColor()
		{
			if (photonView.Owner != null && photonView.Owner.CustomProperties != null && !(player == null))
			{
				Color color = PlayerFactory.GetColor((int)photonView.Owner.CustomProperties["position"]);
				color.r += 0.25f;
				color.g += 0.25f;
				color.b += 0.25f;
				color.a = 1f;
			}
		}

		public void OnPlayerEnteredRoom(Player newPlayer)
		{
		}

		public void OnPlayerLeftRoom(Player otherPlayer)
		{
		}

		public void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
		}

		public void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (!(targetPlayer.UserId != photonView.Owner.UserId) && changedProps.ContainsKey("position"))
			{
				UpdatePlayerColor();
			}
		}

		public void OnMasterClientSwitched(Player newMasterClient)
		{
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			UpdatePlayerColor();
		}
	}
	public class Shooter : MonoBehaviour
	{
		[SerializeField]
		private LineRenderer _bulletTrace;

		[SerializeField]
		private Transform _tip;

		[SerializeField]
		private LayerMask _hitLayer;

		[SerializeField]
		private float _maxBulletDistance;

		[SerializeField]
		private NetItemsSynchronizer _synchronizer;

		private RaycastHit _hitInfo;

		[SerializeField]
		protected PhotonView _photonView;

		private AudioSource _shotSound;

		[Header("Feedback")]
		[SerializeField]
		private GameObject muzzleMesh;

		[SerializeField]
		private ParticleSystem muzzleFx;

		[SerializeField]
		private float decreaseSpeed = 2f;

		public void Awake()
		{
			_shotSound = GetComponent<AudioSource>();
			_bulletTrace.enabled = false;
		}

		protected void ShootAttempt()
		{
			_synchronizer.ForceUpdate();
			Vector3 vector = default(Vector3);
			if (Physics.Raycast(_tip.position, _tip.forward, out _hitInfo, _maxBulletDistance, _hitLayer))
			{
				vector = _hitInfo.transform.position;
				Destructible component = _hitInfo.collider.GetComponent<Destructible>();
				if (component != null)
				{
					component.MarkToDestroy();
				}
				NonUiButton component2 = _hitInfo.collider.GetComponent<NonUiButton>();
				if (component2 != null)
				{
					if (component2.CompareTag("EndMatchButton"))
					{
						component2.EndMatch();
					}
					else if (component2.CompareTag("LogoutButton"))
					{
						component2.LeaveMatch();
					}
				}
			}
			else
			{
				vector = _tip.position + _tip.forward * _maxBulletDistance;
			}
			_photonView.RPC("PlayShotFeedback", RpcTarget.All, _tip.position, vector);
			_synchronizer.ForceUpdate();
		}

		[PunRPC]
		public void PlayShotFeedback(Vector3 position, Vector3 finalPosition)
		{
			Vector3 normalized = (finalPosition - position).normalized;
			_bulletTrace.SetPosition(0, position);
			_bulletTrace.SetPosition(1, finalPosition);
			PlayShotSound();
			StopAllCoroutines();
			StartCoroutine(DisableBulletTrace(normalized, position));
		}

		private IEnumerator DisableBulletTrace(Vector3 direction, Vector3 initialPosition)
		{
			_bulletTrace.enabled = true;
			muzzleFx.Play();
			muzzleMesh.SetActive(value: true);
			yield return null;
			Material i = _bulletTrace.material;
			Color color = i.GetColor("_TintColor");
			color.a = 1f;
			while (color.a >= 0.1f)
			{
				color.a -= Time.deltaTime * decreaseSpeed;
				i.SetColor("_TintColor", color);
				yield return null;
				initialPosition += direction.normalized * decreaseSpeed / 2f;
				_bulletTrace.SetPosition(0, initialPosition);
				muzzleMesh.SetActive(value: false);
			}
			color.a = 0f;
			i.SetColor("_TintColor", color);
			_bulletTrace.enabled = false;
		}

		public void PlayShotSound()
		{
			_shotSound.PlayOneShot(_shotSound.clip);
		}
	}
	public class ShootingRangeFps : BasePlayer
	{
		[Header("Player Specific")]
		public Transform gunPivot;

		public Camera playerCamera;

		[Range(0.1f, 10f)]
		public float mouseSensitivity = 2f;

		[SerializeField]
		private GameObject canvas;

		private float rotationX;

		private float rotationY;

		public void Awake()
		{
			Cursor.lockState = CursorLockMode.Locked;
		}

		public void Update()
		{
			playerCamera.gameObject.SetActive(!PhotonNetwork.IsConnected || photonView.IsMine);
			if (!PhotonNetwork.IsConnected || photonView.IsMine)
			{
				MenuInteraction();
				LookAround();
			}
		}

		public void OnGUI()
		{
			if (!PhotonNetwork.IsConnected && !IsConnecting())
			{
				GUILayout.BeginVertical();
				GUILayout.Label("Press 'RETURN' to begin.");
				GUILayout.EndVertical();
			}
			if (photonView.IsMine && PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
			{
				GUILayout.BeginVertical();
				GUILayout.Label("Press 'ESC' to leave the game.");
				GUILayout.Space(100f);
				Player[] playerList = PhotonNetwork.PlayerList;
				foreach (Player player in playerList)
				{
					GUILayout.Label(string.Concat(player.CustomProperties["name"], ": ", player.CustomProperties["roundScore"]));
				}
				GUILayout.EndVertical();
			}
		}

		private void LookAround()
		{
			rotationX += Input.GetAxis("Mouse X") * mouseSensitivity;
			rotationY += Input.GetAxis("Mouse Y") * mouseSensitivity;
			rotationX = ((rotationX < -360f) ? (rotationX + 360f) : ((rotationX > 360f) ? (rotationX - 360f) : rotationX));
			rotationY = ((rotationY < -360f) ? (rotationY + 360f) : ((rotationY > 360f) ? (rotationY - 360f) : rotationY));
			Quaternion quaternion = Quaternion.AngleAxis(rotationX, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotationY, -Vector3.right);
			base.transform.rotation = Quaternion.identity * quaternion * quaternion2;
		}

		private void MenuInteraction()
		{
			if (Input.GetKeyDown(KeyCode.Return) && !PhotonNetwork.IsConnected && !IsConnecting())
			{
				GameController.Instance.StartMultiplayerGame();
			}
			if (Input.GetKeyDown(KeyCode.Escape) && PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
			{
				NetworkController.Instance.EndMultiplayerGame();
				GameController.Instance.InitMainMenu();
				PhotonNetwork.LocalPlayer.CustomProperties.Clear();
			}
		}

		public override void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			base.OnPhotonInstantiate(info);
			canvas.SetActive(photonView.IsMine);
		}

		private bool IsConnecting()
		{
			if (PhotonNetwork.NetworkClientState != ClientState.ConnectingToGameserver && PhotonNetwork.NetworkClientState != ClientState.ConnectingToMasterserver)
			{
				return PhotonNetwork.NetworkClientState == ClientState.ConnectingToNameServer;
			}
			return true;
		}

		public override bool GunTriggerPressed(int gunIndex)
		{
			if (PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
			{
				return Input.GetMouseButtonDown(0);
			}
			return false;
		}

		public override bool AimingLaserPressed(int gunIndex)
		{
			if (PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
			{
				return Input.GetMouseButtonDown(1);
			}
			return false;
		}

		public override Vector3 GetWandPosition(int gunIndex)
		{
			return gunPivot.position;
		}

		public override Quaternion GetWandRotation(int gunIndex)
		{
			return gunPivot.rotation;
		}
	}
	public class ShootingRangePlayer : MonoBehaviour
	{
		[SerializeField]
		private Transform _uiRoot;

		[SerializeField]
		private Transform _sideUIRoot;

		[SerializeField]
		private GameObject _cameraRig;

		[SerializeField]
		private List<GameObject> _rifles;

		[SerializeField]
		private GameObject _laserPointer;

		public Transform UIRoot => _uiRoot;

		public Transform SideUIRoot => _sideUIRoot;

		public GameObject CameraRig => _cameraRig;

		public List<GameObject> Rifles => _rifles;

		public GameObject LaserPointer => _laserPointer;

		private void OnEnable()
		{
			PhotonView component = GetComponent<PhotonView>();
			if (!(component == null) && component.IsMine)
			{
				VrAnchor[] componentsInChildren = GetComponentsInChildren<VrAnchor>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].enabled = true;
				}
			}
		}

		public virtual void SetupForGame()
		{
		}
	}
	public class ShootingRangeRifle : MonoBehaviour
	{
		[FormerlySerializedAs("_bulletTrace")]
		public LineRenderer bulletTrace;

		[SerializeField]
		private Transform _tip;

		[SerializeField]
		private LayerMask _hitLayer;

		[SerializeField]
		private float _maxBulletDistance;

		[SerializeField]
		private GameObject aimingLaser;

		[SerializeField]
		private NetItemsSynchronizer _synchronizer;

		private RaycastHit _hitInfo;

		[SerializeField]
		protected PhotonView _photonView;

		private AudioSource _shotSound;

		[Header("Feedback")]
		[SerializeField]
		private GameObject muzzleMesh;

		[SerializeField]
		private ParticleSystem muzzleFx;

		[SerializeField]
		private float decreaseSpeed = 2f;

		private bool aimingLaserState = true;

		public IPlayer Player { get; set; }

		public int GunIndex { get; set; }

		public void Awake()
		{
			_shotSound = GetComponent<AudioSource>();
			bulletTrace.enabled = false;
			if (_photonView.IsMine)
			{
				_photonView.RPC("SetLaserState", RpcTarget.All, true);
			}
		}

		private void Update()
		{
			UnityEngine.Debug.Log("transform:" + base.transform.rotation);
			if (_photonView.IsMine)
			{
				if (Player.GunTriggerPressed(GunIndex))
				{
					ShootAttempt();
				}
				if (Player.AimingLaserPressed(GunIndex))
				{
					ToggleAimingLaser();
				}
				base.transform.position = Player.GetWandPosition(GunIndex);
				base.transform.rotation = Player.GetWandRotation(GunIndex);
				UnityEngine.Debug.Log("GunPos:" + Player.GetWandRotation(GunIndex));
			}
		}

		private void ToggleAimingLaser()
		{
			_photonView.RPC("SetLaserState", RpcTarget.All, !aimingLaserState);
		}

		[PunRPC]
		private void SetLaserState(bool state)
		{
			aimingLaserState = state;
			aimingLaser.SetActive(state);
		}

		public void ShootAttempt()
		{
			_synchronizer.ForceUpdate();
			Vector3 vector = default(Vector3);
			if (Physics.Raycast(_tip.position, _tip.forward, out _hitInfo, _maxBulletDistance, _hitLayer))
			{
				vector = _hitInfo.transform.position;
				Destructible component = _hitInfo.collider.GetComponent<Destructible>();
				if (component != null)
				{
					component.MarkToDestroy();
				}
				NonUiButton component2 = _hitInfo.collider.GetComponent<NonUiButton>();
				if (component2 != null)
				{
					if (component2.CompareTag("EndMatchButton"))
					{
						component2.EndMatch();
					}
					else if (component2.CompareTag("LogoutButton"))
					{
						component2.LeaveMatch();
					}
				}
			}
			else
			{
				vector = _tip.position + _tip.forward * _maxBulletDistance;
			}
			_photonView.RPC("PlayShotFeedback", RpcTarget.All, _tip.position, vector);
			_synchronizer.ForceUpdate();
		}

		[PunRPC]
		public void PlayShotFeedback(Vector3 position, Vector3 finalPosition)
		{
			Vector3 normalized = (finalPosition - position).normalized;
			bulletTrace.SetPosition(0, position);
			bulletTrace.SetPosition(1, finalPosition);
			PlayShotSound();
			StopAllCoroutines();
			StartCoroutine(DisableBulletTrace(normalized, position));
		}

		private IEnumerator DisableBulletTrace(Vector3 direction, Vector3 initialPosition)
		{
			bulletTrace.enabled = true;
			muzzleFx.Play();
			muzzleMesh.SetActive(value: true);
			yield return null;
			Material i = bulletTrace.material;
			Color color = i.GetColor("_TintColor");
			color.a = 1f;
			while (color.a >= 0.1f)
			{
				color.a -= Time.deltaTime * decreaseSpeed;
				i.SetColor("_TintColor", color);
				yield return null;
				initialPosition += direction.normalized * decreaseSpeed / 2f;
				bulletTrace.SetPosition(0, initialPosition);
				muzzleMesh.SetActive(value: false);
			}
			color.a = 0f;
			i.SetColor("_TintColor", color);
			bulletTrace.enabled = false;
		}

		public void PlayShotSound()
		{
			_shotSound.PlayOneShot(_shotSound.clip);
		}
	}
	public class ShootingRangeRift : BasePlayer
	{
		[Header("Player Specific")]
		public Transform leftHandPivot;

		public Transform rightHandPivot;

		public override Transform RightHandAnchor => rightHandPivot;

		public override void GameSetup()
		{
			base.GameSetup();
		}

		public override void MenuSetup()
		{
			base.MenuSetup();
		}

		public override bool GunTriggerPressed(int gunIndex)
		{
			return false;
		}

		public override bool AimingLaserPressed(int gunIndex)
		{
			return false;
		}

		public override Vector3 GetWandPosition(int gunIndex)
		{
			if (gunIndex != 0)
			{
				return leftHandPivot.position;
			}
			return rightHandPivot.position;
		}

		public override Quaternion GetWandRotation(int gunIndex)
		{
			if (gunIndex != 0)
			{
				return leftHandPivot.rotation;
			}
			return rightHandPivot.rotation;
		}
	}
	public class Tracker : MonoBehaviour
	{
		[SerializeField]
		private Transform _target;

		[SerializeField]
		private bool _trackPosition;

		[SerializeField]
		private bool _trackRotation;

		private void Update()
		{
			if (!(_target == null))
			{
				if (_trackPosition)
				{
					base.transform.position = _target.position;
				}
				if (_trackRotation)
				{
					base.transform.rotation = _target.rotation;
				}
			}
		}
	}
	[CreateAssetMenu(menuName = "Vr Shooting Range/Throw Configuration")]
	public class TrapThrowingConfiguration : ScriptableObject
	{
		[SerializeField]
		private float _minTrapForce;

		[SerializeField]
		private float _maxTrapFoce;

		[SerializeField]
		private float _minXAngle;

		[SerializeField]
		private float _maxXAngle;

		[SerializeField]
		private float _minYAngle;

		[SerializeField]
		private float _maxYAngle;

		[SerializeField]
		public bool throwForward;

		[SerializeField]
		public Vector3 throwDirection;

		public float RandomTrapForce => UnityEngine.Random.Range(_minTrapForce, _maxTrapFoce);

		public float RandomTrapXAngle => UnityEngine.Random.Range(_minXAngle, _maxXAngle);

		public float RandomTrapYAngle => UnityEngine.Random.Range(_minYAngle, _maxYAngle);
	}
	public class NonUiButton : MonoBehaviour
	{
		public void EndMatch()
		{
			if (!PhotonNetwork.IsMasterClient)
			{
				UnityEngine.Debug.LogWarning("You can not end the match because you are not the MasterClient.");
			}
			GameModel.Instance.ChangeGameState(new ScoringGameState());
		}

		public void LeaveMatch()
		{
			NetworkController.Instance.EndMultiplayerGame();
			GameController.Instance.InitMainMenu();
			PhotonNetwork.LocalPlayer.CustomProperties.Clear();
		}
	}
	public class NonVrController : MonoBehaviour
	{
		public Camera playerCamera;

		[Range(0.1f, 10f)]
		public float MouseSensitivity = 2f;

		[SerializeField]
		private Transform fireSpot;

		[SerializeField]
		private LayerMask hitLayer;

		[SerializeField]
		private PhotonView photonView;

		[SerializeField]
		private GameObject canvas;

		private AudioSource shotSound;

		private float rotationX;

		private float rotationY;

		[Header("Feedback")]
		[SerializeField]
		private GameObject muzzleMesh;

		[SerializeField]
		private ParticleSystem muzzleFx;

		[SerializeField]
		private float decreaseSpeed = 2f;

		[SerializeField]
		private LineRenderer _bulletTrace;

		public void Awake()
		{
			shotSound = GetComponent<AudioSource>();
			Cursor.lockState = CursorLockMode.Locked;
		}

		public void Update()
		{
			playerCamera.gameObject.SetActive(!PhotonNetwork.IsConnected || photonView.IsMine);
			if (!PhotonNetwork.IsConnected || photonView.IsMine)
			{
				MenuInteraction();
				LookAround();
				if (PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
				{
					FireWeapon();
				}
			}
		}

		public void OnGUI()
		{
			if (!PhotonNetwork.IsConnected && !IsConnecting())
			{
				GUILayout.BeginVertical();
				GUILayout.Label("Press 'RETURN' to begin.");
				GUILayout.EndVertical();
			}
			if (photonView.IsMine && PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
			{
				GUILayout.BeginVertical();
				GUILayout.Label("Press 'ESC' to leave the game.");
				GUILayout.Space(100f);
				Player[] playerList = PhotonNetwork.PlayerList;
				foreach (Player player in playerList)
				{
					GUILayout.Label(string.Concat(player.CustomProperties["name"], ": ", player.CustomProperties["roundScore"]));
				}
				GUILayout.EndVertical();
			}
		}

		private void LookAround()
		{
			rotationX += Input.GetAxis("Mouse X") * MouseSensitivity;
			rotationY += Input.GetAxis("Mouse Y") * MouseSensitivity;
			rotationX = ((rotationX < -360f) ? (rotationX + 360f) : ((rotationX > 360f) ? (rotationX - 360f) : rotationX));
			rotationY = ((rotationY < -360f) ? (rotationY + 360f) : ((rotationY > 360f) ? (rotationY - 360f) : rotationY));
			Quaternion quaternion = Quaternion.AngleAxis(rotationX, Vector3.up);
			Quaternion quaternion2 = Quaternion.AngleAxis(rotationY, -Vector3.right);
			base.transform.rotation = Quaternion.identity * quaternion * quaternion2;
		}

		private void MenuInteraction()
		{
			if (Input.GetKeyDown(KeyCode.Return) && !PhotonNetwork.IsConnected && !IsConnecting())
			{
				GameController.Instance.StartMultiplayerGame();
			}
			if (Input.GetKeyDown(KeyCode.Escape) && PhotonNetwork.IsConnected && PhotonNetwork.InRoom)
			{
				NetworkController.Instance.EndMultiplayerGame();
				GameController.Instance.InitMainMenu();
				PhotonNetwork.LocalPlayer.CustomProperties.Clear();
			}
		}

		private void FireWeapon()
		{
			if (!Input.GetMouseButtonDown(0))
			{
				return;
			}
			Vector3 vector = default(Vector3);
			if (Physics.Raycast(base.transform.position, Camera.main.transform.forward, out var hitInfo, 50f, hitLayer))
			{
				vector = hitInfo.point;
				Destructible component = hitInfo.collider.GetComponent<Destructible>();
				if (component != null)
				{
					component.MarkToDestroy();
				}
			}
			else
			{
				vector = fireSpot.position + Camera.main.transform.forward * 50f;
			}
			StopAllCoroutines();
			StartCoroutine(DisableBulletTrace(Camera.main.transform.forward, fireSpot.position));
			photonView.RPC("PlayShotFeedback", RpcTarget.All, fireSpot.position, vector);
		}

		[PunRPC]
		public void PlayShotFeedback(Vector3 position, Vector3 finalPosition)
		{
			Vector3 normalized = (finalPosition - position).normalized;
			_bulletTrace.SetPosition(0, position);
			_bulletTrace.SetPosition(1, finalPosition);
			PlayShotSound();
			StopAllCoroutines();
			StartCoroutine(DisableBulletTrace(normalized, position));
		}

		public void PlayShotSound()
		{
			shotSound.PlayOneShot(shotSound.clip);
		}

		public void OnPhotonInstantiate(PhotonMessageInfo info)
		{
			canvas.SetActive(photonView.IsMine);
		}

		private bool IsConnecting()
		{
			if (PhotonNetwork.NetworkClientState != ClientState.ConnectingToGameserver && PhotonNetwork.NetworkClientState != ClientState.ConnectingToMasterserver)
			{
				return PhotonNetwork.NetworkClientState == ClientState.ConnectingToNameServer;
			}
			return true;
		}

		private IEnumerator DisableBulletTrace(Vector3 direction, Vector3 initialPosition)
		{
			muzzleFx.Play();
			muzzleMesh.SetActive(value: true);
			yield return null;
			muzzleMesh.SetActive(value: false);
			Material i = _bulletTrace.material;
			Color color = i.GetColor("_TintColor");
			color.a = 1f;
			while (color.a >= 0.1f)
			{
				color.a -= Time.deltaTime * decreaseSpeed;
				i.SetColor("_TintColor", color);
				UnityEngine.Debug.Log(color.a);
				yield return null;
				initialPosition += direction.normalized * decreaseSpeed / 2f;
				_bulletTrace.SetPosition(0, initialPosition);
			}
			color.a = 0f;
			i.SetColor("_TintColor", color);
		}
	}
	public class SelfDistructByTimeout : MonoBehaviour
	{
		[SerializeField]
		private float _disctructionTime;

		private void Awake()
		{
			UnityEngine.Object.Destroy(base.gameObject, _disctructionTime);
		}
	}
	public class TrapFactory : MonoBehaviour
	{
		[SerializeField]
		private List<Destructible> _trapObjects;

		[SerializeField]
		private float _trapSpawnInterval;

		[SerializeField]
		private Transform _trapSpawnPointsRoot;

		private List<Transform> _trapSpawnPoints;

		public float TrapSpawnInterval => _trapSpawnInterval;

		public Transform RandomTrapSpawnPoint
		{
			get
			{
				int index = UnityEngine.Random.Range(0, _trapSpawnPoints.Count);
				return _trapSpawnPoints[index];
			}
		}

		private void Start()
		{
			_trapSpawnPoints = new List<Transform>();
			foreach (Transform item in _trapSpawnPointsRoot)
			{
				_trapSpawnPoints.Add(item);
			}
		}

		public void Build()
		{
			Transform randomTrapSpawnPoint = RandomTrapSpawnPoint;
			int index = new System.Random().Next(_trapObjects.Count);
			Destructible destructible = _trapObjects[index];
			TrapThrowingConfiguration throwConfiguration = destructible.throwConfiguration;
			GameObject gameObject = PhotonNetwork.Instantiate(rotation: Quaternion.Euler(throwConfiguration.RandomTrapXAngle, throwConfiguration.RandomTrapYAngle, 0f), prefabName: destructible.name, position: randomTrapSpawnPoint.position, group: 0);
			Vector3 vector = (throwConfiguration.throwForward ? gameObject.transform.forward : throwConfiguration.throwDirection);
			gameObject.GetComponent<Rigidbody>().AddForce(vector * throwConfiguration.RandomTrapForce, ForceMode.Impulse);
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid.ToString() + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.12";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.12";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float num = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + num);
			return num;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace InfinityEngine
{
	[ExecuteInEditMode]
	public class BlendingEffect : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float Amount = 0.5f;

		public float edgeSharpness = 1f;

		[Range(0f, 1f)]
		public float minBlending = 0.15f;

		[Range(0f, 1f)]
		public float maxBlending = 1f;

		public float seethroughness = 1f;

		public float distortion = 0.2f;

		public Texture2D mainTexture;

		public Texture2D normalTexture;

		public Shader shader;

		private Material material;

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (mainTexture == null || normalTexture == null || shader == null)
			{
				material = null;
				return;
			}
			if (material == null)
			{
				material = new Material(shader);
				material.SetTexture("_BlendTex", mainTexture);
				material.SetTexture("_BumpMap", normalTexture);
			}
			if (!Application.isPlaying)
			{
				material.SetTexture("_BlendTex", mainTexture);
				material.SetTexture("_BumpMap", normalTexture);
				edgeSharpness = Mathf.Max(1f, edgeSharpness);
			}
			material.SetFloat("_BlendAmount", Mathf.Clamp01(Mathf.Clamp01(Amount) * (maxBlending - minBlending) + minBlending));
			material.SetFloat("_EdgeSharpness", edgeSharpness);
			material.SetFloat("_SeeThroughness", seethroughness);
			material.SetFloat("_Distortion", distortion);
			Graphics.Blit(source, destination, material);
		}
	}
	public class PlaySoundOnClick : MonoBehaviour
	{
		public AudioClip clip;

		private void Start()
		{
			GetComponent<Button>().onClick.AddListener(delegate
			{
				SoundManager.PlayEffect(clip);
			});
		}

		private void Update()
		{
		}
	}
}
namespace InfinityEngine.Utils
{
	public static class AssetReferences
	{
		private static Texture2D logo;

		private static Texture2D helpIconEnable;

		private static Texture2D helpIconDisable;

		private static Texture2D searchIcon;

		private static Texture2D minusIcon;

		private static Texture2D plusIcon;

		private static Texture2D saveIcon;

		private static Texture2D loadIcon;

		private static Texture2D editIcon;

		private static Texture2D fbICon;

		private static Texture2D twitterIcon;

		private static Texture2D docIcon;

		private static Texture2D rateIcon;

		private static Texture2D moreIcon;

		private static Texture2D supportIcon;

		private static Texture2D achievementIconEnable;

		private static Texture2D leaderboardIconEnable;

		private static Texture2D achievementIconDisable;

		private static Texture2D leaderboardIconDisable;

		private static Texture2D google_translate_icon;

		private static GUISkin infinityEditorSkin;

		private static Font fontAwesomeFont;

		public static Texture2D Logo => logo ?? (logo = Resources.Load<Texture2D>("Textures/logo"));

		public static Texture2D HelpIconEnable => helpIconEnable ?? (helpIconEnable = Resources.Load<Texture2D>("Textures/help_icon_enable"));

		public static Texture2D HelpIconDisable => helpIconDisable ?? (helpIconDisable = Resources.Load<Texture2D>("Textures/help_icon_disable"));

		public static Texture2D SearchIcon => searchIcon ?? (searchIcon = Resources.Load<Texture2D>("Textures/search_icon"));

		public static Texture2D MinusIcon => minusIcon ?? (minusIcon = Resources.Load<Texture2D>("Textures/minus_icon"));

		public static Texture2D PlusIcon => plusIcon ?? (plusIcon = Resources.Load<Texture2D>("Textures/plus_icon"));

		public static Texture2D SaveIcon => saveIcon ?? (saveIcon = Resources.Load<Texture2D>("Textures/save_icon"));

		public static Texture2D LoadIcon => loadIcon ?? (loadIcon = Resources.Load<Texture2D>("Textures/load_icon"));

		public static Texture2D EditIcon => editIcon ?? (editIcon = Resources.Load<Texture2D>("Textures/edit_icon"));

		public static Texture2D FbICon => fbICon ?? (fbICon = Resources.Load<Texture2D>("Textures/facebook_icon"));

		public static Texture2D TwitterIcon => twitterIcon ?? (twitterIcon = Resources.Load<Texture2D>("Textures/twitter_icon"));

		public static Texture2D DocIcon => docIcon ?? (docIcon = Resources.Load<Texture2D>("Textures/doc_icon"));

		public static Texture2D RateIcon => rateIcon ?? (rateIcon = Resources.Load<Texture2D>("Textures/rate_icon"));

		public static Texture2D MoreIcon => moreIcon ?? (moreIcon = Resources.Load<Texture2D>("Textures/more_games_icon"));

		public static Texture2D SupportIcon => supportIcon ?? (supportIcon = Resources.Load<Texture2D>("Textures/support_icon"));

		public static Texture2D AchievementIconEnable => achievementIconEnable ?? (achievementIconEnable = Resources.Load<Texture2D>("Textures/achievement_enable"));

		public static Texture2D LeaderboardIconEnable => leaderboardIconEnable ?? (leaderboardIconEnable = Resources.Load<Texture2D>("Textures/leaderboard_enable"));

		public static Texture2D AchievementIconDisable => achievementIconDisable ?? (achievementIconDisable = Resources.Load<Texture2D>("Textures/achievement_disable"));

		public static Texture2D LeaderboardIconDisable => leaderboardIconDisable ?? (leaderboardIconDisable = Resources.Load<Texture2D>("Textures/leaderboard_disable"));

		public static Texture2D GoogleTranslateIcon => google_translate_icon ?? (google_translate_icon = Resources.Load<Texture2D>("Textures/google_translate_icon"));

		public static GUISkin InfinityEditorSkin => infinityEditorSkin ?? (infinityEditorSkin = Resources.Load<GUISkin>("Skins/infinity-editor-skin"));

		public static GUIStyle AccordionHeader => InfinityEditorSkin.GetStyle("AccordionHeader");

		public static GUIStyle FontAwesome => InfinityEditorSkin.GetStyle("FontAwesome");

		public static Font FontAwesomeFont => fontAwesomeFont ?? (fontAwesomeFont = Resources.Load<Font>("Fonts/FontAwesome"));

		public static GUIStyle GetFontAwesomeStyle(GUIStyle copy)
		{
			return new GUIStyle(copy)
			{
				font = FontAwesomeFont
			};
		}
	}
}
namespace InfinityEngine.Localization
{
	[RequireComponent(typeof(Button))]
	public class Flag : MonoBehaviour
	{
		[SerializeField]
		private Language language;

		public bool loadNextLevel;

		private void Start()
		{
			GetComponent<Button>().onClick.AddListener(delegate
			{
				ISILocalization.ChangeLanguage(language);
				if (loadNextLevel)
				{
					ISILocalization.LoadNextLevel();
				}
			});
		}
	}
	[AddComponentMenu("InfinityEngine/Localization/ISI Localization")]
	public class ISILocalization : InfinityEngine.DesignPatterns.Singleton<ISILocalization>
	{
		private static ISILocalization InstanceReference;

		private const string ApplicationLanguagePreferenceKey = "___APPLICATION_LANGUAGE___";

		public const string DefaultLanguagePreferenceKey = "___DEFAULT_LANGUAGE_PREF___";

		public const string PrefabName = "ISILocalizationPrefab";

		public const string PrefabPath = "Assets/InfinityEngine/Gen/Resources/ISILocalizationPrefab.prefab";

		public const string LanguagePaths = "InfinityEngine/Gen/Xml/ISI Localization/{0}/strings.xml";

		internal LocalizedLanguage m_currentLanguage;

		internal Language m_defaultLanguage;

		internal bool m_isInitialized;

		public static Action onLanguageChanged;

		[SerializeField]
		internal Scene m_nextScene;

		[SerializeField]
		internal int m_loadSceneDelay = 3;

		[SerializeField]
		internal List<LocalizedLanguage> m_languages;

		[SerializeField]
		internal List<string> m_stringKeys;

		[SerializeField]
		internal List<string> m_audiosKeys;

		[SerializeField]
		internal List<string> m_spriteKeys;

		[SerializeField]
		[MinMaxRange(1f, "GetStringMaxRange")]
		internal MinMax m_stringKeysRange;

		[MinMaxRange(1f, "GetAudioMaxRange")]
		[SerializeField]
		internal MinMax m_spriteKeysRange;

		[MinMaxRange(1f, "GetSpriteMaxRange")]
		[SerializeField]
		internal MinMax m_audioKeysRange;

		private Language DefaultLanguage
		{
			get
			{
				string @string = PlayerPrefs.GetString("___DEFAULT_LANGUAGE_PREF___", Language.English.ToString());
				m_defaultLanguage = (Language)Enum.Parse(typeof(Language), @string);
				return m_defaultLanguage;
			}
		}

		public List<LocalizedLanguage> LocalizedLanguages
		{
			get
			{
				return m_languages ?? (m_languages = new List<LocalizedLanguage>());
			}
			set
			{
				m_languages = value;
			}
		}

		public List<string> StringKeys
		{
			get
			{
				return m_stringKeys ?? (m_stringKeys = new List<string>());
			}
			set
			{
				m_stringKeys = value;
			}
		}

		public List<string> AudioKeys
		{
			get
			{
				return m_audiosKeys ?? (m_audiosKeys = new List<string>());
			}
			set
			{
				m_audiosKeys = value;
			}
		}

		public List<string> SpriteKeys
		{
			get
			{
				return m_spriteKeys ?? (m_spriteKeys = new List<string>());
			}
			set
			{
				m_spriteKeys = value;
			}
		}

		public int LanguageCount => LocalizedLanguages.Count;

		public static bool IsInitialized => InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_isInitialized;

		public static Language CurrentLanguage
		{
			get
			{
				if (LoadIfNotInScene())
				{
					return InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage.Language;
				}
				return Language.English;
			}
		}

		public Dictionary<string, List<string>> Keys => new Dictionary<string, List<string>>
		{
			{ "strings", StringKeys },
			{ "audios", AudioKeys },
			{ "sprites", SpriteKeys }
		};

		private int GetStringMaxRange()
		{
			return Math.Max(0, StringKeys.Count);
		}

		private int GetAudioMaxRange()
		{
			return Math.Max(0, AudioKeys.Count);
		}

		private int GetSpriteMaxRange()
		{
			return Math.Max(0, SpriteKeys.Count);
		}

		public void AddLanguage(LocalizedLanguage language)
		{
			LocalizedLanguages.Add(language);
		}

		public void ReplaceLocalizedLanguage(LocalizedLanguage language)
		{
			bool exists = false;
			LocalizedLanguages.ForEach(delegate(LocalizedLanguage model)
			{
				if (model.Language == language.Language)
				{
					model.LocalizedStrings = language.LocalizedStrings;
					exists = true;
				}
			});
			if (!exists)
			{
				LocalizedLanguages.Add(language);
			}
		}

		public bool HasLanguage(Language language)
		{
			return LocalizedLanguages.Any((LocalizedLanguage token) => token.Language == language);
		}

		public void Validate()
		{
			foreach (LocalizedLanguage language in m_languages)
			{
				language.LocalizedAudio = language.LocalizedAudio.Where((AudioClipKV elem) => m_audiosKeys.Contains(elem.Key)).ToList();
				language.LocalizedStrings = language.LocalizedStrings.Where((StringKV elem) => m_stringKeys.Contains(elem.Key)).ToList();
				language.LocalizedSprites = language.LocalizedSprites.Where((SpriteKV elem) => m_spriteKeys.Contains(elem.Key)).ToList();
			}
		}

		public static string GetValueOf(string name)
		{
			if (LoadIfNotInScene())
			{
				return InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage.GetString(name);
			}
			InfinityEngine.Utils.Debugger.LogError("ISI Localization is not initialized !", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.gameObject);
			return null;
		}

		public static string GetFormatedValueOf(string key, params object[] data)
		{
			LoadIfNotInScene();
			string valueOf = GetValueOf(key);
			if (string.IsNullOrEmpty(valueOf))
			{
				return null;
			}
			return string.Format(valueOf, data);
		}

		public static AudioClip GetAudio(string name)
		{
			if (LoadIfNotInScene())
			{
				return InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage.GetAudio(name);
			}
			InfinityEngine.Utils.Debugger.LogError("ISILocalization is not initialized !", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.gameObject);
			return null;
		}

		public static Sprite GetSprite(string name)
		{
			if (LoadIfNotInScene())
			{
				return InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage.GetSprite(name);
			}
			InfinityEngine.Utils.Debugger.LogError("ISILocalization is not initialized !", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.gameObject);
			return null;
		}

		public static bool ChangeLanguage(Language language)
		{
			if (InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.LocalizedLanguages == null && InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.LocalizedLanguages.Count == 0)
			{
				return false;
			}
			InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage = InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.LocalizedLanguages.Find((LocalizedLanguage model) => model.Language == language);
			if (InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage != null)
			{
				InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_isInitialized = true;
				PlayerPrefs.SetString("___APPLICATION_LANGUAGE___", language.ToString());
				LocalizedString.OnLanguageChanged();
				LocalizedSprite.OnLanguageChanged();
				if (onLanguageChanged != null)
				{
					onLanguageChanged();
				}
				return true;
			}
			return false;
		}

		public static void LoadNextLevel()
		{
			if (InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_nextScene == null)
			{
				InfinityEngine.Utils.Debugger.LogError("There is no specifed scene to load", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance);
			}
			else
			{
				Infinity.LoadLevelAfterDelay(InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_nextScene.SceneName, InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_loadSceneDelay);
			}
		}

		public static bool LoadIfNotInScene()
		{
			if (InstanceReference == null)
			{
				InstanceReference = UnityEngine.Object.FindObjectOfType<ISILocalization>();
			}
			if (InstanceReference == null)
			{
				GameObject gameObject = Resources.Load<GameObject>("ISILocalizationPrefab");
				if (gameObject == null)
				{
					InfinityEngine.Utils.Debugger.LogError("There is not ISILocalization prefab in resources folders ! ", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.gameObject);
					return false;
				}
				UnityEngine.Object.Instantiate(gameObject);
				InstanceReference = InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance;
				if (InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.LocalizedLanguages == null || InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.LocalizedLanguages.Count == 0)
				{
					InfinityEngine.Utils.Debugger.LogError("ISILocalization is not Setup ! ", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.gameObject);
					return false;
				}
				if (ChangeLanguage(InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.DefaultLanguage))
				{
					return true;
				}
				InfinityEngine.Utils.Debugger.LogError($"{InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_defaultLanguage} language is not register in ISILocalization !", InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.gameObject);
				return false;
			}
			if (InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.m_currentLanguage == null)
			{
				ChangeLanguage(InfinityEngine.DesignPatterns.Singleton<ISILocalization>.Instance.DefaultLanguage);
				return true;
			}
			return true;
		}
	}
	public struct ISIString
	{
		public string key { get; private set; }

		public ISIString(string key)
		{
			this.key = key;
		}

		public string Format(params object[] arg)
		{
			return ISILocalization.GetFormatedValueOf(key, arg);
		}

		public static implicit operator string(ISIString self)
		{
			return ISILocalization.GetValueOf(self.key);
		}
	}
	[Serializable]
	public enum Language
	{
		English,
		French,
		Spanish,
		Italian,
		German,
		Korean,
		Chinese,
		Japanese,
		Russian,
		Portuguese,
		Polish,
		Bengali,
		Bosnian,
		Catalan,
		Czech,
		Welsh,
		Danish,
		Finnish,
		Hindi,
		Croatian,
		Hungarian,
		Indonesian,
		Dutch,
		Slovak,
		Albanian,
		Serbian,
		Swedish,
		Swahili,
		Tamil,
		Thai,
		Turkish,
		Vietnamese
	}
	public static class LanguageExtensions
	{
		public static Locale ToLocale(this Language language)
		{
			return Locale.WithName(language.ToString());
		}

		public static string Code(this Language language)
		{
			return language.ToLocale().LanguageCode;
		}
	}
	[Serializable]
	public class Locale
	{
		public static Locale Bengali = new Locale("Bengali", "bn", "");

		public static Locale Bosnian = new Locale("Bosnian", "bs", "");

		public static Locale Catalan = new Locale("Catalan", "ca", "");

		public static Locale Czech = new Locale("Czech", "cs", "");

		public static Locale Welsh = new Locale("Welsh", "cy", "");

		public static Locale Danish = new Locale("Danish", "da", "");

		public static Locale German = new Locale("German", "de", "");

		public static Locale English = new Locale("English", "en", "");

		public static Locale Spanish = new Locale("Spanish", "es", "");

		public static Locale Finnish = new Locale("Finnish", "fi", "");

		public static Locale French = new Locale("French", "fr", "");

		public static Locale Hindi = new Locale("Hindi", "hi", "");

		public static Locale Croatian = new Locale("Croatian", "hr", "");

		public static Locale Hungarian = new Locale("Hungarian", "hu", "");

		public static Locale Indonesian = new Locale("Indonesian", "in", "");

		public static Locale Italian = new Locale("Italian", "it", "");

		public static Locale Japanese = new Locale("Japanese", "ja", "");

		public static Locale Korean = new Locale("Korean", "ko", "");

		public static Locale Dutch = new Locale("Dutch", "nl", "");

		public static Locale Polish = new Locale("Polish", "pl", "");

		public static Locale Portuguese = new Locale("Portuguese", "pt", "");

		public static Locale Russian = new Locale("Russian", "ru", "");

		public static Locale Slovak = new Locale("Slovak", "sk", "");

		public static Locale Albanian = new Locale("Albanian", "sq", "");

		public static Locale Serbian = new Locale("Serbian", "sr", "");

		public static Locale Swedish = new Locale("Swedish", "sv", "");

		public static Locale Swahili = new Locale("Swahili", "sw", "");

		public static Locale Tamil = new Locale("Tamil", "ta", "");

		public static Locale Thai = new Locale("Thai", "th", "");

		public static Locale Turkish = new Locale("Turkish", "tr", "");

		public static Locale Vietnamese = new Locale("Vietnamese", "vi", "");

		public static Locale Chinese = new Locale("Chinese", "zh", "");

		public string Name { get; set; }

		public string LanguageCode { get; set; }

		public string Country { get; set; }

		public static Locale[] AllLocales
		{
			get
			{
				Type type = typeof(Locale);
				return (from field in type.GetFields()
					where field.FieldType == type
					select (Locale)field.GetValue(null)).ToArray();
			}
		}

		public string Informations => Name + " : " + LanguageCode + " : " + Country;

		public Locale(string name, string language, string country)
		{
			Name = name;
			LanguageCode = language;
			Country = country;
		}

		public static Locale WithName(string name)
		{
			return AllLocales.FirstOrDefault((Locale elem) => elem.Name == name);
		}

		public override string ToString()
		{
			return Name;
		}
	}
	[AddComponentMenu("InfinityEngine/Localization/Localized Audio")]
	public class LocalizedAudio : MonoBehaviour
	{
		[Popup("Hello", PopupValueTypes.String, true)]
		[SerializeField]
		private string key;

		private AudioClip clip;

		public void Play()
		{
			if (key == null)
			{
				InfinityEngine.Utils.Debugger.LogError("This audio key is null", base.gameObject);
				return;
			}
			clip = ISILocalization.GetAudio(key);
			if (clip == null)
			{
				InfinityEngine.Utils.Debugger.LogError("There is not localized audio with the  key" + key, base.gameObject);
			}
			else
			{
				AudioSource.PlayClipAtPoint(clip, Vector3.zero);
			}
		}
	}
	[Serializable]
	public class LocalizedLanguage
	{
		private int translationStep;

		public bool isExpanded;

		public bool isBeingAutoTranslated;

		public float translationProgress;

		[SerializeField]
		private Texture2D m_flag;

		[SerializeField]
		private Language m_language;

		[SerializeField]
		private List<StringKV> m_localizedStrings;

		[SerializeField]
		private List<AudioClipKV> m_localizedAudio;

		[SerializeField]
		private List<SpriteKV> m_localizedSprites;

		[SerializeField]
		private string m_languageName;

		[SerializeField]
		private string m_languageCode;

		public Language Language
		{
			get
			{
				return m_language;
			}
			set
			{
				m_flag = Resources.Load<Texture2D>($"Flags/{value}_FLAG".ToLower());
				m_language = value;
			}
		}

		public string LanguageName
		{
			get
			{
				if (string.IsNullOrEmpty(m_languageName))
				{
					m_languageName = Language.ToString();
				}
				return m_languageName;
			}
		}

		public string LanguageCode
		{
			get
			{
				if (m_languageCode == null)
				{
					m_languageCode = Language.Code();
				}
				return m_languageCode;
			}
		}

		public Texture2D Flag => m_flag;

		public List<StringKV> LocalizedStrings
		{
			get
			{
				return m_localizedStrings;
			}
			set
			{
				m_localizedStrings = value;
			}
		}

		public List<AudioClipKV> LocalizedAudio
		{
			get
			{
				return m_localizedAudio;
			}
			set
			{
				m_localizedAudio = value;
			}
		}

		public List<SpriteKV> LocalizedSprites
		{
			get
			{
				return m_localizedSprites;
			}
			set
			{
				m_localizedSprites = value;
			}
		}

		public LocalizedLanguage()
			: this(new List<StringKV>())
		{
		}

		public LocalizedLanguage(List<StringKV> strings)
		{
			m_localizedStrings = strings;
			m_localizedAudio = new List<AudioClipKV>();
			m_localizedSprites = new List<SpriteKV>();
		}

		public void SetString(string key, string value)
		{
			StringKV stringKV = m_localizedStrings.Find((StringKV e) => e.Key == key);
			if (stringKV == null)
			{
				m_localizedStrings.Add(new StringKV(key, value));
			}
			else
			{
				stringKV.Value = value;
			}
		}

		public string GetString(string key)
		{
			return LocalizedStrings.Find((StringKV e) => e.Key == key)?.Value;
		}

		public void SetAudio(string key, AudioClip value)
		{
			AudioClipKV audioClipKV = m_localizedAudio.Find((AudioClipKV e) => e.Key == key);
			if (audioClipKV == null)
			{
				m_localizedAudio.Add(new AudioClipKV(key, value));
			}
			else
			{
				audioClipKV.Value = value;
			}
		}

		public AudioClip GetAudio(string key)
		{
			return m_localizedAudio.Find((AudioClipKV e) => e.Key == key)?.Value;
		}

		public void SetSprite(string key, Sprite value)
		{
			SpriteKV spriteKV = m_localizedSprites.Find((SpriteKV e) => e.Key == key);
			if (spriteKV == null)
			{
				m_localizedSprites.Add(new SpriteKV(key, value));
			}
			else
			{
				spriteKV.Value = value;
			}
		}

		public Sprite GetSprite(string key)
		{
			return m_localizedSprites.Find((SpriteKV e) => e.Key == key)?.Value;
		}

		public override string ToString()
		{
			return m_language.ToString();
		}

		public void UpdateTranslationProgress(int totalSteps)
		{
			translationStep++;
			translationProgress = (float)translationStep / (float)totalSteps;
			if (translationStep >= totalSteps)
			{
				isBeingAutoTranslated = false;
				translationProgress = 0f;
				translationProgress = 0f;
			}
		}
	}
	[AddComponentMenu("InfinityEngine/Localization/Localized Sprite")]
	public class LocalizedSprite : MonoBehaviour
	{
		public enum SpriteComponentType
		{
			Image,
			SpriteRenderer
		}

		[SerializeField]
		private SpriteComponentType type;

		[Popup("LocalizedSprite", PopupValueTypes.String, true)]
		[SerializeField]
		private string key;

		private Image image;

		private SpriteRenderer spriteRenderer;

		private static List<LocalizedSprite> LocalizedSprites;

		private void Start()
		{
			if (type == SpriteComponentType.Image)
			{
				image = GetComponent<Image>();
				if (image == null)
				{
					InfinityEngine.Utils.Debugger.LogError("There is no Image component attached to this GameObject", base.gameObject);
					return;
				}
			}
			else
			{
				spriteRenderer = GetComponent<SpriteRenderer>();
				if (spriteRenderer == null)
				{
					InfinityEngine.Utils.Debugger.LogError("There is no SpriteRenderer component attached to this GameObject", base.gameObject);
					return;
				}
			}
			if (ISILocalization.LoadIfNotInScene())
			{
				Infinity.When(() => ISILocalization.IsInitialized, _OnLanguageChanged);
			}
			if (LocalizedSprites == null)
			{
				LocalizedSprites = new List<LocalizedSprite>();
			}
			if (!LocalizedSprites.Contains(this))
			{
				LocalizedSprites.Add(this);
			}
		}

		private void _OnLanguageChanged()
		{
			if (type == SpriteComponentType.Image)
			{
				image.sprite = ISILocalization.GetSprite(key);
			}
			else
			{
				spriteRenderer.sprite = ISILocalization.GetSprite(key);
			}
		}

		public static void OnLanguageChanged()
		{
			if (LocalizedSprites != null)
			{
				LocalizedSprites.ForEach(delegate(LocalizedSprite arg)
				{
					arg._OnLanguageChanged();
				});
			}
		}
	}
	[AddComponentMenu("InfinityEngine/Localization/Localized String")]
	public class LocalizedString : MonoBehaviour
	{
		private enum TextComponentType
		{
			Text,
			TextMesh,
			TextMeshPro,
			TextMeshProUGUI
		}

		[SerializeField]
		private TextComponentType type;

		[Popup("HelloWorld, NewMatch, JoinMatch, Quit, EditGameGround, Start, Return, Save, ContinueMatch, EndMatch, PressTrigger, LeaderBoard, UserProfile, Robot", PopupValueTypes.String, true)]
		[SerializeField]
		private string key;

		private Text label;

		private TextMesh textMesh;

		private TMP_Text textMeshPro;

		private TextMeshProUGUI textMeshProUGUI;

		private static List<LocalizedString> LocalizedStrings;

		private void Start()
		{
			FindComponent();
			if (ISILocalization.LoadIfNotInScene())
			{
				Infinity.When(() => ISILocalization.IsInitialized, _OnLanguageChanged);
			}
			if (LocalizedStrings == null)
			{
				LocalizedStrings = new List<LocalizedString>();
			}
			if (!LocalizedStrings.Contains(this))
			{
				LocalizedStrings.Add(this);
			}
		}

		private void FindComponent()
		{
			object obj = null;
			switch (type)
			{
			case TextComponentType.Text:
				obj = (label = GetComponent<Text>());
				break;
			case TextComponentType.TextMesh:
				obj = (textMesh = GetComponent<TextMesh>());
				break;
			case TextComponentType.TextMeshPro:
				obj = (textMeshPro = GetComponent<TMP_Text>());
				break;
			case TextComponentType.TextMeshProUGUI:
				obj = (textMeshProUGUI = GetComponent<TextMeshProUGUI>());
				break;
			}
			if (obj == null)
			{
				InfinityEngine.Utils.Debugger.LogError($"There is no {type} component attached to this GameObject", this);
			}
		}

		private void _OnLanguageChanged()
		{
			if (label != null)
			{
				label.text = ISILocalization.GetValueOf(key);
			}
			if (textMesh != null)
			{
				textMesh.text = ISILocalization.GetValueOf(key);
			}
			if (textMeshPro != null)
			{
				textMeshPro.text = ISILocalization.GetValueOf(key.Trim());
			}
			if (textMeshProUGUI != null)
			{
				textMeshProUGUI.text = ISILocalization.GetValueOf(key);
			}
		}

		public static void OnLanguageChanged()
		{
			if (LocalizedStrings != null)
			{
				LocalizedStrings.ForEach(delegate(LocalizedString arg)
				{
					arg._OnLanguageChanged();
				});
			}
		}
	}
	public static class R3
	{
		public static class strings
		{
			public const string Names = "HelloWorld, NewMatch, JoinMatch, Quit, EditGameGround, Start, Return, Save, ContinueMatch, EndMatch, PressTrigger, LeaderBoard, UserProfile, Robot";

			public static ISIString HelloWorld = new ISIString("HelloWorld");

			public static ISIString NewMatch = new ISIString("NewMatch");

			public static ISIString JoinMatch = new ISIString("JoinMatch");

			public static ISIString Quit = new ISIString("Quit");

			public static ISIString EditGameGround = new ISIString("EditGameGround");

			public static ISIString Start = new ISIString("Start");

			public static ISIString Return = new ISIString("Return");

			public static ISIString Save = new ISIString("Save");

			public static ISIString ContinueMatch = new ISIString("ContinueMatch");

			public static ISIString EndMatch = new ISIString("EndMatch");

			public static ISIString PressTrigger = new ISIString("PressTrigger");

			public static ISIString LeaderBoard = new ISIString("LeaderBoard");

			public static ISIString UserProfile = new ISIString("UserProfile");

			public static ISIString Robot = new ISIString("Robot");
		}

		public static class audios
		{
			public const string Names = "Hello";

			public static AudioClip Hello => ISILocalization.GetAudio("Hello");
		}

		public static class sprites
		{
			public const string Names = "LocalizedSprite";

			public static Sprite LocalizedSprite => ISILocalization.GetSprite("LocalizedSprite");
		}
	}
}
namespace DigitalOpus.MB.Core
{
	public static class MB_TGAWriter
	{
		public static void Write(Color[] pixels, int width, int height, string path)
		{
			if (File.Exists(path))
			{
				File.Delete(path);
			}
			FileStream output = File.Create(path);
			Write(pixels, width, height, output);
		}

		public static void Write(Color[] pixels, int width, int height, Stream output)
		{
			byte[] array = new byte[pixels.Length * 4];
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < height; i++)
			{
				for (int j = 0; j < width; j++)
				{
					Color color = pixels[num];
					array[num2] = (byte)(color.b * 255f);
					array[num2 + 1] = (byte)(color.g * 255f);
					array[num2 + 2] = (byte)(color.r * 255f);
					array[num2 + 3] = (byte)(color.a * 255f);
					num++;
					num2 += 4;
				}
			}
			byte[] buffer = new byte[18]
			{
				0,
				0,
				2,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				0,
				(byte)((uint)width & 0xFFu),
				(byte)((width & 0xFF00) >> 8),
				(byte)((uint)height & 0xFFu),
				(byte)((height & 0xFF00) >> 8),
				32,
				0
			};
			using BinaryWriter binaryWriter = new BinaryWriter(output);
			binaryWriter.Write(buffer);
			binaryWriter.Write(array);
		}
	}
	public class MB_Utility
	{
		public struct MeshAnalysisResult
		{
			public Rect uvRect;

			public bool hasOutOfBoundsUVs;

			public bool hasOverlappingSubmeshVerts;

			public bool hasOverlappingSubmeshTris;

			public bool hasUVs;

			public float submeshArea;
		}

		private class MB_Triangle
		{
			private int submeshIdx;

			private int[] vs = new int[3];

			public bool isSame(object obj)
			{
				MB_Triangle mB_Triangle = (MB_Triangle)obj;
				if (vs[0] == mB_Triangle.vs[0] && vs[1] == mB_Triangle.vs[1] && vs[2] == mB_Triangle.vs[2] && submeshIdx != mB_Triangle.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public bool sharesVerts(MB_Triangle obj)
			{
				if ((vs[0] == obj.vs[0] || vs[0] == obj.vs[1] || vs[0] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[1] == obj.vs[0] || vs[1] == obj.vs[1] || vs[1] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				if ((vs[2] == obj.vs[0] || vs[2] == obj.vs[1] || vs[2] == obj.vs[2]) && submeshIdx != obj.submeshIdx)
				{
					return true;
				}
				return false;
			}

			public void Initialize(int[] ts, int idx, int sIdx)
			{
				vs[0] = ts[idx];
				vs[1] = ts[idx + 1];
				vs[2] = ts[idx + 2];
				submeshIdx = sIdx;
				Array.Sort(vs);
			}
		}

		public static bool DO_INTEGRITY_CHECKS;

		public static Texture2D createTextureCopy(Texture2D source)
		{
			Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipChain: true);
			texture2D.SetPixels(source.GetPixels());
			return texture2D;
		}

		public static bool ArrayBIsSubsetOfA(object[] a, object[] b)
		{
			for (int i = 0; i < b.Length; i++)
			{
				bool flag = false;
				for (int j = 0; j < a.Length; j++)
				{
					if (a[j] == b[i])
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		public static Material[] GetGOMaterials(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			Material[] array = null;
			Mesh mesh = null;
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				array = component.sharedMaterials;
				MeshFilter component2 = go.GetComponent<MeshFilter>();
				if (component2 == null)
				{
					throw new Exception(string.Concat("Object ", go, " has a MeshRenderer but no MeshFilter."));
				}
				mesh = component2.sharedMesh;
			}
			SkinnedMeshRenderer component3 = go.GetComponent<SkinnedMeshRenderer>();
			if (component3 != null)
			{
				array = component3.sharedMaterials;
				mesh = component3.sharedMesh;
			}
			if (array == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " does not have a MeshRenderer or a SkinnedMeshRenderer component");
				return new Material[0];
			}
			if (mesh == null)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has a MeshRenderer or SkinnedMeshRenderer but no mesh.");
				return new Material[0];
			}
			if (mesh.subMeshCount < array.Length)
			{
				UnityEngine.Debug.LogWarning(string.Concat("Object ", go, " has only ", mesh.subMeshCount, " submeshes and has ", array.Length, " materials. Extra materials do nothing."));
				Material[] array2 = new Material[mesh.subMeshCount];
				Array.Copy(array, array2, array2.Length);
				array = array2;
			}
			return array;
		}

		public static Mesh GetMesh(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				return component.sharedMesh;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2.sharedMesh;
			}
			return null;
		}

		public static void SetMesh(GameObject go, Mesh m)
		{
			if (go == null)
			{
				return;
			}
			MeshFilter component = go.GetComponent<MeshFilter>();
			if (component != null)
			{
				component.sharedMesh = m;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.sharedMesh = m;
			}
		}

		public static Renderer GetRenderer(GameObject go)
		{
			if (go == null)
			{
				return null;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				return component;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				return component2;
			}
			return null;
		}

		public static void DisableRendererInSource(GameObject go)
		{
			if (go == null)
			{
				return;
			}
			MeshRenderer component = go.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
				return;
			}
			SkinnedMeshRenderer component2 = go.GetComponent<SkinnedMeshRenderer>();
			if (component2 != null)
			{
				component2.enabled = false;
			}
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref Rect uvBounds)
		{
			MeshAnalysisResult putResultHere = default(MeshAnalysisResult);
			bool result = hasOutOfBoundsUVs(m, ref putResultHere);
			uvBounds = putResultHere.uvRect;
			return result;
		}

		public static bool hasOutOfBoundsUVs(Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1, int uvChannel = 0)
		{
			if (m == null)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				return putResultHere.hasOutOfBoundsUVs;
			}
			return hasOutOfBoundsUVs(uvChannel switch
			{
				0 => m.uv, 
				1 => m.uv2, 
				2 => m.uv3, 
				_ => m.uv4, 
			}, m, ref putResultHere, submeshIndex);
		}

		public static bool hasOutOfBoundsUVs(Vector2[] uvs, Mesh m, ref MeshAnalysisResult putResultHere, int submeshIndex = -1)
		{
			putResultHere.hasUVs = true;
			if (uvs.Length == 0)
			{
				putResultHere.hasUVs = false;
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			if (submeshIndex >= m.subMeshCount)
			{
				putResultHere.hasOutOfBoundsUVs = false;
				putResultHere.uvRect = default(Rect);
				return putResultHere.hasOutOfBoundsUVs;
			}
			float num;
			float x;
			float num2;
			float y;
			if (submeshIndex >= 0)
			{
				int[] triangles = m.GetTriangles(submeshIndex);
				if (triangles.Length == 0)
				{
					putResultHere.hasOutOfBoundsUVs = false;
					putResultHere.uvRect = default(Rect);
					return putResultHere.hasOutOfBoundsUVs;
				}
				num = (x = uvs[triangles[0]].x);
				num2 = (y = uvs[triangles[0]].y);
				foreach (int num3 in triangles)
				{
					if (uvs[num3].x < num)
					{
						num = uvs[num3].x;
					}
					if (uvs[num3].x > x)
					{
						x = uvs[num3].x;
					}
					if (uvs[num3].y < num2)
					{
						num2 = uvs[num3].y;
					}
					if (uvs[num3].y > y)
					{
						y = uvs[num3].y;
					}
				}
			}
			else
			{
				num = (x = uvs[0].x);
				num2 = (y = uvs[0].y);
				for (int j = 0; j < uvs.Length; j++)
				{
					if (uvs[j].x < num)
					{
						num = uvs[j].x;
					}
					if (uvs[j].x > x)
					{
						x = uvs[j].x;
					}
					if (uvs[j].y < num2)
					{
						num2 = uvs[j].y;
					}
					if (uvs[j].y > y)
					{
						y = uvs[j].y;
					}
				}
			}
			Rect uvRect = default(Rect);
			uvRect.x = num;
			uvRect.y = num2;
			uvRect.width = x - num;
			uvRect.height = y - num2;
			if (x > 1f || num < 0f || y > 1f || num2 < 0f)
			{
				putResultHere.hasOutOfBoundsUVs = true;
			}
			else
			{
				putResultHere.hasOutOfBoundsUVs = false;
			}
			putResultHere.uvRect = uvRect;
			return putResultHere.hasOutOfBoundsUVs;
		}

		public static void setSolidColor(Texture2D t, Color c)
		{
			Color[] pixels = t.GetPixels();
			for (int i = 0; i < pixels.Length; i++)
			{
				pixels[i] = c;
			}
			t.SetPixels(pixels);
			t.Apply();
		}

		public static Texture2D resampleTexture(Texture2D source, int newWidth, int newHeight)
		{
			TextureFormat format = source.format;
			if (format == TextureFormat.ARGB32 || format == TextureFormat.RGBA32 || format == TextureFormat.BGRA32 || format == TextureFormat.RGB24 || format == TextureFormat.Alpha8 || format == TextureFormat.DXT1)
			{
				Texture2D texture2D = new Texture2D(newWidth, newHeight, TextureFormat.ARGB32, mipChain: true);
				float num = newWidth;
				float num2 = newHeight;
				for (int i = 0; i < newWidth; i++)
				{
					for (int j = 0; j < newHeight; j++)
					{
						float x = (float)i / num;
						float y = (float)j / num2;
						texture2D.SetPixel(i, j, source.GetPixelBilinear(x, y));
					}
				}
				texture2D.Apply();
				return texture2D;
			}
			UnityEngine.Debug.LogError("Can only resize textures in formats ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT");
			return null;
		}

		public static bool AreAllSharedMaterialsDistinct(Material[] sharedMaterials)
		{
			for (int i = 0; i < sharedMaterials.Length; i++)
			{
				for (int j = i + 1; j < sharedMaterials.Length; j++)
				{
					if (sharedMaterials[i] == sharedMaterials[j])
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int doSubmeshesShareVertsOrTris(Mesh m, ref MeshAnalysisResult mar)
		{
			MB_Triangle mB_Triangle = new MB_Triangle();
			MB_Triangle mB_Triangle2 = new MB_Triangle();
			int[][] array = new int[m.subMeshCount][];
			for (int i = 0; i < m.subMeshCount; i++)
			{
				array[i] = m.GetTriangles(i);
			}
			bool flag = false;
			bool flag2 = false;
			for (int j = 0; j < m.subMeshCount; j++)
			{
				int[] array2 = array[j];
				for (int k = j + 1; k < m.subMeshCount; k++)
				{
					int[] array3 = array[k];
					for (int l = 0; l < array2.Length; l += 3)
					{
						mB_Triangle.Initialize(array2, l, j);
						for (int n = 0; n < array3.Length; n += 3)
						{
							mB_Triangle2.Initialize(array3, n, k);
							if (mB_Triangle.isSame(mB_Triangle2))
							{
								flag2 = true;
								break;
							}
							if (mB_Triangle.sharesVerts(mB_Triangle2))
							{
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (flag2)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = true;
				return 2;
			}
			if (flag)
			{
				mar.hasOverlappingSubmeshVerts = true;
				mar.hasOverlappingSubmeshTris = false;
				return 1;
			}
			mar.hasOverlappingSubmeshTris = false;
			mar.hasOverlappingSubmeshVerts = false;
			return 0;
		}

		public static bool GetBounds(GameObject go, out Bounds b)
		{
			if (go == null)
			{
				UnityEngine.Debug.LogError("go paramater was null");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			Renderer renderer = GetRenderer(go);
			if (renderer == null)
			{
				UnityEngine.Debug.LogError("GetBounds must be called on an object with a Renderer");
				b = new Bounds(Vector3.zero, Vector3.zero);
				return false;
			}
			if (renderer is MeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			if (renderer is SkinnedMeshRenderer)
			{
				b = renderer.bounds;
				return true;
			}
			UnityEngine.Debug.LogError("GetBounds must be called on an object with a MeshRender or a SkinnedMeshRenderer.");
			b = new Bounds(Vector3.zero, Vector3.zero);
			return false;
		}

		public static void Destroy(UnityEngine.Object o)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(o);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(o, allowDestroyingAssets: false);
			}
		}
	}
	public delegate void ProgressUpdateDelegate(string msg, float progress);
	public delegate bool ProgressUpdateCancelableDelegate(string msg, float progress);
	public enum MB_ObjsToCombineTypes
	{
		prefabOnly,
		sceneObjOnly,
		dontCare
	}
	public enum MB_OutputOptions
	{
		bakeIntoPrefab,
		bakeMeshsInPlace,
		bakeTextureAtlasesOnly,
		bakeIntoSceneObject
	}
	public enum MB_RenderType
	{
		meshRenderer,
		skinnedMeshRenderer
	}
	public enum MB2_OutputOptions
	{
		bakeIntoSceneObject,
		bakeMeshAssetsInPlace,
		bakeIntoPrefab
	}
	public enum MB2_LightmapOptions
	{
		preserve_current_lightmapping,
		ignore_UV2,
		copy_UV2_unchanged,
		generate_new_UV2_layout,
		copy_UV2_unchanged_to_separate_rects
	}
	public enum MB2_PackingAlgorithmEnum
	{
		UnitysPackTextures,
		MeshBakerTexturePacker,
		MeshBakerTexturePacker_Fast,
		MeshBakerTexturePacker_Horizontal,
		MeshBakerTexturePacker_Vertical
	}
	public enum MB_TextureTilingTreatment
	{
		none,
		considerUVs,
		edgeToEdgeX,
		edgeToEdgeY,
		edgeToEdgeXY,
		unknown
	}
	public enum MB2_ValidationLevel
	{
		none,
		quick,
		robust
	}
	public interface MB2_EditorMethodsInterface
	{
		void Clear();

		void RestoreReadFlagsAndFormats(ProgressUpdateDelegate progressInfo);

		void SetReadWriteFlag(Texture2D tx, bool isReadable, bool addToList);

		void AddTextureFormat(Texture2D tx, bool isNormalMap);

		void SaveAtlasToAssetDatabase(Texture2D atlas, ShaderTextureProperty texPropertyName, int atlasNum, Material resMat);

		bool IsNormalMap(Texture2D tx);

		string GetPlatformString();

		void SetTextureSize(Texture2D tx, int size);

		bool IsCompressed(Texture2D tx);

		void CheckBuildSettings(long estimatedAtlasSize);

		bool CheckPrefabTypes(MB_ObjsToCombineTypes prefabType, List<GameObject> gos);

		bool ValidateSkinnedMeshes(List<GameObject> mom);

		void CommitChangesToAssets();

		void OnPreTextureBake();

		void OnPostTextureBake();

		void Destroy(UnityEngine.Object o);
	}
	public enum MB2_LogLevel
	{
		none,
		error,
		warn,
		info,
		debug,
		trace
	}
	public class MB2_Log
	{
		public static void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			if (l <= currentThreshold)
			{
				if (l == MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError(msg);
				}
				if (l == MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning($"frm={Time.frameCount} WARN {msg}");
				}
				if (l == MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} INFO {msg}");
				}
				if (l == MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} DEBUG {msg}");
				}
				if (l == MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"frm={Time.frameCount} TRACE {msg}");
				}
			}
		}

		public static string Error(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} ERROR {arg}";
			UnityEngine.Debug.LogError(text);
			return text;
		}

		public static string Warn(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} WARN {arg}";
			UnityEngine.Debug.LogWarning(text);
			return text;
		}

		public static string Info(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} INFO {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string LogDebug(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} DEBUG {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}

		public static string Trace(string msg, params object[] args)
		{
			string arg = string.Format(msg, args);
			string text = $"f={Time.frameCount} TRACE {arg}";
			UnityEngine.Debug.Log(text);
			return text;
		}
	}
	public class ObjectLog
	{
		private int pos;

		private string[] logMessages;

		private void _CacheLogMessage(string msg)
		{
			if (logMessages.Length != 0)
			{
				logMessages[pos] = msg;
				pos++;
				if (pos >= logMessages.Length)
				{
					pos = 0;
				}
			}
		}

		public ObjectLog(short bufferSize)
		{
			logMessages = new string[bufferSize];
		}

		public void Log(MB2_LogLevel l, string msg, MB2_LogLevel currentThreshold)
		{
			MB2_Log.Log(l, msg, currentThreshold);
			_CacheLogMessage(msg);
		}

		public void Error(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Error(msg, args));
		}

		public void Warn(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Warn(msg, args));
		}

		public void Info(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Info(msg, args));
		}

		public void LogDebug(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.LogDebug(msg, args));
		}

		public void Trace(string msg, params object[] args)
		{
			_CacheLogMessage(MB2_Log.Trace(msg, args));
		}

		public string Dump()
		{
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			if (logMessages[logMessages.Length - 1] != null)
			{
				num = pos;
			}
			for (int i = 0; i < logMessages.Length; i++)
			{
				int num2 = (num + i) % logMessages.Length;
				if (logMessages[num2] == null)
				{
					break;
				}
				stringBuilder.AppendLine(logMessages[num2]);
			}
			return stringBuilder.ToString();
		}
	}
	public interface MBVersionInterface
	{
		string version();

		int GetMajorVersion();

		int GetMinorVersion();

		bool GetActive(GameObject go);

		void SetActive(GameObject go, bool isActive);

		void SetActiveRecursively(GameObject go, bool isActive);

		UnityEngine.Object[] FindSceneObjectsOfType(Type t);

		bool IsRunningAndMeshNotReadWriteable(Mesh m);

		Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL);

		void MeshClear(Mesh m, bool t);

		void MeshAssignUV3(Mesh m, Vector2[] uv3s);

		void MeshAssignUV4(Mesh m, Vector2[] uv4s);

		Vector4 GetLightmapTilingOffset(Renderer r);

		Transform[] GetBones(Renderer r);

		void OptimizeMesh(Mesh m);

		int GetBlendShapeFrameCount(Mesh m, int shapeIndex);

		float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex);

		void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		void ClearBlendShapes(Mesh m);

		void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts);

		int MaxMeshVertexCount();

		void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles);
	}
	public class MBVersion
	{
		private static MBVersionInterface _MBVersion;

		private static MBVersionInterface _CreateMBVersionConcrete()
		{
			return (MBVersionInterface)Activator.CreateInstance(typeof(MBVersionConcrete));
		}

		public static string version()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.version();
		}

		public static int GetMajorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMajorVersion();
		}

		public static int GetMinorVersion()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMinorVersion();
		}

		public static bool GetActive(GameObject go)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetActive(go);
		}

		public static void SetActive(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActive(go, isActive);
		}

		public static void SetActiveRecursively(GameObject go, bool isActive)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetActiveRecursively(go, isActive);
		}

		public static UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.FindSceneObjectsOfType(t);
		}

		public static bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.IsRunningAndMeshNotReadWriteable(m);
		}

		public static Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetMeshUV3orUV4(m, get3, LOG_LEVEL);
		}

		public static void MeshClear(Mesh m, bool t)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshClear(m, t);
		}

		public static void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV3(m, uv3s);
		}

		public static void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.MeshAssignUV4(m, uv4s);
		}

		public static Vector4 GetLightmapTilingOffset(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetLightmapTilingOffset(r);
		}

		public static Transform[] GetBones(Renderer r)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBones(r);
		}

		public static void OptimizeMesh(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.OptimizeMesh(m);
		}

		public static int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameCount(m, shapeIndex);
		}

		public static float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.GetBlendShapeFrameWeight(m, shapeIndex, frameIndex);
		}

		public static void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.GetBlendShapeFrameVertices(m, shapeIndex, frameIndex, vs, ns, ts);
		}

		public static void ClearBlendShapes(Mesh m)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.ClearBlendShapes(m);
		}

		public static void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.AddBlendShapeFrame(m, nm, wt, vs, ns, ts);
		}

		public static int MaxMeshVertexCount()
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			return _MBVersion.MaxMeshVertexCount();
		}

		public static void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles)
		{
			if (_MBVersion == null)
			{
				_MBVersion = _CreateMBVersionConcrete();
			}
			_MBVersion.SetMeshIndexFormatAndClearMesh(m, numVerts, vertices, justClearTriangles);
		}
	}
	[Serializable]
	public class MB3_AgglomerativeClustering
	{
		[Serializable]
		public class ClusterNode
		{
			public item_s leaf;

			public ClusterNode cha;

			public ClusterNode chb;

			public int height;

			public float distToMergedCentroid;

			public Vector3 centroid;

			public int[] leafs;

			public int idx;

			public bool isUnclustered = true;

			public ClusterNode(item_s ii, int index)
			{
				leaf = ii;
				idx = index;
				leafs = new int[1];
				leafs[0] = index;
				centroid = ii.coord;
				height = 0;
			}

			public ClusterNode(ClusterNode a, ClusterNode b, int index, int h, float dist, ClusterNode[] clusters)
			{
				cha = a;
				chb = b;
				idx = index;
				leafs = new int[a.leafs.Length + b.leafs.Length];
				Array.Copy(a.leafs, leafs, a.leafs.Length);
				Array.Copy(b.leafs, 0, leafs, a.leafs.Length, b.leafs.Length);
				Vector3 zero = Vector3.zero;
				for (int i = 0; i < leafs.Length; i++)
				{
					zero += clusters[leafs[i]].centroid;
				}
				centroid = zero / leafs.Length;
				height = h;
				distToMergedCentroid = dist;
			}
		}

		[Serializable]
		public class item_s
		{
			public GameObject go;

			public Vector3 coord;
		}

		public class ClusterDistance
		{
			public ClusterNode a;

			public ClusterNode b;

			public ClusterDistance(ClusterNode aa, ClusterNode bb)
			{
				a = aa;
				b = bb;
			}
		}

		public List<item_s> items = new List<item_s>();

		public ClusterNode[] clusters;

		public bool wasCanceled;

		private const int MAX_PRIORITY_Q_SIZE = 2048;

		private float euclidean_distance(Vector3 a, Vector3 b)
		{
			return Vector3.Distance(a, b);
		}

		public bool agglomerate(ProgressUpdateCancelableDelegate progFunc)
		{
			wasCanceled = true;
			if (progFunc != null)
			{
				wasCanceled = progFunc("Filling Priority Queue:", 0f);
			}
			if (items.Count <= 1)
			{
				clusters = new ClusterNode[0];
				return false;
			}
			clusters = new ClusterNode[items.Count * 2 - 1];
			for (int i = 0; i < items.Count; i++)
			{
				clusters[i] = new ClusterNode(items[i], i);
			}
			int num = items.Count;
			List<ClusterNode> list = new List<ClusterNode>();
			for (int j = 0; j < num; j++)
			{
				clusters[j].isUnclustered = true;
				list.Add(clusters[j]);
			}
			int num2 = 0;
			new Stopwatch().Start();
			float num3 = 0f;
			long num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
			PriorityQueue<float, ClusterDistance> priorityQueue = new PriorityQueue<float, ClusterDistance>();
			int num5 = 0;
			while (list.Count > 1)
			{
				int num6 = 0;
				num2++;
				if (priorityQueue.Count == 0)
				{
					num5++;
					num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
					if (progFunc != null)
					{
						wasCanceled = progFunc("Refilling Q:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
					}
					num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
					if (priorityQueue.Count == 0)
					{
						break;
					}
				}
				KeyValuePair<float, ClusterDistance> keyValuePair = priorityQueue.Dequeue();
				while (!keyValuePair.Value.a.isUnclustered || !keyValuePair.Value.b.isUnclustered)
				{
					if (priorityQueue.Count == 0)
					{
						num5++;
						num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
						if (progFunc != null)
						{
							wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
						}
						num3 = _RefillPriorityQWithSome(priorityQueue, list, clusters, progFunc);
						if (priorityQueue.Count == 0)
						{
							break;
						}
					}
					keyValuePair = priorityQueue.Dequeue();
					num6++;
				}
				num++;
				ClusterNode clusterNode = new ClusterNode(keyValuePair.Value.a, keyValuePair.Value.b, num - 1, num2, keyValuePair.Key, clusters);
				list.Remove(keyValuePair.Value.a);
				list.Remove(keyValuePair.Value.b);
				keyValuePair.Value.a.isUnclustered = false;
				keyValuePair.Value.b.isUnclustered = false;
				int num7 = num - 1;
				if (num7 == clusters.Length)
				{
					UnityEngine.Debug.LogError("how did this happen");
				}
				clusters[num7] = clusterNode;
				list.Add(clusterNode);
				clusterNode.isUnclustered = true;
				for (int k = 0; k < list.Count - 1; k++)
				{
					float num8 = euclidean_distance(clusterNode.centroid, list[k].centroid);
					if (num8 < num3)
					{
						priorityQueue.Add(new KeyValuePair<float, ClusterDistance>(num8, new ClusterDistance(clusterNode, list[k])));
					}
				}
				if (wasCanceled)
				{
					break;
				}
				num4 = GC.GetTotalMemory(forceFullCollection: false) / 1000000;
				if (progFunc != null)
				{
					wasCanceled = progFunc("Creating clusters:" + (float)(items.Count - list.Count) * 100f / (float)items.Count + " unclustered:" + list.Count + " inQ:" + priorityQueue.Count + " usedMem:" + num4, (float)(items.Count - list.Count) / (float)items.Count);
				}
			}
			if (progFunc != null)
			{
				wasCanceled = progFunc("Finished clustering:", 100f);
			}
			if (wasCanceled)
			{
				return false;
			}
			return true;
		}

		private float _RefillPriorityQWithSome(PriorityQueue<float, ClusterDistance> pq, List<ClusterNode> unclustered, ClusterNode[] clusters, ProgressUpdateCancelableDelegate progFunc)
		{
			List<float> list = new List<float>(2048);
			for (int i = 0; i < unclustered.Count; i++)
			{
				for (int j = i + 1; j < unclustered.Count; j++)
				{
					list.Add(euclidean_distance(unclustered[i].centroid, unclustered[j].centroid));
				}
				wasCanceled = progFunc("Refilling Queue Part A:", (float)i / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			if (list.Count == 0)
			{
				return 1E+11f;
			}
			float num = NthSmallestElement(list, 2048);
			for (int k = 0; k < unclustered.Count; k++)
			{
				for (int l = k + 1; l < unclustered.Count; l++)
				{
					int idx = unclustered[k].idx;
					int idx2 = unclustered[l].idx;
					float num2 = euclidean_distance(unclustered[k].centroid, unclustered[l].centroid);
					if (num2 <= num)
					{
						pq.Add(new KeyValuePair<float, ClusterDistance>(num2, new ClusterDistance(clusters[idx], clusters[idx2])));
					}
				}
				wasCanceled = progFunc("Refilling Queue Part B:", (float)(unclustered.Count + k) / ((float)unclustered.Count * 2f));
				if (wasCanceled)
				{
					return 10f;
				}
			}
			return num;
		}

		public int TestRun(List<GameObject> gos)
		{
			List<item_s> list = new List<item_s>();
			for (int i = 0; i < gos.Count; i++)
			{
				item_s item_s = new item_s();
				item_s.go = gos[i];
				item_s.coord = gos[i].transform.position;
				list.Add(item_s);
			}
			items = list;
			if (items.Count > 0)
			{
				agglomerate(null);
			}
			return 0;
		}

		public static void Main()
		{
			List<float> list = new List<float>();
			list.AddRange(new float[10] { 19f, 18f, 17f, 16f, 15f, 10f, 11f, 12f, 13f, 14f });
			UnityEngine.Debug.Log("Loop quick select 10 times.");
			UnityEngine.Debug.Log(NthSmallestElement(list, 0));
		}

		public static T NthSmallestElement<T>(List<T> array, int n) where T : IComparable<T>
		{
			if (n < 0)
			{
				n = 0;
			}
			if (n > array.Count - 1)
			{
				n = array.Count - 1;
			}
			if (array.Count == 0)
			{
				throw new ArgumentException("Array is empty.", "array");
			}
			if (array.Count == 1)
			{
				return array[0];
			}
			return QuickSelectSmallest(array, n)[n];
		}

		private static List<T> QuickSelectSmallest<T>(List<T> input, int n) where T : IComparable<T>
		{
			int num = 0;
			int num2 = input.Count - 1;
			int pivotIndex = n;
			System.Random random = new System.Random();
			while (num2 > num)
			{
				pivotIndex = QuickSelectPartition(input, num, num2, pivotIndex);
				if (pivotIndex == n)
				{
					break;
				}
				if (pivotIndex > n)
				{
					num2 = pivotIndex - 1;
				}
				else
				{
					num = pivotIndex + 1;
				}
				pivotIndex = random.Next(num, num2);
			}
			return input;
		}

		private static int QuickSelectPartition<T>(List<T> array, int startIndex, int endIndex, int pivotIndex) where T : IComparable<T>
		{
			T other = array[pivotIndex];
			Swap(array, pivotIndex, endIndex);
			for (int i = startIndex; i < endIndex; i++)
			{
				if (array[i].CompareTo(other) <= 0)
				{
					Swap(array, i, startIndex);
					startIndex++;
				}
			}
			Swap(array, endIndex, startIndex);
			return startIndex;
		}

		private static void Swap<T>(List<T> array, int index1, int index2)
		{
			if (index1 != index2)
			{
				T value = array[index1];
				array[index1] = array[index2];
				array[index2] = value;
			}
		}
	}
	public class MB3_CopyBoneWeights
	{
		public static void CopyBoneWeightsFromSeamMeshToOtherMeshes(float radius, Mesh seamMesh, Mesh[] targetMeshes)
		{
			List<int> list = new List<int>();
			if (seamMesh == null)
			{
				UnityEngine.Debug.LogError($"The SeamMesh cannot be null");
				return;
			}
			if (seamMesh.vertexCount == 0)
			{
				UnityEngine.Debug.LogError("The seam mesh has no vertices. Check that the Asset Importer for the seam mesh does not have 'Optimize Mesh' checked.");
				return;
			}
			Vector3[] vertices = seamMesh.vertices;
			BoneWeight[] boneWeights = seamMesh.boneWeights;
			Vector3[] normals = seamMesh.normals;
			Vector4[] tangents = seamMesh.tangents;
			Vector2[] uv = seamMesh.uv;
			if (uv.Length != vertices.Length)
			{
				UnityEngine.Debug.LogError("The seam mesh needs uvs to identify which vertices are part of the seam. Vertices with UV > .5 are part of the seam. Vertices with UV < .5 are not part of the seam.");
				return;
			}
			for (int i = 0; i < uv.Length; i++)
			{
				if (uv[i].x > 0.5f && uv[i].y > 0.5f)
				{
					list.Add(i);
				}
			}
			UnityEngine.Debug.Log($"The seam mesh has {seamMesh.vertices.Length} vertices of which {list.Count} are seam vertices.");
			if (list.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the vertices in the Seam Mesh were marked as seam vertices. To mark a vertex as a seam vertex the UV must be greater than (.5,.5). Vertices with UV less than (.5,.5) are excluded.");
				return;
			}
			bool flag = false;
			for (int j = 0; j < targetMeshes.Length; j++)
			{
				if (targetMeshes[j] == null)
				{
					UnityEngine.Debug.LogError($"Mesh {j} was null");
					flag = true;
				}
				if (radius < 0f)
				{
					UnityEngine.Debug.LogError("radius must be zero or positive.");
				}
			}
			if (flag)
			{
				return;
			}
			for (int k = 0; k < targetMeshes.Length; k++)
			{
				Mesh obj = targetMeshes[k];
				Vector3[] vertices2 = obj.vertices;
				BoneWeight[] boneWeights2 = obj.boneWeights;
				Vector3[] normals2 = obj.normals;
				Vector4[] tangents2 = obj.tangents;
				int num = 0;
				for (int l = 0; l < vertices2.Length; l++)
				{
					for (int m = 0; m < list.Count; m++)
					{
						int num2 = list[m];
						if (Vector3.Distance(vertices2[l], vertices[num2]) <= radius)
						{
							num++;
							boneWeights2[l] = boneWeights[num2];
							vertices2[l] = vertices[num2];
							if (normals2.Length == vertices2.Length && normals.Length == normals.Length)
							{
								normals2[l] = normals[num2];
							}
							if (tangents2.Length == vertices2.Length && tangents.Length == vertices.Length)
							{
								tangents2[l] = tangents[num2];
							}
						}
					}
				}
				if (num > 0)
				{
					targetMeshes[k].vertices = vertices2;
					targetMeshes[k].boneWeights = boneWeights2;
					targetMeshes[k].normals = normals2;
					targetMeshes[k].tangents = tangents2;
				}
				UnityEngine.Debug.Log(string.Format("Copied boneweights for {1} vertices in mesh {0} that matched positions in the seam mesh.", targetMeshes[k].name, num));
			}
		}
	}
	[Serializable]
	public abstract class MB3_MeshCombiner
	{
		public delegate void GenerateUV2Delegate(Mesh m, float hardAngle, float packMargin);

		public class MBBlendShapeKey
		{
			public int gameObjecID;

			public int blendShapeIndexInSrc;

			public MBBlendShapeKey(int srcSkinnedMeshRenderGameObjectID, int blendShapeIndexInSource)
			{
				gameObjecID = srcSkinnedMeshRenderGameObjectID;
				blendShapeIndexInSrc = blendShapeIndexInSource;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MBBlendShapeKey) || obj == null)
				{
					return false;
				}
				MBBlendShapeKey mBBlendShapeKey = (MBBlendShapeKey)obj;
				if (gameObjecID == mBBlendShapeKey.gameObjecID)
				{
					return blendShapeIndexInSrc == mBBlendShapeKey.blendShapeIndexInSrc;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (23 * 31 + gameObjecID) * 31 + blendShapeIndexInSrc;
			}
		}

		public class MBBlendShapeValue
		{
			public GameObject combinedMeshGameObject;

			public int blendShapeIndex;
		}

		[SerializeField]
		protected MB2_LogLevel _LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_ValidationLevel _validationLevel = MB2_ValidationLevel.robust;

		[SerializeField]
		protected string _name;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected GameObject _resultSceneObject;

		[SerializeField]
		protected Renderer _targetRenderer;

		[SerializeField]
		protected MB_RenderType _renderType;

		[SerializeField]
		protected MB2_OutputOptions _outputOption;

		[SerializeField]
		protected MB2_LightmapOptions _lightmapOption = MB2_LightmapOptions.ignore_UV2;

		[SerializeField]
		protected bool _doNorm = true;

		[SerializeField]
		protected bool _doTan = true;

		[SerializeField]
		protected bool _doCol;

		[SerializeField]
		protected bool _doUV = true;

		[SerializeField]
		protected bool _doUV3;

		[SerializeField]
		protected bool _doUV4;

		[SerializeField]
		protected bool _doBlendShapes;

		[SerializeField]
		protected bool _recenterVertsToBoundsCenter;

		[SerializeField]
		public bool _optimizeAfterBake = true;

		[SerializeField]
		public float uv2UnwrappingParamsHardAngle = 60f;

		[SerializeField]
		public float uv2UnwrappingParamsPackMargin = 0.005f;

		protected bool _usingTemporaryTextureBakeResult;

		public static bool EVAL_VERSION => false;

		public virtual MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
			}
		}

		public virtual MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
			}
		}

		public string name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public virtual MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public virtual GameObject resultSceneObject
		{
			get
			{
				return _resultSceneObject;
			}
			set
			{
				_resultSceneObject = value;
			}
		}

		public virtual Renderer targetRenderer
		{
			get
			{
				return _targetRenderer;
			}
			set
			{
				if (_targetRenderer != null && _targetRenderer != value)
				{
					UnityEngine.Debug.LogWarning("Previous targetRenderer was not null. Combined mesh may be being used by more than one Renderer");
				}
				_targetRenderer = value;
			}
		}

		public virtual MB_RenderType renderType
		{
			get
			{
				return _renderType;
			}
			set
			{
				_renderType = value;
			}
		}

		public virtual MB2_OutputOptions outputOption
		{
			get
			{
				return _outputOption;
			}
			set
			{
				_outputOption = value;
			}
		}

		public virtual MB2_LightmapOptions lightmapOption
		{
			get
			{
				return _lightmapOption;
			}
			set
			{
				_lightmapOption = value;
			}
		}

		public virtual bool doNorm
		{
			get
			{
				return _doNorm;
			}
			set
			{
				_doNorm = value;
			}
		}

		public virtual bool doTan
		{
			get
			{
				return _doTan;
			}
			set
			{
				_doTan = value;
			}
		}

		public virtual bool doCol
		{
			get
			{
				return _doCol;
			}
			set
			{
				_doCol = value;
			}
		}

		public virtual bool doUV
		{
			get
			{
				return _doUV;
			}
			set
			{
				_doUV = value;
			}
		}

		public virtual bool doUV1
		{
			get
			{
				return false;
			}
			set
			{
			}
		}

		public virtual bool doUV3
		{
			get
			{
				return _doUV3;
			}
			set
			{
				_doUV3 = value;
			}
		}

		public virtual bool doUV4
		{
			get
			{
				return _doUV4;
			}
			set
			{
				_doUV4 = value;
			}
		}

		public virtual bool doBlendShapes
		{
			get
			{
				return _doBlendShapes;
			}
			set
			{
				_doBlendShapes = value;
			}
		}

		public virtual bool recenterVertsToBoundsCenter
		{
			get
			{
				return _recenterVertsToBoundsCenter;
			}
			set
			{
				_recenterVertsToBoundsCenter = value;
			}
		}

		public bool optimizeAfterBake
		{
			get
			{
				return _optimizeAfterBake;
			}
			set
			{
				_optimizeAfterBake = value;
			}
		}

		public virtual bool doUV2()
		{
			if (_lightmapOption != MB2_LightmapOptions.copy_UV2_unchanged && _lightmapOption != 0)
			{
				return _lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects;
			}
			return true;
		}

		public abstract int GetLightmapIndex();

		public abstract void ClearBuffers();

		public abstract void ClearMesh();

		public abstract void DestroyMesh();

		public abstract void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods);

		public abstract List<GameObject> GetObjectsInCombined();

		public abstract int GetNumObjectsInCombined();

		public abstract int GetNumVerticesFor(GameObject go);

		public abstract int GetNumVerticesFor(int instanceID);

		public abstract Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap();

		public virtual void Apply()
		{
			Apply(null);
		}

		public abstract void Apply(GenerateUV2Delegate uv2GenerationMethod);

		public abstract void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapeFlag = false, GenerateUV2Delegate uv2GenerationMethod = null);

		public abstract void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false);

		public abstract bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true);

		public abstract bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource);

		public abstract bool CombinedMeshContains(GameObject go);

		public abstract void UpdateSkinnedMeshApproximateBounds();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBones();

		public abstract void CheckIntegrity();

		public abstract void UpdateSkinnedMeshApproximateBoundsFromBounds();

		public static void UpdateSkinnedMeshApproximateBoundsFromBonesStatic(Transform[] bs, SkinnedMeshRenderer smr)
		{
			Vector3 position = bs[0].position;
			Vector3 position2 = bs[0].position;
			for (int i = 1; i < bs.Length; i++)
			{
				Vector3 position3 = bs[i].position;
				if (position3.x < position2.x)
				{
					position2.x = position3.x;
				}
				if (position3.y < position2.y)
				{
					position2.y = position3.y;
				}
				if (position3.z < position2.z)
				{
					position2.z = position3.z;
				}
				if (position3.x > position.x)
				{
					position.x = position3.x;
				}
				if (position3.y > position.y)
				{
					position.y = position3.y;
				}
				if (position3.z > position.z)
				{
					position.z = position3.z;
				}
			}
			Vector3 vector = (position + position2) / 2f;
			Vector3 vector2 = position - position2;
			Matrix4x4 worldToLocalMatrix = smr.worldToLocalMatrix;
			Bounds localBounds = new Bounds(worldToLocalMatrix * vector, worldToLocalMatrix * vector2);
			smr.localBounds = localBounds;
		}

		public static void UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(List<GameObject> objectsInCombined, SkinnedMeshRenderer smr)
		{
			Bounds b = default(Bounds);
			Bounds bounds = default(Bounds);
			if (MB_Utility.GetBounds(objectsInCombined[0], out b))
			{
				bounds = b;
				for (int i = 1; i < objectsInCombined.Count; i++)
				{
					if (MB_Utility.GetBounds(objectsInCombined[i], out b))
					{
						bounds.Encapsulate(b);
						continue;
					}
					UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
					return;
				}
				smr.localBounds = bounds;
			}
			else
			{
				UnityEngine.Debug.LogError("Could not get bounds. Not updating skinned mesh bounds");
			}
		}

		protected virtual bool _CreateTemporaryTextrueBakeResult(GameObject[] gos, List<Material> matsOnTargetRenderer)
		{
			if (GetNumObjectsInCombined() > 0)
			{
				UnityEngine.Debug.LogError("Can't add objects if there are already objects in combined mesh when 'Texture Bake Result' is not set. Perhaps enable 'Clear Buffers After Bake'");
				return false;
			}
			_usingTemporaryTextureBakeResult = true;
			_textureBakeResults = MB2_TextureBakeResults.CreateForMaterialsOnRenderer(gos, matsOnTargetRenderer);
			return true;
		}

		public abstract List<Material> GetMaterialsOnTargetRenderer();
	}
	[Serializable]
	public class MB3_MeshCombinerSingle : MB3_MeshCombiner
	{
		[Serializable]
		public class SerializableIntArray
		{
			public int[] data;

			public SerializableIntArray()
			{
			}

			public SerializableIntArray(int len)
			{
				data = new int[len];
			}
		}

		[Serializable]
		public class MB_DynamicGameObject : IComparable<MB_DynamicGameObject>
		{
			public int instanceID;

			public string name;

			public int vertIdx;

			public int blendShapeIdx;

			public int numVerts;

			public int numBlendShapes;

			public int[] indexesOfBonesUsed = new int[0];

			public int lightmapIndex = -1;

			public Vector4 lightmapTilingOffset = new Vector4(1f, 1f, 0f, 0f);

			public Vector3 meshSize = Vector3.one;

			public bool show = true;

			public bool invertTriangles;

			public int[] submeshTriIdxs;

			public int[] submeshNumTris;

			public int[] targetSubmeshIdxs;

			public Rect[] uvRects;

			public Rect[] encapsulatingRect;

			public Rect[] sourceMaterialTiling;

			public Rect[] obUVRects;

			public bool _beingDeleted;

			public int _triangleIdxAdjustment;

			[NonSerialized]
			public SerializableIntArray[] _tmpSubmeshTris;

			[NonSerialized]
			public Transform[] _tmpCachedBones;

			[NonSerialized]
			public Matrix4x4[] _tmpCachedBindposes;

			[NonSerialized]
			public BoneWeight[] _tmpCachedBoneWeights;

			[NonSerialized]
			public int[] _tmpIndexesOfSourceBonesUsed;

			public int CompareTo(MB_DynamicGameObject b)
			{
				return vertIdx - b.vertIdx;
			}
		}

		public class MeshChannels
		{
			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector4[] tangents;

			public Vector2[] uv0raw;

			public Vector2[] uv0modified;

			public Vector2[] uv2;

			public Vector2[] uv3;

			public Vector2[] uv4;

			public Color[] colors;

			public BoneWeight[] boneWeights;

			public Matrix4x4[] bindPoses;

			public int[] triangles;

			public MBBlendShape[] blendShapes;
		}

		[Serializable]
		public class MBBlendShapeFrame
		{
			public float frameWeight;

			public Vector3[] vertices;

			public Vector3[] normals;

			public Vector3[] tangents;
		}

		[Serializable]
		public class MBBlendShape
		{
			public int gameObjectID;

			public string name;

			public int indexInSource;

			public MBBlendShapeFrame[] frames;
		}

		public class MeshChannelsCache
		{
			private MB3_MeshCombinerSingle mc;

			protected Dictionary<int, MeshChannels> meshID2MeshChannels = new Dictionary<int, MeshChannels>();

			private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

			public MeshChannelsCache(MB3_MeshCombinerSingle mcs)
			{
				mc = mcs;
			}

			internal Vector3[] GetVertices(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.vertices == null)
				{
					value.vertices = m.vertices;
				}
				return value.vertices;
			}

			internal Vector3[] GetNormals(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.normals == null)
				{
					value.normals = _getMeshNormals(m);
				}
				return value.normals;
			}

			internal Vector4[] GetTangents(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.tangents == null)
				{
					value.tangents = _getMeshTangents(m);
				}
				return value.tangents;
			}

			internal Vector2[] GetUv0Raw(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0raw == null)
				{
					value.uv0raw = _getMeshUVs(m);
				}
				return value.uv0raw;
			}

			internal Vector2[] GetUv0Modified(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv0modified == null)
				{
					value.uv0modified = null;
				}
				return value.uv0modified;
			}

			internal Vector2[] GetUv2(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv2 == null)
				{
					value.uv2 = _getMeshUV2s(m);
				}
				return value.uv2;
			}

			internal Vector2[] GetUv3(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv3 == null)
				{
					value.uv3 = MBVersion.GetMeshUV3orUV4(m, get3: true, mc.LOG_LEVEL);
				}
				return value.uv3;
			}

			internal Vector2[] GetUv4(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.uv4 == null)
				{
					value.uv4 = MBVersion.GetMeshUV3orUV4(m, get3: false, mc.LOG_LEVEL);
				}
				return value.uv4;
			}

			internal Color[] GetColors(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.colors == null)
				{
					value.colors = _getMeshColors(m);
				}
				return value.colors;
			}

			internal Matrix4x4[] GetBindposes(Renderer r)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.bindPoses == null)
				{
					value.bindPoses = _getBindPoses(r);
				}
				return value.bindPoses;
			}

			internal BoneWeight[] GetBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				Mesh mesh = MB_Utility.GetMesh(r.gameObject);
				if (!meshID2MeshChannels.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(mesh.GetInstanceID(), value);
				}
				if (value.boneWeights == null)
				{
					value.boneWeights = _getBoneWeights(r, numVertsInMeshBeingAdded);
				}
				return value.boneWeights;
			}

			internal int[] GetTriangles(Mesh m)
			{
				if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
				{
					value = new MeshChannels();
					meshID2MeshChannels.Add(m.GetInstanceID(), value);
				}
				if (value.triangles == null)
				{
					value.triangles = m.triangles;
				}
				return value.triangles;
			}

			internal MBBlendShape[] GetBlendShapes(Mesh m, int gameObjectID)
			{
				if (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3))
				{
					if (!meshID2MeshChannels.TryGetValue(m.GetInstanceID(), out var value))
					{
						value = new MeshChannels();
						meshID2MeshChannels.Add(m.GetInstanceID(), value);
					}
					if (value.blendShapes == null)
					{
						MBBlendShape[] array = new MBBlendShape[m.blendShapeCount];
						int vertexCount = m.vertexCount;
						for (int i = 0; i < array.Length; i++)
						{
							MBBlendShape mBBlendShape = (array[i] = new MBBlendShape());
							mBBlendShape.frames = new MBBlendShapeFrame[MBVersion.GetBlendShapeFrameCount(m, i)];
							mBBlendShape.name = m.GetBlendShapeName(i);
							mBBlendShape.indexInSource = i;
							mBBlendShape.gameObjectID = gameObjectID;
							for (int j = 0; j < mBBlendShape.frames.Length; j++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = (mBBlendShape.frames[j] = new MBBlendShapeFrame());
								mBBlendShapeFrame.frameWeight = MBVersion.GetBlendShapeFrameWeight(m, i, j);
								mBBlendShapeFrame.vertices = new Vector3[vertexCount];
								mBBlendShapeFrame.normals = new Vector3[vertexCount];
								mBBlendShapeFrame.tangents = new Vector3[vertexCount];
								MBVersion.GetBlendShapeFrameVertices(m, i, j, mBBlendShapeFrame.vertices, mBBlendShapeFrame.normals, mBBlendShapeFrame.tangents);
							}
						}
						value.blendShapes = array;
						return value.blendShapes;
					}
					MBBlendShape[] array2 = new MBBlendShape[value.blendShapes.Length];
					for (int k = 0; k < array2.Length; k++)
					{
						array2[k] = new MBBlendShape();
						array2[k].name = value.blendShapes[k].name;
						array2[k].indexInSource = value.blendShapes[k].indexInSource;
						array2[k].frames = value.blendShapes[k].frames;
						array2[k].gameObjectID = gameObjectID;
					}
					return array2;
				}
				return new MBBlendShape[0];
			}

			private Color[] _getMeshColors(Mesh m)
			{
				Color[] array = m.colors;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no colors. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have colors. Generating an array of white colors"));
					}
					array = new Color[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = Color.white;
					}
				}
				return array;
			}

			private Vector3[] _getMeshNormals(Mesh m)
			{
				Vector3[] normals = m.normals;
				if (normals.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no normals. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have normals. Generating normals."));
					}
					Mesh mesh = UnityEngine.Object.Instantiate(m);
					mesh.RecalculateNormals();
					normals = mesh.normals;
					MB_Utility.Destroy(mesh);
				}
				return normals;
			}

			private Vector4[] _getMeshTangents(Mesh m)
			{
				Vector4[] array = m.tangents;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no tangents. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have tangents. Generating tangents."));
					}
					Vector3[] vertices = m.vertices;
					Vector2[] uv0Raw = GetUv0Raw(m);
					Vector3[] normals = _getMeshNormals(m);
					array = new Vector4[m.vertexCount];
					for (int i = 0; i < m.subMeshCount; i++)
					{
						int[] triangles = m.GetTriangles(i);
						_generateTangents(triangles, vertices, uv0Raw, normals, array);
					}
				}
				return array;
			}

			private Vector2[] _getMeshUVs(Mesh m)
			{
				Vector2[] array = m.uv;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uvs. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uvs. Generating uvs."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			private Vector2[] _getMeshUV2s(Mesh m)
			{
				Vector2[] array = m.uv2;
				if (array.Length == 0)
				{
					if (mc.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv2s. Generating"));
					}
					if (mc.LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv2s. Generating uv2s."));
					}
					if (mc._lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
					{
						UnityEngine.Debug.LogError(string.Concat("Mesh ", m, " did not have a UV2 channel. Nothing to copy when trying to copy UV2 to separate rects. The combined mesh will not lightmap properly. Try using generate new uv2 layout."));
					}
					array = new Vector2[m.vertexCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = _HALF_UV;
					}
				}
				return array;
			}

			public static Matrix4x4[] _getBindPoses(Renderer r)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.bindposes;
				}
				if (r is MeshRenderer)
				{
					Matrix4x4 identity = Matrix4x4.identity;
					return new Matrix4x4[1] { identity };
				}
				UnityEngine.Debug.LogError("Could not _getBindPoses. Object does not have a renderer");
				return null;
			}

			public static BoneWeight[] _getBoneWeights(Renderer r, int numVertsInMeshBeingAdded)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).sharedMesh.boneWeights;
				}
				if (r is MeshRenderer)
				{
					BoneWeight boneWeight = default(BoneWeight);
					int num2 = (boneWeight.boneIndex3 = 0);
					int num4 = (boneWeight.boneIndex2 = num2);
					int boneIndex = (boneWeight.boneIndex1 = num4);
					boneWeight.boneIndex0 = boneIndex;
					boneWeight.weight0 = 1f;
					float num7 = (boneWeight.weight3 = 0f);
					float weight = (boneWeight.weight2 = num7);
					boneWeight.weight1 = weight;
					BoneWeight[] array = new BoneWeight[numVertsInMeshBeingAdded];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = boneWeight;
					}
					return array;
				}
				UnityEngine.Debug.LogError("Could not _getBoneWeights. Object does not have a renderer");
				return null;
			}

			private void _generateTangents(int[] triangles, Vector3[] verts, Vector2[] uvs, Vector3[] normals, Vector4[] outTangents)
			{
				int num = triangles.Length;
				int num2 = verts.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = verts[num3];
					Vector3 vector2 = verts[num4];
					Vector3 vector3 = verts[num5];
					Vector2 vector4 = uvs[num3];
					Vector2 vector5 = uvs[num4];
					Vector2 vector6 = uvs[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					if (num16 == 0f)
					{
						UnityEngine.Debug.LogError("Could not compute tangents. All UVs need to form a valid triangles in UV space. If any UV triangles are collapsed, tangents cannot be generated.");
						return;
					}
					float num17 = 1f / num16;
					Vector3 vector7 = new Vector3((num15 * num6 - num14 * num7) * num17, (num15 * num8 - num14 * num9) * num17, (num15 * num10 - num14 * num11) * num17);
					Vector3 vector8 = new Vector3((num12 * num7 - num13 * num6) * num17, (num12 * num9 - num13 * num8) * num17, (num12 * num11 - num13 * num10) * num17);
					array[num3] += vector7;
					array[num4] += vector7;
					array[num5] += vector7;
					array2[num3] += vector8;
					array2[num4] += vector8;
					array2[num5] += vector8;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 vector9 = normals[j];
					Vector3 vector10 = array[j];
					Vector3 normalized = (vector10 - vector9 * Vector3.Dot(vector9, vector10)).normalized;
					outTangents[j] = new Vector4(normalized.x, normalized.y, normalized.z);
					outTangents[j].w = ((Vector3.Dot(Vector3.Cross(vector9, vector10), array2[j]) < 0f) ? (-1f) : 1f);
				}
			}
		}

		public struct BoneAndBindpose
		{
			public Transform bone;

			public Matrix4x4 bindPose;

			public BoneAndBindpose(Transform t, Matrix4x4 bp)
			{
				bone = t;
				bindPose = bp;
			}

			public override bool Equals(object obj)
			{
				if (obj is BoneAndBindpose && bone == ((BoneAndBindpose)obj).bone && bindPose == ((BoneAndBindpose)obj).bindPose)
				{
					return true;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (bone.GetInstanceID() % int.MaxValue) ^ (int)bindPose[0, 0];
			}
		}

		[SerializeField]
		protected List<GameObject> objectsInCombinedMesh = new List<GameObject>();

		[SerializeField]
		private int lightmapIndex = -1;

		[SerializeField]
		private List<MB_DynamicGameObject> mbDynamicObjectsInCombinedMesh = new List<MB_DynamicGameObject>();

		private Dictionary<int, MB_DynamicGameObject> _instance2combined_map = new Dictionary<int, MB_DynamicGameObject>();

		[SerializeField]
		private Vector3[] verts = new Vector3[0];

		[SerializeField]
		private Vector3[] normals = new Vector3[0];

		[SerializeField]
		private Vector4[] tangents = new Vector4[0];

		[SerializeField]
		private Vector2[] uvs = new Vector2[0];

		[SerializeField]
		private Vector2[] uv2s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv3s = new Vector2[0];

		[SerializeField]
		private Vector2[] uv4s = new Vector2[0];

		[SerializeField]
		private Color[] colors = new Color[0];

		[SerializeField]
		private Matrix4x4[] bindPoses = new Matrix4x4[0];

		[SerializeField]
		private Transform[] bones = new Transform[0];

		[SerializeField]
		internal MBBlendShape[] blendShapes = new MBBlendShape[0];

		[SerializeField]
		internal MBBlendShape[] blendShapesInCombined = new MBBlendShape[0];

		[SerializeField]
		private SerializableIntArray[] submeshTris = new SerializableIntArray[0];

		[SerializeField]
		private Mesh _mesh;

		private BoneWeight[] boneWeights = new BoneWeight[0];

		private GameObject[] empty = new GameObject[0];

		private int[] emptyIDs = new int[0];

		public override MB2_TextureBakeResults textureBakeResults
		{
			set
			{
				if (mbDynamicObjectsInCombinedMesh.Count > 0 && _textureBakeResults != value && _textureBakeResults != null && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("If Texture Bake Result is changed then objects currently in combined mesh may be invalid.");
				}
				_textureBakeResults = value;
			}
		}

		public override MB_RenderType renderType
		{
			set
			{
				if (value == MB_RenderType.skinnedMeshRenderer && _renderType == MB_RenderType.meshRenderer && boneWeights.Length != verts.Length)
				{
					UnityEngine.Debug.LogError("Can't set the render type to SkinnedMeshRenderer without clearing the mesh first. Try deleteing the CombinedMesh scene object.");
				}
				_renderType = value;
			}
		}

		public override GameObject resultSceneObject
		{
			set
			{
				if (_resultSceneObject != value)
				{
					_targetRenderer = null;
					if (_mesh != null && _LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result Scene Object was changed when this mesh baker component had a reference to a mesh. If mesh is being used by another object make sure to reset the mesh to none before baking to avoid overwriting the other mesh.");
					}
				}
				_resultSceneObject = value;
			}
		}

		private MB_DynamicGameObject instance2Combined_MapGet(int gameObjectID)
		{
			return _instance2combined_map[gameObjectID];
		}

		private void instance2Combined_MapAdd(int gameObjectID, MB_DynamicGameObject dgo)
		{
			_instance2combined_map.Add(gameObjectID, dgo);
		}

		private void instance2Combined_MapRemove(int gameObjectID)
		{
			_instance2combined_map.Remove(gameObjectID);
		}

		private bool instance2Combined_MapTryGetValue(int gameObjectID, out MB_DynamicGameObject dgo)
		{
			return _instance2combined_map.TryGetValue(gameObjectID, out dgo);
		}

		private int instance2Combined_MapCount()
		{
			return _instance2combined_map.Count;
		}

		private void instance2Combined_MapClear()
		{
			_instance2combined_map.Clear();
		}

		private bool instance2Combined_MapContainsKey(int gameObjectID)
		{
			return _instance2combined_map.ContainsKey(gameObjectID);
		}

		public override int GetNumObjectsInCombined()
		{
			return mbDynamicObjectsInCombinedMesh.Count;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			list.AddRange(objectsInCombinedMesh);
			return list;
		}

		public Mesh GetMesh()
		{
			if (_mesh == null)
			{
				_mesh = new Mesh();
			}
			return _mesh;
		}

		public void SetMesh(Mesh m)
		{
			_mesh = m;
		}

		public Transform[] GetBones()
		{
			return bones;
		}

		public override int GetLightmapIndex()
		{
			if (lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout || lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				return lightmapIndex;
			}
			return -1;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			return GetNumVerticesFor(go.GetInstanceID());
		}

		public override int GetNumVerticesFor(int instanceID)
		{
			if (instance2Combined_MapTryGetValue(instanceID, out var dgo))
			{
				return dgo.numVerts;
			}
			return -1;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < blendShapesInCombined.Length; i++)
			{
				MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
				mBBlendShapeValue.combinedMeshGameObject = _targetRenderer.gameObject;
				mBBlendShapeValue.blendShapeIndex = i;
				dictionary.Add(new MBBlendShapeKey(blendShapesInCombined[i].gameObjectID, blendShapesInCombined[i].indexInSource), mBBlendShapeValue);
			}
			return dictionary;
		}

		private void _initialize(int numResultMats)
		{
			if (mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				lightmapIndex = -1;
			}
			if (_mesh == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("_initialize Creating new Mesh");
				}
				_mesh = GetMesh();
			}
			if (instance2Combined_MapCount() != mbDynamicObjectsInCombinedMesh.Count)
			{
				instance2Combined_MapClear();
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					if (mbDynamicObjectsInCombinedMesh[i] != null)
					{
						instance2Combined_MapAdd(mbDynamicObjectsInCombinedMesh[i].instanceID, mbDynamicObjectsInCombinedMesh[i]);
					}
				}
				boneWeights = _mesh.boneWeights;
			}
			if (objectsInCombinedMesh.Count == 0 && submeshTris.Length != numResultMats)
			{
				submeshTris = new SerializableIntArray[numResultMats];
				for (int j = 0; j < submeshTris.Length; j++)
				{
					submeshTris[j] = new SerializableIntArray(0);
				}
			}
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && mbDynamicObjectsInCombinedMesh[0].indexesOfBonesUsed.Length == 0 && renderType == MB_RenderType.skinnedMeshRenderer && boneWeights.Length != 0)
			{
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					HashSet<int> hashSet = new HashSet<int>();
					for (int l = mB_DynamicGameObject.vertIdx; l < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; l++)
					{
						if (boneWeights[l].weight0 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex0);
						}
						if (boneWeights[l].weight1 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex1);
						}
						if (boneWeights[l].weight2 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex2);
						}
						if (boneWeights[l].weight3 > 0f)
						{
							hashSet.Add(boneWeights[l].boneIndex3);
						}
					}
					mB_DynamicGameObject.indexesOfBonesUsed = new int[hashSet.Count];
					hashSet.CopyTo(mB_DynamicGameObject.indexesOfBonesUsed);
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Baker used old systems that duplicated bones. Upgrading to new system by building indexesOfBonesUsed");
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_initialize numObjsInCombined={mbDynamicObjectsInCombinedMesh.Count}");
			}
		}

		private bool _collectMaterialTriangles(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map)
		{
			int num = m.subMeshCount;
			if (sharedMaterials.Length < num)
			{
				num = sharedMaterials.Length;
			}
			dgo._tmpSubmeshTris = new SerializableIntArray[num];
			dgo.targetSubmeshIdxs = new int[num];
			for (int i = 0; i < num; i++)
			{
				if (_textureBakeResults.doMultiMaterial)
				{
					if (!sourceMats2submeshIdx_map.Contains(sharedMaterials[i]))
					{
						UnityEngine.Debug.LogError("Object " + dgo.name + " has a material that was not found in the result materials maping. " + sharedMaterials[i]);
						return false;
					}
					dgo.targetSubmeshIdxs[i] = (int)sourceMats2submeshIdx_map[sharedMaterials[i]];
				}
				else
				{
					dgo.targetSubmeshIdxs[i] = 0;
				}
				dgo._tmpSubmeshTris[i] = new SerializableIntArray();
				dgo._tmpSubmeshTris[i].data = m.GetTriangles(i);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Collecting triangles for: " + dgo.name + " submesh:" + i + " maps to submesh:" + dgo.targetSubmeshIdxs[i] + " added:" + dgo._tmpSubmeshTris[i].data.Length, LOG_LEVEL);
				}
			}
			return true;
		}

		private bool _collectOutOfBoundsUVRects2(Mesh m, MB_DynamicGameObject dgo, Material[] sharedMaterials, OrderedDictionary sourceMats2submeshIdx_map, Dictionary<int, MB_Utility.MeshAnalysisResult[]> meshAnalysisResults, MeshChannelsCache meshChannelCache)
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Need to bake textures into combined material");
				return false;
			}
			if (meshAnalysisResults.TryGetValue(m.GetInstanceID(), out var value))
			{
				dgo.obUVRects = new Rect[sharedMaterials.Length];
				for (int i = 0; i < dgo.obUVRects.Length; i++)
				{
					dgo.obUVRects[i] = value[i].uvRect;
				}
			}
			else
			{
				int subMeshCount = m.subMeshCount;
				int num = subMeshCount;
				if (sharedMaterials.Length < subMeshCount)
				{
					num = sharedMaterials.Length;
				}
				dgo.obUVRects = new Rect[num];
				value = new MB_Utility.MeshAnalysisResult[subMeshCount];
				for (int j = 0; j < subMeshCount; j++)
				{
					int num2 = dgo.targetSubmeshIdxs[j];
					if (_textureBakeResults.resultMaterials[num2].considerMeshUVs)
					{
						MB_Utility.hasOutOfBoundsUVs(meshChannelCache.GetUv0Raw(m), m, ref value[j], j);
						Rect uvRect = value[j].uvRect;
						if (j < num)
						{
							dgo.obUVRects[j] = uvRect;
						}
					}
				}
				meshAnalysisResults.Add(m.GetInstanceID(), value);
			}
			return true;
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		private bool _validateMeshFlags()
		{
			if (mbDynamicObjectsInCombinedMesh.Count > 0 && ((!_doNorm && doNorm) || (!_doTan && doTan) || (!_doCol && doCol) || (!_doUV && doUV) || (!_doUV3 && doUV3) || (!_doUV4 && doUV4)))
			{
				UnityEngine.Debug.LogError("The channels have changed. There are already objects in the combined mesh that were added with a different set of channels.");
				return false;
			}
			_doNorm = doNorm;
			_doTan = doTan;
			_doCol = doCol;
			_doUV = doUV;
			_doUV3 = doUV3;
			_doUV4 = doUV4;
			return true;
		}

		private bool _showHide(GameObject[] goToShow, GameObject[] goToHide)
		{
			if (goToShow == null)
			{
				goToShow = empty;
			}
			if (goToHide == null)
			{
				goToHide = empty;
			}
			int numResultMats = _textureBakeResults.resultMaterials.Length;
			_initialize(numResultMats);
			for (int i = 0; i < goToHide.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(goToHide[i].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to hide an object ", goToHide[i], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int j = 0; j < goToShow.Length; j++)
			{
				if (!instance2Combined_MapContainsKey(goToShow[j].GetInstanceID()))
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Trying to show an object ", goToShow[j], " that is not in combined mesh. Did you initially bake with 'clear buffers after bake' enabled?"));
					}
					return false;
				}
			}
			for (int k = 0; k < goToHide.Length; k++)
			{
				_instance2combined_map[goToHide[k].GetInstanceID()].show = false;
			}
			for (int l = 0; l < goToShow.Length; l++)
			{
				_instance2combined_map[goToShow[l].GetInstanceID()].show = true;
			}
			return true;
		}

		private bool _addToCombined(GameObject[] goToAdd, int[] goToDelete, bool disableRendererInSource)
		{
			Stopwatch stopwatch = null;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				stopwatch = new Stopwatch();
				stopwatch.Start();
			}
			if (!_validateTextureBakeResults())
			{
				return false;
			}
			if (!_validateMeshFlags())
			{
				return false;
			}
			if (!ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return false;
			}
			if (outputOption != MB2_OutputOptions.bakeMeshAssetsInPlace && renderType == MB_RenderType.skinnedMeshRenderer && (_targetRenderer == null || !(_targetRenderer is SkinnedMeshRenderer)))
			{
				UnityEngine.Debug.LogError("Target renderer must be set and must be a SkinnedMeshRenderer");
				return false;
			}
			if (_doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("If doBlendShapes is set then RenderType must be skinnedMeshRenderer.");
				return false;
			}
			GameObject[] _goToAdd;
			if (goToAdd == null)
			{
				_goToAdd = empty;
			}
			else
			{
				_goToAdd = (GameObject[])goToAdd.Clone();
			}
			int[] array = ((goToDelete != null) ? ((int[])goToDelete.Clone()) : emptyIDs);
			if (_mesh == null)
			{
				DestroyMesh();
			}
			MB2_TextureBakeResults.Material2AtlasRectangleMapper material2AtlasRectangleMapper = new MB2_TextureBakeResults.Material2AtlasRectangleMapper(textureBakeResults);
			int num = _textureBakeResults.resultMaterials.Length;
			_initialize(num);
			if (submeshTris.Length != num)
			{
				UnityEngine.Debug.LogError("The number of submeshes " + submeshTris.Length + " in the combined mesh was not equal to the number of result materials " + num + " in the Texture Bake Result");
				return false;
			}
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("==== Calling _addToCombined objs adding:" + _goToAdd.Length + " objs deleting:" + array.Length + " fixOutOfBounds:" + textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs().ToString() + " doMultiMaterial:" + textureBakeResults.doMultiMaterial.ToString() + " disableRenderersInSource:" + disableRendererInSource.ToString(), LOG_LEVEL);
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("No resultMaterials in this TextureBakeResults. Try baking textures.");
				return false;
			}
			OrderedDictionary orderedDictionary = new OrderedDictionary();
			for (int j = 0; j < num; j++)
			{
				MB_MultiMaterial mB_MultiMaterial = _textureBakeResults.resultMaterials[j];
				for (int k = 0; k < mB_MultiMaterial.sourceMaterials.Count; k++)
				{
					if (mB_MultiMaterial.sourceMaterials[k] == null)
					{
						UnityEngine.Debug.LogError("Found null material in source materials for combined mesh materials " + j);
						return false;
					}
					if (!orderedDictionary.Contains(mB_MultiMaterial.sourceMaterials[k]))
					{
						orderedDictionary.Add(mB_MultiMaterial.sourceMaterials[k], j);
					}
				}
			}
			int num2 = 0;
			int[] array2 = new int[num];
			int num3 = 0;
			List<MB_DynamicGameObject>[] array3 = null;
			HashSet<int> hashSet = new HashSet<int>();
			HashSet<BoneAndBindpose> hashSet2 = new HashSet<BoneAndBindpose>();
			if (renderType == MB_RenderType.skinnedMeshRenderer && array.Length != 0)
			{
				array3 = _buildBoneIdx2dgoMap();
			}
			for (int l = 0; l < array.Length; l++)
			{
				if (instance2Combined_MapTryGetValue(array[l], out var dgo))
				{
					num2 += dgo.numVerts;
					num3 += dgo.numBlendShapes;
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						for (int m = 0; m < dgo.indexesOfBonesUsed.Length; m++)
						{
							if (array3[dgo.indexesOfBonesUsed[m]].Contains(dgo))
							{
								array3[dgo.indexesOfBonesUsed[m]].Remove(dgo);
								if (array3[dgo.indexesOfBonesUsed[m]].Count == 0)
								{
									hashSet.Add(dgo.indexesOfBonesUsed[m]);
								}
							}
						}
					}
					for (int n = 0; n < dgo.submeshNumTris.Length; n++)
					{
						array2[n] += dgo.submeshNumTris[n];
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Trying to delete an object that is not in combined mesh");
				}
			}
			List<MB_DynamicGameObject> list = new List<MB_DynamicGameObject>();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			MeshChannelsCache meshChannelsCache = new MeshChannelsCache(this);
			int num4 = 0;
			int[] array4 = new int[num];
			int num5 = 0;
			Dictionary<Transform, int> dictionary2 = new Dictionary<Transform, int>();
			for (int num6 = 0; num6 < bones.Length; num6++)
			{
				dictionary2.Add(bones[num6], num6);
			}
			int i;
			for (i = 0; i < _goToAdd.Length; i++)
			{
				if (!instance2Combined_MapContainsKey(_goToAdd[i].GetInstanceID()) || Array.FindIndex(array, (int o) => o == _goToAdd[i].GetInstanceID()) != -1)
				{
					MB_DynamicGameObject mB_DynamicGameObject = new MB_DynamicGameObject();
					GameObject gameObject = _goToAdd[i];
					Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Getting {gOMaterials.Length} shared materials for {gameObject}");
					}
					if (gOMaterials == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " does not have a Renderer");
						_goToAdd[i] = null;
						return false;
					}
					Mesh mesh = MB_Utility.GetMesh(gameObject);
					if (mesh == null)
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " MeshFilter or SkinedMeshRenderer had no mesh");
						_goToAdd[i] = null;
						return false;
					}
					if (MBVersion.IsRunningAndMeshNotReadWriteable(mesh))
					{
						UnityEngine.Debug.LogError("Object " + gameObject.name + " Mesh Importer has read/write flag set to 'false'. This needs to be set to 'true' in order to read data from this mesh.");
						_goToAdd[i] = null;
						return false;
					}
					MB_TextureTilingTreatment[] array5 = new MB_TextureTilingTreatment[gOMaterials.Length];
					Rect[] array6 = new Rect[gOMaterials.Length];
					Rect[] array7 = new Rect[gOMaterials.Length];
					Rect[] array8 = new Rect[gOMaterials.Length];
					string errorMsg = "";
					for (int num7 = 0; num7 < gOMaterials.Length; num7++)
					{
						object obj = orderedDictionary[gOMaterials[num7]];
						if (obj == null)
						{
							UnityEngine.Debug.LogError(string.Concat("Source object ", gameObject.name, " used a material ", gOMaterials[num7], " that was not in the baked materials."));
							return false;
						}
						int idxInResultMats = (int)obj;
						if (!material2AtlasRectangleMapper.TryMapMaterialToUVRect(gOMaterials[num7], mesh, num7, idxInResultMats, meshChannelsCache, dictionary, out array5[num7], out array6[num7], out array7[num7], out array8[num7], ref errorMsg, LOG_LEVEL))
						{
							UnityEngine.Debug.LogError(errorMsg);
							_goToAdd[i] = null;
							return false;
						}
					}
					if (!(_goToAdd[i] != null))
					{
						continue;
					}
					list.Add(mB_DynamicGameObject);
					mB_DynamicGameObject.name = $"{_goToAdd[i].ToString()} {_goToAdd[i].GetInstanceID()}";
					mB_DynamicGameObject.instanceID = _goToAdd[i].GetInstanceID();
					mB_DynamicGameObject.uvRects = array6;
					mB_DynamicGameObject.encapsulatingRect = array7;
					mB_DynamicGameObject.sourceMaterialTiling = array8;
					mB_DynamicGameObject.numVerts = mesh.vertexCount;
					if (_doBlendShapes)
					{
						mB_DynamicGameObject.numBlendShapes = mesh.blendShapeCount;
					}
					Renderer renderer = MB_Utility.GetRenderer(gameObject);
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						_CollectBonesToAddForDGO(mB_DynamicGameObject, dictionary2, hashSet, hashSet2, renderer, meshChannelsCache);
					}
					if (lightmapIndex == -1)
					{
						lightmapIndex = renderer.lightmapIndex;
					}
					if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
					{
						if (lightmapIndex != renderer.lightmapIndex && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " has a different lightmap index. Lightmapping will not work.");
						}
						if (!MBVersion.GetActive(gameObject) && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " is inactive. Can only get lightmap index of active objects.");
						}
						if (renderer.lightmapIndex == -1 && LOG_LEVEL >= MB2_LogLevel.warn)
						{
							UnityEngine.Debug.LogWarning("Object " + gameObject.name + " does not have an index to a lightmap.");
						}
					}
					mB_DynamicGameObject.lightmapIndex = renderer.lightmapIndex;
					mB_DynamicGameObject.lightmapTilingOffset = MBVersion.GetLightmapTilingOffset(renderer);
					if (!_collectMaterialTriangles(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary))
					{
						return false;
					}
					mB_DynamicGameObject.meshSize = renderer.bounds.size;
					mB_DynamicGameObject.submeshNumTris = new int[num];
					mB_DynamicGameObject.submeshTriIdxs = new int[num];
					if (textureBakeResults.DoAnyResultMatsUseConsiderMeshUVs() && !_collectOutOfBoundsUVRects2(mesh, mB_DynamicGameObject, gOMaterials, orderedDictionary, dictionary, meshChannelsCache))
					{
						return false;
					}
					num4 += mB_DynamicGameObject.numVerts;
					num5 += mB_DynamicGameObject.numBlendShapes;
					for (int num8 = 0; num8 < mB_DynamicGameObject._tmpSubmeshTris.Length; num8++)
					{
						array4[mB_DynamicGameObject.targetSubmeshIdxs[num8]] += mB_DynamicGameObject._tmpSubmeshTris[num8].data.Length;
					}
					mB_DynamicGameObject.invertTriangles = IsMirrored(gameObject.transform.localToWorldMatrix);
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + _goToAdd[i].name + " has already been added");
					}
					_goToAdd[i] = null;
				}
			}
			for (int num9 = 0; num9 < _goToAdd.Length; num9++)
			{
				if (_goToAdd[num9] != null && disableRendererInSource)
				{
					MB_Utility.DisableRendererInSource(_goToAdd[num9]);
					if (LOG_LEVEL == MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Disabling renderer on " + _goToAdd[num9].name + " id=" + _goToAdd[num9].GetInstanceID());
					}
				}
			}
			int num10 = verts.Length + num4 - num2;
			int num11 = bindPoses.Length + hashSet2.Count - hashSet.Count;
			int[] array9 = new int[num];
			int num12 = blendShapes.Length + num5 - num3;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Verts adding:" + num4 + " deleting:" + num2 + " submeshes:" + array9.Length + " bones:" + num11 + " blendShapes:" + num12);
			}
			for (int num13 = 0; num13 < array9.Length; num13++)
			{
				array9[num13] = submeshTris[num13].data.Length + array4[num13] - array2[num13];
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("    submesh :" + num13 + " already contains:" + submeshTris[num13].data.Length + " tris to be Added:" + array4[num13] + " tris to be Deleted:" + array2[num13]);
				}
			}
			if (num10 >= MBVersion.MaxMeshVertexCount())
			{
				UnityEngine.Debug.LogError("Cannot add objects. Resulting mesh will have more than " + MBVersion.MaxMeshVertexCount() + " vertices. Try using a Multi-MeshBaker component. This will split the combined mesh into several meshes. You don't have to re-configure the MB2_TextureBaker. Just remove the MB2_MeshBaker component and add a MB2_MultiMeshBaker component.");
				return false;
			}
			Vector3[] destinationArray = null;
			Vector4[] destinationArray2 = null;
			Vector2[] destinationArray3 = null;
			Vector2[] destinationArray4 = null;
			Vector2[] destinationArray5 = null;
			Vector2[] destinationArray6 = null;
			Color[] destinationArray7 = null;
			MBBlendShape[] array10 = null;
			Vector3[] destinationArray8 = new Vector3[num10];
			if (_doNorm)
			{
				destinationArray = new Vector3[num10];
			}
			if (_doTan)
			{
				destinationArray2 = new Vector4[num10];
			}
			if (_doUV)
			{
				destinationArray3 = new Vector2[num10];
			}
			if (_doUV3)
			{
				destinationArray5 = new Vector2[num10];
			}
			if (_doUV4)
			{
				destinationArray6 = new Vector2[num10];
			}
			if (doUV2())
			{
				destinationArray4 = new Vector2[num10];
			}
			if (_doCol)
			{
				destinationArray7 = new Color[num10];
			}
			if (_doBlendShapes)
			{
				array10 = new MBBlendShape[num12];
			}
			BoneWeight[] array11 = new BoneWeight[num10];
			Matrix4x4[] array12 = new Matrix4x4[num11];
			Transform[] array13 = new Transform[num11];
			SerializableIntArray[] array14 = new SerializableIntArray[num];
			for (int num14 = 0; num14 < array14.Length; num14++)
			{
				array14[num14] = new SerializableIntArray(array9[num14]);
			}
			for (int num15 = 0; num15 < array.Length; num15++)
			{
				MB_DynamicGameObject dgo2 = null;
				if (instance2Combined_MapTryGetValue(array[num15], out dgo2))
				{
					dgo2._beingDeleted = true;
				}
			}
			mbDynamicObjectsInCombinedMesh.Sort();
			int num16 = 0;
			int num17 = 0;
			int[] array15 = new int[num];
			int num18 = 0;
			for (int num19 = 0; num19 < mbDynamicObjectsInCombinedMesh.Count; num19++)
			{
				MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[num19];
				if (!mB_DynamicGameObject2._beingDeleted)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Copying obj in combined arrays idx:" + num19, LOG_LEVEL);
					}
					Array.Copy(verts, mB_DynamicGameObject2.vertIdx, destinationArray8, num16, mB_DynamicGameObject2.numVerts);
					if (_doNorm)
					{
						Array.Copy(normals, mB_DynamicGameObject2.vertIdx, destinationArray, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doTan)
					{
						Array.Copy(tangents, mB_DynamicGameObject2.vertIdx, destinationArray2, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV)
					{
						Array.Copy(uvs, mB_DynamicGameObject2.vertIdx, destinationArray3, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV3)
					{
						Array.Copy(uv3s, mB_DynamicGameObject2.vertIdx, destinationArray5, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doUV4)
					{
						Array.Copy(uv4s, mB_DynamicGameObject2.vertIdx, destinationArray6, num16, mB_DynamicGameObject2.numVerts);
					}
					if (doUV2())
					{
						Array.Copy(uv2s, mB_DynamicGameObject2.vertIdx, destinationArray4, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doCol)
					{
						Array.Copy(colors, mB_DynamicGameObject2.vertIdx, destinationArray7, num16, mB_DynamicGameObject2.numVerts);
					}
					if (_doBlendShapes)
					{
						Array.Copy(blendShapes, mB_DynamicGameObject2.blendShapeIdx, array10, num17, mB_DynamicGameObject2.numBlendShapes);
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer)
					{
						Array.Copy(boneWeights, mB_DynamicGameObject2.vertIdx, array11, num16, mB_DynamicGameObject2.numVerts);
					}
					for (int num20 = 0; num20 < num; num20++)
					{
						int[] data = submeshTris[num20].data;
						int num21 = mB_DynamicGameObject2.submeshTriIdxs[num20];
						int num22 = mB_DynamicGameObject2.submeshNumTris[num20];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug("    Adjusting submesh triangles submesh:" + num20 + " startIdx:" + num21 + " num:" + num22 + " nsubmeshTris:" + array14.Length + " targSubmeshTidx:" + array15.Length, LOG_LEVEL);
						}
						for (int num23 = num21; num23 < num21 + num22; num23++)
						{
							data[num23] -= num18;
						}
						Array.Copy(data, num21, array14[num20].data, array15[num20], num22);
					}
					mB_DynamicGameObject2.vertIdx = num16;
					mB_DynamicGameObject2.blendShapeIdx = num17;
					for (int num24 = 0; num24 < array15.Length; num24++)
					{
						mB_DynamicGameObject2.submeshTriIdxs[num24] = array15[num24];
						array15[num24] += mB_DynamicGameObject2.submeshNumTris[num24];
					}
					num17 += mB_DynamicGameObject2.numBlendShapes;
					num16 += mB_DynamicGameObject2.numVerts;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Not copying obj: " + num19, LOG_LEVEL);
					}
					num18 += mB_DynamicGameObject2.numVerts;
				}
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				_CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(hashSet, hashSet2, array13, array12, array11, num2);
			}
			for (int num25 = mbDynamicObjectsInCombinedMesh.Count - 1; num25 >= 0; num25--)
			{
				if (mbDynamicObjectsInCombinedMesh[num25]._beingDeleted)
				{
					instance2Combined_MapRemove(mbDynamicObjectsInCombinedMesh[num25].instanceID);
					objectsInCombinedMesh.RemoveAt(num25);
					mbDynamicObjectsInCombinedMesh.RemoveAt(num25);
				}
			}
			verts = destinationArray8;
			if (_doNorm)
			{
				normals = destinationArray;
			}
			if (_doTan)
			{
				tangents = destinationArray2;
			}
			if (_doUV)
			{
				uvs = destinationArray3;
			}
			if (_doUV3)
			{
				uv3s = destinationArray5;
			}
			if (_doUV4)
			{
				uv4s = destinationArray6;
			}
			if (doUV2())
			{
				uv2s = destinationArray4;
			}
			if (_doCol)
			{
				colors = destinationArray7;
			}
			if (_doBlendShapes)
			{
				blendShapes = array10;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				boneWeights = array11;
			}
			int num26 = bones.Length - hashSet.Count;
			bindPoses = array12;
			bones = array13;
			submeshTris = array14;
			int num27 = 0;
			foreach (BoneAndBindpose item in hashSet2)
			{
				array13[num26 + num27] = item.bone;
				array12[num26 + num27] = item.bindPose;
				num27++;
			}
			for (int num28 = 0; num28 < list.Count; num28++)
			{
				MB_DynamicGameObject mB_DynamicGameObject3 = list[num28];
				GameObject gameObject2 = _goToAdd[num28];
				int num29 = num16;
				int index = num17;
				Mesh mesh2 = MB_Utility.GetMesh(gameObject2);
				Matrix4x4 localToWorldMatrix = gameObject2.transform.localToWorldMatrix;
				Matrix4x4 matrix4x = localToWorldMatrix;
				float num31 = (matrix4x[2, 3] = 0f);
				float value = (matrix4x[1, 3] = num31);
				matrix4x[0, 3] = value;
				destinationArray8 = meshChannelsCache.GetVertices(mesh2);
				Vector3[] array16 = null;
				Vector4[] array17 = null;
				if (_doNorm)
				{
					array16 = meshChannelsCache.GetNormals(mesh2);
				}
				if (_doTan)
				{
					array17 = meshChannelsCache.GetTangents(mesh2);
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer)
				{
					for (int num33 = 0; num33 < destinationArray8.Length; num33++)
					{
						int num34 = num29 + num33;
						verts[num29 + num33] = localToWorldMatrix.MultiplyPoint3x4(destinationArray8[num33]);
						if (_doNorm)
						{
							normals[num34] = matrix4x.MultiplyPoint3x4(array16[num33]);
							normals[num34] = normals[num34].normalized;
						}
						if (_doTan)
						{
							float w = array17[num33].w;
							Vector3 vector = matrix4x.MultiplyPoint3x4(array17[num33]);
							vector.Normalize();
							tangents[num34] = vector;
							tangents[num34].w = w;
						}
					}
				}
				else
				{
					if (_doNorm)
					{
						array16.CopyTo(normals, num29);
					}
					if (_doTan)
					{
						array17.CopyTo(tangents, num29);
					}
					destinationArray8.CopyTo(verts, num29);
				}
				int subMeshCount = mesh2.subMeshCount;
				if (mB_DynamicGameObject3.uvRects.Length < subMeshCount)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Mesh " + mB_DynamicGameObject3.name + " has more submeshes than materials");
					}
					subMeshCount = mB_DynamicGameObject3.uvRects.Length;
				}
				else if (mB_DynamicGameObject3.uvRects.Length > subMeshCount && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Mesh " + mB_DynamicGameObject3.name + " has fewer submeshes than materials");
				}
				if (_doUV)
				{
					_copyAndAdjustUVsFromMesh(mB_DynamicGameObject3, mesh2, num29, meshChannelsCache);
				}
				if (doUV2())
				{
					_copyAndAdjustUV2FromMesh(mB_DynamicGameObject3, mesh2, num29, meshChannelsCache);
				}
				if (_doUV3)
				{
					destinationArray5 = meshChannelsCache.GetUv3(mesh2);
					destinationArray5.CopyTo(uv3s, num29);
				}
				if (_doUV4)
				{
					destinationArray6 = meshChannelsCache.GetUv4(mesh2);
					destinationArray6.CopyTo(uv4s, num29);
				}
				if (_doCol)
				{
					destinationArray7 = meshChannelsCache.GetColors(mesh2);
					destinationArray7.CopyTo(colors, num29);
				}
				if (_doBlendShapes)
				{
					array10 = meshChannelsCache.GetBlendShapes(mesh2, mB_DynamicGameObject3.instanceID);
					array10.CopyTo(blendShapes, index);
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					Renderer renderer2 = MB_Utility.GetRenderer(gameObject2);
					_AddBonesToNewBonesArrayAndAdjustBWIndexes(mB_DynamicGameObject3, renderer2, num29, array13, array11, meshChannelsCache);
				}
				for (int num35 = 0; num35 < array15.Length; num35++)
				{
					mB_DynamicGameObject3.submeshTriIdxs[num35] = array15[num35];
				}
				for (int num36 = 0; num36 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num36++)
				{
					int[] data2 = mB_DynamicGameObject3._tmpSubmeshTris[num36].data;
					for (int num37 = 0; num37 < data2.Length; num37++)
					{
						data2[num37] += num29;
					}
					if (mB_DynamicGameObject3.invertTriangles)
					{
						for (int num38 = 0; num38 < data2.Length; num38 += 3)
						{
							int num39 = data2[num38];
							data2[num38] = data2[num38 + 1];
							data2[num38 + 1] = num39;
						}
					}
					int num40 = mB_DynamicGameObject3.targetSubmeshIdxs[num36];
					data2.CopyTo(submeshTris[num40].data, array15[num40]);
					mB_DynamicGameObject3.submeshNumTris[num40] += data2.Length;
					array15[num40] += data2.Length;
				}
				mB_DynamicGameObject3.vertIdx = num16;
				mB_DynamicGameObject3.blendShapeIdx = num17;
				instance2Combined_MapAdd(gameObject2.GetInstanceID(), mB_DynamicGameObject3);
				objectsInCombinedMesh.Add(gameObject2);
				mbDynamicObjectsInCombinedMesh.Add(mB_DynamicGameObject3);
				num16 += destinationArray8.Length;
				if (_doBlendShapes)
				{
					num17 += array10.Length;
				}
				for (int num41 = 0; num41 < mB_DynamicGameObject3._tmpSubmeshTris.Length; num41++)
				{
					mB_DynamicGameObject3._tmpSubmeshTris[num41] = null;
				}
				mB_DynamicGameObject3._tmpSubmeshTris = null;
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Added to combined:" + mB_DynamicGameObject3.name + " verts:" + destinationArray8.Length + " bindPoses:" + array12.Length, LOG_LEVEL);
				}
			}
			if (lightmapOption == MB2_LightmapOptions.copy_UV2_unchanged_to_separate_rects)
			{
				_copyUV2unchangedToSeparateRects();
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("===== _addToCombined completed. Verts in buffer: " + verts.Length + " time(ms): " + stopwatch.ElapsedMilliseconds, LOG_LEVEL);
			}
			return true;
		}

		private void _copyAndAdjustUVsFromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv0Raw = meshChannelsCache.GetUv0Raw(mesh);
			int[] array = new int[uv0Raw.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = -1;
			}
			bool flag = false;
			for (int j = 0; j < dgo.targetSubmeshIdxs.Length; j++)
			{
				int[] array2 = ((dgo._tmpSubmeshTris == null) ? mesh.GetTriangles(j) : dgo._tmpSubmeshTris[j].data);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Build UV transform for mesh {dgo.name} submesh {j} encapsulatingRect {dgo.encapsulatingRect[j]}");
				}
				Rect rect = MB3_TextureCombinerMerging.BuildTransformMeshUV2AtlasRect(textureBakeResults.resultMaterials[dgo.targetSubmeshIdxs[j]].considerMeshUVs, dgo.uvRects[j], (dgo.obUVRects == null) ? new Rect(0f, 0f, 1f, 1f) : dgo.obUVRects[j], dgo.sourceMaterialTiling[j], dgo.encapsulatingRect[j]);
				foreach (int num in array2)
				{
					if (array[num] == -1)
					{
						array[num] = j;
						Vector2 vector = uv0Raw[num];
						vector.x = rect.x + vector.x * rect.width;
						vector.y = rect.y + vector.y * rect.height;
						uvs[vertsIdx + num] = vector;
					}
					if (array[num] != j)
					{
						flag = true;
					}
				}
			}
			if (flag && LOG_LEVEL >= MB2_LogLevel.warn)
			{
				UnityEngine.Debug.LogWarning(dgo.name + "has submeshes which share verticies. Adjusted uvs may not map correctly in combined atlas.");
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log($"_copyAndAdjustUVsFromMesh copied {uv0Raw.Length} verts");
			}
		}

		private void _copyAndAdjustUV2FromMesh(MB_DynamicGameObject dgo, Mesh mesh, int vertsIdx, MeshChannelsCache meshChannelsCache)
		{
			Vector2[] uv = meshChannelsCache.GetUv2(mesh);
			if (lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping)
			{
				Vector4 lightmapTilingOffset = dgo.lightmapTilingOffset;
				Vector2 vector = new Vector2(lightmapTilingOffset.x, lightmapTilingOffset.y);
				Vector2 vector2 = new Vector2(lightmapTilingOffset.z, lightmapTilingOffset.w);
				Vector2 vector3 = default(Vector2);
				for (int i = 0; i < uv.Length; i++)
				{
					vector3.x = vector.x * uv[i].x;
					vector3.y = vector.y * uv[i].y;
					uv2s[vertsIdx + i] = vector2 + vector3;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied and modify for preserve current lightmapping " + uv.Length);
				}
			}
			else
			{
				uv.CopyTo(uv2s, vertsIdx);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("_copyAndAdjustUV2FromMesh copied without modifying " + uv.Length);
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			UpdateSkinnedMeshApproximateBoundsFromBounds();
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (bones.Length == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("No bones in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBonesStatic(bones, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			if (outputOption == MB2_OutputOptions.bakeMeshAssetsInPlace)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Can't UpdateSkinnedMeshApproximateBoundsFromBounds when output type is bakeMeshAssetsInPlace");
				}
			}
			else if (verts.Length == 0 || mbDynamicObjectsInCombinedMesh.Count == 0)
			{
				if (verts.Length != 0 && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Nothing in SkinnedMeshRenderer. Could not UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (_targetRenderer == null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not set. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else if (!_targetRenderer.GetType().Equals(typeof(SkinnedMeshRenderer)))
			{
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Target Renderer is not a SkinnedMeshRenderer. No point in calling UpdateSkinnedMeshApproximateBoundsFromBounds.");
				}
			}
			else
			{
				MB3_MeshCombiner.UpdateSkinnedMeshApproximateBoundsFromBoundsStatic(objectsInCombinedMesh, (SkinnedMeshRenderer)targetRenderer);
			}
		}

		private int _getNumBones(Renderer r)
		{
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				if (r is SkinnedMeshRenderer)
				{
					return ((SkinnedMeshRenderer)r).bones.Length;
				}
				if (r is MeshRenderer)
				{
					return 1;
				}
				UnityEngine.Debug.LogError("Could not _getNumBones. Object does not have a renderer");
				return 0;
			}
			return 0;
		}

		private Transform[] _getBones(Renderer r)
		{
			return MBVersion.GetBones(r);
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			bool flag = false;
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				flag = true;
			}
			Apply(triangles: true, vertices: true, _doNorm, _doTan, _doUV, doUV2(), _doUV3, _doUV4, doCol, flag, doBlendShapes, uv2GenerationMethod);
		}

		public virtual void ApplyShowHide()
		{
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (renderType == MB_RenderType.meshRenderer)
				{
					MBVersion.MeshClear(_mesh, t: true);
					_mesh.vertices = verts;
				}
				SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
				if (textureBakeResults.doMultiMaterial)
				{
					int num2 = (_mesh.subMeshCount = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied));
					int numNonZeroLengthSubmeshTris = num2;
					int num3 = 0;
					for (int i = 0; i < submeshTrisWithShowHideApplied.Length; i++)
					{
						if (submeshTrisWithShowHideApplied[i].data.Length != 0)
						{
							_mesh.SetTriangles(submeshTrisWithShowHideApplied[i].data, num3);
							num3++;
						}
					}
					_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
				}
				else
				{
					_mesh.triangles = submeshTrisWithShowHideApplied[0].data;
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("ApplyShowHide");
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling ApplyShowHide");
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			Stopwatch stopwatch = null;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				stopwatch = new Stopwatch();
				stopwatch.Start();
			}
			if (_validationLevel >= MB2_ValidationLevel.quick && !ValidateTargRendererAndMeshAndResultSceneObj())
			{
				return;
			}
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Apply called tri={triangles} vert={vertices} norm={normals} tan={tangents} uv={uvs} col={colors} uv3={uv3} uv4={uv4} uv2={uv2} bone={bones} blendShape{blendShapes} meshID={_mesh.GetInstanceID()}");
				}
				if (triangles || _mesh.vertexCount != verts.Length)
				{
					bool justClearTriangles = triangles && !vertices && !normals && !tangents && !uvs && !colors && !uv3 && !uv4 && !uv2 && !bones;
					MBVersion.SetMeshIndexFormatAndClearMesh(_mesh, verts.Length, vertices, justClearTriangles);
				}
				if (vertices)
				{
					Vector3[] array = verts;
					if (verts.Length != 0)
					{
						if (_recenterVertsToBoundsCenter && _renderType == MB_RenderType.meshRenderer)
						{
							array = new Vector3[verts.Length];
							Vector3 vector = verts[0];
							Vector3 vector2 = verts[0];
							for (int i = 1; i < verts.Length; i++)
							{
								Vector3 vector3 = verts[i];
								if (vector.x < vector3.x)
								{
									vector.x = vector3.x;
								}
								if (vector.y < vector3.y)
								{
									vector.y = vector3.y;
								}
								if (vector.z < vector3.z)
								{
									vector.z = vector3.z;
								}
								if (vector2.x > vector3.x)
								{
									vector2.x = vector3.x;
								}
								if (vector2.y > vector3.y)
								{
									vector2.y = vector3.y;
								}
								if (vector2.z > vector3.z)
								{
									vector2.z = vector3.z;
								}
							}
							Vector3 vector4 = (vector + vector2) / 2f;
							for (int j = 0; j < verts.Length; j++)
							{
								array[j] = verts[j] - vector4;
							}
							targetRenderer.transform.position = vector4;
						}
						else
						{
							targetRenderer.transform.position = Vector3.zero;
						}
					}
					_mesh.vertices = array;
				}
				if (triangles && (bool)_textureBakeResults)
				{
					if (_textureBakeResults == null)
					{
						UnityEngine.Debug.LogError("Texture Bake Result was not set.");
					}
					else
					{
						SerializableIntArray[] submeshTrisWithShowHideApplied = GetSubmeshTrisWithShowHideApplied();
						int num2 = (_mesh.subMeshCount = _numNonZeroLengthSubmeshTris(submeshTrisWithShowHideApplied));
						int numNonZeroLengthSubmeshTris = num2;
						int num3 = 0;
						for (int k = 0; k < submeshTrisWithShowHideApplied.Length; k++)
						{
							if (submeshTrisWithShowHideApplied[k].data.Length != 0)
							{
								_mesh.SetTriangles(submeshTrisWithShowHideApplied[k].data, num3);
								num3++;
							}
						}
						_updateMaterialsOnTargetRenderer(submeshTrisWithShowHideApplied, numNonZeroLengthSubmeshTris);
					}
				}
				if (normals)
				{
					if (_doNorm)
					{
						_mesh.normals = this.normals;
					}
					else
					{
						UnityEngine.Debug.LogError("normal flag was set in Apply but MeshBaker didn't generate normals");
					}
				}
				if (tangents)
				{
					if (_doTan)
					{
						_mesh.tangents = this.tangents;
					}
					else
					{
						UnityEngine.Debug.LogError("tangent flag was set in Apply but MeshBaker didn't generate tangents");
					}
				}
				if (uvs)
				{
					if (_doUV)
					{
						_mesh.uv = this.uvs;
					}
					else
					{
						UnityEngine.Debug.LogError("uv flag was set in Apply but MeshBaker didn't generate uvs");
					}
				}
				if (colors)
				{
					if (_doCol)
					{
						_mesh.colors = this.colors;
					}
					else
					{
						UnityEngine.Debug.LogError("color flag was set in Apply but MeshBaker didn't generate colors");
					}
				}
				if (uv3)
				{
					if (_doUV3)
					{
						MBVersion.MeshAssignUV3(_mesh, uv3s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv3 flag was set in Apply but MeshBaker didn't generate uv3s");
					}
				}
				if (uv4)
				{
					if (_doUV4)
					{
						MBVersion.MeshAssignUV4(_mesh, uv4s);
					}
					else
					{
						UnityEngine.Debug.LogError("uv4 flag was set in Apply but MeshBaker didn't generate uv4s");
					}
				}
				if (uv2)
				{
					if (doUV2())
					{
						_mesh.uv2 = uv2s;
					}
					else
					{
						UnityEngine.Debug.LogError("uv2 flag was set in Apply but lightmapping option was set to " + lightmapOption);
					}
				}
				bool flag = false;
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
				{
					if (uv2GenerationMethod != null)
					{
						uv2GenerationMethod(_mesh, uv2UnwrappingParamsHardAngle, uv2UnwrappingParamsPackMargin);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log("generating new UV2 layout for the combined mesh ");
						}
					}
					else
					{
						UnityEngine.Debug.LogError("No GenerateUV2Delegate method was supplied. UV2 cannot be generated.");
					}
					flag = true;
				}
				else if (renderType == MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("UV2 cannot be generated for SkinnedMeshRenderer objects.");
				}
				if (renderType != MB_RenderType.skinnedMeshRenderer && lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout && !flag)
				{
					UnityEngine.Debug.LogError("Failed to generate new UV2 layout. Only works in editor.");
				}
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					if (verts.Length == 0)
					{
						targetRenderer.enabled = false;
					}
					else
					{
						targetRenderer.enabled = true;
					}
					bool updateWhenOffscreen = ((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = true;
					((SkinnedMeshRenderer)targetRenderer).updateWhenOffscreen = updateWhenOffscreen;
				}
				if (bones)
				{
					_mesh.bindposes = bindPoses;
					_mesh.boneWeights = boneWeights;
				}
				if (blendShapesFlag && (MBVersion.GetMajorVersion() > 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() >= 3)))
				{
					if (blendShapesInCombined.Length != blendShapes.Length)
					{
						blendShapesInCombined = new MBBlendShape[blendShapes.Length];
					}
					Vector3[] array2 = new Vector3[verts.Length];
					Vector3[] array3 = new Vector3[verts.Length];
					Vector3[] array4 = new Vector3[verts.Length];
					MBVersion.ClearBlendShapes(_mesh);
					for (int l = 0; l < blendShapes.Length; l++)
					{
						MB_DynamicGameObject mB_DynamicGameObject = instance2Combined_MapGet(blendShapes[l].gameObjectID);
						if (mB_DynamicGameObject != null)
						{
							for (int m = 0; m < blendShapes[l].frames.Length; m++)
							{
								MBBlendShapeFrame mBBlendShapeFrame = blendShapes[l].frames[m];
								int vertIdx = mB_DynamicGameObject.vertIdx;
								Array.Copy(mBBlendShapeFrame.vertices, 0, array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								Array.Copy(mBBlendShapeFrame.normals, 0, array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								Array.Copy(mBBlendShapeFrame.tangents, 0, array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
								MBVersion.AddBlendShapeFrame(_mesh, blendShapes[l].name + blendShapes[l].gameObjectID, mBBlendShapeFrame.frameWeight, array2, array3, array4);
								_ZeroArray(array2, vertIdx, blendShapes[l].frames[m].vertices.Length);
								_ZeroArray(array3, vertIdx, blendShapes[l].frames[m].normals.Length);
								_ZeroArray(array4, vertIdx, blendShapes[l].frames[m].tangents.Length);
							}
						}
						else
						{
							UnityEngine.Debug.LogError("InstanceID in blend shape that was not in instance2combinedMap");
						}
						blendShapesInCombined[l] = blendShapes[l];
					}
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = null;
					((SkinnedMeshRenderer)_targetRenderer).sharedMesh = _mesh;
				}
				if (triangles || vertices)
				{
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("recalculating bounds on mesh.");
					}
					_mesh.RecalculateBounds();
				}
				if (_optimizeAfterBake && !Application.isPlaying)
				{
					MBVersion.OptimizeMesh(_mesh);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Need to add objects to this meshbaker before calling Apply or ApplyAll");
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Apply Complete time: " + stopwatch.ElapsedMilliseconds + " vertices: " + _mesh.vertexCount);
			}
		}

		private int _numNonZeroLengthSubmeshTris(SerializableIntArray[] subTris)
		{
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length != 0)
				{
					num++;
				}
			}
			return num;
		}

		private void _updateMaterialsOnTargetRenderer(SerializableIntArray[] subTris, int numNonZeroLengthSubmeshTris)
		{
			if (subTris.Length != textureBakeResults.resultMaterials.Length)
			{
				UnityEngine.Debug.LogError("Mismatch between number of submeshes and number of result materials");
			}
			Material[] array = new Material[numNonZeroLengthSubmeshTris];
			int num = 0;
			for (int i = 0; i < subTris.Length; i++)
			{
				if (subTris[i].data.Length != 0)
				{
					array[num] = _textureBakeResults.resultMaterials[i].combinedMaterial;
					num++;
				}
			}
			targetRenderer.materials = array;
		}

		public SerializableIntArray[] GetSubmeshTrisWithShowHideApplied()
		{
			bool flag = false;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				if (!mbDynamicObjectsInCombinedMesh[i].show)
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				int[] array = new int[submeshTris.Length];
				SerializableIntArray[] array2 = new SerializableIntArray[submeshTris.Length];
				for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
					if (mB_DynamicGameObject.show)
					{
						for (int k = 0; k < mB_DynamicGameObject.submeshNumTris.Length; k++)
						{
							array[k] += mB_DynamicGameObject.submeshNumTris[k];
						}
					}
				}
				for (int l = 0; l < array2.Length; l++)
				{
					array2[l] = new SerializableIntArray(array[l]);
				}
				int[] array3 = new int[array2.Length];
				for (int m = 0; m < mbDynamicObjectsInCombinedMesh.Count; m++)
				{
					MB_DynamicGameObject mB_DynamicGameObject2 = mbDynamicObjectsInCombinedMesh[m];
					if (!mB_DynamicGameObject2.show)
					{
						continue;
					}
					for (int n = 0; n < submeshTris.Length; n++)
					{
						int[] data = submeshTris[n].data;
						int num = mB_DynamicGameObject2.submeshTriIdxs[n];
						int num2 = num + mB_DynamicGameObject2.submeshNumTris[n];
						for (int num3 = num; num3 < num2; num3++)
						{
							array2[n].data[array3[n]] = data[num3];
							array3[n]++;
						}
					}
				}
				return array2;
			}
			return submeshTris;
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			_updateGameObjects(gos, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
		}

		private void _updateGameObjects(GameObject[] gos, bool recalcBounds, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("UpdateGameObjects called on " + gos.Length + " objects.");
			}
			int numResultMats = 1;
			if (textureBakeResults.doMultiMaterial)
			{
				numResultMats = textureBakeResults.resultMaterials.Length;
			}
			_initialize(numResultMats);
			if (_mesh.vertexCount > 0 && _instance2combined_map.Count == 0)
			{
				UnityEngine.Debug.LogWarning("There were vertices in the combined mesh but nothing in the MeshBaker buffers. If you are trying to bake in the editor and modify at runtime, make sure 'Clear Buffers After Bake' is unchecked.");
			}
			MeshChannelsCache meshChannelCache = new MeshChannelsCache(this);
			for (int i = 0; i < gos.Length; i++)
			{
				_updateGameObject(gos[i], updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo, meshChannelCache);
			}
			if (recalcBounds)
			{
				_mesh.RecalculateBounds();
			}
		}

		private void _updateGameObject(GameObject go, bool updateVertices, bool updateNormals, bool updateTangents, bool updateUV, bool updateUV2, bool updateUV3, bool updateUV4, bool updateColors, bool updateSkinningInfo, MeshChannelsCache meshChannelCache)
		{
			MB_DynamicGameObject dgo = null;
			if (!instance2Combined_MapTryGetValue(go.GetInstanceID(), out dgo))
			{
				UnityEngine.Debug.LogError("Object " + go.name + " has not been added");
				return;
			}
			Mesh mesh = MB_Utility.GetMesh(go);
			if (dgo.numVerts != mesh.vertexCount)
			{
				UnityEngine.Debug.LogError("Object " + go.name + " source mesh has been modified since being added. To update it must have the same number of verts");
				return;
			}
			if (_doUV && updateUV)
			{
				_copyAndAdjustUVsFromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (doUV2() && updateUV2)
			{
				_copyAndAdjustUV2FromMesh(dgo, mesh, dgo.vertIdx, meshChannelCache);
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer && updateSkinningInfo)
			{
				Renderer renderer = MB_Utility.GetRenderer(go);
				BoneWeight[] array = meshChannelCache.GetBoneWeights(renderer, dgo.numVerts);
				Transform[] array2 = _getBones(renderer);
				int num = dgo.vertIdx;
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array2[array[i].boneIndex0] != bones[boneWeights[num].boneIndex0])
					{
						flag = true;
						break;
					}
					boneWeights[num].weight0 = array[i].weight0;
					boneWeights[num].weight1 = array[i].weight1;
					boneWeights[num].weight2 = array[i].weight2;
					boneWeights[num].weight3 = array[i].weight3;
					num++;
				}
				if (flag)
				{
					UnityEngine.Debug.LogError("Detected that some of the boneweights reference different bones than when initial added. Boneweights must reference the same bones " + dgo.name);
				}
			}
			Matrix4x4 localToWorldMatrix = go.transform.localToWorldMatrix;
			if (updateVertices)
			{
				Vector3[] vertices = meshChannelCache.GetVertices(mesh);
				for (int j = 0; j < vertices.Length; j++)
				{
					verts[dgo.vertIdx + j] = localToWorldMatrix.MultiplyPoint3x4(vertices[j]);
				}
			}
			float num3 = (localToWorldMatrix[2, 3] = 0f);
			float value = (localToWorldMatrix[1, 3] = num3);
			localToWorldMatrix[0, 3] = value;
			if (_doNorm && updateNormals)
			{
				Vector3[] array3 = meshChannelCache.GetNormals(mesh);
				for (int k = 0; k < array3.Length; k++)
				{
					int num5 = dgo.vertIdx + k;
					normals[num5] = localToWorldMatrix.MultiplyPoint3x4(array3[k]);
					normals[num5] = normals[num5].normalized;
				}
			}
			if (_doTan && updateTangents)
			{
				Vector4[] array4 = meshChannelCache.GetTangents(mesh);
				for (int l = 0; l < array4.Length; l++)
				{
					int num6 = dgo.vertIdx + l;
					float w = array4[l].w;
					Vector3 vector = localToWorldMatrix.MultiplyPoint3x4(array4[l]);
					vector.Normalize();
					tangents[num6] = vector;
					tangents[num6].w = w;
				}
			}
			if (_doCol && updateColors)
			{
				Color[] array5 = meshChannelCache.GetColors(mesh);
				for (int m = 0; m < array5.Length; m++)
				{
					colors[dgo.vertIdx + m] = array5[m];
				}
			}
			if (_doUV3 && updateUV3)
			{
				Vector2[] uv = meshChannelCache.GetUv3(mesh);
				for (int n = 0; n < uv.Length; n++)
				{
					uv3s[dgo.vertIdx + n] = uv[n];
				}
			}
			if (_doUV4 && updateUV4)
			{
				Vector2[] uv2 = meshChannelCache.GetUv4(mesh);
				for (int num7 = 0; num7 < uv2.Length; num7++)
				{
					uv4s[dgo.vertIdx + num7] = uv2[num7];
				}
			}
		}

		public bool ShowHideGameObjects(GameObject[] toShow, GameObject[] toHide)
		{
			if (textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("TextureBakeResults must be set.");
				return false;
			}
			return _showHide(toShow, toHide);
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			if (validationLevel > MB2_ValidationLevel.none)
			{
				if (gos != null)
				{
					for (int i = 0; i < gos.Length; i++)
					{
						if (gos[i] == null)
						{
							UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
							return false;
						}
						if (validationLevel < MB2_ValidationLevel.robust)
						{
							continue;
						}
						for (int j = i + 1; j < gos.Length; j++)
						{
							if (gos[i] == gos[j])
							{
								UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " appears twice in list of game objects to add"));
								return false;
							}
						}
					}
				}
				if (deleteGOinstanceIDs != null && validationLevel >= MB2_ValidationLevel.robust)
				{
					for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
					{
						for (int l = k + 1; l < deleteGOinstanceIDs.Length; l++)
						{
							if (deleteGOinstanceIDs[k] == deleteGOinstanceIDs[l])
							{
								UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[k] + "appears twice in list of game objects to delete");
								return false;
							}
						}
					}
				}
			}
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			BuildSceneMeshObject(gos);
			if (!_addToCombined(gos, deleteGOinstanceIDs, disableRendererInSource))
			{
				UnityEngine.Debug.LogError("Failed to add/delete objects to combined mesh");
				return false;
			}
			if (targetRenderer != null)
			{
				if (renderType == MB_RenderType.skinnedMeshRenderer)
				{
					SkinnedMeshRenderer obj = (SkinnedMeshRenderer)targetRenderer;
					obj.sharedMesh = _mesh;
					obj.bones = bones;
					UpdateSkinnedMeshApproximateBoundsFromBounds();
				}
				targetRenderer.lightmapIndex = GetLightmapIndex();
			}
			return true;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return objectsInCombinedMesh.Contains(go);
		}

		public override void ClearBuffers()
		{
			verts = new Vector3[0];
			normals = new Vector3[0];
			tangents = new Vector4[0];
			uvs = new Vector2[0];
			uv2s = new Vector2[0];
			uv3s = new Vector2[0];
			uv4s = new Vector2[0];
			colors = new Color[0];
			bones = new Transform[0];
			bindPoses = new Matrix4x4[0];
			boneWeights = new BoneWeight[0];
			submeshTris = new SerializableIntArray[0];
			blendShapes = new MBBlendShape[0];
			if (blendShapesInCombined == null)
			{
				blendShapesInCombined = new MBBlendShape[0];
			}
			else
			{
				for (int i = 0; i < blendShapesInCombined.Length; i++)
				{
					blendShapesInCombined[i].frames = new MBBlendShapeFrame[0];
				}
			}
			mbDynamicObjectsInCombinedMesh.Clear();
			objectsInCombinedMesh.Clear();
			instance2Combined_MapClear();
			if (_usingTemporaryTextureBakeResult)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (LOG_LEVEL >= MB2_LogLevel.trace)
			{
				MB2_Log.LogDebug("ClearBuffers called");
			}
		}

		public override void ClearMesh()
		{
			if (_mesh != null)
			{
				MBVersion.MeshClear(_mesh, t: false);
			}
			else
			{
				_mesh = new Mesh();
			}
			ClearBuffers();
		}

		public override void DestroyMesh()
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				MB_Utility.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			if (_mesh != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Destroying Mesh");
				}
				editorMethods.Destroy(_mesh);
			}
			_mesh = new Mesh();
			ClearBuffers();
		}

		public bool ValidateTargRendererAndMeshAndResultSceneObj()
		{
			if (_resultSceneObject == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Result Scene Object was not set.");
				}
				return false;
			}
			if (_targetRenderer == null)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer was not set.");
				}
				return false;
			}
			if (_targetRenderer.transform.parent != _resultSceneObject.transform)
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Target Renderer game object is not a child of Result Scene Object was not set.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.skinnedMeshRenderer && !(_targetRenderer is SkinnedMeshRenderer))
			{
				if (_LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Render Type is skinned mesh renderer but Target Renderer is not.");
				}
				return false;
			}
			if (_renderType == MB_RenderType.meshRenderer)
			{
				if (!(_targetRenderer is MeshRenderer))
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Render Type is mesh renderer but Target Renderer is not.");
					}
					return false;
				}
				MeshFilter component = _targetRenderer.GetComponent<MeshFilter>();
				if (_mesh != component.sharedMesh)
				{
					if (_LOG_LEVEL >= MB2_LogLevel.error)
					{
						UnityEngine.Debug.LogError("Target renderer mesh is not equal to mesh.");
					}
					return false;
				}
			}
			return true;
		}

		internal static Renderer BuildSceneHierarchPreBake(MB3_MeshCombinerSingle mom, GameObject root, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			if (mom._LOG_LEVEL >= MB2_LogLevel.trace)
			{
				UnityEngine.Debug.Log("Building Scene Hierarchy createNewChild=" + createNewChild);
			}
			MeshFilter meshFilter = null;
			MeshRenderer meshRenderer = null;
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			Transform transform = null;
			if (root == null)
			{
				UnityEngine.Debug.LogError("root was null.");
				return null;
			}
			if (mom.textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("textureBakeResults must be set.");
				return null;
			}
			if (root.GetComponent<Renderer>() != null)
			{
				UnityEngine.Debug.LogError("root game object cannot have a renderer component");
				return null;
			}
			if (!createNewChild)
			{
				if (mom.targetRenderer != null && mom.targetRenderer.transform.parent == root.transform)
				{
					transform = mom.targetRenderer.transform;
				}
				else
				{
					Renderer[] componentsInChildren = root.GetComponentsInChildren<Renderer>();
					if (componentsInChildren.Length == 1)
					{
						if (componentsInChildren[0].transform.parent != root.transform)
						{
							UnityEngine.Debug.LogError("Target Renderer is not an immediate child of Result Scene Object. Try using a game object with no children as the Result Scene Object..");
						}
						transform = componentsInChildren[0].transform;
					}
				}
			}
			if (transform != null && transform.parent != root.transform)
			{
				transform = null;
			}
			GameObject gameObject;
			if (transform == null)
			{
				gameObject = new GameObject(mom.name + "-mesh");
				gameObject.transform.parent = root.transform;
				transform = gameObject.transform;
			}
			transform.parent = root.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
			}
			_ConfigureSceneHierarch(mom, root, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				return skinnedMeshRenderer;
			}
			return meshRenderer;
		}

		public static void BuildPrefabHierarchy(MB3_MeshCombinerSingle mom, GameObject instantiatedPrefabRoot, Mesh m, bool createNewChild = false, GameObject[] objsToBeAdded = null)
		{
			SkinnedMeshRenderer skinnedMeshRenderer = null;
			MeshRenderer meshRenderer = null;
			MeshFilter meshFilter = null;
			GameObject gameObject = new GameObject(mom.name + "-mesh");
			gameObject.transform.parent = instantiatedPrefabRoot.transform;
			Transform transform = gameObject.transform;
			transform.parent = instantiatedPrefabRoot.transform;
			gameObject = transform.gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					MB_Utility.Destroy(component);
				}
				MeshFilter component2 = gameObject.GetComponent<MeshFilter>();
				if (component2 != null)
				{
					MB_Utility.Destroy(component2);
				}
				skinnedMeshRenderer = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (skinnedMeshRenderer == null)
				{
					skinnedMeshRenderer = gameObject.AddComponent<SkinnedMeshRenderer>();
				}
			}
			else
			{
				SkinnedMeshRenderer component3 = gameObject.GetComponent<SkinnedMeshRenderer>();
				if (component3 != null)
				{
					MB_Utility.Destroy(component3);
				}
				meshFilter = gameObject.GetComponent<MeshFilter>();
				if (meshFilter == null)
				{
					meshFilter = gameObject.AddComponent<MeshFilter>();
				}
				meshRenderer = gameObject.GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = gameObject.AddComponent<MeshRenderer>();
				}
			}
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				skinnedMeshRenderer.bones = mom.GetBones();
				bool updateWhenOffscreen = skinnedMeshRenderer.updateWhenOffscreen;
				skinnedMeshRenderer.updateWhenOffscreen = true;
				skinnedMeshRenderer.updateWhenOffscreen = updateWhenOffscreen;
				skinnedMeshRenderer.sharedMesh = m;
			}
			_ConfigureSceneHierarch(mom, instantiatedPrefabRoot, meshRenderer, meshFilter, skinnedMeshRenderer, m, objsToBeAdded);
			if (mom.targetRenderer != null)
			{
				Material[] array = new Material[mom.targetRenderer.sharedMaterials.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = mom.targetRenderer.sharedMaterials[i];
				}
				if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
				{
					skinnedMeshRenderer.sharedMaterial = null;
					skinnedMeshRenderer.sharedMaterials = array;
				}
				else
				{
					meshRenderer.sharedMaterial = null;
					meshRenderer.sharedMaterials = array;
				}
			}
		}

		private static void _ConfigureSceneHierarch(MB3_MeshCombinerSingle mom, GameObject root, MeshRenderer mr, MeshFilter mf, SkinnedMeshRenderer smr, Mesh m, GameObject[] objsToBeAdded = null)
		{
			GameObject gameObject;
			if (mom.renderType == MB_RenderType.skinnedMeshRenderer)
			{
				gameObject = smr.gameObject;
				smr.lightmapIndex = mom.GetLightmapIndex();
			}
			else
			{
				gameObject = mr.gameObject;
				mf.sharedMesh = m;
				mr.lightmapIndex = mom.GetLightmapIndex();
			}
			if (mom.lightmapOption == MB2_LightmapOptions.preserve_current_lightmapping || mom.lightmapOption == MB2_LightmapOptions.generate_new_UV2_layout)
			{
				gameObject.isStatic = true;
			}
			if (objsToBeAdded == null || objsToBeAdded.Length == 0 || !(objsToBeAdded[0] != null))
			{
				return;
			}
			bool flag = true;
			bool flag2 = true;
			string tag = objsToBeAdded[0].tag;
			int layer = objsToBeAdded[0].layer;
			for (int i = 0; i < objsToBeAdded.Length; i++)
			{
				if (objsToBeAdded[i] != null)
				{
					if (!objsToBeAdded[i].tag.Equals(tag))
					{
						flag = false;
					}
					if (objsToBeAdded[i].layer != layer)
					{
						flag2 = false;
					}
				}
			}
			if (flag)
			{
				root.tag = tag;
				gameObject.tag = tag;
			}
			if (flag2)
			{
				root.layer = layer;
				gameObject.layer = layer;
			}
		}

		public void BuildSceneMeshObject(GameObject[] gos = null, bool createNewChild = false)
		{
			if (_resultSceneObject == null)
			{
				_resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			_targetRenderer = BuildSceneHierarchPreBake(this, _resultSceneObject, GetMesh(), createNewChild, gos);
		}

		private bool IsMirrored(Matrix4x4 tm)
		{
			Vector3 lhs = tm.GetRow(0);
			Vector3 rhs = tm.GetRow(1);
			Vector3 rhs2 = tm.GetRow(2);
			lhs.Normalize();
			rhs.Normalize();
			rhs2.Normalize();
			if (!(Vector3.Dot(Vector3.Cross(lhs, rhs), rhs2) >= 0f))
			{
				return true;
			}
			return false;
		}

		public override void CheckIntegrity()
		{
			if (!MB_Utility.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			if (renderType == MB_RenderType.skinnedMeshRenderer)
			{
				for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[i];
					HashSet<int> hashSet = new HashSet<int>();
					HashSet<int> hashSet2 = new HashSet<int>();
					for (int j = mB_DynamicGameObject.vertIdx; j < mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts; j++)
					{
						hashSet.Add(boneWeights[j].boneIndex0);
						hashSet.Add(boneWeights[j].boneIndex1);
						hashSet.Add(boneWeights[j].boneIndex2);
						hashSet.Add(boneWeights[j].boneIndex3);
					}
					for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
					{
						hashSet2.Add(mB_DynamicGameObject.indexesOfBonesUsed[k]);
					}
					hashSet2.ExceptWith(hashSet);
					if (hashSet2.Count > 0)
					{
						UnityEngine.Debug.LogError("The bone indexes were not the same. " + hashSet.Count + " " + hashSet2.Count);
					}
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						if (l < 0 || l > bones.Length)
						{
							UnityEngine.Debug.LogError("Bone index was out of bounds.");
						}
					}
					if (renderType == MB_RenderType.skinnedMeshRenderer && mB_DynamicGameObject.indexesOfBonesUsed.Length < 1)
					{
						UnityEngine.Debug.Log("DGO had no bones");
					}
				}
			}
			if (doBlendShapes && renderType != MB_RenderType.skinnedMeshRenderer)
			{
				UnityEngine.Debug.LogError("Blend shapes can only be used with skinned meshes.");
			}
		}

		private void _ZeroArray(Vector3[] arr, int idx, int length)
		{
			int num = idx + length;
			for (int i = idx; i < num; i++)
			{
				arr[i] = Vector3.zero;
			}
		}

		private List<MB_DynamicGameObject>[] _buildBoneIdx2dgoMap()
		{
			List<MB_DynamicGameObject>[] array = new List<MB_DynamicGameObject>[bones.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new List<MB_DynamicGameObject>();
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[j];
				for (int k = 0; k < mB_DynamicGameObject.indexesOfBonesUsed.Length; k++)
				{
					array[mB_DynamicGameObject.indexesOfBonesUsed[k]].Add(mB_DynamicGameObject);
				}
			}
			return array;
		}

		private void _CollectBonesToAddForDGO(MB_DynamicGameObject dgo, Dictionary<Transform, int> bone2idx, HashSet<int> boneIdxsToDelete, HashSet<BoneAndBindpose> bonesToAdd, Renderer r, MeshChannelsCache meshChannelCache)
		{
			Matrix4x4[] array = (dgo._tmpCachedBindposes = meshChannelCache.GetBindposes(r));
			BoneWeight[] array2 = (dgo._tmpCachedBoneWeights = meshChannelCache.GetBoneWeights(r, dgo.numVerts));
			Transform[] array3 = (dgo._tmpCachedBones = _getBones(r));
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < array2.Length; i++)
			{
				hashSet.Add(array2[i].boneIndex0);
				hashSet.Add(array2[i].boneIndex1);
				hashSet.Add(array2[i].boneIndex2);
				hashSet.Add(array2[i].boneIndex3);
			}
			int[] array4 = new int[hashSet.Count];
			hashSet.CopyTo(array4);
			for (int j = 0; j < array4.Length; j++)
			{
				bool flag = false;
				int num = array4[j];
				if (bone2idx.TryGetValue(array3[num], out var value) && array3[num] == bones[value] && !boneIdxsToDelete.Contains(value) && array[num] == bindPoses[value])
				{
					flag = true;
				}
				if (!flag)
				{
					BoneAndBindpose item = new BoneAndBindpose(array3[num], array[num]);
					if (!bonesToAdd.Contains(item))
					{
						bonesToAdd.Add(item);
					}
				}
			}
			dgo._tmpIndexesOfSourceBonesUsed = array4;
		}

		private void _CopyBonesWeAreKeepingToNewBonesArrayAndAdjustBWIndexes(HashSet<int> boneIdxsToDeleteHS, HashSet<BoneAndBindpose> bonesToAdd, Transform[] nbones, Matrix4x4[] nbindPoses, BoneWeight[] nboneWeights, int totalDeleteVerts)
		{
			if (boneIdxsToDeleteHS.Count > 0)
			{
				int[] array = new int[boneIdxsToDeleteHS.Count];
				boneIdxsToDeleteHS.CopyTo(array);
				Array.Sort(array);
				int[] array2 = new int[bones.Length];
				int num = 0;
				int num2 = 0;
				for (int i = 0; i < bones.Length; i++)
				{
					if (num2 < array.Length && array[num2] == i)
					{
						num2++;
						array2[i] = -1;
						continue;
					}
					array2[i] = num;
					nbones[num] = bones[i];
					nbindPoses[num] = bindPoses[i];
					num++;
				}
				int num3 = boneWeights.Length - totalDeleteVerts;
				for (int j = 0; j < num3; j++)
				{
					nboneWeights[j].boneIndex0 = array2[nboneWeights[j].boneIndex0];
					nboneWeights[j].boneIndex1 = array2[nboneWeights[j].boneIndex1];
					nboneWeights[j].boneIndex2 = array2[nboneWeights[j].boneIndex2];
					nboneWeights[j].boneIndex3 = array2[nboneWeights[j].boneIndex3];
				}
				for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
				{
					MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
					for (int l = 0; l < mB_DynamicGameObject.indexesOfBonesUsed.Length; l++)
					{
						mB_DynamicGameObject.indexesOfBonesUsed[l] = array2[mB_DynamicGameObject.indexesOfBonesUsed[l]];
					}
				}
			}
			else
			{
				Array.Copy(bones, nbones, bones.Length);
				Array.Copy(bindPoses, nbindPoses, bindPoses.Length);
			}
		}

		private void _AddBonesToNewBonesArrayAndAdjustBWIndexes(MB_DynamicGameObject dgo, Renderer r, int vertsIdx, Transform[] nbones, BoneWeight[] nboneWeights, MeshChannelsCache meshChannelCache)
		{
			Transform[] tmpCachedBones = dgo._tmpCachedBones;
			Matrix4x4[] tmpCachedBindposes = dgo._tmpCachedBindposes;
			BoneWeight[] tmpCachedBoneWeights = dgo._tmpCachedBoneWeights;
			int[] array = new int[tmpCachedBones.Length];
			for (int i = 0; i < dgo._tmpIndexesOfSourceBonesUsed.Length; i++)
			{
				int num = dgo._tmpIndexesOfSourceBonesUsed[i];
				for (int j = 0; j < nbones.Length; j++)
				{
					if (tmpCachedBones[num] == nbones[j] && tmpCachedBindposes[num] == bindPoses[j])
					{
						array[num] = j;
						break;
					}
				}
			}
			for (int k = 0; k < tmpCachedBoneWeights.Length; k++)
			{
				int num2 = vertsIdx + k;
				nboneWeights[num2].boneIndex0 = array[tmpCachedBoneWeights[k].boneIndex0];
				nboneWeights[num2].boneIndex1 = array[tmpCachedBoneWeights[k].boneIndex1];
				nboneWeights[num2].boneIndex2 = array[tmpCachedBoneWeights[k].boneIndex2];
				nboneWeights[num2].boneIndex3 = array[tmpCachedBoneWeights[k].boneIndex3];
				nboneWeights[num2].weight0 = tmpCachedBoneWeights[k].weight0;
				nboneWeights[num2].weight1 = tmpCachedBoneWeights[k].weight1;
				nboneWeights[num2].weight2 = tmpCachedBoneWeights[k].weight2;
				nboneWeights[num2].weight3 = tmpCachedBoneWeights[k].weight3;
			}
			for (int l = 0; l < dgo._tmpIndexesOfSourceBonesUsed.Length; l++)
			{
				dgo._tmpIndexesOfSourceBonesUsed[l] = array[dgo._tmpIndexesOfSourceBonesUsed[l]];
			}
			dgo.indexesOfBonesUsed = dgo._tmpIndexesOfSourceBonesUsed;
			dgo._tmpIndexesOfSourceBonesUsed = null;
			dgo._tmpCachedBones = null;
			dgo._tmpCachedBindposes = null;
			dgo._tmpCachedBoneWeights = null;
		}

		private void _copyUV2unchangedToSeparateRects()
		{
			int padding = 16;
			List<Vector2> list = new List<Vector2>();
			float num = 1E+11f;
			float num2 = 0f;
			for (int i = 0; i < mbDynamicObjectsInCombinedMesh.Count; i++)
			{
				float magnitude = mbDynamicObjectsInCombinedMesh[i].meshSize.magnitude;
				if (magnitude > num2)
				{
					num2 = magnitude;
				}
				if (magnitude < num)
				{
					num = magnitude;
				}
			}
			float num3 = 1000f;
			float num4 = 10f;
			float num5 = 0f;
			float num6 = 1f;
			if (num2 - num > num3 - num4)
			{
				num6 = (num3 - num4) / (num2 - num);
				num5 = num4 - num * num6;
			}
			else
			{
				num6 = num3 / num2;
			}
			for (int j = 0; j < mbDynamicObjectsInCombinedMesh.Count; j++)
			{
				float magnitude2 = mbDynamicObjectsInCombinedMesh[j].meshSize.magnitude;
				magnitude2 = magnitude2 * num6 + num5;
				Vector2 item = Vector2.one * magnitude2;
				list.Add(item);
			}
			AtlasPackingResult[] rects = new MB2_TexturePackerRegular
			{
				atlasMustBePowerOfTwo = false
			}.GetRects(list, 8192, 8192, padding);
			for (int k = 0; k < mbDynamicObjectsInCombinedMesh.Count; k++)
			{
				MB_DynamicGameObject mB_DynamicGameObject = mbDynamicObjectsInCombinedMesh[k];
				float x;
				float num7 = (x = uv2s[mB_DynamicGameObject.vertIdx].x);
				float y;
				float num8 = (y = uv2s[mB_DynamicGameObject.vertIdx].y);
				int num9 = mB_DynamicGameObject.vertIdx + mB_DynamicGameObject.numVerts;
				for (int l = mB_DynamicGameObject.vertIdx; l < num9; l++)
				{
					if (uv2s[l].x < num7)
					{
						num7 = uv2s[l].x;
					}
					if (uv2s[l].x > x)
					{
						x = uv2s[l].x;
					}
					if (uv2s[l].y < num8)
					{
						num8 = uv2s[l].y;
					}
					if (uv2s[l].y > y)
					{
						y = uv2s[l].y;
					}
				}
				Rect rect = rects[0].rects[k];
				for (int m = mB_DynamicGameObject.vertIdx; m < num9; m++)
				{
					float num10 = x - num7;
					float num11 = y - num8;
					if (num10 == 0f)
					{
						num10 = 1f;
					}
					if (num11 == 0f)
					{
						num11 = 1f;
					}
					uv2s[m].x = (uv2s[m].x - num7) / num10 * rect.width + rect.x;
					uv2s[m].y = (uv2s[m].y - num8) / num11 * rect.height + rect.y;
				}
			}
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			List<Material> list = new List<Material>();
			if (_targetRenderer != null)
			{
				list.AddRange(_targetRenderer.sharedMaterials);
			}
			return list;
		}
	}
	[Serializable]
	public class MB3_MultiMeshCombiner : MB3_MeshCombiner
	{
		[Serializable]
		public class CombinedMesh
		{
			public MB3_MeshCombinerSingle combinedMesh;

			public int extraSpace = -1;

			public int numVertsInListToDelete;

			public int numVertsInListToAdd;

			public List<GameObject> gosToAdd;

			public List<int> gosToDelete;

			public List<GameObject> gosToUpdate;

			public bool isDirty;

			public CombinedMesh(int maxNumVertsInMesh, GameObject resultSceneObject, MB2_LogLevel ll)
			{
				combinedMesh = new MB3_MeshCombinerSingle();
				combinedMesh.resultSceneObject = resultSceneObject;
				combinedMesh.LOG_LEVEL = ll;
				extraSpace = maxNumVertsInMesh;
				numVertsInListToDelete = 0;
				numVertsInListToAdd = 0;
				gosToAdd = new List<GameObject>();
				gosToDelete = new List<int>();
				gosToUpdate = new List<GameObject>();
			}

			public bool isEmpty()
			{
				List<GameObject> list = new List<GameObject>();
				list.AddRange(combinedMesh.GetObjectsInCombined());
				for (int i = 0; i < gosToDelete.Count; i++)
				{
					for (int j = 0; j < list.Count; j++)
					{
						if (list[j].GetInstanceID() == gosToDelete[i])
						{
							list.RemoveAt(j);
							break;
						}
					}
				}
				if (list.Count == 0)
				{
					return true;
				}
				return false;
			}
		}

		private static GameObject[] empty = new GameObject[0];

		private static int[] emptyIDs = new int[0];

		public Dictionary<int, CombinedMesh> obj2MeshCombinerMap = new Dictionary<int, CombinedMesh>();

		[SerializeField]
		public List<CombinedMesh> meshCombiners = new List<CombinedMesh>();

		[SerializeField]
		private int _maxVertsInMesh = 65535;

		public override MB2_LogLevel LOG_LEVEL
		{
			get
			{
				return _LOG_LEVEL;
			}
			set
			{
				_LOG_LEVEL = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.LOG_LEVEL = value;
				}
			}
		}

		public override MB2_ValidationLevel validationLevel
		{
			get
			{
				return _validationLevel;
			}
			set
			{
				_validationLevel = value;
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.validationLevel = _validationLevel;
				}
			}
		}

		public int maxVertsInMesh
		{
			get
			{
				return _maxVertsInMesh;
			}
			set
			{
				if (obj2MeshCombinerMap.Count <= 0)
				{
					if (value < 3)
					{
						UnityEngine.Debug.LogError("Max verts in mesh must be greater than three.");
					}
					else if (value > MBVersion.MaxMeshVertexCount())
					{
						UnityEngine.Debug.LogError("Meshes in unity cannot have more than " + MBVersion.MaxMeshVertexCount() + " vertices.");
					}
					else
					{
						_maxVertsInMesh = value;
					}
				}
			}
		}

		public override int GetNumObjectsInCombined()
		{
			return obj2MeshCombinerMap.Count;
		}

		public override int GetNumVerticesFor(GameObject go)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(go.GetInstanceID(), out value))
			{
				return value.combinedMesh.GetNumVerticesFor(go);
			}
			return -1;
		}

		public override int GetNumVerticesFor(int gameObjectID)
		{
			CombinedMesh value = null;
			if (obj2MeshCombinerMap.TryGetValue(gameObjectID, out value))
			{
				return value.combinedMesh.GetNumVerticesFor(gameObjectID);
			}
			return -1;
		}

		public override List<GameObject> GetObjectsInCombined()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				list.AddRange(meshCombiners[i].combinedMesh.GetObjectsInCombined());
			}
			return list;
		}

		public override int GetLightmapIndex()
		{
			if (meshCombiners.Count > 0)
			{
				return meshCombiners[0].combinedMesh.GetLightmapIndex();
			}
			return -1;
		}

		public override bool CombinedMeshContains(GameObject go)
		{
			return obj2MeshCombinerMap.ContainsKey(go.GetInstanceID());
		}

		private bool _validateTextureBakeResults()
		{
			if (_textureBakeResults == null)
			{
				UnityEngine.Debug.LogError("Texture Bake Results is null. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.materialsAndUVRects == null || _textureBakeResults.materialsAndUVRects.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no materials in material to sourceUVRect map. Try baking materials. Can't combine meshes.");
				return false;
			}
			if (_textureBakeResults.resultMaterials == null || _textureBakeResults.resultMaterials.Length == 0)
			{
				UnityEngine.Debug.LogError("Texture Bake Results has no result materials. Try baking materials. Can't combine meshes.");
				return false;
			}
			return true;
		}

		public override void Apply(GenerateUV2Delegate uv2GenerationMethod)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void Apply(bool triangles, bool vertices, bool normals, bool tangents, bool uvs, bool uv2, bool uv3, bool uv4, bool colors, bool bones = false, bool blendShapesFlag = false, GenerateUV2Delegate uv2GenerationMethod = null)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].isDirty)
				{
					meshCombiners[i].combinedMesh.Apply(triangles, vertices, normals, tangents, uvs, uv2, uv3, uv4, colors, bones, blendShapesFlag, uv2GenerationMethod);
					meshCombiners[i].isDirty = false;
				}
			}
		}

		public override void UpdateSkinnedMeshApproximateBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBounds();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBones()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBones();
			}
		}

		public override void UpdateSkinnedMeshApproximateBoundsFromBounds()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.UpdateSkinnedMeshApproximateBoundsFromBounds();
			}
		}

		public override void UpdateGameObjects(GameObject[] gos, bool recalcBounds = true, bool updateVertices = true, bool updateNormals = true, bool updateTangents = true, bool updateUV = false, bool updateUV2 = false, bool updateUV3 = false, bool updateUV4 = false, bool updateColors = false, bool updateSkinningInfo = false)
		{
			if (gos == null)
			{
				UnityEngine.Debug.LogError("list of game objects cannot be null");
				return;
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].gosToUpdate.Clear();
			}
			for (int j = 0; j < gos.Length; j++)
			{
				CombinedMesh value = null;
				obj2MeshCombinerMap.TryGetValue(gos[j].GetInstanceID(), out value);
				if (value != null)
				{
					value.gosToUpdate.Add(gos[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning(string.Concat("Object ", gos[j], " is not in the combined mesh."));
				}
			}
			for (int k = 0; k < meshCombiners.Count; k++)
			{
				if (meshCombiners[k].gosToUpdate.Count > 0)
				{
					meshCombiners[k].isDirty = true;
					GameObject[] gos2 = meshCombiners[k].gosToUpdate.ToArray();
					meshCombiners[k].combinedMesh.UpdateGameObjects(gos2, recalcBounds, updateVertices, updateNormals, updateTangents, updateUV, updateUV2, updateUV3, updateUV4, updateColors, updateSkinningInfo);
				}
			}
		}

		public override bool AddDeleteGameObjects(GameObject[] gos, GameObject[] deleteGOs, bool disableRendererInSource = true)
		{
			int[] array = null;
			if (deleteGOs != null)
			{
				array = new int[deleteGOs.Length];
				for (int i = 0; i < deleteGOs.Length; i++)
				{
					if (deleteGOs[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to delete is 'Null'");
					}
					else
					{
						array[i] = deleteGOs[i].GetInstanceID();
					}
				}
			}
			return AddDeleteGameObjectsByID(gos, array, disableRendererInSource);
		}

		public override bool AddDeleteGameObjectsByID(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource = true)
		{
			if (_usingTemporaryTextureBakeResult && gos != null && gos.Length != 0)
			{
				MB_Utility.Destroy(_textureBakeResults);
				_textureBakeResults = null;
				_usingTemporaryTextureBakeResult = false;
			}
			if (_textureBakeResults == null && gos != null && gos.Length != 0 && gos[0] != null && !_CreateTemporaryTextrueBakeResult(gos, GetMaterialsOnTargetRenderer()))
			{
				return false;
			}
			if (!_validate(gos, deleteGOinstanceIDs))
			{
				return false;
			}
			_distributeAmongBakers(gos, deleteGOinstanceIDs);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.AddDeleteGameObjects numCombinedMeshes: ", meshCombiners.Count, " added:", gos, " deleted:", deleteGOinstanceIDs, " disableRendererInSource:", disableRendererInSource.ToString(), " maxVertsPerCombined:", _maxVertsInMesh));
			}
			return _bakeStep1(gos, deleteGOinstanceIDs, disableRendererInSource);
		}

		private bool _validate(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (_validationLevel == MB2_ValidationLevel.none)
			{
				return true;
			}
			if (_maxVertsInMesh < 3)
			{
				UnityEngine.Debug.LogError("Invalid value for maxVertsInMesh=" + _maxVertsInMesh);
			}
			_validateTextureBakeResults();
			if (gos != null)
			{
				for (int i = 0; i < gos.Length; i++)
				{
					if (gos[i] == null)
					{
						UnityEngine.Debug.LogError("The " + i + "th object on the list of objects to combine is 'None'. Use Command-Delete on Mac OS X; Delete or Shift-Delete on Windows to remove this one element.");
						return false;
					}
					if (_validationLevel < MB2_ValidationLevel.robust)
					{
						continue;
					}
					for (int j = i + 1; j < gos.Length; j++)
					{
						if (gos[i] == gos[j])
						{
							UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], "appears twice in list of game objects to add"));
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(gos[i].GetInstanceID()))
					{
						continue;
					}
					bool flag = false;
					if (deleteGOinstanceIDs != null)
					{
						for (int k = 0; k < deleteGOinstanceIDs.Length; k++)
						{
							if (deleteGOinstanceIDs[k] == gos[i].GetInstanceID())
							{
								flag = true;
							}
						}
					}
					if (!flag)
					{
						UnityEngine.Debug.LogError(string.Concat("GameObject ", gos[i], " is already in the combined mesh ", gos[i].GetInstanceID()));
						return false;
					}
				}
			}
			if (deleteGOinstanceIDs != null && _validationLevel >= MB2_ValidationLevel.robust)
			{
				for (int l = 0; l < deleteGOinstanceIDs.Length; l++)
				{
					for (int m = l + 1; m < deleteGOinstanceIDs.Length; m++)
					{
						if (deleteGOinstanceIDs[l] == deleteGOinstanceIDs[m])
						{
							UnityEngine.Debug.LogError("GameObject " + deleteGOinstanceIDs[l] + "appears twice in list of game objects to delete");
							return false;
						}
					}
					if (!obj2MeshCombinerMap.ContainsKey(deleteGOinstanceIDs[l]))
					{
						UnityEngine.Debug.LogWarning("GameObject with instance ID " + deleteGOinstanceIDs[l] + " on the list of objects to delete is not in the combined mesh.");
					}
				}
			}
			return true;
		}

		private void _distributeAmongBakers(GameObject[] gos, int[] deleteGOinstanceIDs)
		{
			if (gos == null)
			{
				gos = empty;
			}
			if (deleteGOinstanceIDs == null)
			{
				deleteGOinstanceIDs = emptyIDs;
			}
			if (resultSceneObject == null)
			{
				resultSceneObject = new GameObject("CombinedMesh-" + base.name);
			}
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].extraSpace = _maxVertsInMesh - meshCombiners[i].combinedMesh.GetMesh().vertexCount;
			}
			for (int j = 0; j < deleteGOinstanceIDs.Length; j++)
			{
				CombinedMesh value = null;
				if (obj2MeshCombinerMap.TryGetValue(deleteGOinstanceIDs[j], out value))
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Removing " + deleteGOinstanceIDs[j] + " from meshCombiner " + meshCombiners.IndexOf(value));
					}
					value.numVertsInListToDelete += value.combinedMesh.GetNumVerticesFor(deleteGOinstanceIDs[j]);
					value.gosToDelete.Add(deleteGOinstanceIDs[j]);
				}
				else
				{
					UnityEngine.Debug.LogWarning("Object " + deleteGOinstanceIDs[j] + " in the list of objects to delete is not in the combined mesh.");
				}
			}
			for (int k = 0; k < gos.Length; k++)
			{
				GameObject gameObject = gos[k];
				int vertexCount = MB_Utility.GetMesh(gameObject).vertexCount;
				CombinedMesh combinedMesh = null;
				for (int l = 0; l < meshCombiners.Count; l++)
				{
					if (meshCombiners[l].extraSpace + meshCombiners[l].numVertsInListToDelete - meshCombiners[l].numVertsInListToAdd > vertexCount)
					{
						combinedMesh = meshCombiners[l];
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							MB2_Log.LogDebug(string.Concat("MB2_MultiMeshCombiner.Added ", gos[k], " to combinedMesh ", l), LOG_LEVEL);
						}
						break;
					}
				}
				if (combinedMesh == null)
				{
					combinedMesh = new CombinedMesh(maxVertsInMesh, _resultSceneObject, _LOG_LEVEL);
					_setMBValues(combinedMesh.combinedMesh);
					meshCombiners.Add(combinedMesh);
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("MB2_MultiMeshCombiner.Created new combinedMesh");
					}
				}
				combinedMesh.gosToAdd.Add(gameObject);
				combinedMesh.numVertsInListToAdd += vertexCount;
			}
		}

		private bool _bakeStep1(GameObject[] gos, int[] deleteGOinstanceIDs, bool disableRendererInSource)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				CombinedMesh combinedMesh = meshCombiners[i];
				if (combinedMesh.combinedMesh.targetRenderer == null)
				{
					combinedMesh.combinedMesh.resultSceneObject = _resultSceneObject;
					combinedMesh.combinedMesh.BuildSceneMeshObject(gos, createNewChild: true);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("BuildSO combiner {0} goID {1} targetRenID {2} meshID {3}", i, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				else if (combinedMesh.combinedMesh.targetRenderer.transform.parent != resultSceneObject.transform)
				{
					UnityEngine.Debug.LogError("targetRender objects must be children of resultSceneObject");
					return false;
				}
				if (combinedMesh.gosToAdd.Count > 0 || combinedMesh.gosToDelete.Count > 0)
				{
					combinedMesh.combinedMesh.AddDeleteGameObjectsByID(combinedMesh.gosToAdd.ToArray(), combinedMesh.gosToDelete.ToArray(), disableRendererInSource);
					if (_LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Baked combiner {0} obsAdded {1} objsRemoved {2} goID {3} targetRenID {4} meshID {5}", i, combinedMesh.gosToAdd.Count, combinedMesh.gosToDelete.Count, combinedMesh.combinedMesh.targetRenderer.gameObject.GetInstanceID(), combinedMesh.combinedMesh.targetRenderer.GetInstanceID(), combinedMesh.combinedMesh.GetMesh().GetInstanceID());
					}
				}
				Renderer renderer = combinedMesh.combinedMesh.targetRenderer;
				Mesh mesh = combinedMesh.combinedMesh.GetMesh();
				if (renderer is MeshRenderer)
				{
					renderer.gameObject.GetComponent<MeshFilter>().sharedMesh = mesh;
				}
				else
				{
					((SkinnedMeshRenderer)renderer).sharedMesh = mesh;
				}
			}
			for (int j = 0; j < meshCombiners.Count; j++)
			{
				CombinedMesh combinedMesh2 = meshCombiners[j];
				for (int k = 0; k < combinedMesh2.gosToDelete.Count; k++)
				{
					obj2MeshCombinerMap.Remove(combinedMesh2.gosToDelete[k]);
				}
			}
			for (int l = 0; l < meshCombiners.Count; l++)
			{
				CombinedMesh combinedMesh3 = meshCombiners[l];
				for (int m = 0; m < combinedMesh3.gosToAdd.Count; m++)
				{
					obj2MeshCombinerMap.Add(combinedMesh3.gosToAdd[m].GetInstanceID(), combinedMesh3);
				}
				if (combinedMesh3.gosToAdd.Count > 0 || combinedMesh3.gosToDelete.Count > 0)
				{
					combinedMesh3.gosToDelete.Clear();
					combinedMesh3.gosToAdd.Clear();
					combinedMesh3.numVertsInListToDelete = 0;
					combinedMesh3.numVertsInListToAdd = 0;
					combinedMesh3.isDirty = true;
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				string text = "Meshes in combined:";
				for (int n = 0; n < meshCombiners.Count; n++)
				{
					text = text + " mesh" + n + "(" + meshCombiners[n].combinedMesh.GetObjectsInCombined().Count + ")\n";
				}
				text = text + "children in result: " + resultSceneObject.transform.childCount;
				MB2_Log.LogDebug(text, LOG_LEVEL);
			}
			if (meshCombiners.Count > 0)
			{
				return true;
			}
			return false;
		}

		public override Dictionary<MBBlendShapeKey, MBBlendShapeValue> BuildSourceBlendShapeToCombinedIndexMap()
		{
			Dictionary<MBBlendShapeKey, MBBlendShapeValue> dictionary = new Dictionary<MBBlendShapeKey, MBBlendShapeValue>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				for (int j = 0; j < meshCombiners[i].combinedMesh.blendShapes.Length; j++)
				{
					MB3_MeshCombinerSingle.MBBlendShape mBBlendShape = meshCombiners[i].combinedMesh.blendShapes[j];
					MBBlendShapeValue mBBlendShapeValue = new MBBlendShapeValue();
					mBBlendShapeValue.combinedMeshGameObject = meshCombiners[i].combinedMesh.targetRenderer.gameObject;
					mBBlendShapeValue.blendShapeIndex = j;
					dictionary.Add(new MBBlendShapeKey(mBBlendShape.gameObjectID, mBBlendShape.indexInSource), mBBlendShapeValue);
				}
			}
			return dictionary;
		}

		public override void ClearBuffers()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				meshCombiners[i].combinedMesh.ClearBuffers();
			}
			obj2MeshCombinerMap.Clear();
		}

		public override void ClearMesh()
		{
			DestroyMesh();
		}

		public override void DestroyMesh()
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					MB_Utility.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		public override void DestroyMeshEditor(MB2_EditorMethodsInterface editorMethods)
		{
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				if (meshCombiners[i].combinedMesh.targetRenderer != null)
				{
					editorMethods.Destroy(meshCombiners[i].combinedMesh.targetRenderer.gameObject);
				}
				meshCombiners[i].combinedMesh.ClearMesh();
			}
			obj2MeshCombinerMap.Clear();
			meshCombiners.Clear();
		}

		private void _setMBValues(MB3_MeshCombinerSingle targ)
		{
			targ.validationLevel = _validationLevel;
			targ.renderType = renderType;
			targ.outputOption = MB2_OutputOptions.bakeIntoSceneObject;
			targ.lightmapOption = lightmapOption;
			targ.textureBakeResults = textureBakeResults;
			targ.doNorm = doNorm;
			targ.doTan = doTan;
			targ.doCol = doCol;
			targ.doUV = doUV;
			targ.doUV3 = doUV3;
			targ.doUV4 = doUV4;
			targ.doBlendShapes = doBlendShapes;
			targ.optimizeAfterBake = base.optimizeAfterBake;
			targ.recenterVertsToBoundsCenter = recenterVertsToBoundsCenter;
			targ.uv2UnwrappingParamsHardAngle = uv2UnwrappingParamsHardAngle;
			targ.uv2UnwrappingParamsPackMargin = uv2UnwrappingParamsPackMargin;
		}

		public override List<Material> GetMaterialsOnTargetRenderer()
		{
			HashSet<Material> hashSet = new HashSet<Material>();
			for (int i = 0; i < meshCombiners.Count; i++)
			{
				hashSet.UnionWith(meshCombiners[i].combinedMesh.GetMaterialsOnTargetRenderer());
			}
			return new List<Material>(hashSet);
		}

		public override void CheckIntegrity()
		{
			if (MB_Utility.DO_INTEGRITY_CHECKS)
			{
				for (int i = 0; i < meshCombiners.Count; i++)
				{
					meshCombiners[i].combinedMesh.CheckIntegrity();
				}
			}
		}
	}
	public class PriorityQueue<TPriority, TValue> : ICollection<KeyValuePair<TPriority, TValue>>, IEnumerable<KeyValuePair<TPriority, TValue>>, IEnumerable
	{
		public List<KeyValuePair<TPriority, TValue>> _baseHeap;

		private IComparer<TPriority> _comparer;

		public bool IsEmpty => _baseHeap.Count == 0;

		public int Count => _baseHeap.Count;

		public bool IsReadOnly => false;

		public PriorityQueue()
			: this((IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity)
			: this(capacity, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(int capacity, IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(capacity);
			_comparer = comparer;
		}

		public PriorityQueue(IComparer<TPriority> comparer)
		{
			if (comparer == null)
			{
				throw new ArgumentNullException();
			}
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>();
			_comparer = comparer;
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data)
			: this(data, (IComparer<TPriority>)Comparer<TPriority>.Default)
		{
		}

		public PriorityQueue(IEnumerable<KeyValuePair<TPriority, TValue>> data, IComparer<TPriority> comparer)
		{
			if (data == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			_comparer = comparer;
			_baseHeap = new List<KeyValuePair<TPriority, TValue>>(data);
			for (int num = _baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				HeapifyFromBeginningToEnd(num);
			}
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2)
		{
			if (pq1 == null || pq2 == null)
			{
				throw new ArgumentNullException();
			}
			if (pq1._comparer != pq2._comparer)
			{
				throw new InvalidOperationException("Priority queues to be merged must have equal comparers");
			}
			return MergeQueues(pq1, pq2, pq1._comparer);
		}

		public static PriorityQueue<TPriority, TValue> MergeQueues(PriorityQueue<TPriority, TValue> pq1, PriorityQueue<TPriority, TValue> pq2, IComparer<TPriority> comparer)
		{
			if (pq1 == null || pq2 == null || comparer == null)
			{
				throw new ArgumentNullException();
			}
			PriorityQueue<TPriority, TValue> priorityQueue = new PriorityQueue<TPriority, TValue>(pq1.Count + pq2.Count, pq1._comparer);
			priorityQueue._baseHeap.AddRange(pq1._baseHeap);
			priorityQueue._baseHeap.AddRange(pq2._baseHeap);
			for (int num = priorityQueue._baseHeap.Count / 2 - 1; num >= 0; num--)
			{
				priorityQueue.HeapifyFromBeginningToEnd(num);
			}
			return priorityQueue;
		}

		public void Enqueue(TPriority priority, TValue value)
		{
			Insert(priority, value);
		}

		public KeyValuePair<TPriority, TValue> Dequeue()
		{
			if (!IsEmpty)
			{
				KeyValuePair<TPriority, TValue> result = _baseHeap[0];
				DeleteRoot();
				return result;
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue DequeueValue()
		{
			return Dequeue().Value;
		}

		public KeyValuePair<TPriority, TValue> Peek()
		{
			if (!IsEmpty)
			{
				return _baseHeap[0];
			}
			throw new InvalidOperationException("Priority queue is empty");
		}

		public TValue PeekValue()
		{
			return Peek().Value;
		}

		private void ExchangeElements(int pos1, int pos2)
		{
			KeyValuePair<TPriority, TValue> value = _baseHeap[pos1];
			_baseHeap[pos1] = _baseHeap[pos2];
			_baseHeap[pos2] = value;
		}

		private void Insert(TPriority priority, TValue value)
		{
			KeyValuePair<TPriority, TValue> item = new KeyValuePair<TPriority, TValue>(priority, value);
			_baseHeap.Add(item);
			HeapifyFromEndToBeginning(_baseHeap.Count - 1);
		}

		private int HeapifyFromEndToBeginning(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return -1;
			}
			while (pos > 0)
			{
				int num = (pos - 1) / 2;
				if (_comparer.Compare(_baseHeap[num].Key, _baseHeap[pos].Key) <= 0)
				{
					break;
				}
				ExchangeElements(num, pos);
				pos = num;
			}
			return pos;
		}

		private void DeleteRoot()
		{
			if (_baseHeap.Count <= 1)
			{
				_baseHeap.Clear();
				return;
			}
			_baseHeap[0] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			HeapifyFromBeginningToEnd(0);
		}

		private void HeapifyFromBeginningToEnd(int pos)
		{
			if (pos >= _baseHeap.Count)
			{
				return;
			}
			while (true)
			{
				int num = pos;
				int num2 = 2 * pos + 1;
				int num3 = 2 * pos + 2;
				if (num2 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num2].Key) > 0)
				{
					num = num2;
				}
				if (num3 < _baseHeap.Count && _comparer.Compare(_baseHeap[num].Key, _baseHeap[num3].Key) > 0)
				{
					num = num3;
				}
				if (num != pos)
				{
					ExchangeElements(num, pos);
					pos = num;
					continue;
				}
				break;
			}
		}

		public void Add(KeyValuePair<TPriority, TValue> item)
		{
			Enqueue(item.Key, item.Value);
		}

		public void Clear()
		{
			_baseHeap.Clear();
		}

		public bool Contains(KeyValuePair<TPriority, TValue> item)
		{
			return _baseHeap.Contains(item);
		}

		public bool TryFindValue(TPriority item, out TValue foundVersion)
		{
			for (int i = 0; i < _baseHeap.Count; i++)
			{
				if (_comparer.Compare(item, _baseHeap[i].Key) == 0)
				{
					foundVersion = _baseHeap[i].Value;
					return true;
				}
			}
			foundVersion = default(TValue);
			return false;
		}

		public void CopyTo(KeyValuePair<TPriority, TValue>[] array, int arrayIndex)
		{
			_baseHeap.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TPriority, TValue> item)
		{
			int num = _baseHeap.IndexOf(item);
			if (num < 0)
			{
				return false;
			}
			_baseHeap[num] = _baseHeap[_baseHeap.Count - 1];
			_baseHeap.RemoveAt(_baseHeap.Count - 1);
			if (HeapifyFromEndToBeginning(num) == num)
			{
				HeapifyFromBeginningToEnd(num);
			}
			return true;
		}

		public IEnumerator<KeyValuePair<TPriority, TValue>> GetEnumerator()
		{
			return _baseHeap.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public struct DVector2
	{
		private static double epsilon = 1E-05;

		public double x;

		public double y;

		public static DVector2 Subtract(DVector2 a, DVector2 b)
		{
			return new DVector2(a.x - b.x, a.y - b.y);
		}

		public DVector2(double xx, double yy)
		{
			x = xx;
			y = yy;
		}

		public DVector2(DVector2 r)
		{
			x = r.x;
			y = r.y;
		}

		public Vector2 GetVector2()
		{
			return new Vector2((float)x, (float)y);
		}

		public bool IsContainedIn(DRect r)
		{
			if (x >= r.x && y >= r.y && x <= r.x + r.width && y <= r.y + r.height)
			{
				return true;
			}
			return false;
		}

		public bool IsContainedInWithMargin(DRect r)
		{
			if (x >= r.x - epsilon && y >= r.y - epsilon && x <= r.x + r.width + epsilon && y <= r.y + r.height + epsilon)
			{
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			return $"({x},{y})";
		}

		public string ToString(string formatS)
		{
			return $"({x.ToString(formatS)},{y.ToString(formatS)})";
		}

		public static double Distance(DVector2 a, DVector2 b)
		{
			double num = b.x - a.x;
			double num2 = b.y - a.y;
			return Math.Sqrt(num * num + num2 * num2);
		}
	}
	public struct DRect
	{
		public double x;

		public double y;

		public double width;

		public double height;

		public DVector2 minD => new DVector2(x, y);

		public DVector2 maxD => new DVector2(x + width, y + height);

		public Vector2 min => new Vector2((float)x, (float)y);

		public Vector2 max => new Vector2((float)(x + width), (float)(y + height));

		public Vector2 size => new Vector2((float)width, (float)height);

		public DVector2 center => new DVector2(x + width / 2.0, y + height / 2.0);

		public DRect(Rect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(Vector2 o, Vector2 s)
		{
			x = o.x;
			y = o.y;
			width = s.x;
			height = s.y;
		}

		public DRect(DRect r)
		{
			x = r.x;
			y = r.y;
			width = r.width;
			height = r.height;
		}

		public DRect(float xx, float yy, float w, float h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public DRect(double xx, double yy, double w, double h)
		{
			x = xx;
			y = yy;
			width = w;
			height = h;
		}

		public Rect GetRect()
		{
			return new Rect((float)x, (float)y, (float)width, (float)height);
		}

		public override bool Equals(object obj)
		{
			DRect dRect = (DRect)obj;
			if (dRect.x == x && dRect.y == y && dRect.width == width && dRect.height == height)
			{
				return true;
			}
			return false;
		}

		public static bool operator ==(DRect a, DRect b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(DRect a, DRect b)
		{
			return !a.Equals(b);
		}

		public override string ToString()
		{
			return string.Format("(x={0},y={1},w={2},h={3})", x.ToString("F5"), y.ToString("F5"), width.ToString("F5"), height.ToString("F5"));
		}

		public void Expand(float amt)
		{
			x -= amt;
			y -= amt;
			width += amt * 2f;
			height += amt * 2f;
		}

		public bool Encloses(DRect smallToTestIfFits)
		{
			double num = smallToTestIfFits.x;
			double num2 = smallToTestIfFits.y;
			double num3 = smallToTestIfFits.x + smallToTestIfFits.width;
			double num4 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num5 = x;
			double num6 = y;
			double num7 = x + width;
			double num8 = y + height;
			if (num5 <= num && num <= num7 && num5 <= num3 && num3 <= num7 && num6 <= num2 && num2 <= num8 && num6 <= num4)
			{
				return num4 <= num8;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode() ^ width.GetHashCode() ^ height.GetHashCode();
		}
	}
	public class MB3_UVTransformUtility
	{
		public static void Test()
		{
			DRect t = new DRect(0.5, 0.5, 2.0, 2.0);
			DRect t2 = new DRect(0.25, 0.25, 3.0, 3.0);
			DRect r = InverseTransform(ref t);
			DRect r2 = InverseTransform(ref t2);
			DRect r3 = CombineTransforms(ref t, ref r2);
			UnityEngine.Debug.Log(r);
			UnityEngine.Debug.Log(r3);
			UnityEngine.Debug.Log("one mat trans " + TransformPoint(ref t, new Vector2(1f, 1f)));
			UnityEngine.Debug.Log("one inv mat trans " + TransformPoint(ref r, new Vector2(1f, 1f)).ToString("f4"));
			UnityEngine.Debug.Log("zero " + TransformPoint(ref r3, new Vector2(0f, 0f)).ToString("f4"));
			UnityEngine.Debug.Log("one " + TransformPoint(ref r3, new Vector2(1f, 1f)).ToString("f4"));
		}

		public static float TransformX(DRect r, double x)
		{
			return (float)(r.width * x + r.x);
		}

		public static DRect CombineTransforms(ref DRect r1, ref DRect r2)
		{
			return new DRect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static Rect CombineTransforms(ref Rect r1, ref Rect r2)
		{
			return new Rect(r1.x * r2.width + r2.x, r1.y * r2.height + r2.y, r1.width * r2.width, r1.height * r2.height);
		}

		public static DRect InverseTransform(ref DRect t)
		{
			DRect result = default(DRect);
			result.x = (0.0 - t.x) / t.width;
			result.y = (0.0 - t.y) / t.height;
			result.width = 1.0 / t.width;
			result.height = 1.0 / t.height;
			return result;
		}

		public static DRect GetShiftTransformToFitBinA(ref DRect A, ref DRect B)
		{
			DVector2 center = A.center;
			DVector2 center2 = B.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double xx = Convert.ToInt32(dVector.x);
			double yy = Convert.ToInt32(dVector.y);
			return new DRect(xx, yy, 1.0, 1.0);
		}

		public static DRect GetEncapsulatingRectShifted(ref DRect uvRect1, ref DRect willBeIn)
		{
			DVector2 center = uvRect1.center;
			DVector2 center2 = willBeIn.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double num = Convert.ToInt32(dVector.x);
			double num2 = Convert.ToInt32(dVector.y);
			DRect dRect = new DRect(willBeIn);
			dRect.x += num;
			dRect.y += num2;
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num3 = uvRect1.x + uvRect1.width;
			double num4 = uvRect1.y + uvRect1.height;
			double x2 = dRect.x;
			double y2 = dRect.y;
			double num5 = dRect.x + dRect.width;
			double num6 = dRect.y + dRect.height;
			double num7;
			double num8 = (num7 = x);
			double num9;
			double num10 = (num9 = y);
			if (x2 < num8)
			{
				num8 = x2;
			}
			if (x < num8)
			{
				num8 = x;
			}
			if (y2 < num10)
			{
				num10 = y2;
			}
			if (y < num10)
			{
				num10 = y;
			}
			if (num5 > num7)
			{
				num7 = num5;
			}
			if (num3 > num7)
			{
				num7 = num3;
			}
			if (num6 > num9)
			{
				num9 = num6;
			}
			if (num4 > num9)
			{
				num9 = num4;
			}
			return new DRect(num8, num10, num7 - num8, num9 - num10);
		}

		public static DRect GetEncapsulatingRect(ref DRect uvRect1, ref DRect uvRect2)
		{
			double x = uvRect1.x;
			double y = uvRect1.y;
			double num = uvRect1.x + uvRect1.width;
			double num2 = uvRect1.y + uvRect1.height;
			double x2 = uvRect2.x;
			double y2 = uvRect2.y;
			double num3 = uvRect2.x + uvRect2.width;
			double num4 = uvRect2.y + uvRect2.height;
			double num5;
			double num6 = (num5 = x);
			double num7;
			double num8 = (num7 = y);
			if (x2 < num6)
			{
				num6 = x2;
			}
			if (x < num6)
			{
				num6 = x;
			}
			if (y2 < num8)
			{
				num8 = y2;
			}
			if (y < num8)
			{
				num8 = y;
			}
			if (num3 > num5)
			{
				num5 = num3;
			}
			if (num > num5)
			{
				num5 = num;
			}
			if (num4 > num7)
			{
				num7 = num4;
			}
			if (num2 > num7)
			{
				num7 = num2;
			}
			return new DRect(num6, num8, num5 - num6, num7 - num8);
		}

		public static bool RectContainsShifted(ref DRect bucket, ref DRect tryFit)
		{
			DVector2 center = bucket.center;
			DVector2 center2 = tryFit.center;
			DVector2 dVector = DVector2.Subtract(center, center2);
			double num = Convert.ToInt32(dVector.x);
			double num2 = Convert.ToInt32(dVector.y);
			DRect smallToTestIfFits = new DRect(tryFit);
			smallToTestIfFits.x += num;
			smallToTestIfFits.y += num2;
			return bucket.Encloses(smallToTestIfFits);
		}

		public static bool RectContainsShifted(ref Rect bucket, ref Rect tryFit)
		{
			Vector2 center = bucket.center;
			Vector2 center2 = tryFit.center;
			Vector2 vector = center - center2;
			float num = Convert.ToInt32(vector.x);
			float num2 = Convert.ToInt32(vector.y);
			Rect smallToTestIfFits = new Rect(tryFit);
			smallToTestIfFits.x += num;
			smallToTestIfFits.y += num2;
			return RectContains(ref bucket, ref smallToTestIfFits);
		}

		public static bool LineSegmentContainsShifted(float bucketOffset, float bucketLength, float tryFitOffset, float tryFitLength)
		{
			float num = bucketOffset + bucketLength / 2f;
			float num2 = tryFitOffset + tryFitLength / 2f;
			float num3 = Convert.ToInt32(num - num2);
			tryFitOffset += num3;
			float num4 = tryFitLength + tryFitOffset;
			float num5 = bucketOffset - 0.01f;
			float num6 = bucketOffset + bucketLength + 0.01f;
			if (num5 <= tryFitLength && tryFitLength <= num6 && num5 <= num4)
			{
				return num4 <= num6;
			}
			return false;
		}

		public static bool RectContains(ref DRect bigRect, ref DRect smallToTestIfFits)
		{
			double x = smallToTestIfFits.x;
			double y = smallToTestIfFits.y;
			double num = smallToTestIfFits.x + smallToTestIfFits.width;
			double num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			double num3 = bigRect.x - 0.009999999776482582;
			double num4 = bigRect.y - 0.009999999776482582;
			double num5 = bigRect.x + bigRect.width + 0.009999999776482582;
			double num6 = bigRect.y + bigRect.height + 0.009999999776482582;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static bool RectContains(ref Rect bigRect, ref Rect smallToTestIfFits)
		{
			float x = smallToTestIfFits.x;
			float y = smallToTestIfFits.y;
			float num = smallToTestIfFits.x + smallToTestIfFits.width;
			float num2 = smallToTestIfFits.y + smallToTestIfFits.height;
			float num3 = bigRect.x - 0.01f;
			float num4 = bigRect.y - 0.01f;
			float num5 = bigRect.x + bigRect.width + 0.01f;
			float num6 = bigRect.y + bigRect.height + 0.01f;
			if (num3 <= x && x <= num5 && num3 <= num && num <= num5 && num4 <= y && y <= num6 && num4 <= num2)
			{
				return num2 <= num6;
			}
			return false;
		}

		public static Vector2 TransformPoint(ref DRect r, Vector2 p)
		{
			return new Vector2((float)(r.width * (double)p.x + r.x), (float)(r.height * (double)p.y + r.y));
		}

		public static DVector2 TransformPoint(ref DRect r, DVector2 p)
		{
			return new DVector2(r.width * p.x + r.x, r.height * p.y + r.y);
		}
	}
	[Serializable]
	public struct AtlasPadding
	{
		public int topBottom;

		public int leftRight;

		public AtlasPadding(int p)
		{
			topBottom = p;
			leftRight = p;
		}

		public AtlasPadding(int px, int py)
		{
			topBottom = py;
			leftRight = px;
		}
	}
	[Serializable]
	public class AtlasPackingResult
	{
		public int atlasX;

		public int atlasY;

		public int usedW;

		public int usedH;

		public Rect[] rects;

		public AtlasPadding[] padding;

		public int[] srcImgIdxs;

		public object data;

		public AtlasPackingResult(AtlasPadding[] pds)
		{
			padding = pds;
		}

		public void CalcUsedWidthAndHeight()
		{
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = 0f;
			for (int i = 0; i < rects.Length; i++)
			{
				num3 += (float)padding[i].leftRight * 2f;
				num4 += (float)padding[i].topBottom * 2f;
				num = Mathf.Max(num, rects[i].x + rects[i].width);
				num2 = Mathf.Max(num2, rects[i].y + rects[i].height);
			}
			usedW = Mathf.CeilToInt(num * (float)atlasX + num3);
			usedH = Mathf.CeilToInt(num2 * (float)atlasY + num4);
			if (usedW > atlasX)
			{
				usedW = atlasX;
			}
			if (usedH > atlasY)
			{
				usedH = atlasY;
			}
		}

		public override string ToString()
		{
			return $"numRects: {rects.Length}, atlasX: {atlasX} atlasY: {atlasY} usedW: {usedW} usedH: {usedH}";
		}
	}
	public abstract class MB2_TexturePacker
	{
		internal enum NodeType
		{
			Container,
			maxDim,
			regular
		}

		internal class PixRect
		{
			public int x;

			public int y;

			public int w;

			public int h;

			public PixRect()
			{
			}

			public PixRect(int xx, int yy, int ww, int hh)
			{
				x = xx;
				y = yy;
				w = ww;
				h = hh;
			}

			public override string ToString()
			{
				return $"x={x},y={y},w={w},h={h}";
			}
		}

		internal class Image
		{
			public int imgId;

			public int w;

			public int h;

			public int x;

			public int y;

			public Image(int id, int tw, int th, AtlasPadding padding, int minImageSizeX, int minImageSizeY)
			{
				imgId = id;
				w = Mathf.Max(tw + padding.leftRight * 2, minImageSizeX);
				h = Mathf.Max(th + padding.topBottom * 2, minImageSizeY);
			}

			public Image(Image im)
			{
				imgId = im.imgId;
				w = im.w;
				h = im.h;
				x = im.x;
				y = im.y;
			}
		}

		internal class ImgIDComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.imgId > y.imgId)
				{
					return 1;
				}
				if (x.imgId == y.imgId)
				{
					return 0;
				}
				return -1;
			}
		}

		internal class ImageHeightComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.h > y.h)
				{
					return -1;
				}
				if (x.h == y.h)
				{
					return 0;
				}
				return 1;
			}
		}

		internal class ImageWidthComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				if (x.w > y.w)
				{
					return -1;
				}
				if (x.w == y.w)
				{
					return 0;
				}
				return 1;
			}
		}

		internal class ImageAreaComparer : IComparer<Image>
		{
			public int Compare(Image x, Image y)
			{
				int num = x.w * x.h;
				int num2 = y.w * y.h;
				if (num > num2)
				{
					return -1;
				}
				if (num == num2)
				{
					return 0;
				}
				return 1;
			}
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		public bool atlasMustBePowerOfTwo = true;

		public static int RoundToNearestPositivePowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.RoundToInt(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public static int CeilToNearestPowerOfTwo(int x)
		{
			int num = (int)Mathf.Pow(2f, Mathf.Ceil(Mathf.Log(x) / Mathf.Log(2f)));
			if (num == 0 || num == 1)
			{
				num = 2;
			}
			return num;
		}

		public abstract AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int padding);

		public abstract AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas);

		internal bool ScaleAtlasToFitMaxDim(Vector2 rootWH, List<Image> images, int maxDimensionX, int maxDimensionY, AtlasPadding padding, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, ref int outW, ref int outH, out float padX, out float padY, out int newMinSizeX, out int newMinSizeY)
		{
			newMinSizeX = minImageSizeX;
			newMinSizeY = minImageSizeY;
			bool result = false;
			padX = (float)padding.leftRight / (float)outW;
			if (rootWH.x > (float)maxDimensionX)
			{
				padX = (float)padding.leftRight / (float)maxDimensionX;
				float num = (float)maxDimensionX / rootWH.x;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas width shrinking to " + num);
				}
				for (int i = 0; i < images.Count; i++)
				{
					Image image = images[i];
					if ((float)image.w * num < (float)masterImageSizeX)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeX.");
						}
						result = true;
						newMinSizeX = Mathf.CeilToInt((float)minImageSizeX / num);
					}
					int num2 = (int)((float)(image.x + image.w) * num);
					image.x = (int)(num * (float)image.x);
					image.w = num2 - image.x;
				}
				outW = maxDimensionX;
			}
			padY = (float)padding.topBottom / (float)outH;
			if (rootWH.y > (float)maxDimensionY)
			{
				padY = (float)padding.topBottom / (float)maxDimensionY;
				float num3 = (float)maxDimensionY / rootWH.y;
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Packing exceeded atlas height shrinking to " + num3);
				}
				for (int j = 0; j < images.Count; j++)
				{
					Image image2 = images[j];
					if ((float)image2.h * num3 < (float)masterImageSizeY)
					{
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Small images are being scaled to zero. Will need to redo packing with larger minTexSizeY.");
						}
						result = true;
						newMinSizeY = Mathf.CeilToInt((float)minImageSizeY / num3);
					}
					int num4 = (int)((float)(image2.y + image2.h) * num3);
					image2.y = (int)(num3 * (float)image2.y);
					image2.h = num4 - image2.y;
				}
				outH = maxDimensionY;
			}
			return result;
		}

		public void normalizeRects(AtlasPackingResult rr, AtlasPadding padding)
		{
			for (int i = 0; i < rr.rects.Length; i++)
			{
				rr.rects[i].x = (rr.rects[i].x + (float)padding.leftRight) / (float)rr.atlasX;
				rr.rects[i].y = (rr.rects[i].y + (float)padding.topBottom) / (float)rr.atlasY;
				rr.rects[i].width = (rr.rects[i].width - (float)(padding.leftRight * 2)) / (float)rr.atlasX;
				rr.rects[i].height = (rr.rects[i].height - (float)(padding.topBottom * 2)) / (float)rr.atlasY;
			}
		}
	}
	public class MB2_TexturePackerRegular : MB2_TexturePacker
	{
		private class ProbeResult
		{
			public int w;

			public int h;

			public int outW;

			public int outH;

			public Node root;

			public bool largerOrEqualToMaxDim;

			public float efficiency;

			public float squareness;

			public float totalAtlasArea;

			public int numAtlases;

			public void Set(int ww, int hh, int outw, int outh, Node r, bool fits, float e, float sq)
			{
				w = ww;
				h = hh;
				outW = outw;
				outH = outh;
				root = r;
				largerOrEqualToMaxDim = fits;
				efficiency = e;
				squareness = sq;
			}

			public float GetScore(bool doPowerOfTwoScore)
			{
				float num = (largerOrEqualToMaxDim ? 1f : 0f);
				if (doPowerOfTwoScore)
				{
					return num * 2f + efficiency;
				}
				return squareness + 2f * efficiency + num;
			}

			public void PrintTree()
			{
				printTree(root, "  ");
			}
		}

		internal class Node
		{
			internal NodeType isFullAtlas;

			internal Node[] child = new Node[2];

			internal PixRect r;

			internal Image img;

			private ProbeResult bestRoot;

			internal Node(NodeType rootType)
			{
				isFullAtlas = rootType;
			}

			private bool isLeaf()
			{
				if (child[0] == null || child[1] == null)
				{
					return true;
				}
				return false;
			}

			internal Node Insert(Image im, bool handed)
			{
				int num;
				int num2;
				if (handed)
				{
					num = 0;
					num2 = 1;
				}
				else
				{
					num = 1;
					num2 = 0;
				}
				if (!isLeaf())
				{
					Node node = child[num].Insert(im, handed);
					if (node != null)
					{
						return node;
					}
					return child[num2].Insert(im, handed);
				}
				if (img != null)
				{
					return null;
				}
				if (r.w < im.w || r.h < im.h)
				{
					return null;
				}
				if (r.w == im.w && r.h == im.h)
				{
					img = im;
					return this;
				}
				child[num] = new Node(NodeType.regular);
				child[num2] = new Node(NodeType.regular);
				int num3 = r.w - im.w;
				int num4 = r.h - im.h;
				if (num3 > num4)
				{
					child[num].r = new PixRect(r.x, r.y, im.w, r.h);
					child[num2].r = new PixRect(r.x + im.w, r.y, r.w - im.w, r.h);
				}
				else
				{
					child[num].r = new PixRect(r.x, r.y, r.w, im.h);
					child[num2].r = new PixRect(r.x, r.y + im.h, r.w, r.h - im.h);
				}
				return child[num].Insert(im, handed);
			}
		}

		private ProbeResult bestRoot;

		public int atlasY;

		private static void printTree(Node r, string spc)
		{
			UnityEngine.Debug.Log(spc + "Nd img=" + (r.img != null).ToString() + " r=" + r.r);
			if (r.child[0] != null)
			{
				printTree(r.child[0], spc + "      ");
			}
			if (r.child[1] != null)
			{
				printTree(r.child[1], spc + "      ");
			}
		}

		private static void flattenTree(Node r, List<Image> putHere)
		{
			if (r.img != null)
			{
				r.img.x = r.r.x;
				r.img.y = r.r.y;
				putHere.Add(r.img);
			}
			if (r.child[0] != null)
			{
				flattenTree(r.child[0], putHere);
			}
			if (r.child[1] != null)
			{
				flattenTree(r.child[1], putHere);
			}
		}

		private static void drawGizmosNode(Node r)
		{
			Vector3 size = new Vector3(r.r.w, r.r.h, 0f);
			Vector3 center = new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f);
			Gizmos.color = Color.yellow;
			Gizmos.DrawWireCube(center, size);
			if (r.img != null)
			{
				Gizmos.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
				size = new Vector3(r.img.w, r.img.h, 0f);
				Gizmos.DrawCube(new Vector3((float)r.r.x + size.x / 2f, (float)(-r.r.y) - size.y / 2f, 0f), size);
			}
			if (r.child[0] != null)
			{
				Gizmos.color = Color.red;
				drawGizmosNode(r.child[0]);
			}
			if (r.child[1] != null)
			{
				Gizmos.color = Color.green;
				drawGizmosNode(r.child[1]);
			}
		}

		private static Texture2D createFilledTex(Color c, int w, int h)
		{
			Texture2D texture2D = new Texture2D(w, h);
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					texture2D.SetPixel(i, j, c);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		public void DrawGizmos()
		{
			if (bestRoot != null)
			{
				drawGizmosNode(bestRoot.root);
				Gizmos.color = Color.yellow;
				Vector3 size = new Vector3(bestRoot.outW, -bestRoot.outH, 0f);
				Gizmos.DrawWireCube(new Vector3(size.x / 2f, size.y / 2f, 0f), size);
			}
		}

		private bool ProbeSingleAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDimX, int maxAtlasDimY, ProbeResult pr)
		{
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					return false;
				}
				if (i != imgsToAdd.Length - 1)
				{
					continue;
				}
				int x = 0;
				int y = 0;
				GetExtent(node, ref x, ref y);
				int num = x;
				int num2 = y;
				bool fits;
				float num6;
				float num7;
				if (atlasMustBePowerOfTwo)
				{
					num = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(x), maxAtlasDimX);
					num2 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(y), maxAtlasDimY);
					if (num2 < num / 2)
					{
						num2 = num / 2;
					}
					if (num < num2 / 2)
					{
						num = num2 / 2;
					}
					fits = x <= maxAtlasDimX && y <= maxAtlasDimY;
					float num3 = Mathf.Max(1f, (float)x / (float)maxAtlasDimX);
					float num4 = Mathf.Max(1f, (float)y / (float)maxAtlasDimY);
					float num5 = (float)num * num3 * (float)num2 * num4;
					num6 = 1f - (num5 - imgArea) / num5;
					num7 = 1f;
				}
				else
				{
					num6 = 1f - ((float)(x * y) - imgArea) / (float)(x * y);
					num7 = ((x >= y) ? ((float)y / (float)x) : ((float)x / (float)y));
					fits = x <= maxAtlasDimX && y <= maxAtlasDimY;
				}
				pr.Set(x, y, num, num2, node, fits, num6, num7);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Probe success efficiency w=" + x + " h=" + y + " e=" + num6 + " sq=" + num7 + " fits=" + fits.ToString());
				}
				return true;
			}
			UnityEngine.Debug.LogError("Should never get here.");
			return false;
		}

		private bool ProbeMultiAtlas(Image[] imgsToAdd, int idealAtlasW, int idealAtlasH, float imgArea, int maxAtlasDimX, int maxAtlasDimY, ProbeResult pr)
		{
			int num = 0;
			Node node = new Node(NodeType.maxDim);
			node.r = new PixRect(0, 0, idealAtlasW, idealAtlasH);
			for (int i = 0; i < imgsToAdd.Length; i++)
			{
				if (node.Insert(imgsToAdd[i], handed: false) == null)
				{
					if (imgsToAdd[i].x > idealAtlasW && imgsToAdd[i].y > idealAtlasH)
					{
						return false;
					}
					Node obj = new Node(NodeType.Container)
					{
						r = new PixRect(0, 0, node.r.w + idealAtlasW, idealAtlasH)
					};
					Node node2 = new Node(NodeType.maxDim)
					{
						r = new PixRect(node.r.w, 0, idealAtlasW, idealAtlasH)
					};
					obj.child[1] = node2;
					obj.child[0] = node;
					node = obj;
					node.Insert(imgsToAdd[i], handed: false);
					num++;
				}
			}
			pr.numAtlases = num;
			pr.root = node;
			pr.totalAtlasArea = num * maxAtlasDimX * maxAtlasDimY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				MB2_Log.LogDebug("Probe success efficiency numAtlases=" + num + " totalArea=" + pr.totalAtlasArea);
			}
			return true;
		}

		internal void GetExtent(Node r, ref int x, ref int y)
		{
			if (r.img != null)
			{
				if (r.r.x + r.img.w > x)
				{
					x = r.r.x + r.img.w;
				}
				if (r.r.y + r.img.h > y)
				{
					y = r.r.y + r.img.h;
				}
			}
			if (r.child[0] != null)
			{
				GetExtent(r.child[0], ref x, ref y);
			}
			if (r.child[1] != null)
			{
				GetExtent(r.child[1], ref x, ref y);
			}
		}

		private int StepWidthHeight(int oldVal, int step, int maxDim)
		{
			if (atlasMustBePowerOfTwo && oldVal < maxDim)
			{
				return oldVal * 2;
			}
			int num = oldVal + step;
			if (num > maxDim && oldVal < maxDim)
			{
				num = maxDim;
			}
			return num;
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int atPadding)
		{
			List<AtlasPadding> list = new List<AtlasPadding>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				AtlasPadding item = default(AtlasPadding);
				item.leftRight = (item.topBottom = atPadding);
				list.Add(item);
			}
			return GetRects(imgWidthHeights, list, maxDimensionX, maxDimensionY, doMultiAtlas: false);
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < paddings.Count; i++)
			{
				num = Mathf.Max(num, paddings[i].leftRight);
				num2 = Mathf.Max(num2, paddings[i].topBottom);
			}
			if (doMultiAtlas)
			{
				return _GetRectsMultiAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimension={maxDimensionX}, minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}, recursionDepth={recursionDepth}");
			}
			if (recursionDepth > 10)
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogError("Maximum recursion depth reached. Couldn't find packing for these textures.");
				}
				return null;
			}
			float num = 0f;
			int num2 = 0;
			int num3 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			for (int i = 0; i < array.Length; i++)
			{
				int tw = (int)imgWidthHeights[i].x;
				int th = (int)imgWidthHeights[i].y;
				Image image = (array[i] = new Image(i, tw, th, paddings[i], minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				num2 = Mathf.Max(num2, image.w);
				num3 = Mathf.Max(num3, image.h);
			}
			if ((float)num3 / (float)num2 > 2f)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using height Comparer");
				}
				Array.Sort(array, new ImageHeightComparer());
			}
			else if ((double)((float)num3 / (float)num2) < 0.5)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using width Comparer");
				}
				Array.Sort(array, new ImageWidthComparer());
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("Using area Comparer");
				}
				Array.Sort(array, new ImageAreaComparer());
			}
			int num4 = (int)Mathf.Sqrt(num);
			int num6;
			int num5;
			if (atlasMustBePowerOfTwo)
			{
				num6 = (num5 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num4));
				if (num2 > num6)
				{
					num6 = MB2_TexturePacker.CeilToNearestPowerOfTwo(num6);
				}
				if (num3 > num5)
				{
					num5 = MB2_TexturePacker.CeilToNearestPowerOfTwo(num5);
				}
			}
			else
			{
				num6 = num4;
				num5 = num4;
				if (num2 > num4)
				{
					num6 = num2;
					num5 = Mathf.Max(Mathf.CeilToInt(num / (float)num2), num3);
				}
				if (num3 > num4)
				{
					num6 = Mathf.Max(Mathf.CeilToInt(num / (float)num3), num2);
					num5 = num3;
				}
			}
			if (num6 == 0)
			{
				num6 = 4;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			int num7 = (int)((float)num6 * 0.15f);
			int num8 = (int)((float)num5 * 0.15f);
			if (num7 == 0)
			{
				num7 = 1;
			}
			if (num8 == 0)
			{
				num8 = 1;
			}
			int num9 = 2;
			int num10 = num6;
			int num11 = num5;
			while (num9 >= 1 && num11 < num4 * 1000)
			{
				bool flag = false;
				num9 = 0;
				num10 = num6;
				while (!flag && num10 < num4 * 1000)
				{
					ProbeResult probeResult = new ProbeResult();
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log("Probing h=" + num11 + " w=" + num10);
					}
					if (ProbeSingleAtlas(array, num10, num11, num, maxDimensionX, maxDimensionY, probeResult))
					{
						flag = true;
						if (bestRoot == null)
						{
							bestRoot = probeResult;
						}
						else if (probeResult.GetScore(atlasMustBePowerOfTwo) > bestRoot.GetScore(atlasMustBePowerOfTwo))
						{
							bestRoot = probeResult;
						}
						continue;
					}
					num9++;
					num10 = StepWidthHeight(num10, num7, maxDimensionX);
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						MB2_Log.LogDebug("increasing Width h=" + num11 + " w=" + num10);
					}
				}
				num11 = StepWidthHeight(num11, num8, maxDimensionY);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug("increasing Height h=" + num11 + " w=" + num10);
				}
			}
			if (bestRoot == null)
			{
				return null;
			}
			int num12 = 0;
			int num13 = 0;
			if (atlasMustBePowerOfTwo)
			{
				num12 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(bestRoot.w), maxDimensionX);
				num13 = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(bestRoot.h), maxDimensionY);
				if (num13 < num12 / 2)
				{
					num13 = num12 / 2;
				}
				if (num12 < num13 / 2)
				{
					num12 = num13 / 2;
				}
			}
			else
			{
				num12 = Mathf.Min(bestRoot.w, maxDimensionX);
				num13 = Mathf.Min(bestRoot.h, maxDimensionY);
			}
			bestRoot.outW = num12;
			bestRoot.outH = num13;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: atlasW=" + num12 + " atlasH" + num13 + " w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim.ToString());
			}
			List<Image> list = new List<Image>();
			flattenTree(bestRoot.root, list);
			list.Sort(new ImgIDComparer());
			Vector2 rootWH = new Vector2(bestRoot.w, bestRoot.h);
			if (!ScaleAtlasToFitMaxDim(rootWH, list, maxDimensionX, maxDimensionY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref num12, ref num13, out var padX, out var padY, out var newMinSizeX, out var newMinSizeY))
			{
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				atlasPackingResult.rects = new Rect[list.Count];
				atlasPackingResult.srcImgIdxs = new int[list.Count];
				atlasPackingResult.atlasX = num12;
				atlasPackingResult.atlasY = num13;
				atlasPackingResult.usedW = -1;
				atlasPackingResult.usedH = -1;
				for (int j = 0; j < list.Count; j++)
				{
					Image image2 = list[j];
					Rect rect = (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)num12 + padX, (float)image2.y / (float)num13 + padY, (float)image2.w / (float)num12 - padX * 2f, (float)image2.h / (float)num13 - padY * 2f));
					atlasPackingResult.srcImgIdxs[j] = image2.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug("Image: " + j + " imgID=" + image2.imgId + " x=" + rect.x * (float)num12 + " y=" + rect.y * (float)num13 + " w=" + rect.width * (float)num12 + " h=" + rect.height * (float)num13 + " padding=" + paddings[j]);
					}
				}
				atlasPackingResult.CalcUsedWidthAndHeight();
				return atlasPackingResult;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("==================== REDOING PACKING ================");
			}
			return _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, newMinSizeX, newMinSizeY, masterImageSizeX, masterImageSizeY, recursionDepth + 1);
		}

		private AtlasPackingResult[] _GetRectsMultiAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"_GetRects numImages={imgWidthHeights.Count}, maxDimensionX={maxDimensionPassedX}, maxDimensionY={maxDimensionPassedY} minImageSizeX={minImageSizeX}, minImageSizeY={minImageSizeY}, masterImageSizeX={masterImageSizeX}, masterImageSizeY={masterImageSizeY}");
			}
			float num = 0f;
			int a = 0;
			int a2 = 0;
			Image[] array = new Image[imgWidthHeights.Count];
			int num2 = maxDimensionPassedX;
			int num3 = maxDimensionPassedY;
			if (atlasMustBePowerOfTwo)
			{
				num2 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num2);
				num3 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num3);
			}
			for (int i = 0; i < array.Length; i++)
			{
				int a3 = (int)imgWidthHeights[i].x;
				int a4 = (int)imgWidthHeights[i].y;
				a3 = Mathf.Min(a3, num2 - paddings[i].leftRight * 2);
				a4 = Mathf.Min(a4, num3 - paddings[i].topBottom * 2);
				Image image = (array[i] = new Image(i, a3, a4, paddings[i], minImageSizeX, minImageSizeY));
				num += (float)(image.w * image.h);
				a = Mathf.Max(a, image.w);
				a2 = Mathf.Max(a2, image.h);
			}
			int num4;
			int num5;
			if (atlasMustBePowerOfTwo)
			{
				num4 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num3);
				num5 = MB2_TexturePacker.RoundToNearestPositivePowerOfTwo(num2);
			}
			else
			{
				num4 = num3;
				num5 = num2;
			}
			if (num5 == 0)
			{
				num5 = 4;
			}
			if (num4 == 0)
			{
				num4 = 4;
			}
			ProbeResult probeResult = new ProbeResult();
			Array.Sort(array, new ImageHeightComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult))
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageWidthComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			Array.Sort(array, new ImageAreaComparer());
			if (ProbeMultiAtlas(array, num5, num4, num, num2, num3, probeResult) && probeResult.totalAtlasArea < bestRoot.totalAtlasArea)
			{
				bestRoot = probeResult;
			}
			if (bestRoot == null)
			{
				return null;
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Best fit found: w=" + bestRoot.w + " h=" + bestRoot.h + " efficiency=" + bestRoot.efficiency + " squareness=" + bestRoot.squareness + " fits in max dimension=" + bestRoot.largerOrEqualToMaxDim.ToString());
			}
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			List<Node> list2 = new List<Node>();
			Stack<Node> stack = new Stack<Node>();
			for (Node node = bestRoot.root; node != null; node = node.child[0])
			{
				stack.Push(node);
			}
			while (stack.Count > 0)
			{
				Node node = stack.Pop();
				if (node.isFullAtlas == NodeType.maxDim)
				{
					list2.Add(node);
				}
				if (node.child[1] != null)
				{
					for (node = node.child[1]; node != null; node = node.child[0])
					{
						stack.Push(node);
					}
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				List<Image> list3 = new List<Image>();
				flattenTree(list2[j], list3);
				Rect[] array2 = new Rect[list3.Count];
				int[] array3 = new int[list3.Count];
				for (int k = 0; k < list3.Count; k++)
				{
					array2[k] = new Rect(list3[k].x - list2[j].r.x, list3[k].y, list3[k].w, list3[k].h);
					array3[k] = list3[k].imgId;
				}
				AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				GetExtent(list2[j], ref atlasPackingResult.usedW, ref atlasPackingResult.usedH);
				atlasPackingResult.usedW -= list2[j].r.x;
				int w = list2[j].r.w;
				int h = list2[j].r.h;
				if (atlasMustBePowerOfTwo)
				{
					w = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasPackingResult.usedW), list2[j].r.w);
					h = Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasPackingResult.usedH), list2[j].r.h);
					if (h < w / 2)
					{
						h = w / 2;
					}
					if (w < h / 2)
					{
						w = h / 2;
					}
				}
				else
				{
					w = atlasPackingResult.usedW;
					h = atlasPackingResult.usedH;
				}
				atlasPackingResult.atlasY = h;
				atlasPackingResult.atlasX = w;
				atlasPackingResult.rects = array2;
				atlasPackingResult.srcImgIdxs = array3;
				atlasPackingResult.CalcUsedWidthAndHeight();
				list.Add(atlasPackingResult);
				normalizeRects(atlasPackingResult, paddings[j]);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug($"Done GetRects ");
				}
			}
			return list.ToArray();
		}
	}
	public class MB2_TexturePackerHorizontalVert : MB2_TexturePacker
	{
		public enum TexturePackingOrientation
		{
			horizontal,
			vertical
		}

		public TexturePackingOrientation packingOrientation;

		public bool stretchImagesToEdges = true;

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, int maxDimensionX, int maxDimensionY, int padding)
		{
			List<AtlasPadding> list = new List<AtlasPadding>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				AtlasPadding item = default(AtlasPadding);
				if (packingOrientation == TexturePackingOrientation.horizontal)
				{
					item.leftRight = 0;
					item.topBottom = 8;
				}
				else
				{
					item.leftRight = 8;
					item.topBottom = 0;
				}
				list.Add(item);
			}
			return GetRects(imgWidthHeights, list, maxDimensionX, maxDimensionY, doMultiAtlas: false);
		}

		public override AtlasPackingResult[] GetRects(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, bool doMultiAtlas)
		{
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < paddings.Count; i++)
			{
				num = Mathf.Max(num, paddings[i].leftRight);
				num2 = Mathf.Max(num2, paddings[i].topBottom);
			}
			if (doMultiAtlas)
			{
				if (packingOrientation == TexturePackingOrientation.vertical)
				{
					return _GetRectsMultiAtlasVertical(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
				}
				return _GetRectsMultiAtlasHorizontal(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2);
			}
			AtlasPackingResult atlasPackingResult = _GetRectsSingleAtlas(imgWidthHeights, paddings, maxDimensionX, maxDimensionY, 2 + num * 2, 2 + num2 * 2, 2 + num * 2, 2 + num2 * 2, 0);
			if (atlasPackingResult == null)
			{
				return null;
			}
			return new AtlasPackingResult[1] { atlasPackingResult };
		}

		private AtlasPackingResult _GetRectsSingleAtlas(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionX, int maxDimensionY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY, int recursionDepth)
		{
			AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
			List<Rect> list = new List<Rect>();
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			List<Image> list2 = new List<Image>();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				if (packingOrientation == TexturePackingOrientation.vertical)
				{
					image.h -= paddings[i].topBottom * 2;
					image.x = num;
					image.y = 0;
					list.Add(new Rect(image.w, image.h, num, 0f));
					num += image.w;
					num2 = Mathf.Max(num2, image.h);
				}
				else
				{
					image.w -= paddings[i].leftRight * 2;
					image.y = num;
					image.x = 0;
					list.Add(new Rect(image.w, image.h, 0f, num));
					num += image.h;
					num3 = Mathf.Max(num3, image.w);
				}
				list2.Add(image);
			}
			Vector2 rootWH = ((packingOrientation != TexturePackingOrientation.vertical) ? new Vector2(num3, num) : new Vector2(num, num2));
			int outW = (int)rootWH.x;
			int outH = (int)rootWH.y;
			if (packingOrientation != TexturePackingOrientation.vertical)
			{
				outH = ((!atlasMustBePowerOfTwo) ? Mathf.Min(outH, maxDimensionY) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(outH), maxDimensionY));
			}
			else
			{
				outW = ((!atlasMustBePowerOfTwo) ? Mathf.Min(outW, maxDimensionX) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(outW), maxDimensionX));
			}
			if (!ScaleAtlasToFitMaxDim(rootWH, list2, maxDimensionX, maxDimensionY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref outW, ref outH, out var padX, out var padY, out var _, out var _))
			{
				atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
				atlasPackingResult.rects = new Rect[list2.Count];
				atlasPackingResult.srcImgIdxs = new int[list2.Count];
				atlasPackingResult.atlasX = outW;
				atlasPackingResult.atlasY = outH;
				for (int j = 0; j < list2.Count; j++)
				{
					Image image2 = list2[j];
					Rect rect = ((packingOrientation != TexturePackingOrientation.vertical) ? (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)outW, (float)image2.y / (float)outH + padY, stretchImagesToEdges ? 1f : ((float)image2.w / (float)outW), (float)image2.h / (float)outH - padY * 2f)) : (atlasPackingResult.rects[j] = new Rect((float)image2.x / (float)outW + padX, (float)image2.y / (float)outH, (float)image2.w / (float)outW - padX * 2f, stretchImagesToEdges ? 1f : ((float)image2.h / (float)outH))));
					atlasPackingResult.srcImgIdxs[j] = image2.imgId;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						MB2_Log.LogDebug(string.Concat("Image: ", j, " imgID=", image2.imgId, " x=", rect.x * (float)outW, " y=", rect.y * (float)outH, " w=", rect.width * (float)outW, " h=", rect.height * (float)outH, " padding=", paddings[j], " outW=", outW, " outH=", outH));
					}
				}
				atlasPackingResult.CalcUsedWidthAndHeight();
				return atlasPackingResult;
			}
			UnityEngine.Debug.Log("Packing failed returning null atlas result");
			return null;
		}

		private AtlasPackingResult[] _GetRectsMultiAtlasVertical(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			int num = 0;
			int num2 = 0;
			int atlasX = 0;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			List<Image> list2 = new List<Image>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				image.h -= paddings[i].topBottom * 2;
				list2.Add(image);
			}
			list2.Sort(new ImageWidthComparer());
			List<Image> list3 = new List<Image>();
			List<Rect> list4 = new List<Rect>();
			int spaceRemaining = maxDimensionPassedX;
			while (list2.Count > 0 || list3.Count > 0)
			{
				Image image2 = PopLargestThatFits(list2, spaceRemaining, maxDimensionPassedX, list3.Count == 0);
				if (image2 == null)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Atlas filled creating a new atlas ");
					}
					AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
					atlasPackingResult.atlasX = atlasX;
					atlasPackingResult.atlasY = num2;
					Rect[] array = new Rect[list3.Count];
					int[] array2 = new int[list3.Count];
					for (int j = 0; j < list3.Count; j++)
					{
						Rect rect = new Rect(list3[j].x, list3[j].y, list3[j].w, stretchImagesToEdges ? num2 : list3[j].h);
						array[j] = rect;
						array2[j] = list3[j].imgId;
					}
					atlasPackingResult.rects = array;
					atlasPackingResult.srcImgIdxs = array2;
					atlasPackingResult.CalcUsedWidthAndHeight();
					list3.Clear();
					list4.Clear();
					num = 0;
					num2 = 0;
					list.Add(atlasPackingResult);
					spaceRemaining = maxDimensionPassedX;
				}
				else
				{
					image2.x = num;
					image2.y = 0;
					list3.Add(image2);
					list4.Add(new Rect(num, 0f, image2.w, image2.h));
					num += image2.w;
					num2 = Mathf.Max(num2, image2.h);
					atlasX = num;
					spaceRemaining = maxDimensionPassedX - num;
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				int atlasX2 = list[k].atlasX;
				int outH = Mathf.Min(list[k].atlasY, maxDimensionPassedY);
				atlasX2 = ((!atlasMustBePowerOfTwo) ? Mathf.Min(atlasX2, maxDimensionPassedX) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasX2), maxDimensionPassedX));
				list[k].atlasX = atlasX2;
				ScaleAtlasToFitMaxDim(new Vector2(list[k].atlasX, list[k].atlasY), list3, maxDimensionPassedX, maxDimensionPassedY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref atlasX2, ref outH, out var _, out var _, out var _, out var _);
			}
			for (int l = 0; l < list.Count; l++)
			{
				normalizeRects(list[l], paddings[l]);
				list[l].CalcUsedWidthAndHeight();
			}
			return list.ToArray();
		}

		private AtlasPackingResult[] _GetRectsMultiAtlasHorizontal(List<Vector2> imgWidthHeights, List<AtlasPadding> paddings, int maxDimensionPassedX, int maxDimensionPassedY, int minImageSizeX, int minImageSizeY, int masterImageSizeX, int masterImageSizeY)
		{
			List<AtlasPackingResult> list = new List<AtlasPackingResult>();
			int num = 0;
			int atlasY = 0;
			int num2 = 0;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Packing rects for: " + imgWidthHeights.Count);
			}
			List<Image> list2 = new List<Image>();
			for (int i = 0; i < imgWidthHeights.Count; i++)
			{
				Image image = new Image(i, (int)imgWidthHeights[i].x, (int)imgWidthHeights[i].y, paddings[i], minImageSizeX, minImageSizeY);
				image.w -= paddings[i].leftRight * 2;
				list2.Add(image);
			}
			list2.Sort(new ImageHeightComparer());
			List<Image> list3 = new List<Image>();
			List<Rect> list4 = new List<Rect>();
			int spaceRemaining = maxDimensionPassedY;
			while (list2.Count > 0 || list3.Count > 0)
			{
				Image image2 = PopLargestThatFits(list2, spaceRemaining, maxDimensionPassedY, list3.Count == 0);
				if (image2 == null)
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Atlas filled creating a new atlas ");
					}
					AtlasPackingResult atlasPackingResult = new AtlasPackingResult(paddings.ToArray());
					atlasPackingResult.atlasX = num2;
					atlasPackingResult.atlasY = atlasY;
					Rect[] array = new Rect[list3.Count];
					int[] array2 = new int[list3.Count];
					for (int j = 0; j < list3.Count; j++)
					{
						Rect rect = new Rect(list3[j].x, list3[j].y, stretchImagesToEdges ? num2 : list3[j].w, list3[j].h);
						array[j] = rect;
						array2[j] = list3[j].imgId;
					}
					atlasPackingResult.rects = array;
					atlasPackingResult.srcImgIdxs = array2;
					list3.Clear();
					list4.Clear();
					num = 0;
					atlasY = 0;
					list.Add(atlasPackingResult);
					spaceRemaining = maxDimensionPassedY;
				}
				else
				{
					image2.x = 0;
					image2.y = num;
					list3.Add(image2);
					list4.Add(new Rect(0f, num, image2.w, image2.h));
					num += image2.h;
					num2 = Mathf.Max(num2, image2.w);
					atlasY = num;
					spaceRemaining = maxDimensionPassedY - num;
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				int atlasY2 = list[k].atlasY;
				int outW = Mathf.Min(list[k].atlasX, maxDimensionPassedX);
				atlasY2 = ((!atlasMustBePowerOfTwo) ? Mathf.Min(atlasY2, maxDimensionPassedY) : Mathf.Min(MB2_TexturePacker.CeilToNearestPowerOfTwo(atlasY2), maxDimensionPassedY));
				list[k].atlasY = atlasY2;
				ScaleAtlasToFitMaxDim(new Vector2(list[k].atlasX, list[k].atlasY), list3, maxDimensionPassedX, maxDimensionPassedY, paddings[0], minImageSizeX, minImageSizeY, masterImageSizeX, masterImageSizeY, ref outW, ref atlasY2, out var _, out var _, out var _, out var _);
			}
			for (int l = 0; l < list.Count; l++)
			{
				normalizeRects(list[l], paddings[l]);
				list[l].CalcUsedWidthAndHeight();
			}
			return list.ToArray();
		}

		private Image PopLargestThatFits(List<Image> images, int spaceRemaining, int maxDim, bool emptyAtlas)
		{
			if (images.Count == 0)
			{
				return null;
			}
			int num = ((packingOrientation != TexturePackingOrientation.vertical) ? images[0].h : images[0].w);
			if (images.Count > 0 && num >= maxDim)
			{
				if (emptyAtlas)
				{
					Image result = images[0];
					images.RemoveAt(0);
					return result;
				}
				return null;
			}
			int i;
			for (i = 0; i < images.Count; i++)
			{
				if (num < spaceRemaining)
				{
					break;
				}
			}
			if (i < images.Count)
			{
				Image result2 = images[i];
				images.RemoveAt(i);
				return result2;
			}
			return null;
		}
	}
	internal interface MB_ITextureCombinerPacker
	{
		IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);

		AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL);

		IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);
	}
	internal abstract class MB3_TextureCombinerPackerRoot : MB_ITextureCombinerPacker
	{
		internal static void CreateTemporaryTexturesForAtlas(List<MB_TexSet> distinctMaterialTextures, MB3_TextureCombiner combiner, int propIdx, MB3_TextureCombinerPipeline.TexturePipelineData data)
		{
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
				if (mB_TexSet.ts[propIdx].isNull)
				{
					Color colorForTemporaryTexture = data.nonTexturePropertyBlender.GetColorForTemporaryTexture(mB_TexSet.matsAndGOs.mats[0].mat, data.texPropertyNames[propIdx]);
					mB_TexSet.CreateColoredTexToReplaceNull(data.texPropertyNames[propIdx].name, propIdx, data._fixOutOfBoundsUVs, combiner, colorForTemporaryTexture);
				}
			}
		}

		public static AtlasPackingResult[] CalculateAtlasRectanglesStatic(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			List<Vector2> list = new List<Vector2>();
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				list.Add(new Vector2(data.distinctMaterialTextures[i].idealWidth, data.distinctMaterialTextures[i].idealHeight));
			}
			MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(data._packingAlgorithm);
			mB2_TexturePacker.atlasMustBePowerOfTwo = data._meshBakerTexturePackerForcePowerOfTwo;
			List<AtlasPadding> list2 = new List<AtlasPadding>();
			for (int j = 0; j < list.Count; j++)
			{
				AtlasPadding item = default(AtlasPadding);
				item.topBottom = data._atlasPadding;
				item.leftRight = data._atlasPadding;
				if (data._packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal)
				{
					item.leftRight = 0;
				}
				if (data._packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical)
				{
					item.topBottom = 0;
				}
				list2.Add(item);
			}
			return mB2_TexturePacker.GetRects(list, list2, data._maxAtlasWidth, data._maxAtlasHeight, doMultiAtlas: false);
		}

		public static void MakeProceduralTexturesReadable(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			UnityEngine.Debug.LogError("TODO this should be done as close to textures being used as possible due to memory issues.");
		}

		public virtual IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				for (int j = 0; j < data.texPropertyNames.Count; j++)
				{
					MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[i].ts[j];
					if (!meshBakerMaterialTexture.isNull && textureEditorMethods != null)
					{
						Texture texture2D = meshBakerMaterialTexture.GetTexture2D();
						progressInfo?.Invoke($"Convert texture {texture2D} to readable format ", 0.5f);
						textureEditorMethods.AddTextureFormat((Texture2D)texture2D, data.texPropertyNames[j].isNormalMap);
					}
				}
			}
			yield break;
		}

		public virtual AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return CalculateAtlasRectanglesStatic(data, doMultiAtlas, LOG_LEVEL);
		}

		public abstract IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL);
	}
	[Serializable]
	public class ShaderTextureProperty
	{
		public string name;

		public bool isNormalMap;

		public ShaderTextureProperty(string n, bool norm)
		{
			name = n;
			isNormalMap = norm;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ShaderTextureProperty))
			{
				return false;
			}
			ShaderTextureProperty shaderTextureProperty = (ShaderTextureProperty)obj;
			if (!name.Equals(shaderTextureProperty.name))
			{
				return false;
			}
			if (isNormalMap != shaderTextureProperty.isNormalMap)
			{
				return false;
			}
			return true;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public static string[] GetNames(List<ShaderTextureProperty> props)
		{
			string[] array = new string[props.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = props[i].name;
			}
			return array;
		}
	}
	[Serializable]
	public class MB3_TextureCombiner
	{
		private class TemporaryTexture
		{
			internal string property;

			internal Texture2D texture;

			public TemporaryTexture(string prop, Texture2D tex)
			{
				property = prop;
				texture = tex;
			}
		}

		public class CombineTexturesIntoAtlasesCoroutineResult
		{
			public bool success = true;

			public bool isFinished;
		}

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		[SerializeField]
		protected MB2_TextureBakeResults _textureBakeResults;

		[SerializeField]
		protected int _atlasPadding = 1;

		[SerializeField]
		protected int _maxAtlasSize = 1;

		[SerializeField]
		protected int _maxAtlasWidthOverride = 4096;

		[SerializeField]
		protected int _maxAtlasHeightOverride = 4096;

		[SerializeField]
		protected bool _useMaxAtlasWidthOverride;

		[SerializeField]
		protected bool _useMaxAtlasHeightOverride;

		[SerializeField]
		protected bool _resizePowerOfTwoTextures;

		[SerializeField]
		protected bool _fixOutOfBoundsUVs;

		[SerializeField]
		protected int _maxTilingBakeSize = 1024;

		[SerializeField]
		protected bool _saveAtlasesAsAssets;

		[SerializeField]
		protected MB2_PackingAlgorithmEnum _packingAlgorithm;

		[SerializeField]
		protected bool _meshBakerTexturePackerForcePowerOfTwo = true;

		[SerializeField]
		protected List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

		[SerializeField]
		protected bool _normalizeTexelDensity;

		[SerializeField]
		protected bool _considerNonTextureProperties;

		private List<TemporaryTexture> _temporaryTextures = new List<TemporaryTexture>();

		public static bool _RunCorutineWithoutPauseIsRunning;

		public MB2_TextureBakeResults textureBakeResults
		{
			get
			{
				return _textureBakeResults;
			}
			set
			{
				_textureBakeResults = value;
			}
		}

		public int atlasPadding
		{
			get
			{
				return _atlasPadding;
			}
			set
			{
				_atlasPadding = value;
			}
		}

		public int maxAtlasSize
		{
			get
			{
				return _maxAtlasSize;
			}
			set
			{
				_maxAtlasSize = value;
			}
		}

		public virtual int maxAtlasWidthOverride
		{
			get
			{
				return _maxAtlasWidthOverride;
			}
			set
			{
				_maxAtlasWidthOverride = value;
			}
		}

		public virtual int maxAtlasHeightOverride
		{
			get
			{
				return _maxAtlasHeightOverride;
			}
			set
			{
				_maxAtlasHeightOverride = value;
			}
		}

		public virtual bool useMaxAtlasWidthOverride
		{
			get
			{
				return _useMaxAtlasWidthOverride;
			}
			set
			{
				_useMaxAtlasWidthOverride = value;
			}
		}

		public virtual bool useMaxAtlasHeightOverride
		{
			get
			{
				return _useMaxAtlasHeightOverride;
			}
			set
			{
				_useMaxAtlasHeightOverride = value;
			}
		}

		public bool resizePowerOfTwoTextures
		{
			get
			{
				return _resizePowerOfTwoTextures;
			}
			set
			{
				_resizePowerOfTwoTextures = value;
			}
		}

		public bool fixOutOfBoundsUVs
		{
			get
			{
				return _fixOutOfBoundsUVs;
			}
			set
			{
				_fixOutOfBoundsUVs = value;
			}
		}

		public int maxTilingBakeSize
		{
			get
			{
				return _maxTilingBakeSize;
			}
			set
			{
				_maxTilingBakeSize = value;
			}
		}

		public bool saveAtlasesAsAssets
		{
			get
			{
				return _saveAtlasesAsAssets;
			}
			set
			{
				_saveAtlasesAsAssets = value;
			}
		}

		public MB2_PackingAlgorithmEnum packingAlgorithm
		{
			get
			{
				return _packingAlgorithm;
			}
			set
			{
				_packingAlgorithm = value;
			}
		}

		public bool meshBakerTexturePackerForcePowerOfTwo
		{
			get
			{
				return _meshBakerTexturePackerForcePowerOfTwo;
			}
			set
			{
				_meshBakerTexturePackerForcePowerOfTwo = value;
			}
		}

		public List<ShaderTextureProperty> customShaderPropNames
		{
			get
			{
				return _customShaderPropNames;
			}
			set
			{
				_customShaderPropNames = value;
			}
		}

		public bool considerNonTextureProperties
		{
			get
			{
				return _considerNonTextureProperties;
			}
			set
			{
				_considerNonTextureProperties = value;
			}
		}

		public static void RunCorutineWithoutPause(IEnumerator cor, int recursionDepth)
		{
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = true;
			}
			if (recursionDepth > 20)
			{
				UnityEngine.Debug.LogError("Recursion Depth Exceeded.");
				return;
			}
			while (cor.MoveNext())
			{
				object current = cor.Current;
				if (!(current is YieldInstruction) && current != null && current is IEnumerator)
				{
					RunCorutineWithoutPause((IEnumerator)cor.Current, recursionDepth + 1);
				}
			}
			if (recursionDepth == 0)
			{
				_RunCorutineWithoutPauseIsRunning = false;
			}
		}

		public bool CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			CombineTexturesIntoAtlasesCoroutineResult combineTexturesIntoAtlasesCoroutineResult = new CombineTexturesIntoAtlasesCoroutineResult();
			RunCorutineWithoutPause(_CombineTexturesIntoAtlases(progressInfo, combineTexturesIntoAtlasesCoroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects), 0);
			return combineTexturesIntoAtlasesCoroutineResult.success;
		}

		public IEnumerator CombineTexturesIntoAtlasesCoroutine(ProgressUpdateDelegate progressInfo, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods = null, CombineTexturesIntoAtlasesCoroutineResult coroutineResult = null, float maxTimePerFrame = 0.01f, List<AtlasPackingResult> packingResults = null, bool onlyPackRects = false)
		{
			if (!_RunCorutineWithoutPauseIsRunning && (MBVersion.GetMajorVersion() < 5 || (MBVersion.GetMajorVersion() == 5 && MBVersion.GetMinorVersion() < 3)))
			{
				UnityEngine.Debug.LogError("Running the texture combiner as a coroutine only works in Unity 5.3 and higher");
				yield return null;
			}
			coroutineResult.success = true;
			coroutineResult.isFinished = false;
			if (maxTimePerFrame <= 0f)
			{
				UnityEngine.Debug.LogError("maxTimePerFrame must be a value greater than zero");
				coroutineResult.isFinished = true;
			}
			else
			{
				yield return _CombineTexturesIntoAtlases(progressInfo, coroutineResult, resultAtlasesAndRects, resultMaterial, objsToMesh, allowedMaterialsFilter, textureEditorMethods, packingResults, onlyPackRects);
				coroutineResult.isFinished = true;
			}
		}

		private IEnumerator _CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, Material resultMaterial, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> atlasPackingResult, bool onlyPackRects)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			try
			{
				_temporaryTextures.Clear();
				MeshBakerMaterialTexture.readyToBuildAtlases = false;
				if (textureEditorMethods != null)
				{
					textureEditorMethods.Clear();
					textureEditorMethods.OnPreTextureBake();
				}
				if (objsToMesh == null || objsToMesh.Count == 0)
				{
					UnityEngine.Debug.LogError("No meshes to combine. Please assign some meshes to combine.");
					result.success = false;
					yield break;
				}
				if (_atlasPadding < 0)
				{
					UnityEngine.Debug.LogError("Atlas padding must be zero or greater.");
					result.success = false;
					yield break;
				}
				if (_maxTilingBakeSize < 2 || _maxTilingBakeSize > 4096)
				{
					UnityEngine.Debug.LogError("Invalid value for max tiling bake size.");
					result.success = false;
					yield break;
				}
				for (int i = 0; i < objsToMesh.Count; i++)
				{
					Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
					for (int j = 0; j < gOMaterials.Length; j++)
					{
						if (gOMaterials[j] == null)
						{
							UnityEngine.Debug.LogError(string.Concat("Game object ", objsToMesh[i], " has a null material"));
							result.success = false;
							yield break;
						}
					}
				}
				progressInfo?.Invoke("Collecting textures for " + objsToMesh.Count + " meshes.", 0.01f);
				MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = LoadPipelineData(resultMaterial, new List<ShaderTextureProperty>(), objsToMesh, allowedMaterialsFilter, new List<MB_TexSet>());
				if (!MB3_TextureCombinerPipeline._CollectPropertyNames(texturePipelineData, LOG_LEVEL))
				{
					result.success = false;
					yield break;
				}
				if (_fixOutOfBoundsUVs && (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal || _packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical) && LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.LogWarning("'Consider Mesh UVs' is enabled but packing algorithm is MeshBakerTexturePacker_Horizontal or MeshBakerTexturePacker_Vertical. It is recommended to use these packers without using 'Consider Mesh UVs'");
				}
				texturePipelineData.nonTexturePropertyBlender.LoadTextureBlendersIfNeeded(texturePipelineData.resultMaterial);
				if (onlyPackRects)
				{
					yield return __RunTexturePacker(result, texturePipelineData, textureEditorMethods, atlasPackingResult);
				}
				else
				{
					yield return __CombineTexturesIntoAtlases(progressInfo, result, resultAtlasesAndRects, texturePipelineData, textureEditorMethods);
				}
			}
			finally
			{
				MB3_TextureCombiner mB3_TextureCombiner = this;
				mB3_TextureCombiner._destroyAllTemporaryTextures();
				mB3_TextureCombiner._restoreProceduralMaterials();
				if (textureEditorMethods != null)
				{
					textureEditorMethods.RestoreReadFlagsAndFormats(progressInfo);
					textureEditorMethods.OnPostTextureBake();
				}
				if (mB3_TextureCombiner.LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log(string.Concat("===== Done creating atlases for ", resultMaterial, " Total time to create atlases ", sw.Elapsed.ToString()));
				}
			}
		}

		private MB3_TextureCombinerPipeline.TexturePipelineData LoadPipelineData(Material resultMaterial, List<ShaderTextureProperty> texPropertyNames, List<GameObject> objsToMesh, List<Material> allowedMaterialsFilter, List<MB_TexSet> distinctMaterialTextures)
		{
			MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = new MB3_TextureCombinerPipeline.TexturePipelineData();
			texturePipelineData._textureBakeResults = _textureBakeResults;
			texturePipelineData._atlasPadding = _atlasPadding;
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical && _useMaxAtlasHeightOverride)
			{
				texturePipelineData._maxAtlasHeight = _maxAtlasHeightOverride;
				texturePipelineData._useMaxAtlasHeightOverride = true;
			}
			else
			{
				texturePipelineData._maxAtlasHeight = _maxAtlasSize;
			}
			if (_packingAlgorithm == MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal && _useMaxAtlasWidthOverride)
			{
				texturePipelineData._maxAtlasWidth = _maxAtlasWidthOverride;
				texturePipelineData._useMaxAtlasWidthOverride = true;
			}
			else
			{
				texturePipelineData._maxAtlasWidth = _maxAtlasSize;
			}
			texturePipelineData._resizePowerOfTwoTextures = _resizePowerOfTwoTextures;
			texturePipelineData._fixOutOfBoundsUVs = _fixOutOfBoundsUVs;
			texturePipelineData._maxTilingBakeSize = _maxTilingBakeSize;
			texturePipelineData._saveAtlasesAsAssets = _saveAtlasesAsAssets;
			texturePipelineData._packingAlgorithm = _packingAlgorithm;
			texturePipelineData._meshBakerTexturePackerForcePowerOfTwo = _meshBakerTexturePackerForcePowerOfTwo;
			texturePipelineData._customShaderPropNames = _customShaderPropNames;
			texturePipelineData._normalizeTexelDensity = _normalizeTexelDensity;
			texturePipelineData._considerNonTextureProperties = _considerNonTextureProperties;
			texturePipelineData.nonTexturePropertyBlender = new MB3_TextureCombinerNonTextureProperties(LOG_LEVEL, _considerNonTextureProperties);
			texturePipelineData.resultMaterial = resultMaterial;
			texturePipelineData.distinctMaterialTextures = distinctMaterialTextures;
			texturePipelineData.allObjsToMesh = objsToMesh;
			texturePipelineData.allowedMaterialsFilter = allowedMaterialsFilter;
			texturePipelineData.texPropertyNames = texPropertyNames;
			return texturePipelineData;
		}

		private IEnumerator __CombineTexturesIntoAtlases(ProgressUpdateDelegate progressInfo, CombineTexturesIntoAtlasesCoroutineResult result, MB_AtlasesAndRects resultAtlasesAndRects, MB3_TextureCombinerPipeline.TexturePipelineData data, MB2_EditorMethodsInterface textureEditorMethods)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__CombineTexturesIntoAtlases texture properties in shader:" + data.texPropertyNames.Count + " objsToMesh:" + data.allObjsToMesh.Count + " _fixOutOfBoundsUVs:" + data._fixOutOfBoundsUVs.ToString());
			}
			progressInfo?.Invoke("Collecting textures ", 0.01f);
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return MB3_TextureCombinerPipeline.__Step1_CollectDistinctMatTexturesAndUsedObjects(progressInfo, result, data, this, textureEditorMethods, usedObjsToMesh, LOG_LEVEL);
			if (!result.success)
			{
				yield break;
			}
			if (MB3_MeshCombiner.EVAL_VERSION)
			{
				bool flag = true;
				for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
				{
					for (int j = 0; j < data.distinctMaterialTextures[i].matsAndGOs.mats.Count; j++)
					{
						if (!data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Diffuse") && !data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name.EndsWith("Bumped Diffuse"))
						{
							UnityEngine.Debug.LogError("The free version of Mesh Baker only works with Diffuse and Bumped Diffuse Shaders. The full version can be used with any shader. Material " + data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.name + " uses shader " + data.distinctMaterialTextures[i].matsAndGOs.mats[j].mat.shader.name);
							flag = false;
						}
					}
				}
				if (!flag)
				{
					result.success = false;
					yield break;
				}
			}
			yield return MB3_TextureCombinerPipeline.CalculateIdealSizesForTexturesInAtlasAndPadding(progressInfo, result, data, this, textureEditorMethods, LOG_LEVEL);
			if (result.success)
			{
				StringBuilder report = MB3_TextureCombinerPipeline.GenerateReport(data);
				MB_ITextureCombinerPacker texturePaker = MB3_TextureCombinerPipeline.CreatePacker(data.OnlyOneTextureInAtlasReuseTextures(), data._packingAlgorithm);
				yield return texturePaker.ConvertTexturesToReadableFormats(progressInfo, result, data, this, textureEditorMethods, LOG_LEVEL);
				if (result.success)
				{
					AtlasPackingResult[] array = texturePaker.CalculateAtlasRectangles(data, doMultiAtlas: false, LOG_LEVEL);
					yield return MB3_TextureCombinerPipeline.__Step3_BuildAndSaveAtlasesAndStoreResults(result, progressInfo, data, this, texturePaker, array[0], textureEditorMethods, resultAtlasesAndRects, report, LOG_LEVEL);
				}
			}
		}

		private IEnumerator __RunTexturePacker(CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB2_EditorMethodsInterface textureEditorMethods, List<AtlasPackingResult> packingResult)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("__RunTexturePacker texture properties in shader:" + data.texPropertyNames.Count + " objsToMesh:" + data.allObjsToMesh.Count + " _fixOutOfBoundsUVs:" + data._fixOutOfBoundsUVs.ToString());
			}
			List<GameObject> usedObjsToMesh = new List<GameObject>();
			yield return MB3_TextureCombinerPipeline.__Step1_CollectDistinctMatTexturesAndUsedObjects(null, result, data, this, textureEditorMethods, usedObjsToMesh, LOG_LEVEL);
			if (!result.success)
			{
				yield break;
			}
			data.allTexturesAreNullAndSameColor = new MB3_TextureCombinerPipeline.CreateAtlasForProperty[data.texPropertyNames.Count];
			yield return MB3_TextureCombinerPipeline.CalculateIdealSizesForTexturesInAtlasAndPadding(null, result, data, this, textureEditorMethods, LOG_LEVEL);
			if (result.success)
			{
				MB_ITextureCombinerPacker texturePacker = MB3_TextureCombinerPipeline.CreatePacker(data.OnlyOneTextureInAtlasReuseTextures(), data._packingAlgorithm);
				AtlasPackingResult[] array = MB3_TextureCombinerPipeline.__Step3_RunTexturePacker(data, texturePacker, LOG_LEVEL);
				for (int i = 0; i < array.Length; i++)
				{
					packingResult.Add(array[i]);
				}
			}
		}

		internal int _getNumTemporaryTextures()
		{
			return _temporaryTextures.Count;
		}

		public Texture2D _createTemporaryTexture(string propertyName, int w, int h, TextureFormat texFormat, bool mipMaps)
		{
			Texture2D texture2D = new Texture2D(w, h, texFormat, mipMaps);
			texture2D.name = $"tmp{_temporaryTextures.Count}_{w}x{h}";
			MB_Utility.setSolidColor(texture2D, Color.clear);
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal Texture2D _createTextureCopy(string propertyName, Texture2D t)
		{
			Texture2D texture2D = MB_Utility.createTextureCopy(t);
			texture2D.name = $"tmpCopy{_temporaryTextures.Count}_{texture2D.width}x{texture2D.height}";
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal Texture2D _resizeTexture(string propertyName, Texture2D t, int w, int h)
		{
			Texture2D texture2D = MB_Utility.resampleTexture(t, w, h);
			texture2D.name = $"tmpResampled{_temporaryTextures.Count}_{w}x{h}";
			TemporaryTexture item = new TemporaryTexture(propertyName, texture2D);
			_temporaryTextures.Add(item);
			return texture2D;
		}

		internal void _destroyAllTemporaryTextures()
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + _temporaryTextures.Count + " temporary textures");
			}
			for (int i = 0; i < _temporaryTextures.Count; i++)
			{
				MB_Utility.Destroy(_temporaryTextures[i].texture);
			}
			_temporaryTextures.Clear();
		}

		internal void _destroyTemporaryTextures(string propertyName)
		{
			int num = 0;
			for (int num2 = _temporaryTextures.Count - 1; num2 >= 0; num2--)
			{
				if (_temporaryTextures[num2].property.Equals(propertyName))
				{
					num++;
					MB_Utility.Destroy(_temporaryTextures[num2].texture);
					_temporaryTextures.RemoveAt(num2);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Destroying " + num + " temporary textures " + propertyName + " num remaining " + _temporaryTextures.Count);
			}
		}

		public void _restoreProceduralMaterials()
		{
		}

		public void SuggestTreatment(List<GameObject> objsToMesh, Material[] resultMaterials, List<ShaderTextureProperty> _customShaderPropNames)
		{
			this._customShaderPropNames = _customShaderPropNames;
			StringBuilder stringBuilder = new StringBuilder();
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < objsToMesh.Count; i++)
			{
				GameObject gameObject = objsToMesh[i];
				if (gameObject == null)
				{
					continue;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(objsToMesh[i]);
				if (gOMaterials.Length > 1)
				{
					stringBuilder.AppendFormat("\nObject {0} uses {1} materials. Possible treatments:\n", objsToMesh[i].name, gOMaterials.Length);
					stringBuilder.AppendFormat("  1) Collapse the submeshes together into one submesh in the combined mesh. Each of the original submesh materials will map to a different UV rectangle in the atlas(es) used by the combined material.\n");
					stringBuilder.AppendFormat("  2) Use the multiple materials feature to map submeshes in the source mesh to submeshes in the combined mesh.\n");
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					MB_Utility.doSubmeshesShareVertsOrTris(mesh, ref value[0]);
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						value[j].hasOverlappingSubmeshTris = value[0].hasOverlappingSubmeshTris;
						value[j].hasOverlappingSubmeshVerts = value[0].hasOverlappingSubmeshVerts;
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					if (value[k].hasOutOfBoundsUVs)
					{
						DRect dRect = new DRect(value[k].uvRect);
						stringBuilder.AppendFormat("\nObject {0} submesh={1} material={2} uses UVs outside the range 0,0 .. 1,1 to create tiling that tiles the box {3},{4} .. {5},{6}. This is a problem because the UVs outside the 0,0 .. 1,1 rectangle will pick up neighboring textures in the atlas. Possible Treatments:\n", gameObject, k, gOMaterials[k], dRect.x.ToString("G4"), dRect.y.ToString("G4"), (dRect.x + dRect.width).ToString("G4"), (dRect.y + dRect.height).ToString("G4"));
						stringBuilder.AppendFormat("    1) Ignore the problem. The tiling may not affect result significantly.\n");
						stringBuilder.AppendFormat("    2) Use the 'fix out of bounds UVs' feature to bake the tiling and scale the UVs to fit in the 0,0 .. 1,1 rectangle.\n");
						stringBuilder.AppendFormat("    3) Use the Multiple Materials feature to map the material on this submesh to its own submesh in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
						stringBuilder.AppendFormat("    4) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
					}
				}
				if (value[0].hasOverlappingSubmeshVerts)
				{
					stringBuilder.AppendFormat("\nObject {0} has submeshes that share vertices. This is a problem because each vertex can have only one UV coordinate and may be required to map to different positions in the various atlases that are generated. Possible treatments:\n", objsToMesh[i]);
					stringBuilder.AppendFormat(" 1) Ignore the problem. The vertices may not affect the result.\n");
					stringBuilder.AppendFormat(" 2) Use the Multiple Materials feature to map the submeshs that overlap to their own submeshs in the combined mesh. No other materials should map to this submesh. This will result in only one texture in the atlas(es) and the UVs should tile correctly.\n");
					stringBuilder.AppendFormat(" 3) Combine only meshes that use the same (or subset of) the set of materials on this mesh. The original material(s) can be applied to the result\n");
				}
			}
			Dictionary<Material, List<GameObject>> dictionary2 = new Dictionary<Material, List<GameObject>>();
			for (int l = 0; l < objsToMesh.Count; l++)
			{
				if (!(objsToMesh[l] != null))
				{
					continue;
				}
				Material[] gOMaterials2 = MB_Utility.GetGOMaterials(objsToMesh[l]);
				for (int m = 0; m < gOMaterials2.Length; m++)
				{
					if (gOMaterials2[m] != null)
					{
						if (!dictionary2.TryGetValue(gOMaterials2[m], out var value2))
						{
							value2 = new List<GameObject>();
							dictionary2.Add(gOMaterials2[m], value2);
						}
						if (!value2.Contains(objsToMesh[l]))
						{
							value2.Add(objsToMesh[l]);
						}
					}
				}
			}
			for (int n = 0; n < resultMaterials.Length; n++)
			{
				string shaderName = ((resultMaterials[n] != null) ? "None" : resultMaterials[n].shader.name);
				MB3_TextureCombinerPipeline.TexturePipelineData texturePipelineData = LoadPipelineData(resultMaterials[n], new List<ShaderTextureProperty>(), objsToMesh, new List<Material>(), new List<MB_TexSet>());
				MB3_TextureCombinerPipeline._CollectPropertyNames(texturePipelineData, LOG_LEVEL);
				foreach (Material key in dictionary2.Keys)
				{
					for (int num = 0; num < texturePipelineData.texPropertyNames.Count; num++)
					{
						if (!key.HasProperty(texturePipelineData.texPropertyNames[num].name))
						{
							continue;
						}
						Texture textureConsideringStandardShaderKeywords = MB3_TextureCombinerPipeline.GetTextureConsideringStandardShaderKeywords(shaderName, key, texturePipelineData.texPropertyNames[num].name);
						if (textureConsideringStandardShaderKeywords != null)
						{
							Vector2 textureOffset = key.GetTextureOffset(texturePipelineData.texPropertyNames[num].name);
							Vector3 vector = key.GetTextureScale(texturePipelineData.texPropertyNames[num].name);
							if (textureOffset.x < 0f || textureOffset.x + vector.x > 1f || textureOffset.y < 0f || textureOffset.y + vector.y > 1f)
							{
								stringBuilder.AppendFormat("\nMaterial {0} used by objects {1} uses texture {2} that is tiled (scale={3} offset={4}). If there is more than one texture in the atlas  then Mesh Baker will bake the tiling into the atlas. If the baked tiling is large then quality can be lost. Possible treatments:\n", key, PrintList(dictionary2[key]), textureConsideringStandardShaderKeywords, vector, textureOffset);
								stringBuilder.AppendFormat("  1) Use the baked tiling.\n");
								stringBuilder.AppendFormat("  2) Use the Multiple Materials feature to map the material on this object/submesh to its own submesh in the combined mesh. No other materials should map to this submesh. The original material can be applied to this submesh.\n");
								stringBuilder.AppendFormat("  3) Combine only meshes that use the same (or subset of) the set of textures on this mesh. The original material can be applied to the result.\n");
							}
						}
					}
				}
			}
			string text = "";
			text = ((stringBuilder.Length != 0) ? ("====== There are possible problems with these meshes that may prevent them from combining well. TREATMENT SUGGESTIONS (copy and paste to text editor if too big) =====\n" + stringBuilder.ToString()) : "====== No problems detected. These meshes should combine well ====\n  If there are problems with the combined meshes please report the problem to digitalOpus.ca so we can improve Mesh Baker.");
			UnityEngine.Debug.Log(text);
		}

		private string PrintList(List<GameObject> gos)
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < gos.Count; i++)
			{
				stringBuilder.Append(string.Concat(gos[i], ","));
			}
			return stringBuilder.ToString();
		}
	}
	public class MeshBakerMaterialTexture
	{
		private Texture2D _t;

		public float texelDensity;

		internal static bool readyToBuildAtlases;

		private DRect encapsulatingSamplingRect;

		public Texture2D t
		{
			set
			{
				_t = value;
			}
		}

		public DRect matTilingRect { get; private set; }

		public bool isNull => _t == null;

		public int width
		{
			get
			{
				if (_t != null)
				{
					return _t.width;
				}
				throw new Exception("Texture was null. can't get width");
			}
		}

		public int height
		{
			get
			{
				if (_t != null)
				{
					return _t.height;
				}
				throw new Exception("Texture was null. can't get height");
			}
		}

		public MeshBakerMaterialTexture()
		{
		}

		public MeshBakerMaterialTexture(Texture tx)
		{
			if (tx is Texture2D)
			{
				_t = (Texture2D)tx;
			}
			else if (!(tx == null))
			{
				UnityEngine.Debug.LogError("An error occured. Texture must be Texture2D " + tx);
			}
		}

		public MeshBakerMaterialTexture(Texture tx, Vector2 matTilingOffset, Vector2 matTilingScale, float texelDens)
		{
			if (tx is Texture2D)
			{
				_t = (Texture2D)tx;
			}
			else if (!(tx == null))
			{
				UnityEngine.Debug.LogError("An error occured. Texture must be Texture2D " + tx);
			}
			matTilingRect = new DRect(matTilingOffset, matTilingScale);
			texelDensity = texelDens;
		}

		public DRect GetEncapsulatingSamplingRect()
		{
			return encapsulatingSamplingRect;
		}

		public void SetEncapsulatingSamplingRect(MB_TexSet ts, DRect r)
		{
			encapsulatingSamplingRect = r;
		}

		public Texture2D GetTexture2D()
		{
			if (!readyToBuildAtlases)
			{
				UnityEngine.Debug.LogError("This function should not be called before Step3. For steps 1 and 2 should always call methods like isNull, width, height");
				throw new Exception("GetTexture2D called before ready to build atlases");
			}
			return _t;
		}

		public string GetTexName()
		{
			if (_t != null)
			{
				return _t.name;
			}
			return "null";
		}

		public bool AreTexturesEqual(MeshBakerMaterialTexture b)
		{
			if (_t == b._t)
			{
				return true;
			}
			return false;
		}
	}
	public class MatAndTransformToMerged
	{
		public Material mat;

		public string objName;

		public DRect obUVRectIfTilingSame { get; private set; }

		public DRect samplingRectMatAndUVTiling { get; private set; }

		public DRect materialTiling { get; private set; }

		public MatAndTransformToMerged(DRect obUVrect, bool fixOutOfBoundsUVs)
		{
			_init(obUVrect, fixOutOfBoundsUVs, null);
		}

		public MatAndTransformToMerged(DRect obUVrect, bool fixOutOfBoundsUVs, Material m)
		{
			_init(obUVrect, fixOutOfBoundsUVs, m);
		}

		private void _init(DRect obUVrect, bool fixOutOfBoundsUVs, Material m)
		{
			if (fixOutOfBoundsUVs)
			{
				obUVRectIfTilingSame = obUVrect;
			}
			else
			{
				obUVRectIfTilingSame = new DRect(0f, 0f, 1f, 1f);
			}
			mat = m;
		}

		public override bool Equals(object obj)
		{
			if (obj is MatAndTransformToMerged)
			{
				MatAndTransformToMerged matAndTransformToMerged = (MatAndTransformToMerged)obj;
				if (matAndTransformToMerged.mat == mat && matAndTransformToMerged.obUVRectIfTilingSame == obUVRectIfTilingSame)
				{
					return true;
				}
			}
			return false;
		}

		public override int GetHashCode()
		{
			return mat.GetHashCode() ^ obUVRectIfTilingSame.GetHashCode() ^ samplingRectMatAndUVTiling.GetHashCode();
		}

		public string GetMaterialName()
		{
			if (mat != null)
			{
				return mat.name;
			}
			if (objName != null)
			{
				return $"[matFor: {objName}]";
			}
			return "Unknown";
		}

		public void AssignInitialValuesForMaterialTilingAndSamplingRectMatAndUVTiling(bool allTexturesUseSameMatTiling, DRect matTiling)
		{
			if (allTexturesUseSameMatTiling)
			{
				materialTiling = matTiling;
			}
			else
			{
				materialTiling = new DRect(0f, 0f, 1f, 1f);
			}
			DRect r = materialTiling;
			DRect r2 = obUVRectIfTilingSame;
			samplingRectMatAndUVTiling = MB3_UVTransformUtility.CombineTransforms(ref r2, ref r);
		}
	}
	public class MatsAndGOs
	{
		public List<MatAndTransformToMerged> mats;

		public List<GameObject> gos;
	}
	public class MB_TexSet
	{
		private interface PipelineVariation
		{
			void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect);

			void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment);

			Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex);

			void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props);
		}

		private class PipelineVariationAllTexturesUseSameMatTiling : PipelineVariation
		{
			private MB_TexSet texSet;

			public PipelineVariationAllTexturesUseSameMatTiling(MB_TexSet ts)
			{
				texSet = ts;
			}

			public void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
			{
				propsUseDifferntTiling_obUVRect = new Rect(0f, 0f, 0f, 0f);
				allPropsUseSameTiling_encapsulatingSamplingRect = texSet.GetEncapsulatingSamplingRectIfTilingSame();
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect.x = 0f;
					allPropsUseSameTiling_encapsulatingSamplingRect.width = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect.y = 0f;
					allPropsUseSameTiling_encapsulatingSamplingRect.height = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					allPropsUseSameTiling_encapsulatingSamplingRect = new Rect(0f, 0f, 1f, 1f);
				}
			}

			public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
			{
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj in ts)
					{
						DRect encapsulatingSamplingRect = obj.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect.width = 1.0;
						obj.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj2 in ts)
					{
						DRect encapsulatingSamplingRect2 = obj2.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect2.height = 1.0;
						obj2.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect2);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj3 in ts)
					{
						DRect encapsulatingSamplingRect3 = obj3.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect3.height = 1.0;
						encapsulatingSamplingRect3.width = 1.0;
						obj3.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect3);
					}
				}
			}

			public Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
			{
				return texSet.matsAndGOs.mats[materialIndex].materialTiling.GetRect();
			}

			public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
			{
			}
		}

		private class PipelineVariationSomeTexturesUseDifferentMatTiling : PipelineVariation
		{
			private MB_TexSet texSet;

			public PipelineVariationSomeTexturesUseDifferentMatTiling(MB_TexSet ts)
			{
				texSet = ts;
			}

			public void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
			{
				allPropsUseSameTiling_encapsulatingSamplingRect = new Rect(0f, 0f, 0f, 0f);
				propsUseDifferntTiling_obUVRect = texSet.obUVrect.GetRect();
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					propsUseDifferntTiling_obUVRect.x = 0f;
					propsUseDifferntTiling_obUVRect.width = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					propsUseDifferntTiling_obUVRect.y = 0f;
					propsUseDifferntTiling_obUVRect.height = 1f;
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					propsUseDifferntTiling_obUVRect = new Rect(0f, 0f, 1f, 1f);
				}
			}

			public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
			{
				if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeX)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj in ts)
					{
						DRect encapsulatingSamplingRect = obj.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect.width = 1.0;
						obj.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj2 in ts)
					{
						DRect encapsulatingSamplingRect2 = obj2.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect2.height = 1.0;
						obj2.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect2);
					}
				}
				else if (texSet.tilingTreatment == MB_TextureTilingTreatment.edgeToEdgeXY)
				{
					MeshBakerMaterialTexture[] ts = texSet.ts;
					foreach (MeshBakerMaterialTexture obj3 in ts)
					{
						DRect encapsulatingSamplingRect3 = obj3.GetEncapsulatingSamplingRect();
						encapsulatingSamplingRect3.height = 1.0;
						encapsulatingSamplingRect3.width = 1.0;
						obj3.SetEncapsulatingSamplingRect(texSet, encapsulatingSamplingRect3);
					}
				}
			}

			public Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
			{
				return new Rect(0f, 0f, 0f, 0f);
			}

			public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
			{
				if (!texSet.thisIsOnlyTexSetInAtlas)
				{
					return;
				}
				for (int i = 0; i < props.Count; i++)
				{
					if (resultMaterial.HasProperty(props[i].name))
					{
						resultMaterial.SetTextureOffset(props[i].name, texSet.ts[i].matTilingRect.min);
						resultMaterial.SetTextureScale(props[i].name, texSet.ts[i].matTilingRect.size);
					}
				}
			}
		}

		public MeshBakerMaterialTexture[] ts;

		public MatsAndGOs matsAndGOs;

		public int idealWidth;

		public int idealHeight;

		private PipelineVariation pipelineVariation;

		public bool allTexturesUseSameMatTiling { get; private set; }

		public bool thisIsOnlyTexSetInAtlas { get; private set; }

		public MB_TextureTilingTreatment tilingTreatment { get; private set; }

		public Vector2 obUVoffset { get; private set; }

		public Vector2 obUVscale { get; private set; }

		internal DRect obUVrect => new DRect(obUVoffset, obUVscale);

		public MB_TexSet(MeshBakerMaterialTexture[] tss, Vector2 uvOffset, Vector2 uvScale, MB_TextureTilingTreatment treatment)
		{
			ts = tss;
			tilingTreatment = treatment;
			obUVoffset = uvOffset;
			obUVscale = uvScale;
			allTexturesUseSameMatTiling = false;
			thisIsOnlyTexSetInAtlas = false;
			matsAndGOs = new MatsAndGOs();
			matsAndGOs.mats = new List<MatAndTransformToMerged>();
			matsAndGOs.gos = new List<GameObject>();
			pipelineVariation = new PipelineVariationSomeTexturesUseDifferentMatTiling(this);
		}

		internal bool IsEqual(object obj, bool fixOutOfBoundsUVs, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender)
		{
			if (!(obj is MB_TexSet))
			{
				return false;
			}
			MB_TexSet mB_TexSet = (MB_TexSet)obj;
			if (mB_TexSet.ts.Length != ts.Length)
			{
				return false;
			}
			for (int i = 0; i < ts.Length; i++)
			{
				if (ts[i].matTilingRect != mB_TexSet.ts[i].matTilingRect)
				{
					return false;
				}
				if (!ts[i].AreTexturesEqual(mB_TexSet.ts[i]))
				{
					return false;
				}
				if (!resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, mB_TexSet.matsAndGOs.mats[0].mat))
				{
					return false;
				}
			}
			if (fixOutOfBoundsUVs && (obUVoffset.x != mB_TexSet.obUVoffset.x || obUVoffset.y != mB_TexSet.obUVoffset.y))
			{
				return false;
			}
			if (fixOutOfBoundsUVs && (obUVscale.x != mB_TexSet.obUVscale.x || obUVscale.y != mB_TexSet.obUVscale.y))
			{
				return false;
			}
			return true;
		}

		private Rect GetEncapsulatingSamplingRectIfTilingSame()
		{
			if (ts.Length != 0)
			{
				return ts[0].GetEncapsulatingSamplingRect().GetRect();
			}
			return new Rect(0f, 0f, 1f, 1f);
		}

		public void SetEncapsulatingSamplingRectWhenMergingTexSets(DRect newEncapsulatingSamplingRect)
		{
			for (int i = 0; i < ts.Length; i++)
			{
				ts[i].SetEncapsulatingSamplingRect(this, newEncapsulatingSamplingRect);
			}
		}

		public void SetEncapsulatingSamplingRectForTesting(int propIdx, DRect newEncapsulatingSamplingRect)
		{
			ts[propIdx].SetEncapsulatingSamplingRect(this, newEncapsulatingSamplingRect);
		}

		public void SetEncapsulatingRect(int propIdx, bool considerMeshUVs)
		{
			if (considerMeshUVs)
			{
				ts[propIdx].SetEncapsulatingSamplingRect(this, obUVrect);
			}
			else
			{
				ts[propIdx].SetEncapsulatingSamplingRect(this, new DRect(0f, 0f, 1f, 1f));
			}
		}

		public void CreateColoredTexToReplaceNull(string propName, int propIdx, bool considerMeshUVs, MB3_TextureCombiner combiner, Color col)
		{
			MeshBakerMaterialTexture obj = ts[propIdx];
			obj.t = combiner._createTemporaryTexture(propName, 16, 16, TextureFormat.ARGB32, mipMaps: true);
			MB_Utility.setSolidColor(obj.GetTexture2D(), col);
		}

		public void SetThisIsOnlyTexSetInAtlasTrue()
		{
			thisIsOnlyTexSetInAtlas = true;
		}

		public void SetAllTexturesUseSameMatTilingTrue()
		{
			allTexturesUseSameMatTiling = true;
			pipelineVariation = new PipelineVariationAllTexturesUseSameMatTiling(this);
		}

		public void AdjustResultMaterialNonTextureProperties(Material resultMaterial, List<ShaderTextureProperty> props)
		{
			pipelineVariation.AdjustResultMaterialNonTextureProperties(resultMaterial, props);
		}

		public void SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment newTilingTreatment)
		{
			tilingTreatment = newTilingTreatment;
			pipelineVariation.SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(newTilingTreatment);
		}

		internal void GetRectsForTextureBakeResults(out Rect allPropsUseSameTiling_encapsulatingSamplingRect, out Rect propsUseDifferntTiling_obUVRect)
		{
			pipelineVariation.GetRectsForTextureBakeResults(out allPropsUseSameTiling_encapsulatingSamplingRect, out propsUseDifferntTiling_obUVRect);
		}

		internal Rect GetMaterialTilingRectForTextureBakerResults(int materialIndex)
		{
			return pipelineVariation.GetMaterialTilingRectForTextureBakerResults(materialIndex);
		}

		internal void CalcInitialFullSamplingRects(bool fixOutOfBoundsUVs)
		{
			DRect r = new DRect(0f, 0f, 1f, 1f);
			if (fixOutOfBoundsUVs)
			{
				r = obUVrect;
			}
			for (int i = 0; i < ts.Length; i++)
			{
				if (!ts[i].isNull)
				{
					DRect r2 = ts[i].matTilingRect;
					DRect r3 = ((!fixOutOfBoundsUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : obUVrect);
					ts[i].SetEncapsulatingSamplingRect(this, MB3_UVTransformUtility.CombineTransforms(ref r3, ref r2));
					r = ts[i].GetEncapsulatingSamplingRect();
				}
			}
			for (int j = 0; j < ts.Length; j++)
			{
				if (ts[j].isNull)
				{
					ts[j].SetEncapsulatingSamplingRect(this, r);
				}
			}
		}

		internal void CalcMatAndUVSamplingRects()
		{
			DRect matTiling = new DRect(0f, 0f, 1f, 1f);
			if (allTexturesUseSameMatTiling)
			{
				for (int i = 0; i < ts.Length; i++)
				{
					if (!ts[i].isNull)
					{
						matTiling = ts[i].matTilingRect;
						break;
					}
				}
			}
			for (int j = 0; j < matsAndGOs.mats.Count; j++)
			{
				matsAndGOs.mats[j].AssignInitialValuesForMaterialTilingAndSamplingRectMatAndUVTiling(allTexturesUseSameMatTiling, matTiling);
			}
		}

		public bool AllTexturesAreSameForMerge(MB_TexSet other, bool considerNonTextureProperties, MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender)
		{
			if (other.ts.Length != ts.Length)
			{
				return false;
			}
			if (!other.allTexturesUseSameMatTiling || !allTexturesUseSameMatTiling)
			{
				return false;
			}
			int num = -1;
			for (int i = 0; i < ts.Length; i++)
			{
				if (!ts[i].AreTexturesEqual(other.ts[i]))
				{
					return false;
				}
				if (num == -1 && !ts[i].isNull)
				{
					num = i;
				}
				if (considerNonTextureProperties && !resultMaterialTextureBlender.NonTexturePropertiesAreEqual(matsAndGOs.mats[0].mat, other.matsAndGOs.mats[0].mat))
				{
					return false;
				}
			}
			if (num != -1)
			{
				for (int j = 0; j < ts.Length; j++)
				{
					if (!ts[j].AreTexturesEqual(other.ts[j]))
					{
						return false;
					}
				}
			}
			return true;
		}

		internal void DrawRectsToMergeGizmos(Color encC, Color innerC)
		{
			DRect A = ts[0].GetEncapsulatingSamplingRect();
			A.Expand(0.05f);
			Gizmos.color = encC;
			Gizmos.DrawWireCube(A.center.GetVector2(), A.size);
			for (int i = 0; i < matsAndGOs.mats.Count; i++)
			{
				DRect B = matsAndGOs.mats[i].samplingRectMatAndUVTiling;
				DRect r = MB3_UVTransformUtility.GetShiftTransformToFitBinA(ref A, ref B);
				Vector2 vector = MB3_UVTransformUtility.TransformPoint(ref r, B.min);
				B.x = vector.x;
				B.y = vector.y;
				Gizmos.color = innerC;
				Gizmos.DrawWireCube(B.center.GetVector2(), B.size);
			}
		}

		internal string GetDescription()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendFormat("[GAME_OBJS=");
			for (int i = 0; i < matsAndGOs.gos.Count; i++)
			{
				stringBuilder.AppendFormat("{0},", matsAndGOs.gos[i].name);
			}
			stringBuilder.AppendFormat("MATS=");
			for (int j = 0; j < matsAndGOs.mats.Count; j++)
			{
				stringBuilder.AppendFormat("{0},", matsAndGOs.mats[j].GetMaterialName());
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}

		internal string GetMatSubrectDescriptions()
		{
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < matsAndGOs.mats.Count; i++)
			{
				stringBuilder.AppendFormat("\n    {0}={1},", matsAndGOs.mats[i].GetMaterialName(), matsAndGOs.mats[i].samplingRectMatAndUVTiling);
			}
			return stringBuilder.ToString();
		}
	}
	public class MB3_TextureCombinerMerging
	{
		private bool _considerNonTextureProperties;

		private MB3_TextureCombinerNonTextureProperties resultMaterialTextureBlender;

		private bool fixOutOfBoundsUVs = true;

		public MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private static bool LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS;

		public static Rect BuildTransformMeshUV2AtlasRect(bool considerMeshUVs, Rect _atlasRect, Rect _obUVRect, Rect _sourceMaterialTiling, Rect _encapsulatingRect)
		{
			DRect r = new DRect(_atlasRect);
			DRect t = ((!considerMeshUVs) ? new DRect(0.0, 0.0, 1.0, 1.0) : new DRect(_obUVRect));
			DRect r2 = new DRect(_sourceMaterialTiling);
			DRect t2 = new DRect(_encapsulatingRect);
			DRect r3 = MB3_UVTransformUtility.InverseTransform(ref t2);
			DRect r4 = MB3_UVTransformUtility.InverseTransform(ref t);
			DRect B = MB3_UVTransformUtility.CombineTransforms(ref t, ref r2);
			DRect r5 = MB3_UVTransformUtility.GetShiftTransformToFitBinA(ref t2, ref B);
			B = MB3_UVTransformUtility.CombineTransforms(ref B, ref r5);
			DRect r6 = MB3_UVTransformUtility.CombineTransforms(ref B, ref r3);
			DRect r7 = MB3_UVTransformUtility.CombineTransforms(ref r4, ref r6);
			return MB3_UVTransformUtility.CombineTransforms(ref r7, ref r).GetRect();
		}

		public MB3_TextureCombinerMerging(bool considerNonTextureProps, MB3_TextureCombinerNonTextureProperties resultMaterialTexBlender, bool fixObUVs, MB2_LogLevel logLevel)
		{
			LOG_LEVEL = logLevel;
			_considerNonTextureProperties = considerNonTextureProps;
			resultMaterialTextureBlender = resultMaterialTexBlender;
			fixOutOfBoundsUVs = fixObUVs;
		}

		public void MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects");
			}
			int num = 0;
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				int num2 = -1;
				bool flag = true;
				DRect dRect = default(DRect);
				for (int j = 0; j < mB_TexSet.ts.Length; j++)
				{
					if (num2 != -1)
					{
						if (!mB_TexSet.ts[j].isNull && dRect != mB_TexSet.ts[j].matTilingRect)
						{
							flag = false;
						}
					}
					else if (!mB_TexSet.ts[j].isNull)
					{
						num2 = j;
						dRect = mB_TexSet.ts[j].matTilingRect;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.debug || LOG_LEVEL_TRACE_MERGE_MAT_SUBRECTS)
				{
					if (flag)
					{
						UnityEngine.Debug.LogFormat("TextureSet {0} allTexturesUseSameMatTiling = {1}", i, flag);
					}
					else
					{
						UnityEngine.Debug.Log($"Textures in material(s) do not all use the same material tiling. This set of textures will not be considered for merge: {mB_TexSet.GetDescription()} ");
					}
				}
				if (flag)
				{
					mB_TexSet.SetAllTexturesUseSameMatTilingTrue();
				}
			}
			for (int k = 0; k < distinctMaterialTextures.Count; k++)
			{
				MB_TexSet mB_TexSet2 = distinctMaterialTextures[k];
				for (int l = 0; l < mB_TexSet2.matsAndGOs.mats.Count; l++)
				{
					if (mB_TexSet2.matsAndGOs.gos.Count > 0)
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = mB_TexSet2.matsAndGOs.gos[0].name;
					}
					else if (mB_TexSet2.ts[0] != null)
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = $"[objWithTx:{mB_TexSet2.ts[0].GetTexName()} atlasBlock:{k} matIdx{l}]";
					}
					else
					{
						mB_TexSet2.matsAndGOs.mats[l].objName = string.Format("[objWithTx:{0} atlasBlock:{1} matIdx{2}]", "Unknown", k, l);
					}
				}
				mB_TexSet2.CalcInitialFullSamplingRects(fixOutOfBoundsUVs);
				mB_TexSet2.CalcMatAndUVSamplingRects();
			}
			List<int> list = new List<int>();
			for (int m = 0; m < distinctMaterialTextures.Count; m++)
			{
				MB_TexSet mB_TexSet3 = distinctMaterialTextures[m];
				for (int n = m + 1; n < distinctMaterialTextures.Count; n++)
				{
					MB_TexSet mB_TexSet4 = distinctMaterialTextures[n];
					if (!mB_TexSet4.AllTexturesAreSameForMerge(mB_TexSet3, _considerNonTextureProperties, resultMaterialTextureBlender))
					{
						continue;
					}
					double num3 = 0.0;
					double num4 = 0.0;
					DRect dRect2 = default(DRect);
					int num5 = -1;
					for (int num6 = 0; num6 < mB_TexSet3.ts.Length; num6++)
					{
						if (!mB_TexSet3.ts[num6].isNull && num5 == -1)
						{
							num5 = num6;
						}
					}
					if (num5 != -1)
					{
						DRect uvRect = mB_TexSet4.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num7 = 1; num7 < mB_TexSet4.matsAndGOs.mats.Count; num7++)
						{
							DRect willBeIn = mB_TexSet4.matsAndGOs.mats[num7].samplingRectMatAndUVTiling;
							uvRect = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect, ref willBeIn);
						}
						DRect uvRect2 = mB_TexSet3.matsAndGOs.mats[0].samplingRectMatAndUVTiling;
						for (int num8 = 1; num8 < mB_TexSet3.matsAndGOs.mats.Count; num8++)
						{
							DRect willBeIn2 = mB_TexSet3.matsAndGOs.mats[num8].samplingRectMatAndUVTiling;
							uvRect2 = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect2, ref willBeIn2);
						}
						dRect2 = MB3_UVTransformUtility.GetEncapsulatingRectShifted(ref uvRect, ref uvRect2);
						num3 += dRect2.width * dRect2.height;
						num4 += uvRect.width * uvRect.height + uvRect2.width * uvRect2.height;
					}
					else
					{
						dRect2 = new DRect(0f, 0f, 1f, 1f);
					}
					if (num3 < num4)
					{
						num++;
						StringBuilder stringBuilder = null;
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							stringBuilder = new StringBuilder();
							stringBuilder.AppendFormat("About To Merge:\n   TextureSet1 {0}\n   TextureSet2 {1}\n", mB_TexSet4.GetDescription(), mB_TexSet3.GetDescription());
							if (LOG_LEVEL >= MB2_LogLevel.trace)
							{
								for (int num9 = 0; num9 < mB_TexSet4.matsAndGOs.mats.Count; num9++)
								{
									stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num9].mat, mB_TexSet4.matsAndGOs.mats[num9].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].GetEncapsulatingSamplingRect());
								}
								for (int num10 = 0; num10 < mB_TexSet3.matsAndGOs.mats.Count; num10++)
								{
									stringBuilder.AppendFormat("tx2 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet3.matsAndGOs.mats[num10].mat, mB_TexSet3.matsAndGOs.mats[num10].samplingRectMatAndUVTiling, mB_TexSet3.ts[0].GetEncapsulatingSamplingRect());
								}
							}
						}
						for (int num11 = 0; num11 < mB_TexSet3.matsAndGOs.gos.Count; num11++)
						{
							if (!mB_TexSet4.matsAndGOs.gos.Contains(mB_TexSet3.matsAndGOs.gos[num11]))
							{
								mB_TexSet4.matsAndGOs.gos.Add(mB_TexSet3.matsAndGOs.gos[num11]);
							}
						}
						for (int num12 = 0; num12 < mB_TexSet3.matsAndGOs.mats.Count; num12++)
						{
							mB_TexSet4.matsAndGOs.mats.Add(mB_TexSet3.matsAndGOs.mats[num12]);
						}
						mB_TexSet4.SetEncapsulatingSamplingRectWhenMergingTexSets(dRect2);
						if (!list.Contains(m))
						{
							list.Add(m);
						}
						if (LOG_LEVEL < MB2_LogLevel.debug)
						{
							break;
						}
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							stringBuilder.AppendFormat("=== After Merge TextureSet {0}\n", mB_TexSet4.GetDescription());
							for (int num13 = 0; num13 < mB_TexSet4.matsAndGOs.mats.Count; num13++)
							{
								stringBuilder.AppendFormat("tx1 Mat {0} matAndMeshUVRect {1} fullSamplingRect {2}\n", mB_TexSet4.matsAndGOs.mats[num13].mat, mB_TexSet4.matsAndGOs.mats[num13].samplingRectMatAndUVTiling, mB_TexSet4.ts[0].GetEncapsulatingSamplingRect());
							}
							if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS && MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
							{
								DoIntegrityCheckMergedEncapsulatingSamplingRects(distinctMaterialTextures);
							}
						}
						UnityEngine.Debug.Log(stringBuilder.ToString());
						break;
					}
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log($"Considered merging {mB_TexSet4.GetDescription()} and {mB_TexSet3.GetDescription()} but there was not enough overlap. It is more efficient to bake these to separate rectangles.");
					}
				}
			}
			for (int num14 = list.Count - 1; num14 >= 0; num14--)
			{
				distinctMaterialTextures.RemoveAt(list[num14]);
			}
			list.Clear();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects complete merged {num} now have {distinctMaterialTextures.Count}");
			}
			if (MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				DoIntegrityCheckMergedEncapsulatingSamplingRects(distinctMaterialTextures);
			}
		}

		public void DoIntegrityCheckMergedEncapsulatingSamplingRects(List<MB_TexSet> distinctMaterialTextures)
		{
			if (!MB3_MeshBakerRoot.DO_INTEGRITY_CHECKS)
			{
				return;
			}
			for (int i = 0; i < distinctMaterialTextures.Count; i++)
			{
				MB_TexSet mB_TexSet = distinctMaterialTextures[i];
				if (!mB_TexSet.allTexturesUseSameMatTiling)
				{
					continue;
				}
				for (int j = 0; j < mB_TexSet.matsAndGOs.mats.Count; j++)
				{
					MatAndTransformToMerged matAndTransformToMerged = mB_TexSet.matsAndGOs.mats[j];
					DRect obUVRectIfTilingSame = matAndTransformToMerged.obUVRectIfTilingSame;
					DRect materialTiling = matAndTransformToMerged.materialTiling;
					if (!MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(mB_TexSet.tilingTreatment, obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect(), MB2_LogLevel.info))
					{
						UnityEngine.Debug.LogErrorFormat(string.Concat("mesh ", mB_TexSet.matsAndGOs.mats[j].objName, "\n uv=", obUVRectIfTilingSame, "\n mat=", materialTiling.GetRect().ToString("f5"), "\n samplingRect=", mB_TexSet.matsAndGOs.mats[j].samplingRectMatAndUVTiling.GetRect().ToString("f4"), "\n encapsulatingRect ", mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect().ToString("f4"), "\n"));
						UnityEngine.Debug.LogErrorFormat(string.Format("Integrity check failed. " + mB_TexSet.matsAndGOs.mats[j].objName + " Encapsulating sampling rect failed to contain potentialRect\n"));
						MB2_TextureBakeResults.IsMeshAndMaterialRectEnclosedByAtlasRect(mB_TexSet.tilingTreatment, obUVRectIfTilingSame.GetRect(), materialTiling.GetRect(), mB_TexSet.ts[0].GetEncapsulatingSamplingRect().GetRect(), MB2_LogLevel.trace);
					}
				}
			}
		}
	}
	public class MB3_TextureCombinerNonTextureProperties
	{
		public interface MaterialProperty
		{
			string PropertyName { get; set; }

			MaterialPropertyValueAveraged GetAverageCalculator();

			object GetDefaultValue();
		}

		public class MaterialPropertyFloat : MaterialProperty
		{
			private MaterialPropertyValueAveragedFloat _averageCalc;

			private float _defaultValue;

			public string PropertyName { get; set; }

			public MaterialPropertyFloat(string name, float defValue)
			{
				_averageCalc = new MaterialPropertyValueAveragedFloat();
				_defaultValue = defValue;
				PropertyName = name;
			}

			public MaterialPropertyValueAveraged GetAverageCalculator()
			{
				return _averageCalc;
			}

			public object GetDefaultValue()
			{
				return _defaultValue;
			}
		}

		public class MaterialPropertyColor : MaterialProperty
		{
			private MaterialPropertyValueAveragedColor _averageCalc;

			private Color _defaultValue;

			public string PropertyName { get; set; }

			public MaterialPropertyColor(string name, Color defaultVal)
			{
				_averageCalc = new MaterialPropertyValueAveragedColor();
				_defaultValue = defaultVal;
				PropertyName = name;
			}

			public MaterialPropertyValueAveraged GetAverageCalculator()
			{
				return _averageCalc;
			}

			public object GetDefaultValue()
			{
				return _defaultValue;
			}
		}

		public interface MaterialPropertyValueAveraged
		{
			void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property);

			object GetAverage();

			int NumValues();

			void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property);
		}

		public class MaterialPropertyValueAveragedFloat : MaterialPropertyValueAveraged
		{
			public float averageVal;

			public int numValues;

			public void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					float @float = mat.GetFloat(property.PropertyName);
					averageVal = averageVal * (float)numValues / (float)(numValues + 1) + @float / (float)(numValues + 1);
					numValues++;
				}
			}

			public object GetAverage()
			{
				return averageVal;
			}

			public int NumValues()
			{
				return numValues;
			}

			public void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					if (numValues > 0)
					{
						mat.SetFloat(property.PropertyName, averageVal);
					}
					else
					{
						mat.SetFloat(property.PropertyName, (float)property.GetDefaultValue());
					}
				}
			}
		}

		public class MaterialPropertyValueAveragedColor : MaterialPropertyValueAveraged
		{
			public Color averageVal;

			public int numValues;

			public void TryGetPropValueFromMaterialAndBlendIntoAverage(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					Color color = mat.GetColor(property.PropertyName);
					averageVal = averageVal * numValues / (numValues + 1) + color / (numValues + 1);
					numValues++;
				}
			}

			public object GetAverage()
			{
				return averageVal;
			}

			public int NumValues()
			{
				return numValues;
			}

			public void SetAverageValueOrDefaultOnMaterial(Material mat, MaterialProperty property)
			{
				if (mat.HasProperty(property.PropertyName))
				{
					if (numValues > 0)
					{
						mat.SetColor(property.PropertyName, averageVal);
					}
					else
					{
						mat.SetColor(property.PropertyName, (Color)property.GetDefaultValue());
					}
				}
			}
		}

		public struct TexPropertyNameColorPair
		{
			public string name;

			public Color color;

			public TexPropertyNameColorPair(string nm, Color col)
			{
				name = nm;
				color = col;
			}
		}

		private interface NonTextureProperties
		{
			bool NonTexturePropertiesAreEqual(Material a, Material b);

			Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName);

			void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods);

			Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty);

			Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty);
		}

		private class NonTexturePropertiesDontBlendProps : NonTextureProperties
		{
			private MB3_TextureCombinerNonTextureProperties _textureProperties;

			public NonTexturePropertiesDontBlendProps(MB3_TextureCombinerNonTextureProperties textureProperties)
			{
				_textureProperties = textureProperties;
			}

			public bool NonTexturePropertiesAreEqual(Material a, Material b)
			{
				return true;
			}

			public Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
			{
				UnityEngine.Debug.LogError("TintTextureWithTextureCombiner should never be called if resultMaterialTextureBlender is null");
				return t;
			}

			public void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
			{
				if (resultMat == null || texPropertyNames == null)
				{
					return;
				}
				for (int i = 0; i < _textureProperties._nonTextureProperties.Length; i++)
				{
					MaterialProperty materialProperty = _textureProperties._nonTextureProperties[i];
					if (resultMat.HasProperty(materialProperty.PropertyName))
					{
						materialProperty.GetAverageCalculator().SetAverageValueOrDefaultOnMaterial(resultMat, materialProperty);
					}
				}
				editorMethods?.CommitChangesToAssets();
			}

			public Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				return Color.white;
			}

			public Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				if (texProperty.isNormalMap)
				{
					return NEUTRAL_NORMAL_MAP_COLOR;
				}
				if (_textureProperties.textureProperty2DefaultColorMap.ContainsKey(texProperty.name))
				{
					return _textureProperties.textureProperty2DefaultColorMap[texProperty.name];
				}
				return new Color(1f, 1f, 1f, 0f);
			}
		}

		private class NonTexturePropertiesBlendProps : NonTextureProperties
		{
			private MB3_TextureCombinerNonTextureProperties _textureProperties;

			private TextureBlender resultMaterialTextureBlender;

			public NonTexturePropertiesBlendProps(MB3_TextureCombinerNonTextureProperties textureProperties, TextureBlender resultMats)
			{
				resultMaterialTextureBlender = resultMats;
				_textureProperties = textureProperties;
			}

			public bool NonTexturePropertiesAreEqual(Material a, Material b)
			{
				return resultMaterialTextureBlender.NonTexturePropertiesAreEqual(a, b);
			}

			public Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
			{
				resultMaterialTextureBlender.OnBeforeTintTexture(sourceMaterial.matsAndGOs.mats[0].mat, shaderPropertyName.name);
				if (_textureProperties.LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Blending texture {t.name} mat {sourceMaterial.matsAndGOs.mats[0].mat} with non-texture properties using TextureBlender {resultMaterialTextureBlender}");
				}
				for (int i = 0; i < t.height; i++)
				{
					Color[] pixels = t.GetPixels(0, i, t.width, 1);
					for (int j = 0; j < pixels.Length; j++)
					{
						pixels[j] = resultMaterialTextureBlender.OnBlendTexturePixel(shaderPropertyName.name, pixels[j]);
					}
					t.SetPixels(0, i, t.width, 1, pixels);
				}
				t.Apply();
				return t;
			}

			public void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
			{
				if (!(resultMat == null) && texPropertyNames != null)
				{
					if (_textureProperties.LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Adjusting non texture properties using TextureBlender for shader: " + resultMat.shader.name);
					}
					resultMaterialTextureBlender.SetNonTexturePropertyValuesOnResultMaterial(resultMat);
					editorMethods?.CommitChangesToAssets();
				}
			}

			public Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				resultMaterialTextureBlender.OnBeforeTintTexture(matIfBlender, texProperty.name);
				Color colorForTemporaryTexture = GetColorForTemporaryTexture(matIfBlender, texProperty);
				return resultMaterialTextureBlender.OnBlendTexturePixel(texProperty.name, colorForTemporaryTexture);
			}

			public Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
			{
				return resultMaterialTextureBlender.GetColorIfNoTexture(matIfBlender, texProperty);
			}
		}

		public static Color NEUTRAL_NORMAL_MAP_COLOR = new Color(0.5f, 0.5f, 1f);

		private TexPropertyNameColorPair[] defaultTextureProperty2DefaultColorMap = new TexPropertyNameColorPair[6]
		{
			new TexPropertyNameColorPair("_MainTex", new Color(1f, 1f, 1f, 0f)),
			new TexPropertyNameColorPair("_MetallicGlossMap", new Color(0f, 0f, 0f, 1f)),
			new TexPropertyNameColorPair("_ParallaxMap", new Color(0f, 0f, 0f, 0f)),
			new TexPropertyNameColorPair("_OcclusionMap", new Color(1f, 1f, 1f, 1f)),
			new TexPropertyNameColorPair("_EmissionMap", new Color(0f, 0f, 0f, 0f)),
			new TexPropertyNameColorPair("_DetailMask", new Color(0f, 0f, 0f, 0f))
		};

		private MaterialProperty[] _nonTextureProperties = new MaterialProperty[8]
		{
			new MaterialPropertyColor("_Color", Color.white),
			new MaterialPropertyFloat("_Glossiness", 0.5f),
			new MaterialPropertyFloat("_GlossMapScale", 1f),
			new MaterialPropertyFloat("_Metallic", 0f),
			new MaterialPropertyFloat("_BumpScale", 0.1f),
			new MaterialPropertyFloat("_Parallax", 0.02f),
			new MaterialPropertyFloat("_OcclusionStrength", 1f),
			new MaterialPropertyColor("_EmissionColor", Color.black)
		};

		private MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info;

		private bool _considerNonTextureProperties;

		private TextureBlender resultMaterialTextureBlender;

		private TextureBlender[] textureBlenders = new TextureBlender[0];

		private Dictionary<string, Color> textureProperty2DefaultColorMap = new Dictionary<string, Color>();

		private NonTextureProperties _nonTexturePropertiesBlender;

		public MB3_TextureCombinerNonTextureProperties(MB2_LogLevel ll, bool considerNonTextureProps)
		{
			LOG_LEVEL = ll;
			_considerNonTextureProperties = considerNonTextureProps;
			textureProperty2DefaultColorMap = new Dictionary<string, Color>();
			for (int i = 0; i < defaultTextureProperty2DefaultColorMap.Length; i++)
			{
				textureProperty2DefaultColorMap.Add(defaultTextureProperty2DefaultColorMap[i].name, defaultTextureProperty2DefaultColorMap[i].color);
				_nonTexturePropertiesBlender = new NonTexturePropertiesDontBlendProps(this);
			}
		}

		internal void CollectAverageValuesOfNonTextureProperties(Material resultMaterial, Material mat)
		{
			for (int i = 0; i < _nonTextureProperties.Length; i++)
			{
				MaterialProperty materialProperty = _nonTextureProperties[i];
				if (resultMaterial.HasProperty(materialProperty.PropertyName))
				{
					materialProperty.GetAverageCalculator().TryGetPropValueFromMaterialAndBlendIntoAverage(mat, materialProperty);
				}
			}
		}

		internal void LoadTextureBlendersIfNeeded(Material resultMaterial)
		{
			if (_considerNonTextureProperties)
			{
				LoadTextureBlenders();
				FindBestTextureBlender(resultMaterial);
			}
		}

		private static bool InterfaceFilter(Type typeObj, object criteriaObj)
		{
			return typeObj.ToString() == criteriaObj.ToString();
		}

		private void FindBestTextureBlender(Material resultMaterial)
		{
			resultMaterialTextureBlender = FindMatchingTextureBlender(resultMaterial.shader.name);
			if (resultMaterialTextureBlender != null)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Using _considerNonTextureProperties found a TextureBlender for result material. Using: " + resultMaterialTextureBlender);
				}
			}
			else
			{
				if (LOG_LEVEL >= MB2_LogLevel.error)
				{
					UnityEngine.Debug.LogWarning("Using _considerNonTextureProperties could not find a TextureBlender that matches the shader on the result material. Using the Fallback Texture Blender.");
				}
				resultMaterialTextureBlender = new TextureBlenderFallback();
			}
			_nonTexturePropertiesBlender = new NonTexturePropertiesBlendProps(this, resultMaterialTextureBlender);
		}

		private void LoadTextureBlenders()
		{
			string filterCriteria = "DigitalOpus.MB.Core.TextureBlender";
			TypeFilter filter = InterfaceFilter;
			List<Type> list = new List<Type>();
			Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
			foreach (Assembly assembly in assemblies)
			{
				IEnumerable enumerable = null;
				try
				{
					enumerable = assembly.GetTypes();
				}
				catch (Exception ex)
				{
					ex.Equals(null);
				}
				if (enumerable == null)
				{
					continue;
				}
				Type[] types = assembly.GetTypes();
				foreach (Type type in types)
				{
					if (type.FindInterfaces(filter, filterCriteria).Length != 0)
					{
						list.Add(type);
					}
				}
			}
			TextureBlender textureBlender = null;
			List<TextureBlender> list2 = new List<TextureBlender>();
			foreach (Type item in list)
			{
				if (!item.IsAbstract && !item.IsInterface)
				{
					TextureBlender textureBlender2 = (TextureBlender)Activator.CreateInstance(item);
					if (textureBlender2 is TextureBlenderFallback)
					{
						textureBlender = textureBlender2;
					}
					else
					{
						list2.Add(textureBlender2);
					}
				}
			}
			if (textureBlender != null)
			{
				list2.Add(textureBlender);
			}
			textureBlenders = list2.ToArray();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Loaded {textureBlenders.Length} TextureBlenders.");
			}
		}

		internal bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return _nonTexturePropertiesBlender.NonTexturePropertiesAreEqual(a, b);
		}

		internal Texture2D TintTextureWithTextureCombiner(Texture2D t, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName)
		{
			return _nonTexturePropertiesBlender.TintTextureWithTextureCombiner(t, sourceMaterial, shaderPropertyName);
		}

		internal void AdjustNonTextureProperties(Material resultMat, List<ShaderTextureProperty> texPropertyNames, List<MB_TexSet> distinctMaterialTextures, MB2_EditorMethodsInterface editorMethods)
		{
			if (!(resultMat == null) && texPropertyNames != null)
			{
				_nonTexturePropertiesBlender.AdjustNonTextureProperties(resultMat, texPropertyNames, distinctMaterialTextures, editorMethods);
			}
		}

		internal Color GetColorAsItWouldAppearInAtlasIfNoTexture(Material matIfBlender, ShaderTextureProperty texProperty)
		{
			return _nonTexturePropertiesBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(matIfBlender, texProperty);
		}

		internal Color GetColorForTemporaryTexture(Material matIfBlender, ShaderTextureProperty texProperty)
		{
			return _nonTexturePropertiesBlender.GetColorForTemporaryTexture(matIfBlender, texProperty);
		}

		private TextureBlender FindMatchingTextureBlender(string shaderName)
		{
			for (int i = 0; i < textureBlenders.Length; i++)
			{
				if (textureBlenders[i].DoesShaderNameMatch(shaderName))
				{
					return textureBlenders[i];
				}
			}
			return null;
		}
	}
	internal class MB3_TextureCombinerPackerMeshBaker : MB3_TextureCombinerPackerRoot
	{
		public override IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Rect[] uvRects = packedAtlasRects.rects;
			int atlasSizeX = packedAtlasRects.atlasX;
			int atlasSizeY = packedAtlasRects.atlasY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Generated atlas will be " + atlasSizeX + "x" + atlasSizeY);
			}
			for (int propIdx = 0; propIdx < data.numAtlases; propIdx++)
			{
				ShaderTextureProperty property = data.texPropertyNames[propIdx];
				Texture2D texture2D;
				if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(propIdx, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					texture2D = null;
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("=== Not creating atlas for " + property.name + " because textures are null and default value parameters are the same.");
					}
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("=== Creating atlas for " + property.name);
					}
					GC.Collect();
					MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, propIdx, data);
					Color[][] atlasPixels = new Color[atlasSizeY][];
					for (int i = 0; i < atlasPixels.Length; i++)
					{
						atlasPixels[i] = new Color[atlasSizeX];
					}
					bool isNormalMap = false;
					if (property.isNormalMap)
					{
						isNormalMap = true;
					}
					for (int texSetIdx = 0; texSetIdx < data.distinctMaterialTextures.Count; texSetIdx++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[texSetIdx];
						MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[propIdx];
						string text = "Creating Atlas '" + property.name + "' texture " + meshBakerMaterialTexture.GetTexName();
						progressInfo?.Invoke(text, 0.01f);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log($"Adding texture {meshBakerMaterialTexture.GetTexName()} to atlas {property.name} for texSet {texSetIdx} srcMat {mB_TexSet.matsAndGOs.mats[0].GetMaterialName()}");
						}
						Rect rect = uvRects[texSetIdx];
						Texture2D texture2D2 = mB_TexSet.ts[propIdx].GetTexture2D();
						int targX = Mathf.RoundToInt(rect.x * (float)atlasSizeX);
						int targY = Mathf.RoundToInt(rect.y * (float)atlasSizeY);
						int num = Mathf.RoundToInt(rect.width * (float)atlasSizeX);
						int num2 = Mathf.RoundToInt(rect.height * (float)atlasSizeY);
						if (num == 0 || num2 == 0)
						{
							UnityEngine.Debug.LogError("Image in atlas has no height or width " + rect);
						}
						progressInfo?.Invoke(text + " set ReadWrite flag", 0.01f);
						textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
						progressInfo?.Invoke(text + "Copying to atlas: '" + meshBakerMaterialTexture.GetTexName() + "'", 0.02f);
						DRect encapsulatingSamplingRect = mB_TexSet.ts[propIdx].GetEncapsulatingSamplingRect();
						yield return CopyScaledAndTiledToAtlas(mB_TexSet.ts[propIdx], mB_TexSet, property, encapsulatingSamplingRect, targX, targY, num, num2, packedAtlasRects.padding[texSetIdx], atlasPixels, isNormalMap, data, combiner, progressInfo, LOG_LEVEL);
					}
					yield return data.numAtlases;
					progressInfo?.Invoke("Applying changes to atlas: '" + property.name + "'", 0.03f);
					texture2D = new Texture2D(atlasSizeX, atlasSizeY, TextureFormat.ARGB32, mipChain: true);
					for (int j = 0; j < atlasPixels.Length; j++)
					{
						texture2D.SetPixels(0, j, atlasSizeX, 1, atlasPixels[j]);
					}
					texture2D.Apply();
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.Log("Saving atlas " + property.name + " w=" + texture2D.width + " h=" + texture2D.height);
					}
				}
				atlases[propIdx] = texture2D;
				progressInfo?.Invoke("Saving atlas: '" + property.name + "'", 0.04f);
				new Stopwatch().Start();
				if (data._saveAtlasesAsAssets && textureEditorMethods != null)
				{
					textureEditorMethods.SaveAtlasToAssetDatabase(atlases[propIdx], data.texPropertyNames[propIdx], propIdx, data.resultMaterial);
				}
				else
				{
					data.resultMaterial.SetTexture(data.texPropertyNames[propIdx].name, atlases[propIdx]);
				}
				data.resultMaterial.SetTextureOffset(data.texPropertyNames[propIdx].name, Vector2.zero);
				data.resultMaterial.SetTextureScale(data.texPropertyNames[propIdx].name, Vector2.one);
				combiner._destroyTemporaryTextures(data.texPropertyNames[propIdx].name);
			}
		}

		internal static IEnumerator CopyScaledAndTiledToAtlas(MeshBakerMaterialTexture source, MB_TexSet sourceMaterial, ShaderTextureProperty shaderPropertyName, DRect srcSamplingRect, int targX, int targY, int targW, int targH, AtlasPadding padding, Color[][] atlasPixels, bool isNormalMap, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, ProgressUpdateDelegate progressInfo = null, MB2_LogLevel LOG_LEVEL = MB2_LogLevel.info)
		{
			Texture2D texture2D = source.GetTexture2D();
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"CopyScaledAndTiledToAtlas: {texture2D} inAtlasX={targX} inAtlasY={targY} inAtlasW={targW} inAtlasH={targH} paddX={padding.leftRight} paddY={padding.topBottom} srcSamplingRect={srcSamplingRect}");
			}
			float num = targW;
			float num2 = targH;
			float num3 = (float)srcSamplingRect.width;
			float num4 = (float)srcSamplingRect.height;
			float num5 = (float)srcSamplingRect.x;
			float num6 = (float)srcSamplingRect.y;
			int w = (int)num;
			int h = (int)num2;
			if (data._considerNonTextureProperties)
			{
				texture2D = combiner._createTextureCopy(shaderPropertyName.name, texture2D);
				texture2D = data.nonTexturePropertyBlender.TintTextureWithTextureCombiner(texture2D, sourceMaterial, shaderPropertyName);
			}
			for (int k = 0; k < w; k++)
			{
				if (progressInfo != null && w > 0)
				{
					progressInfo("CopyScaledAndTiledToAtlas " + ((float)k / (float)w * 100f).ToString("F0"), 0.2f);
				}
				for (int l = 0; l < h; l++)
				{
					float x = (float)k / num * num3 + num5;
					float y = (float)l / num2 * num4 + num6;
					atlasPixels[targY + l][targX + k] = texture2D.GetPixelBilinear(x, y);
				}
			}
			for (int m = 0; m < w; m++)
			{
				for (int n = 1; n <= padding.topBottom; n++)
				{
					atlasPixels[targY - n][targX + m] = atlasPixels[targY][targX + m];
					atlasPixels[targY + h - 1 + n][targX + m] = atlasPixels[targY + h - 1][targX + m];
				}
			}
			for (int num7 = 0; num7 < h; num7++)
			{
				for (int num8 = 1; num8 <= padding.leftRight; num8++)
				{
					atlasPixels[targY + num7][targX - num8] = atlasPixels[targY + num7][targX];
					atlasPixels[targY + num7][targX + w + num8 - 1] = atlasPixels[targY + num7][targX + w - 1];
				}
			}
			for (int i = 1; i <= padding.leftRight; i++)
			{
				for (int j = 1; j <= padding.topBottom; j++)
				{
					atlasPixels[targY - j][targX - i] = atlasPixels[targY][targX];
					atlasPixels[targY + h - 1 + j][targX - i] = atlasPixels[targY + h - 1][targX];
					atlasPixels[targY + h - 1 + j][targX + w + i - 1] = atlasPixels[targY + h - 1][targX + w - 1];
					atlasPixels[targY - j][targX + w + i - 1] = atlasPixels[targY][targX + w - 1];
					yield return null;
				}
				yield return null;
			}
		}
	}
	internal class MB3_TextureCombinerPackerMeshBakerFast : MB_ITextureCombinerPacker
	{
		public IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			yield break;
		}

		public virtual AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return MB3_TextureCombinerPackerRoot.CalculateAtlasRectanglesStatic(data, doMultiAtlas, LOG_LEVEL);
		}

		public IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Rect[] rects = packedAtlasRects.rects;
			int atlasX = packedAtlasRects.atlasX;
			int atlasY = packedAtlasRects.atlasY;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Generated atlas will be " + atlasX + "x" + atlasY);
			}
			GameObject gameObject = null;
			try
			{
				gameObject = new GameObject("MBrenderAtlasesGO");
				MB3_AtlasPackerRenderTexture mB3_AtlasPackerRenderTexture = gameObject.AddComponent<MB3_AtlasPackerRenderTexture>();
				gameObject.AddComponent<Camera>();
				if (data._considerNonTextureProperties && LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Blend Non-Texture Properties has limited functionality when used with Mesh Baker Texture Packer Fast.");
				}
				for (int i = 0; i < data.numAtlases; i++)
				{
					Texture2D texture2D;
					if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
					{
						texture2D = null;
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Not creating atlas for " + data.texPropertyNames[i].name + " because textures are null and default value parameters are the same.");
						}
					}
					else
					{
						GC.Collect();
						MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, i, data);
						progressInfo?.Invoke("Creating Atlas '" + data.texPropertyNames[i].name + "'", 0.01f);
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("About to render " + data.texPropertyNames[i].name + " isNormal=" + data.texPropertyNames[i].isNormalMap);
						}
						mB3_AtlasPackerRenderTexture.LOG_LEVEL = LOG_LEVEL;
						mB3_AtlasPackerRenderTexture.width = atlasX;
						mB3_AtlasPackerRenderTexture.height = atlasY;
						mB3_AtlasPackerRenderTexture.padding = data._atlasPadding;
						mB3_AtlasPackerRenderTexture.rects = rects;
						mB3_AtlasPackerRenderTexture.textureSets = data.distinctMaterialTextures;
						mB3_AtlasPackerRenderTexture.indexOfTexSetToRender = i;
						mB3_AtlasPackerRenderTexture.texPropertyName = data.texPropertyNames[i];
						mB3_AtlasPackerRenderTexture.isNormalMap = data.texPropertyNames[i].isNormalMap;
						mB3_AtlasPackerRenderTexture.fixOutOfBoundsUVs = data._fixOutOfBoundsUVs;
						mB3_AtlasPackerRenderTexture.considerNonTextureProperties = data._considerNonTextureProperties;
						mB3_AtlasPackerRenderTexture.resultMaterialTextureBlender = data.nonTexturePropertyBlender;
						texture2D = mB3_AtlasPackerRenderTexture.OnRenderAtlas(combiner);
						if (LOG_LEVEL >= MB2_LogLevel.debug)
						{
							UnityEngine.Debug.Log("Saving atlas " + data.texPropertyNames[i].name + " w=" + texture2D.width + " h=" + texture2D.height + " id=" + texture2D.GetInstanceID());
						}
					}
					atlases[i] = texture2D;
					progressInfo?.Invoke("Saving atlas: '" + data.texPropertyNames[i].name + "'", 0.04f);
					if (data._saveAtlasesAsAssets && textureEditorMethods != null)
					{
						textureEditorMethods.SaveAtlasToAssetDatabase(atlases[i], data.texPropertyNames[i], i, data.resultMaterial);
					}
					else
					{
						data.resultMaterial.SetTexture(data.texPropertyNames[i].name, atlases[i]);
					}
					data.resultMaterial.SetTextureOffset(data.texPropertyNames[i].name, Vector2.zero);
					data.resultMaterial.SetTextureScale(data.texPropertyNames[i].name, Vector2.one);
					combiner._destroyTemporaryTextures(data.texPropertyNames[i].name);
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			finally
			{
				if (gameObject != null)
				{
					MB_Utility.Destroy(gameObject);
				}
			}
			yield break;
		}
	}
	internal class MB3_TextureCombinerPackerMeshBakerHorizontalVertical : MB3_TextureCombinerPackerMeshBaker
	{
		private interface IPipeline
		{
			MB2_PackingAlgorithmEnum GetPackingAlg();

			void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight);

			MB_TextureTilingTreatment GetEdge2EdgeTreatment();

			void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue);

			void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY);

			void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight);
		}

		private class VerticalPipeline : IPipeline
		{
			public MB2_PackingAlgorithmEnum GetPackingAlg()
			{
				return MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical;
			}

			public void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight)
			{
				if (texSet.idealHeight >= maxAtlasHeight && texSet.ts[0].GetEncapsulatingSamplingRect().height > 1.0)
				{
					horizontalVert.Add(texSet);
				}
				else
				{
					regular.Add(texSet);
				}
			}

			public MB_TextureTilingTreatment GetEdge2EdgeTreatment()
			{
				return MB_TextureTilingTreatment.edgeToEdgeY;
			}

			public void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue)
			{
				padding.topBottom = 0;
				padding.leftRight = paddingValue;
			}

			public void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY)
			{
				float num = a.usedW + b.usedW;
				if (num > (float)maxWidthDim)
				{
					float num2 = (float)maxWidthDim / num;
					float num3 = (float)Mathf.FloorToInt((float)a.usedW * num2) / (float)maxWidthDim;
					num2 = num3;
					float width = 1f - num3;
					AatlasToFinal = new Rect(0f, 0f, num2, 1f);
					BatlasToFinal = new Rect(num3, 0f, width, 1f);
				}
				else
				{
					float num4 = (float)a.usedW / num;
					AatlasToFinal = new Rect(0f, 0f, num4, 1f);
					BatlasToFinal = new Rect(num4, 0f, (float)b.usedW / num, 1f);
				}
				if (a.atlasX > b.atlasX)
				{
					if (!stretchBToAtlasWidth)
					{
						BatlasToFinal.width = (float)b.atlasX / (float)a.atlasX;
					}
				}
				else if (b.atlasX > a.atlasX)
				{
					AatlasToFinal.width = (float)a.atlasX / (float)b.atlasX;
				}
				atlasX = a.usedW + b.usedW;
				atlasY = Mathf.Max(a.usedH, b.usedH);
			}

			public void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight)
			{
				atlasRegularMaxWidth = maxAtlasWidth - usedHorizontalVertWidth;
				atlasRegularMaxHeight = maxAtlasHeight;
			}
		}

		private class HorizontalPipeline : IPipeline
		{
			public MB2_PackingAlgorithmEnum GetPackingAlg()
			{
				return MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal;
			}

			public void SortTexSetIntoBins(MB_TexSet texSet, List<MB_TexSet> horizontalVert, List<MB_TexSet> regular, int maxAtlasWidth, int maxAtlasHeight)
			{
				if (texSet.idealWidth >= maxAtlasWidth && texSet.ts[0].GetEncapsulatingSamplingRect().width > 1.0)
				{
					horizontalVert.Add(texSet);
				}
				else
				{
					regular.Add(texSet);
				}
			}

			public MB_TextureTilingTreatment GetEdge2EdgeTreatment()
			{
				return MB_TextureTilingTreatment.edgeToEdgeX;
			}

			public void InitializeAtlasPadding(ref AtlasPadding padding, int paddingValue)
			{
				padding.topBottom = paddingValue;
				padding.leftRight = 0;
			}

			public void MergeAtlasPackingResultStackBonAInternal(AtlasPackingResult a, AtlasPackingResult b, out Rect AatlasToFinal, out Rect BatlasToFinal, bool stretchBToAtlasWidth, int maxWidthDim, int maxHeightDim, out int atlasX, out int atlasY)
			{
				float num = a.usedH + b.usedH;
				if (num > (float)maxHeightDim)
				{
					float num2 = (float)maxHeightDim / num;
					float num3 = (float)Mathf.FloorToInt((float)a.usedH * num2) / (float)maxHeightDim;
					num2 = num3;
					float height = 1f - num3;
					AatlasToFinal = new Rect(0f, 0f, 1f, num2);
					BatlasToFinal = new Rect(0f, num3, 1f, height);
				}
				else
				{
					float num4 = (float)a.usedH / num;
					AatlasToFinal = new Rect(0f, 0f, 1f, num4);
					BatlasToFinal = new Rect(0f, num4, 1f, (float)b.usedH / num);
				}
				if (a.atlasX > b.atlasX)
				{
					if (!stretchBToAtlasWidth)
					{
						BatlasToFinal.width = (float)b.atlasX / (float)a.atlasX;
					}
				}
				else if (b.atlasX > a.atlasX)
				{
					AatlasToFinal.width = (float)a.atlasX / (float)b.atlasX;
				}
				atlasX = Mathf.Max(a.usedW, b.usedW);
				atlasY = a.usedH + b.usedH;
			}

			public void GetExtraRoomForRegularAtlas(int usedHorizontalVertWidth, int usedHorizontalVertHeight, int maxAtlasWidth, int maxAtlasHeight, out int atlasRegularMaxWidth, out int atlasRegularMaxHeight)
			{
				atlasRegularMaxWidth = maxAtlasWidth;
				atlasRegularMaxHeight = maxAtlasHeight - usedHorizontalVertHeight;
			}
		}

		public enum AtlasDirection
		{
			horizontal,
			vertical
		}

		private AtlasDirection _atlasDirection;

		public MB3_TextureCombinerPackerMeshBakerHorizontalVertical(AtlasDirection ad)
		{
			_atlasDirection = ad;
		}

		public override AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			IPipeline pipeline = ((_atlasDirection != 0) ? ((IPipeline)new VerticalPipeline()) : ((IPipeline)new HorizontalPipeline()));
			UnityEngine.Debug.LogError("TODO handle max atlas dimension when not using override");
			if (_atlasDirection == AtlasDirection.horizontal)
			{
				if (data._useMaxAtlasWidthOverride)
				{
				}
			}
			else
			{
				_ = data._useMaxAtlasHeightOverride;
			}
			List<MB_TexSet> list = new List<MB_TexSet>();
			List<MB_TexSet> list2 = new List<MB_TexSet>();
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				pipeline.SortTexSetIntoBins(data.distinctMaterialTextures[i], list, list2, data._maxAtlasWidth, data._maxAtlasHeight);
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Splitting list of distinctMaterialTextures numHorizontalVertical={list.Count} numRegular={list2.Count}");
			}
			AtlasPackingResult[] array;
			if (list.Count > 0)
			{
				MB2_PackingAlgorithmEnum packingAlg = pipeline.GetPackingAlg();
				List<Vector2> list3 = new List<Vector2>();
				for (int j = 0; j < list.Count; j++)
				{
					list[j].SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(pipeline.GetEdge2EdgeTreatment());
					list3.Add(new Vector2(list[j].idealWidth, list[j].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(packingAlg);
				mB2_TexturePacker.atlasMustBePowerOfTwo = false;
				List<AtlasPadding> list4 = new List<AtlasPadding>();
				for (int k = 0; k < list3.Count; k++)
				{
					AtlasPadding padding = default(AtlasPadding);
					pipeline.InitializeAtlasPadding(ref padding, data._atlasPadding);
					list4.Add(padding);
				}
				mB2_TexturePacker.LOG_LEVEL = MB2_LogLevel.trace;
				array = mB2_TexturePacker.GetRects(list3, list4, data._maxAtlasWidth, data._maxAtlasHeight, doMultiAtlas: false);
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"Packed {list.Count} textures with edgeToEdge tiling into an atlas of size {array[0].atlasX} by {array[0].atlasY} usedW {array[0].usedW} usedH {array[0].usedH}");
				}
			}
			else
			{
				array = new AtlasPackingResult[0];
			}
			AtlasPackingResult[] array2;
			if (list2.Count > 0)
			{
				MB2_PackingAlgorithmEnum packingAlg = MB2_PackingAlgorithmEnum.MeshBakerTexturePacker;
				List<Vector2> list5 = new List<Vector2>();
				for (int l = 0; l < list2.Count; l++)
				{
					list5.Add(new Vector2(list2[l].idealWidth, list2[l].idealHeight));
				}
				MB2_TexturePacker mB2_TexturePacker = MB3_TextureCombinerPipeline.CreateTexturePacker(MB2_PackingAlgorithmEnum.MeshBakerTexturePacker);
				mB2_TexturePacker.atlasMustBePowerOfTwo = false;
				List<AtlasPadding> list6 = new List<AtlasPadding>();
				for (int m = 0; m < list5.Count; m++)
				{
					AtlasPadding item = default(AtlasPadding);
					item.topBottom = data._atlasPadding;
					item.leftRight = data._atlasPadding;
					list6.Add(item);
				}
				int usedHorizontalVertWidth = 0;
				int usedHorizontalVertHeight = 0;
				if (array.Length != 0)
				{
					usedHorizontalVertHeight = array[0].atlasY;
					usedHorizontalVertWidth = array[0].atlasX;
				}
				pipeline.GetExtraRoomForRegularAtlas(usedHorizontalVertWidth, usedHorizontalVertHeight, data._maxAtlasWidth, data._maxAtlasHeight, out var atlasRegularMaxWidth, out var atlasRegularMaxHeight);
				array2 = mB2_TexturePacker.GetRects(list5, list6, atlasRegularMaxWidth, atlasRegularMaxHeight, doMultiAtlas: false);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log($"Packed {list2.Count} textures without edgeToEdge tiling into an atlas of size {array2[0].atlasX} by {array2[0].atlasY} usedW {array2[0].usedW} usedH {array2[0].usedH}");
				}
			}
			else
			{
				array2 = new AtlasPackingResult[0];
			}
			AtlasPackingResult atlasPackingResult = null;
			if (array.Length == 0 && array2.Length == 0)
			{
				return null;
			}
			if (array.Length != 0 && array2.Length != 0)
			{
				atlasPackingResult = MergeAtlasPackingResultStackBonA(array[0], array2[0], data._maxAtlasWidth, data._maxAtlasHeight, stretchBToAtlasWidth: true, pipeline);
			}
			else if (array.Length != 0)
			{
				atlasPackingResult = array[0];
			}
			else if (array2.Length != 0)
			{
				atlasPackingResult = array2[0];
			}
			list.AddRange(list2);
			data.distinctMaterialTextures = list;
			if (atlasPackingResult != null)
			{
				return new AtlasPackingResult[1] { atlasPackingResult };
			}
			return new AtlasPackingResult[0];
		}

		public static AtlasPackingResult TestStackRectanglesHorizontal(AtlasPackingResult a, AtlasPackingResult b, int maxHeightDim, int maxWidthDim, bool stretchBToAtlasWidth)
		{
			return MergeAtlasPackingResultStackBonA(a, b, maxWidthDim, maxHeightDim, stretchBToAtlasWidth, new HorizontalPipeline());
		}

		public static AtlasPackingResult TestStackRectanglesVertical(AtlasPackingResult a, AtlasPackingResult b, int maxHeightDim, int maxWidthDim, bool stretchBToAtlasWidth)
		{
			return MergeAtlasPackingResultStackBonA(a, b, maxWidthDim, maxHeightDim, stretchBToAtlasWidth, new VerticalPipeline());
		}

		private static AtlasPackingResult MergeAtlasPackingResultStackBonA(AtlasPackingResult a, AtlasPackingResult b, int maxWidthDim, int maxHeightDim, bool stretchBToAtlasWidth, IPipeline pipeline)
		{
			pipeline.MergeAtlasPackingResultStackBonAInternal(a, b, out var AatlasToFinal, out var BatlasToFinal, stretchBToAtlasWidth, maxWidthDim, maxHeightDim, out var atlasX, out var atlasY);
			Rect[] array = new Rect[a.rects.Length + b.rects.Length];
			AtlasPadding[] array2 = new AtlasPadding[a.rects.Length + b.rects.Length];
			int[] array3 = new int[a.rects.Length + b.rects.Length];
			Array.Copy(a.padding, array2, a.padding.Length);
			Array.Copy(b.padding, 0, array2, a.padding.Length, b.padding.Length);
			Array.Copy(a.srcImgIdxs, array3, a.srcImgIdxs.Length);
			Array.Copy(b.srcImgIdxs, 0, array3, a.srcImgIdxs.Length, b.srcImgIdxs.Length);
			Array.Copy(a.rects, array, a.rects.Length);
			for (int i = 0; i < a.rects.Length; i++)
			{
				Rect rect = a.rects[i];
				rect.x = AatlasToFinal.x + rect.x * AatlasToFinal.width;
				rect.y = AatlasToFinal.y + rect.y * AatlasToFinal.height;
				rect.width *= AatlasToFinal.width;
				rect.height *= AatlasToFinal.height;
				array[i] = rect;
				array3[i] = a.srcImgIdxs[i];
			}
			for (int j = 0; j < b.rects.Length; j++)
			{
				Rect rect2 = b.rects[j];
				rect2.x = BatlasToFinal.x + rect2.x * BatlasToFinal.width;
				rect2.y = BatlasToFinal.y + rect2.y * BatlasToFinal.height;
				rect2.width *= BatlasToFinal.width;
				rect2.height *= BatlasToFinal.height;
				array[a.rects.Length + j] = rect2;
				array3[a.rects.Length + j] = b.srcImgIdxs[j];
			}
			AtlasPackingResult atlasPackingResult = new AtlasPackingResult(array2);
			atlasPackingResult.atlasX = atlasX;
			atlasPackingResult.atlasY = atlasY;
			atlasPackingResult.padding = array2;
			atlasPackingResult.rects = array;
			atlasPackingResult.srcImgIdxs = array3;
			atlasPackingResult.CalcUsedWidthAndHeight();
			return atlasPackingResult;
		}
	}
	internal class MB3_TextureCombinerPackerOneTextureInAtlas : MB_ITextureCombinerPacker
	{
		public IEnumerator ConvertTexturesToReadableFormats(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			yield break;
		}

		public AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
			}
			AtlasPackingResult[] array = new AtlasPackingResult[1];
			AtlasPadding[] pds = new AtlasPadding[1]
			{
				new AtlasPadding(data._atlasPadding)
			};
			array[0] = new AtlasPackingResult(pds);
			array[0].rects = new Rect[1];
			array[0].srcImgIdxs = new int[1];
			array[0].rects[0] = new Rect(0f, 0f, 1f, 1f);
			MeshBakerMaterialTexture meshBakerMaterialTexture = null;
			if (data.distinctMaterialTextures[0].ts.Length != 0)
			{
				meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[0];
			}
			if (meshBakerMaterialTexture == null || meshBakerMaterialTexture.isNull)
			{
				array[0].atlasX = 16;
				array[0].atlasY = 16;
				array[0].usedW = 16;
				array[0].usedH = 16;
			}
			else
			{
				array[0].atlasX = meshBakerMaterialTexture.width;
				array[0].atlasY = meshBakerMaterialTexture.height;
				array[0].usedW = meshBakerMaterialTexture.width;
				array[0].usedH = meshBakerMaterialTexture.height;
			}
			return array;
		}

		public IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Only one image per atlas. Will re-use original texture");
			}
			for (int i = 0; i < data.numAtlases; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[i];
				atlases[i] = meshBakerMaterialTexture.GetTexture2D();
				data.resultMaterial.SetTexture(data.texPropertyNames[i].name, atlases[i]);
				data.resultMaterial.SetTextureScale(data.texPropertyNames[i].name, Vector2.one);
				data.resultMaterial.SetTextureOffset(data.texPropertyNames[i].name, Vector2.zero);
			}
			yield break;
		}
	}
	internal class MB3_TextureCombinerPackerUnity : MB3_TextureCombinerPackerRoot
	{
		public override AtlasPackingResult[] CalculateAtlasRectangles(MB3_TextureCombinerPipeline.TexturePipelineData data, bool doMultiAtlas, MB2_LogLevel LOG_LEVEL)
		{
			return new AtlasPackingResult[1]
			{
				new AtlasPackingResult(new AtlasPadding[0])
			};
		}

		public override IEnumerator CreateAtlases(ProgressUpdateDelegate progressInfo, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, AtlasPackingResult packedAtlasRects, Texture2D[] atlases, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			_ = packedAtlasRects.rects;
			long num = 0L;
			int w = 1;
			int h = 1;
			Rect[] array = null;
			for (int i = 0; i < data.numAtlases; i++)
			{
				ShaderTextureProperty shaderTextureProperty = data.texPropertyNames[i];
				Texture2D texture2D;
				if (!MB3_TextureCombinerPipeline._ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					texture2D = null;
				}
				else
				{
					if (LOG_LEVEL >= MB2_LogLevel.debug)
					{
						UnityEngine.Debug.LogWarning("Beginning loop " + i + " num temporary textures " + combiner._getNumTemporaryTextures());
					}
					MB3_TextureCombinerPackerRoot.CreateTemporaryTexturesForAtlas(data.distinctMaterialTextures, combiner, i, data);
					Texture2D[] array2 = new Texture2D[data.distinctMaterialTextures.Count];
					for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
					{
						MB_TexSet mB_TexSet = data.distinctMaterialTextures[j];
						int idealWidth = mB_TexSet.idealWidth;
						int idealHeight = mB_TexSet.idealHeight;
						Texture2D texture2D2 = mB_TexSet.ts[i].GetTexture2D();
						progressInfo?.Invoke("Adjusting for scale and offset " + texture2D2, 0.01f);
						textureEditorMethods?.SetReadWriteFlag(texture2D2, isReadable: true, addToList: true);
						texture2D2 = GetAdjustedForScaleAndOffset2(shaderTextureProperty.name, mB_TexSet.ts[i], mB_TexSet.obUVoffset, mB_TexSet.obUVscale, data, combiner, LOG_LEVEL);
						if (texture2D2.width != idealWidth || texture2D2.height != idealHeight)
						{
							progressInfo?.Invoke(string.Concat("Resizing texture '", texture2D2, "'"), 0.01f);
							if (LOG_LEVEL >= MB2_LogLevel.debug)
							{
								UnityEngine.Debug.LogWarning("Copying and resizing texture " + shaderTextureProperty.name + " from " + texture2D2.width + "x" + texture2D2.height + " to " + idealWidth + "x" + idealHeight);
							}
							texture2D2 = combiner._resizeTexture(shaderTextureProperty.name, texture2D2, idealWidth, idealHeight);
						}
						num += texture2D2.width * texture2D2.height;
						if (data._considerNonTextureProperties)
						{
							texture2D2 = combiner._createTextureCopy(shaderTextureProperty.name, texture2D2);
							data.nonTexturePropertyBlender.TintTextureWithTextureCombiner(texture2D2, data.distinctMaterialTextures[j], shaderTextureProperty);
						}
						array2[j] = texture2D2;
					}
					textureEditorMethods?.CheckBuildSettings(num);
					if (Math.Sqrt(num) > 3500.0 && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("The maximum possible atlas size is 4096. Textures may be shrunk");
					}
					texture2D = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: true);
					progressInfo?.Invoke("Packing texture atlas " + shaderTextureProperty.name, 0.25f);
					if (i == 0)
					{
						progressInfo?.Invoke("Estimated min size of atlases: " + Math.Sqrt(num).ToString("F0"), 0.1f);
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							UnityEngine.Debug.Log("Estimated atlas minimum size:" + Math.Sqrt(num).ToString("F0"));
						}
						int maximumAtlasSize = 4096;
						array = texture2D.PackTextures(array2, data._atlasPadding, maximumAtlasSize, makeNoLongerReadable: false);
						if (LOG_LEVEL >= MB2_LogLevel.info)
						{
							UnityEngine.Debug.Log("After pack textures atlas size " + texture2D.width + " " + texture2D.height);
						}
						w = texture2D.width;
						h = texture2D.height;
						texture2D.Apply();
					}
					else
					{
						progressInfo?.Invoke("Copying Textures Into: " + shaderTextureProperty.name, 0.1f);
						texture2D = _copyTexturesIntoAtlas(array2, data._atlasPadding, array, w, h, combiner);
					}
				}
				atlases[i] = texture2D;
				if (data._saveAtlasesAsAssets)
				{
					textureEditorMethods?.SaveAtlasToAssetDatabase(atlases[i], shaderTextureProperty, i, data.resultMaterial);
				}
				data.resultMaterial.SetTextureOffset(shaderTextureProperty.name, Vector2.zero);
				data.resultMaterial.SetTextureScale(shaderTextureProperty.name, Vector2.one);
				combiner._destroyTemporaryTextures(shaderTextureProperty.name);
				GC.Collect();
			}
			packedAtlasRects.rects = array;
			yield break;
		}

		internal static Texture2D _copyTexturesIntoAtlas(Texture2D[] texToPack, int padding, Rect[] rs, int w, int h, MB3_TextureCombiner combiner)
		{
			Texture2D texture2D = new Texture2D(w, h, TextureFormat.ARGB32, mipChain: true);
			MB_Utility.setSolidColor(texture2D, Color.clear);
			for (int i = 0; i < rs.Length; i++)
			{
				Rect rect = rs[i];
				Texture2D texture2D2 = texToPack[i];
				Texture2D texture2D3 = null;
				int x = Mathf.RoundToInt(rect.x * (float)w);
				int y = Mathf.RoundToInt(rect.y * (float)h);
				int num = Mathf.RoundToInt(rect.width * (float)w);
				int num2 = Mathf.RoundToInt(rect.height * (float)h);
				if (texture2D2.width != num && texture2D2.height != num2)
				{
					texture2D3 = (texture2D2 = MB_Utility.resampleTexture(texture2D2, num, num2));
				}
				texture2D.SetPixels(x, y, num, num2, texture2D2.GetPixels());
				if (texture2D3 != null)
				{
					MB_Utility.Destroy(texture2D3);
				}
			}
			texture2D.Apply();
			return texture2D;
		}

		internal static Texture2D GetAdjustedForScaleAndOffset2(string propertyName, MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, MB3_TextureCombinerPipeline.TexturePipelineData data, MB3_TextureCombiner combiner, MB2_LogLevel LOG_LEVEL)
		{
			Texture2D texture2D = source.GetTexture2D();
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!data._fixOutOfBoundsUVs)
				{
					return texture2D;
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return texture2D;
				}
			}
			Vector2 adjustedForScaleAndOffset2Dimensions = MB3_TextureCombinerPipeline.GetAdjustedForScaleAndOffset2Dimensions(source, obUVoffset, obUVscale, data, LOG_LEVEL);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.LogWarning(string.Concat("GetAdjustedForScaleAndOffset2: ", texture2D, " ", obUVoffset, " ", obUVscale));
			}
			float x = adjustedForScaleAndOffset2Dimensions.x;
			float y = adjustedForScaleAndOffset2Dimensions.y;
			float num = (float)source.matTilingRect.width;
			float num2 = (float)source.matTilingRect.height;
			float num3 = (float)source.matTilingRect.x;
			float num4 = (float)source.matTilingRect.y;
			if (data._fixOutOfBoundsUVs)
			{
				num *= obUVscale.x;
				num2 *= obUVscale.y;
				num3 = (float)(source.matTilingRect.x * (double)obUVscale.x + (double)obUVoffset.x);
				num4 = (float)(source.matTilingRect.y * (double)obUVscale.y + (double)obUVoffset.y);
			}
			Texture2D texture2D2 = combiner._createTemporaryTexture(propertyName, (int)x, (int)y, TextureFormat.ARGB32, mipMaps: true);
			for (int i = 0; i < texture2D2.width; i++)
			{
				for (int j = 0; j < texture2D2.height; j++)
				{
					float x2 = (float)i / x * num + num3;
					float y2 = (float)j / y * num2 + num4;
					texture2D2.SetPixel(i, j, texture2D.GetPixelBilinear(x2, y2));
				}
			}
			texture2D2.Apply();
			return texture2D2;
		}
	}
	public class MB3_TextureCombinerPipeline
	{
		public struct CreateAtlasForProperty
		{
			public bool allTexturesAreNull;

			public bool allTexturesAreSame;

			public bool allNonTexturePropsAreSame;

			public override string ToString()
			{
				return $"AllTexturesNull={allTexturesAreNull} areSame={allTexturesAreSame} nonTexPropsAreSame={allNonTexturePropsAreSame}";
			}
		}

		internal class TexturePipelineData
		{
			internal MB2_TextureBakeResults _textureBakeResults;

			internal int _atlasPadding = 1;

			internal int _maxAtlasWidth = 1;

			internal int _maxAtlasHeight = 1;

			internal bool _useMaxAtlasHeightOverride;

			internal bool _useMaxAtlasWidthOverride;

			internal bool _resizePowerOfTwoTextures;

			internal bool _fixOutOfBoundsUVs;

			internal int _maxTilingBakeSize = 1024;

			internal bool _saveAtlasesAsAssets;

			internal MB2_PackingAlgorithmEnum _packingAlgorithm;

			internal bool _meshBakerTexturePackerForcePowerOfTwo = true;

			internal List<ShaderTextureProperty> _customShaderPropNames = new List<ShaderTextureProperty>();

			internal bool _normalizeTexelDensity;

			internal bool _considerNonTextureProperties;

			internal MB3_TextureCombinerNonTextureProperties nonTexturePropertyBlender;

			internal List<MB_TexSet> distinctMaterialTextures;

			internal List<GameObject> allObjsToMesh;

			internal List<Material> allowedMaterialsFilter;

			internal List<ShaderTextureProperty> texPropertyNames;

			internal CreateAtlasForProperty[] allTexturesAreNullAndSameColor;

			internal Material resultMaterial;

			internal int numAtlases
			{
				get
				{
					if (texPropertyNames != null)
					{
						return texPropertyNames.Count;
					}
					return 0;
				}
			}

			internal bool OnlyOneTextureInAtlasReuseTextures()
			{
				if (distinctMaterialTextures != null && distinctMaterialTextures.Count == 1 && distinctMaterialTextures[0].thisIsOnlyTexSetInAtlas && !_fixOutOfBoundsUVs && !_considerNonTextureProperties)
				{
					return true;
				}
				return false;
			}
		}

		public static bool USE_EXPERIMENTAL_HOIZONTALVERTICAL = false;

		public static ShaderTextureProperty[] shaderTexPropertyNames = new ShaderTextureProperty[19]
		{
			new ShaderTextureProperty("_MainTex", norm: false),
			new ShaderTextureProperty("_BumpMap", norm: true),
			new ShaderTextureProperty("_Normal", norm: true),
			new ShaderTextureProperty("_BumpSpecMap", norm: false),
			new ShaderTextureProperty("_DecalTex", norm: false),
			new ShaderTextureProperty("_Detail", norm: false),
			new ShaderTextureProperty("_GlossMap", norm: false),
			new ShaderTextureProperty("_Illum", norm: false),
			new ShaderTextureProperty("_LightTextureB0", norm: false),
			new ShaderTextureProperty("_ParallaxMap", norm: false),
			new ShaderTextureProperty("_ShadowOffset", norm: false),
			new ShaderTextureProperty("_TranslucencyMap", norm: false),
			new ShaderTextureProperty("_SpecMap", norm: false),
			new ShaderTextureProperty("_SpecGlossMap", norm: false),
			new ShaderTextureProperty("_TranspMap", norm: false),
			new ShaderTextureProperty("_MetallicGlossMap", norm: false),
			new ShaderTextureProperty("_OcclusionMap", norm: false),
			new ShaderTextureProperty("_EmissionMap", norm: false),
			new ShaderTextureProperty("_DetailMask", norm: false)
		};

		internal static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, bool considerNonTextureProperties, CreateAtlasForProperty[] allTexturesAreNullAndSameColor)
		{
			CreateAtlasForProperty createAtlasForProperty = allTexturesAreNullAndSameColor[propertyIndex];
			if (considerNonTextureProperties)
			{
				if (!createAtlasForProperty.allNonTexturePropsAreSame || !createAtlasForProperty.allTexturesAreNull)
				{
					return true;
				}
				return false;
			}
			if (!createAtlasForProperty.allTexturesAreNull)
			{
				return true;
			}
			return false;
		}

		internal static bool _CollectPropertyNames(TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			int i;
			for (i = 0; i < data.texPropertyNames.Count; i++)
			{
				ShaderTextureProperty shaderTextureProperty = data._customShaderPropNames.Find((ShaderTextureProperty x) => x.name.Equals(data.texPropertyNames[i].name));
				if (shaderTextureProperty != null)
				{
					data._customShaderPropNames.Remove(shaderTextureProperty);
				}
			}
			Material resultMaterial = data.resultMaterial;
			if (resultMaterial == null)
			{
				UnityEngine.Debug.LogError("Please assign a result material. The combined mesh will use this material.");
				return false;
			}
			string text = "";
			for (int j = 0; j < shaderTexPropertyNames.Length; j++)
			{
				if (resultMaterial.HasProperty(shaderTexPropertyNames[j].name))
				{
					text = text + ", " + shaderTexPropertyNames[j].name;
					if (!data.texPropertyNames.Contains(shaderTexPropertyNames[j]))
					{
						data.texPropertyNames.Add(shaderTexPropertyNames[j]);
					}
					if (resultMaterial.GetTextureOffset(shaderTexPropertyNames[j].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is may be incorrect.");
					}
					if (resultMaterial.GetTextureScale(shaderTexPropertyNames[j].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should have tiling of 1,1");
					}
				}
			}
			for (int k = 0; k < data._customShaderPropNames.Count; k++)
			{
				if (resultMaterial.HasProperty(data._customShaderPropNames[k].name))
				{
					text = text + ", " + data._customShaderPropNames[k].name;
					data.texPropertyNames.Add(data._customShaderPropNames[k]);
					if (resultMaterial.GetTextureOffset(data._customShaderPropNames[k].name) != new Vector2(0f, 0f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material has non-zero offset. This is probably incorrect.");
					}
					if (resultMaterial.GetTextureScale(data._customShaderPropNames[k].name) != new Vector2(1f, 1f) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Result material should probably have tiling of 1,1.");
					}
				}
				else if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning("Result material shader does not use property " + data._customShaderPropNames[k].name + " in the list of custom shader property names");
				}
			}
			return true;
		}

		internal static bool _ShouldWeCreateAtlasForThisProperty(int propertyIndex, CreateAtlasForProperty[] allTexturesAreNullAndSameColor, TexturePipelineData data)
		{
			CreateAtlasForProperty createAtlasForProperty = allTexturesAreNullAndSameColor[propertyIndex];
			if (data._considerNonTextureProperties)
			{
				if (!createAtlasForProperty.allNonTexturePropsAreSame || !createAtlasForProperty.allTexturesAreNull)
				{
					return true;
				}
				return false;
			}
			if (!createAtlasForProperty.allTexturesAreNull)
			{
				return true;
			}
			return false;
		}

		public static Texture GetTextureConsideringStandardShaderKeywords(string shaderName, Material mat, string propertyName)
		{
			if ((shaderName.Equals("Standard") || shaderName.Equals("Standard (Specular setup)") || shaderName.Equals("Standard (Roughness setup")) && propertyName.Equals("_EmissionMap"))
			{
				if (mat.IsKeywordEnabled("_EMISSION"))
				{
					return mat.GetTexture(propertyName);
				}
				return null;
			}
			return mat.GetTexture(propertyName);
		}

		internal static IEnumerator __Step1_CollectDistinctMatTexturesAndUsedObjects(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, List<GameObject> usedObjsToMesh, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			bool flag = false;
			Dictionary<int, MB_Utility.MeshAnalysisResult[]> dictionary = new Dictionary<int, MB_Utility.MeshAnalysisResult[]>();
			for (int i = 0; i < data.allObjsToMesh.Count; i++)
			{
				GameObject gameObject = data.allObjsToMesh[i];
				progressInfo?.Invoke("Collecting textures for " + gameObject, (float)i / (float)data.allObjsToMesh.Count / 2f);
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Collecting textures for object " + gameObject);
				}
				if (gameObject == null)
				{
					UnityEngine.Debug.LogError("The list of objects to mesh contained nulls.");
					result.success = false;
					yield break;
				}
				Mesh mesh = MB_Utility.GetMesh(gameObject);
				if (mesh == null)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh has no mesh.");
					result.success = false;
					yield break;
				}
				Material[] gOMaterials = MB_Utility.GetGOMaterials(gameObject);
				if (gOMaterials.Length == 0)
				{
					UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects has no materials.");
					result.success = false;
					yield break;
				}
				if (!dictionary.TryGetValue(mesh.GetInstanceID(), out var value))
				{
					value = new MB_Utility.MeshAnalysisResult[mesh.subMeshCount];
					for (int j = 0; j < mesh.subMeshCount; j++)
					{
						MB_Utility.hasOutOfBoundsUVs(mesh, ref value[j], j);
						if (data._normalizeTexelDensity)
						{
							value[j].submeshArea = GetSubmeshArea(mesh, j);
						}
						if (data._fixOutOfBoundsUVs && !value[j].hasUVs)
						{
							value[j].uvRect = new Rect(0f, 0f, 1f, 1f);
							UnityEngine.Debug.LogWarning(string.Concat("Mesh for object ", gameObject, " has no UV channel but 'consider UVs' is enabled. Assuming UVs will be generated filling 0,0,1,1 rectangle."));
						}
					}
					dictionary.Add(mesh.GetInstanceID(), value);
				}
				if (data._fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log(string.Concat("Mesh Analysis for object ", gameObject, " numSubmesh=", value.Length, " HasOBUV=", value[0].hasOutOfBoundsUVs.ToString(), " UVrectSubmesh0=", value[0].uvRect));
				}
				for (int k = 0; k < gOMaterials.Length; k++)
				{
					progressInfo?.Invoke($"Collecting textures for {gameObject} submesh {k}", (float)i / (float)data.allObjsToMesh.Count / 2f);
					Material material = gOMaterials[k];
					if (data.allowedMaterialsFilter != null && !data.allowedMaterialsFilter.Contains(material))
					{
						continue;
					}
					flag = flag || value[k].hasOutOfBoundsUVs;
					if (material.name.Contains("(Instance)"))
					{
						UnityEngine.Debug.LogError("The sharedMaterial on object " + gameObject.name + " has been 'Instanced'. This was probably caused by a script accessing the meshRender.material property in the editor.  The material to UV Rectangle mapping will be incorrect. To fix this recreate the object from its prefab or re-assign its material from the correct asset.");
						result.success = false;
						yield break;
					}
					if (data._fixOutOfBoundsUVs && !MB_Utility.AreAllSharedMaterialsDistinct(gOMaterials) && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning("Object " + gameObject.name + " uses the same material on multiple submeshes. This may generate strange resultAtlasesAndRects especially when used with fix out of bounds uvs. Try duplicating the material.");
					}
					MeshBakerMaterialTexture[] array = new MeshBakerMaterialTexture[data.texPropertyNames.Count];
					for (int l = 0; l < data.texPropertyNames.Count; l++)
					{
						Texture texture = null;
						Vector2 matTilingScale = Vector2.one;
						Vector2 matTilingOffset = Vector2.zero;
						float texelDens = 0f;
						if (material.HasProperty(data.texPropertyNames[l].name))
						{
							Texture textureConsideringStandardShaderKeywords = GetTextureConsideringStandardShaderKeywords(data.resultMaterial.shader.name, material, data.texPropertyNames[l].name);
							if (textureConsideringStandardShaderKeywords != null)
							{
								if (!(textureConsideringStandardShaderKeywords is Texture2D))
								{
									UnityEngine.Debug.LogError("Object " + gameObject.name + " in the list of objects to mesh uses a Texture that is not a Texture2D. Cannot build atlases.");
									result.success = false;
									yield break;
								}
								texture = textureConsideringStandardShaderKeywords;
								TextureFormat format = ((Texture2D)texture).format;
								bool flag2 = false;
								if (!Application.isPlaying && textureEditorMethods != null)
								{
									flag2 = textureEditorMethods.IsNormalMap((Texture2D)texture);
								}
								if ((format != TextureFormat.ARGB32 && format != TextureFormat.RGBA32 && format != TextureFormat.BGRA32 && format != TextureFormat.RGB24 && format != TextureFormat.Alpha8) || flag2)
								{
									if (Application.isPlaying && data._packingAlgorithm != MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast)
									{
										UnityEngine.Debug.LogError(string.Concat("Object ", gameObject.name, " in the list of objects to mesh uses Texture ", texture.name, " uses format ", format, " that is not in: ARGB32, RGBA32, BGRA32, RGB24, Alpha8 or DXT. These textures cannot be resized at runtime. Try changing texture format. If format says 'compressed' try changing it to 'truecolor'"));
										result.success = false;
										yield break;
									}
									texture = (Texture2D)material.GetTexture(data.texPropertyNames[l].name);
								}
							}
							if (texture != null && data._normalizeTexelDensity)
							{
								texelDens = ((value[l].submeshArea != 0f) ? ((float)(texture.width * texture.height) / value[l].submeshArea) : 0f);
							}
							matTilingScale = material.GetTextureScale(data.texPropertyNames[l].name);
							matTilingOffset = material.GetTextureOffset(data.texPropertyNames[l].name);
						}
						array[l] = new MeshBakerMaterialTexture(texture, matTilingOffset, matTilingScale, texelDens);
					}
					data.nonTexturePropertyBlender.CollectAverageValuesOfNonTextureProperties(data.resultMaterial, material);
					Vector2 vector = new Vector2(value[k].uvRect.width, value[k].uvRect.height);
					Vector2 vector2 = new Vector2(value[k].uvRect.x, value[k].uvRect.y);
					MB_TextureTilingTreatment treatment = MB_TextureTilingTreatment.none;
					if (data._fixOutOfBoundsUVs)
					{
						treatment = MB_TextureTilingTreatment.considerUVs;
					}
					MB_TexSet setOfTexs = new MB_TexSet(array, vector2, vector, treatment);
					MatAndTransformToMerged item = new MatAndTransformToMerged(new DRect(vector2, vector), data._fixOutOfBoundsUVs, material);
					setOfTexs.matsAndGOs.mats.Add(item);
					MB_TexSet mB_TexSet = data.distinctMaterialTextures.Find((MB_TexSet x) => x.IsEqual(setOfTexs, data._fixOutOfBoundsUVs, data.nonTexturePropertyBlender));
					if (mB_TexSet != null)
					{
						setOfTexs = mB_TexSet;
					}
					else
					{
						data.distinctMaterialTextures.Add(setOfTexs);
					}
					if (!setOfTexs.matsAndGOs.mats.Contains(item))
					{
						setOfTexs.matsAndGOs.mats.Add(item);
					}
					if (!setOfTexs.matsAndGOs.gos.Contains(gameObject))
					{
						setOfTexs.matsAndGOs.gos.Add(gameObject);
						if (!usedObjsToMesh.Contains(gameObject))
						{
							usedObjsToMesh.Add(gameObject);
						}
					}
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log($"Step1_CollectDistinctTextures collected {data.distinctMaterialTextures.Count} sets of textures fixOutOfBoundsUV={data._fixOutOfBoundsUVs} considerNonTextureProperties={data._considerNonTextureProperties}");
			}
			if (data.distinctMaterialTextures.Count == 0)
			{
				UnityEngine.Debug.LogError("None of the source object materials matched any of the allowed materials for this submesh.");
				result.success = false;
				yield break;
			}
			new MB3_TextureCombinerMerging(data._considerNonTextureProperties, data.nonTexturePropertyBlender, data._fixOutOfBoundsUVs, LOG_LEVEL).MergeOverlappingDistinctMaterialTexturesAndCalcMaterialSubrects(data.distinctMaterialTextures);
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step1_CollectDistinctTextures " + stopwatch.ElapsedMilliseconds.ToString("f5"));
			}
		}

		private static CreateAtlasForProperty[] CalculateAllTexturesAreNullAndSameColor(TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			CreateAtlasForProperty[] array = new CreateAtlasForProperty[data.texPropertyNames.Count];
			for (int i = 0; i < data.texPropertyNames.Count; i++)
			{
				MeshBakerMaterialTexture meshBakerMaterialTexture = data.distinctMaterialTextures[0].ts[i];
				Color color = Color.black;
				if (data._considerNonTextureProperties)
				{
					color = data.nonTexturePropertyBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(data.distinctMaterialTextures[0].matsAndGOs.mats[0].mat, data.texPropertyNames[i]);
				}
				int num = 0;
				int num2 = 0;
				int num3 = 0;
				for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
				{
					if (!data.distinctMaterialTextures[j].ts[i].isNull)
					{
						num++;
					}
					if (meshBakerMaterialTexture.AreTexturesEqual(data.distinctMaterialTextures[j].ts[i]))
					{
						num2++;
					}
					if (data._considerNonTextureProperties && data.nonTexturePropertyBlender.GetColorAsItWouldAppearInAtlasIfNoTexture(data.distinctMaterialTextures[j].matsAndGOs.mats[0].mat, data.texPropertyNames[i]) == color)
					{
						num3++;
					}
				}
				array[i].allTexturesAreNull = num == 0;
				array[i].allTexturesAreSame = num2 == data.distinctMaterialTextures.Count;
				array[i].allNonTexturePropsAreSame = num3 == data.distinctMaterialTextures.Count;
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log($"AllTexturesAreNullAndSameColor prop: {data.texPropertyNames[i].name} createAtlas:{_ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, array)}  val:{array[i]}");
				}
			}
			return array;
		}

		internal static IEnumerator CalculateIdealSizesForTexturesInAtlasAndPadding(ProgressUpdateDelegate progressInfo, MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, TexturePipelineData data, MB3_TextureCombiner combiner, MB2_EditorMethodsInterface textureEditorMethods, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			MeshBakerMaterialTexture.readyToBuildAtlases = true;
			data.allTexturesAreNullAndSameColor = CalculateAllTexturesAreNullAndSameColor(data, LOG_LEVEL);
			int num = data._atlasPadding;
			if (data.distinctMaterialTextures.Count == 1 && !data._fixOutOfBoundsUVs && !data._considerNonTextureProperties)
			{
				if (LOG_LEVEL >= MB2_LogLevel.info)
				{
					UnityEngine.Debug.Log("All objects use the same textures in this set of atlases. Original textures will be reused instead of creating atlases.");
				}
				num = 0;
				data.distinctMaterialTextures[0].SetThisIsOnlyTexSetInAtlasTrue();
				data.distinctMaterialTextures[0].SetTilingTreatmentAndAdjustEncapsulatingSamplingRect(MB_TextureTilingTreatment.edgeToEdgeXY);
			}
			for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					UnityEngine.Debug.Log("Calculating ideal sizes for texSet TexSet " + i + " of " + data.distinctMaterialTextures.Count);
				}
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
				mB_TexSet.idealWidth = 1;
				mB_TexSet.idealHeight = 1;
				int num2 = 1;
				int num3 = 1;
				for (int j = 0; j < data.texPropertyNames.Count; j++)
				{
					if (!_ShouldWeCreateAtlasForThisProperty(j, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
					{
						continue;
					}
					MeshBakerMaterialTexture meshBakerMaterialTexture = mB_TexSet.ts[j];
					if (LOG_LEVEL >= MB2_LogLevel.trace)
					{
						UnityEngine.Debug.Log($"Calculating ideal size for texSet {i} property {data.texPropertyNames[j].name}");
					}
					if (!meshBakerMaterialTexture.matTilingRect.size.Equals(Vector2.one) && data.distinctMaterialTextures.Count > 1 && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.GetTexName(), "is tiled by ", meshBakerMaterialTexture.matTilingRect.size, " tiling will be baked into a texture with maxSize:", data._maxTilingBakeSize));
					}
					if (!mB_TexSet.obUVscale.Equals(Vector2.one) && data.distinctMaterialTextures.Count > 1 && data._fixOutOfBoundsUVs && LOG_LEVEL >= MB2_LogLevel.warn)
					{
						UnityEngine.Debug.LogWarning(string.Concat("Texture ", meshBakerMaterialTexture.GetTexName(), " has out of bounds UVs that effectively tile by ", mB_TexSet.obUVscale, " tiling will be baked into a texture with maxSize:", data._maxTilingBakeSize));
					}
					if (meshBakerMaterialTexture.isNull)
					{
						mB_TexSet.SetEncapsulatingRect(j, data._fixOutOfBoundsUVs);
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log($"No source texture creating a 16x16 texture for {data.texPropertyNames[j].name} texSet {i} srcMat {mB_TexSet.matsAndGOs.mats[0].GetMaterialName()}");
						}
					}
					if (meshBakerMaterialTexture.isNull)
					{
						continue;
					}
					Vector2 adjustedForScaleAndOffset2Dimensions = GetAdjustedForScaleAndOffset2Dimensions(meshBakerMaterialTexture, mB_TexSet.obUVoffset, mB_TexSet.obUVscale, data, LOG_LEVEL);
					if ((int)(adjustedForScaleAndOffset2Dimensions.x * adjustedForScaleAndOffset2Dimensions.y) > num2 * num3)
					{
						if (LOG_LEVEL >= MB2_LogLevel.trace)
						{
							UnityEngine.Debug.Log(string.Concat("    matTex ", meshBakerMaterialTexture.GetTexName(), " ", adjustedForScaleAndOffset2Dimensions, " has a bigger size than ", num2, " ", num3));
						}
						num2 = (int)adjustedForScaleAndOffset2Dimensions.x;
						num3 = (int)adjustedForScaleAndOffset2Dimensions.y;
					}
				}
				if (data._resizePowerOfTwoTextures)
				{
					if (num2 <= num * 5)
					{
						UnityEngine.Debug.LogWarning(string.Format("Some of the textures have widths close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with widths this small.", mB_TexSet.ToString()));
					}
					if (num3 <= num * 5)
					{
						UnityEngine.Debug.LogWarning(string.Format("Some of the textures have heights close to the size of the padding. It is not recommended to use _resizePowerOfTwoTextures with heights this small.", mB_TexSet.ToString()));
					}
					if (IsPowerOfTwo(num2))
					{
						num2 -= num * 2;
					}
					if (IsPowerOfTwo(num3))
					{
						num3 -= num * 2;
					}
					if (num2 < 1)
					{
						num2 = 1;
					}
					if (num3 < 1)
					{
						num3 = 1;
					}
				}
				if (LOG_LEVEL >= MB2_LogLevel.trace)
				{
					UnityEngine.Debug.Log("    Ideal size is " + num2 + " " + num3);
				}
				mB_TexSet.idealWidth = num2;
				mB_TexSet.idealHeight = num3;
			}
			data._atlasPadding = num;
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step2 Calculate Ideal Sizes part1: " + stopwatch.Elapsed.ToString());
			}
			yield break;
		}

		internal static AtlasPackingResult[] __Step3_RunTexturePacker(TexturePipelineData data, MB_ITextureCombinerPacker texturePacker, MB2_LogLevel LOG_LEVEL)
		{
			AtlasPackingResult[] array = texturePacker.CalculateAtlasRectangles(data, doMultiAtlas: true, LOG_LEVEL);
			for (int i = 0; i < array.Length; i++)
			{
				List<MatsAndGOs> list = new List<MatsAndGOs>();
				array[i].data = list;
				for (int j = 0; j < array[i].srcImgIdxs.Length; j++)
				{
					MB_TexSet mB_TexSet = data.distinctMaterialTextures[array[i].srcImgIdxs[j]];
					list.Add(mB_TexSet.matsAndGOs);
				}
			}
			return array;
		}

		internal static MB_ITextureCombinerPacker CreatePacker(bool onlyOneTextureInAtlasReuseTextures, MB2_PackingAlgorithmEnum packingAlgorithm)
		{
			if (onlyOneTextureInAtlasReuseTextures)
			{
				return new MB3_TextureCombinerPackerOneTextureInAtlas();
			}
			switch (packingAlgorithm)
			{
			case MB2_PackingAlgorithmEnum.UnitysPackTextures:
				return new MB3_TextureCombinerPackerUnity();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal:
				if (USE_EXPERIMENTAL_HOIZONTALVERTICAL)
				{
					return new MB3_TextureCombinerPackerMeshBakerHorizontalVertical(MB3_TextureCombinerPackerMeshBakerHorizontalVertical.AtlasDirection.horizontal);
				}
				return new MB3_TextureCombinerPackerMeshBaker();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical:
				if (USE_EXPERIMENTAL_HOIZONTALVERTICAL)
				{
					return new MB3_TextureCombinerPackerMeshBakerHorizontalVertical(MB3_TextureCombinerPackerMeshBakerHorizontalVertical.AtlasDirection.vertical);
				}
				return new MB3_TextureCombinerPackerMeshBaker();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker:
				return new MB3_TextureCombinerPackerMeshBaker();
			default:
				return new MB3_TextureCombinerPackerMeshBakerFast();
			}
		}

		internal static IEnumerator __Step3_BuildAndSaveAtlasesAndStoreResults(MB3_TextureCombiner.CombineTexturesIntoAtlasesCoroutineResult result, ProgressUpdateDelegate progressInfo, TexturePipelineData data, MB3_TextureCombiner combiner, MB_ITextureCombinerPacker packer, AtlasPackingResult atlasPackingResult, MB2_EditorMethodsInterface textureEditorMethods, MB_AtlasesAndRects resultAtlasesAndRects, StringBuilder report, MB2_LogLevel LOG_LEVEL)
		{
			Stopwatch sw = new Stopwatch();
			sw.Start();
			GC.Collect();
			Texture2D[] atlases = new Texture2D[data.numAtlases];
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("time Step 3 Create And Save Atlases part 1 " + sw.Elapsed.ToString());
			}
			yield return packer.CreateAtlases(progressInfo, data, combiner, atlasPackingResult, atlases, textureEditorMethods, LOG_LEVEL);
			float num = sw.ElapsedMilliseconds;
			data.nonTexturePropertyBlender.AdjustNonTextureProperties(data.resultMaterial, data.texPropertyNames, data.distinctMaterialTextures, textureEditorMethods);
			if (data.distinctMaterialTextures.Count > 0)
			{
				data.distinctMaterialTextures[0].AdjustResultMaterialNonTextureProperties(data.resultMaterial, data.texPropertyNames);
			}
			progressInfo?.Invoke("Building Report", 0.7f);
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("---- Atlases ------");
			for (int i = 0; i < data.numAtlases; i++)
			{
				if (atlases[i] != null)
				{
					stringBuilder.AppendLine("Created Atlas For: " + data.texPropertyNames[i].name + " h=" + atlases[i].height + " w=" + atlases[i].width);
				}
				else if (!_ShouldWeCreateAtlasForThisProperty(i, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
				{
					stringBuilder.AppendLine("Did not create atlas for " + data.texPropertyNames[i].name + " because all source textures were null.");
				}
			}
			report.Append(stringBuilder.ToString());
			List<MB_MaterialAndUVRect> list = new List<MB_MaterialAndUVRect>();
			for (int j = 0; j < data.distinctMaterialTextures.Count; j++)
			{
				MB_TexSet mB_TexSet = data.distinctMaterialTextures[j];
				List<MatAndTransformToMerged> mats = mB_TexSet.matsAndGOs.mats;
				mB_TexSet.GetRectsForTextureBakeResults(out var allPropsUseSameTiling_encapsulatingSamplingRect, out var propsUseDifferntTiling_obUVRect);
				for (int k = 0; k < mats.Count; k++)
				{
					Rect materialTilingRectForTextureBakerResults = mB_TexSet.GetMaterialTilingRectForTextureBakerResults(k);
					MB_MaterialAndUVRect item = new MB_MaterialAndUVRect(mats[k].mat, atlasPackingResult.rects[j], mB_TexSet.allTexturesUseSameMatTiling, materialTilingRectForTextureBakerResults, allPropsUseSameTiling_encapsulatingSamplingRect, propsUseDifferntTiling_obUVRect, mB_TexSet.tilingTreatment, mats[k].objName);
					if (!list.Contains(item))
					{
						list.Add(item);
					}
				}
			}
			resultAtlasesAndRects.atlases = atlases;
			resultAtlasesAndRects.texPropertyNames = ShaderTextureProperty.GetNames(data.texPropertyNames);
			resultAtlasesAndRects.mat2rect_map = list;
			progressInfo?.Invoke("Restoring Texture Formats & Read Flags", 0.8f);
			combiner._destroyAllTemporaryTextures();
			textureEditorMethods?.RestoreReadFlagsAndFormats(progressInfo);
			if (report != null && LOG_LEVEL >= MB2_LogLevel.info)
			{
				UnityEngine.Debug.Log(report.ToString());
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Time Step 3 Create And Save Atlases part 3 " + ((float)sw.ElapsedMilliseconds - num).ToString("f5"));
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log("Total time Step 3 Create And Save Atlases " + sw.Elapsed.ToString());
			}
		}

		internal static StringBuilder GenerateReport(TexturePipelineData data)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (data.numAtlases > 0)
			{
				stringBuilder = new StringBuilder();
				stringBuilder.AppendLine("Report");
				for (int i = 0; i < data.distinctMaterialTextures.Count; i++)
				{
					MB_TexSet mB_TexSet = data.distinctMaterialTextures[i];
					stringBuilder.AppendLine("----------");
					stringBuilder.Append("This set of textures will be resized to:" + mB_TexSet.idealWidth + "x" + mB_TexSet.idealHeight + "\n");
					for (int j = 0; j < mB_TexSet.ts.Length; j++)
					{
						if (!mB_TexSet.ts[j].isNull)
						{
							stringBuilder.Append("   [" + data.texPropertyNames[j].name + " " + mB_TexSet.ts[j].GetTexName() + " " + mB_TexSet.ts[j].width + "x" + mB_TexSet.ts[j].height + "]");
							if (mB_TexSet.ts[j].matTilingRect.size != Vector2.one || mB_TexSet.ts[j].matTilingRect.min != Vector2.zero)
							{
								stringBuilder.AppendFormat(" material scale {0} offset{1} ", mB_TexSet.ts[j].matTilingRect.size.ToString("G4"), mB_TexSet.ts[j].matTilingRect.min.ToString("G4"));
							}
							if (mB_TexSet.obUVscale != Vector2.one || mB_TexSet.obUVoffset != Vector2.zero)
							{
								stringBuilder.AppendFormat(" obUV scale {0} offset{1} ", mB_TexSet.obUVscale.ToString("G4"), mB_TexSet.obUVoffset.ToString("G4"));
							}
							stringBuilder.AppendLine("");
						}
						else
						{
							stringBuilder.Append("   [" + data.texPropertyNames[j].name + " null ");
							if (!_ShouldWeCreateAtlasForThisProperty(j, data._considerNonTextureProperties, data.allTexturesAreNullAndSameColor))
							{
								stringBuilder.Append("no atlas will be created all textures null]\n");
							}
							else
							{
								stringBuilder.AppendFormat("a 16x16 texture will be created]\n");
							}
						}
					}
					stringBuilder.AppendLine("");
					stringBuilder.Append("Materials using:");
					for (int k = 0; k < mB_TexSet.matsAndGOs.mats.Count; k++)
					{
						stringBuilder.Append(mB_TexSet.matsAndGOs.mats[k].mat.name + ", ");
					}
					stringBuilder.AppendLine("");
				}
			}
			return stringBuilder;
		}

		internal static MB2_TexturePacker CreateTexturePacker(MB2_PackingAlgorithmEnum _packingAlgorithm)
		{
			switch (_packingAlgorithm)
			{
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker:
				return new MB2_TexturePackerRegular();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Fast:
				return new MB2_TexturePackerRegular();
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Horizontal:
				return new MB2_TexturePackerHorizontalVert
				{
					packingOrientation = MB2_TexturePackerHorizontalVert.TexturePackingOrientation.horizontal
				};
			case MB2_PackingAlgorithmEnum.MeshBakerTexturePacker_Vertical:
				return new MB2_TexturePackerHorizontalVert
				{
					packingOrientation = MB2_TexturePackerHorizontalVert.TexturePackingOrientation.vertical
				};
			default:
				UnityEngine.Debug.LogError("packing algorithm must be one of the MeshBaker options to create a Texture Packer");
				return null;
			}
		}

		internal static Vector2 GetAdjustedForScaleAndOffset2Dimensions(MeshBakerMaterialTexture source, Vector2 obUVoffset, Vector2 obUVscale, TexturePipelineData data, MB2_LogLevel LOG_LEVEL)
		{
			if (source.matTilingRect.x == 0.0 && source.matTilingRect.y == 0.0 && source.matTilingRect.width == 1.0 && source.matTilingRect.height == 1.0)
			{
				if (!data._fixOutOfBoundsUVs)
				{
					return new Vector2(source.width, source.height);
				}
				if (obUVoffset.x == 0f && obUVoffset.y == 0f && obUVscale.x == 1f && obUVscale.y == 1f)
				{
					return new Vector2(source.width, source.height);
				}
			}
			if (LOG_LEVEL >= MB2_LogLevel.debug)
			{
				UnityEngine.Debug.Log(string.Concat("GetAdjustedForScaleAndOffset2Dimensions: ", source.GetTexName(), " ", obUVoffset, " ", obUVscale));
			}
			Rect rect = source.GetEncapsulatingSamplingRect().GetRect();
			float num = rect.width * (float)source.width;
			float num2 = rect.height * (float)source.height;
			if (num > (float)data._maxTilingBakeSize)
			{
				num = data._maxTilingBakeSize;
			}
			if (num2 > (float)data._maxTilingBakeSize)
			{
				num2 = data._maxTilingBakeSize;
			}
			if (num < 1f)
			{
				num = 1f;
			}
			if (num2 < 1f)
			{
				num2 = 1f;
			}
			return new Vector2(num, num2);
		}

		internal static Color32 ConvertNormalFormatFromUnity_ToStandard(Color32 c)
		{
			Vector3 zero = Vector3.zero;
			zero.x = (float)(int)c.a * 2f - 1f;
			zero.y = (float)(int)c.g * 2f - 1f;
			zero.z = Mathf.Sqrt(1f - zero.x * zero.x - zero.y * zero.y);
			Color32 result = default(Color32);
			result.a = 1;
			result.r = (byte)((zero.x + 1f) * 0.5f);
			result.g = (byte)((zero.y + 1f) * 0.5f);
			result.b = (byte)((zero.z + 1f) * 0.5f);
			return result;
		}

		internal static float GetSubmeshArea(Mesh m, int submeshIdx)
		{
			if (submeshIdx >= m.subMeshCount || submeshIdx < 0)
			{
				return 0f;
			}
			Vector3[] vertices = m.vertices;
			int[] indices = m.GetIndices(submeshIdx);
			float num = 0f;
			for (int i = 0; i < indices.Length; i += 3)
			{
				Vector3 vector = vertices[indices[i]];
				Vector3 vector2 = vertices[indices[i + 1]];
				Vector3 vector3 = vertices[indices[i + 2]];
				num += Vector3.Cross(vector2 - vector, vector3 - vector).magnitude / 2f;
			}
			return num;
		}

		internal static bool IsPowerOfTwo(int x)
		{
			return (x & (x - 1)) == 0;
		}
	}
	public class MBVersionConcrete : MBVersionInterface
	{
		private Vector2 _HALF_UV = new Vector2(0.5f, 0.5f);

		public string version()
		{
			return "3.26.0";
		}

		public int GetMajorVersion()
		{
			return int.Parse(Application.unityVersion.Split('.')[0]);
		}

		public int GetMinorVersion()
		{
			return int.Parse(Application.unityVersion.Split('.')[1]);
		}

		public bool GetActive(GameObject go)
		{
			return go.activeInHierarchy;
		}

		public void SetActive(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public void SetActiveRecursively(GameObject go, bool isActive)
		{
			go.SetActive(isActive);
		}

		public UnityEngine.Object[] FindSceneObjectsOfType(Type t)
		{
			return UnityEngine.Object.FindObjectsOfType(t);
		}

		public void OptimizeMesh(Mesh m)
		{
		}

		public bool IsRunningAndMeshNotReadWriteable(Mesh m)
		{
			if (Application.isPlaying)
			{
				return !m.isReadable;
			}
			return false;
		}

		public Vector2[] GetMeshUV1s(Mesh m, MB2_LogLevel LOG_LEVEL)
		{
			if (LOG_LEVEL >= MB2_LogLevel.warn)
			{
				MB2_Log.LogDebug("UV1 does not exist in Unity 5+");
			}
			Vector2[] array = m.uv;
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv1s. Generating"));
				}
				if (LOG_LEVEL >= MB2_LogLevel.warn)
				{
					UnityEngine.Debug.LogWarning(string.Concat("Mesh ", m, " didn't have uv1s. Generating uv1s."));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public Vector2[] GetMeshUV3orUV4(Mesh m, bool get3, MB2_LogLevel LOG_LEVEL)
		{
			Vector2[] array = ((!get3) ? m.uv4 : m.uv3);
			if (array.Length == 0)
			{
				if (LOG_LEVEL >= MB2_LogLevel.debug)
				{
					MB2_Log.LogDebug(string.Concat("Mesh ", m, " has no uv", get3 ? "3" : "4", ". Generating"));
				}
				array = new Vector2[m.vertexCount];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _HALF_UV;
				}
			}
			return array;
		}

		public void MeshClear(Mesh m, bool t)
		{
			m.Clear(t);
		}

		public void MeshAssignUV3(Mesh m, Vector2[] uv3s)
		{
			m.uv3 = uv3s;
		}

		public void MeshAssignUV4(Mesh m, Vector2[] uv4s)
		{
			m.uv4 = uv4s;
		}

		public Vector4 GetLightmapTilingOffset(Renderer r)
		{
			return r.lightmapScaleOffset;
		}

		public Transform[] GetBones(Renderer r)
		{
			if (r is SkinnedMeshRenderer)
			{
				return ((SkinnedMeshRenderer)r).bones;
			}
			if (r is MeshRenderer)
			{
				return new Transform[1] { r.transform };
			}
			UnityEngine.Debug.LogError("Could not getBones. Object does not have a renderer");
			return null;
		}

		public int GetBlendShapeFrameCount(Mesh m, int shapeIndex)
		{
			return m.GetBlendShapeFrameCount(shapeIndex);
		}

		public float GetBlendShapeFrameWeight(Mesh m, int shapeIndex, int frameIndex)
		{
			return m.GetBlendShapeFrameWeight(shapeIndex, frameIndex);
		}

		public void GetBlendShapeFrameVertices(Mesh m, int shapeIndex, int frameIndex, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.GetBlendShapeFrameVertices(shapeIndex, frameIndex, vs, ns, ts);
		}

		public void ClearBlendShapes(Mesh m)
		{
			m.ClearBlendShapes();
		}

		public void AddBlendShapeFrame(Mesh m, string nm, float wt, Vector3[] vs, Vector3[] ns, Vector3[] ts)
		{
			m.AddBlendShapeFrame(nm, wt, vs, ns, ts);
		}

		public int MaxMeshVertexCount()
		{
			return 2147483646;
		}

		public void SetMeshIndexFormatAndClearMesh(Mesh m, int numVerts, bool vertices, bool justClearTriangles)
		{
			if (vertices && numVerts > 65534 && m.indexFormat == IndexFormat.UInt16)
			{
				MBVersion.MeshClear(m, t: false);
				m.indexFormat = IndexFormat.UInt32;
			}
			else if (vertices && numVerts <= 65534 && m.indexFormat == IndexFormat.UInt32)
			{
				MBVersion.MeshClear(m, t: false);
				m.indexFormat = IndexFormat.UInt16;
			}
			else if (justClearTriangles)
			{
				MBVersion.MeshClear(m, t: true);
			}
			else
			{
				MBVersion.MeshClear(m, t: false);
			}
		}
	}
	[Serializable]
	public class GrouperData
	{
		public bool clusterOnLMIndex;

		public bool clusterByLODLevel;

		public Vector3 origin;

		public Vector3 cellSize;

		public int pieNumSegments = 4;

		public Vector3 pieAxis = Vector3.up;

		public int height = 1;

		public float maxDistBetweenClusters = 1f;

		public bool includeCellsWithOnlyOneRenderer = true;
	}
	[Serializable]
	public abstract class MB3_MeshBakerGrouperCore
	{
		public GrouperData d;

		public abstract Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection);

		public abstract void DrawGizmos(Bounds sourceObjectBounds);

		public void DoClustering(MB3_TextureBaker tb, MB3_MeshBakerGrouper grouper)
		{
			Dictionary<string, List<Renderer>> dictionary = FilterIntoGroups(tb.GetObjectsToCombine());
			if (d.clusterOnLMIndex)
			{
				Dictionary<string, List<Renderer>> dictionary2 = new Dictionary<string, List<Renderer>>();
				foreach (string key4 in dictionary.Keys)
				{
					List<Renderer> gaws = dictionary[key4];
					Dictionary<int, List<Renderer>> dictionary3 = GroupByLightmapIndex(gaws);
					foreach (int key5 in dictionary3.Keys)
					{
						string key = key4 + "-LM-" + key5;
						dictionary2.Add(key, dictionary3[key5]);
					}
				}
				dictionary = dictionary2;
			}
			if (d.clusterByLODLevel)
			{
				Dictionary<string, List<Renderer>> dictionary4 = new Dictionary<string, List<Renderer>>();
				foreach (string key6 in dictionary.Keys)
				{
					foreach (Renderer r in dictionary[key6])
					{
						if (r == null)
						{
							continue;
						}
						bool flag = false;
						LODGroup componentInParent = r.GetComponentInParent<LODGroup>();
						if (componentInParent != null)
						{
							LOD[] lODs = componentInParent.GetLODs();
							for (int i = 0; i < lODs.Length; i++)
							{
								if (Array.Find(lODs[i].renderers, (Renderer x) => x == r) != null)
								{
									flag = true;
									string key2 = $"{key6}_LOD{i}";
									if (!dictionary4.TryGetValue(key2, out var value))
									{
										value = new List<Renderer>();
										dictionary4.Add(key2, value);
									}
									if (!value.Contains(r))
									{
										value.Add(r);
									}
								}
							}
						}
						if (!flag)
						{
							string key3 = $"{key6}_LOD0";
							if (!dictionary4.TryGetValue(key3, out var value2))
							{
								value2 = new List<Renderer>();
								dictionary4.Add(key3, value2);
							}
							if (!value2.Contains(r))
							{
								value2.Add(r);
							}
						}
					}
				}
				dictionary = dictionary4;
			}
			int num = 0;
			foreach (string key7 in dictionary.Keys)
			{
				List<Renderer> list = dictionary[key7];
				if (list.Count > 1 || grouper.data.includeCellsWithOnlyOneRenderer)
				{
					AddMeshBaker(tb, key7, list);
				}
				else
				{
					num++;
				}
			}
			UnityEngine.Debug.Log($"Found {dictionary.Count} cells with Renderers. Not creating bakers for {num} because there is only one mesh in the cell. Creating {dictionary.Count - num} bakers.");
		}

		private Dictionary<int, List<Renderer>> GroupByLightmapIndex(List<Renderer> gaws)
		{
			Dictionary<int, List<Renderer>> dictionary = new Dictionary<int, List<Renderer>>();
			for (int i = 0; i < gaws.Count; i++)
			{
				List<Renderer> list = null;
				if (dictionary.ContainsKey(gaws[i].lightmapIndex))
				{
					list = dictionary[gaws[i].lightmapIndex];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(gaws[i].lightmapIndex, list);
				}
				list.Add(gaws[i]);
			}
			return dictionary;
		}

		private void AddMeshBaker(MB3_TextureBaker tb, string key, List<Renderer> gaws)
		{
			int num = 0;
			for (int i = 0; i < gaws.Count; i++)
			{
				Mesh mesh = MB_Utility.GetMesh(gaws[i].gameObject);
				if (mesh != null)
				{
					num += mesh.vertexCount;
				}
			}
			GameObject gameObject = new GameObject("MeshBaker-" + key);
			gameObject.transform.position = Vector3.zero;
			MB3_MeshBakerCommon mB3_MeshBakerCommon;
			if (num >= 65535)
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MultiMeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			else
			{
				mB3_MeshBakerCommon = gameObject.AddComponent<MB3_MeshBaker>();
				mB3_MeshBakerCommon.useObjsToMeshFromTexBaker = false;
			}
			mB3_MeshBakerCommon.textureBakeResults = tb.textureBakeResults;
			mB3_MeshBakerCommon.transform.parent = tb.transform;
			for (int j = 0; j < gaws.Count; j++)
			{
				mB3_MeshBakerCommon.GetObjectsToCombine().Add(gaws[j].gameObject);
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperNone : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperNone(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			UnityEngine.Debug.Log("Filtering into groups none");
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<Renderer> list = new List<Renderer>();
			for (int i = 0; i < selection.Count; i++)
			{
				if (selection[i] != null)
				{
					list.Add(selection[i].GetComponent<Renderer>());
				}
			}
			dictionary.Add("MeshBaker", list);
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperGrid : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperGrid(GrouperData d)
		{
			base.d = d;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.cellSize.x <= 0f || d.cellSize.y <= 0f || d.cellSize.z <= 0f)
			{
				UnityEngine.Debug.LogError("cellSize x,y,z must all be greater than zero.");
				return dictionary;
			}
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (component is MeshRenderer || component is SkinnedMeshRenderer)
				{
					Vector3 center = component.bounds.center;
					center.x = Mathf.Floor((center.x - d.origin.x) / d.cellSize.x) * d.cellSize.x;
					center.y = Mathf.Floor((center.y - d.origin.y) / d.cellSize.y) * d.cellSize.y;
					center.z = Mathf.Floor((center.z - d.origin.z) / d.cellSize.z) * d.cellSize.z;
					List<Renderer> list = null;
					string key = center.ToString();
					if (dictionary.ContainsKey(key))
					{
						list = dictionary[key];
					}
					else
					{
						list = new List<Renderer>();
						dictionary.Add(key, list);
					}
					if (!list.Contains(component))
					{
						list.Add(component);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			Vector3 cellSize = d.cellSize;
			if (cellSize.x <= 1E-05f || cellSize.y <= 1E-05f || cellSize.z <= 1E-05f)
			{
				return;
			}
			Vector3 vector = sourceObjectBounds.center - sourceObjectBounds.extents;
			Vector3 origin = d.origin;
			origin.x %= cellSize.x;
			origin.y %= cellSize.y;
			origin.z %= cellSize.z;
			vector.x = Mathf.Round(vector.x / cellSize.x) * cellSize.x + origin.x;
			vector.y = Mathf.Round(vector.y / cellSize.y) * cellSize.y + origin.y;
			vector.z = Mathf.Round(vector.z / cellSize.z) * cellSize.z + origin.z;
			if (vector.x > sourceObjectBounds.center.x - sourceObjectBounds.extents.x)
			{
				vector.x -= cellSize.x;
			}
			if (vector.y > sourceObjectBounds.center.y - sourceObjectBounds.extents.y)
			{
				vector.y -= cellSize.y;
			}
			if (vector.z > sourceObjectBounds.center.z - sourceObjectBounds.extents.z)
			{
				vector.z -= cellSize.z;
			}
			Vector3 vector2 = vector;
			if (Mathf.CeilToInt(sourceObjectBounds.size.x / cellSize.x + sourceObjectBounds.size.y / cellSize.y + sourceObjectBounds.size.z / cellSize.z) > 200)
			{
				Gizmos.DrawWireCube(d.origin + cellSize / 2f, cellSize);
				return;
			}
			while (vector.x < sourceObjectBounds.center.x + sourceObjectBounds.extents.x)
			{
				vector.y = vector2.y;
				while (vector.y < sourceObjectBounds.center.y + sourceObjectBounds.extents.y)
				{
					vector.z = vector2.z;
					while (vector.z < sourceObjectBounds.center.z + sourceObjectBounds.extents.z)
					{
						Gizmos.DrawWireCube(vector + cellSize / 2f, cellSize);
						vector.z += cellSize.z;
					}
					vector.y += cellSize.y;
				}
				vector.x += cellSize.x;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperPie : MB3_MeshBakerGrouperCore
	{
		public MB3_MeshBakerGrouperPie(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			if (d.pieNumSegments == 0)
			{
				UnityEngine.Debug.LogError("pieNumSegments must be greater than zero.");
				return dictionary;
			}
			if (d.pieAxis.magnitude <= 1E-06f)
			{
				UnityEngine.Debug.LogError("Pie axis must have length greater than zero.");
				return dictionary;
			}
			d.pieAxis.Normalize();
			Quaternion quaternion = Quaternion.FromToRotation(d.pieAxis, Vector3.up);
			UnityEngine.Debug.Log("Collecting renderers in each cell");
			foreach (GameObject item in selection)
			{
				if (item == null)
				{
					continue;
				}
				Renderer component = item.GetComponent<Renderer>();
				if (!(component is MeshRenderer) && !(component is SkinnedMeshRenderer))
				{
					continue;
				}
				Vector3 vector = component.bounds.center - d.origin;
				vector.Normalize();
				vector = quaternion * vector;
				float num = 0f;
				if (Mathf.Abs(vector.x) < 0.0001f && Mathf.Abs(vector.z) < 0.0001f)
				{
					num = 0f;
				}
				else
				{
					num = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
					if (num < 0f)
					{
						num = 360f + num;
					}
				}
				int num2 = Mathf.FloorToInt(num / 360f * (float)d.pieNumSegments);
				List<Renderer> list = null;
				string key = "seg_" + num2;
				if (dictionary.ContainsKey(key))
				{
					list = dictionary[key];
				}
				else
				{
					list = new List<Renderer>();
					dictionary.Add(key, list);
				}
				if (!list.Contains(component))
				{
					list.Add(component);
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sourceObjectBounds)
		{
			if (!(d.pieAxis.magnitude < 0.1f) && d.pieNumSegments >= 1)
			{
				float magnitude = sourceObjectBounds.extents.magnitude;
				DrawCircle(d.pieAxis, d.origin, magnitude, 24);
				Quaternion quaternion = Quaternion.FromToRotation(Vector3.up, d.pieAxis);
				Quaternion quaternion2 = Quaternion.AngleAxis(180f / (float)d.pieNumSegments, Vector3.up);
				Vector3 vector = Vector3.forward;
				for (int i = 0; i < d.pieNumSegments; i++)
				{
					Vector3 vector2 = quaternion * vector;
					Gizmos.DrawLine(d.origin, d.origin + vector2 * magnitude);
					vector = quaternion2 * vector;
					vector = quaternion2 * vector;
				}
			}
		}

		public static void DrawCircle(Vector3 axis, Vector3 center, float radius, int subdiv)
		{
			Quaternion quaternion = Quaternion.AngleAxis(360 / subdiv, axis);
			Vector3 vector = new Vector3(axis.y, 0f - axis.x, axis.z);
			vector.Normalize();
			vector *= radius;
			for (int i = 0; i < subdiv + 1; i++)
			{
				Vector3 vector2 = quaternion * vector;
				Gizmos.DrawLine(center + vector, center + vector2);
				vector = vector2;
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperKMeans : MB3_MeshBakerGrouperCore
	{
		public int numClusters = 4;

		public Vector3[] clusterCenters = new Vector3[0];

		public float[] clusterSizes = new float[0];

		public MB3_MeshBakerGrouperKMeans(GrouperData data)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			List<GameObject> list = new List<GameObject>();
			int num = 20;
			foreach (GameObject item in selection)
			{
				if (!(item == null))
				{
					GameObject gameObject = item;
					Renderer component = gameObject.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(gameObject);
					}
				}
			}
			if (list.Count > 0 && num > 0 && num < list.Count)
			{
				MB3_KMeansClustering mB3_KMeansClustering = new MB3_KMeansClustering(list, num);
				mB3_KMeansClustering.Cluster();
				clusterCenters = new Vector3[num];
				clusterSizes = new float[num];
				for (int i = 0; i < num; i++)
				{
					List<Renderer> cluster = mB3_KMeansClustering.GetCluster(i, out clusterCenters[i], out clusterSizes[i]);
					if (cluster.Count > 0)
					{
						dictionary.Add("Cluster_" + i, cluster);
					}
				}
			}
			return dictionary;
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (clusterCenters != null && clusterSizes != null && clusterCenters.Length == clusterSizes.Length)
			{
				for (int i = 0; i < clusterSizes.Length; i++)
				{
					Gizmos.DrawWireSphere(clusterCenters[i], clusterSizes[i]);
				}
			}
		}
	}
	[Serializable]
	public class MB3_MeshBakerGrouperCluster : MB3_MeshBakerGrouperCore
	{
		public MB3_AgglomerativeClustering cluster;

		private float _lastMaxDistBetweenClusters;

		public float _ObjsExtents = 10f;

		public float _minDistBetweenClusters = 0.001f;

		private List<MB3_AgglomerativeClustering.ClusterNode> _clustersToDraw = new List<MB3_AgglomerativeClustering.ClusterNode>();

		private float[] _radii;

		public MB3_MeshBakerGrouperCluster(GrouperData data, List<GameObject> gos)
		{
			d = data;
		}

		public override Dictionary<string, List<Renderer>> FilterIntoGroups(List<GameObject> selection)
		{
			Dictionary<string, List<Renderer>> dictionary = new Dictionary<string, List<Renderer>>();
			for (int i = 0; i < _clustersToDraw.Count; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = _clustersToDraw[i];
				List<Renderer> list = new List<Renderer>();
				for (int j = 0; j < clusterNode.leafs.Length; j++)
				{
					Renderer component = cluster.clusters[clusterNode.leafs[j]].leaf.go.GetComponent<Renderer>();
					if (component is MeshRenderer || component is SkinnedMeshRenderer)
					{
						list.Add(component);
					}
				}
				dictionary.Add("Cluster_" + i, list);
			}
			return dictionary;
		}

		public void BuildClusters(List<GameObject> gos, ProgressUpdateCancelableDelegate progFunc)
		{
			if (gos.Count == 0)
			{
				UnityEngine.Debug.LogWarning("No objects to cluster. Add some objects to the list of Objects To Combine.");
				return;
			}
			if (cluster == null)
			{
				cluster = new MB3_AgglomerativeClustering();
			}
			List<MB3_AgglomerativeClustering.item_s> list = new List<MB3_AgglomerativeClustering.item_s>();
			int i;
			for (i = 0; i < gos.Count; i++)
			{
				if (gos[i] != null && list.Find((MB3_AgglomerativeClustering.item_s x) => x.go == gos[i]) == null)
				{
					Renderer component = gos[i].GetComponent<Renderer>();
					if (component != null && (component is MeshRenderer || component is SkinnedMeshRenderer))
					{
						MB3_AgglomerativeClustering.item_s item_s = new MB3_AgglomerativeClustering.item_s();
						item_s.go = gos[i];
						item_s.coord = component.bounds.center;
						list.Add(item_s);
					}
				}
			}
			cluster.items = list;
			cluster.agglomerate(progFunc);
			if (!cluster.wasCanceled)
			{
				_BuildListOfClustersToDraw(progFunc, out var smallest, out var largest);
				d.maxDistBetweenClusters = Mathf.Lerp(smallest, largest, 0.9f);
			}
		}

		private void _BuildListOfClustersToDraw(ProgressUpdateCancelableDelegate progFunc, out float smallest, out float largest)
		{
			_clustersToDraw.Clear();
			if (cluster.clusters == null)
			{
				smallest = 1f;
				largest = 10f;
				return;
			}
			progFunc?.Invoke("Building Clusters To Draw A:", 0f);
			List<MB3_AgglomerativeClustering.ClusterNode> list = new List<MB3_AgglomerativeClustering.ClusterNode>();
			largest = 1f;
			smallest = 10000000f;
			for (int i = 0; i < cluster.clusters.Length; i++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode = cluster.clusters[i];
				if (clusterNode.distToMergedCentroid <= d.maxDistBetweenClusters)
				{
					if (d.includeCellsWithOnlyOneRenderer)
					{
						_clustersToDraw.Add(clusterNode);
					}
					else if (clusterNode.leaf == null)
					{
						_clustersToDraw.Add(clusterNode);
					}
				}
				if (clusterNode.distToMergedCentroid > largest)
				{
					largest = clusterNode.distToMergedCentroid;
				}
				if (clusterNode.height > 0 && clusterNode.distToMergedCentroid < smallest)
				{
					smallest = clusterNode.distToMergedCentroid;
				}
			}
			progFunc?.Invoke("Building Clusters To Draw B:", 0f);
			for (int j = 0; j < _clustersToDraw.Count; j++)
			{
				list.Add(_clustersToDraw[j].cha);
				list.Add(_clustersToDraw[j].chb);
			}
			for (int k = 0; k < list.Count; k++)
			{
				_clustersToDraw.Remove(list[k]);
			}
			_radii = new float[_clustersToDraw.Count];
			progFunc?.Invoke("Building Clusters To Draw C:", 0f);
			for (int l = 0; l < _radii.Length; l++)
			{
				MB3_AgglomerativeClustering.ClusterNode clusterNode2 = _clustersToDraw[l];
				Bounds bounds = new Bounds(clusterNode2.centroid, Vector3.one);
				for (int m = 0; m < clusterNode2.leafs.Length; m++)
				{
					Renderer component = cluster.clusters[clusterNode2.leafs[m]].leaf.go.GetComponent<Renderer>();
					if (component != null)
					{
						bounds.Encapsulate(component.bounds);
					}
				}
				_radii[l] = bounds.extents.magnitude;
			}
			progFunc?.Invoke("Building Clusters To Draw D:", 0f);
			_ObjsExtents = largest + 1f;
			_minDistBetweenClusters = Mathf.Lerp(smallest, 0f, 0.9f);
			if (_ObjsExtents < 2f)
			{
				_ObjsExtents = 2f;
			}
		}

		public override void DrawGizmos(Bounds sceneObjectBounds)
		{
			if (cluster != null && cluster.clusters != null)
			{
				if (_lastMaxDistBetweenClusters != d.maxDistBetweenClusters)
				{
					_BuildListOfClustersToDraw(null, out var _, out var _);
					_lastMaxDistBetweenClusters = d.maxDistBetweenClusters;
				}
				for (int i = 0; i < _clustersToDraw.Count; i++)
				{
					Gizmos.color = Color.white;
					Gizmos.DrawWireSphere(_clustersToDraw[i].centroid, _radii[i]);
				}
			}
		}
	}
	public interface TextureBlender
	{
		bool DoesShaderNameMatch(string shaderName);

		void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName);

		Color OnBlendTexturePixel(string shaderPropertyName, Color pixelColor);

		bool NonTexturePropertiesAreEqual(Material a, Material b);

		void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial);

		Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName);
	}
	public class TextureBlenderFallback : TextureBlender
	{
		private bool m_doTintColor;

		private Color m_tintColor;

		private Color m_defaultColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return true;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				m_doTintColor = true;
				m_tintColor = Color.white;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else if (sourceMat.HasProperty("_TintColor"))
				{
					m_tintColor = sourceMat.GetColor("_TintColor");
				}
			}
			else
			{
				m_doTintColor = false;
			}
		}

		public Color OnBlendTexturePixel(string shaderPropertyName, Color pixelColor)
		{
			if (m_doTintColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (a.HasProperty("_Color"))
			{
				if (_compareColor(a, b, m_defaultColor, "_Color"))
				{
					return true;
				}
			}
			else if (a.HasProperty("_TintColor") && _compareColor(a, b, m_defaultColor, "_TintColor"))
			{
				return true;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.HasProperty("_Color"))
			{
				resultMaterial.SetColor("_Color", m_defaultColor);
			}
			else if (resultMaterial.HasProperty("_TintColor"))
			{
				resultMaterial.SetColor("_TintColor", m_defaultColor);
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texProperty)
		{
			if (texProperty.isNormalMap)
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texProperty.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						return mat.GetColor("_Color");
					}
					catch (Exception)
					{
					}
				}
				else if (mat != null && mat.HasProperty("_TintColor"))
				{
					try
					{
						return mat.GetColor("_TintColor");
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_SpecGlossMap"))
			{
				if (mat != null && mat.HasProperty("_SpecColor"))
				{
					try
					{
						Color color = mat.GetColor("_SpecColor");
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								color.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						UnityEngine.Debug.LogWarning(color);
						return color;
					}
					catch (Exception)
					{
					}
				}
			}
			else if (texProperty.name.Equals("_MetallicGlossMap"))
			{
				if (mat != null && mat.HasProperty("_Metallic"))
				{
					try
					{
						float @float = mat.GetFloat("_Metallic");
						Color result = new Color(@float, @float, @float);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								result.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						return result;
					}
					catch (Exception)
					{
					}
				}
			}
			else
			{
				if (texProperty.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texProperty.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texProperty.name.Equals("_EmissionMap"))
				{
					if (mat != null && mat.HasProperty("_EmissionScaleUI"))
					{
						if (mat.HasProperty("_EmissionColor") && mat.HasProperty("_EmissionColorUI"))
						{
							try
							{
								Color color2 = mat.GetColor("_EmissionColor");
								Color color3 = mat.GetColor("_EmissionColorUI");
								float float2 = mat.GetFloat("_EmissionScaleUI");
								if (color2 == new Color(0f, 0f, 0f, 0f) && color3 == new Color(1f, 1f, 1f, 1f))
								{
									return new Color(float2, float2, float2, float2);
								}
								return color3;
							}
							catch (Exception)
							{
							}
						}
						else
						{
							try
							{
								float float3 = mat.GetFloat("_EmissionScaleUI");
								return new Color(float3, float3, float3, float3);
							}
							catch (Exception)
							{
							}
						}
					}
				}
				else if (texProperty.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}

		public static bool _compareColor(Material a, Material b, Color defaultVal, string propertyName)
		{
			Color color = defaultVal;
			Color color2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				color = a.GetColor(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				color2 = b.GetColor(propertyName);
			}
			if (color != color2)
			{
				return false;
			}
			return true;
		}

		public static bool _compareFloat(Material a, Material b, float defaultVal, string propertyName)
		{
			float num = defaultVal;
			float num2 = defaultVal;
			if (a.HasProperty(propertyName))
			{
				num = a.GetFloat(propertyName);
			}
			if (b.HasProperty(propertyName))
			{
				num2 = b.GetFloat(propertyName);
			}
			if (num != num2)
			{
				return false;
			}
			return true;
		}
	}
	public class TextureBlenderLegacyBumpDiffuse : TextureBlender
	{
		private bool doColor;

		private Color m_tintColor;

		private Color m_defaultTintColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Bumped Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Bumped Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", Color.white);
		}

		public Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderLegacyDiffuse : TextureBlender
	{
		private bool doColor;

		private Color m_tintColor;

		private Color m_defaultTintColor = Color.white;

		public bool DoesShaderNameMatch(string shaderName)
		{
			if (shaderName.Equals("Legacy Shaders/Diffuse"))
			{
				return true;
			}
			if (shaderName.Equals("Diffuse"))
			{
				return true;
			}
			return false;
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.EndsWith("_MainTex"))
			{
				doColor = true;
				m_tintColor = sourceMat.GetColor("_Color");
			}
			else
			{
				doColor = false;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			return TextureBlenderFallback._compareColor(a, b, m_defaultTintColor, "_Color");
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			resultMaterial.SetColor("_Color", Color.white);
		}

		public Color GetColorIfNoTexture(Material m, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_MainTex") && m != null && m.HasProperty("_Color"))
			{
				try
				{
					return m.GetColor("_Color");
				}
				catch (Exception)
				{
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderMaterialPropertyCacheHelper
	{
		private struct MaterialPropertyPair
		{
			public Material material;

			public string property;

			public MaterialPropertyPair(Material m, string prop)
			{
				material = m;
				property = prop;
			}

			public override bool Equals(object obj)
			{
				if (!(obj is MaterialPropertyPair materialPropertyPair))
				{
					return false;
				}
				if (!material.Equals(materialPropertyPair.material))
				{
					return false;
				}
				if (property != materialPropertyPair.property)
				{
					return false;
				}
				return true;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}
		}

		private Dictionary<MaterialPropertyPair, object> nonTexturePropertyValuesForSourceMaterials = new Dictionary<MaterialPropertyPair, object>();

		private bool AllNonTexturePropertyValuesAreEqual(string prop)
		{
			bool flag = false;
			object obj = null;
			foreach (MaterialPropertyPair key in nonTexturePropertyValuesForSourceMaterials.Keys)
			{
				if (key.property.Equals(prop))
				{
					if (!flag)
					{
						obj = nonTexturePropertyValuesForSourceMaterials[key];
						flag = true;
					}
					else if (!obj.Equals(nonTexturePropertyValuesForSourceMaterials[key]))
					{
						return false;
					}
				}
			}
			return true;
		}

		public void CacheMaterialProperty(Material m, string property, object value)
		{
			nonTexturePropertyValuesForSourceMaterials[new MaterialPropertyPair(m, property)] = value;
		}

		public object GetValueIfAllSourceAreTheSameOrDefault(string property, object defaultValue)
		{
			if (AllNonTexturePropertyValuesAreEqual(property))
			{
				foreach (MaterialPropertyPair key in nonTexturePropertyValuesForSourceMaterials.Keys)
				{
					if (key.property.Equals(property))
					{
						return nonTexturePropertyValuesForSourceMaterials[key];
					}
				}
			}
			return defaultValue;
		}
	}
	public class TextureBlenderStandardMetallic : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doEmission,
			doBump,
			doNone
		}

		private static Color NeutralNormalMap = new Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private Color m_tintColor;

		private float m_glossiness;

		private float m_glossMapScale;

		private float m_metallic;

		private bool m_hasMetallicGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private Color m_generatingTintedAtlasColor = Color.white;

		private float m_generatingTintedAtlasMetallic;

		private float m_generatingTintedAtlasGlossiness = 1f;

		private float m_generatingTintedAtlasGlossMapScale = 1f;

		private float m_generatingTintedAtlasBumpScale = 1f;

		private Color m_generatingTintedAtlasEmission = Color.white;

		private Color m_notGeneratingAtlasDefaultColor = Color.white;

		private float m_notGeneratingAtlasDefaultMetallic;

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private Color m_notGeneratingAtlasDefaultEmisionColor = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlasColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
				m_metallic = m_generatingTintedAtlasMetallic;
				if (sourceMat.GetTexture("_MetallicGlossMap") != null)
				{
					m_hasMetallicGlossMap = true;
				}
				else
				{
					m_hasMetallicGlossMap = false;
				}
				if (sourceMat.HasProperty("_Metallic"))
				{
					m_metallic = sourceMat.GetFloat("_Metallic");
				}
				else
				{
					m_metallic = 0f;
				}
				if (sourceMat.HasProperty("_GlossMapScale"))
				{
					m_glossMapScale = sourceMat.GetFloat("_GlossMapScale");
				}
				else
				{
					m_glossMapScale = 1f;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_glossiness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_glossiness = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlasBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emissionColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				if (m_hasMetallicGlossMap)
				{
					pixelColor = new Color(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a * m_glossMapScale);
					return pixelColor;
				}
				return new Color(m_metallic, 0f, 0f, m_glossiness);
			}
			if (propertyToDo == Prop.doBump)
			{
				return Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultGlossiness, "_Glossiness"))
			{
				return false;
			}
			bool flag = a.HasProperty("_MetallicGlossMap") && a.GetTexture("_MetallicGlossMap") != null;
			bool flag2 = b.HasProperty("_MetallicGlossMap") && b.GetTexture("_MetallicGlossMap") != null;
			if (flag && flag2)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_GlossMapScale"))
				{
					return false;
				}
			}
			else
			{
				if (flag || flag2)
				{
					return false;
				}
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_Metallic"))
				{
					return false;
				}
			}
			if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultEmisionColor, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlasColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_MetallicGlossMap") != null)
			{
				resultMaterial.SetFloat("_Metallic", m_generatingTintedAtlasMetallic);
				resultMaterial.SetFloat("_GlossMapScale", m_generatingTintedAtlasGlossMapScale);
				resultMaterial.SetFloat("_Glossiness", m_generatingTintedAtlasGlossiness);
			}
			else
			{
				resultMaterial.SetFloat("_Metallic", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Metallic", m_notGeneratingAtlasDefaultMetallic));
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", m_generatingTintedAtlasEmission);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_MetallicGlossMap"))
				{
					if (mat != null && mat.HasProperty("_Metallic"))
					{
						try
						{
							float @float = mat.GetFloat("_Metallic");
							Color color2 = new Color(@float, @float, @float);
							if (mat.HasProperty("_Glossiness"))
							{
								try
								{
									color2.a = mat.GetFloat("_Glossiness");
								}
								catch (Exception)
								{
								}
							}
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Metallic", @float);
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						}
						catch (Exception)
						{
						}
						return new Color(0f, 0f, 0f, 0.5f);
					}
					return new Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.IsKeywordEnabled("_EMISSION"))
						{
							return Color.black;
						}
						if (!mat.HasProperty("_EmissionColor"))
						{
							return Color.black;
						}
						try
						{
							Color color3 = mat.GetColor("_EmissionColor");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardMetallicRoughness : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doMetallic,
			doRoughness,
			doEmission,
			doBump,
			doNone
		}

		private static Color NeutralNormalMap = new Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private Color m_tintColor;

		private float m_roughness;

		private float m_metallic;

		private bool m_hasMetallicGlossMap;

		private bool m_hasSpecGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private Color m_generatingTintedAtlasColor = Color.white;

		private float m_generatingTintedAtlasMetallic;

		private float m_generatingTintedAtlasRoughness = 0.5f;

		private float m_generatingTintedAtlasBumpScale = 1f;

		private Color m_generatingTintedAtlasEmission = Color.white;

		private Color m_notGeneratingAtlasDefaultColor = Color.white;

		private float m_notGeneratingAtlasDefaultMetallic;

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private Color m_notGeneratingAtlasDefaultEmisionColor = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Roughness setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlasColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_MetallicGlossMap"))
			{
				propertyToDo = Prop.doMetallic;
				m_metallic = m_generatingTintedAtlasMetallic;
				if (sourceMat.GetTexture("_MetallicGlossMap") != null)
				{
					m_hasMetallicGlossMap = true;
				}
				else
				{
					m_hasMetallicGlossMap = false;
				}
				if (sourceMat.HasProperty("_Metallic"))
				{
					m_metallic = sourceMat.GetFloat("_Metallic");
				}
				else
				{
					m_metallic = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_SpecGlossMap"))
			{
				propertyToDo = Prop.doRoughness;
				m_roughness = m_generatingTintedAtlasRoughness;
				if (sourceMat.GetTexture("_SpecGlossMap") != null)
				{
					m_hasSpecGlossMap = true;
				}
				else
				{
					m_hasSpecGlossMap = false;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_roughness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_roughness = 1f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlasBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_emissionColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doMetallic)
			{
				if (m_hasMetallicGlossMap)
				{
					return pixelColor;
				}
				return new Color(m_metallic, 0f, 0f, m_roughness);
			}
			if (propertyToDo == Prop.doRoughness)
			{
				if (m_hasSpecGlossMap)
				{
					return pixelColor;
				}
				return new Color(m_roughness, 0f, 0f, 0f);
			}
			if (propertyToDo == Prop.doBump)
			{
				return Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_notGeneratingAtlasDefaultColor, "_Color"))
			{
				return false;
			}
			bool num = a.HasProperty("_MetallicGlossMap") && a.GetTexture("_MetallicGlossMap") != null;
			bool flag = b.HasProperty("_MetallicGlossMap") && b.GetTexture("_MetallicGlossMap") != null;
			if (!num && !flag)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_notGeneratingAtlasDefaultMetallic, "_Metallic"))
				{
					return false;
				}
				bool num2 = a.HasProperty("_SpecGlossMap") && a.GetTexture("_SpecGlossMap") != null;
				bool flag2 = b.HasProperty("_SpecGlossMap") && b.GetTexture("_SpecGlossMap") != null;
				if (!num2 && !flag2)
				{
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasRoughness, "_Glossiness"))
					{
						return false;
					}
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasBumpScale, "_bumpScale"))
					{
						return false;
					}
					if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlasRoughness, "_Glossiness"))
					{
						return false;
					}
					if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
					{
						return false;
					}
					if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlasEmission, "_EmissionColor"))
					{
						return false;
					}
					return true;
				}
				return false;
			}
			return false;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlasColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_MetallicGlossMap") != null)
			{
				resultMaterial.SetFloat("_Metallic", m_generatingTintedAtlasMetallic);
			}
			else
			{
				resultMaterial.SetFloat("_Metallic", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Metallic", m_notGeneratingAtlasDefaultMetallic));
			}
			if (!(resultMaterial.GetTexture("_SpecGlossMap") != null))
			{
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			else
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlasBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", Color.white);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_MetallicGlossMap"))
				{
					if (mat != null && mat.HasProperty("_Metallic"))
					{
						try
						{
							float @float = mat.GetFloat("_Metallic");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Metallic", @float);
						}
						catch (Exception)
						{
						}
						return new Color(0f, 0f, 0f, 0.5f);
					}
					return new Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_SpecGlossMap"))
				{
					bool flag = false;
					try
					{
						Color color2 = new Color(0f, 0f, 0f, 0.5f);
						if (mat.HasProperty("_Glossiness"))
						{
							try
							{
								flag = true;
								color2.a = mat.GetFloat("_Glossiness");
							}
							catch (Exception)
							{
							}
						}
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						return new Color(0f, 0f, 0f, 0.5f);
					}
					catch (Exception)
					{
					}
					if (!flag)
					{
						return new Color(0f, 0f, 0f, 0.5f);
					}
				}
				else
				{
					if (texPropertyName.name.Equals("_ParallaxMap"))
					{
						return new Color(0f, 0f, 0f, 0f);
					}
					if (texPropertyName.name.Equals("_OcclusionMap"))
					{
						return new Color(1f, 1f, 1f, 1f);
					}
					if (texPropertyName.name.Equals("_EmissionMap"))
					{
						if (mat != null)
						{
							if (!mat.IsKeywordEnabled("_EMISSION"))
							{
								return Color.black;
							}
							if (!mat.HasProperty("_EmissionColor"))
							{
								return Color.black;
							}
							try
							{
								Color color3 = mat.GetColor("_EmissionColor");
								sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
							}
							catch (Exception)
							{
							}
						}
					}
					else if (texPropertyName.name.Equals("_DetailMask"))
					{
						return new Color(0f, 0f, 0f, 0f);
					}
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
	public class TextureBlenderStandardSpecular : TextureBlender
	{
		private enum Prop
		{
			doColor,
			doSpecular,
			doEmission,
			doBump,
			doNone
		}

		private static Color NeutralNormalMap = new Color(0.5f, 0.5f, 1f);

		private TextureBlenderMaterialPropertyCacheHelper sourceMaterialPropertyCache = new TextureBlenderMaterialPropertyCacheHelper();

		private Color m_tintColor;

		private float m_glossiness;

		private float m_SpecGlossMapScale;

		private Color m_specColor;

		private bool m_hasSpecGlossMap;

		private float m_bumpScale;

		private bool m_shaderDoesEmission;

		private Color m_emissionColor;

		private Prop propertyToDo = Prop.doNone;

		private Color m_generatingTintedAtlaColor = Color.white;

		private Color m_generatingTintedAtlaSpecular = Color.black;

		private float m_generatingTintedAtlaGlossiness = 1f;

		private float m_generatingTintedAtlaSpecGlossMapScale = 1f;

		private float m_generatingTintedAtlaBumpScale = 1f;

		private Color m_generatingTintedAtlaEmission = Color.white;

		private Color m_notGeneratingAtlasDefaultColor = Color.white;

		private Color m_notGeneratingAtlasDefaultSpecularColor = new Color(0f, 0f, 0f, 1f);

		private float m_notGeneratingAtlasDefaultGlossiness = 0.5f;

		private Color m_notGeneratingAtlasDefaultEmisionColor = Color.black;

		public bool DoesShaderNameMatch(string shaderName)
		{
			return shaderName.Equals("Standard (Specular setup)");
		}

		public void OnBeforeTintTexture(Material sourceMat, string shaderTexturePropertyName)
		{
			if (shaderTexturePropertyName.Equals("_MainTex"))
			{
				propertyToDo = Prop.doColor;
				if (sourceMat.HasProperty("_Color"))
				{
					m_tintColor = sourceMat.GetColor("_Color");
				}
				else
				{
					m_tintColor = m_generatingTintedAtlaColor;
				}
			}
			else if (shaderTexturePropertyName.Equals("_SpecGlossMap"))
			{
				propertyToDo = Prop.doSpecular;
				m_specColor = m_generatingTintedAtlaSpecular;
				if (sourceMat.GetTexture("_SpecGlossMap") != null)
				{
					m_hasSpecGlossMap = true;
				}
				else
				{
					m_hasSpecGlossMap = false;
				}
				if (sourceMat.HasProperty("_SpecColor"))
				{
					m_specColor = sourceMat.GetColor("_SpecColor");
				}
				else
				{
					m_specColor = new Color(0f, 0f, 0f, 1f);
				}
				if (sourceMat.HasProperty("_GlossMapScale"))
				{
					m_SpecGlossMapScale = sourceMat.GetFloat("_GlossMapScale");
				}
				else
				{
					m_SpecGlossMapScale = 1f;
				}
				if (sourceMat.HasProperty("_Glossiness"))
				{
					m_glossiness = sourceMat.GetFloat("_Glossiness");
				}
				else
				{
					m_glossiness = 0f;
				}
			}
			else if (shaderTexturePropertyName.Equals("_BumpMap"))
			{
				propertyToDo = Prop.doBump;
				if (sourceMat.HasProperty(shaderTexturePropertyName))
				{
					if (sourceMat.HasProperty("_BumpScale"))
					{
						m_bumpScale = sourceMat.GetFloat("_BumpScale");
					}
				}
				else
				{
					m_bumpScale = m_generatingTintedAtlaBumpScale;
				}
			}
			else if (shaderTexturePropertyName.Equals("_EmissionMap"))
			{
				propertyToDo = Prop.doEmission;
				m_shaderDoesEmission = sourceMat.IsKeywordEnabled("_EMISSION");
				if (sourceMat.HasProperty("_EmissionColor"))
				{
					m_emissionColor = sourceMat.GetColor("_EmissionColor");
				}
				else
				{
					m_generatingTintedAtlaColor = m_notGeneratingAtlasDefaultEmisionColor;
				}
			}
			else
			{
				propertyToDo = Prop.doNone;
			}
		}

		public Color OnBlendTexturePixel(string propertyToDoshaderPropertyName, Color pixelColor)
		{
			if (propertyToDo == Prop.doColor)
			{
				return new Color(pixelColor.r * m_tintColor.r, pixelColor.g * m_tintColor.g, pixelColor.b * m_tintColor.b, pixelColor.a * m_tintColor.a);
			}
			if (propertyToDo == Prop.doSpecular)
			{
				if (m_hasSpecGlossMap)
				{
					pixelColor = new Color(pixelColor.r, pixelColor.g, pixelColor.b, pixelColor.a * m_SpecGlossMapScale);
					return pixelColor;
				}
				Color specColor = m_specColor;
				specColor.a = m_glossiness;
				return specColor;
			}
			if (propertyToDo == Prop.doBump)
			{
				return Color.Lerp(NeutralNormalMap, pixelColor, m_bumpScale);
			}
			if (propertyToDo == Prop.doEmission)
			{
				if (m_shaderDoesEmission)
				{
					return new Color(pixelColor.r * m_emissionColor.r, pixelColor.g * m_emissionColor.g, pixelColor.b * m_emissionColor.b, pixelColor.a * m_emissionColor.a);
				}
				return Color.black;
			}
			return pixelColor;
		}

		public bool NonTexturePropertiesAreEqual(Material a, Material b)
		{
			if (!TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaColor, "_Color"))
			{
				return false;
			}
			if (!TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaSpecular, "_SpecColor"))
			{
				return false;
			}
			bool flag = a.HasProperty("_SpecGlossMap") && a.GetTexture("_SpecGlossMap") != null;
			bool flag2 = b.HasProperty("_SpecGlossMap") && b.GetTexture("_SpecGlossMap") != null;
			if (flag && flag2)
			{
				if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaSpecGlossMapScale, "_GlossMapScale"))
				{
					return false;
				}
			}
			else
			{
				if (flag || flag2)
				{
					return false;
				}
				if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaGlossiness, "_Glossiness"))
				{
					return false;
				}
			}
			if (!TextureBlenderFallback._compareFloat(a, b, m_generatingTintedAtlaBumpScale, "_BumpScale"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") != b.IsKeywordEnabled("_EMISSION"))
			{
				return false;
			}
			if (a.IsKeywordEnabled("_EMISSION") && !TextureBlenderFallback._compareColor(a, b, m_generatingTintedAtlaEmission, "_EmissionColor"))
			{
				return false;
			}
			return true;
		}

		public void SetNonTexturePropertyValuesOnResultMaterial(Material resultMaterial)
		{
			if (resultMaterial.GetTexture("_MainTex") != null)
			{
				resultMaterial.SetColor("_Color", m_generatingTintedAtlaColor);
			}
			else
			{
				resultMaterial.SetColor("_Color", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Color", m_notGeneratingAtlasDefaultColor));
			}
			if (resultMaterial.GetTexture("_SpecGlossMap") != null)
			{
				resultMaterial.SetColor("_SpecColor", m_generatingTintedAtlaSpecular);
				resultMaterial.SetFloat("_GlossMapScale", m_generatingTintedAtlaSpecGlossMapScale);
				resultMaterial.SetFloat("_Glossiness", m_generatingTintedAtlaGlossiness);
			}
			else
			{
				resultMaterial.SetColor("_SpecColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_SpecColor", m_notGeneratingAtlasDefaultSpecularColor));
				resultMaterial.SetFloat("_Glossiness", (float)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_Glossiness", m_notGeneratingAtlasDefaultGlossiness));
			}
			if (resultMaterial.GetTexture("_BumpMap") != null)
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlaBumpScale);
			}
			else
			{
				resultMaterial.SetFloat("_BumpScale", m_generatingTintedAtlaBumpScale);
			}
			if (resultMaterial.GetTexture("_EmissionMap") != null)
			{
				resultMaterial.EnableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", Color.white);
			}
			else
			{
				resultMaterial.DisableKeyword("_EMISSION");
				resultMaterial.SetColor("_EmissionColor", (Color)sourceMaterialPropertyCache.GetValueIfAllSourceAreTheSameOrDefault("_EmissionColor", m_notGeneratingAtlasDefaultEmisionColor));
			}
		}

		public Color GetColorIfNoTexture(Material mat, ShaderTextureProperty texPropertyName)
		{
			if (texPropertyName.name.Equals("_BumpMap"))
			{
				return new Color(0.5f, 0.5f, 1f);
			}
			if (texPropertyName.name.Equals("_MainTex"))
			{
				if (mat != null && mat.HasProperty("_Color"))
				{
					try
					{
						Color color = mat.GetColor("_Color");
						sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Color", color);
					}
					catch (Exception)
					{
					}
					return Color.white;
				}
			}
			else
			{
				if (texPropertyName.name.Equals("_SpecGlossMap"))
				{
					if (mat != null && mat.HasProperty("_SpecColor"))
					{
						try
						{
							Color color2 = mat.GetColor("_SpecColor");
							if (mat.HasProperty("_Glossiness"))
							{
								try
								{
									color2.a = mat.GetFloat("_Glossiness");
								}
								catch (Exception)
								{
								}
							}
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_SpecColor", color2);
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_Glossiness", color2.a);
						}
						catch (Exception)
						{
						}
					}
					return new Color(0f, 0f, 0f, 0.5f);
				}
				if (texPropertyName.name.Equals("_ParallaxMap"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
				if (texPropertyName.name.Equals("_OcclusionMap"))
				{
					return new Color(1f, 1f, 1f, 1f);
				}
				if (texPropertyName.name.Equals("_EmissionMap"))
				{
					if (mat != null)
					{
						if (!mat.IsKeywordEnabled("_EMISSION"))
						{
							return Color.black;
						}
						if (!mat.HasProperty("_EmissionColor"))
						{
							return Color.black;
						}
						try
						{
							Color color3 = mat.GetColor("_EmissionColor");
							sourceMaterialPropertyCache.CacheMaterialProperty(mat, "_EmissionColor", color3);
						}
						catch (Exception)
						{
						}
					}
				}
				else if (texPropertyName.name.Equals("_DetailMask"))
				{
					return new Color(0f, 0f, 0f, 0f);
				}
			}
			return new Color(1f, 1f, 1f, 0f);
		}
	}
}
namespace RSG
{
	public interface IPromise<PromisedT>
	{
		int Id { get; }

		IPromise<PromisedT> WithName(string name);

		void Done(Action<PromisedT> onResolved, Action<Exception> onRejected);

		void Done(Action<PromisedT> onResolved);

		void Done();

		IPromise Catch(Action<Exception> onRejected);

		IPromise<PromisedT> Catch(Func<Exception, PromisedT> onRejected);

		IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, IPromise<ConvertedT>> onResolved);

		IPromise Then(Func<PromisedT, IPromise> onResolved);

		IPromise Then(Action<PromisedT> onResolved);

		IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected);

		IPromise Then(Func<PromisedT, IPromise> onResolved, Action<Exception> onRejected);

		IPromise Then(Action<PromisedT> onResolved, Action<Exception> onRejected);

		IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected, Action<float> onProgress);

		IPromise Then(Func<PromisedT, IPromise> onResolved, Action<Exception> onRejected, Action<float> onProgress);

		IPromise Then(Action<PromisedT> onResolved, Action<Exception> onRejected, Action<float> onProgress);

		IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, ConvertedT> transform);

		IPromise<IEnumerable<ConvertedT>> ThenAll<ConvertedT>(Func<PromisedT, IEnumerable<IPromise<ConvertedT>>> chain);

		IPromise ThenAll(Func<PromisedT, IEnumerable<IPromise>> chain);

		IPromise<ConvertedT> ThenRace<ConvertedT>(Func<PromisedT, IEnumerable<IPromise<ConvertedT>>> chain);

		IPromise ThenRace(Func<PromisedT, IEnumerable<IPromise>> chain);

		IPromise<PromisedT> Finally(Action onComplete);

		IPromise ContinueWith(Func<IPromise> onResolved);

		IPromise<ConvertedT> ContinueWith<ConvertedT>(Func<IPromise<ConvertedT>> onComplete);

		IPromise<PromisedT> Progress(Action<float> onProgress);
	}
	public interface IRejectable
	{
		void Reject(Exception ex);
	}
	public interface IPendingPromise<PromisedT> : IRejectable
	{
		int Id { get; }

		void Resolve(PromisedT value);

		void ReportProgress(float progress);
	}
	public enum PromiseState
	{
		Pending,
		Rejected,
		Resolved
	}
	public class Promise<PromisedT> : IPromise<PromisedT>, IPendingPromise<PromisedT>, IRejectable, IPromiseInfo
	{
		private Exception rejectionException;

		private PromisedT resolveValue;

		private List<RejectHandler> rejectHandlers;

		private List<ProgressHandler> progressHandlers;

		private List<Action<PromisedT>> resolveCallbacks;

		private List<IRejectable> resolveRejectables;

		private readonly int id;

		public int Id => id;

		public string Name { get; private set; }

		public PromiseState CurState { get; private set; }

		public Promise()
		{
			CurState = PromiseState.Pending;
			id = Promise.NextId();
			if (Promise.EnablePromiseTracking)
			{
				Promise.PendingPromises.Add(this);
			}
		}

		public Promise(Action<Action<PromisedT>, Action<Exception>> resolver)
		{
			CurState = PromiseState.Pending;
			id = Promise.NextId();
			if (Promise.EnablePromiseTracking)
			{
				Promise.PendingPromises.Add(this);
			}
			try
			{
				resolver(Resolve, Reject);
			}
			catch (Exception ex)
			{
				Reject(ex);
			}
		}

		private void AddRejectHandler(Action<Exception> onRejected, IRejectable rejectable)
		{
			if (rejectHandlers == null)
			{
				rejectHandlers = new List<RejectHandler>();
			}
			rejectHandlers.Add(new RejectHandler
			{
				callback = onRejected,
				rejectable = rejectable
			});
		}

		private void AddResolveHandler(Action<PromisedT> onResolved, IRejectable rejectable)
		{
			if (resolveCallbacks == null)
			{
				resolveCallbacks = new List<Action<PromisedT>>();
			}
			if (resolveRejectables == null)
			{
				resolveRejectables = new List<IRejectable>();
			}
			resolveCallbacks.Add(onResolved);
			resolveRejectables.Add(rejectable);
		}

		private void AddProgressHandler(Action<float> onProgress, IRejectable rejectable)
		{
			if (progressHandlers == null)
			{
				progressHandlers = new List<ProgressHandler>();
			}
			progressHandlers.Add(new ProgressHandler
			{
				callback = onProgress,
				rejectable = rejectable
			});
		}

		private void InvokeHandler<T>(Action<T> callback, IRejectable rejectable, T value)
		{
			try
			{
				callback(value);
			}
			catch (Exception ex)
			{
				rejectable.Reject(ex);
			}
		}

		private void ClearHandlers()
		{
			rejectHandlers = null;
			resolveCallbacks = null;
			resolveRejectables = null;
			progressHandlers = null;
		}

		private void InvokeRejectHandlers(Exception ex)
		{
			if (rejectHandlers != null)
			{
				rejectHandlers.Each(delegate(RejectHandler handler)
				{
					InvokeHandler(handler.callback, handler.rejectable, ex);
				});
			}
			ClearHandlers();
		}

		private void InvokeResolveHandlers(PromisedT value)
		{
			if (resolveCallbacks != null)
			{
				int i = 0;
				for (int count = resolveCallbacks.Count; i < count; i++)
				{
					InvokeHandler(resolveCallbacks[i], resolveRejectables[i], value);
				}
			}
			ClearHandlers();
		}

		private void InvokeProgressHandlers(float progress)
		{
			if (progressHandlers != null)
			{
				progressHandlers.Each(delegate(ProgressHandler handler)
				{
					InvokeHandler(handler.callback, handler.rejectable, progress);
				});
			}
		}

		public void Reject(Exception ex)
		{
			if (CurState != 0)
			{
				throw new PromiseStateException(string.Concat("Attempt to reject a promise that is already in state: ", CurState, ", a promise can only be rejected when it is still in state: ", PromiseState.Pending));
			}
			rejectionException = ex;
			CurState = PromiseState.Rejected;
			if (Promise.EnablePromiseTracking)
			{
				Promise.PendingPromises.Remove(this);
			}
			InvokeRejectHandlers(ex);
		}

		public void Resolve(PromisedT value)
		{
			if (CurState != 0)
			{
				throw new PromiseStateException(string.Concat("Attempt to resolve a promise that is already in state: ", CurState, ", a promise can only be resolved when it is still in state: ", PromiseState.Pending));
			}
			resolveValue = value;
			CurState = PromiseState.Resolved;
			if (Promise.EnablePromiseTracking)
			{
				Promise.PendingPromises.Remove(this);
			}
			InvokeResolveHandlers(value);
		}

		public void ReportProgress(float progress)
		{
			if (CurState != 0)
			{
				throw new PromiseStateException(string.Concat("Attempt to report progress on a promise that is already in state: ", CurState, ", a promise can only report progress when it is still in state: ", PromiseState.Pending));
			}
			InvokeProgressHandlers(progress);
		}

		public void Done(Action<PromisedT> onResolved, Action<Exception> onRejected)
		{
			Then(onResolved, onRejected).Catch(delegate(Exception ex)
			{
				Promise.PropagateUnhandledException(this, ex);
			});
		}

		public void Done(Action<PromisedT> onResolved)
		{
			Then(onResolved).Catch(delegate(Exception ex)
			{
				Promise.PropagateUnhandledException(this, ex);
			});
		}

		public void Done()
		{
			Catch(delegate(Exception ex)
			{
				Promise.PropagateUnhandledException(this, ex);
			});
		}

		public IPromise<PromisedT> WithName(string name)
		{
			Name = name;
			return this;
		}

		public IPromise Catch(Action<Exception> onRejected)
		{
			Promise resultPromise = new Promise();
			resultPromise.WithName(Name);
			Action<PromisedT> resolveHandler = delegate
			{
				resultPromise.Resolve();
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				try
				{
					onRejected(ex);
					resultPromise.Resolve();
				}
				catch (Exception ex2)
				{
					resultPromise.Reject(ex2);
				}
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			ProgressHandlers(resultPromise, delegate(float v)
			{
				resultPromise.ReportProgress(v);
			});
			return resultPromise;
		}

		public IPromise<PromisedT> Catch(Func<Exception, PromisedT> onRejected)
		{
			Promise<PromisedT> resultPromise = new Promise<PromisedT>();
			resultPromise.WithName(Name);
			Action<PromisedT> resolveHandler = delegate(PromisedT v)
			{
				resultPromise.Resolve(v);
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				try
				{
					resultPromise.Resolve(onRejected(ex));
				}
				catch (Exception ex2)
				{
					resultPromise.Reject(ex2);
				}
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			ProgressHandlers(resultPromise, delegate(float v)
			{
				resultPromise.ReportProgress(v);
			});
			return resultPromise;
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, IPromise<ConvertedT>> onResolved)
		{
			return Then(onResolved, null, null);
		}

		public IPromise Then(Func<PromisedT, IPromise> onResolved)
		{
			return Then(onResolved, null, null);
		}

		public IPromise Then(Action<PromisedT> onResolved)
		{
			return Then(onResolved, null, null);
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected)
		{
			return Then(onResolved, onRejected, null);
		}

		public IPromise Then(Func<PromisedT, IPromise> onResolved, Action<Exception> onRejected)
		{
			return Then(onResolved, onRejected, null);
		}

		public IPromise Then(Action<PromisedT> onResolved, Action<Exception> onRejected)
		{
			return Then(onResolved, onRejected, null);
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected, Action<float> onProgress)
		{
			Promise<ConvertedT> resultPromise = new Promise<ConvertedT>();
			resultPromise.WithName(Name);
			Action<PromisedT> resolveHandler = delegate(PromisedT v)
			{
				onResolved(v).Progress(delegate(float progress)
				{
					resultPromise.ReportProgress(progress);
				}).Then(delegate(ConvertedT chainedValue)
				{
					resultPromise.Resolve(chainedValue);
				}, delegate(Exception ex)
				{
					resultPromise.Reject(ex);
				});
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				if (onRejected == null)
				{
					resultPromise.Reject(ex);
					return;
				}
				try
				{
					onRejected(ex).Then(delegate(ConvertedT chainedValue)
					{
						resultPromise.Resolve(chainedValue);
					}, delegate(Exception callbackEx)
					{
						resultPromise.Reject(callbackEx);
					});
				}
				catch (Exception ex2)
				{
					resultPromise.Reject(ex2);
				}
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return resultPromise;
		}

		public IPromise Then(Func<PromisedT, IPromise> onResolved, Action<Exception> onRejected, Action<float> onProgress)
		{
			Promise resultPromise = new Promise();
			resultPromise.WithName(Name);
			Action<PromisedT> resolveHandler = delegate(PromisedT v)
			{
				if (onResolved != null)
				{
					onResolved(v).Progress(delegate(float progress)
					{
						resultPromise.ReportProgress(progress);
					}).Then(delegate
					{
						resultPromise.Resolve();
					}, delegate(Exception ex)
					{
						resultPromise.Reject(ex);
					});
				}
				else
				{
					resultPromise.Resolve();
				}
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				if (onRejected != null)
				{
					onRejected(ex);
				}
				resultPromise.Reject(ex);
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return resultPromise;
		}

		public IPromise Then(Action<PromisedT> onResolved, Action<Exception> onRejected, Action<float> onProgress)
		{
			Promise resultPromise = new Promise();
			resultPromise.WithName(Name);
			Action<PromisedT> resolveHandler = delegate(PromisedT v)
			{
				if (onResolved != null)
				{
					onResolved(v);
				}
				resultPromise.Resolve();
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				if (onRejected != null)
				{
					onRejected(ex);
				}
				resultPromise.Reject(ex);
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return resultPromise;
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<PromisedT, ConvertedT> transform)
		{
			return Then((PromisedT value) => Promise<ConvertedT>.Resolved(transform(value)));
		}

		private void ActionHandlers(IRejectable resultPromise, Action<PromisedT> resolveHandler, Action<Exception> rejectHandler)
		{
			if (CurState == PromiseState.Resolved)
			{
				InvokeHandler(resolveHandler, resultPromise, resolveValue);
				return;
			}
			if (CurState == PromiseState.Rejected)
			{
				InvokeHandler(rejectHandler, resultPromise, rejectionException);
				return;
			}
			AddResolveHandler(resolveHandler, resultPromise);
			AddRejectHandler(rejectHandler, resultPromise);
		}

		private void ProgressHandlers(IRejectable resultPromise, Action<float> progressHandler)
		{
			if (CurState == PromiseState.Pending)
			{
				AddProgressHandler(progressHandler, resultPromise);
			}
		}

		public IPromise<IEnumerable<ConvertedT>> ThenAll<ConvertedT>(Func<PromisedT, IEnumerable<IPromise<ConvertedT>>> chain)
		{
			return Then((PromisedT value) => Promise<ConvertedT>.All(chain(value)));
		}

		public IPromise ThenAll(Func<PromisedT, IEnumerable<IPromise>> chain)
		{
			return Then((PromisedT value) => Promise.All(chain(value)));
		}

		public static IPromise<IEnumerable<PromisedT>> All(params IPromise<PromisedT>[] promises)
		{
			return All((IEnumerable<IPromise<PromisedT>>)promises);
		}

		public static IPromise<IEnumerable<PromisedT>> All(IEnumerable<IPromise<PromisedT>> promises)
		{
			IPromise<PromisedT>[] array = promises.ToArray();
			if (array.Length == 0)
			{
				return Promise<IEnumerable<PromisedT>>.Resolved(Enumerable.Empty<PromisedT>());
			}
			int remainingCount = array.Length;
			PromisedT[] results = new PromisedT[remainingCount];
			float[] progress = new float[remainingCount];
			Promise<IEnumerable<PromisedT>> resultPromise = new Promise<IEnumerable<PromisedT>>();
			resultPromise.WithName("All");
			array.Each(delegate(IPromise<PromisedT> promise, int index)
			{
				promise.Progress(delegate(float v)
				{
					progress[index] = v;
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.ReportProgress(progress.Average());
					}
				}).Then(delegate(PromisedT result)
				{
					progress[index] = 1f;
					results[index] = result;
					int num = remainingCount - 1;
					remainingCount = num;
					if (remainingCount <= 0 && resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Resolve(results);
					}
				}).Catch(delegate(Exception ex)
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Reject(ex);
					}
				})
					.Done();
			});
			return resultPromise;
		}

		public IPromise<ConvertedT> ThenRace<ConvertedT>(Func<PromisedT, IEnumerable<IPromise<ConvertedT>>> chain)
		{
			return Then((PromisedT value) => Promise<ConvertedT>.Race(chain(value)));
		}

		public IPromise ThenRace(Func<PromisedT, IEnumerable<IPromise>> chain)
		{
			return Then((PromisedT value) => Promise.Race(chain(value)));
		}

		public static IPromise<PromisedT> Race(params IPromise<PromisedT>[] promises)
		{
			return Race((IEnumerable<IPromise<PromisedT>>)promises);
		}

		public static IPromise<PromisedT> Race(IEnumerable<IPromise<PromisedT>> promises)
		{
			IPromise<PromisedT>[] array = promises.ToArray();
			if (array.Length == 0)
			{
				throw new InvalidOperationException("At least 1 input promise must be provided for Race");
			}
			Promise<PromisedT> resultPromise = new Promise<PromisedT>();
			resultPromise.WithName("Race");
			float[] progress = new float[array.Length];
			array.Each(delegate(IPromise<PromisedT> promise, int index)
			{
				promise.Progress(delegate(float v)
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						progress[index] = v;
						resultPromise.ReportProgress(progress.Max());
					}
				}).Then(delegate(PromisedT result)
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Resolve(result);
					}
				}).Catch(delegate(Exception ex)
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Reject(ex);
					}
				})
					.Done();
			});
			return resultPromise;
		}

		public static IPromise<PromisedT> Resolved(PromisedT promisedValue)
		{
			Promise<PromisedT> promise = new Promise<PromisedT>();
			promise.Resolve(promisedValue);
			return promise;
		}

		public static IPromise<PromisedT> Rejected(Exception ex)
		{
			Promise<PromisedT> promise = new Promise<PromisedT>();
			promise.Reject(ex);
			return promise;
		}

		public IPromise<PromisedT> Finally(Action onComplete)
		{
			Promise<PromisedT> promise = new Promise<PromisedT>();
			promise.WithName(Name);
			Then(delegate(PromisedT x)
			{
				promise.Resolve(x);
			});
			Catch(delegate(Exception e)
			{
				try
				{
					onComplete();
					promise.Reject(e);
				}
				catch (Exception ex)
				{
					promise.Reject(ex);
				}
			});
			return promise.Then(delegate(PromisedT v)
			{
				onComplete();
				return v;
			});
		}

		public IPromise ContinueWith(Func<IPromise> onComplete)
		{
			Promise promise = new Promise();
			promise.WithName(Name);
			Then(delegate
			{
				promise.Resolve();
			});
			Catch(delegate
			{
				promise.Resolve();
			});
			return promise.Then(onComplete);
		}

		public IPromise<ConvertedT> ContinueWith<ConvertedT>(Func<IPromise<ConvertedT>> onComplete)
		{
			Promise promise = new Promise();
			promise.WithName(Name);
			Then(delegate
			{
				promise.Resolve();
			});
			Catch(delegate
			{
				promise.Resolve();
			});
			return promise.Then(onComplete);
		}

		public IPromise<PromisedT> Progress(Action<float> onProgress)
		{
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return this;
		}
	}
	public interface IPromise
	{
		int Id { get; }

		IPromise WithName(string name);

		void Done(Action onResolved, Action<Exception> onRejected);

		void Done(Action onResolved);

		void Done();

		IPromise Catch(Action<Exception> onRejected);

		IPromise<ConvertedT> Then<ConvertedT>(Func<IPromise<ConvertedT>> onResolved);

		IPromise Then(Func<IPromise> onResolved);

		IPromise Then(Action onResolved);

		IPromise<ConvertedT> Then<ConvertedT>(Func<IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected);

		IPromise Then(Func<IPromise> onResolved, Action<Exception> onRejected);

		IPromise Then(Action onResolved, Action<Exception> onRejected);

		IPromise<ConvertedT> Then<ConvertedT>(Func<IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected, Action<float> onProgress);

		IPromise Then(Func<IPromise> onResolved, Action<Exception> onRejected, Action<float> onProgress);

		IPromise Then(Action onResolved, Action<Exception> onRejected, Action<float> onProgress);

		IPromise ThenAll(Func<IEnumerable<IPromise>> chain);

		IPromise<IEnumerable<ConvertedT>> ThenAll<ConvertedT>(Func<IEnumerable<IPromise<ConvertedT>>> chain);

		IPromise ThenSequence(Func<IEnumerable<Func<IPromise>>> chain);

		IPromise ThenRace(Func<IEnumerable<IPromise>> chain);

		IPromise<ConvertedT> ThenRace<ConvertedT>(Func<IEnumerable<IPromise<ConvertedT>>> chain);

		IPromise Finally(Action onComplete);

		IPromise ContinueWith(Func<IPromise> onResolved);

		IPromise<ConvertedT> ContinueWith<ConvertedT>(Func<IPromise<ConvertedT>> onComplete);

		IPromise Progress(Action<float> onProgress);
	}
	public interface IPendingPromise : IRejectable
	{
		int Id { get; }

		void Resolve();

		void ReportProgress(float progress);
	}
	public interface IPromiseInfo
	{
		int Id { get; }

		string Name { get; }
	}
	public class ExceptionEventArgs : EventArgs
	{
		public Exception Exception { get; private set; }

		internal ExceptionEventArgs(Exception exception)
		{
			Exception = exception;
		}
	}
	public struct RejectHandler
	{
		public Action<Exception> callback;

		public IRejectable rejectable;
	}
	public struct ProgressHandler
	{
		public Action<float> callback;

		public IRejectable rejectable;
	}
	public class Promise : IPromise, IPendingPromise, IRejectable, IPromiseInfo
	{
		public struct ResolveHandler
		{
			public Action callback;

			public IRejectable rejectable;
		}

		public static bool EnablePromiseTracking = false;

		private static EventHandler<ExceptionEventArgs> unhandlerException;

		private static int nextPromiseId;

		internal static readonly HashSet<IPromiseInfo> PendingPromises = new HashSet<IPromiseInfo>();

		private Exception rejectionException;

		private List<RejectHandler> rejectHandlers;

		private List<ResolveHandler> resolveHandlers;

		private List<ProgressHandler> progressHandlers;

		private readonly int id;

		public int Id => id;

		public string Name { get; private set; }

		public PromiseState CurState { get; private set; }

		public static event EventHandler<ExceptionEventArgs> UnhandledException
		{
			add
			{
				unhandlerException = (EventHandler<ExceptionEventArgs>)Delegate.Combine(unhandlerException, value);
			}
			remove
			{
				unhandlerException = (EventHandler<ExceptionEventArgs>)Delegate.Remove(unhandlerException, value);
			}
		}

		public static IEnumerable<IPromiseInfo> GetPendingPromises()
		{
			return PendingPromises;
		}

		public Promise()
		{
			CurState = PromiseState.Pending;
			id = NextId();
			if (EnablePromiseTracking)
			{
				PendingPromises.Add(this);
			}
		}

		public Promise(Action<Action, Action<Exception>> resolver)
		{
			CurState = PromiseState.Pending;
			id = NextId();
			if (EnablePromiseTracking)
			{
				PendingPromises.Add(this);
			}
			try
			{
				resolver(Resolve, Reject);
			}
			catch (Exception ex)
			{
				Reject(ex);
			}
		}

		internal static int NextId()
		{
			return ++nextPromiseId;
		}

		private void AddRejectHandler(Action<Exception> onRejected, IRejectable rejectable)
		{
			if (rejectHandlers == null)
			{
				rejectHandlers = new List<RejectHandler>();
			}
			rejectHandlers.Add(new RejectHandler
			{
				callback = onRejected,
				rejectable = rejectable
			});
		}

		private void AddResolveHandler(Action onResolved, IRejectable rejectable)
		{
			if (resolveHandlers == null)
			{
				resolveHandlers = new List<ResolveHandler>();
			}
			resolveHandlers.Add(new ResolveHandler
			{
				callback = onResolved,
				rejectable = rejectable
			});
		}

		private void AddProgressHandler(Action<float> onProgress, IRejectable rejectable)
		{
			if (progressHandlers == null)
			{
				progressHandlers = new List<ProgressHandler>();
			}
			progressHandlers.Add(new ProgressHandler
			{
				callback = onProgress,
				rejectable = rejectable
			});
		}

		private void InvokeRejectHandler(Action<Exception> callback, IRejectable rejectable, Exception value)
		{
			try
			{
				callback(value);
			}
			catch (Exception ex)
			{
				rejectable.Reject(ex);
			}
		}

		private void InvokeResolveHandler(Action callback, IRejectable rejectable)
		{
			try
			{
				callback();
			}
			catch (Exception ex)
			{
				rejectable.Reject(ex);
			}
		}

		private void InvokeProgressHandler(Action<float> callback, IRejectable rejectable, float progress)
		{
			try
			{
				callback(progress);
			}
			catch (Exception ex)
			{
				rejectable.Reject(ex);
			}
		}

		private void ClearHandlers()
		{
			rejectHandlers = null;
			resolveHandlers = null;
			progressHandlers = null;
		}

		private void InvokeRejectHandlers(Exception ex)
		{
			if (rejectHandlers != null)
			{
				rejectHandlers.Each(delegate(RejectHandler handler)
				{
					InvokeRejectHandler(handler.callback, handler.rejectable, ex);
				});
			}
			ClearHandlers();
		}

		private void InvokeResolveHandlers()
		{
			if (resolveHandlers != null)
			{
				resolveHandlers.Each(delegate(ResolveHandler handler)
				{
					InvokeResolveHandler(handler.callback, handler.rejectable);
				});
			}
			ClearHandlers();
		}

		private void InvokeProgressHandlers(float progress)
		{
			if (progressHandlers != null)
			{
				progressHandlers.Each(delegate(ProgressHandler handler)
				{
					InvokeProgressHandler(handler.callback, handler.rejectable, progress);
				});
			}
		}

		public void Reject(Exception ex)
		{
			if (CurState != 0)
			{
				throw new PromiseStateException(string.Concat("Attempt to reject a promise that is already in state: ", CurState, ", a promise can only be rejected when it is still in state: ", PromiseState.Pending));
			}
			rejectionException = ex;
			CurState = PromiseState.Rejected;
			if (EnablePromiseTracking)
			{
				PendingPromises.Remove(this);
			}
			InvokeRejectHandlers(ex);
		}

		public void Resolve()
		{
			if (CurState != 0)
			{
				throw new PromiseStateException(string.Concat("Attempt to resolve a promise that is already in state: ", CurState, ", a promise can only be resolved when it is still in state: ", PromiseState.Pending));
			}
			CurState = PromiseState.Resolved;
			if (EnablePromiseTracking)
			{
				PendingPromises.Remove(this);
			}
			InvokeResolveHandlers();
		}

		public void ReportProgress(float progress)
		{
			if (CurState != 0)
			{
				throw new PromiseStateException(string.Concat("Attempt to report progress on a promise that is already in state: ", CurState, ", a promise can only report progress when it is still in state: ", PromiseState.Pending));
			}
			InvokeProgressHandlers(progress);
		}

		public void Done(Action onResolved, Action<Exception> onRejected)
		{
			Then(onResolved, onRejected).Catch(delegate(Exception ex)
			{
				PropagateUnhandledException(this, ex);
			});
		}

		public void Done(Action onResolved)
		{
			Then(onResolved).Catch(delegate(Exception ex)
			{
				PropagateUnhandledException(this, ex);
			});
		}

		public void Done()
		{
			Catch(delegate(Exception ex)
			{
				PropagateUnhandledException(this, ex);
			});
		}

		public IPromise WithName(string name)
		{
			Name = name;
			return this;
		}

		public IPromise Catch(Action<Exception> onRejected)
		{
			Promise resultPromise = new Promise();
			resultPromise.WithName(Name);
			Action resolveHandler = delegate
			{
				resultPromise.Resolve();
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				try
				{
					onRejected(ex);
					resultPromise.Resolve();
				}
				catch (Exception ex2)
				{
					resultPromise.Reject(ex2);
				}
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			ProgressHandlers(resultPromise, delegate(float v)
			{
				resultPromise.ReportProgress(v);
			});
			return resultPromise;
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<IPromise<ConvertedT>> onResolved)
		{
			return Then(onResolved, null, null);
		}

		public IPromise Then(Func<IPromise> onResolved)
		{
			return Then(onResolved, null, null);
		}

		public IPromise Then(Action onResolved)
		{
			return Then(onResolved, null, null);
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected)
		{
			return Then(onResolved, onRejected, null);
		}

		public IPromise Then(Func<IPromise> onResolved, Action<Exception> onRejected)
		{
			return Then(onResolved, onRejected, null);
		}

		public IPromise Then(Action onResolved, Action<Exception> onRejected)
		{
			return Then(onResolved, onRejected, null);
		}

		public IPromise<ConvertedT> Then<ConvertedT>(Func<IPromise<ConvertedT>> onResolved, Func<Exception, IPromise<ConvertedT>> onRejected, Action<float> onProgress)
		{
			Promise<ConvertedT> resultPromise = new Promise<ConvertedT>();
			resultPromise.WithName(Name);
			Action resolveHandler = delegate
			{
				onResolved().Progress(delegate(float progress)
				{
					resultPromise.ReportProgress(progress);
				}).Then(delegate(ConvertedT chainedValue)
				{
					resultPromise.Resolve(chainedValue);
				}, delegate(Exception ex)
				{
					resultPromise.Reject(ex);
				});
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				if (onRejected == null)
				{
					resultPromise.Reject(ex);
					return;
				}
				try
				{
					onRejected(ex).Then(delegate(ConvertedT chainedValue)
					{
						resultPromise.Resolve(chainedValue);
					}, delegate(Exception callbackEx)
					{
						resultPromise.Reject(callbackEx);
					});
				}
				catch (Exception ex2)
				{
					resultPromise.Reject(ex2);
				}
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return resultPromise;
		}

		public IPromise Then(Func<IPromise> onResolved, Action<Exception> onRejected, Action<float> onProgress)
		{
			Promise resultPromise = new Promise();
			resultPromise.WithName(Name);
			Action resolveHandler = delegate
			{
				if (onResolved != null)
				{
					onResolved().Progress(delegate(float progress)
					{
						resultPromise.ReportProgress(progress);
					}).Then(delegate
					{
						resultPromise.Resolve();
					}, delegate(Exception ex)
					{
						resultPromise.Reject(ex);
					});
				}
				else
				{
					resultPromise.Resolve();
				}
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				if (onRejected != null)
				{
					onRejected(ex);
				}
				resultPromise.Reject(ex);
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return resultPromise;
		}

		public IPromise Then(Action onResolved, Action<Exception> onRejected, Action<float> onProgress)
		{
			Promise resultPromise = new Promise();
			resultPromise.WithName(Name);
			Action resolveHandler = delegate
			{
				if (onResolved != null)
				{
					onResolved();
				}
				resultPromise.Resolve();
			};
			Action<Exception> rejectHandler = delegate(Exception ex)
			{
				if (onRejected != null)
				{
					onRejected(ex);
					resultPromise.Resolve();
				}
				else
				{
					resultPromise.Reject(ex);
				}
			};
			ActionHandlers(resultPromise, resolveHandler, rejectHandler);
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return resultPromise;
		}

		private void ActionHandlers(IRejectable resultPromise, Action resolveHandler, Action<Exception> rejectHandler)
		{
			if (CurState == PromiseState.Resolved)
			{
				InvokeResolveHandler(resolveHandler, resultPromise);
				return;
			}
			if (CurState == PromiseState.Rejected)
			{
				InvokeRejectHandler(rejectHandler, resultPromise, rejectionException);
				return;
			}
			AddResolveHandler(resolveHandler, resultPromise);
			AddRejectHandler(rejectHandler, resultPromise);
		}

		private void ProgressHandlers(IRejectable resultPromise, Action<float> progressHandler)
		{
			if (CurState == PromiseState.Pending)
			{
				AddProgressHandler(progressHandler, resultPromise);
			}
		}

		public IPromise ThenAll(Func<IEnumerable<IPromise>> chain)
		{
			return Then(() => All(chain()));
		}

		public IPromise<IEnumerable<ConvertedT>> ThenAll<ConvertedT>(Func<IEnumerable<IPromise<ConvertedT>>> chain)
		{
			return Then(() => Promise<ConvertedT>.All(chain()));
		}

		public static IPromise All(params IPromise[] promises)
		{
			return All((IEnumerable<IPromise>)promises);
		}

		public static IPromise All(IEnumerable<IPromise> promises)
		{
			IPromise[] array = promises.ToArray();
			if (array.Length == 0)
			{
				return Resolved();
			}
			int remainingCount = array.Length;
			Promise resultPromise = new Promise();
			resultPromise.WithName("All");
			float[] progress = new float[remainingCount];
			array.Each(delegate(IPromise promise, int index)
			{
				promise.Progress(delegate(float v)
				{
					progress[index] = v;
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.ReportProgress(progress.Average());
					}
				}).Then(delegate
				{
					progress[index] = 1f;
					int num = remainingCount - 1;
					remainingCount = num;
					if (remainingCount <= 0 && resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Resolve();
					}
				}).Catch(delegate(Exception ex)
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Reject(ex);
					}
				})
					.Done();
			});
			return resultPromise;
		}

		public IPromise ThenSequence(Func<IEnumerable<Func<IPromise>>> chain)
		{
			return Then(() => Sequence(chain()));
		}

		public static IPromise Sequence(params Func<IPromise>[] fns)
		{
			return Sequence((IEnumerable<Func<IPromise>>)fns);
		}

		public static IPromise Sequence(IEnumerable<Func<IPromise>> fns)
		{
			Promise promise = new Promise();
			int count = 0;
			fns.Aggregate(Resolved(), delegate(IPromise prevPromise, Func<IPromise> fn)
			{
				int itemSequence = count;
				int num = count + 1;
				count = num;
				return prevPromise.Then(delegate
				{
					float num3 = 1f / (float)count;
					promise.ReportProgress(num3 * (float)itemSequence);
					return fn();
				}).Progress(delegate(float v)
				{
					float num2 = 1f / (float)count;
					promise.ReportProgress(num2 * (v + (float)itemSequence));
				});
			}).Then(delegate
			{
				promise.Resolve();
			}).Catch(promise.Reject);
			return promise;
		}

		public IPromise ThenRace(Func<IEnumerable<IPromise>> chain)
		{
			return Then(() => Race(chain()));
		}

		public IPromise<ConvertedT> ThenRace<ConvertedT>(Func<IEnumerable<IPromise<ConvertedT>>> chain)
		{
			return Then(() => Promise<ConvertedT>.Race(chain()));
		}

		public static IPromise Race(params IPromise[] promises)
		{
			return Race((IEnumerable<IPromise>)promises);
		}

		public static IPromise Race(IEnumerable<IPromise> promises)
		{
			IPromise[] array = promises.ToArray();
			if (array.Length == 0)
			{
				throw new InvalidOperationException("At least 1 input promise must be provided for Race");
			}
			Promise resultPromise = new Promise();
			resultPromise.WithName("Race");
			float[] progress = new float[array.Length];
			array.Each(delegate(IPromise promise, int index)
			{
				promise.Progress(delegate(float v)
				{
					progress[index] = v;
					resultPromise.ReportProgress(progress.Max());
				}).Catch(delegate(Exception ex)
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Reject(ex);
					}
				}).Then(delegate
				{
					if (resultPromise.CurState == PromiseState.Pending)
					{
						resultPromise.Resolve();
					}
				})
					.Done();
			});
			return resultPromise;
		}

		public static IPromise Resolved()
		{
			Promise promise = new Promise();
			promise.Resolve();
			return promise;
		}

		public static IPromise Rejected(Exception ex)
		{
			Promise promise = new Promise();
			promise.Reject(ex);
			return promise;
		}

		public IPromise Finally(Action onComplete)
		{
			Promise promise = new Promise();
			promise.WithName(Name);
			Then(delegate
			{
				promise.Resolve();
			});
			Catch(delegate(Exception e)
			{
				try
				{
					onComplete();
					promise.Reject(e);
				}
				catch (Exception ex)
				{
					promise.Reject(ex);
				}
			});
			return promise.Then(onComplete);
		}

		public IPromise ContinueWith(Func<IPromise> onComplete)
		{
			Promise promise = new Promise();
			promise.WithName(Name);
			Then(delegate
			{
				promise.Resolve();
			});
			Catch(delegate
			{
				promise.Resolve();
			});
			return promise.Then(onComplete);
		}

		public IPromise<ConvertedT> ContinueWith<ConvertedT>(Func<IPromise<ConvertedT>> onComplete)
		{
			Promise promise = new Promise();
			promise.WithName(Name);
			Then(delegate
			{
				promise.Resolve();
			});
			Catch(delegate
			{
				promise.Resolve();
			});
			return promise.Then(onComplete);
		}

		public IPromise Progress(Action<float> onProgress)
		{
			if (onProgress != null)
			{
				ProgressHandlers(this, onProgress);
			}
			return this;
		}

		internal static void PropagateUnhandledException(object sender, Exception ex)
		{
			if (unhandlerException != null)
			{
				unhandlerException(sender, new ExceptionEventArgs(ex));
			}
		}
	}
	public static class PromiseHelpers
	{
		public static IPromise<Tuple<T1, T2>> All<T1, T2>(IPromise<T1> p1, IPromise<T2> p2)
		{
			T1 val2 = default(T1);
			T2 val3 = default(T2);
			int numUnresolved = 2;
			bool alreadyRejected = false;
			Promise<Tuple<T1, T2>> promise = new Promise<Tuple<T1, T2>>();
			p1.Then(delegate(T1 val)
			{
				val2 = val;
				numUnresolved--;
				if (numUnresolved <= 0)
				{
					promise.Resolve(Tuple.Create(val2, val3));
				}
			}).Catch(delegate(Exception e)
			{
				if (!alreadyRejected)
				{
					promise.Reject(e);
				}
				alreadyRejected = true;
			}).Done();
			p2.Then(delegate(T2 val)
			{
				val3 = val;
				numUnresolved--;
				if (numUnresolved <= 0)
				{
					promise.Resolve(Tuple.Create(val2, val3));
				}
			}).Catch(delegate(Exception e)
			{
				if (!alreadyRejected)
				{
					promise.Reject(e);
				}
				alreadyRejected = true;
			}).Done();
			return promise;
		}

		public static IPromise<Tuple<T1, T2, T3>> All<T1, T2, T3>(IPromise<T1> p1, IPromise<T2> p2, IPromise<T3> p3)
		{
			return All(All(p1, p2), p3).Then((Tuple<Tuple<T1, T2>, T3> vals) => Tuple.Create(vals.Item1.Item1, vals.Item1.Item2, vals.Item2));
		}

		public static IPromise<Tuple<T1, T2, T3, T4>> All<T1, T2, T3, T4>(IPromise<T1> p1, IPromise<T2> p2, IPromise<T3> p3, IPromise<T4> p4)
		{
			return All(All(p1, p2), All(p3, p4)).Then((Tuple<Tuple<T1, T2>, Tuple<T3, T4>> vals) => Tuple.Create(vals.Item1.Item1, vals.Item1.Item2, vals.Item2.Item1, vals.Item2.Item2));
		}
	}
	public class PromiseCancelledException : Exception
	{
		public PromiseCancelledException()
		{
		}

		public PromiseCancelledException(string message)
			: base(message)
		{
		}
	}
	internal class PredicateWait
	{
		public Func<TimeData, bool> predicate;

		public float timeStarted;

		public IPendingPromise pendingPromise;

		public TimeData timeData;

		public int frameStarted;
	}
	public struct TimeData
	{
		public float elapsedTime;

		public float deltaTime;

		public int elapsedUpdates;
	}
	public interface IPromiseTimer
	{
		IPromise WaitFor(float seconds);

		IPromise WaitUntil(Func<TimeData, bool> predicate);

		IPromise WaitWhile(Func<TimeData, bool> predicate);

		void Update(float deltaTime);

		bool Cancel(IPromise promise);
	}
	public class PromiseTimer : IPromiseTimer
	{
		private float curTime;

		private int curFrame;

		private readonly LinkedList<PredicateWait> waiting = new LinkedList<PredicateWait>();

		public IPromise WaitFor(float seconds)
		{
			return WaitUntil((TimeData t) => t.elapsedTime >= seconds);
		}

		public IPromise WaitWhile(Func<TimeData, bool> predicate)
		{
			return WaitUntil((TimeData t) => !predicate(t));
		}

		public IPromise WaitUntil(Func<TimeData, bool> predicate)
		{
			Promise promise = new Promise();
			PredicateWait value = new PredicateWait
			{
				timeStarted = curTime,
				pendingPromise = promise,
				timeData = default(TimeData),
				predicate = predicate,
				frameStarted = curFrame
			};
			waiting.AddLast(value);
			return promise;
		}

		public bool Cancel(IPromise promise)
		{
			LinkedListNode<PredicateWait> linkedListNode = FindInWaiting(promise);
			if (linkedListNode == null)
			{
				return false;
			}
			linkedListNode.Value.pendingPromise.Reject(new PromiseCancelledException("Promise was cancelled by user."));
			waiting.Remove(linkedListNode);
			return true;
		}

		private LinkedListNode<PredicateWait> FindInWaiting(IPromise promise)
		{
			for (LinkedListNode<PredicateWait> linkedListNode = waiting.First; linkedListNode != null; linkedListNode = linkedListNode.Next)
			{
				if (linkedListNode.Value.pendingPromise.Id.Equals(promise.Id))
				{
					return linkedListNode;
				}
			}
			return null;
		}

		public void Update(float deltaTime)
		{
			curTime += deltaTime;
			curFrame++;
			LinkedListNode<PredicateWait> linkedListNode = waiting.First;
			while (linkedListNode != null)
			{
				PredicateWait value = linkedListNode.Value;
				float num = curTime - value.timeStarted;
				value.timeData.deltaTime = num - value.timeData.elapsedTime;
				value.timeData.elapsedTime = num;
				int elapsedUpdates = curFrame - value.frameStarted;
				value.timeData.elapsedUpdates = elapsedUpdates;
				bool flag;
				try
				{
					flag = value.predicate(value.timeData);
				}
				catch (Exception ex)
				{
					value.pendingPromise.Reject(ex);
					linkedListNode = RemoveNode(linkedListNode);
					continue;
				}
				if (flag)
				{
					value.pendingPromise.Resolve();
					linkedListNode = RemoveNode(linkedListNode);
				}
				else
				{
					linkedListNode = linkedListNode.Next;
				}
			}
		}

		private LinkedListNode<PredicateWait> RemoveNode(LinkedListNode<PredicateWait> node)
		{
			LinkedListNode<PredicateWait> node2 = node;
			node = node.Next;
			waiting.Remove(node2);
			return node;
		}
	}
	public class Tuple
	{
		public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2)
		{
			return new Tuple<T1, T2>(item1, item2);
		}

		public static Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3)
		{
			return new Tuple<T1, T2, T3>(item1, item2, item3);
		}

		public static Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4)
		{
			return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);
		}
	}
	public class Tuple<T1, T2>
	{
		public T1 Item1 { get; private set; }

		public T2 Item2 { get; private set; }

		internal Tuple(T1 item1, T2 item2)
		{
			Item1 = item1;
			Item2 = item2;
		}
	}
	public class Tuple<T1, T2, T3>
	{
		public T1 Item1 { get; private set; }

		public T2 Item2 { get; private set; }

		public T3 Item3 { get; private set; }

		internal Tuple(T1 item1, T2 item2, T3 item3)
		{
			Item1 = item1;
			Item2 = item2;
			Item3 = item3;
		}
	}
	public class Tuple<T1, T2, T3, T4>
	{
		public T1 Item1 { get; private set; }

		public T2 Item2 { get; private set; }

		public T3 Item3 { get; private set; }

		public T4 Item4 { get; private set; }

		internal Tuple(T1 item1, T2 item2, T3 item3, T4 item4)
		{
			Item1 = item1;
			Item2 = item2;
			Item3 = item3;
			Item4 = item4;
		}
	}
}
namespace RSG.Exceptions
{
	public class PromiseException : Exception
	{
		public PromiseException()
		{
		}

		public PromiseException(string message)
			: base(message)
		{
		}

		public PromiseException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
	public class PromiseStateException : PromiseException
	{
		public PromiseStateException()
		{
		}

		public PromiseStateException(string message)
			: base(message)
		{
		}

		public PromiseStateException(string message, Exception inner)
			: base(message, inner)
		{
		}
	}
}
namespace RSG.Promises
{
	public static class EnumerableExt
	{
		public static void Each<T>(this IEnumerable<T> source, Action<T> fn)
		{
			foreach (T item in source)
			{
				fn(item);
			}
		}

		public static void Each<T>(this IEnumerable<T> source, Action<T, int> fn)
		{
			int num = 0;
			foreach (T item in source)
			{
				fn(item, num);
				num++;
			}
		}

		public static IEnumerable<T> FromItems<T>(params T[] items)
		{
			for (int i = 0; i < items.Length; i++)
			{
				yield return items[i];
			}
		}
	}
}
namespace Proyecto26
{
	public static class HttpBase
	{
		public static IEnumerator CreateRequestAndRetry(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			int retries = 0;
			do
			{
				using UnityWebRequest request = CreateRequest(options);
				yield return request.SendWebRequestWithOptions(options);
				ResponseHelper responseHelper = request.CreateWebResponse();
				if (request.IsValidRequest(options))
				{
					DebugLog(options.EnableDebug, $"Url: {options.Uri}\nMethod: {options.Method}\nStatus: {request.responseCode}\nResponse: {responseHelper.Text}", isError: false);
					callback(null, responseHelper);
					break;
				}
				if (!options.IsAborted && retries < options.Retries)
				{
					yield return new WaitForSeconds(options.RetrySecondsDelay);
					retries++;
					if (options.RetryCallback != null)
					{
						options.RetryCallback(CreateException(request), retries);
					}
					DebugLog(options.EnableDebug, $"Retry Request\nUrl: {options.Uri}\nMethod: {options.Method}", isError: false);
					continue;
				}
				RequestException ex = CreateException(request);
				DebugLog(options.EnableDebug, ex, isError: true);
				callback(ex, responseHelper);
				break;
			}
			while (retries <= options.Retries);
		}

		private static UnityWebRequest CreateRequest(RequestHelper options)
		{
			if (options.FormData != null && options.Method == "POST")
			{
				return UnityWebRequest.Post(options.Uri, options.FormData);
			}
			return new UnityWebRequest(options.Uri, options.Method);
		}

		private static RequestException CreateException(UnityWebRequest request)
		{
			return new RequestException(request.error, request.isHttpError, request.isNetworkError, request.responseCode, request.downloadHandler.text);
		}

		private static void DebugLog(bool debugEnabled, object message, bool isError)
		{
			if (debugEnabled)
			{
				if (isError)
				{
					UnityEngine.Debug.LogError(message);
				}
				else
				{
					UnityEngine.Debug.Log(message);
				}
			}
		}

		public static IEnumerator DefaultUnityWebRequest(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			return CreateRequestAndRetry(options, callback);
		}

		public static IEnumerator DefaultUnityWebRequest<TResponse>(RequestHelper options, Action<RequestException, ResponseHelper, TResponse> callback)
		{
			return CreateRequestAndRetry(options, delegate(RequestException err, ResponseHelper res)
			{
				TResponse arg = default(TResponse);
				if (err == null && !string.IsNullOrEmpty(res.Text))
				{
					try
					{
						arg = JsonUtility.FromJson<TResponse>(res.Text);
					}
					catch (Exception ex)
					{
						DebugLog(options.EnableDebug, $"Invalid JSON format\nError: {ex.Message}", isError: true);
					}
				}
				callback(err, res, arg);
			});
		}

		public static IEnumerator DefaultUnityWebRequest<TResponse>(RequestHelper options, Action<RequestException, ResponseHelper, TResponse[]> callback)
		{
			return CreateRequestAndRetry(options, delegate(RequestException err, ResponseHelper res)
			{
				TResponse[] arg = null;
				if (err == null && !string.IsNullOrEmpty(res.Text))
				{
					try
					{
						arg = JsonHelper.ArrayFromJson<TResponse>(res.Text);
					}
					catch (Exception ex)
					{
						DebugLog(options.EnableDebug, $"Invalid JSON format\nError: {ex.Message}", isError: true);
					}
				}
				callback(err, res, arg);
			});
		}
	}
	public static class JsonHelper
	{
		[Serializable]
		private class Wrapper<T>
		{
			public T[] Items;
		}

		public static T[] ArrayFromJson<T>(string json)
		{
			return JsonUtility.FromJson<Wrapper<T>>("{ \"Items\": " + json + "}").Items;
		}

		public static T[] FromJsonString<T>(string json)
		{
			return JsonUtility.FromJson<Wrapper<T>>(json).Items;
		}

		public static string ArrayToJsonString<T>(T[] array)
		{
			return JsonUtility.ToJson(new Wrapper<T>
			{
				Items = array
			});
		}

		public static string ArrayToJsonString<T>(T[] array, bool prettyPrint)
		{
			return JsonUtility.ToJson(new Wrapper<T>
			{
				Items = array
			}, prettyPrint);
		}
	}
	public class RequestException : Exception
	{
		private bool _isHttpError;

		private bool _isNetworkError;

		private long _statusCode;

		private string _serverMessage;

		private string _response;

		public bool IsHttpError
		{
			get
			{
				return _isHttpError;
			}
			private set
			{
				_isHttpError = value;
			}
		}

		public bool IsNetworkError
		{
			get
			{
				return _isNetworkError;
			}
			private set
			{
				_isNetworkError = value;
			}
		}

		public long StatusCode
		{
			get
			{
				return _statusCode;
			}
			private set
			{
				_statusCode = value;
			}
		}

		public string ServerMessage
		{
			get
			{
				return _serverMessage;
			}
			set
			{
				_serverMessage = value;
			}
		}

		public string Response
		{
			get
			{
				return _response;
			}
			set
			{
				_response = value;
			}
		}

		public RequestException()
		{
		}

		public RequestException(string message)
			: base(message)
		{
		}

		public RequestException(string format, params object[] args)
			: base(string.Format(format, args))
		{
		}

		public RequestException(string message, bool isHttpError, bool isNetworkError, long statusCode, string response)
			: base(message)
		{
			_isHttpError = isHttpError;
			_isNetworkError = isNetworkError;
			_statusCode = statusCode;
			_response = response;
		}
	}
	public class RequestHelper
	{
		private string _uri;

		private string _method;

		private object _body;

		private string _bodyString;

		private byte[] _bodyRaw;

		private int? _timeout;

		private string _contentType;

		private int _retries;

		private float _retrySecondsDelay;

		private Action<RequestException, int> _retryCallback;

		private bool _enableDebug;

		private bool? _chunkedTransfer;

		private bool? _useHttpContinue = true;

		private int? _redirectLimit;

		private bool _ignoreHttpException;

		private WWWForm _formData;

		private Dictionary<string, string> _simpleForm;

		private List<IMultipartFormSection> _formSections;

		private CertificateHandler _certificateHandler;

		private UploadHandler _uploadHandler;

		private DownloadHandler _downloadHandler;

		private Dictionary<string, string> _headers;

		private bool _isAborted;

		private bool _defaultContentType = true;

		public string Uri
		{
			get
			{
				return _uri;
			}
			set
			{
				_uri = value;
			}
		}

		public string Method
		{
			get
			{
				return _method;
			}
			set
			{
				_method = value;
			}
		}

		public object Body
		{
			get
			{
				return _body;
			}
			set
			{
				_body = value;
			}
		}

		public string BodyString
		{
			get
			{
				return _bodyString;
			}
			set
			{
				_bodyString = value;
			}
		}

		public byte[] BodyRaw
		{
			get
			{
				return _bodyRaw;
			}
			set
			{
				_bodyRaw = value;
			}
		}

		public int? Timeout
		{
			get
			{
				return _timeout;
			}
			set
			{
				_timeout = value;
			}
		}

		public string ContentType
		{
			get
			{
				return _contentType;
			}
			set
			{
				_contentType = value;
			}
		}

		public int Retries
		{
			get
			{
				return _retries;
			}
			set
			{
				_retries = value;
			}
		}

		public float RetrySecondsDelay
		{
			get
			{
				return _retrySecondsDelay;
			}
			set
			{
				_retrySecondsDelay = value;
			}
		}

		public Action<RequestException, int> RetryCallback
		{
			get
			{
				return _retryCallback;
			}
			set
			{
				_retryCallback = value;
			}
		}

		public bool EnableDebug
		{
			get
			{
				return _enableDebug;
			}
			set
			{
				_enableDebug = value;
			}
		}

		public bool? ChunkedTransfer
		{
			get
			{
				return _chunkedTransfer;
			}
			set
			{
				_chunkedTransfer = value;
			}
		}

		public bool? UseHttpContinue
		{
			get
			{
				return _useHttpContinue;
			}
			set
			{
				_useHttpContinue = value;
			}
		}

		public int? RedirectLimit
		{
			get
			{
				return _redirectLimit;
			}
			set
			{
				_redirectLimit = value;
			}
		}

		public bool IgnoreHttpException
		{
			get
			{
				return _ignoreHttpException;
			}
			set
			{
				_ignoreHttpException = value;
			}
		}

		public WWWForm FormData
		{
			get
			{
				return _formData;
			}
			set
			{
				_formData = value;
			}
		}

		public Dictionary<string, string> SimpleForm
		{
			get
			{
				return _simpleForm;
			}
			set
			{
				_simpleForm = value;
			}
		}

		public List<IMultipartFormSection> FormSections
		{
			get
			{
				return _formSections;
			}
			set
			{
				_formSections = value;
			}
		}

		public CertificateHandler CertificateHandler
		{
			get
			{
				return _certificateHandler;
			}
			set
			{
				_certificateHandler = value;
			}
		}

		public UploadHandler UploadHandler
		{
			get
			{
				return _uploadHandler;
			}
			set
			{
				_uploadHandler = value;
			}
		}

		public DownloadHandler DownloadHandler
		{
			get
			{
				return _downloadHandler;
			}
			set
			{
				_downloadHandler = value;
			}
		}

		public Dictionary<string, string> Headers
		{
			get
			{
				if (_headers == null)
				{
					_headers = new Dictionary<string, string>();
				}
				return _headers;
			}
			set
			{
				_headers = value;
			}
		}

		public UnityWebRequest Request { private get; set; }

		public float UploadProgress
		{
			get
			{
				float result = 0f;
				if (Request != null)
				{
					result = Request.uploadProgress;
				}
				return result;
			}
		}

		public ulong UploadedBytes
		{
			get
			{
				ulong result = 0uL;
				if (Request != null)
				{
					result = Request.uploadedBytes;
				}
				return result;
			}
		}

		public float DownloadProgress
		{
			get
			{
				float result = 0f;
				if (Request != null)
				{
					result = Request.downloadProgress;
				}
				return result;
			}
		}

		public ulong DownloadedBytes
		{
			get
			{
				ulong result = 0uL;
				if (Request != null)
				{
					result = Request.downloadedBytes;
				}
				return result;
			}
		}

		public bool IsAborted
		{
			get
			{
				return _isAborted;
			}
			set
			{
				_isAborted = value;
			}
		}

		public bool DefaultContentType
		{
			get
			{
				return _defaultContentType;
			}
			set
			{
				_defaultContentType = value;
			}
		}

		public string GetHeader(string name)
		{
			if (Request != null)
			{
				return Request.GetRequestHeader(name);
			}
			Headers.TryGetValue(name, out var value);
			return value;
		}

		public void Abort()
		{
			if (Request != null && !IsAborted)
			{
				try
				{
					IsAborted = true;
					Request.Abort();
				}
				finally
				{
					Request = null;
				}
			}
		}
	}
	[Serializable]
	public class ResponseHelper
	{
		public UnityWebRequest Request { get; private set; }

		public long StatusCode => Request.responseCode;

		public byte[] Data
		{
			get
			{
				try
				{
					return Request.downloadHandler.data;
				}
				catch (Exception)
				{
					return null;
				}
			}
		}

		public string Text
		{
			get
			{
				try
				{
					return Request.downloadHandler.text;
				}
				catch (Exception)
				{
					return string.Empty;
				}
			}
		}

		public string Error => Request.error;

		public Dictionary<string, string> Headers => Request.GetResponseHeaders();

		public ResponseHelper(UnityWebRequest request)
		{
			Request = request;
		}

		public override string ToString()
		{
			return JsonUtility.ToJson(this, prettyPrint: true);
		}
	}
	public static class StaticCoroutine
	{
		private class CoroutineHolder : MonoBehaviour
		{
		}

		private static CoroutineHolder _runner;

		private static CoroutineHolder runner
		{
			get
			{
				if (_runner == null)
				{
					_runner = new GameObject("Static Coroutine RestClient").AddComponent<CoroutineHolder>();
					UnityEngine.Object.DontDestroyOnLoad(_runner);
				}
				return _runner;
			}
		}

		public static Coroutine StartCoroutine(IEnumerator coroutine)
		{
			return runner.StartCoroutine(coroutine);
		}
	}
	public static class RestClient
	{
		private static Dictionary<string, string> _defaultRequestHeaders;

		public static Dictionary<string, string> DefaultRequestHeaders
		{
			get
			{
				if (_defaultRequestHeaders == null)
				{
					_defaultRequestHeaders = new Dictionary<string, string>();
				}
				return _defaultRequestHeaders;
			}
			set
			{
				_defaultRequestHeaders = value;
			}
		}

		public static void CleanDefaultHeaders()
		{
			DefaultRequestHeaders.Clear();
		}

		public static void Request(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			StaticCoroutine.StartCoroutine(HttpBase.DefaultUnityWebRequest(options, callback));
		}

		public static void Request<T>(RequestHelper options, Action<RequestException, ResponseHelper, T> callback)
		{
			StaticCoroutine.StartCoroutine(HttpBase.DefaultUnityWebRequest(options, callback));
		}

		public static void Get(string url, Action<RequestException, ResponseHelper> callback)
		{
			Get(new RequestHelper
			{
				Uri = url
			}, callback);
		}

		public static void Get(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			options.Method = "GET";
			Request(options, callback);
		}

		public static void Get<T>(string url, Action<RequestException, ResponseHelper, T> callback)
		{
			Get(new RequestHelper
			{
				Uri = url
			}, callback);
		}

		public static void Get<T>(RequestHelper options, Action<RequestException, ResponseHelper, T> callback)
		{
			options.Method = "GET";
			Request(options, callback);
		}

		public static void GetArray<T>(string url, Action<RequestException, ResponseHelper, T[]> callback)
		{
			GetArray(new RequestHelper
			{
				Uri = url
			}, callback);
		}

		public static void GetArray<T>(RequestHelper options, Action<RequestException, ResponseHelper, T[]> callback)
		{
			options.Method = "GET";
			StaticCoroutine.StartCoroutine(HttpBase.DefaultUnityWebRequest(options, callback));
		}

		public static void Post(string url, object body, Action<RequestException, ResponseHelper> callback)
		{
			Post(new RequestHelper
			{
				Uri = url,
				Body = body
			}, callback);
		}

		public static void Post(string url, string bodyString, Action<RequestException, ResponseHelper> callback)
		{
			Post(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			}, callback);
		}

		public static void Post(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			options.Method = "POST";
			Request(options, callback);
		}

		public static void Post<T>(string url, object body, Action<RequestException, ResponseHelper, T> callback)
		{
			Post(new RequestHelper
			{
				Uri = url,
				Body = body
			}, callback);
		}

		public static void Post<T>(string url, string bodyString, Action<RequestException, ResponseHelper, T> callback)
		{
			Post(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			}, callback);
		}

		public static void Post<T>(RequestHelper options, Action<RequestException, ResponseHelper, T> callback)
		{
			options.Method = "POST";
			Request(options, callback);
		}

		public static void Put(string url, object body, Action<RequestException, ResponseHelper> callback)
		{
			Put(new RequestHelper
			{
				Uri = url,
				Body = body
			}, callback);
		}

		public static void Put(string url, string bodyString, Action<RequestException, ResponseHelper> callback)
		{
			Put(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			}, callback);
		}

		public static void Put(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			options.Method = "PUT";
			Request(options, callback);
		}

		public static void Put<T>(string url, object body, Action<RequestException, ResponseHelper, T> callback)
		{
			Put(new RequestHelper
			{
				Uri = url,
				Body = body
			}, callback);
		}

		public static void Put<T>(string url, string bodyString, Action<RequestException, ResponseHelper, T> callback)
		{
			Put(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			}, callback);
		}

		public static void Put<T>(RequestHelper options, Action<RequestException, ResponseHelper, T> callback)
		{
			options.Method = "PUT";
			Request(options, callback);
		}

		public static void Delete(string url, Action<RequestException, ResponseHelper> callback)
		{
			Delete(new RequestHelper
			{
				Uri = url
			}, callback);
		}

		public static void Delete(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			options.Method = "DELETE";
			Request(options, callback);
		}

		public static void Head(string url, Action<RequestException, ResponseHelper> callback)
		{
			Head(new RequestHelper
			{
				Uri = url
			}, callback);
		}

		public static void Head(RequestHelper options, Action<RequestException, ResponseHelper> callback)
		{
			options.Method = "HEAD";
			Request(options, callback);
		}

		public static IPromise<ResponseHelper> Request(RequestHelper options)
		{
			Promise<ResponseHelper> promise = new Promise<ResponseHelper>();
			Request(options, promise.Promisify<ResponseHelper>);
			return promise;
		}

		public static IPromise<T> Request<T>(RequestHelper options)
		{
			Promise<T> promise = new Promise<T>();
			Request<T>(options, promise.Promisify);
			return promise;
		}

		public static IPromise<ResponseHelper> Get(string url)
		{
			return Get(new RequestHelper
			{
				Uri = url
			});
		}

		public static IPromise<ResponseHelper> Get(RequestHelper options)
		{
			Promise<ResponseHelper> promise = new Promise<ResponseHelper>();
			Get(options, promise.Promisify<ResponseHelper>);
			return promise;
		}

		public static IPromise<T> Get<T>(string url)
		{
			return Get<T>(new RequestHelper
			{
				Uri = url
			});
		}

		public static IPromise<T> Get<T>(RequestHelper options)
		{
			Promise<T> promise = new Promise<T>();
			Get<T>(options, promise.Promisify);
			return promise;
		}

		public static IPromise<T[]> GetArray<T>(string url)
		{
			return GetArray<T>(new RequestHelper
			{
				Uri = url
			});
		}

		public static IPromise<T[]> GetArray<T>(RequestHelper options)
		{
			Promise<T[]> promise = new Promise<T[]>();
			GetArray<T>(options, promise.Promisify);
			return promise;
		}

		public static IPromise<ResponseHelper> Post(string url, object body)
		{
			return Post(new RequestHelper
			{
				Uri = url,
				Body = body
			});
		}

		public static IPromise<ResponseHelper> Post(string url, string bodyString)
		{
			return Post(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			});
		}

		public static IPromise<ResponseHelper> Post(RequestHelper options)
		{
			Promise<ResponseHelper> promise = new Promise<ResponseHelper>();
			Post(options, promise.Promisify<ResponseHelper>);
			return promise;
		}

		public static IPromise<T> Post<T>(string url, object body)
		{
			return Post<T>(new RequestHelper
			{
				Uri = url,
				Body = body
			});
		}

		public static IPromise<T> Post<T>(string url, string bodyString)
		{
			return Post<T>(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			});
		}

		public static IPromise<T> Post<T>(RequestHelper options)
		{
			Promise<T> promise = new Promise<T>();
			Post<T>(options, promise.Promisify);
			return promise;
		}

		public static IPromise<ResponseHelper> Put(string url, object body)
		{
			return Put(new RequestHelper
			{
				Uri = url,
				Body = body
			});
		}

		public static IPromise<ResponseHelper> Put(string url, string bodyString)
		{
			return Put(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			});
		}

		public static IPromise<ResponseHelper> Put(RequestHelper options)
		{
			Promise<ResponseHelper> promise = new Promise<ResponseHelper>();
			Put(options, promise.Promisify<ResponseHelper>);
			return promise;
		}

		public static IPromise<T> Put<T>(string url, object body)
		{
			return Put<T>(new RequestHelper
			{
				Uri = url,
				Body = body
			});
		}

		public static IPromise<T> Put<T>(string url, string bodyString)
		{
			return Put<T>(new RequestHelper
			{
				Uri = url,
				BodyString = bodyString
			});
		}

		public static IPromise<T> Put<T>(RequestHelper options)
		{
			Promise<T> promise = new Promise<T>();
			Put<T>(options, promise.Promisify);
			return promise;
		}

		public static IPromise<ResponseHelper> Delete(string url)
		{
			return Delete(new RequestHelper
			{
				Uri = url
			});
		}

		public static IPromise<ResponseHelper> Delete(RequestHelper options)
		{
			Promise<ResponseHelper> promise = new Promise<ResponseHelper>();
			Delete(options, promise.Promisify<ResponseHelper>);
			return promise;
		}

		public static IPromise<ResponseHelper> Head(string url)
		{
			return Delete(new RequestHelper
			{
				Uri = url
			});
		}

		public static IPromise<ResponseHelper> Head(RequestHelper options)
		{
			Promise<ResponseHelper> promise = new Promise<ResponseHelper>();
			Head(options, promise.Promisify<ResponseHelper>);
			return promise;
		}

		private static void Promisify<T>(this Promise<T> promise, RequestException error, T response)
		{
			if (error != null)
			{
				promise.Reject(error);
			}
			else
			{
				promise.Resolve(response);
			}
		}

		private static void Promisify<T>(this Promise<T> promise, RequestException error, ResponseHelper response, T body)
		{
			if (error != null && response != null)
			{
				error.ServerMessage = response.Error ?? error.Message;
			}
			promise.Promisify(error, body);
		}
	}
}
namespace Proyecto26.Common
{
	public static class Common
	{
		private const string CONTENT_TYPE_HEADER = "Content-Type";

		private const string DEFAULT_CONTENT_TYPE = "application/json";

		private static string GetFormSectionsContentType(out byte[] bodyRaw, RequestHelper options)
		{
			byte[] array = UnityWebRequest.GenerateBoundary();
			byte[] array2 = UnityWebRequest.SerializeFormSections(options.FormSections, array);
			byte[] bytes = Encoding.UTF8.GetBytes("\r\n--" + Encoding.UTF8.GetString(array) + "--");
			bodyRaw = new byte[array2.Length + bytes.Length];
			Buffer.BlockCopy(array2, 0, bodyRaw, 0, array2.Length);
			Buffer.BlockCopy(bytes, 0, bodyRaw, array2.Length, bytes.Length);
			return "multipart/form-data; boundary=" + Encoding.UTF8.GetString(array);
		}

		private static void ConfigureWebRequestWithOptions(UnityWebRequest request, byte[] bodyRaw, string contentType, RequestHelper options)
		{
			if (options.CertificateHandler != null)
			{
				request.certificateHandler = options.CertificateHandler;
			}
			if (options.UploadHandler != null)
			{
				request.uploadHandler = options.UploadHandler;
			}
			if (bodyRaw != null)
			{
				request.uploadHandler = new UploadHandlerRaw(bodyRaw);
				request.uploadHandler.contentType = contentType;
			}
			if (options.DownloadHandler != null)
			{
				request.downloadHandler = options.DownloadHandler;
			}
			else
			{
				request.downloadHandler = new DownloadHandlerBuffer();
			}
			if (!string.IsNullOrEmpty(contentType))
			{
				request.SetRequestHeader("Content-Type", contentType);
			}
			foreach (KeyValuePair<string, string> defaultRequestHeader in RestClient.DefaultRequestHeaders)
			{
				request.SetRequestHeader(defaultRequestHeader.Key, defaultRequestHeader.Value);
			}
			foreach (KeyValuePair<string, string> header in options.Headers)
			{
				request.SetRequestHeader(header.Key, header.Value);
			}
			if (options.Timeout.HasValue)
			{
				request.timeout = options.Timeout.Value;
			}
			if (options.ChunkedTransfer.HasValue)
			{
				request.chunkedTransfer = options.ChunkedTransfer.Value;
			}
			if (options.UseHttpContinue.HasValue)
			{
				request.useHttpContinue = options.UseHttpContinue.Value;
			}
			if (options.RedirectLimit.HasValue)
			{
				request.redirectLimit = options.RedirectLimit.Value;
			}
			options.Request = request;
		}

		public static IEnumerator SendWebRequestWithOptions(this UnityWebRequest request, RequestHelper options)
		{
			byte[] bodyRaw = options.BodyRaw;
			string value = string.Empty;
			if (!options.Headers.TryGetValue("Content-Type", out value) && options.DefaultContentType)
			{
				value = "application/json";
			}
			if (options.Body != null || !string.IsNullOrEmpty(options.BodyString))
			{
				string text = options.BodyString;
				if (options.Body != null)
				{
					text = JsonUtility.ToJson(options.Body);
				}
				bodyRaw = Encoding.UTF8.GetBytes(text.ToCharArray());
			}
			else if (options.SimpleForm != null && options.SimpleForm.Count > 0)
			{
				bodyRaw = UnityWebRequest.SerializeSimpleForm(options.SimpleForm);
				value = "application/x-www-form-urlencoded";
			}
			else if (options.FormSections != null && options.FormSections.Count > 0)
			{
				value = GetFormSectionsContentType(out bodyRaw, options);
			}
			else if (options.FormData != null)
			{
				value = string.Empty;
			}
			if (!string.IsNullOrEmpty(options.ContentType))
			{
				value = options.ContentType;
			}
			ConfigureWebRequestWithOptions(request, bodyRaw, value, options);
			yield return request.SendWebRequest();
		}
	}
	public static class Extensions
	{
		public static ResponseHelper CreateWebResponse(this UnityWebRequest request)
		{
			return new ResponseHelper(request);
		}

		public static bool IsValidRequest(this UnityWebRequest request, RequestHelper options)
		{
			if (request.isDone && !request.isNetworkError)
			{
				if (request.isHttpError)
				{
					return options.IgnoreHttpException;
				}
				return true;
			}
			return false;
		}
	}
}
namespace Models
{
	[Serializable]
	public class Photo
	{
		public int albumId;

		public int id;

		public string title;

		public string url;

		public string thumbnailUrl;

		public override string ToString()
		{
			return JsonUtility.ToJson(this, prettyPrint: true);
		}
	}
	[Serializable]
	public class Post
	{
		public int id;

		public int userId;

		public string title;

		public string body;

		public override string ToString()
		{
			return JsonUtility.ToJson(this, prettyPrint: true);
		}
	}
	[Serializable]
	public class Todo
	{
		public int id;

		public int userId;

		public string title;

		public bool completed;

		public override string ToString()
		{
			return JsonUtility.ToJson(this, prettyPrint: true);
		}
	}
	[Serializable]
	public class User
	{
		public int id;

		public string name;

		public string username;

		public string email;

		public string phone;

		public string website;

		public override string ToString()
		{
			return JsonUtility.ToJson(this, prettyPrint: true);
		}
	}
}
namespace DG.Tweening
{
	public static class DOTweenModulePhysics
	{
		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMove(this Rigidbody target, Vector3 endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, endValue, duration);
			tweenerCore.SetOptions(snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveX(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue, 0f, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.X, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveY(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, endValue, 0f), duration);
			tweenerCore.SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector3, Vector3, VectorOptions> DOMoveZ(this Rigidbody target, float endValue, float duration, bool snapping = false)
		{
			TweenerCore<Vector3, Vector3, VectorOptions> tweenerCore = DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, 0f, endValue), duration);
			tweenerCore.SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DORotate(this Rigidbody target, Vector3 endValue, float duration, RotateMode mode = RotateMode.Fast)
		{
			TweenerCore<Quaternion, Vector3, QuaternionOptions> tweenerCore = DOTween.To(() => target.rotation, target.MoveRotation, endValue, duration);
			tweenerCore.SetTarget(target);
			tweenerCore.plugOptions.rotateMode = mode;
			return tweenerCore;
		}

		public static TweenerCore<Quaternion, Vector3, QuaternionOptions> DOLookAt(this Rigidbody target, Vector3 towards, float duration, AxisConstraint axisConstraint = AxisConstraint.None, Vector3? up = null)
		{
			TweenerCore<Quaternion, Vector3, QuaternionOptions> tweenerCore = DOTween.To(() => target.rotation, target.MoveRotation, towards, duration).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetLookAt);
			tweenerCore.plugOptions.axisConstraint = axisConstraint;
			tweenerCore.plugOptions.up = ((!up.HasValue) ? Vector3.up : up.Value);
			return tweenerCore;
		}

		public static Sequence DOJump(this Rigidbody target, Vector3 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			float startPosY = 0f;
			float offsetY = -1f;
			bool offsetYSet = false;
			Sequence s = DOTween.Sequence();
			Tween yTween = DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, jumpPower, 0f), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad)
				.SetRelative()
				.SetLoops(numJumps * 2, LoopType.Yoyo)
				.OnStart(delegate
				{
					startPosY = target.position.y;
				});
			s.Append(DOTween.To(() => target.position, target.MovePosition, new Vector3(endValue.x, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)).Join(DOTween.To(() => target.position, target.MovePosition, new Vector3(0f, 0f, endValue.z), duration).SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)).Join(yTween)
				.SetTarget(target)
				.SetEase(DOTween.defaultEaseType);
			yTween.OnUpdate(delegate
			{
				if (!offsetYSet)
				{
					offsetYSet = true;
					offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
				}
				Vector3 position = target.position;
				position.y += DOVirtual.EasedValue(0f, offsetY, yTween.ElapsedPercentage(), Ease.OutQuad);
				target.MovePosition(position);
			});
			return s;
		}

		public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOPath(this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			if (resolution < 1)
			{
				resolution = 1;
			}
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, new DG.Tweening.Plugins.Core.PathCore.Path(pathType, path, resolution, gizmoColor), duration).SetTarget(target).SetUpdate(UpdateType.Fixed);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			return tweenerCore;
		}

		public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOLocalPath(this Rigidbody target, Vector3[] path, float duration, PathType pathType = PathType.Linear, PathMode pathMode = PathMode.Full3D, int resolution = 10, Color? gizmoColor = null)
		{
			if (resolution < 1)
			{
				resolution = 1;
			}
			Transform trans = target.transform;
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => trans.localPosition, delegate(Vector3 x)
			{
				target.MovePosition((trans.parent == null) ? x : trans.parent.TransformPoint(x));
			}, new DG.Tweening.Plugins.Core.PathCore.Path(pathType, path, resolution, gizmoColor), duration).SetTarget(target).SetUpdate(UpdateType.Fixed);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			tweenerCore.plugOptions.useLocalPosition = true;
			return tweenerCore;
		}

		internal static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOPath(this Rigidbody target, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => target.position, target.MovePosition, path, duration).SetTarget(target);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			return tweenerCore;
		}

		internal static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> DOLocalPath(this Rigidbody target, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode = PathMode.Full3D)
		{
			Transform trans = target.transform;
			TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> tweenerCore = DOTween.To(PathPlugin.Get(), () => trans.localPosition, delegate(Vector3 x)
			{
				target.MovePosition((trans.parent == null) ? x : trans.parent.TransformPoint(x));
			}, path, duration).SetTarget(target);
			tweenerCore.plugOptions.isRigidbody = true;
			tweenerCore.plugOptions.mode = pathMode;
			tweenerCore.plugOptions.useLocalPosition = true;
			return tweenerCore;
		}
	}
	public static class DOTweenModuleUnityVersion
	{
		public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			sequence.SetTarget(target);
			return sequence;
		}

		public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.SetColor(property, gradientColorKey.color);
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, property, duration2).SetEase(Ease.Linear));
			}
			sequence.SetTarget(target);
			return sequence;
		}

		public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForCompletion(t);
		}

		public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForRewind(t);
		}

		public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForKill(t);
		}

		public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
		}

		public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForPosition(t, position);
		}

		public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForStart(t);
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOOffset(this Material target, Vector2 endValue, int propertyID, float duration)
		{
			if (!target.HasProperty(propertyID))
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
				}
				return null;
			}
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.GetTextureOffset(propertyID), delegate(Vector2 x)
			{
				target.SetTextureOffset(propertyID, x);
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}

		public static TweenerCore<Vector2, Vector2, VectorOptions> DOTiling(this Material target, Vector2 endValue, int propertyID, float duration)
		{
			if (!target.HasProperty(propertyID))
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
				}
				return null;
			}
			TweenerCore<Vector2, Vector2, VectorOptions> tweenerCore = DOTween.To(() => target.GetTextureScale(propertyID), delegate(Vector2 x)
			{
				target.SetTextureScale(propertyID, x);
			}, endValue, duration);
			tweenerCore.SetTarget(target);
			return tweenerCore;
		}
	}
	public static class DOTweenCYInstruction
	{
		public class WaitForCompletion : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.IsComplete();
					}
					return false;
				}
			}

			public WaitForCompletion(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForRewind : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						if (t.playedOnce)
						{
							return t.position * (float)(t.CompletedLoops() + 1) > 0f;
						}
						return true;
					}
					return false;
				}
			}

			public WaitForRewind(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForKill : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting => t.active;

			public WaitForKill(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForElapsedLoops : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly int elapsedLoops;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.CompletedLoops() < elapsedLoops;
					}
					return false;
				}
			}

			public WaitForElapsedLoops(Tween tween, int elapsedLoops)
			{
				t = tween;
				this.elapsedLoops = elapsedLoops;
			}
		}

		public class WaitForPosition : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly float position;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.position * (float)(t.CompletedLoops() + 1) < position;
					}
					return false;
				}
			}

			public WaitForPosition(Tween tween, float position)
			{
				t = tween;
				this.position = position;
			}
		}

		public class WaitForStart : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.playedOnce;
					}
					return false;
				}
			}

			public WaitForStart(Tween tween)
			{
				t = tween;
			}
		}
	}
	public static class DOTweenModuleUtils
	{
		public static class Physics
		{
			public static void SetOrientationOnPath(PathOptions options, Tween t, Quaternion newRot, Transform trans)
			{
				if (options.isRigidbody)
				{
					((Rigidbody)t.target).rotation = newRot;
				}
				else
				{
					trans.rotation = newRot;
				}
			}

			public static bool HasRigidbody2D(UnityEngine.Component target)
			{
				return false;
			}

			[Preserve]
			public static bool HasRigidbody(UnityEngine.Component target)
			{
				return target.GetComponent<Rigidbody>() != null;
			}

			[Preserve]
			public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> CreateDOTweenPathTween(MonoBehaviour target, bool tweenRigidbody, bool isLocal, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode)
			{
				Rigidbody rigidbody = (tweenRigidbody ? target.GetComponent<Rigidbody>() : null);
				if (tweenRigidbody && rigidbody != null)
				{
					return isLocal ? rigidbody.DOLocalPath(path, duration, pathMode) : rigidbody.DOPath(path, duration, pathMode);
				}
				return isLocal ? target.transform.DOLocalPath(path, duration, pathMode) : target.transform.DOPath(path, duration, pathMode);
			}
		}

		private static bool _initialized;

		[Preserve]
		public static void Init()
		{
			if (!_initialized)
			{
				_initialized = true;
				DOTweenExternalCommand.SetOrientationOnPath += Physics.SetOrientationOnPath;
			}
		}

		[Preserve]
		private static void Preserver()
		{
			AppDomain.CurrentDomain.GetAssemblies();
			typeof(MonoBehaviour).GetMethod("Stub");
		}
	}
}
