using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AOT;
using Battlehub.RTEditor;
using Battlehub.RTHandles;
using Battlehub.UIControls;
using Battlehub.Utils;
using BoundarySystem_Ext;
using CurvedUI;
using I2.Loc;
using LitJson;
using NaughtyAttributes;
using Pvr_UnitySDKAPI;
using Pvr_UnitySDKAPI.Achievement;
using TMPro;
using UnityEngine;
using UnityEngine.Android;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.XR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: OptionalDependency("Valve.VR.InteractionSystem.Player", "CURVEDUI_STEAMVR_INT")]
[assembly: OptionalDependency("TMPro.TextMeshProUGUI", "CURVEDUI_TMP")]
[assembly: AssemblyVersion("0.0.0.0")]
public class LocomotionMaleScript : MonoBehaviour
{
	private Animator anim;

	private void Start()
	{
		anim = base.transform.GetComponent<Animator>();
	}

	private void OnGUI()
	{
		GUILayout.Label("CONTROLS");
		GUILayout.Label("Movement: W A S D");
		GUILayout.Label("Turn: Q E");
		GUILayout.Label("Jump: Spacebar");
	}

	private void Update()
	{
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		anim.SetFloat("Speed", axis2, 0.15f, Time.deltaTime);
		anim.SetFloat("Direction", axis, 0.15f, Time.deltaTime);
		if (axis2 > 0.05f)
		{
			if (axis > 0.05f)
			{
				base.transform.Rotate(Vector3.up * (Time.deltaTime + 2f), Space.World);
			}
			if (axis < -0.05f)
			{
				base.transform.Rotate(Vector3.up * (Time.deltaTime + -2f), Space.World);
			}
		}
		else if (axis2 < -0.05f)
		{
			if (axis > 0.05f)
			{
				base.transform.Rotate(Vector3.up * (Time.deltaTime + -2f), Space.World);
			}
			if (axis < -0.05f)
			{
				base.transform.Rotate(Vector3.up * (Time.deltaTime + 2f), Space.World);
			}
		}
		if (Input.GetKey(KeyCode.Q))
		{
			anim.SetFloat("Turn", -1f, 0.1f, Time.deltaTime);
			base.transform.Rotate(Vector3.up * (Time.deltaTime + -2f), Space.World);
		}
		else if (Input.GetKey(KeyCode.E))
		{
			anim.SetFloat("Turn", 1f, 0.1f, Time.deltaTime);
			base.transform.Rotate(Vector3.up * (Time.deltaTime + 2f), Space.World);
		}
		else
		{
			anim.SetFloat("Turn", 0f, 0.1f, Time.deltaTime);
		}
		if (Input.GetButton("Jump"))
		{
			StartCoroutine(TriggerAnimatorBool("Jump"));
		}
	}

	private IEnumerator TriggerAnimatorBool(string name)
	{
		anim.SetBool(name, value: true);
		yield return null;
		anim.SetBool(name, value: false);
	}
}
public class DemoAnimationScript : MonoBehaviour
{
	public Animator anim;

	private void Start()
	{
	}

	public void attack1()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Attack1");
	}

	public void attack2()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Attack2");
	}

	public void attack3()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Attack3");
	}

	public void NomralPunch()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("NormalPunch");
	}

	public void ZombieAttack()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("ZombieAttack");
	}

	public void IdleToShoot()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("IdleToShoot");
	}

	public void IdleToShootBow()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("IdleToShootBow");
	}

	public void GetHit()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("GetHit");
	}

	public void Salute()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Salute");
	}

	public void SimpleAttack()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("SimpleAttack");
	}

	public void Spell1()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Spell1");
	}

	public void Spell2()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Spell2");
	}

	public void Spell3()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Spell3");
	}

	public void Spell4()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetTrigger("Spell4");
	}

	public void Walk()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Walk", value: true);
	}

	public void Run()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Run", value: true);
	}

	public void Idle1()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Idle1", value: true);
	}

	public void IdleStill()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("IdleStill", value: true);
	}

	public void Swim()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("Swim", value: true);
	}

	public void SitandTalk()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("SitandTalk", value: true);
	}

	public void RideAnimalStill()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("RideAnimalStill", value: true);
	}

	public void RideAnimalMoving()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: true);
	}

	public void HoldBow()
	{
		anim.SetBool("ZombieWalk", value: false);
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: true);
	}

	public void ZombieWalk()
	{
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: false);
		anim.SetBool("ZombieWalk", value: true);
	}

	public void HoldShoot()
	{
		anim.SetBool("SitandTalk", value: false);
		anim.SetBool("Swim", value: false);
		anim.SetBool("Idle1", value: false);
		anim.SetBool("Run", value: false);
		anim.SetBool("Walk", value: false);
		anim.SetBool("SitandLook", value: false);
		anim.SetBool("SitStill", value: false);
		anim.SetBool("IdleStill", value: false);
		anim.SetBool("RideAnimalStill", value: false);
		anim.SetBool("RideAnimalMoving", value: false);
		anim.SetBool("HoldBow", value: false);
		anim.SetBool("HoldShoot", value: true);
	}

	private void Update()
	{
	}
}
public class GUI_SelectAni : MonoBehaviour
{
	public GameObject Cat01;

	public GameObject Cat02;

	public GameObject Cat03;

	public GameObject Cat04;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnGUI()
	{
		int num = 100;
		int num2 = 50;
		int num3 = 150;
		string text = "Ani";
		GUI.Label(new Rect(20f, 50f, 500f, 50f), "-  You can see by rotating the mouse");
		GUI.Label(new Rect(20f, 80f, 200f, 50f), "-  Animations");
		text = "Idle01";
		if (GUI.Button(new Rect(20f, num, num3, num2), text))
		{
			Cat01.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat01.GetComponent<Animation>().CrossFade(text);
			Cat02.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat02.GetComponent<Animation>().CrossFade(text);
			Cat03.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat03.GetComponent<Animation>().CrossFade(text);
			Cat04.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat04.GetComponent<Animation>().CrossFade(text);
		}
		text = "Idle02";
		if (GUI.Button(new Rect(20f, num += num2, num3, num2), text))
		{
			Cat01.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat01.GetComponent<Animation>().CrossFade(text);
			Cat02.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat02.GetComponent<Animation>().CrossFade(text);
			Cat03.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat03.GetComponent<Animation>().CrossFade(text);
			Cat04.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat04.GetComponent<Animation>().CrossFade(text);
		}
		text = "Idle03";
		if (GUI.Button(new Rect(20f, num += num2, num3, num2), text))
		{
			Cat01.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat01.GetComponent<Animation>().CrossFade(text);
			Cat02.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat02.GetComponent<Animation>().CrossFade(text);
			Cat03.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat03.GetComponent<Animation>().CrossFade(text);
			Cat04.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat04.GetComponent<Animation>().CrossFade(text);
		}
		text = "Walk";
		if (GUI.Button(new Rect(20f, num += num2, num3, num2), text))
		{
			Cat01.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat01.GetComponent<Animation>().CrossFade(text);
			Cat02.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat02.GetComponent<Animation>().CrossFade(text);
			Cat03.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat03.GetComponent<Animation>().CrossFade(text);
			Cat04.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat04.GetComponent<Animation>().CrossFade(text);
		}
		text = "Run";
		if (GUI.Button(new Rect(20f, num += num2, num3, num2), text))
		{
			Cat01.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat01.GetComponent<Animation>().CrossFade(text);
			Cat02.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat02.GetComponent<Animation>().CrossFade(text);
			Cat03.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat03.GetComponent<Animation>().CrossFade(text);
			Cat04.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat04.GetComponent<Animation>().CrossFade(text);
		}
		text = "Dance";
		if (GUI.Button(new Rect(20f, num += num2, num3, num2), text))
		{
			Cat01.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat01.GetComponent<Animation>().CrossFade(text);
			Cat02.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat02.GetComponent<Animation>().CrossFade(text);
			Cat03.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat03.GetComponent<Animation>().CrossFade(text);
			Cat04.GetComponent<Animation>().wrapMode = WrapMode.Loop;
			Cat04.GetComponent<Animation>().CrossFade(text);
		}
	}
}
public class RotateObject : MonoBehaviour
{
	private void Update()
	{
		if (Input.GetMouseButton(0))
		{
			base.transform.Rotate(Vector3.up * -15f * Input.GetAxis("Mouse X"));
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
[AddComponentMenu("Camera-Control/Mouse Orbit with zoom")]
public class MouseOrbitImproved : MonoBehaviour
{
	public Transform target;

	public float distance = 5f;

	public float xSpeed = 120f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distanceMin = 0.5f;

	public float distanceMax = 15f;

	private Rigidbody rigidbody;

	private float x;

	private float y;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		rigidbody = GetComponent<Rigidbody>();
		if (rigidbody != null)
		{
			rigidbody.freezeRotation = true;
		}
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			x += Input.GetAxis("Mouse X") * xSpeed * distance * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
			if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
			{
				distance -= hitInfo.distance;
			}
			Vector3 vector = new Vector3(0f, 0f, 0f - distance);
			Vector3 position = quaternion * vector + target.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class CUI_CameraRotationOnButtonHeld : MonoBehaviour
{
	[SerializeField]
	private float Sensitivity = 0.5f;

	private Vector3 oldMousePos;

	private bool move = true;

	private void Start()
	{
		oldMousePos = Input.mousePosition;
	}
}
public class CUI_MoveAlong : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		(base.transform as RectTransform).anchoredPosition = new Vector2((base.transform as RectTransform).anchoredPosition.x + (base.transform as RectTransform).anchoredPosition.x / 100f, (base.transform as RectTransform).anchoredPosition.y);
		if ((base.transform as RectTransform).anchoredPosition.x > (base.transform.parent as RectTransform).rect.width)
		{
			(base.transform as RectTransform).anchoredPosition = new Vector2(20f, (base.transform as RectTransform).anchoredPosition.y);
		}
	}
}
public class CUI_MoveHeartbeat : MonoBehaviour
{
	public float speed;

	public bool wrapAroundParent = true;

	private RectTransform rectie;

	private RectTransform parentRectie;

	private void Start()
	{
		rectie = base.transform as RectTransform;
		parentRectie = base.transform.parent as RectTransform;
	}

	private void Update()
	{
		rectie.anchoredPosition = new Vector2(rectie.anchoredPosition.x - speed * Time.deltaTime, rectie.anchoredPosition.y);
		if (wrapAroundParent && rectie.anchoredPosition.x + rectie.rect.width < 0f)
		{
			rectie.anchoredPosition = new Vector2(parentRectie.rect.width, rectie.anchoredPosition.y);
		}
	}
}
public class CUI_ShowParentCoordinates : MonoBehaviour
{
	private void Start()
	{
		GetComponent<Text>().text = base.transform.parent.GetComponent<RectTransform>().anchoredPosition.ToString();
	}

	private void Update()
	{
	}
}
public class CUI_rotation_anim : MonoBehaviour
{
	public Vector3 Rotation;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.RotateAround(base.transform.position, base.transform.up, Rotation.y * Time.deltaTime);
		base.transform.RotateAround(base.transform.position, base.transform.right, Rotation.x * Time.deltaTime);
		base.transform.RotateAround(base.transform.position, base.transform.forward, Rotation.z * Time.deltaTime);
	}
}
public class CUI_touchpad : MonoBehaviour
{
	private RectTransform container;

	[SerializeField]
	private RectTransform dot;

	private void Awake()
	{
		container = base.transform as RectTransform;
	}

	private void MoveDotOnTouchpadAxisChanged(object o, ViveInputArgs args)
	{
		dot.anchoredPosition = new Vector2(args.touchpadAxis.x * container.rect.width * 0.5f, args.touchpadAxis.y * container.rect.width * 0.5f);
	}
}
[ExecuteInEditMode]
public class CurvedUIInputModule : StandaloneInputModule
{
	public enum CUIControlMethod
	{
		MOUSE = 0,
		GAZE = 1,
		WORLD_MOUSE = 2,
		CUSTOM_RAY = 3,
		STEAMVR_LEGACY = 4,
		OCULUSVR = 5,
		GOOGLEVR = 7,
		STEAMVR_2 = 8
	}

	public enum Hand
	{
		Both,
		Right,
		Left
	}

	[SerializeField]
	private CUIControlMethod controlMethod;

	[SerializeField]
	private string submitButtonName = "Fire1";

	[SerializeField]
	private bool gazeUseTimedClick;

	[SerializeField]
	private float gazeClickTimer = 2f;

	[SerializeField]
	private float gazeClickTimerDelay = 1f;

	[SerializeField]
	private Image gazeTimedClickProgressImage;

	[SerializeField]
	private float worldSpaceMouseSensitivity = 1f;

	[SerializeField]
	private Hand usedHand = Hand.Right;

	[SerializeField]
	private Transform controllerTransformOverride;

	private static bool disableOtherInputModulesOnStart = true;

	private static CurvedUIInputModule instance;

	private GameObject currentDragging;

	private GameObject currentPointedAt;

	private GameObject m_rightController;

	private GameObject m_leftController;

	private float gazeTimerProgress;

	private Ray customControllerRay;

	private float dragThreshold = 10f;

	private bool pressedDown;

	private bool pressedLastFrame;

	private Vector3 lastMouseOnScreenPos = Vector2.zero;

	private Vector2 worldSpaceMouseInCanvasSpace = Vector2.zero;

	private Vector2 lastWorldSpaceMouseOnCanvas = Vector2.zero;

	private Vector2 worldSpaceMouseOnCanvasDelta = Vector2.zero;

	public static CurvedUIInputModule Instance
	{
		get
		{
			if (instance == null)
			{
				instance = EnableInputModule<CurvedUIInputModule>();
			}
			return instance;
		}
		private set
		{
			instance = value;
		}
	}

	public static CUIControlMethod ControlMethod
	{
		get
		{
			return Instance.controlMethod;
		}
		set
		{
			if (Instance.controlMethod != value)
			{
				Instance.controlMethod = value;
			}
		}
	}

	public Hand UsedHand
	{
		get
		{
			return usedHand;
		}
		set
		{
			usedHand = value;
		}
	}

	public Transform ControllerTransform
	{
		get
		{
			if (ControllerTransformOverride != null)
			{
				return ControllerTransformOverride;
			}
			UnityEngine.Debug.LogWarning("CURVEDUI: CurvedUIInputModule.ActiveController will only return proper gameobject in  STEAMVR, STEAMVR_LEGACY, OCULUSVR or GOOGLEVR control methods.");
			return null;
		}
	}

	public Vector3 ControllerPointingDirection
	{
		get
		{
			UnityEngine.Debug.LogWarning("CURVEDUI: CurvedUIInputModule.PointingDirection will only return proper direction in  STEAMVR, STEAMVR_LEGACY, OCULUSVR or GOOGLEVR control methods.");
			return Vector3.forward;
		}
	}

	public Vector3 ControllerPointingOrigin
	{
		get
		{
			UnityEngine.Debug.LogWarning("CURVEDUI: CurvedUIInputModule.PointingOrigin will only return proper position in  STEAMVR, STEAMVR_LEGACY, OCULUSVR or GOOGLEVR control methods.");
			return Vector3.zero;
		}
	}

	public Transform ControllerTransformOverride
	{
		get
		{
			return instance.controllerTransformOverride;
		}
		set
		{
			instance.controllerTransformOverride = value;
		}
	}

	public GameObject CurrentPointedAt => currentPointedAt;

	public static Ray CustomControllerRay
	{
		get
		{
			return Instance.customControllerRay;
		}
		set
		{
			Instance.customControllerRay = value;
		}
	}

	public static bool CustomControllerButtonState
	{
		get
		{
			return Instance.pressedDown;
		}
		set
		{
			Instance.pressedDown = value;
		}
	}

	[Obsolete("Use CustomControllerButtonState instead.")]
	public static bool CustomControllerButtonDown
	{
		get
		{
			return Instance.pressedDown;
		}
		set
		{
			Instance.pressedDown = value;
		}
	}

	public Vector2 WorldSpaceMouseInCanvasSpace
	{
		get
		{
			return worldSpaceMouseInCanvasSpace;
		}
		set
		{
			worldSpaceMouseInCanvasSpace = value;
			lastWorldSpaceMouseOnCanvas = value;
		}
	}

	public Vector2 WorldSpaceMouseInCanvasSpaceDelta => worldSpaceMouseInCanvasSpace - lastWorldSpaceMouseOnCanvas;

	public float WorldSpaceMouseSensitivity
	{
		get
		{
			return worldSpaceMouseSensitivity;
		}
		set
		{
			worldSpaceMouseSensitivity = value;
		}
	}

	public bool GazeUseTimedClick
	{
		get
		{
			return gazeUseTimedClick;
		}
		set
		{
			gazeUseTimedClick = value;
		}
	}

	public float GazeClickTimer
	{
		get
		{
			return gazeClickTimer;
		}
		set
		{
			gazeClickTimer = Mathf.Max(value, 0f);
		}
	}

	public float GazeClickTimerDelay
	{
		get
		{
			return gazeClickTimerDelay;
		}
		set
		{
			gazeClickTimerDelay = Mathf.Max(value, 0f);
		}
	}

	public float GazeTimerProgress => gazeTimerProgress;

	public Image GazeTimedClickProgressImage
	{
		get
		{
			return gazeTimedClickProgressImage;
		}
		set
		{
			gazeTimedClickProgressImage = value;
		}
	}

	protected override void Awake()
	{
		if (Application.isPlaying)
		{
			Instance = this;
			base.Awake();
			if (gazeTimedClickProgressImage != null)
			{
				gazeTimedClickProgressImage.fillAmount = 0f;
			}
		}
	}

	protected virtual void Update()
	{
		if (Time.frameCount % 120 == 0 && EventSystem.current != null && EventSystem.current.gameObject != base.gameObject)
		{
			UnityEngine.Debug.LogError("CURVEDUI: Second EventSystem component detected. This can make UI unusable. Make sure there is only one EventSystem component on the scene. Click on this message to have the extra one selected.", EventSystem.current.gameObject);
		}
	}

	protected void LateUpdate()
	{
		pressedLastFrame = pressedDown;
	}

	protected override void Start()
	{
		if (Application.isPlaying)
		{
			base.Start();
		}
	}

	public override void Process()
	{
		switch (controlMethod)
		{
		default:
			base.Process();
			break;
		case CUIControlMethod.GAZE:
			ProcessGaze();
			break;
		case CUIControlMethod.STEAMVR_LEGACY:
			ProcessViveControllers();
			break;
		case CUIControlMethod.STEAMVR_2:
			ProcessSteamVR2Controllers();
			break;
		case CUIControlMethod.OCULUSVR:
			ProcessOculusVRController();
			break;
		case CUIControlMethod.WORLD_MOUSE:
			if (Input.touchCount > 0)
			{
				worldSpaceMouseOnCanvasDelta = Input.GetTouch(0).deltaPosition * worldSpaceMouseSensitivity;
			}
			else
			{
				worldSpaceMouseOnCanvasDelta = new Vector2((Input.mousePosition - lastMouseOnScreenPos).x, (Input.mousePosition - lastMouseOnScreenPos).y) * worldSpaceMouseSensitivity;
				lastMouseOnScreenPos = Input.mousePosition;
			}
			lastWorldSpaceMouseOnCanvas = worldSpaceMouseInCanvasSpace;
			worldSpaceMouseInCanvasSpace += worldSpaceMouseOnCanvasDelta;
			base.Process();
			break;
		case CUIControlMethod.CUSTOM_RAY:
			ProcessCustomRayController();
			break;
		}
	}

	protected virtual void ProcessGaze()
	{
		bool flag = SendUpdateEventToSelectedObject();
		if (base.eventSystem.sendNavigationEvents)
		{
			if (!flag)
			{
				flag |= SendMoveEventToSelectedObject();
			}
			if (!flag)
			{
				SendSubmitEventToSelectedObject();
			}
		}
		ProcessMouseEvent();
	}

	protected virtual void ProcessCustomRayController()
	{
		base.Process();
	}

	protected override MouseState GetMousePointerEventData(int id)
	{
		MouseState mousePointerEventData = base.GetMousePointerEventData(id);
		if (ControlMethod != 0 && ControlMethod != CUIControlMethod.WORLD_MOUSE)
		{
			mousePointerEventData.SetButtonState(PointerEventData.InputButton.Left, CustomRayFramePressedState(), mousePointerEventData.GetButtonState(PointerEventData.InputButton.Left).eventData.buttonData);
		}
		return mousePointerEventData;
	}

	private PointerEventData.FramePressState CustomRayFramePressedState()
	{
		if (pressedDown && !pressedLastFrame)
		{
			return PointerEventData.FramePressState.Pressed;
		}
		if (!pressedDown && pressedLastFrame)
		{
			return PointerEventData.FramePressState.Released;
		}
		return PointerEventData.FramePressState.NotChanged;
	}

	protected virtual void ProcessViveControllers()
	{
	}

	protected virtual void ProcessOculusVRController()
	{
	}

	private void ProcessSteamVR2Controllers()
	{
	}

	private static T EnableInputModule<T>() where T : BaseInputModule
	{
		bool flag = true;
		EventSystem eventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		if (eventSystem == null)
		{
			UnityEngine.Debug.LogError("CurvedUI: Your EventSystem component is missing from the scene! Unity Canvas will not track interactions without it.");
			return null;
		}
		BaseInputModule[] components = eventSystem.GetComponents<BaseInputModule>();
		foreach (BaseInputModule baseInputModule in components)
		{
			if (baseInputModule is T)
			{
				flag = false;
				baseInputModule.enabled = true;
			}
			else if (disableOtherInputModulesOnStart)
			{
				baseInputModule.enabled = false;
			}
		}
		if (flag)
		{
			eventSystem.gameObject.AddComponent<T>();
		}
		return eventSystem.GetComponent<T>();
	}
}
public class CameraControl : MonoBehaviour
{
	public float Speed = 10f;

	public int MouseSensitivity = 100;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.KeypadMultiply))
		{
			Vector3 vector = base.transform.position + base.transform.forward * 20f;
			base.transform.RotateAround(vector, Vector3.up, Time.deltaTime * Speed);
			base.transform.LookAt(vector);
		}
		if (Input.GetKey(KeyCode.KeypadDivide))
		{
			Vector3 vector2 = base.transform.position + base.transform.forward * 20f;
			base.transform.RotateAround(vector2, Vector3.up, 0f - Time.deltaTime * Speed);
			base.transform.LookAt(vector2);
		}
		if (Input.GetKey(KeyCode.KeypadPlus))
		{
			base.transform.position += base.transform.up * Speed * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode.KeypadMinus))
		{
			base.transform.position -= base.transform.up * Speed * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode.Minus))
		{
			GetComponent<Camera>().fieldOfView += 1f;
		}
		if (Input.GetKey(KeyCode.Equals))
		{
			GetComponent<Camera>().fieldOfView -= 1f;
		}
		if (Input.GetKey(KeyCode.UpArrow) || Input.GetKey(KeyCode.W) || Input.GetMouseButton(0))
		{
			base.transform.position += base.transform.forward * Speed * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode.DownArrow) || Input.GetKey(KeyCode.S) || Input.GetMouseButton(1))
		{
			base.transform.position -= base.transform.forward * Speed * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode.RightArrow) || Input.GetKey(KeyCode.D))
		{
			base.transform.position += base.transform.right * Speed * Time.deltaTime;
		}
		if (Input.GetKey(KeyCode.LeftArrow) || Input.GetKey(KeyCode.A))
		{
			base.transform.position -= base.transform.right * Speed * Time.deltaTime;
		}
		base.transform.localEulerAngles += new Vector3(Input.GetAxis("Mouse Y") * (float)MouseSensitivity * Time.deltaTime, Input.GetAxis("Mouse X") * (float)MouseSensitivity * Time.deltaTime, 0f);
		Speed += Input.GetAxis("Mouse ScrollWheel") * 10f;
	}
}
public class MouseLook : MonoBehaviour
{
	private Vector2 _mouseAbsolute;

	private Vector2 _smoothMouse;

	[Space(20f)]
	[Header("Mouse Look Settings :")]
	public Vector2 clampInDegrees = new Vector2(360f, 180f);

	public CursorLockMode lockCursor;

	public Vector2 sensitivity = new Vector2(2f, 2f);

	public Vector2 smoothing = new Vector2(3f, 3f);

	public Vector2 targetDirection;

	public Vector2 targetCharacterDirection;

	public GameObject characterBody;

	[Space(20f)]
	[Header("Camera Move Settings :")]
	public float acceleration = 1f;

	public float maxSpeed = 5f;

	public float dampingSpeed = 0.2f;

	public KeyCode fwdKey = KeyCode.W;

	public KeyCode leftKey = KeyCode.A;

	public KeyCode backKey = KeyCode.S;

	public KeyCode rightKey = KeyCode.D;

	private float speedX;

	private float speedZ;

	private void Start()
	{
		targetDirection = base.transform.localRotation.eulerAngles;
		if ((bool)characterBody)
		{
			targetCharacterDirection = characterBody.transform.localRotation.eulerAngles;
		}
	}

	private void Update()
	{
		Cursor.lockState = lockCursor;
		Quaternion quaternion = Quaternion.Euler(targetDirection);
		Quaternion quaternion2 = Quaternion.Euler(targetCharacterDirection);
		Vector2 a = new Vector2(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"));
		a = Vector2.Scale(a, new Vector2(sensitivity.x * smoothing.x, sensitivity.y * smoothing.y));
		_smoothMouse.x = Mathf.Lerp(_smoothMouse.x, a.x, 1f / smoothing.x);
		_smoothMouse.y = Mathf.Lerp(_smoothMouse.y, a.y, 1f / smoothing.y);
		_mouseAbsolute += _smoothMouse;
		if (clampInDegrees.x < 360f)
		{
			_mouseAbsolute.x = Mathf.Clamp(_mouseAbsolute.x, (0f - clampInDegrees.x) * 0.5f, clampInDegrees.x * 0.5f);
		}
		Quaternion localRotation = Quaternion.AngleAxis(0f - _mouseAbsolute.y, quaternion * Vector3.right);
		base.transform.localRotation = localRotation;
		if (clampInDegrees.y < 360f)
		{
			_mouseAbsolute.y = Mathf.Clamp(_mouseAbsolute.y, (0f - clampInDegrees.y) * 0.5f, clampInDegrees.y * 0.5f);
		}
		base.transform.localRotation *= quaternion;
		if ((bool)characterBody)
		{
			Quaternion localRotation2 = Quaternion.AngleAxis(_mouseAbsolute.x, characterBody.transform.up);
			characterBody.transform.localRotation = localRotation2;
			characterBody.transform.localRotation *= quaternion2;
		}
		else
		{
			Quaternion quaternion3 = Quaternion.AngleAxis(_mouseAbsolute.x, base.transform.InverseTransformDirection(Vector3.up));
			base.transform.localRotation *= quaternion3;
		}
	}

	private void FixedUpdate()
	{
		if (Input.GetKey(rightKey))
		{
			speedX += acceleration * Time.deltaTime;
		}
		else if (Input.GetKey(leftKey))
		{
			speedX -= acceleration * Time.deltaTime;
		}
		if (Input.GetKey(backKey))
		{
			speedZ -= acceleration * Time.deltaTime;
		}
		else if (Input.GetKey(fwdKey))
		{
			speedZ += acceleration * Time.deltaTime;
		}
		speedX = Mathf.Lerp(speedX, 0f, dampingSpeed * Time.deltaTime);
		speedZ = Mathf.Lerp(speedZ, 0f, dampingSpeed * Time.deltaTime);
		speedX = Mathf.Clamp(speedX, (0f - maxSpeed) * Time.deltaTime, maxSpeed * Time.deltaTime);
		speedZ = Mathf.Clamp(speedZ, (0f - maxSpeed) * Time.deltaTime, maxSpeed * Time.deltaTime);
		base.transform.position = base.transform.TransformPoint(new Vector3(speedX, 0f, speedZ));
	}
}
public class PlayerMove : MonoBehaviour
{
	[SerializeField]
	public float sensitivity = 5f;

	[SerializeField]
	public float smoothing = 2f;

	public Transform cam;

	private Vector2 mouseLook;

	private Vector2 smoothV;

	public float walkSpeed = 10f;

	public float runSpeed = 20f;

	public float strafingSpeed = 10f;

	private float movementSpeed;

	private CharacterController charController;

	private void Awake()
	{
		charController = GetComponent<CharacterController>();
		if (!cam)
		{
			cam = base.transform.Find("Camera");
		}
		Cursor.visible = false;
	}

	private void Update()
	{
		CameraMovement();
		PlayerMovement();
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Cursor.visible = true;
		}
	}

	private void CameraMovement()
	{
		Vector2 a = new Vector2(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"));
		a = Vector2.Scale(a, new Vector2(sensitivity * smoothing, sensitivity * smoothing));
		smoothV.x = Mathf.Lerp(smoothV.x, a.x, 1f / smoothing);
		smoothV.y = Mathf.Lerp(smoothV.y, a.y, 1f / smoothing);
		mouseLook += smoothV;
		cam.localRotation = Quaternion.AngleAxis(Mathf.Clamp(0f - mouseLook.y, -70f, 70f), Vector3.right);
		base.transform.localRotation = Quaternion.AngleAxis(mouseLook.x, base.transform.up);
	}

	private void PlayerMovement()
	{
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		if (Input.GetKey(KeyCode.LeftShift))
		{
			base.transform.Translate(axis * runSpeed * Time.deltaTime, 0f, axis2 * strafingSpeed * Time.deltaTime);
		}
		else
		{
			base.transform.Translate(axis * walkSpeed * Time.deltaTime, 0f, axis2 * strafingSpeed * Time.deltaTime);
		}
	}
}
public class CityGenerator : MonoBehaviour
{
	private int nB;

	private Vector3 center;

	private int residential;

	private bool _residential;

	private GameObject cityMaker;

	[HideInInspector]
	public GameObject miniBorder;

	[HideInInspector]
	public GameObject smallBorder;

	[HideInInspector]
	public GameObject largeBorder;

	[HideInInspector]
	public GameObject mediumBorder;

	[HideInInspector]
	public GameObject[] largeBlocks;

	private bool[] _largeBlocks;

	public GameObject[] BB;

	public GameObject[] BC;

	public GameObject[] BR;

	public GameObject[] DC;

	public GameObject[] EB;

	public GameObject[] EC;

	public GameObject[] MB;

	public GameObject[] BK;

	public GameObject[] SB;

	private int[] _BB;

	private int[] _BC;

	private int[] _BR;

	private int[] _EB;

	private int[] _EC;

	private int[] _MB;

	private int[] _BK;

	private int[] _SB;

	private GameObject[] tempArray;

	private int numB;

	public int distCenter = 300;

	private GameObject pB;

	public void GenerateStreetsVerySmall()
	{
		if (!cityMaker)
		{
			cityMaker = GameObject.Find("City-Maker");
		}
		if ((bool)cityMaker)
		{
			UnityEngine.Object.DestroyImmediate(cityMaker);
		}
		cityMaker = new GameObject("City-Maker");
		distCenter = 200;
		int num = 0;
		int maxExclusive = largeBlocks.Length;
		num = UnityEngine.Random.Range(0, maxExclusive);
		UnityEngine.Object.Instantiate(largeBlocks[num], new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 0f, 0f), cityMaker.transform);
		center = new Vector3(0f, 0f, 0f);
		UnityEngine.Object.Instantiate(miniBorder, new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 0f, 0f), cityMaker.transform).transform.SetParent(cityMaker.transform);
	}

	public void GenerateStreetsSmall()
	{
		if (!cityMaker)
		{
			cityMaker = GameObject.Find("City-Maker");
		}
		if ((bool)cityMaker)
		{
			UnityEngine.Object.DestroyImmediate(cityMaker);
		}
		cityMaker = new GameObject("City-Maker");
		distCenter = 350;
		int num = 0;
		int maxExclusive = largeBlocks.Length;
		_largeBlocks = new bool[largeBlocks.Length];
		Vector3[] array = new Vector3[3];
		int[] array2 = new int[3];
		if (UnityEngine.Random.Range(0f, 6f) < 3f)
		{
			array[1] = new Vector3(0f, 0f, 0f);
			array2[1] = 0;
			array[2] = new Vector3(0f, 0f, 300f);
			array2[2] = 0;
		}
		else
		{
			array[1] = new Vector3(-150f, 0f, 150f);
			array2[1] = 90;
			array[2] = new Vector3(150f, 0f, 150f);
			array2[2] = 90;
		}
		for (int i = 1; i < 3; i++)
		{
			for (int j = 0; j < 100; j++)
			{
				num = UnityEngine.Random.Range(0, maxExclusive);
				if (!_largeBlocks[num])
				{
					break;
				}
			}
			_largeBlocks[num] = true;
			UnityEngine.Object.Instantiate(largeBlocks[num], array[i], Quaternion.Euler(0f, array2[i], 0f), cityMaker.transform);
		}
		center = array[UnityEngine.Random.Range(1, 2)];
		UnityEngine.Object.Instantiate(smallBorder, new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 0f, 0f), cityMaker.transform).transform.SetParent(cityMaker.transform);
	}

	public void GenerateStreets()
	{
		if (!cityMaker)
		{
			cityMaker = GameObject.Find("City-Maker");
		}
		if ((bool)cityMaker)
		{
			UnityEngine.Object.DestroyImmediate(cityMaker);
		}
		cityMaker = new GameObject("City-Maker");
		distCenter = 350;
		int num = 0;
		int maxExclusive = largeBlocks.Length;
		_largeBlocks = new bool[largeBlocks.Length];
		Vector3[] array = new Vector3[5];
		int[] array2 = new int[5];
		float num2 = UnityEngine.Random.Range(0f, 6f);
		if (num2 < 2f)
		{
			array[1] = new Vector3(0f, 0f, 0f);
			array2[1] = 0;
			array[2] = new Vector3(0f, 0f, 300f);
			array2[2] = 0;
			array[3] = new Vector3(450f, 0f, 150f);
			array2[3] = 90;
			array[4] = new Vector3(-450f, 0f, 150f);
			array2[4] = 90;
		}
		else if (num2 < 3f)
		{
			array[1] = new Vector3(-450f, 0f, 150f);
			array2[1] = 90;
			array[2] = new Vector3(-150f, 0f, 150f);
			array2[2] = 90;
			array[3] = new Vector3(150f, 0f, 150f);
			array2[3] = 90;
			array[4] = new Vector3(450f, 0f, 150f);
			array2[4] = 90;
		}
		else if (num2 < 4f)
		{
			array[1] = new Vector3(-450f, 0f, 150f);
			array2[1] = 90;
			array[2] = new Vector3(-150f, 0f, 150f);
			array2[2] = 90;
			array[3] = new Vector3(300f, 0f, 0f);
			array2[3] = 0;
			array[4] = new Vector3(300f, 0f, 300f);
			array2[4] = 0;
		}
		else
		{
			array[1] = new Vector3(450f, 0f, 150f);
			array2[1] = 90;
			array[2] = new Vector3(150f, 0f, 150f);
			array2[2] = 90;
			array[3] = new Vector3(-300f, 0f, 0f);
			array2[3] = 0;
			array[4] = new Vector3(-300f, 0f, 300f);
			array2[4] = 0;
		}
		for (int i = 1; i < 5; i++)
		{
			for (int j = 0; j < 100; j++)
			{
				num = UnityEngine.Random.Range(0, maxExclusive);
				if (!_largeBlocks[num])
				{
					break;
				}
			}
			_largeBlocks[num] = true;
			UnityEngine.Object.Instantiate(largeBlocks[num], array[i], Quaternion.Euler(0f, array2[i], 0f), cityMaker.transform);
		}
		center = array[UnityEngine.Random.Range(1, 4)];
		UnityEngine.Object.Instantiate(mediumBorder, new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 0f, 0f), cityMaker.transform).transform.SetParent(cityMaker.transform);
	}

	public void GenerateStreetsBig()
	{
		if (!cityMaker)
		{
			cityMaker = GameObject.Find("City-Maker");
		}
		if ((bool)cityMaker)
		{
			UnityEngine.Object.DestroyImmediate(cityMaker);
		}
		cityMaker = new GameObject("City-Maker");
		distCenter = 350;
		int num = 0;
		int maxExclusive = largeBlocks.Length;
		_largeBlocks = new bool[largeBlocks.Length];
		Vector3[] array = new Vector3[7];
		int[] array2 = new int[7];
		float num2 = UnityEngine.Random.Range(0f, 6f);
		if (num2 < 3f)
		{
			array[1] = new Vector3(0f, 0f, 0f);
			array2[1] = 0;
			array[2] = new Vector3(0f, 0f, 300f);
			array2[2] = 0;
			array[3] = new Vector3(450f, 0f, 150f);
			array2[3] = 90;
			array[4] = new Vector3(-450f, 0f, 150f);
			array2[4] = 90;
			array[5] = new Vector3(-300f, 0f, 600f);
			array2[5] = 0;
			array[6] = new Vector3(300f, 0f, 600f);
			array2[6] = 0;
		}
		else if (num2 < 3f)
		{
			array[1] = new Vector3(-450f, 0f, 150f);
			array2[1] = 90;
			array[2] = new Vector3(-150f, 0f, 150f);
			array2[2] = 90;
			array[3] = new Vector3(150f, 0f, 150f);
			array2[3] = 90;
			array[4] = new Vector3(450f, 0f, 150f);
			array2[4] = 90;
			array[5] = new Vector3(-300f, 0f, 600f);
			array2[5] = 0;
			array[6] = new Vector3(300f, 0f, 600f);
			array2[6] = 0;
		}
		else if (num2 < 4f)
		{
			array[1] = new Vector3(-300f, 0f, 300f);
			array2[1] = 0;
			array[2] = new Vector3(-300f, 0f, 0f);
			array2[2] = 0;
			array[3] = new Vector3(150f, 0f, 150f);
			array2[3] = 90;
			array[4] = new Vector3(450f, 0f, 150f);
			array2[4] = 90;
			array[5] = new Vector3(-300f, 0f, 600f);
			array2[5] = 0;
			array[6] = new Vector3(300f, 0f, 600f);
			array2[6] = 0;
		}
		else
		{
			array[1] = new Vector3(-450f, 0f, 150f);
			array2[1] = 90;
			array[2] = new Vector3(300f, 0f, 0f);
			array2[2] = 0;
			array[3] = new Vector3(-150f, 0f, 150f);
			array2[3] = 90;
			array[4] = new Vector3(450f, 0f, 450f);
			array2[4] = 90;
			array[5] = new Vector3(-300f, 0f, 600f);
			array2[5] = 0;
			array[6] = new Vector3(150f, 0f, 450f);
			array2[6] = 90;
		}
		for (int i = 1; i < 7; i++)
		{
			for (int j = 0; j < 100; j++)
			{
				num = UnityEngine.Random.Range(0, maxExclusive);
				if (!_largeBlocks[num])
				{
					break;
				}
			}
			_largeBlocks[num] = true;
			UnityEngine.Object.Instantiate(largeBlocks[num], array[i], Quaternion.Euler(0f, array2[i], 0f), cityMaker.transform);
		}
		center = array[UnityEngine.Random.Range(1, 6)];
		UnityEngine.Object.Instantiate(largeBorder, new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 0f, 0f), cityMaker.transform).transform.SetParent(cityMaker.transform);
	}

	public void GenerateAllBuildings()
	{
		_BB = new int[BB.Length];
		_BC = new int[BC.Length];
		_BR = new int[BR.Length];
		_EB = new int[EB.Length];
		_EC = new int[EC.Length];
		_MB = new int[MB.Length];
		_BK = new int[BK.Length];
		_SB = new int[SB.Length];
		residential = 0;
		DestroyBuildings();
		GameObject obj = new GameObject();
		nB = 0;
		CreateBuildingsInSuperBlocks();
		CreateBuildingsInBlocks();
		CreateBuildingsInLines();
		CreateBuildingsInDouble();
		UnityEngine.Debug.ClearDeveloperConsole();
		UnityEngine.Debug.Log(nB + " buildings were created");
		UnityEngine.Object.DestroyImmediate(obj);
	}

	public void CreateBuildingsInLines()
	{
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "Marcador"
			select g).ToArray();
		GameObject[] array = tempArray;
		foreach (GameObject gameObject in array)
		{
			_residential = residential < 15 && Vector3.Distance(center, gameObject.transform.position) > 400f && UnityEngine.Random.Range(0, 100) < 30;
			foreach (Transform item in gameObject.transform)
			{
				if (item.name == "E")
				{
					CreateBuildingsInCorners(item.gameObject);
				}
				else
				{
					CreateBuildingsInLine(item.gameObject, 90f);
				}
			}
			_residential = false;
		}
	}

	public void CreateBuildingsInCorners(GameObject child)
	{
		pB = null;
		int num = 0;
		int num2 = 0;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = Vector3.Distance(center, child.transform.position);
		int num6 = 0;
		while (num2 < 100)
		{
			num2++;
			if (num5 < (float)distCenter)
			{
				do
				{
					num6++;
					num = UnityEngine.Random.Range(0, EC.Length);
				}
				while (_EC[num] != 0 && (num6 <= 100 || _EC[num] > 1) && (num6 <= 150 || _EC[num] > 2) && (num6 <= 200 || _EC[num] > 3) && num6 <= 250 && num6 < 300);
				num3 = GetWith(EC[num]);
				if (num3 <= 36.05f)
				{
					_EC[num]++;
					pB = EC[num];
					break;
				}
			}
			else
			{
				do
				{
					num6++;
					num = UnityEngine.Random.Range(0, EB.Length);
				}
				while (_EB[num] != 0 && (num6 <= 100 || _EB[num] > 1) && (num6 <= 150 || _EB[num] > 2) && (num6 <= 200 || _EB[num] > 2) && num6 <= 250 && num6 < 300);
				num3 = GetWith(EB[num]);
				if (num3 <= 36.05f)
				{
					_EB[num]++;
					pB = EB[num];
					break;
				}
			}
		}
		GameObject gameObject = UnityEngine.Object.Instantiate(pB, new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 0f, 0f));
		gameObject.name = gameObject.name;
		gameObject.transform.SetParent(child.transform);
		gameObject.transform.localPosition = new Vector3(0f - num3 * 0.5f, 0f, 0f);
		gameObject.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
		nB++;
		num4 = GetHeight(pB);
		if (num4 < 29.9f)
		{
			GameObject gameObject2 = new GameObject("Marcador");
			gameObject2.transform.SetParent(child.transform);
			gameObject2.transform.localPosition = new Vector3(0f, 0f, -36f);
			gameObject2.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
			gameObject2.name = (36f - num4).ToString();
			CreateBuildingsInLine(gameObject2, 90f);
		}
		else
		{
			float num7 = 36f - num4;
			float z = 1f + num7 / num4;
			gameObject.transform.localScale = new Vector3(1f, 1f, z);
		}
		if (num3 < 29.9f)
		{
			GameObject gameObject2 = new GameObject("Marcador");
			gameObject2.transform.SetParent(child.transform);
			gameObject2.transform.localPosition = new Vector3(0f - num3, 0f, 0f);
			gameObject2.transform.localRotation = Quaternion.Euler(0f, 270f, 0f);
			gameObject2.name = (36f - num3).ToString();
			CreateBuildingsInLine(gameObject2, 90f);
		}
		else
		{
			float num7 = 36f - num3;
			float z = 1f + num7 / num3;
			gameObject.transform.localScale = new Vector3(z, 1f, 1f);
		}
	}

	private int RandRotation()
	{
		int num = 0;
		return UnityEngine.Random.Range(0, 4) switch
		{
			3 => 180, 
			2 => 90, 
			1 => 270, 
			_ => 0, 
		};
	}

	public void CreateBuildingsInBlocks()
	{
		int num = 0;
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "Blocks"
			select g).ToArray();
		GameObject[] array = tempArray;
		for (int i = 0; i < array.Length; i++)
		{
			foreach (Transform item in array[i].transform)
			{
				if (UnityEngine.Random.Range(0, 20) > 5)
				{
					int num2 = 0;
					do
					{
						num2++;
						num = UnityEngine.Random.Range(0, BK.Length);
					}
					while (_BK[num] != 0 && (num2 <= 125 || _BK[num] > 1) && (num2 <= 150 || _BK[num] > 2) && (num2 <= 200 || _BK[num] > 3) && num2 <= 250 && num2 < 300);
					_BK[num]++;
					UnityEngine.Object.Instantiate(BK[num], item.position, item.rotation, item);
					nB++;
					continue;
				}
				for (int j = 1; j <= 4; j++)
				{
					GameObject gameObject = new GameObject("E");
					gameObject.transform.SetParent(item);
					if (j == 1)
					{
						gameObject.transform.localPosition = new Vector3(-36f, 0f, -36f);
						gameObject.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
					}
					if (j == 2)
					{
						gameObject.transform.localPosition = new Vector3(-36f, 0f, 36f);
						gameObject.transform.localRotation = Quaternion.Euler(0f, 270f, 0f);
					}
					if (j == 3)
					{
						gameObject.transform.localPosition = new Vector3(36f, 0f, 36f);
						gameObject.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
					}
					if (j == 4)
					{
						gameObject.transform.localPosition = new Vector3(36f, 0f, -36f);
						gameObject.transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
					}
					CreateBuildingsInCorners(gameObject);
				}
			}
		}
	}

	public void CreateBuildingsInSuperBlocks()
	{
		int num = 0;
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "SuperBlocks"
			select g).ToArray();
		GameObject[] array = tempArray;
		for (int i = 0; i < array.Length; i++)
		{
			foreach (Transform item in array[i].transform)
			{
				int num2 = 0;
				do
				{
					num2++;
					num = UnityEngine.Random.Range(0, SB.Length);
				}
				while (_SB[num] != 0 && (num2 <= 125 || _SB[num] > 1) && (num2 <= 150 || _SB[num] > 2) && (num2 <= 200 || _SB[num] > 3) && num2 <= 250 && num2 < 300);
				_SB[num]++;
				UnityEngine.Object.Instantiate(SB[num], item.position, item.rotation, item);
				nB++;
			}
		}
	}

	private void CreateBuildingsInLine(GameObject line, float angulo)
	{
		int num = -1;
		GameObject[] array = new GameObject[50];
		float num2 = ((!line.name.Contains(".")) ? float.Parse(line.name) : (float.Parse(line.name.Split('.')[0]) + float.Parse(line.name.Split('.')[1]) / float.Parse("1" + "0000000".Substring(0, line.name.Split('.')[1].Length))));
		float num3 = 0f;
		float num4 = 0f;
		int num5 = 0;
		int num6 = 0;
		float num7 = Vector3.Distance(center, line.transform.position);
		while (num5 < 100)
		{
			num5++;
			num6 = 0;
			int num8 = 0;
			while (num6 < 200 && num3 <= num2 - 4f)
			{
				num6++;
				if (num7 < (float)distCenter)
				{
					do
					{
						num8++;
						numB = UnityEngine.Random.Range(0, BC.Length);
					}
					while (_BC[numB] != 0 && (num8 <= 125 || _BC[numB] > 1) && (num8 <= 150 || _BC[numB] > 2) && (num8 <= 200 || _BC[numB] > 3) && num8 <= 250 && num8 < 300);
					num4 = GetWith(BC[numB]);
					if (num3 + num4 <= num2 + 4f)
					{
						pB = BC[numB];
						_BC[numB]++;
						_ = _BC[numB];
						break;
					}
				}
				else if (_residential)
				{
					do
					{
						num8++;
						numB = UnityEngine.Random.Range(0, BR.Length);
					}
					while (_BR[numB] != 0 && (num8 <= 100 || _BR[numB] > 1) && (num8 <= 150 || _BR[numB] > 2) && (num8 <= 200 || _BR[numB] > 3) && num8 <= 250 && num8 < 300);
					num4 = GetWith(BR[numB]);
					if (num3 + num4 <= num2 + 4f)
					{
						pB = BR[numB];
						_BR[numB]++;
						_ = _BR[numB];
						residential++;
						break;
					}
				}
				else
				{
					do
					{
						num8++;
						numB = UnityEngine.Random.Range(0, BB.Length);
					}
					while (_BB[numB] != 0 && (num8 <= 100 || _BB[numB] > 1) && (num8 <= 150 || _BB[numB] > 2) && (num8 <= 200 || _BB[numB] > 3) && num8 <= 250 && num8 < 300);
					num4 = GetWith(BB[numB]);
					if (num3 + num4 <= num2 + 4f)
					{
						pB = BB[numB];
						_BB[numB]++;
						_ = _BB[numB];
						break;
					}
				}
			}
			if (num6 >= 200 || num3 > num2 - 4f)
			{
				AjustaLargura(array, num + 1, num2 - num3, 0f);
				break;
			}
			num++;
			array[num] = UnityEngine.Object.Instantiate(pB, new Vector3(0f, 0f, num3 + num4 * 0.5f), Quaternion.Euler(0f, angulo, 0f));
			nB++;
			array[num].name = array[num].name;
			array[num].transform.SetParent(line.transform);
			array[num].transform.localPosition = new Vector3(0f, 0f, num3 + num4 * 0.5f);
			array[num].transform.localRotation = Quaternion.Euler(0f, angulo, 0f);
			num3 += num4;
			if (num3 > num2 - 6f)
			{
				AjustaLargura(array, num + 1, num2 - num3, 0f);
			}
		}
	}

	private void CreateBuildingsInDoubleLine(GameObject line)
	{
		int num = -1;
		GameObject[] array = new GameObject[20];
		float num2 = float.Parse(line.name);
		float num3 = 0f;
		float num4 = 0f;
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		while (num5 < 100)
		{
			num5++;
			num6 = 0;
			num7 = 0;
			while (num6 < 200 && num3 <= num2 - 4f)
			{
				num6++;
				do
				{
					num7++;
					numB = UnityEngine.Random.Range(0, MB.Length);
				}
				while (_MB[numB] != 0 && (num7 <= 100 || _MB[numB] > 1) && (num7 <= 150 || _MB[numB] > 2) && num7 <= 200 && num7 < 300);
				num4 = GetWith(MB[numB]);
				if (num3 + num4 <= num2 + 4f)
				{
					_MB[numB]++;
					break;
				}
			}
			if (num6 >= 200 || num3 > num2 - 4f)
			{
				AjustaLargura(array, num + 1, num2 - num3, 0f);
				break;
			}
			num++;
			array[num] = UnityEngine.Object.Instantiate(MB[numB], new Vector3(0f, 0f, 0f), Quaternion.Euler(0f, 90f, 0f), line.transform);
			nB++;
			array[num].name = "building";
			array[num].transform.SetParent(line.transform);
			array[num].transform.localPosition = new Vector3(0f, 0f, num3 + num4 * 0.5f);
			array[num].transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
			num3 += num4;
			if (num3 > num2 - 6f)
			{
				AjustaLargura(array, num + 1, num2 - num3, 0f);
			}
		}
	}

	private void CreateBuildingsInDouble()
	{
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "Double"
			select g).ToArray();
		GameObject[] array = tempArray;
		for (int i = 0; i < array.Length; i++)
		{
			foreach (Transform item in array[i].transform)
			{
				float num = float.Parse(item.name);
				if (UnityEngine.Random.Range(0, 10) < 5)
				{
					float height;
					do
					{
						numB = UnityEngine.Random.Range(0, DC.Length);
						height = GetHeight(DC[numB]);
					}
					while (height > num / 2f);
					UnityEngine.Object.Instantiate(DC[numB], item.transform.position, item.transform.rotation, item.transform);
					nB++;
					float height2;
					do
					{
						numB = UnityEngine.Random.Range(0, DC.Length);
						height2 = GetHeight(DC[numB]);
					}
					while (height2 > num - (height + 26f));
					GameObject obj = UnityEngine.Object.Instantiate(DC[numB], item.transform.position, item.rotation, item.transform);
					obj.transform.SetParent(item.transform);
					obj.transform.localPosition = new Vector3(0f, 0f, 0f - num);
					obj.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
					GameObject gameObject = new GameObject((num - height - height2).ToString() ?? "");
					gameObject.transform.SetParent(item.transform);
					gameObject.transform.localPosition = new Vector3(0f, 0f, 0f - (num - height2));
					gameObject.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
					gameObject.name = (num - height - height2).ToString() ?? "";
					CreateBuildingsInDoubleLine(gameObject);
					continue;
				}
				GameObject gameObject2 = new GameObject("Marcador");
				gameObject2.transform.SetParent(item);
				gameObject2.transform.localPosition = new Vector3(0f, 0f, 0f);
				gameObject2.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
				GameObject gameObject3;
				for (int j = 1; j <= 4; j++)
				{
					gameObject3 = new GameObject("E");
					gameObject3.transform.SetParent(gameObject2.transform);
					if (j == 1)
					{
						gameObject3.transform.localPosition = new Vector3(36f, 0f, 0f - num);
						gameObject3.transform.localRotation = Quaternion.Euler(0f, 90f, 0f);
					}
					if (j == 2)
					{
						gameObject3.transform.localPosition = new Vector3(36f, 0f, 0f);
						gameObject3.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
					}
					if (j == 3)
					{
						gameObject3.transform.localPosition = new Vector3(-36f, 0f, 0f);
						gameObject3.transform.localRotation = Quaternion.Euler(0f, 270f, 0f);
					}
					if (j == 4)
					{
						gameObject3.transform.localPosition = new Vector3(-36f, 0f, 0f - num);
						gameObject3.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
					}
					CreateBuildingsInCorners(gameObject3);
				}
				gameObject3 = new GameObject((num - 72f).ToString() ?? "");
				gameObject3.transform.SetParent(gameObject2.transform);
				gameObject3.transform.localPosition = new Vector3(-36f, 0.001f, -36f);
				gameObject3.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
				CreateBuildingsInLine(gameObject3, 90f);
				gameObject3 = new GameObject((num - 72f).ToString() ?? "");
				gameObject3.transform.SetParent(gameObject2.transform);
				gameObject3.transform.localPosition = new Vector3(36f, 0.001f, 0f - (num - 36f));
				gameObject3.transform.localRotation = Quaternion.Euler(0f, 0f, 0f);
				CreateBuildingsInLine(gameObject3, 90f);
			}
		}
	}

	private void AjustaLargura(GameObject[] predios, int quantos, float metrosRestantes, float init)
	{
		if (metrosRestantes != 0f)
		{
			float num = metrosRestantes / (float)quantos;
			float num2 = init;
			float num3 = 0f;
			for (int i = 0; i < quantos; i++)
			{
				float x = 1f + num / GetWith(predios[i]);
				num3 = GetWith(predios[i]) + num;
				predios[i].transform.localPosition = new Vector3(predios[i].transform.localPosition.x, predios[i].transform.localPosition.y, num2 + num3 * 0.5f);
				predios[i].transform.localScale = new Vector3(x, 1f, 1f);
				num2 += num3;
			}
		}
	}

	private float GetWith(GameObject building)
	{
		if (building.transform.GetComponent<MeshFilter>() != null)
		{
			return building.transform.GetComponent<MeshFilter>().sharedMesh.bounds.size.x;
		}
		return building.GetComponent<MeshSize>().meshFilter.sharedMesh.bounds.size.x;
	}

	private float GetHeight(GameObject building)
	{
		if (building.GetComponent<MeshFilter>() != null)
		{
			return building.GetComponent<MeshFilter>().sharedMesh.bounds.size.z;
		}
		return building.GetComponent<MeshSize>().meshFilter.sharedMesh.bounds.size.z;
	}

	public void DestroyBuildings()
	{
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "Marcador"
			select g).ToArray();
		for (int i = 1; i < 8; i++)
		{
			GameObject[] array = tempArray;
			for (int j = 0; j < array.Length; j++)
			{
				foreach (Transform item in array[j].transform)
				{
					DestryObjetcs2(item.gameObject, "All");
				}
			}
		}
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "Blocks"
			select g).ToArray();
		for (int k = 1; k < 8; k++)
		{
			GameObject[] array = tempArray;
			for (int j = 0; j < array.Length; j++)
			{
				foreach (Transform item2 in array[j].transform)
				{
					DestryObjetcs2(item2.gameObject, "All");
				}
			}
		}
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "SuperBlocks"
			select g).ToArray();
		for (int l = 1; l < 8; l++)
		{
			GameObject[] array = tempArray;
			for (int j = 0; j < array.Length; j++)
			{
				foreach (Transform item3 in array[j].transform)
				{
					DestryObjetcs2(item3.gameObject, "All");
				}
			}
		}
		tempArray = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name == "Double"
			select g).ToArray();
		for (int m = 1; m < 8; m++)
		{
			GameObject[] array = tempArray;
			for (int j = 0; j < array.Length; j++)
			{
				foreach (Transform item4 in array[j].transform)
				{
					DestryObjetcs2(item4.gameObject, "All");
				}
			}
		}
	}

	private void DestryObjetcs2(GameObject line, string nameObj)
	{
		foreach (Transform item in line.transform)
		{
			if (nameObj == "All")
			{
				UnityEngine.Object.DestroyImmediate(item.gameObject);
			}
			else if (item.name == nameObj)
			{
				UnityEngine.Object.DestroyImmediate(item.gameObject);
			}
		}
	}
}
public class FreeflightCamera : MonoBehaviour
{
	public float speedNormal = 10f;

	public float speedFast = 50f;

	public float mouseSensitivityX = 5f;

	public float mouseSensitivityY = 5f;

	private float rotY;

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void Update()
	{
		if (Input.GetMouseButton(1))
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * mouseSensitivityX;
			rotY += Input.GetAxis("Mouse Y") * mouseSensitivityY;
			rotY = Mathf.Clamp(rotY, -89.5f, 89.5f);
			base.transform.localEulerAngles = new Vector3(0f - rotY, y, 0f);
		}
		float axis = Input.GetAxis("Vertical");
		float axis2 = Input.GetAxis("Horizontal");
		if (axis != 0f)
		{
			float num = (Input.GetKey(KeyCode.LeftShift) ? speedFast : speedNormal);
			Vector3 vector = new Vector3(0f, 0f, axis * num * Time.deltaTime);
			base.gameObject.transform.localPosition += base.gameObject.transform.localRotation * vector;
		}
		if (axis2 != 0f)
		{
			float num2 = (Input.GetKey(KeyCode.LeftShift) ? speedFast : speedNormal);
			Vector3 vector2 = new Vector3(axis2 * num2 * Time.deltaTime, 0f, 0f);
			base.gameObject.transform.localPosition += base.gameObject.transform.localRotation * vector2;
		}
	}
}
public class MeshSize : MonoBehaviour
{
	public MeshFilter meshFilter;
}
public class Mesh_CombineUtility
{
	public struct MeshInstance
	{
		public Mesh mesh;

		public int subMeshIndex;

		public Matrix4x4 transform;
	}

	public static Mesh Combine(MeshInstance[] combines, bool generateStrips)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		MeshInstance[] array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance = array[i];
			if (!meshInstance.mesh)
			{
				continue;
			}
			num += meshInstance.mesh.vertexCount;
			if (!generateStrips)
			{
				continue;
			}
			int num4 = meshInstance.mesh.GetTriangles(meshInstance.subMeshIndex).Length;
			if (num4 != 0)
			{
				if (num3 != 0)
				{
					num3 = (((num3 & 1) != 1) ? (num3 + 2) : (num3 + 3));
				}
				num3 += num4;
			}
			else
			{
				generateStrips = false;
			}
		}
		if (!generateStrips)
		{
			array = combines;
			for (int i = 0; i < array.Length; i++)
			{
				MeshInstance meshInstance2 = array[i];
				if ((bool)meshInstance2.mesh)
				{
					num2 += meshInstance2.mesh.GetTriangles(meshInstance2.subMeshIndex).Length;
				}
			}
		}
		Vector3[] array2 = new Vector3[num];
		Vector3[] array3 = new Vector3[num];
		Vector4[] array4 = new Vector4[num];
		Vector2[] array5 = new Vector2[num];
		Vector2[] array6 = new Vector2[num];
		Color[] array7 = new Color[num];
		int[] array8 = new int[num2];
		int[] array9 = new int[num3];
		int offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance3 = array[i];
			if ((bool)meshInstance3.mesh)
			{
				Copy(meshInstance3.mesh.vertexCount, meshInstance3.mesh.vertices, array2, ref offset, meshInstance3.transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance4 = array[i];
			if ((bool)meshInstance4.mesh)
			{
				Matrix4x4 transform = meshInstance4.transform;
				transform = transform.inverse.transpose;
				CopyNormal(meshInstance4.mesh.vertexCount, meshInstance4.mesh.normals, array3, ref offset, transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance5 = array[i];
			if ((bool)meshInstance5.mesh)
			{
				Matrix4x4 transform2 = meshInstance5.transform;
				transform2 = transform2.inverse.transpose;
				CopyTangents(meshInstance5.mesh.vertexCount, meshInstance5.mesh.tangents, array4, ref offset, transform2);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance6 = array[i];
			if ((bool)meshInstance6.mesh)
			{
				Copy(meshInstance6.mesh.vertexCount, meshInstance6.mesh.uv, array5, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance7 = array[i];
			if ((bool)meshInstance7.mesh)
			{
				Copy(meshInstance7.mesh.vertexCount, meshInstance7.mesh.uv2, array6, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance8 = array[i];
			if ((bool)meshInstance8.mesh)
			{
				CopyColors(meshInstance8.mesh.vertexCount, meshInstance8.mesh.colors, array7, ref offset);
			}
		}
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance9 = array[i];
			if (!meshInstance9.mesh)
			{
				continue;
			}
			if (generateStrips)
			{
				int[] triangles = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				if (num6 != 0)
				{
					if ((num6 & 1) == 1)
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						array9[num6 + 2] = triangles[0] + num7;
						num6 += 3;
					}
					else
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						num6 += 2;
					}
				}
				for (int j = 0; j < triangles.Length; j++)
				{
					array9[j + num6] = triangles[j] + num7;
				}
				num6 += triangles.Length;
			}
			else
			{
				int[] triangles2 = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				for (int k = 0; k < triangles2.Length; k++)
				{
					array8[k + num5] = triangles2[k] + num7;
				}
				num5 += triangles2.Length;
			}
			num7 += meshInstance9.mesh.vertexCount;
		}
		if (array2.Length > 65000)
		{
			return null;
		}
		Mesh mesh = new Mesh();
		mesh.name = "Combined Mesh";
		mesh.vertices = array2;
		mesh.normals = array3;
		mesh.colors = array7;
		mesh.uv = array5;
		mesh.uv2 = array6;
		mesh.tangents = array4;
		if (generateStrips)
		{
			mesh.SetTriangles(array9, 0);
		}
		else
		{
			mesh.triangles = array8;
		}
		return mesh;
	}

	private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyPoint(src[i]);
		}
		offset += vertexcount;
	}

	private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyVector(src[i]).normalized;
		}
		offset += vertexcount;
	}

	private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyColors(int vertexcount, Color[] src, Color[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			Vector4 vector = src[i];
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			vector2 = transform.MultiplyVector(vector2).normalized;
			dst[i + offset] = new Vector4(vector2.x, vector2.y, vector2.z, vector.w);
		}
		offset += vertexcount;
	}
}
public class Mouse_Orbit : MonoBehaviour
{
	public Transform target;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
		Invoke("SetTarget", 1f);
	}

	private void SetTarget()
	{
		GetComponent<Mouse_Orbit>().target = GameObject.Find("New Car(Clone)").transform;
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			if (Input.GetMouseButton(0))
			{
				GetComponent<Mouse_Orbit>().target = GameObject.Find("New Car(Clone)").transform;
			}
			if (Input.GetMouseButton(1))
			{
				x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
				y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				y = ClampAngle(y, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(y, x, 0f);
				Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
			}
			if (Input.GetAxis("Mouse ScrollWheel") > 0f)
			{
				distance += 1f;
			}
			else if (Input.GetAxis("Mouse ScrollWheel") < 0f)
			{
				distance -= 1f;
			}
		}
	}

	private float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class TrafficCar : MonoBehaviour
{
	[Serializable]
	public class CarWheelsTransform
	{
		public Transform frontRight;

		public Transform frontLeft;

		public Transform backRight;

		public Transform backLeft;

		public Transform backRight2;

		public Transform backLeft2;
	}

	[Serializable]
	public class CarSetting
	{
		public bool showNormalGizmos;

		[Range(10000f, 30000f)]
		public float springs = 25000f;

		[Range(1000f, 6000f)]
		public float dampers = 1500f;

		[Range(60f, 200f)]
		public float carPower = 120f;

		[Range(5f, 10f)]
		public float brakePower = 8f;

		public Vector3 shiftCentre = new Vector3(0f, -0.05f, 0f);

		public float LimitForwardSpeed = 30f;
	}

	private class WheelComponent
	{
		public Transform wheel;

		public WheelCollider collider;

		public float rotation;

		public float rotation2;
	}

	private float timeStoped;

	private GameObject atualWay;

	private int countWays;

	private Transform[] nodes;

	private int currentNode;

	private float distancia;

	private float steer;

	private float speed;

	private float brake;

	private Transform mRayL;

	private Transform mRayR;

	private Transform mRayL2;

	private Vector3 steerCurAngle;

	private Rigidbody myRigidbody;

	private float angulo;

	private GameObject bulsola;

	private FCGWaypointsContainer atualWayScript;

	private Vector3 relativeVector;

	public CarWheelsTransform wheelsTransforms;

	public CarSetting carSetting;

	private float maxSteerAngle = 60f;

	private WheelComponent[] wheels;

	public int accel = 10;

	private GameObject[] tf01;

	private RaycastHit hit;

	private int wdist = 6;

	private int f;

	private Transform GetTransformWheel(string wheelName)
	{
		GameObject[] array = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name.Equals(wheelName) && g.transform.parent.root == base.transform
			select g).ToArray();
		if (array.Length != 0)
		{
			return array[0].transform;
		}
		return null;
	}

	private void init2()
	{
		if (!wheelsTransforms.frontRight)
		{
			wheelsTransforms.frontRight = GetTransformWheel("FR");
		}
		if (!wheelsTransforms.frontLeft)
		{
			wheelsTransforms.frontLeft = GetTransformWheel("FL");
		}
		if (!wheelsTransforms.backRight)
		{
			wheelsTransforms.backRight = GetTransformWheel("BR");
		}
		if (!wheelsTransforms.backLeft)
		{
			wheelsTransforms.backLeft = GetTransformWheel("BL");
		}
		if (!wheelsTransforms.backRight2)
		{
			wheelsTransforms.backRight2 = base.transform.Find("BR2");
		}
		if (!wheelsTransforms.backLeft2)
		{
			wheelsTransforms.backLeft2 = base.transform.Find("BL2");
		}
		if (!wheelsTransforms.frontRight)
		{
			UnityEngine.Object.Destroy(base.transform.gameObject);
			return;
		}
		if (!wheelsTransforms.frontLeft)
		{
			UnityEngine.Object.Destroy(base.transform.gameObject);
			return;
		}
		if (!wheelsTransforms.backRight)
		{
			UnityEngine.Object.Destroy(base.transform.gameObject);
			return;
		}
		if (!wheelsTransforms.backLeft)
		{
			UnityEngine.Object.Destroy(base.transform.gameObject);
			return;
		}
		float z = wheelsTransforms.frontRight.localPosition.z + 1f;
		mRayL2 = new GameObject("RayL2").transform;
		mRayL2.SetParent(base.transform);
		mRayL2.localRotation = Quaternion.Euler(new Vector3(0f, 0f, 0f));
		mRayL2.localPosition = new Vector3(-4.9f, 0.5f, 4f);
		mRayL = new GameObject("RayL").transform;
		mRayL.SetParent(base.transform);
		mRayL.localRotation = Quaternion.Euler(new Vector3(0f, 0f, 0f));
		mRayL.localPosition = new Vector3(-0.72f, 0.5f, z);
		mRayR = new GameObject("RayLR").transform;
		mRayR.SetParent(base.transform);
		mRayR.localRotation = Quaternion.Euler(new Vector3(0f, 0f, 0f));
		mRayR.localPosition = new Vector3(0.72f, 0.5f, z);
		bulsola = new GameObject("Bulsola");
		bulsola.transform.SetParent(base.transform);
		bulsola.transform.localPosition = new Vector3(0f, 0f, 0f);
		if (!base.transform.GetComponent<Rigidbody>())
		{
			base.transform.gameObject.AddComponent<Rigidbody>();
		}
		myRigidbody = base.transform.GetComponent<Rigidbody>();
		myRigidbody.centerOfMass = carSetting.shiftCentre;
		if (myRigidbody.mass < 1000f)
		{
			myRigidbody.mass = 1000f;
		}
		wheels = new WheelComponent[4];
		maxSteerAngle = Mathf.Clamp(Vector3.Distance(wheelsTransforms.frontRight.transform.position, wheelsTransforms.backRight.transform.position) * 12f, 35f, 60f);
		wheels[0] = SetWheelComponent(wheelsTransforms.frontRight, maxSteerAngle, drive: true);
		wheels[1] = SetWheelComponent(wheelsTransforms.frontLeft, maxSteerAngle, drive: true);
		wheels[2] = SetWheelComponent(wheelsTransforms.backRight, 0f, drive: false);
		wheels[3] = SetWheelComponent(wheelsTransforms.backLeft, 0f, drive: false);
	}

	private WheelComponent SetWheelComponent(Transform wheel, float maxSteer, bool drive)
	{
		WheelComponent wheelComponent = new WheelComponent();
		GameObject gameObject = new GameObject(wheel.name + " - WheelCollider");
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.position = wheel.position;
		gameObject.transform.eulerAngles = base.transform.eulerAngles;
		WheelCollider obj = (WheelCollider)gameObject.AddComponent(typeof(WheelCollider));
		wheelComponent.wheel = wheel;
		wheelComponent.collider = gameObject.GetComponent<WheelCollider>();
		obj.suspensionDistance = 0.05f;
		obj.radius = GetWhellRadio(wheel) * 0.92f;
		obj.mass = 1500f;
		return wheelComponent;
	}

	private float GetWhellRadio(Transform eu)
	{
		return eu.transform.GetComponent<MeshFilter>().sharedMesh.bounds.size.z * eu.transform.localScale.z * 0.5f;
	}

	public void init(GameObject path)
	{
		init2();
		atualWay = path;
		atualWayScript = atualWay.GetComponent<FCGWaypointsContainer>();
		currentNode = 1;
		DefineNewPath();
	}

	private void DefineNewPath()
	{
		nodes = new Transform[atualWay.transform.childCount];
		int num = 0;
		foreach (Transform item in atualWay.transform)
		{
			nodes[num++] = item;
		}
		countWays = nodes.Length;
		currentNode = 0;
		distancia = Vector3.Distance(nodes[currentNode].position, base.transform.position);
	}

	private void VerificaPoints()
	{
		if (distancia < 5f)
		{
			if (currentNode < countWays - 1)
			{
				currentNode++;
			}
			else
			{
				mRayL2.localPosition = new Vector3(-5f, 0.5f, 4f);
				if (Physics.Raycast(mRayL2.position, mRayL2.forward, out var hitInfo, 50f))
				{
					if ((bool)hitInfo.transform.gameObject.GetComponent<TrafficCar>())
					{
						atualWay = atualWay.GetComponent<FCGWaypointsContainer>().nextWay[0];
					}
					else
					{
						atualWay = atualWay.GetComponent<FCGWaypointsContainer>().nextWay[UnityEngine.Random.Range(0, atualWay.GetComponent<FCGWaypointsContainer>().nextWay.Length)];
					}
				}
				else
				{
					mRayL2.localPosition = new Vector3(-4f, 0.5f, 4f);
					if (Physics.Raycast(mRayL2.position, mRayL2.forward, out hitInfo, 50f))
					{
						if ((bool)hitInfo.transform.gameObject.GetComponent<TrafficCar>())
						{
							atualWay = atualWay.GetComponent<FCGWaypointsContainer>().nextWay[0];
						}
						else
						{
							atualWay = atualWay.GetComponent<FCGWaypointsContainer>().nextWay[UnityEngine.Random.Range(0, atualWay.GetComponent<FCGWaypointsContainer>().nextWay.Length)];
						}
					}
					else
					{
						atualWay = atualWay.GetComponent<FCGWaypointsContainer>().nextWay[UnityEngine.Random.Range(0, atualWay.GetComponent<FCGWaypointsContainer>().nextWay.Length)];
					}
				}
				atualWayScript = atualWay.GetComponent<FCGWaypointsContainer>();
				DefineNewPath();
			}
		}
		distancia = Vector3.Distance(nodes[currentNode].position, base.transform.position);
	}

	private void ApplySteer()
	{
		relativeVector = base.transform.InverseTransformPoint(nodes[currentNode].position);
		steer = relativeVector.x / relativeVector.magnitude * maxSteerAngle;
		if (currentNode == 0 && distancia > 18f && distancia < 30f)
		{
			angulo = GetAngulo(nodes[currentNode]);
			if (angulo > 330f || angulo < 30f)
			{
				steer *= 0.1f;
			}
		}
	}

	private void FixedUpdate()
	{
		if (!atualWay)
		{
			UnityEngine.Object.Destroy(base.transform.gameObject);
			return;
		}
		VerificaPoints();
		ApplySteer();
		MoveCar();
	}

	private float FixedRaycasts()
	{
		float result = 0f;
		mRayR.localRotation = Quaternion.Euler(new Vector3(0f, steer, 0f));
		mRayL.localRotation = mRayR.localRotation;
		if (Physics.Raycast(mRayL.position, mRayL.forward, out hit, wdist))
		{
			UnityEngine.Debug.DrawRay(mRayL.position, mRayL.forward * wdist, Color.red);
			result = 4000f / hit.distance;
		}
		else if (Physics.Raycast(mRayR.position, mRayR.forward, out hit, wdist))
		{
			UnityEngine.Debug.DrawRay(mRayR.position, mRayR.forward * wdist, Color.red);
			result = 4000f / hit.distance;
		}
		return result;
	}

	private float GetAngulo(Transform target)
	{
		bulsola.transform.LookAt(target);
		return bulsola.transform.localEulerAngles.y;
	}

	private void MoveCar()
	{
		brake = FixedRaycasts();
		if (brake > 0f)
		{
			accel = 0;
		}
		speed = myRigidbody.velocity.magnitude * 2.7f;
		if (brake > 0f && speed < 10f)
		{
			timeStoped += Time.deltaTime;
			if (timeStoped > 30f)
			{
				UnityEngine.Object.Destroy(base.transform.gameObject);
				UnityEngine.Debug.Log("removed Car " + base.transform.name);
			}
			return;
		}
		timeStoped = 0f;
		myRigidbody.centerOfMass = carSetting.shiftCentre;
		try
		{
			f = wheels.Length;
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.Log("Error - wheels in " + base.transform.name);
			UnityEngine.Debug.LogException(exception, this);
			return;
		}
		for (int i = 0; i < f; i++)
		{
			WheelCollider collider = wheels[i].collider;
			if (i < 2)
			{
				if (brake == 0f)
				{
					collider.brakeTorque = 0f;
					collider.motorTorque = Mathf.Lerp(carSetting.carPower * 20f, 0f, speed / carSetting.LimitForwardSpeed);
				}
				else
				{
					collider.motorTorque = 0f;
					collider.brakeTorque = carSetting.brakePower * brake;
				}
				collider.steerAngle = steer;
				if (i == 0)
				{
					wheels[i].rotation = Mathf.Repeat(wheels[i].rotation + Time.deltaTime * collider.rpm * 360f / 60f, 360f);
					wheels[i].rotation2 = Mathf.Lerp(wheels[i].rotation2, collider.steerAngle, 0.1f);
					wheels[i].wheel.localRotation = Quaternion.Euler(wheels[i].rotation, wheels[i].rotation2, 0f);
				}
				else
				{
					wheels[i].wheel.localRotation = wheels[0].wheel.localRotation;
				}
				if ((bool)wheelsTransforms.backRight2)
				{
					wheelsTransforms.backRight2.rotation = wheelsTransforms.backRight.rotation;
					wheelsTransforms.backLeft2.rotation = wheelsTransforms.backRight.rotation;
				}
			}
			else
			{
				if (brake > 0f)
				{
					accel = 10;
					collider.motorTorque = 0f;
					collider.brakeTorque = carSetting.brakePower * brake;
				}
				else
				{
					collider.brakeTorque = 0f;
				}
				wheels[i].wheel.localRotation = Quaternion.Euler(wheels[0].rotation, 0f, 0f);
			}
		}
	}
}
public class TrafficLights : MonoBehaviour
{
	[Serializable]
	public class TrafficLightState
	{
		public int status;

		public GameObject t31;

		public GameObject t13;

		public GameObject t21;

		public GameObject t12;

		public GameObject t11;

		public GameObject stop31;

		public GameObject stop13;
	}

	private float countTime;

	private int step;

	public TrafficLightState tState;

	private void Start()
	{
		countTime = 0f;
		step = 0;
		tState.status = ((UnityEngine.Random.Range(1, 8) < 4) ? 13 : 31);
		EnabledObjects(tState.status);
	}

	private void FixedUpdate()
	{
		countTime += Time.deltaTime;
		if (step == 0)
		{
			if (countTime > 10f)
			{
				countTime = 0f;
				step = 1;
				if (tState.status == 13)
				{
					tState.status = 12;
				}
				else if (tState.status == 31)
				{
					tState.status = 21;
				}
				EnabledObjects(tState.status);
			}
		}
		else if (step == 1)
		{
			if (countTime > 3f)
			{
				countTime = 0f;
				step = 2;
				if (tState.status == 12)
				{
					tState.status = 41;
				}
				else if (tState.status == 21)
				{
					tState.status = 14;
				}
				EnabledObjects(tState.status);
			}
		}
		else if (step == 2 && countTime > 3f)
		{
			countTime = 0f;
			step = 0;
			if (tState.status == 14)
			{
				tState.status = 13;
			}
			else if (tState.status == 41)
			{
				tState.status = 31;
			}
			EnabledObjects(tState.status);
		}
	}

	private void EnabledObjects(int habilita)
	{
		tState.t12.SetActive(habilita == 12);
		tState.t21.SetActive(habilita == 21);
		tState.t13.SetActive(habilita == 13);
		tState.t31.SetActive(habilita == 31);
		tState.t11.SetActive(habilita == 11 || habilita == 14 || habilita == 41);
		tState.stop13.SetActive(habilita != 31);
		tState.stop31.SetActive(habilita != 13);
	}
}
public class TrafficSystem : MonoBehaviour
{
	[HideInInspector]
	private GameObject[] tf01;

	public GameObject[] IaCars;

	private void Start()
	{
		tf01 = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name.Equals("TF-01")
			select g).ToArray();
		int num = tf01.Length;
		for (int i = 0; i < num; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(IaCars[Mathf.Clamp(UnityEngine.Random.Range(0, IaCars.Length), 0, IaCars.Length - 1)], tf01[i].transform.position, tf01[i].transform.rotation);
			if (!gameObject.GetComponent<TrafficCar>())
			{
				gameObject.AddComponent<TrafficCar>();
			}
			gameObject.GetComponent<TrafficCar>().init(tf01[i].transform.parent.gameObject);
		}
	}
}
public class FCGWaypointsContainer : MonoBehaviour
{
	public List<Transform> waypoints = new List<Transform>();

	public GameObject[] nextWay;

	private GameObject[] tf01;

	private void Start()
	{
		tf01 = (from g in UnityEngine.Object.FindObjectsOfType(typeof(GameObject))
			select g as GameObject into g
			where g.name.Equals("TF-01")
			select g).ToArray();
		for (int i = 0; i < waypoints.Count; i++)
		{
			if (i < waypoints.Count - 1)
			{
				waypoints[i].LookAt(waypoints[i + 1]);
				continue;
			}
			waypoints[i].rotation = Quaternion.LookRotation(waypoints[i].position - waypoints[i - 1].position);
			NextWays(waypoints[i]);
		}
	}

	public void InvertNodesDirection()
	{
		Vector3 vector = new Vector3(0f, 0f, 0f);
		int num = Mathf.CeilToInt(waypoints.Count / 2);
		for (int i = 0; i < num; i++)
		{
			vector = waypoints[i].position;
			waypoints[i].position = waypoints[waypoints.Count - i - 1].position;
			waypoints[waypoints.Count - i - 1].position = vector;
		}
	}

	private void AddNewWays(Transform referencia, ArrayList arr)
	{
		int num = 0;
		float num2 = -180f;
		Transform transform;
		for (int i = 0; i < arr.Count; i++)
		{
			float num3 = GetAngulo(referencia, (Transform)arr[i]);
			if (num3 > 180f)
			{
				num3 -= 360f;
			}
			transform = (Transform)arr[i];
			if (num3 > num2)
			{
				num2 = num3;
				num = i;
			}
		}
		nextWay = new GameObject[arr.Count];
		transform = (Transform)arr[num];
		nextWay[0] = transform.transform.parent.gameObject;
		int num4 = 0;
		for (int j = 0; j < arr.Count; j++)
		{
			if (j != num)
			{
				num4++;
				transform = (Transform)arr[j];
				nextWay[num4] = transform.parent.gameObject;
			}
		}
	}

	private void NextWays(Transform referencia)
	{
		int num = tf01.Length;
		if (num < 1)
		{
			return;
		}
		ArrayList arrayList = new ArrayList();
		for (int i = 0; i < num; i++)
		{
			float num2 = Vector3.Distance(referencia.position, tf01[i].transform.position);
			if (num2 < 50f && num2 > 8f)
			{
				float angulo = GetAngulo(referencia, tf01[i].transform);
				if ((angulo > 270f || angulo < 90f) && num2 < 35f)
				{
					arrayList.Add(tf01[i].transform);
				}
			}
		}
		referencia.transform.parent.gameObject.GetComponent<FCGWaypointsContainer>().AddNewWays(referencia, arrayList);
	}

	private float GetAngulo(Transform origem, Transform target)
	{
		GameObject obj = new GameObject("Bulsola");
		obj.transform.parent = origem;
		obj.transform.localPosition = new Vector3(0f, 0f, 0f);
		obj.transform.LookAt(target);
		float y = obj.transform.localEulerAngles.y;
		UnityEngine.Object.Destroy(obj);
		return y;
	}

	private void OnDrawGizmos()
	{
		for (int i = 0; i < waypoints.Count; i++)
		{
			Gizmos.color = new Color(0f, 1f, 1f, 0.3f);
			Gizmos.DrawSphere(waypoints[i].transform.position, 1f);
			if (i < waypoints.Count - 1)
			{
				if ((bool)waypoints[i] && (bool)waypoints[i + 1] && waypoints.Count > 0 && i < waypoints.Count - 1)
				{
					Gizmos.DrawLine(waypoints[i].position, waypoints[i + 1].position);
					waypoints[i].LookAt(waypoints[i + 1]);
				}
			}
			else if (i == waypoints.Count - 1)
			{
				waypoints[i].rotation = waypoints[i - 1].rotation;
			}
		}
	}
}
public class CoolDown : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public Image overlay;

	private bool isCoolDown;

	private float coolDownDuration;

	private float coolDownInitTime;

	public bool IsCoolDown => isCoolDown;

	public void Update()
	{
		if (overlay != null)
		{
			if (Time.time - coolDownInitTime < coolDownDuration)
			{
				overlay.fillAmount = Mathf.Clamp01(1f - (Time.time - coolDownInitTime) / coolDownDuration);
			}
			else
			{
				overlay.fillAmount = 0f;
			}
			isCoolDown = overlay.fillAmount > 0f;
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		Cooldown(3f, 1.5f);
	}

	public void Cooldown(float coolDown, float globalCoolDown)
	{
		if (!isCoolDown)
		{
			coolDownDuration = coolDown;
			coolDownInitTime = Time.time;
			isCoolDown = true;
			base.transform.root.BroadcastMessage("GlobalCooldown", globalCoolDown, SendMessageOptions.DontRequireReceiver);
		}
	}

	private void GlobalCooldown(float coolDown)
	{
		if (Time.time + coolDownInitTime * coolDownDuration < Time.time + coolDownInitTime * coolDown || !isCoolDown)
		{
			coolDownDuration = coolDown;
			coolDownInitTime = Time.time;
		}
	}
}
public class SelectDifficulty : MonoBehaviour
{
	public int index;

	public Toggle[] toggles;

	public void OnSelect()
	{
		for (int i = 0; i < toggles.Length; i++)
		{
			if (i != index)
			{
				toggles[i].isOn = false;
			}
		}
		toggles[index].isOn = true;
	}
}
public class ButtonAnimator : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
{
	private Animator buttonAnimator;

	private void Start()
	{
		buttonAnimator = GetComponent<Animator>();
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		buttonAnimator.SetTrigger("Highlighted");
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		buttonAnimator.SetTrigger("Normal");
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		buttonAnimator.SetTrigger("Pressed");
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (eventData.hovered.Contains(base.gameObject))
		{
			buttonAnimator.SetTrigger("Highlighted");
		}
		else
		{
			buttonAnimator.SetTrigger("Normal");
		}
	}
}
public class Nl_DragObject : MonoBehaviour
{
	public static Camera Cam;

	private Rigidbody rigidboy;

	private float distanceZ;

	private bool isTaken;

	private Vector3 offset;

	private Vector3 dir;

	private void Start()
	{
		rigidboy = base.gameObject.GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (isTaken)
		{
			if (Input.GetMouseButton(1))
			{
				Vector3 position = new Vector3(Input.mousePosition.x, Input.mousePosition.y, distanceZ);
				Vector3 vector = Cam.ScreenToWorldPoint(position);
				rigidboy.MovePosition(vector + offset);
			}
			else
			{
				rigidboy.useGravity = true;
				rigidboy.constraints = RigidbodyConstraints.None;
				isTaken = false;
			}
			if (Input.GetAxis("Horizontal") != 0f && Input.GetKey(KeyCode.LeftAlt))
			{
				base.transform.Rotate(Vector3.up * 100f * Time.deltaTime * Input.GetAxis("Horizontal"));
			}
			if (Input.GetAxis("Vertical") != 0f && Input.GetKey(KeyCode.LeftAlt))
			{
				base.transform.Rotate(Vector3.right * 100f * Time.deltaTime * Input.GetAxis("Vertical"));
			}
		}
	}

	private void OnMouseOver()
	{
		if (Input.GetKey(KeyCode.LeftAlt) && Input.GetMouseButtonDown(1))
		{
			isTaken = true;
			distanceZ = Vector3.Distance(Cam.transform.position, base.gameObject.transform.position);
			Vector3 position = new Vector3(Input.mousePosition.x, Input.mousePosition.y, distanceZ);
			Vector3 vector = Cam.ScreenToWorldPoint(position);
			offset = rigidboy.position - vector;
			rigidboy.velocity = Vector3.zero;
			rigidboy.useGravity = false;
			rigidboy.constraints = RigidbodyConstraints.FreezeRotation;
		}
	}
}
public class AchievementSample : MonoBehaviour
{
	public Text dataOutput;

	public InputField getDefinitionsByNameInputField;

	public InputField getProgressByNameInputField;

	public InputField unLockInputField;

	public InputField addCountInputField;

	public InputField addFieldsInputField;

	private void Start()
	{
		AchievementCore.RegisterNetwork();
	}

	private void OnDestroy()
	{
		AchievementCore.UnRegisterNetwork();
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			printOutputLine("Achievement Init");
			achievementInit();
		}
	}

	private void Update()
	{
		Request.RunCallbacks();
	}

	public void AsyncInitialize()
	{
		dataOutput.text = "> ";
		printOutputLine("AsyncInitialize");
		achievementInit();
	}

	public void GetDefinitionsByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetDefinitionsByName");
		string text = getDefinitionsByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementDefinition(achievementNames);
			getDefinitionsByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetProgressByName()
	{
		dataOutput.text = "> ";
		printOutputLine("GetProgressByName");
		string text = getProgressByNameInputField.text;
		if (text != "")
		{
			string[] achievementNames = text.Split(',');
			getAchievementProgress(achievementNames);
			getProgressByNameInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void GetAllDefinitions()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllDefinitions");
		getAchievementAllDefinition();
	}

	public void GetAllProgress()
	{
		dataOutput.text = "> ";
		printOutputLine("GetAllProgress");
		getAchievementAllProgress();
	}

	public void UnLock()
	{
		dataOutput.text = "> ";
		printOutputLine("UnLock");
		string text = unLockInputField.text;
		if (text != "")
		{
			unlockAchievement(text);
			unLockInputField.text = "";
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddCount()
	{
		dataOutput.text = "> ";
		printOutputLine("AddCount");
		string text = addCountInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				try
				{
					Convert.ToInt64(array[1]);
				}
				catch (Exception)
				{
					printOutputLine("Invalid Command");
					throw;
				}
				addCountAchievement(array[0], array[1]);
				addCountInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	public void AddFields()
	{
		dataOutput.text = "> ";
		printOutputLine("AddFields");
		string text = addFieldsInputField.text;
		if (text != "")
		{
			string[] array = text.Split(',');
			if (array.Length > 1)
			{
				addFieldsAchievement(array[0], array[1]);
				addFieldsInputField.text = "";
			}
			else
			{
				printOutputLine("Invalid Command");
			}
		}
		else
		{
			printOutputLine("Invalid Command");
		}
	}

	private void achievementInit()
	{
		Achievements.Init().OnComplete(initAchievementCallback);
	}

	private void getAchievementAllDefinition()
	{
		Achievements.GetAllDefinitions().OnComplete(achievementAllDefinitionCallback);
	}

	private void getAchievementAllProgress()
	{
		Achievements.GetAllProgress().OnComplete(achievementAllProgressCallback);
	}

	private void addFieldsAchievement(string achievementName, string fields)
	{
		Achievements.AddFields(achievementName, fields).OnComplete(achievementFieldsCallback);
	}

	private void addCountAchievement(string achievementName, string count)
	{
		Achievements.AddCount(achievementName, Convert.ToInt64(count)).OnComplete(achievementCountCallback);
	}

	private void unlockAchievement(string achievementName)
	{
		Achievements.Unlock(achievementName).OnComplete(achievementUnlockCallback);
	}

	private void getAchievementProgress(string[] achievementNames)
	{
		Achievements.GetProgressByName(achievementNames).OnComplete(achievementProgressCallback);
	}

	private void getAchievementDefinition(string[] achievementNames)
	{
		Achievements.GetDefinitionsByName(achievementNames).OnComplete(achievementDefinitionCallback);
	}

	private void printOutputLine(string newLine)
	{
		dataOutput.text = "> " + newLine + Environment.NewLine + dataOutput.text;
	}

	private void achievementAllDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			Pvr_AchievementDefinitionList achievementDefinitions = msg.GetAchievementDefinitions();
			if (achievementDefinitions.HasNextPage)
			{
				Achievements.GetNextAchievementDefinitionListPage(achievementDefinitions).OnComplete(achievementAllDefinitionCallback);
			}
			{
				foreach (Pvr_AchievementDefinition item in achievementDefinitions)
				{
					printOutputLine("Bitfield Name: " + item.Name.ToString());
					switch (item.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + item.BitfieldLength);
						printOutputLine("Target: " + item.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + item.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
					printOutputLine("Bitfield Title: " + item.Title.ToString());
					printOutputLine("Bitfield Description: " + item.Description.ToString());
					printOutputLine("Bitfield UnlockedDescription: " + item.UnlockedDescription.ToString());
					printOutputLine("Bitfield UnlockedIcon: " + item.UnlockedIcon.ToString());
					printOutputLine("Bitfield LockedIcon: " + item.LockedIcon.ToString());
					printOutputLine("Bitfield IsSecrect: " + item.IsSecrect);
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementAllProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			Pvr_AchievementProgressList achievementProgressList = msg.GetAchievementProgressList();
			if (achievementProgressList.HasNextPage)
			{
				Achievements.GetNextAchievementProgressListPage(achievementProgressList).OnComplete(achievementAllProgressCallback);
			}
			{
				foreach (Pvr_AchievementProgress item in achievementProgressList)
				{
					printOutputLine("Current Name: " + item.Name.ToString());
					if (item.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + item.Bitfield.ToString());
					printOutputLine("Current Count: " + item.Count);
					printOutputLine("Current UnlockTime: " + item.UnlockTime.ToString());
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementFieldsCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement fields added.");
			return;
		}
		printOutputLine("Received achievement fields add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementCountCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement count added.");
			return;
		}
		printOutputLine("Received achievement count add error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementUnlockCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Achievement unlocked");
			return;
		}
		printOutputLine("Received achievement unlock error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementProgressCallback(Pvr_Message<Pvr_AchievementProgressList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement progress success");
			{
				foreach (Pvr_AchievementProgress achievementProgress in msg.GetAchievementProgressList())
				{
					if (achievementProgress.IsUnlocked)
					{
						printOutputLine("Achievement Unlocked");
					}
					else
					{
						printOutputLine("Achievement Locked");
					}
					printOutputLine("Current Bitfield: " + achievementProgress.Bitfield.ToString());
					printOutputLine("Current Count: " + achievementProgress.Count);
				}
				return;
			}
		}
		printOutputLine("Received achievement progress error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void achievementDefinitionCallback(Pvr_Message<Pvr_AchievementDefinitionList> msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received achievement definitions success");
			{
				foreach (Pvr_AchievementDefinition achievementDefinition in msg.GetAchievementDefinitions())
				{
					switch (achievementDefinition.Type)
					{
					case AchievementType.Simple:
						printOutputLine("Achievement Type: Simple");
						break;
					case AchievementType.Bitfield:
						printOutputLine("Achievement Type: Bitfield");
						printOutputLine("Bitfield Length: " + achievementDefinition.BitfieldLength);
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					case AchievementType.Count:
						printOutputLine("Achievement Type: Count");
						printOutputLine("Target: " + achievementDefinition.Target);
						break;
					default:
						printOutputLine("Achievement Type: Unknown");
						break;
					}
				}
				return;
			}
		}
		printOutputLine("Received achievement definitions error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void initAchievementCallback(Pvr_Message msg)
	{
		if (!msg.IsError)
		{
			printOutputLine("Received init success");
			return;
		}
		printOutputLine("Received init error");
		Error error = msg.GetError();
		printOutputLine("Error: Message:" + error.Message + " Code: " + error.Code + " HttpCode: " + error.HttpCode);
	}

	private void LoginCallback(string LoginInfo)
	{
		UnityEngine.Debug.Log("Received loginCallback:" + LoginInfo);
		printOutputLine("Received loginCallback: " + LoginInfo);
	}
}
public class Pvr_Controller : MonoBehaviour
{
	public enum UserHandNess
	{
		Right,
		Left
	}

	public enum GazeType
	{
		Never,
		DuringMotion,
		Always
	}

	public enum ControllerAxis
	{
		Controller,
		Wrist,
		Elbow,
		Shoulder
	}

	public GameObject controller0;

	public GameObject controller1;

	private static UserHandNess handness;

	public ControllerAxis Axis;

	public GazeType Gazetype;

	[Range(0f, 0.2f)]
	public float ElbowHeight;

	[Range(0f, 0.2f)]
	public float ElbowDepth;

	[Range(0f, 30f)]
	public float PointerTiltAngle = 15f;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private Vector3[] inputDirection = new Vector3[2];

	public static Vector3 pointerPosition { get; set; }

	public static Quaternion pointerRotation { get; set; }

	public static Vector3 elbowPosition { get; set; }

	public static Quaternion elbowRotation { get; set; }

	public static Vector3 wristPosition { get; set; }

	public static Quaternion wristRotation { get; set; }

	public static Vector3 shoulderPosition { get; set; }

	public static Quaternion shoulderRotation { get; set; }

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent += HandnessChanged;
	}

	private void Start()
	{
		handness = Controller.UPvr_GetHandNess();
		if (handness == (UserHandNess)(-1))
		{
			handness = UserHandNess.Right;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerState;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerChanged;
		Pvr_ControllerManager.ChangeHandNessCallBackEvent -= HandnessChanged;
	}

	private void MainControllerChanged(string index)
	{
		RefreshHandness();
	}

	private void HandnessChanged(string index)
	{
		RefreshHandness();
	}

	private void ServiceStartSuccess()
	{
		RefreshHandness();
	}

	private void RefreshHandness()
	{
		handness = Controller.UPvr_GetHandNess();
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			ChangeHandNess();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		if (!pause)
		{
			if (controller0 != null)
			{
				controller0.transform.localScale = Vector3.zero;
			}
			if (controller1 != null)
			{
				controller1.transform.localScale = Vector3.zero;
			}
		}
		Invoke("ShowController", 0.1f * Time.timeScale);
	}

	private void ShowController()
	{
		if (controller0 != null)
		{
			controller0.transform.localScale = Vector3.one;
		}
		if (controller1 != null)
		{
			controller1.transform.localScale = Vector3.one;
		}
	}

	private void CheckControllerState(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		if (num && num2 == 1)
		{
			RefreshHandness();
		}
	}

	private void Update()
	{
		if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (Controller.UPvr_GetPreferenceDevice() == 1)
		{
			DoUpdateControler0();
			DoUpdateControler1();
			UpdateControlloerRay();
			return;
		}
		if (controller0 != null)
		{
			controller0.transform.localRotation = Controller.UPvr_GetControllerQUA(0);
			controller0.transform.localPosition = Controller.UPvr_GetControllerPOS(0);
			UpdateControlloerRay(update0: true, update1: false);
		}
		if (controller1 != null)
		{
			controller1.transform.localRotation = Controller.UPvr_GetControllerQUA(1);
			controller1.transform.localPosition = Controller.UPvr_GetControllerPOS(1);
			UpdateControlloerRay(update0: false);
		}
	}

	public static void ChangeHandNess()
	{
		handness = ((handness == UserHandNess.Right) ? UserHandNess.Left : UserHandNess.Right);
	}

	private void DoUpdateControler0()
	{
		SetArmParaToSo((int)handness, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(0);
		UpdateControllerDataSO(0);
	}

	private void DoUpdateControler1()
	{
		int hand = ((handness != UserHandNess.Left) ? 1 : 0);
		SetArmParaToSo(hand, (int)Gazetype, ElbowHeight, ElbowDepth, PointerTiltAngle);
		CalcArmModelfromSo(1);
		UpdateControllerDataSO(1);
	}

	private void UpdateControlloerRay(bool update0 = true, bool update1 = true)
	{
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			if (update0 && controller0 != null)
			{
				controller0.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
			if (update1 && controller1 != null)
			{
				controller1.GetComponent<Pvr_ControllerModuleInit>().UpdateRay();
			}
		}
	}

	private Quaternion UpdateSimulatedFrameParams()
	{
		if (Input.GetKey(KeyCode.LeftShift))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -80f, 80f);
		}
		else if (Input.GetKey(KeyCode.RightShift))
		{
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -80f, 80f);
		}
		return Quaternion.Euler(mouseY, mouseX, mouseZ);
	}

	private void SetArmParaToSo(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
	{
		Controller.UPvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
	}

	private void CalcArmModelfromSo(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[4];
		float[] array3 = new float[3];
		Quaternion quaternion = default(Quaternion);
		quaternion = Controller.UPvr_GetControllerQUA(hand);
		Vector3 vector = Controller.UPvr_GetAngularVelocity(hand);
		array2[0] = quaternion.x;
		array2[1] = quaternion.y;
		array2[2] = quaternion.z;
		array2[3] = quaternion.w;
		array3[0] = vector.x;
		array3[1] = vector.y;
		array3[2] = vector.z;
		if (Gazetype == GazeType.DuringMotion)
		{
			Vector3 b = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation * Vector3.forward;
			b.y = 0f;
			b.Normalize();
			float t = Mathf.Clamp((vector.magnitude - 0.2f) / 45f, 0f, 0.1f);
			inputDirection[hand] = Vector3.Slerp(inputDirection[hand], b, t);
			if (Controller.UPvr_GetKeyLongPressed(hand, Pvr_KeyCode.HOME))
			{
				inputDirection[hand] = default(Vector3);
			}
			Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.forward, inputDirection[hand]);
			array[0] = quaternion2.x;
			array[1] = quaternion2.y;
			array[2] = quaternion2.z;
			array[3] = quaternion2.w;
		}
		else
		{
			array[0] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.x;
			array[1] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.y;
			array[2] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.z;
			array[3] = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.w;
		}
		Controller.UPvr_CalcArmModelParameters(array, array2, array3);
	}

	public void UpdateControllerDataSO(int hand)
	{
		float[] array = new float[4];
		float[] array2 = new float[3];
		Vector3 vector;
		Quaternion localRotation;
		switch (Axis)
		{
		case ControllerAxis.Controller:
			Controller.UPvr_GetPointerPose(array, array2);
			pointerPosition = new Vector3(array2[0], array2[1], array2[2]);
			pointerRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = pointerPosition;
			localRotation = pointerRotation;
			break;
		case ControllerAxis.Wrist:
			Controller.UPvr_GetWristPose(array, array2);
			wristPosition = new Vector3(array2[0], array2[1], array2[2]);
			wristRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = wristPosition;
			localRotation = wristRotation;
			break;
		case ControllerAxis.Elbow:
			Controller.UPvr_GetElbowPose(array, array2);
			elbowPosition = new Vector3(array2[0], array2[1], array2[2]);
			elbowRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = elbowPosition;
			localRotation = elbowRotation;
			break;
		case ControllerAxis.Shoulder:
			Controller.UPvr_GetShoulderPose(array, array2);
			shoulderPosition = new Vector3(array2[0], array2[1], array2[2]);
			shoulderRotation = new Quaternion(array[0], array[1], array[2], array[3]);
			vector = shoulderPosition;
			localRotation = shoulderRotation;
			break;
		default:
			throw new Exception("Invalid FromJoint.");
		}
		if (hand == 0)
		{
			if (controller0 != null)
			{
				if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
				{
					controller0.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
				}
				else
				{
					controller0.transform.localPosition = vector;
				}
				controller0.transform.localRotation = localRotation;
			}
		}
		else if (controller1 != null)
		{
			if (!Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
			{
				controller1.transform.localPosition = vector + Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			}
			else
			{
				controller1.transform.localPosition = vector;
			}
			controller1.transform.localRotation = localRotation;
		}
	}
}
public class Pvr_ControllerDemo : MonoBehaviour
{
	public GameObject HeadSetController;

	public GameObject controller0;

	public GameObject controller1;

	public GameObject cube;

	private Ray ray;

	private GameObject currentController;

	private Transform lastHit;

	private Transform currentHit;

	[SerializeField]
	private Material normat;

	[SerializeField]
	private Material gazemat;

	[SerializeField]
	private Material clickmat;

	private bool noClick;

	private GameObject referenceObj;

	public float rayDefaultLength = 4f;

	private bool isHasController;

	private bool headcontrolmode;

	private RaycastHit hit;

	private GameObject rayLine;

	private GameObject dot;

	private Transform dragObj;

	private float disX;

	private float disY;

	private float disZ;

	private void Start()
	{
		ray = default(Ray);
		hit = default(RaycastHit);
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent += ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
			isHasController = true;
		}
		referenceObj = new GameObject("ReferenceObj");
	}

	private void OnDestroy()
	{
		if (isHasController)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerStateChangedEvent -= ControllerStateListener;
			Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
		}
	}

	private void Update()
	{
		if (HeadSetController.activeSelf)
		{
			HeadSetController.transform.parent.localRotation = Quaternion.Euler(Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.x, Pvr_UnitySDKSensor.Instance.HeadPose.Orientation.eulerAngles.y, 0f);
			HeadSetController.transform.parent.localPosition = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
			ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
			if (Physics.Raycast(ray, out hit))
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = new Vector3(0.09f, 0.09f, 0.09f);
				}
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water") && !noClick)
				{
					hit.transform.GetComponent<Renderer>().material = gazemat;
				}
				lastHit = hit.transform;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = hit.point;
					HeadSetController.transform.position -= (hit.point - HeadSetController.transform.parent.parent.Find("Head").position).normalized * 0.02f;
					float num = 0.008f * hit.distance / 4f;
					Mathf.Clamp(num, 0.002f, 0.008f);
					HeadSetController.transform.localScale = new Vector3(num, num, 1f);
				}
			}
			else
			{
				if (HeadSetController.name == "SightPointer")
				{
					HeadSetController.transform.localScale = Vector3.zero;
				}
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					HeadSetController.transform.position = HeadSetController.transform.parent.parent.Find("Head").position + ray.direction.normalized * (0.5f + rayDefaultLength);
					HeadSetController.transform.localScale = new Vector3(0.008f, 0.008f, 1f);
				}
			}
			if ((Input.GetKeyDown(KeyCode.JoystickButton0) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
			{
				lastHit.transform.GetComponent<Renderer>().material = clickmat;
				noClick = true;
			}
			return;
		}
		if (currentController != null)
		{
			ray.direction = currentController.transform.forward - currentController.transform.up * 0.25f;
			ray.origin = currentController.transform.Find("start").position;
			if (Physics.Raycast(ray, out hit))
			{
				currentHit = hit.transform;
				if (currentHit != null && lastHit != null && currentHit != lastHit && (bool)lastHit.GetComponent<Pvr_UIGraphicRaycaster>() && lastHit.transform.gameObject.activeInHierarchy && lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					lastHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = false;
				}
				if (currentHit != null && lastHit != null && currentHit == lastHit && (bool)currentHit.GetComponent<Pvr_UIGraphicRaycaster>() && !currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled)
				{
					currentHit.GetComponent<Pvr_UIGraphicRaycaster>().enabled = true;
				}
				if (1 << hit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					if (!noClick)
					{
						hit.transform.GetComponent<Renderer>().material = gazemat;
					}
					if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0))
					{
						referenceObj.transform.position = hit.point;
						disX = hit.transform.position.x - referenceObj.transform.position.x;
						disY = hit.transform.position.y - referenceObj.transform.position.y;
						dragObj = hit.transform;
					}
					if ((Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButton(0)) && hit.transform == dragObj.transform)
					{
						referenceObj.transform.position = new Vector3(hit.point.x, hit.point.y, hit.transform.position.z);
						dragObj.position = new Vector3(referenceObj.transform.position.x + disX, referenceObj.transform.position.y + disY, hit.transform.position.z);
					}
				}
				lastHit = hit.transform;
				currentController.transform.Find("dot").position = hit.point;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					float num2 = 0.178f * currentController.transform.Find("dot").localPosition.z / 3.3f;
					Mathf.Clamp(num2, 0.05f, 0.178f);
					currentController.transform.Find("dot").localScale = new Vector3(num2, num2, 1f);
				}
			}
			else
			{
				if (lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water"))
				{
					lastHit.transform.GetComponent<Renderer>().material = normat;
				}
				currentHit = null;
				noClick = false;
				if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
				{
					currentController.transform.Find("dot").localScale = new Vector3(0.178f, 0.178f, 1f);
				}
			}
		}
		if ((Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD) || Input.GetMouseButtonDown(0)) && lastHit != null && 1 << lastHit.transform.gameObject.layer == LayerMask.GetMask("Water") && currentHit != null)
		{
			lastHit.transform.GetComponent<Renderer>().material = clickmat;
			noClick = true;
		}
	}

	private void ServiceStartSuccess()
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void ControllerStateListener(string data)
	{
		if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
		{
			HeadSetController.SetActive(value: false);
		}
		else
		{
			HeadSetController.SetActive(value: true);
		}
		if (Controller.UPvr_GetMainHandNess() == 0)
		{
			currentController = controller0;
		}
		if (Controller.UPvr_GetMainHandNess() == 1)
		{
			currentController = controller1;
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		HeadSetController.SetActive(Convert.ToInt16(state) != 1);
	}

	public void SwitchControlMode()
	{
	}
}
public class Pvr_ControllerEventsExamples : MonoBehaviour
{
	private void Start()
	{
		if (!(GetComponent<Pvr_UIPointer>() == null))
		{
			GetComponent<Pvr_UIPointer>().UIPointerElementEnter += UIPointerElementEnter;
			GetComponent<Pvr_UIPointer>().UIPointerElementExit += UIPointerElementExit;
			GetComponent<Pvr_UIPointer>().UIPointerElementClick += UIPointerElementClick;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragStart += UIPointerElementDragStart;
			GetComponent<Pvr_UIPointer>().UIPointerElementDragEnd += UIPointerElementDragEnd;
		}
	}

	private void UIPointerElementEnter(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer entered" + e.currentTarget.name);
	}

	private void UIPointerElementExit(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer exited" + e.currentTarget.name);
	}

	private void UIPointerElementClick(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer clicked" + e.currentTarget.name);
	}

	private void UIPointerElementDragStart(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer started dragging" + e.currentTarget.name);
	}

	private void UIPointerElementDragEnd(object sender, UIPointerEventArgs e)
	{
		PLOG.I("UI Pointer stopped dragging" + e.currentTarget.name);
	}
}
public class Pvr_ControllerInit : MonoBehaviour
{
	private ControllerVariety Variety;

	private bool isCustomModel;

	[SerializeField]
	private GameObject goblin;

	[SerializeField]
	private GameObject g2;

	[SerializeField]
	private GameObject neo2L;

	[SerializeField]
	private GameObject neo2R;

	[SerializeField]
	private GameObject neo3L;

	[SerializeField]
	private GameObject neo3R;

	[SerializeField]
	private Material standardMat;

	[SerializeField]
	private Material unlitMat;

	private int controllerType = -1;

	[HideInInspector]
	public bool loadModelSuccess;

	private int systemOrUnity;

	private JsonData curControllerData;

	private string modelName = "";

	private string texFormat = "";

	private string prePath = "";

	private string modelFilePath = "/system/media/PvrRes/controller/";

	private const string goblinTexbasePath = "Controller/controller1/controller1";

	private const string g2TexbasePath = "Controller/controller3/controller3";

	private const string neo2TexbasePath = "Controller/controller4/controller4";

	private const string neo3TexbasePath = "Controller/controller5/controller5";

	private void Awake()
	{
		Render.UPvr_GetIntConfig(15, ref systemOrUnity);
		Variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		isCustomModel = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().IsCustomModel;
		if (!isCustomModel)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
			Pvr_ControllerManager.SetControllerAbilityEvent += CheckControllerStateOfAbility;
			Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForGoblin;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.SetControllerAbilityEvent -= CheckControllerStateOfAbility;
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForGoblin;
	}

	private void OnApplicationPause(bool pause)
	{
		if (pause)
		{
			DestroyLocalController();
		}
	}

	private void ServiceStartSuccess()
	{
		int num = Controller.UPvr_GetDeviceType();
		if (controllerType != num && num != 0)
		{
			controllerType = num;
		}
		LoadResFromJson();
		if (Pvr_ControllerManager.controllerlink.neoserviceStarted)
		{
			if (Variety == ControllerVariety.Controller0)
			{
				if (Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					StartCoroutine(RefreshController(0));
				}
				else
				{
					DestroyLocalController();
				}
			}
			if (Variety == ControllerVariety.Controller1)
			{
				if (Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					StartCoroutine(RefreshController(1));
				}
				else
				{
					DestroyLocalController();
				}
			}
		}
		if (Pvr_ControllerManager.controllerlink.goblinserviceStarted && Variety == ControllerVariety.Controller0)
		{
			if (Pvr_ControllerManager.controllerlink.controller0Connected)
			{
				StartCoroutine(RefreshController(0));
			}
			else
			{
				DestroyLocalController();
			}
		}
	}

	private void LoadResFromJson()
	{
		string text = Pvr_UnitySDKAPI.System.UPvr_GetObjectOrArray("config.controller", 7);
		if (text != null)
		{
			JsonData jsonData = JsonMapper.ToObject(text);
			if (controllerType >= 0 && jsonData.Count >= controllerType)
			{
				curControllerData = jsonData[controllerType - 1];
				modelFilePath = (string)curControllerData["base_path"];
				modelName = (string)curControllerData["model_name"] + "_sys";
			}
		}
		else
		{
			PLOG.E("PvrLog LoadJsonFromSystem Error");
		}
	}

	private void CheckControllerStateForGoblin(string state)
	{
		int num = Controller.UPvr_GetDeviceType();
		if (Variety != 0)
		{
			return;
		}
		if (Convert.ToInt16(state) == 1)
		{
			if (controllerType != num)
			{
				DestroySysController();
				controllerType = num;
			}
			StartCoroutine(RefreshController(0));
		}
		else
		{
			DestroyLocalController();
		}
	}

	private void CheckControllerStateOfAbility(string data)
	{
		bool num = Convert.ToBoolean(Convert.ToInt16(data.Substring(4, 1)));
		short num2 = Convert.ToInt16(data.Substring(0, 1));
		int num3 = Controller.UPvr_GetDeviceType();
		if (num)
		{
			controllerType = num3;
			switch (num2)
			{
			case 0:
				if (Variety == ControllerVariety.Controller0)
				{
					StartCoroutine(RefreshController(0));
				}
				break;
			case 1:
				if (Variety == ControllerVariety.Controller1)
				{
					StartCoroutine(RefreshController(1));
				}
				break;
			}
			return;
		}
		switch (num2)
		{
		case 0:
			if (Variety == ControllerVariety.Controller0)
			{
				DestroyLocalController();
			}
			break;
		case 1:
			if (Variety == ControllerVariety.Controller1)
			{
				DestroyLocalController();
			}
			break;
		}
	}

	private void DestroyLocalController()
	{
		foreach (Transform item in base.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
			loadModelSuccess = false;
		}
	}

	private void DestroySysController()
	{
		foreach (Transform item in base.transform)
		{
			if (item.name == modelName)
			{
				UnityEngine.Object.Destroy(item.gameObject);
				loadModelSuccess = false;
			}
		}
	}

	private IEnumerator RefreshController(int id)
	{
		yield return null;
		yield return null;
		if (Controller.UPvr_GetControllerState(id) != ControllerState.Connected)
		{
			yield break;
		}
		if (systemOrUnity == 0)
		{
			LoadControllerFromPrefab();
			if (!loadModelSuccess)
			{
				LoadControllerFromSystem(id);
			}
		}
		else
		{
			bool flag = false;
			foreach (Transform item in base.transform)
			{
				if (item.name == modelName)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				LoadControllerFromSystem(id);
				if (!loadModelSuccess)
				{
					LoadControllerFromPrefab();
				}
			}
			else
			{
				base.transform.Find(modelName).gameObject.SetActive(value: true);
			}
		}
		Pvr_ToolTips.RefreshTips();
		PLOG.I("PvrLog Controller Refresh Success");
	}

	private void LoadControllerFromPrefab()
	{
		switch (controllerType)
		{
		case 1:
		{
			Pvr_ControllerVisual pvr_ControllerVisual3 = UnityEngine.Object.Instantiate(goblin, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual3.currentDevice = ControllerDevice.Goblin;
			LoadTexture(pvr_ControllerVisual3, "Controller/controller1/controller1", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 3:
		{
			Pvr_ControllerVisual pvr_ControllerVisual2 = UnityEngine.Object.Instantiate(g2, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual2.currentDevice = ControllerDevice.G2;
			LoadTexture(pvr_ControllerVisual2, "Controller/controller3/controller3", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 4:
		{
			Pvr_ControllerVisual pvr_ControllerVisual4 = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo2L : neo2R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual4.currentDevice = ControllerDevice.Neo2;
			LoadTexture(pvr_ControllerVisual4, "Controller/controller4/controller4", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		case 5:
		{
			Pvr_ControllerVisual pvr_ControllerVisual = UnityEngine.Object.Instantiate((Variety == ControllerVariety.Controller0) ? neo3L : neo3R, base.transform, worldPositionStays: false).AddComponent<Pvr_ControllerVisual>();
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			LoadTexture(pvr_ControllerVisual, "Controller/controller5/controller5", fromRes: true);
			loadModelSuccess = true;
			break;
		}
		default:
			loadModelSuccess = false;
			break;
		}
	}

	private void LoadControllerFromSystem(int id)
	{
		string text = controllerType.ToString() + id + ".obj";
		string text2 = modelFilePath + text;
		if (!File.Exists(text2))
		{
			PLOG.I("PvrLog Obj File does not exist==" + text2);
			return;
		}
		GameObject gameObject = new GameObject();
		gameObject.name = modelName;
		gameObject.AddComponent<MeshFilter>().mesh = Pvr_ObjImporter.Instance.ImportFile(text2);
		gameObject.transform.SetParent(base.transform);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.AddComponent<MeshRenderer>().material = (((int)curControllerData["material_type"] == 0) ? standardMat : unlitMat);
		loadModelSuccess = true;
		Pvr_ControllerVisual pvr_ControllerVisual = gameObject.AddComponent<Pvr_ControllerVisual>();
		switch (controllerType)
		{
		case 1:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Goblin;
			break;
		case 3:
			pvr_ControllerVisual.currentDevice = ControllerDevice.G2;
			break;
		case 4:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo2;
			break;
		case 5:
			pvr_ControllerVisual.currentDevice = ControllerDevice.Neo3;
			break;
		default:
			pvr_ControllerVisual.currentDevice = ControllerDevice.NewController;
			break;
		}
		pvr_ControllerVisual.variety = Variety;
		LoadTexture(pvr_ControllerVisual, controllerType.ToString() + id, fromRes: false);
		gameObject.transform.localRotation = Quaternion.Euler(new Vector3(0f, 180f, 0f));
		gameObject.transform.localScale = new Vector3(-0.01f, 0.01f, 0.01f);
	}

	private void LoadTexture(Pvr_ControllerVisual visual, string controllerName, bool fromRes)
	{
		if (fromRes)
		{
			texFormat = "";
			prePath = controllerName;
		}
		else
		{
			texFormat = "." + (string)curControllerData["tex_format"];
			prePath = modelFilePath + controllerName;
		}
		string filepath = prePath + "_idle" + texFormat;
		visual.m_idle = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_app" + texFormat;
		visual.m_app = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_home" + texFormat;
		visual.m_home = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_touch" + texFormat;
		visual.m_touchpad = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_down" + texFormat;
		visual.m_volDn = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_volume_up" + texFormat;
		visual.m_volUp = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_trigger" + texFormat;
		visual.m_trigger = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_a" + texFormat;
		visual.m_a = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_b" + texFormat;
		visual.m_b = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_x" + texFormat;
		visual.m_x = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_y" + texFormat;
		visual.m_y = LoadOneTexture(filepath, fromRes);
		filepath = prePath + "_grip" + texFormat;
		visual.m_grip = LoadOneTexture(filepath, fromRes);
	}

	private Texture2D LoadOneTexture(string filepath, bool fromRes)
	{
		if (fromRes)
		{
			return Resources.Load<Texture2D>(filepath);
		}
		int width = (int)curControllerData["tex_width"];
		int height = (int)curControllerData["tex_height"];
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadPNG(filepath));
		return texture2D;
	}

	private byte[] ReadPNG(string path)
	{
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}
}
public class Pvr_ControllerLink
{
	public AndroidJavaClass javaHummingbirdClass;

	public AndroidJavaClass javaPico2ReceiverClass;

	public AndroidJavaClass javaserviceClass;

	public AndroidJavaClass javavractivityclass;

	public AndroidJavaClass javaCVClass;

	public AndroidJavaObject activity;

	public string gameobjname = "";

	public bool picoDevice;

	public string hummingBirdMac;

	public int hummingBirdRSSI;

	public bool goblinserviceStarted;

	public bool neoserviceStarted;

	public bool controller0Connected;

	public bool controller1Connected;

	public int mainHandID;

	public Pvr_Controller.UserHandNess handness;

	public int controllerType;

	public ControllerHand Controller0;

	public ControllerHand Controller1;

	public int platFormType = -1;

	public int trackingmode = -1;

	public int systemProp = -1;

	public int enablehand6dofbyhead = -1;

	public bool switchHomeKey = true;

	private int iPhoneHMDModeEnabled;

	private float[] hbPoseData = new float[4];

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private int[] neo3TouchValue = new int[15];

	private float[] fixedState = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private float[] neoposeData = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };

	private int[] goblinKeyArray = new int[47];

	private int[] neoKeyArray = new int[67];

	private int[] neotriggerV = new int[9];

	private float[] velocity = new float[3];

	private float[] angularVelocity = new float[3];

	private float[] acceData = new float[3];

	public Pvr_ControllerLink(string name)
	{
		gameobjname = name;
		hummingBirdMac = "";
		hummingBirdRSSI = 0;
		UnityEngine.Debug.Log("PvrLog Controller GameObject:" + gameobjname);
		StartHummingBirdService();
		Controller0 = new ControllerHand();
		Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
		Controller1 = new ControllerHand();
		Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
	}

	private void StartHummingBirdService()
	{
		try
		{
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaHummingbirdClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientActivity");
			javaCVClass = new AndroidJavaClass("com.picovr.picovrlib.cvcontrollerclient.ControllerClient");
			javavractivityclass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaHummingbirdClass.GetRawClass());
			Render.UPvr_GetIntConfig(4, ref platFormType);
			UnityEngine.Debug.Log("PvrLog platform" + platFormType);
			Render.UPvr_GetIntConfig(5, ref trackingmode);
			UnityEngine.Debug.Log("PvrLog trackingmode" + trackingmode);
			systemProp = GetSysproc();
			UnityEngine.Debug.Log("PvrLog systemProp" + systemProp);
			Render.UPvr_GetIntConfig(7, ref enablehand6dofbyhead);
			UnityEngine.Debug.Log("PvrLog enablehand6dofbyhead" + enablehand6dofbyhead);
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				picoDevice = platFormType != 0;
				javaPico2ReceiverClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.HbClientReceiver");
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setPlatformType", platFormType);
			}
			else
			{
				picoDevice = true;
				SetGameObjectToJar(gameobjname);
			}
			Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
			if (iPhoneHMDModeEnabled == 1)
			{
				BindService();
			}
			else if (IsServiceExisted())
			{
				BindService();
			}
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
	}

	public bool IsServiceExisted()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "isServiceExisted", activity, trackingmode);
		UnityEngine.Debug.Log("PvrLog ServiceExisted ?" + result);
		return result;
	}

	public void SetGameObjectToJar(string name)
	{
		UnityEngine.Debug.Log("PvrLog SetGameObjectToJar " + name);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setGameObjectCallback", name);
	}

	public void BindService()
	{
		UnityEngine.Debug.Log("PvrLog Bind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "bindService", activity, trackingmode);
	}

	public void UnBindService()
	{
		UnityEngine.Debug.Log("PvrLog UnBind Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaserviceClass, "unbindService", activity, trackingmode);
	}

	public void StopLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopOnBootReceiver", activity);
	}

	public void StartLark2Receiver()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Receiver");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
	}

	public void StopLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StopLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "stopReceiver", activity);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "unbindHbService", activity);
	}

	public void StartLark2Service()
	{
		UnityEngine.Debug.Log("PvrLog StartLark2Service");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaPico2ReceiverClass, "startReceiver", activity, gameobjname);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "bindHbService", activity);
	}

	public int getHandness()
	{
		int result = -1;
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javavractivityclass, "getPvrHandness", activity);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbHandednessInSP");
		}
		PLOG.I("PvrLog GetHandness =" + result);
		return result;
	}

	public void setHandness(int hand)
	{
		PLOG.I("PvrLog SetHandness =" + hand);
		if (iPhoneHMDModeEnabled == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setHbHandednessInSP", hand);
		}
	}

	public void StartScan()
	{
		PLOG.I("PvrLog ScanHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", true);
	}

	public void StopScan()
	{
		PLOG.I("PvrLog StopScanHBController");
		if (iPhoneHMDModeEnabled == 0)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "scanHbDevice", false);
		}
	}

	public int GetSysproc()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaserviceClass, "getSysproc");
		PLOG.I("PvrLog GetSysproc" + result);
		return result;
	}

	public void ResetController(int num)
	{
		UnityEngine.Debug.Log("PvrLog ResetController" + num);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetControllerSensorState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "resetHbSensorState");
		}
	}

	public void ConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog ConnectHBController" + hummingBirdMac);
		if (hummingBirdMac != "")
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "connectHbController", hummingBirdMac);
		}
	}

	public void DisConnectBLE()
	{
		UnityEngine.Debug.Log("PvrLog DisConnectHBController");
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "disconnectHbController");
	}

	public bool StartUpgrade()
	{
		UnityEngine.Debug.Log("PvrLog StartUpgradeHBController");
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "startUpgrade");
		return result;
	}

	public void setBinPath(string path, bool isasset)
	{
		UnityEngine.Debug.Log("PvrLog setBinPath" + path + isasset);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBinPath", path, isasset);
	}

	public string GetBLEImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEImageType" + result);
		return result;
	}

	public long GetBLEVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getBLEVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetBLEVersion" + result);
		return result;
	}

	public string GetFileImageType()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileImageType");
		}
		UnityEngine.Debug.Log("PvrLog GetFileImageType" + result);
		return result;
	}

	public long GetFileVersion()
	{
		long result = 0L;
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getFileVersion");
		}
		UnityEngine.Debug.Log("PvrLog GetFileVersion" + result);
		return result;
	}

	public int GetControllerConnectionState(int num)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerConnectionState", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHbConnectionState");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerState:" + num + "state:" + result);
		}
		return result;
	}

	public void RebackToLauncher()
	{
		UnityEngine.Debug.Log("PvrLog RebackToLauncher");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startLauncher");
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "startLauncher");
		}
	}

	public void TurnUpVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnUpVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnUpVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnUpVolume", activity);
		}
	}

	public void TurnDownVolume()
	{
		UnityEngine.Debug.Log("PvrLog TurnDownVolume");
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "turnDownVolume", activity);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "turnDownVolume", activity);
		}
	}

	public float[] GetHBControllerPoseData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref hbPoseData, javaHummingbirdClass, "getHBSensorPose");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerData" + hbPoseData[0] + "," + hbPoseData[1] + "," + hbPoseData[2] + "," + hbPoseData[3]);
		}
		return hbPoseData;
	}

	public float[] GetControllerSensorData()
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem", Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref sensorData, javaCVClass, "getControllerDataInfoBySharmem");
		}
		return sensorData;
	}

	public int[] GetControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref keyData, javaCVClass, "getDoubleControllerKeyEventUnityExtBySharmem");
		return keyData;
	}

	public int[] GetNeo3TouchData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neo3TouchValue, javaCVClass, "getControllerTouchEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3Touch hand:" + hand + "-" + neo3TouchValue[0] + neo3TouchValue[1] + neo3TouchValue[2] + neo3TouchValue[3] + neo3TouchValue[4] + "," + neo3TouchValue[5] + neo3TouchValue[6] + neo3TouchValue[7] + neo3TouchValue[8] + neo3TouchValue[9] + "," + neo3TouchValue[10] + neo3TouchValue[11] + neo3TouchValue[12] + neo3TouchValue[13] + neo3TouchValue[14]);
		}
		return neo3TouchValue;
	}

	public int GetNeo3GripValue(int hand)
	{
		int result = 0;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerGripValue", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Neo3GripValue:" + result);
		}
		return result;
	}

	public float[] GetControllerFixedSensorState(int hand)
	{
		if (trackingmode == 2 || trackingmode == 3)
		{
			return fixedState;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref fixedState, javaCVClass, "getControllerFixedSensorState", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GetControllerFixedSensorState " + hand + "Rotation:" + fixedState[0] + "," + fixedState[1] + "," + fixedState[2] + "," + fixedState[3] + "Position:" + fixedState[4] + "," + fixedState[5] + "," + fixedState[6]);
		}
		return fixedState;
	}

	public float[] GetCvControllerPoseData(int hand)
	{
		if (enablehand6dofbyhead == 1)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand, Pvr_UnitySDKManager.SDK.headData);
		}
		else
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoposeData, javaCVClass, "getControllerSensorState", hand);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerData :" + neoposeData[0] + "," + neoposeData[1] + "," + neoposeData[2] + "," + neoposeData[3] + "," + neoposeData[4] + "," + neoposeData[5] + "," + neoposeData[6]);
		}
		return neoposeData;
	}

	public int[] GetHBControllerKeyData()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref goblinKeyArray, javaHummingbirdClass, "getHBKeyEventUnityExt");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog HBControllerKey" + goblinKeyArray[0] + goblinKeyArray[1] + goblinKeyArray[2] + goblinKeyArray[3] + goblinKeyArray[4] + "," + goblinKeyArray[5] + goblinKeyArray[6] + goblinKeyArray[7] + goblinKeyArray[8] + goblinKeyArray[9] + "," + goblinKeyArray[10] + goblinKeyArray[11] + goblinKeyArray[12] + goblinKeyArray[13] + goblinKeyArray[14] + "," + goblinKeyArray[15] + goblinKeyArray[16] + goblinKeyArray[17] + goblinKeyArray[18] + goblinKeyArray[19] + "," + goblinKeyArray[20] + goblinKeyArray[21] + goblinKeyArray[22] + goblinKeyArray[23] + goblinKeyArray[24] + "," + goblinKeyArray[25] + goblinKeyArray[26] + goblinKeyArray[27] + goblinKeyArray[28] + goblinKeyArray[29] + "," + goblinKeyArray[30] + goblinKeyArray[31] + goblinKeyArray[32] + goblinKeyArray[33] + goblinKeyArray[34] + "," + goblinKeyArray[35] + goblinKeyArray[36] + goblinKeyArray[37] + goblinKeyArray[38] + goblinKeyArray[39] + "," + goblinKeyArray[40] + goblinKeyArray[41] + goblinKeyArray[42] + goblinKeyArray[43] + goblinKeyArray[44] + "," + goblinKeyArray[45] + goblinKeyArray[46]);
		}
		return goblinKeyArray;
	}

	public int GetHBKeyValue()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTriggerKeyEvent");
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog GoblinControllerTriggerKey:" + result);
		}
		return result;
	}

	public int[] GetCvControllerKeyData(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neoKeyArray, javaCVClass, "getControllerKeyEventUnityExt", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVControllerKey hand:" + hand + "-" + neoKeyArray[0] + neoKeyArray[1] + neoKeyArray[2] + neoKeyArray[3] + neoKeyArray[4] + "," + neoKeyArray[5] + neoKeyArray[6] + neoKeyArray[7] + neoKeyArray[8] + neoKeyArray[9] + "," + neoKeyArray[10] + neoKeyArray[11] + neoKeyArray[12] + neoKeyArray[13] + neoKeyArray[14] + "," + neoKeyArray[15] + neoKeyArray[16] + neoKeyArray[17] + neoKeyArray[18] + neoKeyArray[19] + "," + neoKeyArray[20] + neoKeyArray[21] + neoKeyArray[22] + neoKeyArray[23] + neoKeyArray[24] + "," + neoKeyArray[25] + neoKeyArray[26] + neoKeyArray[27] + neoKeyArray[28] + neoKeyArray[29] + "," + neoKeyArray[30] + neoKeyArray[31] + neoKeyArray[32] + neoKeyArray[33] + neoKeyArray[34] + "," + neoKeyArray[35] + neoKeyArray[36] + neoKeyArray[37] + neoKeyArray[38] + neoKeyArray[39] + "," + neoKeyArray[40] + neoKeyArray[41] + neoKeyArray[42] + neoKeyArray[43] + neoKeyArray[44] + "," + neoKeyArray[45] + neoKeyArray[46] + neoKeyArray[47] + neoKeyArray[48] + neoKeyArray[49] + "," + neoKeyArray[50] + neoKeyArray[51] + neoKeyArray[52] + neoKeyArray[53] + neoKeyArray[54] + "," + neoKeyArray[55] + neoKeyArray[56] + neoKeyArray[57] + neoKeyArray[58] + neoKeyArray[59] + "," + neoKeyArray[60] + neoKeyArray[61] + neoKeyArray[62] + neoKeyArray[63] + neoKeyArray[64] + "," + neoKeyArray[65] + neoKeyArray[66]);
		}
		return neoKeyArray;
	}

	public int GetCVTriggerValue(int hand)
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref neotriggerV, javaCVClass, "getControllerKeyEvent", hand);
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog CVTriggerValue " + neotriggerV[7]);
		}
		return neotriggerV[7];
	}

	public void AutoConnectHbController(int scanTimeMs)
	{
		PLOG.I("PvrLog AutoConnectHbController" + scanTimeMs);
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "autoConnectHbController", scanTimeMs, gameobjname);
	}

	public void StartControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StartControllerThread" + headSensorState + handSensorState);
	}

	public void StopControllerThread(int headSensorState, int handSensorState)
	{
		if (BoundarySystem.UPvr_IsBoundaryEnable())
		{
			headSensorState = 1;
			handSensorState = 1;
		}
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopControllerThread", headSensorState, handSensorState);
		UnityEngine.Debug.Log("PvrLog StopControllerThread" + headSensorState + handSensorState);
	}

	public void SetUnityVersionToJar(string version)
	{
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setUnityVersion", version);
		}
		UnityEngine.Debug.Log("PvrLog SetUnityVersionToJar" + version);
	}

	public Vector3 GetVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref velocity, javaCVClass, "getControllerLinearVelocity", num);
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Velocity" + velocity[0] + "," + velocity[1] + "," + velocity[2]);
		}
		return new Vector3(velocity[0], velocity[1], 0f - velocity[2]);
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaCVClass, "getControllerAngularVelocity", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref angularVelocity, javaHummingbirdClass, "getHbAngularVelocity");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Gyro:" + angularVelocity[0] + "," + angularVelocity[1] + "," + angularVelocity[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaCVClass, "getControllerAcceleration", num);
		}
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref acceData, javaHummingbirdClass, "getHbAcceleration");
		}
		if (PLOG.logLevel > 2)
		{
			PLOG.D("PvrLog Acce:" + acceData[0] + acceData[1] + acceData[2]);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public string GetConnectedDeviceMac()
	{
		string result = "";
		if (goblinserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getConnectedDeviceMac");
		}
		PLOG.I("PvrLog ConnectedDeviceMac:" + result);
		return result;
	}

	public void VibrateNeo2Controller(float strength, int time, int hand)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "vibrateCV2ControllerStrength", strength, time, hand);
		}
		PLOG.I("PvrLog VibrateNeo2Controller:" + strength + time + hand);
	}

	public int GetMainControllerIndex()
	{
		int result = 0;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getMainControllerIndex");
		}
		PLOG.I("PvrLog GetMainControllerIndex:" + result);
		return result;
	}

	public void SetMainController(int index)
	{
		PLOG.I("PvrLog SetMainController:" + index);
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setMainController", index);
		}
	}

	public void ResetHeadSensorForController()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "resetHeadSensorForController");
		}
		PLOG.I("PvrLog ResetHeadSensorForController:");
	}

	public void GetDeviceVersion(int deviceType)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getDeviceVersion", deviceType);
		}
		PLOG.I("PvrLog GetDeviceVersion:" + deviceType);
	}

	public void GetControllerSnCode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerSnCode", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerSnCode:" + controllerSerialNum);
	}

	public void SetControllerUnbind(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerUnbind", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerUnbind:" + controllerSerialNum);
	}

	public void SetStationRestart()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setStationRestart");
		}
		PLOG.I("PvrLog SetStationRestart");
	}

	public void StartStationOtaUpdate()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startStationOtaUpdate");
		}
		PLOG.I("PvrLog StartStationOtaUpdate");
	}

	public void StartControllerOtaUpdate(int mode, int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startControllerOtaUpdate", mode, controllerSerialNum);
		}
		PLOG.I("PvrLog StartControllerOtaUpdate" + mode + controllerSerialNum);
	}

	public void EnterPairMode(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "enterPairMode", controllerSerialNum);
		}
		PLOG.I("PvrLog EnterPairMode" + controllerSerialNum);
	}

	public void SetControllerShutdown(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setControllerShutdown", controllerSerialNum);
		}
		PLOG.I("PvrLog SetControllerShutdown" + controllerSerialNum);
	}

	public int GetStationPairState()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationPairState");
		}
		PLOG.I("PvrLog StationPairState" + result);
		return result;
	}

	public int GetStationOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getStationOtaUpdateProgress");
		}
		PLOG.I("PvrLog StationOtaUpdateProgress" + result);
		return result;
	}

	public int GetControllerOtaUpdateProgress()
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerOtaUpdateProgress");
		}
		PLOG.I("PvrLog ControllerOtaUpdateProgress" + result);
		return result;
	}

	public void GetControllerVersionAndSN(int controllerSerialNum)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerVersionAndSN", controllerSerialNum);
		}
		PLOG.I("PvrLog GetControllerVersionAndSN" + controllerSerialNum);
	}

	public void GetControllerUniqueID()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "getControllerUniqueID");
		}
		PLOG.I("PvrLog GetControllerUniqueID");
	}

	public void InterruptStationPairMode()
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "interruptStationPairMode");
		}
		PLOG.I("PvrLog InterruptStationPairMode");
	}

	public int GetControllerAbility(int controllerSerialNum)
	{
		int result = -1;
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerAbility", controllerSerialNum);
		}
		PLOG.I("PvrLog ControllerAbility:" + result);
		return result;
	}

	public void SwitchHomeKey(bool state)
	{
		PLOG.I("PvrLog SwitchHomeKey:" + state);
		switchHomeKey = state;
	}

	public void SetBootReconnect()
	{
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaHummingbirdClass, "setBootReconnect");
		PLOG.I("PvrLog SetBootReconnect");
	}

	public int GetTemperature()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getTemperature");
		PLOG.I("PvrLog Temperature:" + result);
		return result;
	}

	public int GetDeviceType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getDeviceType");
		PLOG.I("PvrLog DeviceType:" + result);
		return result;
	}

	public int GetControllerType()
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerType");
		return result;
	}

	public string GetHummingBird2SN()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getHummingBird2SN");
		PLOG.I("PvrLog HummingBird2SN:" + result);
		return result;
	}

	public string GetControllerVersion()
	{
		string result = "";
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "getControllerVersion");
		PLOG.I("PvrLog ControllerVersion:" + result);
		return result;
	}

	public bool IsEnbleTrigger()
	{
		bool result = false;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaHummingbirdClass, "isEnbleTrigger");
		PLOG.I("PvrLog IsEnbleTrigger:" + result);
		return result;
	}

	public void StartCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "startCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StartCV2PairingMode:" + devicetype);
	}

	public void StopCV2PairingMode(int devicetype)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "stopCV2PairingMode", devicetype);
		}
		PLOG.I("PvrLog StopCV2PairingMode:" + devicetype);
	}

	public int GetControllerBindingState(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerBindingState", id);
		PLOG.I("PvrLog getControllerBindingState:" + result);
		return result;
	}

	public void setIsEnbleHomeKey(bool state)
	{
		if (neoserviceStarted)
		{
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(javaCVClass, "setIsEnbleHomeKey", state);
		}
		PLOG.I("PvrLog setIsEnbleHomeKey:" + state);
	}

	public int getControllerSensorStatus(int id)
	{
		int result = -1;
		Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaCVClass, "getControllerSensorStatus", id);
		PLOG.I("PvrLog getControllerSensorStatus:" + result);
		return result;
	}
}
public class Pvr_ControllerManager : MonoBehaviour
{
	public delegate void PvrServiceStartSuccess();

	public delegate void PvrControllerStateChanged(string data);

	public delegate void ChangeMainControllerCallBack(string index);

	public delegate void ChangeHandNessCallBack(string index);

	public delegate void SetHbServiceBindState();

	public delegate void ControllerThreadStartedCallback();

	public delegate void SetControllerServiceBindState();

	public delegate void ControllerStatusChange(string isconnect);

	public delegate void SetControllerAbility(string data);

	public delegate void SetControllerStateChanged(string data);

	public delegate void SetHbControllerMac(string mac);

	public delegate void ControllerDeviceVersionCallback(string data);

	public delegate void ControllerSnCodeCallback(string data);

	public delegate void ControllerUnbindCallback(string status);

	public delegate void ControllerStationStatusCallback(string status);

	public delegate void ControllerStationBusyCallback(string status);

	public delegate void ControllerOtaStartCodeCallback(string data);

	public delegate void ControllerDeviceVersionAndSNCallback(string data);

	public delegate void ControllerUniqueIDCallback(string data);

	public delegate void ControllerCombinedKeyUnbindCallback(string data);

	private static Pvr_ControllerManager instance;

	public static Pvr_ControllerLink controllerlink;

	private float cTime = 1f;

	private bool stopConnect;

	public Text toast;

	private bool controllerServicestate;

	private float disConnectTime;

	public bool LengthAdaptiveRay;

	private float[] sensorData = new float[28];

	private int[] keyData = new int[134];

	private float[] g2SensorData = new float[4];

	private int[] g2KeyData = new int[47];

	private int keyOffset;

	private int rotControllerMode = 1;

	public static Pvr_ControllerManager Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
			}
			if (instance == null)
			{
				GameObject obj = new GameObject("GameObject");
				instance = obj.AddComponent<Pvr_ControllerManager>();
				obj.transform.localPosition = Vector3.zero;
			}
			return instance;
		}
	}

	public static event PvrServiceStartSuccess PvrServiceStartSuccessEvent;

	public static event PvrControllerStateChanged PvrControllerStateChangedEvent;

	public static event ChangeMainControllerCallBack ChangeMainControllerCallBackEvent;

	public static event ChangeHandNessCallBack ChangeHandNessCallBackEvent;

	public static event SetHbServiceBindState SetHbServiceBindStateEvent;

	public static event ControllerThreadStartedCallback ControllerThreadStartedCallbackEvent;

	public static event SetControllerServiceBindState SetControllerServiceBindStateEvent;

	public static event ControllerStatusChange ControllerStatusChangeEvent;

	public static event SetControllerAbility SetControllerAbilityEvent;

	public static event SetControllerStateChanged SetControllerStateChangedEvent;

	public static event SetHbControllerMac SetHbControllerMacEvent;

	public static event ControllerDeviceVersionCallback ControllerDeviceVersionCallbackEvent;

	public static event ControllerSnCodeCallback ControllerSnCodeCallbackEvent;

	public static event ControllerUnbindCallback ControllerUnbindCallbackEvent;

	public static event ControllerStationStatusCallback ControllerStationStatusCallbackEvent;

	public static event ControllerStationBusyCallback ControllerStationBusyCallbackEvent;

	public static event ControllerOtaStartCodeCallback ControllerOtaStartCodeCallbackEvent;

	public static event ControllerDeviceVersionAndSNCallback ControllerDeviceVersionAndSNCallbackEvent;

	public static event ControllerUniqueIDCallback ControllerUniqueIDCallbackEvent;

	public static event ControllerCombinedKeyUnbindCallback ControllerCombinedKeyUnbindCallbackEvent;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			PLOG.E("instance object should be a singleton.");
			return;
		}
		if (controllerlink == null)
		{
			controllerlink = new Pvr_ControllerLink(base.gameObject.name);
			return;
		}
		controllerlink.SetGameObjectToJar(base.gameObject.name);
		BindService();
	}

	private void Start()
	{
		if (controllerlink.trackingmode < 2)
		{
			Invoke("CheckControllerService", 10f);
		}
		Render.UPvr_GetIntConfig(23, ref rotControllerMode);
	}

	private void Update()
	{
		if (controllerlink.neoserviceStarted)
		{
			sensorData = controllerlink.GetControllerSensorData();
			keyData = controllerlink.GetControllerKeyData();
			if (controllerlink.controller0Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[2] = 0f - sensorData[2];
					sensorData[3] = 0f - sensorData[3];
					controllerlink.Controller0.Rotation.Set(sensorData[0], sensorData[1], sensorData[2], sensorData[3]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[4] / 1000f, sensorData[5] / 1000f, (0f - sensorData[6]) / 1000f);
				}
				else
				{
					controllerlink.Controller0.Rotation.Set(sensorData[7], sensorData[8], sensorData[9], sensorData[10]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller0.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller0.Position.Set(sensorData[11] / 1000f, sensorData[12] / 1000f, (0f - sensorData[13]) / 1000f);
				}
				if (!controllerlink.Controller0.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(0) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
					}
					else
					{
						controllerlink.Controller0.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: true, Convert.ToInt32(Convert.ToString(keyData[35]) + Convert.ToString(keyData[15]) + "00", 2));
				}
				TransformData(controllerlink.Controller0, 0, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[0], sensorData[1], sensorData[2], sensorData[3], sensorData[4], sensorData[5], sensorData[6], 0, valid: false, 0);
			}
			if (controllerlink.controller1Connected)
			{
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					sensorData[16] = 0f - sensorData[16];
					sensorData[17] = 0f - sensorData[17];
					controllerlink.Controller1.Rotation.Set(sensorData[14], sensorData[15], sensorData[16], sensorData[17]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[18] / 1000f, sensorData[19] / 1000f, (0f - sensorData[20]) / 1000f);
				}
				else
				{
					controllerlink.Controller1.Rotation.Set(sensorData[21], sensorData[22], sensorData[23], sensorData[24]);
					if (rotControllerMode == 0)
					{
						controllerlink.Controller1.Rotation *= Quaternion.Euler(34f, 0f, 0f);
					}
					controllerlink.Controller1.Position.Set(sensorData[25] / 1000f, sensorData[26] / 1000f, (0f - sensorData[27]) / 1000f);
				}
				if (!controllerlink.Controller1.isShowBoundary)
				{
					if (controllerlink.getControllerSensorStatus(1) == 0)
					{
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
					}
					else
					{
						controllerlink.Controller1.isShowBoundary = true;
						Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
					}
				}
				else
				{
					Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: true, Convert.ToInt32(Convert.ToString(keyData[102]) + Convert.ToString(keyData[82]) + "00", 2));
				}
				TransformData(controllerlink.Controller1, 1, keyData);
			}
			else
			{
				Sensor.UPvr_SetReinPosition(sensorData[14], sensorData[15], sensorData[16], sensorData[17], sensorData[18], sensorData[19], sensorData[20], 1, valid: false, 0);
			}
		}
		if (controllerlink.goblinserviceStarted && controllerlink.controller0Connected)
		{
			g2SensorData = controllerlink.GetHBControllerPoseData();
			controllerlink.Controller0.Rotation.Set(g2SensorData[0], g2SensorData[1], g2SensorData[2], g2SensorData[3]);
			g2KeyData = controllerlink.GetHBControllerKeyData();
			TransformData(controllerlink.Controller0, 0, g2KeyData);
		}
		SetSystemKey();
	}

	private void OnApplicationPause(bool pause)
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (pause)
		{
			if (controllerlink.neoserviceStarted)
			{
				controllerlink.SetGameObjectToJar("");
				controllerlink.StopControllerThread(headSensorState, handSensorState);
			}
			if (controllerlink.goblinserviceStarted)
			{
				controllerlink.StopLark2Receiver();
			}
			return;
		}
		controllerlink.Controller0 = new ControllerHand();
		controllerlink.Controller1 = new ControllerHand();
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar(base.gameObject.name);
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.StartControllerThread(headSensorState, handSensorState);
		}
		if (controllerlink.goblinserviceStarted)
		{
			controllerlink.StartLark2Receiver();
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	private void OnDestroy()
	{
		controllerlink.UnBindService();
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 0, valid: false, 0);
		Sensor.UPvr_SetReinPosition(0f, 0f, 0f, 1f, 0f, 0f, 0f, 1, valid: false, 0);
	}

	private void OnApplicationQuit()
	{
		int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
		int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
		if (controllerlink.neoserviceStarted)
		{
			controllerlink.SetGameObjectToJar("");
			controllerlink.StopControllerThread(headSensorState, handSensorState);
		}
	}

	public void StopLark2Service()
	{
		if (controllerlink != null)
		{
			controllerlink.StopLark2Service();
		}
	}

	public Vector3 GetAngularVelocity(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAngularVelocity(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public Vector3 GetAcceleration(int num)
	{
		if (controllerlink != null)
		{
			return controllerlink.GetAcceleration(num);
		}
		return new Vector3(0f, 0f, 0f);
	}

	public void BindService()
	{
		if (controllerlink != null)
		{
			controllerlink.BindService();
		}
	}

	public void StartScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StartScan();
		}
	}

	public void StopScan()
	{
		if (controllerlink != null)
		{
			controllerlink.StopScan();
		}
	}

	public void ResetController(int num)
	{
		if (controllerlink != null)
		{
			controllerlink.ResetController(num);
		}
	}

	public static int GetControllerConnectionState(int num)
	{
		return controllerlink.GetControllerConnectionState(num);
	}

	public void ConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.ConnectBLE();
		}
	}

	public void DisConnectBLE()
	{
		if (controllerlink != null)
		{
			controllerlink.DisConnectBLE();
		}
	}

	public void SetBinPath(string path, bool isAsset)
	{
		if (controllerlink != null)
		{
			controllerlink.setBinPath(path, isAsset);
		}
	}

	public void StartUpgrade()
	{
		if (controllerlink != null)
		{
			controllerlink.StartUpgrade();
		}
	}

	public static string GetBLEImageType()
	{
		return controllerlink.GetBLEImageType();
	}

	public static long GetBLEVersion()
	{
		return controllerlink.GetBLEVersion();
	}

	public static string GetFileImageType()
	{
		return controllerlink.GetFileImageType();
	}

	public static long GetFileVersion()
	{
		return controllerlink.GetFileVersion();
	}

	public static void AutoConnectHbController(int scans)
	{
		if (controllerlink != null)
		{
			controllerlink.AutoConnectHbController(scans);
		}
	}

	public static string GetConnectedDeviceMac()
	{
		string result = "";
		if (controllerlink != null)
		{
			result = controllerlink.GetConnectedDeviceMac();
		}
		return result;
	}

	public void setHbControllerMac(string mac)
	{
		PLOG.I("PvrLog HBMacRSSI" + mac);
		controllerlink.hummingBirdMac = mac.Substring(0, 17);
		controllerlink.hummingBirdRSSI = Convert.ToInt16(mac.Remove(0, 18));
		if (Pvr_ControllerManager.SetHbControllerMacEvent != null)
		{
			Pvr_ControllerManager.SetHbControllerMacEvent(mac.Substring(0, 17));
		}
	}

	public int GetControllerRSSI()
	{
		return controllerlink.hummingBirdRSSI;
	}

	public void setHbServiceBindState(string state)
	{
		PLOG.I("PvrLog HBBindCallBack" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.goblinserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.goblinserviceStarted = true;
			controllerlink.controller0Connected = GetControllerConnectionState(0) == 1;
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
			if (Pvr_ControllerManager.SetHbServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetHbServiceBindStateEvent();
			}
			if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
			{
				Pvr_ControllerManager.PvrServiceStartSuccessEvent();
			}
		}
	}

	public void setControllerServiceBindState(string state)
	{
		PLOG.I("PvrLog CVBindCallBack" + state);
		if (Convert.ToInt16(state) == 0)
		{
			Invoke("BindService", 0.5f);
			controllerlink.neoserviceStarted = false;
		}
		else if (Convert.ToInt16(state) == 1)
		{
			controllerlink.SetUnityVersionToJar("2.8.9.12");
			controllerlink.neoserviceStarted = true;
			int headSensorState = ((!Pvr_UnitySDKManager.SDK.HmdOnlyrot) ? 1 : 0);
			int handSensorState = ((!Pvr_UnitySDKManager.SDK.ControllerOnlyrot) ? 1 : 0);
			controllerlink.StartControllerThread(headSensorState, handSensorState);
			if (Pvr_ControllerManager.SetControllerServiceBindStateEvent != null)
			{
				Pvr_ControllerManager.SetControllerServiceBindStateEvent();
			}
		}
	}

	public void setHbControllerConnectState(string isconnect)
	{
		PLOG.I("PvrLog HBControllerConnect" + isconnect);
		controllerlink.controller0Connected = Convert.ToInt16(isconnect) == 1;
		if (!controllerlink.controller0Connected)
		{
			controllerlink.Controller0 = new ControllerHand();
		}
		else
		{
			ResetController(0);
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
		stopConnect = false;
		if (Pvr_ControllerManager.ControllerStatusChangeEvent != null)
		{
			Pvr_ControllerManager.ControllerStatusChangeEvent(isconnect);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(isconnect);
		}
	}

	public void setControllerStateChanged(string state)
	{
		PLOG.I("PvrLog CVControllerStateChanged" + state);
		int num = Convert.ToInt16(state.Substring(0, 1));
		if (num == 0)
		{
			controllerlink.controller0Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller0Connected)
			{
				controllerlink.Controller0 = new ControllerHand();
				controllerlink.Controller0.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(-0.1f, -0.3f, 0.3f);
			}
		}
		else
		{
			controllerlink.controller1Connected = Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1)));
			if (!controllerlink.controller1Connected)
			{
				controllerlink.Controller1 = new ControllerHand();
				controllerlink.Controller1.Position = new Vector3(0f, Pvr_UnitySDKSensor.Instance.HeadPose.Position.y, 0f) + new Vector3(0.1f, -0.3f, 0.3f);
			}
		}
		if (Convert.ToBoolean(Convert.ToInt16(state.Substring(2, 1))))
		{
			controllerlink.controllerType = controllerlink.GetControllerType();
			controllerlink.ResetController(num);
		}
		controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
		if (Pvr_ControllerManager.SetControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.SetControllerStateChangedEvent(state);
		}
		if (Pvr_ControllerManager.PvrControllerStateChangedEvent != null)
		{
			Pvr_ControllerManager.PvrControllerStateChangedEvent(state);
		}
	}

	public void setControllerAbility(string data)
	{
		PLOG.I("PvrLog setControllerAbility" + data);
		if (Pvr_ControllerManager.SetControllerAbilityEvent != null)
		{
			Pvr_ControllerManager.SetControllerAbilityEvent(data);
		}
	}

	public void controllerThreadStartedCallback()
	{
		PLOG.I("PvrLog ThreadStartSuccess");
		GetCVControllerState();
		if (Pvr_ControllerManager.ControllerThreadStartedCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerThreadStartedCallbackEvent();
		}
		if (Pvr_ControllerManager.PvrServiceStartSuccessEvent != null)
		{
			Pvr_ControllerManager.PvrServiceStartSuccessEvent();
		}
	}

	public void controllerDeviceVersionCallback(string data)
	{
		PLOG.I("PvrLog VersionCallBack" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionCallbackEvent(data);
		}
	}

	public void controllerSnCodeCallback(string data)
	{
		PLOG.I("PvrLog SNCodeCallBack" + data);
		if (Pvr_ControllerManager.ControllerSnCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerSnCodeCallbackEvent(data);
		}
	}

	public void controllerUnbindCallback(string status)
	{
		PLOG.I("PvrLog ControllerUnBindCallBack" + status);
		if (Pvr_ControllerManager.ControllerUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUnbindCallbackEvent(status);
		}
	}

	public void controllerStationStatusCallback(string status)
	{
		PLOG.I("PvrLog StationStatusCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationStatusCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationStatusCallbackEvent(status);
		}
	}

	public void controllerStationBusyCallback(string status)
	{
		PLOG.I("PvrLog StationBusyCallBack" + status);
		if (Pvr_ControllerManager.ControllerStationBusyCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerStationBusyCallbackEvent(status);
		}
	}

	public void controllerOTAStartCodeCallback(string data)
	{
		PLOG.I("PvrLog OTAUpdateCallBack" + data);
		if (Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerOtaStartCodeCallbackEvent(data);
		}
	}

	public void controllerDeviceVersionAndSNCallback(string data)
	{
		PLOG.I("PvrLog DeviceVersionAndSNCallback" + data);
		if (Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerDeviceVersionAndSNCallbackEvent(data);
		}
	}

	public void controllerUniqueIDCallback(string data)
	{
		PLOG.I("PvrLog controllerUniqueIDCallback" + data);
		if (Pvr_ControllerManager.ControllerUniqueIDCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerUniqueIDCallbackEvent(data);
		}
	}

	public void controllerCombinedKeyUnbindCallback(string controllerSerialNum)
	{
		if (Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent != null)
		{
			Pvr_ControllerManager.ControllerCombinedKeyUnbindCallbackEvent(controllerSerialNum);
		}
	}

	public void setupdateFailed()
	{
	}

	public void setupdateSuccess()
	{
	}

	public void setupdateProgress(string progress)
	{
	}

	public void setHbAutoConnectState(string state)
	{
		PLOG.I("PvrLog HBAutoConnectState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0 && GetControllerConnectionState(0) == 0)
		{
			ShowToast(2);
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(3);
		}
	}

	public void callbackControllerServiceState(string state)
	{
		PLOG.I("PvrLog HBServiceState" + state);
		controllerServicestate = true;
		if (Convert.ToInt16(state) == 0)
		{
			ShowToast(0);
		}
		if (Convert.ToInt16(state) == 1)
		{
			BindService();
		}
		if (Convert.ToInt16(state) == 2)
		{
			ShowToast(1);
		}
	}

	public void changeMainControllerCallback(string index)
	{
		PLOG.I("PvrLog MainControllerCallBack" + index);
		controllerlink.mainHandID = Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeMainControllerCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeMainControllerCallBackEvent(index);
		}
	}

	public void changeHandnessCallback(string index)
	{
		PLOG.I("PvrLog changeHandnessCallback" + index);
		controllerlink.handness = (Pvr_Controller.UserHandNess)Convert.ToInt16(index);
		if (Pvr_ControllerManager.ChangeHandNessCallBackEvent != null)
		{
			Pvr_ControllerManager.ChangeHandNessCallBackEvent(index);
		}
	}

	private void ShowToast(int type)
	{
		if (toast != null)
		{
			switch (type)
			{
			case 0:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip0");
				Invoke("HideToast", 5f);
				break;
			case 1:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip1");
				Invoke("HideToast", 5f);
				break;
			case 2:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip2");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 3:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip3");
				AutoConnectHbController(6000);
				Invoke("HideToast", 5f);
				break;
			case 4:
				toast.text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("servicetip4");
				Invoke("HideToast", 10f);
				break;
			}
		}
	}

	private void HideToast()
	{
		if (toast != null)
		{
			toast.text = "";
		}
	}

	private void CheckControllerService()
	{
		if (!controllerServicestate)
		{
			ShowToast(4);
		}
	}

	private void GetCVControllerState()
	{
		int controllerConnectionState = GetControllerConnectionState(0);
		int controllerConnectionState2 = GetControllerConnectionState(1);
		PLOG.I("PvrLog CVconnect" + controllerConnectionState + controllerConnectionState2);
		if (controllerConnectionState == -1 && controllerConnectionState2 == -1)
		{
			Invoke("GetCVControllerState", 0.02f);
		}
		if (controllerConnectionState != -1 && controllerConnectionState2 != -1)
		{
			controllerlink.controller0Connected = controllerConnectionState == 1;
			controllerlink.controller1Connected = controllerConnectionState2 == 1;
			if (!controllerlink.controller0Connected && controllerlink.controller1Connected && controllerlink.GetMainControllerIndex() == 0)
			{
				Controller.UPvr_SetMainHandNess(1);
			}
			if (controllerlink.controller0Connected || controllerlink.controller1Connected)
			{
				controllerlink.controllerType = controllerlink.GetControllerType();
			}
			controllerlink.mainHandID = controllerlink.GetMainControllerIndex();
			controllerlink.handness = (Pvr_Controller.UserHandNess)controllerlink.getHandness();
		}
	}

	private void SetSystemKey()
	{
		if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME) || Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME)))
		{
			if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 0);
			}
			else if (controllerlink.trackingmode == 0 || controllerlink.trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			if (Pvr_UnitySDKManager.SDK.ControllerOnlyrot || (controllerlink.controller0Connected && Controller.UPvr_GetControllerPOS(0).Equals(Vector3.zero)) || (controllerlink.controller1Connected && Controller.UPvr_GetControllerPOS(1).Equals(Vector3.zero)))
			{
				if (Controller.UPvr_GetKeyLongPressed(0, Pvr_KeyCode.HOME))
				{
					ResetController(0);
				}
				if (Controller.UPvr_GetKeyLongPressed(1, Pvr_KeyCode.HOME))
				{
					ResetController(1);
				}
			}
		}
		if (controllerlink.picoDevice)
		{
			if (controllerlink.switchHomeKey && (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.HOME) || (Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.HOME) && !stopConnect)))
			{
				controllerlink.RebackToLauncher();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEUP))
			{
				controllerlink.TurnUpVolume();
			}
			if (Controller.UPvr_GetKeyClick(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKeyClick(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				controllerlink.TurnDownVolume();
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN))
			{
				cTime = 1f;
			}
			if (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEUP) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEUP))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnUpVolume();
				}
			}
			if (!Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && !Controller.UPvr_GetKey(1, Pvr_KeyCode.HOME) && (Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) || Controller.UPvr_GetKey(1, Pvr_KeyCode.VOLUMEDOWN)))
			{
				cTime -= Time.deltaTime;
				if (cTime <= 0f)
				{
					cTime = 0.2f;
					controllerlink.TurnDownVolume();
				}
			}
		}
		if (controllerlink.goblinserviceStarted && Controller.UPvr_GetKey(0, Pvr_KeyCode.HOME) && Controller.UPvr_GetKey(0, Pvr_KeyCode.VOLUMEDOWN) && !stopConnect)
		{
			disConnectTime += Time.deltaTime;
			if ((double)disConnectTime > 1.0)
			{
				DisConnectBLE();
				controllerlink.hummingBirdMac = "";
				stopConnect = true;
				disConnectTime = 0f;
			}
		}
	}

	private void TransformData(ControllerHand hand, int handId, int[] data)
	{
		keyOffset = ((handId == 1) ? 67 : 0);
		hand.TouchPadPosition.x = data[keyOffset];
		hand.TouchPadPosition.y = data[5 + keyOffset];
		TransSingleKey(hand.Home, 10 + keyOffset, data);
		TransSingleKey(hand.App, 15 + keyOffset, data);
		TransSingleKey(hand.Touch, 20 + keyOffset, data);
		TransSingleKey(hand.VolumeUp, 25 + keyOffset, data);
		TransSingleKey(hand.VolumeDown, 30 + keyOffset, data);
		TransSingleKey(hand.Trigger, 35 + keyOffset, data);
		if (controllerlink.goblinserviceStarted && !controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetHBKeyValue();
		}
		if (!controllerlink.goblinserviceStarted && controllerlink.neoserviceStarted)
		{
			hand.TriggerNum = controllerlink.GetCVTriggerValue(handId);
		}
		hand.Battery = data[40 + keyOffset];
		if (data.Length == 47)
		{
			hand.SwipeDirection = (SwipeDirection)data[45];
			hand.TouchPadClick = (TouchPadClick)data[46];
		}
		else
		{
			switch (handId)
			{
			case 0:
				TransSingleKey(hand.X, 45 + keyOffset, data);
				TransSingleKey(hand.Y, 50 + keyOffset, data);
				TransSingleKey(hand.Left, 60 + keyOffset, data);
				break;
			case 1:
				TransSingleKey(hand.A, 45 + keyOffset, data);
				TransSingleKey(hand.B, 50 + keyOffset, data);
				TransSingleKey(hand.Right, 55 + keyOffset, data);
				break;
			}
			hand.SwipeDirection = (SwipeDirection)data[65 + keyOffset];
			hand.TouchPadClick = (TouchPadClick)data[66 + keyOffset];
		}
		hand.GripValue = controllerlink.GetNeo3GripValue(handId);
		TransformTouchData(hand, handId, controllerlink.GetNeo3TouchData(handId));
	}

	private void TransSingleKey(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.State = Convert.ToBoolean(data[beginIndex]);
		key.PressedDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.PressedUp = Convert.ToBoolean(data[beginIndex + 2]);
		key.LongPressed = Convert.ToBoolean(data[beginIndex + 3]);
		key.Click = Convert.ToBoolean(data[beginIndex + 4]);
	}

	private void TransformTouchData(ControllerHand hand, int handId, int[] data)
	{
		switch (handId)
		{
		case 0:
			TransSingleTouchValue(hand.X, 0, data);
			TransSingleTouchValue(hand.Y, 3, data);
			break;
		case 1:
			TransSingleTouchValue(hand.A, 0, data);
			TransSingleTouchValue(hand.B, 3, data);
			break;
		}
		TransSingleTouchValue(hand.Touch, 6, data);
		TransSingleTouchValue(hand.Trigger, 9, data);
		TransSingleTouchValue(hand.Thumbrest, 12, data);
	}

	private void TransSingleTouchValue(PvrControllerKey key, int beginIndex, int[] data)
	{
		key.Touch = Convert.ToBoolean(data[beginIndex]);
		key.TouchDown = Convert.ToBoolean(data[beginIndex + 1]);
		key.TouchUp = Convert.ToBoolean(data[beginIndex + 2]);
	}
}
public class Pvr_ControllerModuleInit : MonoBehaviour
{
	public ControllerVariety Variety;

	public bool IsCustomModel;

	[SerializeField]
	private GameObject dot;

	[SerializeField]
	private GameObject rayLine;

	[SerializeField]
	private GameObject controller;

	private bool moduleState = true;

	private void Awake()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent += ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent += ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent += MainControllerIDChanged;
		if (Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			rayLine = base.transform.GetComponentInChildren<LineRenderer>(includeInactive: true).gameObject;
			rayLine.GetComponent<LineRenderer>().startWidth = 0.003f;
			rayLine.GetComponent<LineRenderer>().endWidth = 0.0015f;
		}
	}

	private void OnDestroy()
	{
		Pvr_ControllerManager.PvrServiceStartSuccessEvent -= ServiceStartSuccess;
		Pvr_ControllerManager.PvrControllerStateChangedEvent -= ControllerStateChanged;
		Pvr_ControllerManager.ChangeMainControllerCallBackEvent -= MainControllerIDChanged;
	}

	private void ServiceStartSuccess()
	{
		RefreshRay();
	}

	private void ControllerStateChanged(string data)
	{
		if (Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			moduleState = true;
			controller.transform.localScale = Vector3.one;
		}
		RefreshRay();
	}

	private void MainControllerIDChanged(string data)
	{
		RefreshRay();
	}

	private void RefreshRay()
	{
		if (Variety == ControllerVariety.Controller0)
		{
			StartCoroutine(ShowOrHideRay(0));
		}
		if (Variety == ControllerVariety.Controller1)
		{
			StartCoroutine(ShowOrHideRay(1));
		}
	}

	private IEnumerator ShowOrHideRay(int id)
	{
		yield return null;
		yield return null;
		if (moduleState)
		{
			bool active = Controller.UPvr_GetMainHandNess() == id && Controller.UPvr_GetControllerState(id) == ControllerState.Connected;
			dot.SetActive(active);
			rayLine.SetActive(active);
		}
	}

	public void ForceHideOrShow(bool state)
	{
		dot.SetActive(state);
		rayLine.SetActive(state);
		controller.transform.localScale = (state ? Vector3.one : Vector3.zero);
		moduleState = state;
	}

	public void UpdateRay()
	{
		if (!Pvr_ControllerManager.Instance.LengthAdaptiveRay)
		{
			return;
		}
		bool flag = false;
		flag = ((Pvr_ControllerManager.controllerlink.controller0Connected || Pvr_ControllerManager.controllerlink.controller1Connected) ? true : false);
		if (flag && rayLine != null && rayLine.gameObject.activeSelf)
		{
			if (Controller.UPvr_GetDeviceType() == 1)
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0f, 0.058f));
			}
			else
			{
				rayLine.GetComponent<LineRenderer>().SetPosition(0, base.transform.TransformPoint(0f, 0.009f, 0.055f));
			}
			rayLine.GetComponent<LineRenderer>().SetPosition(1, dot.transform.position);
		}
	}
}
public class Pvr_ControllerPower : MonoBehaviour
{
	[SerializeField]
	private Sprite power1;

	[SerializeField]
	private Sprite power2;

	[SerializeField]
	private Sprite power3;

	[SerializeField]
	private Sprite power4;

	[SerializeField]
	private Sprite power5;

	[HideInInspector]
	public ControllerVariety variety;

	[HideInInspector]
	public ControllerDevice currentDevice;

	private Image powerImage;

	private int powerValue;

	private float power;

	private void Start()
	{
		powerImage = base.transform.GetComponent<Image>();
		powerValue = -1;
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
	}

	private void Update()
	{
		RefreshPower((variety != 0) ? 1 : 0);
	}

	private void RefreshPower(int hand)
	{
		if (powerValue != Controller.UPvr_GetControllerPower(hand))
		{
			switch (Controller.UPvr_GetControllerPower(hand))
			{
			case 1:
				powerImage.sprite = power1;
				powerImage.color = Color.red;
				break;
			case 2:
				powerImage.sprite = power2;
				powerImage.color = Color.white;
				break;
			case 3:
				powerImage.sprite = power3;
				powerImage.color = Color.white;
				break;
			case 4:
				powerImage.sprite = power4;
				powerImage.color = Color.white;
				break;
			case 5:
				powerImage.sprite = power5;
				powerImage.color = Color.white;
				break;
			default:
				powerImage.sprite = power1;
				powerImage.color = Color.white;
				break;
			}
			powerValue = Controller.UPvr_GetControllerPower(hand);
		}
	}
}
public class Pvr_ControllerVisual : MonoBehaviour
{
	public ControllerDevice currentDevice;

	public Texture2D m_idle;

	public Texture2D m_app;

	public Texture2D m_home;

	public Texture2D m_touchpad;

	public Texture2D m_volUp;

	public Texture2D m_volDn;

	public Texture2D m_trigger;

	public Texture2D m_a;

	public Texture2D m_b;

	public Texture2D m_x;

	public Texture2D m_y;

	public Texture2D m_grip;

	private Renderer controllerRenderMat;

	[HideInInspector]
	public ControllerVariety variety;

	private void Awake()
	{
		controllerRenderMat = GetComponent<Renderer>();
	}

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
	}

	private void Update()
	{
		ChangeKeyEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeKeyEffects(int hand)
	{
		if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.TOUCHPAD))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_touchpad);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.APP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_app);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.HOME))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_home);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEUP))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volUp);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.VOLUMEDOWN))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_volDn);
		}
		else if (Controller.UPvr_GetControllerTriggerValue(hand) > 0 || Controller.UPvr_GetKey(hand, Pvr_KeyCode.TRIGGER))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_trigger);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.X))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_x);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Y))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_y);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.A))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_a);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.B))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_b);
		}
		else if (Controller.UPvr_GetKey(hand, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(hand, Pvr_KeyCode.Right))
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_grip);
		}
		else if (controllerRenderMat.material.GetTexture("_MainTex") != m_idle)
		{
			controllerRenderMat.material.SetTexture("_MainTex", m_idle);
		}
	}
}
public class Pvr_ToolTips : MonoBehaviour
{
	public enum TipBtn
	{
		app,
		touchpad,
		home,
		volup,
		voldown,
		trigger,
		grip
	}

	private ControllerDevice currentDevice;

	private float tipsAlpha;

	public static Pvr_ToolTips tooltips;

	public void ChangeTipsText(TipBtn tip, string key)
	{
		switch (tip)
		{
		case TipBtn.app:
			base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.touchpad:
			base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.home:
			base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.volup:
			base.transform.Find("volup/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.voldown:
			base.transform.Find("voldown/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.trigger:
			base.transform.Find("triggertip/btn/Text").GetComponent<Text>().text = key;
			break;
		case TipBtn.grip:
			base.transform.Find("grip/btn/Text").GetComponent<Text>().text = key;
			break;
		}
	}

	private void Awake()
	{
		tooltips = base.transform.GetComponent<Pvr_ToolTips>();
	}

	private void Update()
	{
		switch (currentDevice)
		{
		case ControllerDevice.Goblin:
		case ControllerDevice.G2:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo2:
		case ControllerDevice.Neo3:
			tipsAlpha = (330f - base.transform.parent.parent.parent.localRotation.eulerAngles.x) / 45f;
			if (base.transform.parent.parent.parent.localRotation.eulerAngles.x >= 270f && base.transform.parent.parent.parent.localRotation.eulerAngles.x <= 330f)
			{
				tipsAlpha = Mathf.Max(0f, tipsAlpha);
				tipsAlpha = ((tipsAlpha > 1f) ? 1f : tipsAlpha);
			}
			else
			{
				tipsAlpha = 0f;
			}
			GetComponent<CanvasGroup>().alpha = tipsAlpha;
			break;
		case ControllerDevice.Neo:
			break;
		}
	}

	private void LoadTextFromJson()
	{
		currentDevice = base.transform.GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		base.transform.Find("apptip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("apptip");
		base.transform.Find("touchtip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("touchtip");
		base.transform.Find("hometip/btn/Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("hometip");
		Transform transform = base.transform.Find("volup/btn/Text");
		if (transform != null)
		{
			transform.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voluptip");
		}
		Transform transform2 = base.transform.Find("voldown/btn/Text");
		if (transform2 != null)
		{
			transform2.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("voldowntip");
		}
		Transform transform3 = base.transform.Find("triggertip/btn/Text");
		if (transform3 != null)
		{
			transform3.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("triggertip");
		}
		Transform transform4 = base.transform.Find("grip/btn/Text");
		if (transform4 != null)
		{
			transform4.GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("griptip");
		}
	}

	public static void RefreshTips()
	{
		if (tooltips != null)
		{
			tooltips.LoadTextFromJson();
		}
	}
}
public class Pvr_TouchPadScroll : MonoBehaviour
{
	private ScrollRect scrollRect;

	private bool isHoving;

	private int mainHand;

	private SwipeDirection direction;

	private Vector2 currPos;

	private Vector2 tarPos;

	private float lerpSpeed = 10f;

	private Transform tranViewport;

	private float ignoreDis = 3f;

	private Vector2 lastTouchDownPos;

	private Vector2 lastTouchUpPos;

	private bool isTouching;

	private bool isClosed = true;

	private Vector2 vecOrigin = Vector2.zero;

	private Vector2 vecOriginNeo2 = new Vector2(128f, 128f);

	private void Awake()
	{
		scrollRect = base.gameObject.GetComponent<ScrollRect>();
		tranViewport = base.transform.Find("Viewport");
	}

	private void Update()
	{
		Process();
		UpdateTargetPos();
		UpdatePos();
	}

	private bool IsControllerConnect()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			return true;
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			return true;
		}
		return false;
	}

	private void UpdateTargetPos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (isHoving)
		{
			if (Pvr_ControllerManager.controllerlink.GetControllerType() == 3)
			{
				ComputeTouchPos();
			}
			else
			{
				ComputeRockerPos();
			}
			if ((currPos - tarPos).sqrMagnitude <= 10f)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeTouchPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOrigin;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if ((vector - vecOrigin).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOrigin;
			lastTouchUpPos = vecOrigin;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private void ComputeRockerPos()
	{
		mainHand = Controller.UPvr_GetMainHandNess();
		currPos = scrollRect.content.localPosition;
		Vector2 vector = vecOriginNeo2;
		if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
		{
			vector = Controller.UPvr_GetTouchPadPosition(mainHand);
		}
		if (VerifyNeo2TouchValid(vector) && (vector - vecOriginNeo2).sqrMagnitude >= 1f)
		{
			if (!isTouching)
			{
				lastTouchDownPos = vector;
				isTouching = true;
			}
			lastTouchUpPos.x = vector.x;
			if (Mathf.Abs(lastTouchUpPos.x - lastTouchDownPos.x) > ignoreDis)
			{
				Vector2 vector2 = new Vector2((lastTouchUpPos.x - lastTouchDownPos.x) * 10f, 0f);
				lastTouchDownPos.x = lastTouchUpPos.x;
				if (isClosed)
				{
					tarPos = currPos + vector2;
					isClosed = false;
				}
				else
				{
					tarPos += vector2;
				}
			}
		}
		else
		{
			lastTouchDownPos = vecOriginNeo2;
			lastTouchUpPos = vecOriginNeo2;
			isTouching = false;
			if ((double)scrollRect.horizontalScrollbar.value >= 0.999 || (double)scrollRect.horizontalScrollbar.value <= 0.0001)
			{
				isClosed = true;
			}
		}
	}

	private bool VerifyNeo2TouchValid(Vector2 nowTouchPos)
	{
		if (nowTouchPos.x > vecOriginNeo2.x && nowTouchPos.x > lastTouchDownPos.x)
		{
			return true;
		}
		if (nowTouchPos.x < vecOriginNeo2.x && nowTouchPos.x < lastTouchDownPos.x)
		{
			return true;
		}
		return false;
	}

	private void UpdatePos()
	{
		if (Controller.UPvr_GetKey(0, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TOUCHPAD))
		{
			ResetParameter();
		}
		else if (!isClosed && IsControllerConnect())
		{
			if ((double)scrollRect.horizontalScrollbar.value >= 0.9999 && tarPos.x <= currPos.x)
			{
				isClosed = true;
				return;
			}
			if ((double)scrollRect.horizontalScrollbar.value <= 0.0001 && tarPos.x >= currPos.x)
			{
				isClosed = true;
				return;
			}
			currPos.x = Mathf.Lerp(currPos.x, tarPos.x, lerpSpeed * Time.deltaTime);
			currPos.y = Mathf.Lerp(currPos.y, tarPos.y, lerpSpeed * Time.deltaTime);
			scrollRect.content.localPosition = currPos;
		}
	}

	private void ResetParameter()
	{
		currPos = scrollRect.content.localPosition;
		tarPos = scrollRect.content.localPosition;
		isClosed = true;
	}

	private void Process()
	{
		for (int i = 0; i < Pvr_InputModule.pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = Pvr_InputModule.pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				isHoving = IsHovering(pvr_UIPointer);
			}
		}
	}

	private bool IsHovering(Pvr_UIPointer pointer)
	{
		if (!IsControllerConnect())
		{
			return false;
		}
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if (FindTree(item.transform))
			{
				mainHand = Controller.UPvr_GetMainHandNess();
				if (mainHand == 0 && Pvr_ControllerManager.controllerlink.controller0Connected)
				{
					return true;
				}
				if (mainHand == 1 && Pvr_ControllerManager.controllerlink.controller1Connected)
				{
					return true;
				}
			}
		}
		return false;
	}

	private bool FindTree(Transform tran)
	{
		if (tran == base.transform || tran == tranViewport)
		{
			return true;
		}
		if (tran.IsChildOf(tranViewport))
		{
			return true;
		}
		return false;
	}
}
public class Pvr_TouchVisual : MonoBehaviour
{
	[HideInInspector]
	public ControllerDevice currentDevice;

	[HideInInspector]
	public ControllerVariety variety;

	private MeshRenderer touchRenderer;

	private void Start()
	{
		variety = base.transform.GetComponentInParent<Pvr_ControllerModuleInit>().Variety;
		currentDevice = GetComponentInParent<Pvr_ControllerVisual>().currentDevice;
		touchRenderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		ChangeEffects((variety != 0) ? 1 : 0);
	}

	private void ChangeEffects(int hand)
	{
		if (currentDevice == ControllerDevice.G2)
		{
			if (Controller.UPvr_IsTouching(0))
			{
				touchRenderer.enabled = true;
				base.transform.localPosition = new Vector3(1.3f - Controller.UPvr_GetTouchPadPosition(hand).x * 0.01f, 1.6f, -1.7f - Controller.UPvr_GetTouchPadPosition(hand).y * 0.01f);
			}
			else
			{
				touchRenderer.enabled = false;
			}
		}
	}
}
public class DemoController : MonoBehaviour
{
	public delegate void showLoadingEventHandler();

	private Callback callback;

	private GameObject msg;

	private Pvr_UnitySDKManager picoVrManager;

	private string currentOrderID;

	public GameObject loading;

	public GameObject BG;

	public GameObject InputPanel;

	public static showLoadingEventHandler showLoading;

	private void Awake()
	{
		UnityEngine.Debug.Log(loading.name);
		UnityEngine.Debug.Log(BG.name);
		showLoading = (showLoadingEventHandler)Delegate.Combine(showLoading, new showLoadingEventHandler(StopLoading));
		InputManager.doEnter = (InputManager.doEnterEventHandler)Delegate.Combine(InputManager.doEnter, new InputManager.doEnterEventHandler(DoPayByCode));
		currentOrderID = "";
	}

	private void Start()
	{
		msg = GameObject.Find("MassageInfo");
		InitDelegate();
		callback = new Callback();
		picoVrManager = GameObject.Find("Pvr_UnitySDK").GetComponent<Pvr_UnitySDKManager>();
		InputPanel.SetActive(value: false);
	}

	private void Update()
	{
		if (picoVrManager != null && (Input.GetKeyDown(KeyCode.Y) || Input.GetKeyDown(KeyCode.Joystick1Button2)))
		{
			UnityEngine.Debug.Log("update");
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
		if (Input.GetKeyDown(KeyCode.Joystick1Button1) || Input.GetKeyDown(KeyCode.Escape))
		{
			if (InputPanel.activeInHierarchy)
			{
				InputPanel.SetActive(value: false);
			}
			else
			{
				Application.Quit();
			}
		}
	}

	private void InitDelegate()
	{
		foreach (string item in new ArrayList { "Login", "GetUserAPI", "PayOne", "PayCode", "QueryOrder" })
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
	}

	private void OnClick(GameObject btnObj)
	{
		switch (btnObj.name)
		{
		case "Login":
			StartLoading();
			LoginSDK.Login();
			break;
		case "PayOne":
			CommonDic.getInstance().setParameters("subject", "game");
			CommonDic.getInstance().setParameters("body", "gamePay");
			CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
			CommonDic.getInstance().setParameters("total", "1");
			CommonDic.getInstance().setParameters("goods_tag", "game");
			CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
			CommonDic.getInstance().setParameters("pay_code", "");
			StartLoading();
			PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
			break;
		case "PayCode":
			InputPanel.SetActive(value: true);
			break;
		case "QueryOrder":
			StartLoading();
			PicoPaymentSDK.QueryOrder(currentOrderID);
			break;
		case "GetUserAPI":
			StartLoading();
			LoginSDK.GetUserAPI();
			break;
		}
	}

	public string getRamdomTestOrderID()
	{
		currentOrderID = (UnityEngine.Random.value * 65535f).ToString();
		return currentOrderID;
	}

	private void StartLoading()
	{
		loading.SetActive(value: true);
		BG.SetActive(value: true);
	}

	public void StopLoading()
	{
		if ((bool)loading && (bool)BG)
		{
			loading.SetActive(value: false);
			BG.SetActive(value: false);
		}
		else
		{
			UnityEngine.Debug.LogError("demo");
		}
	}

	public void DoPayByCode()
	{
		CommonDic.getInstance().setParameters("subject", "game");
		CommonDic.getInstance().setParameters("body", "gamePay");
		CommonDic.getInstance().setParameters("order_id", getRamdomTestOrderID());
		CommonDic.getInstance().setParameters("total", "0");
		CommonDic.getInstance().setParameters("goods_tag", "game");
		CommonDic.getInstance().setParameters("notify_url", "www.picovr.com");
		CommonDic.getInstance().setParameters("pay_code", GameObject.Find("CodeText").GetComponent<Text>().text);
		UnityEngine.Debug.Log("" + GameObject.Find("CodeText").GetComponent<Text>().text);
		StartLoading();
		GameObject.Find("CodeText").GetComponent<Text>().text = "";
		InputPanel.SetActive(value: false);
		PicoPaymentSDK.Pay(CommonDic.getInstance().PayOrderString());
	}

	private bool VerifyLocalToken()
	{
		if (CommonDic.getInstance().access_token.Equals(""))
		{
			GameObject.Find("MassageInfo").GetComponent<Text>().text = "{code:exception,msg:}";
			currentOrderID = "";
			StopLoading();
			return false;
		}
		return true;
	}
}
public class LoadingRatation : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.gameObject.transform.Rotate(new Vector3(0f, 0f, -4f));
	}
}
public class InputManager : MonoBehaviour
{
	public delegate void doEnterEventHandler();

	public static doEnterEventHandler doEnter;

	private StringBuilder sb = new StringBuilder();

	private ArrayList btnsName = new ArrayList();

	private GameObject enter;

	private void Awake()
	{
		InitKeyBoard();
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void InitKeyBoard()
	{
		btnsName.Add("1");
		btnsName.Add("2");
		btnsName.Add("3");
		btnsName.Add("4");
		btnsName.Add("5");
		btnsName.Add("6");
		btnsName.Add("7");
		btnsName.Add("8");
		btnsName.Add("9");
		btnsName.Add("0");
		btnsName.Add("Q");
		btnsName.Add("W");
		btnsName.Add("E");
		btnsName.Add("R");
		btnsName.Add("T");
		btnsName.Add("Y");
		btnsName.Add("U");
		btnsName.Add("I");
		btnsName.Add("O");
		btnsName.Add("P");
		btnsName.Add("A");
		btnsName.Add("S");
		btnsName.Add("D");
		btnsName.Add("F");
		btnsName.Add("G");
		btnsName.Add("H");
		btnsName.Add("J");
		btnsName.Add("K");
		btnsName.Add("L");
		btnsName.Add("Z");
		btnsName.Add("X");
		btnsName.Add("C");
		btnsName.Add("V");
		btnsName.Add("B");
		btnsName.Add("N");
		btnsName.Add("M");
		btnsName.Add("Clear");
		btnsName.Add("Capslock");
		btnsName.Add("Enter");
		foreach (string item in btnsName)
		{
			GameObject btnObj = GameObject.Find(item);
			btnObj.GetComponent<Button>().onClick.AddListener(delegate
			{
				OnClick(btnObj);
			});
		}
		enter = GameObject.Find("Enter");
		enter.SetActive(sb.Length > 0);
	}

	private void OnClick(GameObject btnObj)
	{
		if (btnObj.name.Equals("Capslock"))
		{
			if (GameObject.Find("Q").transform.GetChild(0).GetComponent<Text>().text.Equals("Q"))
			{
				DoCapslock(IsUpper: true);
			}
			else
			{
				DoCapslock(IsUpper: false);
			}
		}
		else if (btnObj.name.Equals("Clear"))
		{
			GameObject.Find("CodeText").GetComponent<Text>().text = "";
			ClearBuffer();
		}
		else if (btnObj.name.Equals("Enter"))
		{
			ClearBuffer();
			doEnter();
		}
		else
		{
			EnterChar(btnObj.transform.GetChild(0).GetComponent<Text>().text);
		}
	}

	private void EnterChar(string s)
	{
		sb.Append(s);
		GameObject.Find("CodeText").GetComponent<Text>().text = sb.ToString();
		enter.SetActive(sb.Length > 0);
	}

	private void DoCapslock(bool IsUpper)
	{
		if (IsUpper)
		{
			foreach (string item in btnsName)
			{
				Text component = GameObject.Find(item).transform.GetChild(0).GetComponent<Text>();
				component.text = component.text.ToLower();
			}
			return;
		}
		foreach (string item2 in btnsName)
		{
			Text component2 = GameObject.Find(item2).transform.GetChild(0).GetComponent<Text>();
			component2.text = component2.text.ToUpper();
		}
	}

	private void ClearBuffer()
	{
		sb.Remove(0, sb.Length);
		enter.SetActive(sb.Length > 0);
	}
}
public class Callback : MonoBehaviour
{
	private static string IS_SUCCESS = "isSuccess";

	private static string MSG = "msg";

	private static string CODE = "code";

	public void LoginCallback(string LoginInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(LoginInfo);
		SetMassage(LoginInfo);
		DemoController.showLoading();
		if (jsonData[IS_SUCCESS] != null)
		{
			CommonDic.getInstance().isSuccess = jsonData[IS_SUCCESS].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().loginMsg = jsonData[MSG].ToString();
		}
		UnityEngine.Debug.Log("login:" + LoginInfo);
	}

	public void QueryOrPayCallback(string queryOrPayInfo)
	{
		JsonData jsonData = JsonMapper.ToObject(queryOrPayInfo);
		if (jsonData[CODE] != null)
		{
			CommonDic.getInstance().code = jsonData["code"].ToString();
		}
		if (jsonData[MSG] != null)
		{
			CommonDic.getInstance().msg = jsonData["msg"].ToString();
		}
		if (jsonData != null)
		{
			CommonDic.getInstance().order_info = jsonData[1].ToString();
		}
		SetMassage(queryOrPayInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("pay:" + queryOrPayInfo);
	}

	public void UserInfoCallback(string userInfo)
	{
		CommonDic.getInstance().user_info = userInfo;
		SetMassage(userInfo);
		DemoController.showLoading();
		UnityEngine.Debug.Log("userInfo:" + userInfo);
	}

	public void SetMassage(string massage)
	{
		if (!GetCurrentGameObject().Equals(null))
		{
			GetCurrentGameObject().GetComponent<Text>().text = massage;
		}
		else
		{
			UnityEngine.Debug.LogError("Message");
		}
	}

	public GameObject GetCurrentGameObject()
	{
		return GameObject.Find("MassageInfo");
	}

	public void ActivityForResultCallback(string activity)
	{
		PicoPaymentSDK.jo.Call("authCallback", activity);
	}
}
public class CommonDic
{
	private static CommonDic dic;

	private static Dictionary<string, string> mydic;

	private string _app_ID;

	private string _app_Key;

	private string _user_token;

	private string _access_token = "";

	private string _open_id;

	private string _refresh_token;

	private string _expires_in;

	private string _user_info;

	private string _subject;

	private string _body;

	private string _order_id;

	private string _total;

	private string _goods_tag;

	private string _notify_url;

	private string _trade_type;

	private string _pay_code = "";

	private string _order_info;

	private string _code;

	private string _msg = "null";

	private string _merchant_ID;

	private string _payKey;

	private string _isSuucess;

	private string _loginMsg;

	public string subject
	{
		get
		{
			return _subject;
		}
		set
		{
			_subject = value;
		}
	}

	public string body
	{
		get
		{
			return _body;
		}
		set
		{
			_body = value;
		}
	}

	public string order_id
	{
		get
		{
			return _order_id;
		}
		set
		{
			_order_id = value;
		}
	}

	public string total
	{
		get
		{
			return _total;
		}
		set
		{
			_total = value;
		}
	}

	public string goods_tag
	{
		get
		{
			return _goods_tag;
		}
		set
		{
			_goods_tag = value;
		}
	}

	public string notify_url
	{
		get
		{
			return _notify_url;
		}
		set
		{
			_notify_url = value;
		}
	}

	public string pay_code
	{
		get
		{
			return _pay_code;
		}
		set
		{
			_pay_code = value;
		}
	}

	public string trade_type
	{
		get
		{
			return _trade_type;
		}
		set
		{
			_trade_type = value;
		}
	}

	public string user_token
	{
		get
		{
			return _user_token;
		}
		set
		{
			_user_token = value;
		}
	}

	public string access_token
	{
		get
		{
			return _access_token;
		}
		set
		{
			_access_token = value;
		}
	}

	public string open_id
	{
		get
		{
			return _open_id;
		}
		set
		{
			_open_id = value;
		}
	}

	public string refresh_token
	{
		get
		{
			return _refresh_token;
		}
		set
		{
			_refresh_token = value;
		}
	}

	public string expires_in
	{
		get
		{
			return _expires_in;
		}
		set
		{
			_expires_in = value;
		}
	}

	public string isSuccess
	{
		get
		{
			return _isSuucess;
		}
		set
		{
			_isSuucess = value;
		}
	}

	public string loginMsg
	{
		get
		{
			return _loginMsg;
		}
		set
		{
			_loginMsg = value;
		}
	}

	public string user_info
	{
		get
		{
			return _user_info;
		}
		set
		{
			_user_info = value;
		}
	}

	public string order_info
	{
		get
		{
			return _order_info;
		}
		set
		{
			_order_info = value;
		}
	}

	public string code
	{
		get
		{
			return _code;
		}
		set
		{
			_code = value;
		}
	}

	public string msg
	{
		get
		{
			return _msg;
		}
		set
		{
			_msg = value;
		}
	}

	public string app_ID
	{
		get
		{
			return _app_ID;
		}
		set
		{
			_app_ID = value;
		}
	}

	public string app_Key
	{
		get
		{
			return _app_Key;
		}
		set
		{
			_app_Key = value;
		}
	}

	public string merchant_ID
	{
		get
		{
			return _merchant_ID;
		}
		set
		{
			_merchant_ID = value;
		}
	}

	public string paykey
	{
		get
		{
			return _payKey;
		}
		set
		{
			_payKey = value;
		}
	}

	public static CommonDic getInstance()
	{
		if (dic == null)
		{
			dic = new CommonDic();
		}
		if (mydic == null)
		{
			mydic = new Dictionary<string, string>();
			InitDicData(mydic);
		}
		return dic;
	}

	public Dictionary<string, string> getDic()
	{
		return mydic;
	}

	public void setParameters(string name, string value)
	{
		if (name.Equals("subject"))
		{
			subject = value;
		}
		if (name.Equals("body"))
		{
			body = value;
		}
		if (name.Equals("order_id"))
		{
			order_id = value;
		}
		if (name.Equals("total"))
		{
			total = value;
		}
		if (name.Equals("goods_tag"))
		{
			goods_tag = value;
		}
		if (name.Equals("notify_url"))
		{
			notify_url = value;
		}
		if (name.Equals("trade_type"))
		{
			trade_type = value;
		}
		if (name.Equals("pay_code"))
		{
			pay_code = value;
		}
	}

	public string PayOrderString()
	{
		return JsonMapper.ToJson(getInstance());
	}

	public static void InitDicData(Dictionary<string, string> mydic)
	{
		mydic.Add("00000", "");
		mydic.Add("10000", "");
		mydic.Add("10001", "");
		mydic.Add("10002", "");
		mydic.Add("10003", "");
		mydic.Add("11000", "");
		mydic.Add("11001", "");
		mydic.Add("11002", "");
		mydic.Add("11003", "");
		mydic.Add("12000", "");
		mydic.Add("12001", "");
		mydic.Add("12003", "P");
		mydic.Add("12004", "");
		mydic.Add("13000", "");
		mydic.Add("13001", "");
		mydic.Add("13002", "");
		mydic.Add("14000", "");
		mydic.Add("14001", "/");
		mydic.Add("14002", "");
		mydic.Add("15000", "");
		mydic.Add("15001", "ID");
		mydic.Add("15002", "Pico");
		mydic.Add("NOAUTH", "");
		mydic.Add("SYSTEMERROR", "");
		mydic.Add("APP_ID_NOT_EXIST", "APP_ID");
		mydic.Add("MCHID_NOT_EXIST", "MCHID");
		mydic.Add("APP_ID_MCHID_NOT_MATCH", "app_idmch_idID");
		mydic.Add("LACK_PARAMS", "");
		mydic.Add("SIGNERROR", "");
		mydic.Add("NO_DATA", "");
	}
}
public class LoginSDK
{
	public static void Login()
	{
		PicoPaymentSDK.Login();
	}

	public static void GetUserAPI()
	{
		PicoPaymentSDK.GetUserAPI();
	}
}
public class PicoPaymentSDK
{
	private static AndroidJavaObject _jo = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

	public static AndroidJavaObject jo
	{
		get
		{
			return _jo;
		}
		set
		{
			_jo = value;
		}
	}

	public static void Login()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("authSSO");
	}

	public static void Pay(string payOrderJson)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("pay", payOrderJson);
	}

	public static void QueryOrder(string orderId)
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("queryOrder", orderId);
	}

	public static void GetUserAPI()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		jo.Call("init", @static);
		jo.Call("getUserAPI");
	}
}
public class Pvr_ToBService : MonoBehaviour
{
	public Text deviceInfoText;

	private void Awake()
	{
		InitToBService();
	}

	private void Start()
	{
		BindToBService();
	}

	private void OnDestory()
	{
		UnBindToBService();
	}

	private void InitToBService()
	{
		ToBService.UPvr_InitToBService();
		ToBService.UPvr_SetUnityObjectName(base.name);
	}

	private void BindToBService()
	{
		ToBService.UPvr_BindToBService();
	}

	private void UnBindToBService()
	{
		ToBService.UPvr_UnBindToBService();
	}

	private void BoolCallback(string value)
	{
		if (ToBService.BoolCallback != null)
		{
			ToBService.BoolCallback(bool.Parse(value));
		}
		ToBService.BoolCallback = null;
	}

	private void IntCallback(string value)
	{
		if (ToBService.IntCallback != null)
		{
			ToBService.IntCallback(int.Parse(value));
		}
		ToBService.IntCallback = null;
	}

	private void LongCallback(string value)
	{
		if (ToBService.LongCallback != null)
		{
			ToBService.LongCallback(int.Parse(value));
		}
		ToBService.LongCallback = null;
	}

	public void StateGetDeviceInfo()
	{
		string text = ToBService.UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum.PUI_VERSION);
		deviceInfoText.text = "PUI_VERSION:" + text;
	}

	public void ControlSetDeviceAction()
	{
		ToBService.UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum.DEVICE_CONTROL_SHUTDOWN, ControlSetDeviceActionCallBack);
	}

	private void ControlSetDeviceActionCallBack(int value)
	{
		UnityEngine.Debug.Log("ControlSetDeviceActionCallBack : " + value);
	}

	public void AppManager()
	{
		ToBService.UPvr_ControlAPPManger(PBS_PackageControlEnum.PACKAGE_SILENCE_UNINSTALL, "com.pico.ipd.test", AppManagerCallBack);
	}

	private void AppManagerCallBack(int value)
	{
		UnityEngine.Debug.Log("AppManagerCallBack : " + value);
	}
}
public class PLOG : MonoBehaviour
{
	public static int logLevel;

	public static void getConfigTraceLevel()
	{
		Render.UPvr_GetIntConfig(6, ref logLevel);
	}

	public static void D(string msg)
	{
		if (logLevel > 2)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void I(string msg)
	{
		if (logLevel > 1)
		{
			UnityEngine.Debug.Log(msg);
		}
	}

	public static void W(string msg)
	{
		if (logLevel > 0)
		{
			UnityEngine.Debug.LogWarning(msg);
		}
	}

	public static void E(string msg)
	{
		UnityEngine.Debug.LogError(msg);
	}
}
public class CPicoSDKSettingAsset : ScriptableObject
{
	public bool IgnoreSDKSetting;

	public bool DontshowBuildWaring;

	public bool AppIDChecked;
}
[Serializable]
public class Pvr_UnitySDKProjectSetting : ScriptableObject
{
	public RenderTextureAntiAliasing rtAntiAlising;

	public RenderTextureDepth rtBitDepth;

	public RenderTextureFormat rtFormat;

	public bool usedefaultRenderTexture;

	public Vector2 customRTSize;

	public bool usedefaultfps;

	public int customfps;

	public bool usesinglepass;

	public bool usecontentprotect;

	public static Pvr_UnitySDKProjectSetting GetProjectConfig()
	{
		return Resources.Load<Pvr_UnitySDKProjectSetting>("ProjectSetting");
	}
}
public sealed class Pvr_UnitySDKPlatformSetting : ScriptableObject
{
	public enum simulationType
	{
		Null,
		Invalid,
		Valid
	}

	[SerializeField]
	private bool entitlementchecksimulation;

	[SerializeField]
	private bool startTimeEntitlementCheck;

	[SerializeField]
	public string appID;

	public List<string> deviceSN = new List<string>();

	private static Pvr_UnitySDKPlatformSetting instance;

	public static bool Entitlementchecksimulation
	{
		get
		{
			return Instance.entitlementchecksimulation;
		}
		set
		{
			if (Instance.entitlementchecksimulation != value)
			{
				Instance.entitlementchecksimulation = value;
			}
		}
	}

	public static bool StartTimeEntitlementCheck
	{
		get
		{
			return Instance.startTimeEntitlementCheck;
		}
		set
		{
			if (Instance.startTimeEntitlementCheck != value)
			{
				Instance.startTimeEntitlementCheck = value;
			}
		}
	}

	public static Pvr_UnitySDKPlatformSetting Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<Pvr_UnitySDKPlatformSetting>("PlatformSettings");
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class Pvr_UnitySDKManager : MonoBehaviour
{
	public delegate void EntitlementCheckResult(int ReturnValue);

	public static PlatForm platform;

	private static Pvr_UnitySDKManager sdk;

	[HideInInspector]
	public float EyesAspect = 1f;

	[HideInInspector]
	public int posStatus;

	[HideInInspector]
	public bool ismirroring;

	[HideInInspector]
	public Vector3 resetBasePos;

	[HideInInspector]
	public int trackingmode = -1;

	[HideInInspector]
	public int systemprop = -1;

	[HideInInspector]
	public bool systemFPS;

	[HideInInspector]
	public float[] headData = new float[7];

	[SerializeField]
	private bool rotfoldout;

	[SerializeField]
	private bool hmdOnlyrot;

	[SerializeField]
	private bool controllerOnlyrot;

	[SerializeField]
	private TrackingOrigin trackingOrigin;

	public bool ResetTrackerOnLoad;

	[HideInInspector]
	public Vector3 leftEyeOffset;

	[HideInInspector]
	public Vector3 rightEyeOffset;

	[HideInInspector]
	public Rect leftEyeRect;

	[HideInInspector]
	public Rect rightEyeRect;

	[HideInInspector]
	public Matrix4x4 leftEyeView;

	[HideInInspector]
	public Matrix4x4 rightEyeView;

	[HideInInspector]
	public Pvr_UnitySDKEditor pvr_UnitySDKEditor;

	[SerializeField]
	private bool vrModeEnabled = true;

	[HideInInspector]
	public Material Eyematerial;

	[HideInInspector]
	public Material Middlematerial;

	[HideInInspector]
	public bool newPicovrTriggered;

	[SerializeField]
	private bool showFPS;

	[HideInInspector]
	public Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[SerializeField]
	private bool pVRNeck = true;

	[HideInInspector]
	public bool UseCustomNeckPara;

	[HideInInspector]
	public bool onResume;

	[HideInInspector]
	public bool isEnterVRMode;

	public bool isHasController;

	public Pvr_UnitySDKConfigProfile pvr_UnitySDKConfig;

	private GameObject calltoast;

	private GameObject msgtoast;

	private GameObject lowhmdBatterytoast;

	private GameObject lowphoneBatterytoast;

	private GameObject LowPhoneHealthtoast;

	private GameObject LowcontrollerBatterytoast;

	private bool lowControllerpowerstate;

	private float controllerpowershowtime;

	private bool UseToast = true;

	private int iPhoneHMDModeEnabled;

	private GameObject G3LiteTips;

	[SerializeField]
	private bool monoscopic;

	private bool mIsAndroid7;

	public static Func<bool> eventEnterVRMode;

	[HideInInspector]
	public bool ShowVideoSeethrough;

	public int SystemDebugFFRLevel = -1;

	public int SystemFFRLevel = -1;

	public int AppCheckResult = 100;

	public Action longPressHomeKeyAction;

	public static Pvr_UnitySDKManager SDK
	{
		get
		{
			if (sdk == null)
			{
				sdk = UnityEngine.Object.FindObjectOfType<Pvr_UnitySDKManager>();
			}
			return sdk;
		}
	}

	public bool Rotfoldout
	{
		get
		{
			return rotfoldout;
		}
		set
		{
			if (value != rotfoldout)
			{
				rotfoldout = value;
			}
		}
	}

	public bool HmdOnlyrot
	{
		get
		{
			return hmdOnlyrot;
		}
		set
		{
			if (value != hmdOnlyrot)
			{
				hmdOnlyrot = value;
			}
		}
	}

	public bool ControllerOnlyrot
	{
		get
		{
			return controllerOnlyrot;
		}
		set
		{
			if (value != controllerOnlyrot)
			{
				controllerOnlyrot = value;
			}
		}
	}

	public TrackingOrigin TrackingOrigin
	{
		get
		{
			return trackingOrigin;
		}
		set
		{
			if (value != trackingOrigin)
			{
				trackingOrigin = value;
				Sensor.UPvr_SetTrackingOriginType(value);
			}
		}
	}

	[HideInInspector]
	public bool VRModeEnabled
	{
		get
		{
			return vrModeEnabled;
		}
		set
		{
			if (value != vrModeEnabled)
			{
				vrModeEnabled = value;
			}
		}
	}

	[HideInInspector]
	public bool picovrTriggered { get; set; }

	public bool ShowFPS
	{
		get
		{
			return showFPS;
		}
		set
		{
			if (value != showFPS)
			{
				showFPS = value;
			}
		}
	}

	public bool PVRNeck
	{
		get
		{
			return pVRNeck;
		}
		set
		{
			if (value != pVRNeck)
			{
				pVRNeck = value;
			}
		}
	}

	[HideInInspector]
	public bool Monoscopic
	{
		get
		{
			return monoscopic;
		}
		set
		{
			if (value != monoscopic)
			{
				monoscopic = value;
				Render.UPvr_SetMonoMode(monoscopic);
			}
		}
	}

	public static event EntitlementCheckResult EntitlementCheckResultEvent;

	public void ChangeDefaultCustomRtSize(int w, int h)
	{
		Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize = new Vector2(w, h);
	}

	public Vector3 EyeOffset(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeOffset;
		}
		return leftEyeOffset;
	}

	public Rect EyeRect(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeRect;
		}
		return leftEyeRect;
	}

	private bool SDKManagerInit()
	{
		if (SDKManagerInitConfigProfile())
		{
			mIsAndroid7 = SystemInfo.operatingSystem.Contains("Android OS 7.");
			PLOG.I("Android 7 = " + mIsAndroid7);
			if (SDKManagerInitCoreAbility())
			{
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitCoreAbility()
	{
		Sensor.UPvr_SetTrackingOriginType(trackingOrigin);
		Render.UPvr_SetMonoMode(monoscopic);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		return true;
	}

	public void smsReceivedCallback(string msg)
	{
		PLOG.I("PvrLog MSG" + msg);
		JsonData jsonData = JsonMapper.ToObject(msg);
		string text = "";
		if (msg.Contains("messageSender"))
		{
			text = (string)jsonData["messageSender"];
		}
		string text2 = "";
		if (msg.Contains("messageAdr"))
		{
			text2 = (string)jsonData["messageAdr"];
			if (text2.Substring(0, 3) == "+82")
			{
				text2 = "0" + text2.Remove(0, 3);
				text2 = TransformNumber(text2);
			}
			else if (text2.Substring(0, 1) != "+")
			{
				text2 = TransformNumber(text2);
			}
		}
		if (UseToast)
		{
			msgtoast.transform.Find("number").GetComponent<Text>().text = text2;
			msgtoast.transform.Find("name").GetComponent<Text>().text = text;
			if (text.Length == 0)
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				msgtoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(2, state: true, 0f));
			StartCoroutine(ToastManager(2, state: false, 5f));
		}
	}

	public void phoneStateCallback(string state)
	{
		PLOG.I("PvrLog phone" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string text = "";
		if (state.Contains("phoneNumber"))
		{
			text = (string)jsonData["phoneNumber"];
			if (text.Substring(0, 3) == "+82")
			{
				text = "0" + text.Remove(0, 3);
				text = TransformNumber(text);
			}
			else if (text.Substring(0, 1) != "+")
			{
				text = TransformNumber(text);
			}
		}
		string text2 = "";
		if (state.Contains("contactName"))
		{
			text2 = (string)jsonData["contactName"];
		}
		if (UseToast)
		{
			calltoast.transform.Find("number").GetComponent<Text>().text = text;
			calltoast.transform.Find("name").GetComponent<Text>().text = text2;
			if (text2.Length == 0)
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(0f, 0f, 0f);
			}
			else
			{
				calltoast.transform.Find("number").transform.localPosition = new Vector3(60f, 0f, 0f);
			}
			StartCoroutine(ToastManager(1, state: true, 0f));
			StartCoroutine(ToastManager(1, state: false, 5f));
		}
	}

	public void phoneBatteryStateCallback(string state)
	{
		PLOG.I("PvrLog phoneBatteryState" + state);
		JsonData jsonData = JsonMapper.ToObject(state);
		string value = "";
		if (state.Contains("phoneBatteryLevel"))
		{
			value = (string)jsonData["phoneBatteryLevel"];
		}
		string value2 = "";
		if (state.Contains("phoneBatteryHealth"))
		{
			value2 = (string)jsonData["phoneBatteryHealth"];
		}
		if (!UseToast)
		{
			return;
		}
		if (Convert.ToInt16(value) <= 5)
		{
			if (!lowhmdBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(4, state: true, 0f));
				StartCoroutine(ToastManager(4, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(4, state: true, 5f));
				StartCoroutine(ToastManager(4, state: false, 8f));
			}
		}
		if (Convert.ToInt16(value2) == 3)
		{
			StartCoroutine(ToastManager(5, state: true, 0f));
			StartCoroutine(ToastManager(5, state: false, 5f));
		}
	}

	public void hmdLowBatteryCallback(string level)
	{
		PLOG.I("PvrLog hmdLowBatteryCallback" + level);
		if (UseToast)
		{
			if (!lowphoneBatterytoast.activeSelf)
			{
				StartCoroutine(ToastManager(3, state: true, 0f));
				StartCoroutine(ToastManager(3, state: false, 3f));
			}
			else
			{
				StartCoroutine(ToastManager(3, state: true, 5f));
				StartCoroutine(ToastManager(3, state: false, 8f));
			}
		}
	}

	private string TransformNumber(string number)
	{
		if (number.Length == 11)
		{
			string text = number.Substring(0, 3);
			string text2 = number.Substring(3, 4);
			string text3 = number.Substring(7, 4);
			number = text + "-" + text2 + "-" + text3;
		}
		else if (number.Length == 10)
		{
			if (number.Substring(1, 1) == "1")
			{
				string text4 = number.Substring(0, 3);
				string text5 = number.Substring(3, 3);
				string text6 = number.Substring(6, 4);
				number = text4 + "-" + text5 + "-" + text6;
			}
			else
			{
				string text7 = number.Substring(0, 2);
				string text8 = number.Substring(2, 4);
				string text9 = number.Substring(6, 4);
				number = text7 + "-" + text8 + "-" + text9;
			}
		}
		else if (number.Length == 9)
		{
			if (number.Substring(1, 1) == "2")
			{
				string text10 = number.Substring(0, 2);
				string text11 = number.Substring(2, 3);
				string text12 = number.Substring(5, 4);
				number = text10 + "-" + text11 + "-" + text12;
			}
			else
			{
				number = "+82" + number.Remove(0, 1);
			}
		}
		return number;
	}

	public void onHmdOrientationReseted()
	{
	}

	private IEnumerator ToastManager(int type, bool state, float time)
	{
		yield return new WaitForSeconds(time);
		switch (type)
		{
		case 1:
			calltoast.SetActive(state);
			break;
		case 2:
			msgtoast.SetActive(state);
			break;
		case 3:
			lowhmdBatterytoast.SetActive(state);
			break;
		case 4:
			lowphoneBatterytoast.SetActive(state);
			break;
		case 5:
			LowPhoneHealthtoast.SetActive(state);
			break;
		case 6:
			LowcontrollerBatterytoast.SetActive(state);
			break;
		}
	}

	private void CheckControllerStateForG2(string state)
	{
		if (iPhoneHMDModeEnabled == 1 && Convert.ToBoolean(Convert.ToInt16(state)) && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			StartCoroutine(ToastManager(6, state: true, 0f));
			StartCoroutine(ToastManager(6, state: false, 3f));
		}
	}

	public void notificationCallback(string data)
	{
		JsonData jsonData = JsonMapper.ToObject(data);
		if (G3LiteTips == null)
		{
			G3LiteTips = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/G3LiteTips") as GameObject, base.transform.Find("Head"), worldPositionStays: false);
		}
		JsonData jsonData2 = JsonMapper.ToObject(jsonData["str"].ToString());
		switch ((int)jsonData["type"])
		{
		case 0:
			SetProperty(0, jsonData2, "Sms");
			break;
		case 1:
			SetProperty(1, jsonData2, "Call");
			break;
		case 2:
			SetProperty(2, jsonData2, "Warnning");
			break;
		case 3:
			SetProperty(3, jsonData2, "Warnning");
			break;
		case 4:
			SetProperty(4, jsonData2, "Warnning");
			break;
		case 5:
		{
			Transform transform = G3LiteTips.transform.Find("Onlyimage");
			SetBaseProperty(transform, jsonData2["General"], "");
			SetImageProperty(transform, jsonData2["General"], "");
			transform.gameObject.SetActive(value: true);
			StartCoroutine(G3TipsManager(transform.gameObject, (int)jsonData2["General"]["time"]));
			break;
		}
		case -1:
			break;
		}
	}

	private Sprite LoadSprite(Vector2 size, string filepath)
	{
		int width = (int)size.x;
		int height = (int)size.y;
		Texture2D texture2D = new Texture2D(width, height);
		texture2D.LoadImage(ReadTex(filepath));
		return Sprite.Create(texture2D, new Rect(0f, 0f, texture2D.width, texture2D.height), new Vector2(0.5f, 0.5f));
	}

	private byte[] ReadTex(string path)
	{
		if (path == "")
		{
			return new byte[0];
		}
		FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);
		fileStream.Seek(0L, SeekOrigin.Begin);
		byte[] array = new byte[fileStream.Length];
		fileStream.Read(array, 0, (int)fileStream.Length);
		fileStream.Close();
		fileStream.Dispose();
		fileStream = null;
		return array;
	}

	private void SetProperty(int type, JsonData data, string value)
	{
		Transform trans = G3LiteTips.transform.Find(value);
		SetBaseProperty(trans, data, "");
		SetImageProperty(trans, data, "");
		trans.gameObject.SetActive(value: true);
		StartCoroutine(G3TipsManager(trans.gameObject, (int)data["time"]));
		Transform transform = trans.transform.Find("icon");
		SetBaseProperty(transform, data, "icon_");
		SetImageProperty(transform, data, "icon_");
		Transform transform2 = trans.transform.Find("title");
		SetBaseProperty(transform2, data, "title_");
		SetTextProperty(transform2, data, "title_");
		if (type != 1)
		{
			Transform transform3 = trans.transform.Find("details");
			SetBaseProperty(transform3, data, "details_");
			SetTextProperty(transform3, data, "details_");
			Transform transform4 = trans.transform.Find("image1");
			SetBaseProperty(transform4, data, "image1_");
			SetImageProperty(transform4, data, "image1_");
		}
		if (type == 0 || type == 1)
		{
			Transform transform5 = trans.transform.Find("explain");
			SetBaseProperty(transform5, data, "explain_");
			SetTextProperty(transform5, data, "explain_");
			Transform transform6 = trans.transform.Find("source");
			SetBaseProperty(transform6, data, "source_");
			SetTextProperty(transform6, data, "source_");
		}
		if (type == 0)
		{
			Transform transform7 = trans.transform.Find("time");
			SetBaseProperty(transform7, data, "system_time_");
			SetTextProperty(transform7, data, "system_time_");
		}
		Transform transform8 = trans.transform.Find("Button");
		SetBaseProperty(transform8, data, "button_");
		SetImageProperty(transform8, data, "button_");
		transform8.GetComponent<Button>().onClick.AddListener(delegate
		{
			StartCoroutine(G3TipsManager(trans.gameObject, 0f));
		});
		Transform transform9 = transform8.transform.Find("Text");
		SetBaseProperty(transform9, data, "button_text_");
		SetTextProperty(transform9, data, "button_text_");
	}

	private void SetBaseProperty(Transform trans, JsonData data, string value)
	{
		string prop_name = value + "pos";
		string prop_name2 = value + "angles";
		string prop_name3 = value + "size";
		string prop_name4 = value + "scale";
		trans.GetComponent<RectTransform>().anchoredPosition3D = new Vector3(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]));
		trans.GetComponent<RectTransform>().eulerAngles = new Vector3(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]));
		trans.GetComponent<RectTransform>().sizeDelta = new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1]));
		trans.GetComponent<RectTransform>().localScale = new Vector3(JsonToFloat(data[prop_name4][0]), JsonToFloat(data[prop_name4][1]), JsonToFloat(data[prop_name4][2]));
	}

	private void SetImageProperty(Transform image, JsonData data, string value)
	{
		string prop_name = value + "sprite";
		string prop_name2 = value + "color";
		string prop_name3 = value + "size";
		image.GetComponent<Image>().sprite = LoadSprite(new Vector2(JsonToFloat(data[prop_name3][0]), JsonToFloat(data[prop_name3][1])), (string)data[prop_name]);
		image.GetComponent<Image>().color = new Color(JsonToFloat(data[prop_name2][0]), JsonToFloat(data[prop_name2][1]), JsonToFloat(data[prop_name2][2]), JsonToFloat(data[prop_name2][3]));
	}

	private void SetTextProperty(Transform text, JsonData data, string value)
	{
		string prop_name = value + "color";
		string prop_name2 = value + "font_size";
		string prop_name3 = value + "font_style";
		string prop_name4 = value + "text";
		text.GetComponent<Text>().text = (string)data[prop_name4];
		text.GetComponent<Text>().color = new Color(JsonToFloat(data[prop_name][0]), JsonToFloat(data[prop_name][1]), JsonToFloat(data[prop_name][2]), JsonToFloat(data[prop_name][3]));
		text.GetComponent<Text>().fontSize = (int)data[prop_name2];
		text.GetComponent<Text>().fontStyle = (FontStyle)(int)data[prop_name3];
	}

	private IEnumerator G3TipsManager(GameObject tip, float time)
	{
		yield return new WaitForSeconds(time);
		tip.SetActive(value: false);
	}

	private float JsonToFloat(JsonData data)
	{
		return Convert.ToSingle((string)data);
	}

	private bool SDKManagerInitFPS()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>(includeInactive: true);
		GameObject gameObject = null;
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.gameObject.name == "FPS")
			{
				gameObject = transform.gameObject;
			}
		}
		if (gameObject != null)
		{
			if (systemFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			int res = 0;
			Render.UPvr_GetIntConfig(10, ref res);
			if (Convert.ToBoolean(res))
			{
				gameObject.SetActive(value: true);
				return true;
			}
			if (ShowFPS)
			{
				gameObject.SetActive(value: true);
				return true;
			}
			return false;
		}
		return false;
	}

	private bool SDKManagerInitConfigProfile()
	{
		pvr_UnitySDKConfig = Pvr_UnitySDKConfigProfile.Default;
		return true;
	}

	private bool SDKManagerInitEditor()
	{
		if (pvr_UnitySDKEditor == null)
		{
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		else
		{
			pvr_UnitySDKEditor = null;
			pvr_UnitySDKEditor = base.gameObject.AddComponent<Pvr_UnitySDKEditor>();
		}
		return true;
	}

	private bool SDKManagerInitPara()
	{
		return true;
	}

	public void SDKManagerLongHomeKey()
	{
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			return;
		}
		if (isHasController)
		{
			if (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected)
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
			}
			else
			{
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
		}
		else
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
	}

	private void setLongHomeKey()
	{
		if (sdk.HmdOnlyrot)
		{
			if (Pvr_UnitySDKSensor.Instance != null)
			{
				PLOG.I(Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor() ? "Long Home Key to Reset Sensor Success!" : "Long Home Key to Reset Sensor Failed!");
			}
			return;
		}
		if (trackingmode == 4 || trackingmode == 5 || trackingmode == 6)
		{
			Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
		}
		else
		{
			if (trackingmode == 2 || trackingmode == 3)
			{
				if (isHasController && (Controller.UPvr_GetControllerState(0) == ControllerState.Connected || Controller.UPvr_GetControllerState(1) == ControllerState.Connected))
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(0, 1);
				}
				else
				{
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
			}
			if (trackingmode == 0 || trackingmode == 1)
			{
				Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
			}
		}
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
	}

	public void verifyAPPCallback(string code)
	{
		UnityEngine.Debug.Log("PvrLog verifyAPPCallback" + code);
		AppCheckResult = Convert.ToInt32(code);
		if (Pvr_UnitySDKManager.EntitlementCheckResultEvent != null)
		{
			Pvr_UnitySDKManager.EntitlementCheckResultEvent(AppCheckResult);
		}
	}

	public void IpdRefreshCallBack(string ipd)
	{
		UnityEngine.Debug.Log("PvrLog IpdRefreshCallBack");
		Pvr_UnitySDKEye[] eyes = Pvr_UnitySDKEyeManager.Instance.Eyes;
		for (int i = 0; i < eyes.Length; i++)
		{
			eyes[i].RefreshCameraPosition(Convert.ToSingle(ipd));
		}
	}

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT Unity Version:" + Application.unityVersion);
		Vector3 vector = neckOffset;
		UnityEngine.Debug.Log("DISFT Customize NeckOffset:" + vector.ToString());
		UnityEngine.Debug.Log("DISFT MSAA :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			UnityEngine.Debug.Log("DISFT LWRP = Enable");
		}
		UnityEngine.Debug.Log("DISFT Content Proctect :" + Pvr_UnitySDKProjectSetting.GetProjectConfig().usecontentprotect);
		int res = 0;
		LoadIsMirroringValue();
		if (!ismirroring)
		{
			Render.UPvr_GetIntConfig(18, ref res);
			if (res == 1)
			{
				UnityEngine.Debug.Log("DISFT ScreenOrientation.Portrait = Enable");
				Screen.orientation = ScreenOrientation.Portrait;
			}
		}
		else
		{
			Render.UPvr_GetIntConfig(19, ref res);
			Screen.orientation = ((res == 0) ? ScreenOrientation.Portrait : ScreenOrientation.LandscapeLeft);
		}
		new AndroidJavaClass("com.psmart.vrlib.VrActivity");
		new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		Pvr_ControllerManager pvr_ControllerManager = UnityEngine.Object.FindObjectOfType<Pvr_ControllerManager>();
		isHasController = pvr_ControllerManager != null;
		PLOG.getConfigTraceLevel();
		Render.UPvr_GetIntConfig(5, ref trackingmode);
		Application.targetFrameRate = 61;
		int res2 = 0;
		Render.UPvr_GetIntConfig(3, ref res2);
		if (res2 == 0)
		{
			SDK.HmdOnlyrot = true;
		}
		int res3 = -1;
		Render.UPvr_GetIntConfig(9, ref res3);
		float res4 = 0f;
		Render.UPvr_GetFloatConfig(6, ref res4);
		Application.targetFrameRate = ((res3 > 0) ? res3 : ((int)res4));
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultfps)
		{
			if ((float)Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps <= res4)
			{
				Application.targetFrameRate = Pvr_UnitySDKProjectSetting.GetProjectConfig().customfps;
			}
			else
			{
				Application.targetFrameRate = (int)res4;
			}
		}
		UnityEngine.Debug.Log("DISFT Customize FPS :" + Application.targetFrameRate);
		if (!UseCustomNeckPara)
		{
			float res5 = 0f;
			float res6 = 0f;
			float res7 = 0f;
			int configsenum = 4;
			int configsenum2 = 5;
			Render.UPvr_GetFloatConfig(3, ref res5);
			Render.UPvr_GetFloatConfig(configsenum, ref res6);
			Render.UPvr_GetFloatConfig(configsenum2, ref res7);
			if (res5 != 0f || res6 != 0f || res7 != 0f)
			{
				neckOffset = new Vector3(res5, res6, res7);
			}
		}
		Render.UPvr_GetIntConfig(16, ref iPhoneHMDModeEnabled);
		Pvr_ControllerManager.ControllerStatusChangeEvent += CheckControllerStateForG2;
		InitUI();
		RefreshTextByLanguage();
	}

	private IEnumerator Start()
	{
		if (SDKManagerInit())
		{
			PLOG.I("SDK Init success.");
		}
		else
		{
			PLOG.E("SDK Init Failed.");
			Application.Quit();
		}
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.ReInit();
		}
		SDKManagerInitFPS();
		if (Pvr_UnitySDKPlatformSetting.StartTimeEntitlementCheck)
		{
			if (PlatformSettings.UPvr_IsCurrentDeviceValid() != Pvr_UnitySDKPlatformSetting.simulationType.Valid)
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT PASS");
				string appID = Pvr_UnitySDKPlatformSetting.Instance.appID;
				UnityEngine.Debug.Log("DISFT Start-time Entitlement Check Enable");
				PLOG.I("DISFT Start-time Entitlement Check APPID :" + appID);
				PlatformSettings.UPvr_AppEntitlementCheckExtra(appID);
			}
			else
			{
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation PASS");
			}
		}
		yield return StartCoroutine(InitRenderThreadRoutine());
	}

	private IEnumerator InitRenderThreadRoutine()
	{
		PLOG.I("InitRenderThreadRoutine begin");
		int i = 0;
		while (i < 2)
		{
			yield return null;
			int num = i + 1;
			i = num;
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine after a wait");
		if (Pvr_UnitySDKRender.Instance != null)
		{
			Pvr_UnitySDKRender.Instance.IssueRenderThread();
		}
		else
		{
			UnityEngine.Debug.Log("InitRenderThreadRoutine pvr_UnitySDKRender == null");
		}
		UnityEngine.Debug.Log("InitRenderThreadRoutine end");
	}

	private void Update()
	{
		if (isHasController && iPhoneHMDModeEnabled == 1 && Controller.UPvr_GetControllerPower(0) == 0 && Pvr_ControllerManager.controllerlink.controller0Connected && Pvr_ControllerManager.controllerlink.Controller0.Rotation.eulerAngles != Vector3.zero)
		{
			if (!lowControllerpowerstate)
			{
				StartCoroutine(ToastManager(6, state: true, 0f));
				StartCoroutine(ToastManager(6, state: false, 3f));
				lowControllerpowerstate = true;
			}
			controllerpowershowtime += Time.deltaTime;
			if (controllerpowershowtime >= 3600f)
			{
				lowControllerpowerstate = false;
				controllerpowershowtime = 0f;
			}
		}
		if (Input.touchCount == 1 && Input.touches[0].phase == TouchPhase.Began)
		{
			newPicovrTriggered = true;
		}
		if (Input.GetKeyDown(KeyCode.JoystickButton0))
		{
			newPicovrTriggered = true;
		}
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.SensorUpdate();
		}
		picovrTriggered = newPicovrTriggered;
		newPicovrTriggered = false;
	}

	private void OnDestroy()
	{
		if (sdk == this)
		{
			sdk = null;
		}
		RenderTexture.active = null;
		Resources.UnloadUnusedAssets();
		GC.Collect();
		Pvr_ControllerManager.ControllerStatusChangeEvent -= CheckControllerStateForG2;
	}

	private void OnEnable()
	{
		if (sdk == null)
		{
			sdk = this;
		}
		else if (sdk != this)
		{
			sdk = this;
		}
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnPause()
	{
		Pvr_UnitySDKAPI.System.UPvr_StopHomeKeyReceiver();
		LeaveVRMode();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StopUnitySDKSensor();
		}
	}

	private void OnApplicationPause(bool pause)
	{
		bool flag = pause;
		UnityEngine.Debug.Log("OnApplicationPause-------------------------" + (flag ? "true" : "false"));
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity() && !Pvr_UnitySDKRender.Instance.isShellMode)
		{
			bool flag2 = Pvr_UnitySDKAPI.System.UPvr_GetMainActivityPauseStatus();
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity Pause State:" + flag2);
			pause = flag2;
		}
		if (flag == pause)
		{
			if (pause)
			{
				onResume = false;
				OnPause();
			}
			else
			{
				onResume = true;
				GL.InvalidateState();
				StartCoroutine(OnResume());
			}
		}
		else if (pause)
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity pause Unity resume");
			GL.InvalidateState();
			StartCoroutine(OnResume());
			onResume = false;
			OnPause();
		}
		else
		{
			UnityEngine.Debug.Log("OnApplicationPause-------------------------Activity resume Unity pause");
			OnPause();
			onResume = true;
			GL.InvalidateState();
			StartCoroutine(OnResume());
		}
	}

	public void EnterVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Resume);
		isEnterVRMode = true;
		if (eventEnterVRMode != null)
		{
			eventEnterVRMode();
		}
	}

	public void LeaveVRMode()
	{
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.Pause);
		isEnterVRMode = false;
	}

	public void SixDofForceQuit()
	{
		Application.Quit();
	}

	private void InitUI()
	{
		if (iPhoneHMDModeEnabled == 1)
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load("Prefabs/flamingo2Tips") as GameObject, base.transform.Find("Head"), worldPositionStays: false).transform;
			calltoast = transform.Find("Call").gameObject;
			msgtoast = transform.Find("Msg").gameObject;
			lowhmdBatterytoast = transform.Find("LowHmdBattery").gameObject;
			lowphoneBatterytoast = transform.Find("LowPhoneBattery").gameObject;
			LowPhoneHealthtoast = transform.Find("LowPhoneHealth").gameObject;
			LowcontrollerBatterytoast = transform.Find("LowControllerBattery").gameObject;
		}
	}

	private void RefreshTextByLanguage()
	{
		if (msgtoast != null)
		{
			msgtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast0");
			msgtoast.transform.Find("string").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("msgtoast1");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast0");
			calltoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("calltoast1");
			lowhmdBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowhmdBatterytoast");
			lowphoneBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("lowphoneBatterytoast");
			LowPhoneHealthtoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowPhoneHealthtoast");
			LowcontrollerBatterytoast.transform.Find("Text").GetComponent<Text>().text = Pvr_UnitySDKAPI.System.UPvr_GetLangString("LowcontrollerBatterytoast");
		}
	}

	private void LoadIsMirroringValue()
	{
		AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		AndroidJavaObject androidJavaObject = @static.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
		string text = @static.Call<string>("getPackageName", Array.Empty<object>());
		AndroidJavaObject androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getApplicationInfo", new object[2] { text, 128 }).Get<AndroidJavaObject>("metaData");
		ismirroring = Convert.ToBoolean(androidJavaObject2.Call<int>("getInt", new object[2] { "bypass_presentation", 0 }));
	}

	private IEnumerator OnResume()
	{
		int ability6dof = 0;
		Render.UPvr_GetIntConfig(3, ref ability6dof);
		RefreshTextByLanguage();
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.StartUnitySDKSensor();
			int res = -1;
			Render.UPvr_GetIntConfig(8, ref res);
			if (res != 1)
			{
				int res2 = -1;
				Render.UPvr_GetIntConfig(11, ref res2);
				if (res2 != 8)
				{
					Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
				}
			}
		}
		if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
		{
			PLOG.I("onresume set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
			PLOG.I("onresume presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
		}
		for (int j = 0; j < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; j++)
		{
			Pvr_UnitySDKEyeManager.Instance.Eyes[j].RefreshCameraPosition(Pvr_UnitySDKAPI.System.UPvr_GetIPD());
		}
		int waitNum = 15;
		Render.UPvr_GetIntConfig(20, ref waitNum);
		int resetNum = 10;
		Render.UPvr_GetIntConfig(21, ref resetNum);
		for (int i = 0; i < waitNum; i++)
		{
			if (i == resetNum && ResetTrackerOnLoad && ability6dof == 1)
			{
				UnityEngine.Debug.Log("Reset Tracker OnLoad");
				Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
			}
			yield return null;
		}
		EnterVRMode();
		Pvr_UnitySDKAPI.System.UPvr_StartHomeKeyReceiver(base.gameObject.name);
		Pvr_UnitySDKEye.setLevel = false;
		if (longPressHomeKeyAction != null)
		{
			longPressHomeKeyAction();
		}
		if (Render.UPvr_GetIntSysProc("pvrsist.foveation.level", ref SystemDebugFFRLevel))
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemDebugFFRLevel);
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level is : " + SystemDebugFFRLevel);
		}
		else
		{
			UnityEngine.Debug.Log("DISFT OnResume Get System Debug ffr level Error,ffr level is : " + SystemDebugFFRLevel);
		}
		if (SystemDebugFFRLevel == -1)
		{
			Render.UPvr_GetIntConfig(22, ref SystemFFRLevel);
			if (SystemFFRLevel != -1)
			{
				Render.SetFoveatedRenderingLevel((EFoveationLevel)SystemFFRLevel);
				UnityEngine.Debug.Log("DISFT OnResume Get System ffr level is : " + SystemFFRLevel);
			}
		}
	}
}
public class QuitGame : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			Application.Quit();
		}
	}
}
public class Pvr_UnityEyeMask : MonoBehaviour
{
	private class EyeMaskData
	{
		public Eye eyeSide;

		public Camera camera;

		public CommandBuffer cmdBuf;
	}

	private Shader eyeMaskShader;

	private Material eyeMaskMaterial;

	private Mesh eyeMaskMeshLeft;

	private Mesh eyeMaskMeshRight;

	private Mesh eyeMaskMeshBoth;

	private float zDir = -1f;

	private Color eyeMaskColor = Color.black;

	private List<EyeMaskData> cameraDataList = new List<EyeMaskData>();

	private void Awake()
	{
		UnityEngine.Debug.Log("DISFT EyeMask = Enable");
		if (SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES3 || SystemInfo.graphicsDeviceType == GraphicsDeviceType.OpenGLES2)
		{
			zDir = -1f;
		}
		else if (SystemInfo.usesReversedZBuffer)
		{
			zDir = 1f;
		}
		else
		{
			zDir = 0f;
		}
	}

	private void OnEnable()
	{
		if (eyeMaskShader == null)
		{
			eyeMaskShader = Shader.Find("Pvr_UnitySDK/Pvr_EyeMask");
		}
		if (eyeMaskMaterial == null && eyeMaskShader != null)
		{
			eyeMaskMaterial = new Material(eyeMaskShader);
			eyeMaskMaterial.SetColor("_Color", eyeMaskColor);
		}
		if (eyeMaskMaterial == null)
		{
			base.enabled = false;
			UnityEngine.Debug.LogWarning("EyeMask materil is null or EyeMask shader not found!");
		}
		else
		{
			PrepareCameras();
			Camera.onPreRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
			CreateCommandBuffer();
		}
	}

	private void OnDisable()
	{
		Camera.onPreRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPreRender, new Camera.CameraCallback(OnCustomPreRender));
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.camera != null && cameraData.cmdBuf != null)
			{
				RemoveCameraCommandBuffer(cameraData);
			}
		}
		CleanEyeMask();
	}

	private void CreateCommandBuffer()
	{
		if (VerifyCommadBuffer())
		{
			return;
		}
		if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
		{
			eyeMaskMeshLeft = GetStencilMesh(Eye.LeftEye);
			eyeMaskMeshRight = GetStencilMesh(Eye.RightEye);
			if (eyeMaskMeshLeft == null || eyeMaskMeshRight == null)
			{
				UnityEngine.Debug.LogWarning("Stencil Mesh is not exist, disable EyeMask.");
				base.enabled = false;
				return;
			}
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData.eyeSide == Eye.LeftEye)
			{
				CommandBuffer commandBuffer = new CommandBuffer();
				commandBuffer.name = "EyeMaskLeft";
				commandBuffer.DrawMesh(eyeMaskMeshLeft, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer;
			}
			else if (cameraData.eyeSide == Eye.RightEye)
			{
				CommandBuffer commandBuffer2 = new CommandBuffer();
				commandBuffer2.name = "EyeMaskRight";
				commandBuffer2.DrawMesh(eyeMaskMeshRight, Matrix4x4.identity, eyeMaskMaterial, 0, 0);
				cameraData.cmdBuf = commandBuffer2;
			}
			else if (cameraData.eyeSide == Eye.BothEye)
			{
				if (eyeMaskMeshBoth == null)
				{
					eyeMaskMeshBoth = GetStencilMeshBoth(eyeMaskMeshLeft, eyeMaskMeshRight);
					float value = Mathf.Max(Mathf.Abs(eyeMaskMeshLeft.bounds.max.x), Mathf.Abs(eyeMaskMeshRight.bounds.min.x));
					eyeMaskMaterial.SetFloat("_MeshOffsetX", value);
				}
				CommandBuffer commandBuffer3 = new CommandBuffer();
				commandBuffer3.name = "EyeMaskBoth";
				commandBuffer3.DrawMesh(eyeMaskMeshBoth, Matrix4x4.identity, eyeMaskMaterial, 0, 1);
				cameraData.cmdBuf = commandBuffer3;
			}
		}
	}

	private void OnCustomPreRender(Camera cam)
	{
		if (!VerifyCommadBuffer())
		{
			UnityEngine.Debug.LogWarning("Verify CommandBuffer failed!");
			return;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (!(cameraData.camera != cam))
			{
				RemoveCameraCommandBuffer(cameraData);
				AddCameraCommandBuffer(cameraData);
			}
		}
	}

	private Mesh GetStencilMesh(Eye eyeSide)
	{
		int vertexCount = 0;
		int triangleCount = 0;
		IntPtr vertexDataPtr = IntPtr.Zero;
		IntPtr indexDataPtr = IntPtr.Zero;
		Render.UPvr_GetStencilMesh((int)eyeSide, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		if (vertexCount <= 0 || triangleCount <= 0 || vertexDataPtr == IntPtr.Zero || indexDataPtr == IntPtr.Zero)
		{
			return null;
		}
		Vector3[] array = new Vector3[vertexCount];
		int[] array2 = new int[triangleCount * 3];
		float[] array3 = new float[vertexCount * 3];
		int[] array4 = new int[triangleCount * 3];
		Marshal.Copy(vertexDataPtr, array3, 0, vertexCount * 3);
		Marshal.Copy(indexDataPtr, array4, 0, triangleCount * 3);
		for (int i = 0; i < vertexCount; i++)
		{
			array[i] = new Vector3(array3[3 * i], array3[3 * i + 1], zDir);
		}
		for (int j = 0; j < triangleCount; j++)
		{
			array2[3 * j] = array4[3 * j + 2];
			array2[3 * j + 1] = array4[3 * j + 1];
			array2[3 * j + 2] = array4[3 * j];
		}
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskMesh";
		mesh.vertices = array;
		mesh.SetIndices(array2, MeshTopology.Triangles, 0);
		return mesh;
	}

	private Mesh GetStencilMeshBoth(Mesh leftMesh, Mesh rightMesh)
	{
		float num = Mathf.Max(Mathf.Abs(leftMesh.bounds.max.x), Mathf.Abs(rightMesh.bounds.min.x));
		Mesh mesh = new Mesh();
		mesh.name = "EyeMaskBoth";
		CombineInstance combineInstance = default(CombineInstance);
		combineInstance.mesh = leftMesh;
		Matrix4x4 identity = Matrix4x4.identity;
		identity.SetTRS(Vector3.left * num, Quaternion.identity, Vector3.one);
		combineInstance.transform = identity;
		CombineInstance combineInstance2 = default(CombineInstance);
		combineInstance2.mesh = rightMesh;
		Matrix4x4 identity2 = Matrix4x4.identity;
		identity2.SetTRS(Vector3.right * num, Quaternion.identity, Vector3.one);
		combineInstance2.transform = identity2;
		CombineInstance[] combine = new CombineInstance[2] { combineInstance, combineInstance2 };
		mesh.CombineMeshes(combine);
		return mesh;
	}

	private bool VerifyCommadBuffer()
	{
		if (cameraDataList == null || cameraDataList.Count <= 0)
		{
			return false;
		}
		foreach (EyeMaskData cameraData in cameraDataList)
		{
			if (cameraData == null || cameraData.cmdBuf == null)
			{
				return false;
			}
		}
		return true;
	}

	private void PrepareCameras()
	{
		cameraDataList.Clear();
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			if (Pvr_UnitySDKEyeManager.Instance.BothEyeCamera == null)
			{
				UnityEngine.Debug.LogWarning("BothEye Camera is null!");
				return;
			}
			EyeMaskData eyeMaskData = new EyeMaskData();
			eyeMaskData.eyeSide = Eye.BothEye;
			eyeMaskData.camera = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			cameraDataList.Add(eyeMaskData);
		}
		else if (Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera == null || Pvr_UnitySDKEyeManager.Instance.RightEyeCamera == null)
		{
			UnityEngine.Debug.LogWarning("LeftEye or RightEye Camera is null!");
		}
		else
		{
			EyeMaskData eyeMaskData2 = new EyeMaskData();
			eyeMaskData2.eyeSide = Eye.LeftEye;
			eyeMaskData2.camera = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			eyeMaskData2.cmdBuf = null;
			cameraDataList.Add(eyeMaskData2);
			EyeMaskData eyeMaskData3 = new EyeMaskData();
			eyeMaskData3.eyeSide = Eye.RightEye;
			eyeMaskData3.camera = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
			eyeMaskData3.cmdBuf = null;
			cameraDataList.Add(eyeMaskData3);
		}
	}

	private void AddCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void RemoveCameraCommandBuffer(EyeMaskData data)
	{
		data.camera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, data.cmdBuf);
	}

	private void CleanEyeMask()
	{
		cameraDataList.Clear();
		eyeMaskMeshLeft = null;
		eyeMaskMeshRight = null;
		eyeMaskMeshBoth = null;
		eyeMaskShader = null;
		eyeMaskMaterial = null;
	}
}
[RequireComponent(typeof(Camera))]
public class Pvr_UnitySDKEye : MonoBehaviour
{
	public static List<Pvr_UnitySDKEye> Instances = new List<Pvr_UnitySDKEye>();

	public Eye eyeSide;

	private int eyeCameraOriginCullingMask;

	private CameraClearFlags eyeCameraOriginClearFlag;

	private Color eyeCameraOriginBackgroundColor;

	private int lastBoundaryState;

	private Matrix4x4 realProj = Matrix4x4.identity;

	private const int bufferSize = 3;

	private int IDIndex;

	private RenderEventType eventType;

	private int previousId;

	public static bool setLevel = false;

	private Material mat_Vignette;

	public Camera eyecamera { get; private set; }

	private void Awake()
	{
		Instances.Add(this);
		eyecamera = GetComponent<Camera>();
	}

	private void Start()
	{
		Setup(eyeSide);
		SetupUpdate();
		if (eyecamera != null)
		{
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
		}
	}

	private void Update()
	{
		if (!(eyecamera != null) || !eyecamera.enabled)
		{
			return;
		}
		int num = BoundarySystem.UPvr_GetSeeThroughState();
		if (num == lastBoundaryState)
		{
			return;
		}
		switch (num)
		{
		case 2:
			eyeCameraOriginCullingMask = eyecamera.cullingMask;
			eyeCameraOriginClearFlag = eyecamera.clearFlags;
			eyeCameraOriginBackgroundColor = eyecamera.backgroundColor;
			eyecamera.cullingMask = 0;
			eyecamera.clearFlags = CameraClearFlags.Color;
			eyecamera.backgroundColor = Color.black;
			break;
		case 1:
			if (lastBoundaryState == 2)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		default:
			if (lastBoundaryState == 2 || lastBoundaryState == 1)
			{
				if (eyecamera.cullingMask == 0)
				{
					eyecamera.cullingMask = eyeCameraOriginCullingMask;
				}
				if (eyecamera.clearFlags == CameraClearFlags.Color)
				{
					eyecamera.clearFlags = eyeCameraOriginClearFlag;
				}
				if (eyecamera.backgroundColor == Color.black)
				{
					eyecamera.backgroundColor = eyeCameraOriginBackgroundColor;
				}
			}
			break;
		}
		lastBoundaryState = num;
	}

	private void OnEnable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.beginCameraRendering += MyPreRender;
			RenderPipelineManager.endCameraRendering += MyPostRender;
		}
	}

	private void OnDisable()
	{
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			RenderPipelineManager.beginCameraRendering -= MyPreRender;
			RenderPipelineManager.endCameraRendering -= MyPostRender;
		}
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void MyPreRender(Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPreRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPreRender();
		}
	}

	public void MyPostRender(ScriptableRenderContext context, Camera camera)
	{
		if (!(camera.gameObject != base.gameObject))
		{
			OnPostRender();
		}
	}

	private void OnPreRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPreRender();
		}
		SetFFRParameter();
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.BeginEye);
	}

	private void OnPostRender()
	{
		if (!eyecamera.enabled)
		{
			return;
		}
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex]));
		Pvr_UnitySDKPluginEvent.Issue(eventType);
		if (Pvr_UnitySDKRender.Instance.StereoRendering != null)
		{
			if (Pvr_UnitySDKRender.Instance.isSwitchSDK)
			{
				return;
			}
			Pvr_UnitySDKRender.Instance.StereoRendering.OnSDKPostRender();
		}
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.EndEye);
	}

	public void EyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex].DiscardContents();
			eyecamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[IDIndex];
		}
	}

	private void Setup(Eye eyeSide)
	{
		eyecamera = GetComponent<Camera>();
		switch (eyeSide)
		{
		case Eye.LeftEye:
		case Eye.RightEye:
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
			break;
		case Eye.BothEye:
			base.transform.localPosition = Vector3.zero;
			break;
		}
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		eyecamera.rect = new Rect(0f, 0f, 1f, 1f);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eventType = ((eyeSide == Eye.LeftEye) ? RenderEventType.LeftEyeEndFrame : RenderEventType.RightEyeEndFrame);
		}
		else
		{
			eventType = RenderEventType.BothEyeEndFrame;
		}
	}

	private void SetupUpdate()
	{
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			eyecamera.enabled = !Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath != StereoRenderingPathPico.SinglePass;
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.enabled = Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass;
		}
		eyecamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		eyecamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx + (int)eyeSide * 3;
		}
		else if (eyeSide == Eye.BothEye)
		{
			IDIndex = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.isSwitchSDK = Pvr_UnitySDKRender.Instance.lastEyeTextureIdx == Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.lastEyeTextureIdx = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
		}
	}

	public void RefreshCameraPosition(float ipd)
	{
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - ipd) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(ipd / 2f, 0f, 0f);
		if (eyeSide == Eye.LeftEye || eyeSide == Eye.RightEye)
		{
			base.transform.localPosition = Pvr_UnitySDKManager.SDK.EyeOffset(eyeSide);
		}
		else if (eyeSide == Eye.BothEye)
		{
			eyecamera.stereoSeparation = ipd;
		}
	}

	private void DrawVignetteLine()
	{
		if (null == mat_Vignette)
		{
			mat_Vignette = new Material(Shader.Find("Diffuse"));
			if (null == mat_Vignette)
			{
				return;
			}
		}
		GL.PushMatrix();
		mat_Vignette.SetPass(0);
		GL.LoadOrtho();
		vignette();
		GL.PopMatrix();
	}

	private void vignette()
	{
		GL.Begin(7);
		GL.Color(Color.black);
		GL.Vertex3(0f, 1f, 0f);
		GL.Vertex3(1f, 1f, 0f);
		GL.Vertex3(1f, 0.995f, 0f);
		GL.Vertex3(0f, 0.995f, 0f);
		GL.Vertex3(0f, 0f, 0f);
		GL.Vertex3(0f, 0.005f, 0f);
		GL.Vertex3(1f, 0.005f, 0f);
		GL.Vertex3(1f, 0f, 0f);
		GL.Vertex(new Vector3(0f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 1f, 0f));
		GL.Vertex(new Vector3(0.005f, 0f, 0f));
		GL.Vertex(new Vector3(0f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 1f, 0f));
		GL.Vertex(new Vector3(1f, 0f, 0f));
		GL.Vertex(new Vector3(0.995f, 0f, 0f));
		GL.End();
	}

	private void SetFFRParameter()
	{
		Vector3 vector = Vector3.zero;
		if (Pvr_UnitySDKManager.SDK.isEnterVRMode && Pvr_UnitySDKEyeManager.supportEyeTracking && Pvr_UnitySDKEyeManager.Instance.EyeTracking)
		{
			vector = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingPos();
		}
		int textureId = Pvr_UnitySDKRender.Instance.eyeTextureIds[IDIndex];
		Render.UPvr_SetFoveationResource(textureId, previousId, vector.x, vector.y);
		previousId = textureId;
	}
}
public class Pvr_UnitySDKEyeManager : MonoBehaviour
{
	private static Pvr_UnitySDKEyeManager instance;

	private Pvr_UnitySDKEye[] eyes;

	[HideInInspector]
	public Camera LeftEyeCamera;

	[HideInInspector]
	public Camera RightEyeCamera;

	[HideInInspector]
	public Camera MonoEyeCamera;

	[HideInInspector]
	public Camera BothEyeCamera;

	private int MonoEyeTextureID;

	private readonly int WaitSplashScreenFrames = 3;

	private int frameNum;

	[SerializeField]
	[HideInInspector]
	private bool foveatedRendering;

	[SerializeField]
	[HideInInspector]
	private EFoveationLevel foveationLevel;

	private int eyeTextureId;

	private RenderEventType eventType = RenderEventType.LeftEyeEndFrame;

	private Pvr_UnitySDKEyeOverlay compositeLayer;

	private int overlayLayerDepth = 1;

	private int underlayLayerDepth;

	private bool isHeadLocked;

	private int layerFlags;

	[HideInInspector]
	public bool EyeTracking;

	[HideInInspector]
	public Vector3 eyePoint;

	private EyeTrackingData eyePoseData;

	[HideInInspector]
	public static bool supportEyeTracking;

	[Tooltip("If true, specific color gradient when switching scenes.")]
	public bool screenFade;

	[Tooltip("Define the duration of screen fade.")]
	public float fadeTime = 5f;

	[Tooltip("Define the color of screen fade.")]
	public Color fadeColor = new Color(0f, 0f, 0f, 1f);

	public int renderQueue = 5000;

	private MeshRenderer fadeMeshRenderer;

	private MeshFilter fadeMeshFilter;

	private Material fadeMaterial;

	private float elapsedTime;

	private bool isFading;

	private float currentAlpha;

	private float nowFadeAlpha;

	public static Pvr_UnitySDKEyeManager Instance
	{
		get
		{
			if (instance == null)
			{
				PLOG.E("Pvr_UnitySDKEyeManager instance is not init yet...");
			}
			return instance;
		}
	}

	public Pvr_UnitySDKEye[] Eyes
	{
		get
		{
			if (eyes == null)
			{
				eyes = Pvr_UnitySDKEye.Instances.ToArray();
			}
			return eyes;
		}
	}

	[HideInInspector]
	public bool FoveatedRendering
	{
		get
		{
			return foveatedRendering;
		}
		set
		{
			if (value == foveatedRendering)
			{
				return;
			}
			foveatedRendering = value;
			if (Application.isPlaying)
			{
				Render.UPvr_EnableFoveation(enable: true);
				if (!foveatedRendering)
				{
					Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
				}
			}
		}
	}

	[HideInInspector]
	public EFoveationLevel FoveationLevel
	{
		get
		{
			return foveationLevel;
		}
		set
		{
			if (value != foveationLevel)
			{
				foveationLevel = value;
			}
		}
	}

	private void SetCameraEnableEditor()
	{
		MonoEyeCamera.enabled = !Pvr_UnitySDKManager.SDK.VRModeEnabled || Pvr_UnitySDKManager.SDK.Monoscopic;
		for (int i = 0; i < Eyes.Length; i++)
		{
			if (Eyes[i].eyeSide == Eye.LeftEye || Eyes[i].eyeSide == Eye.RightEye)
			{
				Eyes[i].eyecamera.enabled = Pvr_UnitySDKManager.SDK.VRModeEnabled;
			}
			else if (Eyes[i].eyeSide == Eye.BothEye)
			{
				Eyes[i].eyecamera.enabled = false;
			}
		}
	}

	private void SetCamerasEnableByStereoRendering()
	{
		MonoEyeCamera.enabled = Pvr_UnitySDKManager.SDK.Monoscopic && Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.MultiPass;
	}

	private void SetupMonoCamera()
	{
		base.transform.localPosition = Vector3.zero;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeCamera.rect = new Rect(0f, 0f, 1f, 1f);
	}

	private void SetupUpdate()
	{
		MonoEyeCamera.fieldOfView = Pvr_UnitySDKRender.Instance.EyeVFoV;
		MonoEyeCamera.aspect = Pvr_UnitySDKManager.SDK.EyesAspect;
		MonoEyeTextureID = Pvr_UnitySDKRender.Instance.currEyeTextureIdx;
	}

	private void MonoEyeRender()
	{
		SetupUpdate();
		if (Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID] != null)
		{
			Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID].DiscardContents();
			MonoEyeCamera.targetTexture = Pvr_UnitySDKRender.Instance.eyeTextures[MonoEyeTextureID];
		}
	}

	private void Awake()
	{
		if (MonoEyeCamera == null)
		{
			MonoEyeCamera = GetComponent<Camera>();
		}
		if (LeftEyeCamera == null)
		{
			LeftEyeCamera = base.gameObject.transform.Find("LeftEye").GetComponent<Camera>();
		}
		if (RightEyeCamera == null)
		{
			RightEyeCamera = base.gameObject.transform.Find("RightEye").GetComponent<Camera>();
		}
		if (BothEyeCamera == null)
		{
			BothEyeCamera = base.gameObject.transform.Find("BothEye").GetComponent<Camera>();
		}
		if (BothEyeCamera != null)
		{
			BothEyeCamera.transform.GetComponent<Pvr_UnitySDKEye>().eyeSide = Eye.BothEye;
		}
		CreateFadeMesh();
		SetCurrentAlpha(0f);
		Render.UPvr_EnableFoveation(enable: true);
		if (foveatedRendering)
		{
			Render.SetFoveatedRenderingLevel(foveationLevel);
		}
		else
		{
			Render.SetFoveatedRenderingLevel((EFoveationLevel)(-1));
		}
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Combine(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnEnable()
	{
		if (instance == null)
		{
			instance = this;
		}
		else if (instance != this)
		{
			instance = this;
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			Pvr_UnitySDKRender.Instance.StereoRendering.InitEye(BothEyeCamera);
		}
		foreach (Pvr_UnitySDKEyeOverlay instance in Pvr_UnitySDKEyeOverlay.Instances)
		{
			instance.RefreshCamera();
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
			{
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
				{
					UnityEngine.Debug.Log("DISFT Cylinder OverLay = Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
				{
					UnityEngine.Debug.Log("DISFT 360 OverLay= Enable");
				}
				if (instance.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad)
				{
					UnityEngine.Debug.Log("DISFT 2D OverLay= Enable");
				}
			}
			if (instance.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
			{
				UnityEngine.Debug.Log("DISFT UnderLay= Enable");
			}
		}
		GfxDeviceAdvanceFrameGLES();
		StartCoroutine("EndOfFrame");
		if (screenFade)
		{
			StartCoroutine(ScreenFade(1f, 0f));
		}
	}

	private void Start()
	{
		SetCamerasEnableByStereoRendering();
		SetupMonoCamera();
	}

	private void Update()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			for (int i = 0; i < Eyes.Length; i++)
			{
				if (Eyes[i].isActiveAndEnabled && Eyes[i].eyeSide == Eye.BothEye)
				{
					Eyes[i].EyeRender();
				}
			}
		}
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath != 0)
		{
			return;
		}
		if (!Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			for (int j = 0; j < Eyes.Length; j++)
			{
				if (Eyes[j].isActiveAndEnabled && Eyes[j].eyeSide != Eye.BothEye)
				{
					Eyes[j].EyeRender();
				}
			}
		}
		else
		{
			MonoEyeRender();
		}
	}

	private void OnPause()
	{
		Pvr_UnitySDKManager.eventEnterVRMode = (Func<bool>)Delegate.Remove(Pvr_UnitySDKManager.eventEnterVRMode, new Func<bool>(SetEyeTrackingMode));
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private void OnDestroy()
	{
		DestoryFadeMesh();
	}

	private void OnPostRender()
	{
		long data = Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.LeftEyeEndFrame);
		Pvr_UnitySDKAPI.System.UPvr_UnityEventData(data);
		Pvr_UnitySDKPluginEvent.Issue(RenderEventType.RightEyeEndFrame);
	}

	private IEnumerator EndOfFrame()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!Pvr_UnitySDKManager.SDK.isEnterVRMode)
			{
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
			}
			if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum == WaitSplashScreenFrames)
			{
				Pvr_UnitySDKAPI.System.UPvr_RemovePlatformLogo();
				if (Pvr_UnitySDKManager.SDK.ResetTrackerOnLoad)
				{
					UnityEngine.Debug.Log("Reset Tracker OnLoad");
					Pvr_UnitySDKSensor.Instance.OptionalResetUnitySDKSensor(1, 1);
				}
				Pvr_UnitySDKAPI.System.UPvr_StartVRModel();
				Pvr_UnitySDKRender.Instance.isFirstStartup = false;
			}
			else if (Pvr_UnitySDKRender.Instance.isFirstStartup && frameNum < WaitSplashScreenFrames)
			{
				PLOG.I("frameNum:" + frameNum);
				frameNum++;
			}
			int num = BoundarySystem.UPvr_GetSeeThroughState();
			if (Pvr_UnitySDKEyeOverlay.Instances.Count > 0 && num != 2)
			{
				overlayLayerDepth = 1;
				underlayLayerDepth = 0;
				Pvr_UnitySDKEyeOverlay.Instances.Sort();
				for (int i = 0; i < Pvr_UnitySDKEyeOverlay.Instances.Count; i++)
				{
					compositeLayer = Pvr_UnitySDKEyeOverlay.Instances[i];
					if (!compositeLayer.isActiveAndEnabled || (compositeLayer.layerTextures[0] == null && compositeLayer.layerTextures[1] == null && !compositeLayer.isExternalAndroidSurface) || (compositeLayer.layerTransform != null && !compositeLayer.layerTransform.gameObject.activeSelf))
					{
						continue;
					}
					layerFlags = 0;
					if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Quad || compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Cylinder)
					{
						if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Overlay)
						{
							isHeadLocked = false;
							if (compositeLayer.layerTransform != null && compositeLayer.layerTransform.parent == base.transform)
							{
								isHeadLocked = true;
							}
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, overlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, overlayLayerDepth, isHeadLocked, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							overlayLayerDepth++;
						}
						else if (compositeLayer.overlayType == Pvr_UnitySDKEyeOverlay.OverlayType.Underlay)
						{
							if (compositeLayer.isExternalAndroidSurface)
							{
								layerFlags |= 1;
								CreateExternalSurface(compositeLayer, underlayLayerDepth);
							}
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[0], 0, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[0], compositeLayer.ModelScales[0], compositeLayer.ModelRotations[0], compositeLayer.ModelTranslations[0], compositeLayer.CameraRotations[0], compositeLayer.CameraTranslations[0], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							Render.UPvr_SetOverlayModelViewMatrix((int)compositeLayer.overlayType, (int)compositeLayer.overlayShape, compositeLayer.layerTextureIds[1], 1, underlayLayerDepth, isHeadLocked: false, layerFlags, compositeLayer.MVMatrixs[1], compositeLayer.ModelScales[1], compositeLayer.ModelRotations[1], compositeLayer.ModelTranslations[1], compositeLayer.CameraRotations[1], compositeLayer.CameraTranslations[1], compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
							underlayLayerDepth++;
						}
					}
					else if (compositeLayer.overlayShape == Pvr_UnitySDKEyeOverlay.OverlayShape.Equirect)
					{
						if (compositeLayer.isExternalAndroidSurface)
						{
							layerFlags |= 1;
							CreateExternalSurface(compositeLayer, 0);
						}
						Render.UPvr_SetupLayerData(0, 0, compositeLayer.layerTextureIds[0], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
						Render.UPvr_SetupLayerData(0, 1, compositeLayer.layerTextureIds[1], (int)compositeLayer.overlayShape, layerFlags, compositeLayer.GetLayerColorScale(), compositeLayer.GetLayerColorOffset());
					}
				}
			}
			Pvr_UnitySDKAPI.System.UPvr_UnityEventData(Pvr_UnitySDKAPI.System.UPvr_GetEyeBufferData(0));
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.TimeWarp);
			Pvr_UnitySDKRender.Instance.currEyeTextureIdx = Pvr_UnitySDKRender.Instance.nextEyeTextureIdx;
			Pvr_UnitySDKRender.Instance.nextEyeTextureIdx = (Pvr_UnitySDKRender.Instance.nextEyeTextureIdx + 1) % 3;
		}
	}

	private void CreateExternalSurface(Pvr_UnitySDKEyeOverlay overlayInstance, int layerDepth)
	{
		if (overlayInstance.externalAndroidSurfaceObject == IntPtr.Zero)
		{
			overlayInstance.externalAndroidSurfaceObject = Render.UPvr_CreateLayerAndroidSurface((int)overlayInstance.overlayType, layerDepth);
			UnityEngine.Debug.LogFormat("CreateExternalSurface: Overlay Type:{0}, LayerDepth:{1}, SurfaceObject:{2}", overlayInstance.overlayType, layerDepth, overlayInstance.externalAndroidSurfaceObject);
			if (overlayInstance.externalAndroidSurfaceObject != IntPtr.Zero && overlayInstance.externalAndroidSurfaceObjectCreated != null)
			{
				overlayInstance.externalAndroidSurfaceObjectCreated();
			}
		}
	}

	public bool SetEyeTrackingMode()
	{
		supportEyeTracking = (Pvr_UnitySDKAPI.System.UPvr_GetTrackingMode() & 4) != 0;
		bool result = false;
		if (EyeTracking && supportEyeTracking)
		{
			result = Pvr_UnitySDKAPI.System.UPvr_setTrackingMode(6);
		}
		UnityEngine.Debug.Log("SetEyeTrackingMode EyeTracking " + EyeTracking + " supportEyeTracking " + supportEyeTracking + " result " + result);
		return result;
	}

	public Vector3 GetEyeTrackingPos()
	{
		if (!Instance.EyeTracking)
		{
			return Vector3.zero;
		}
		bool flag = Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingData(ref eyePoseData);
		if (!flag)
		{
			PLOG.E("UPvr_getEyeTrackingData failed " + flag);
			return Vector3.zero;
		}
		EyeDeviceInfo deviceInfo = GetDeviceInfo();
		Vector3 zero = Vector3.zero;
		zero.x = 0.5f * (deviceInfo.targetFrustumLeft.right - deviceInfo.targetFrustumLeft.left);
		zero.y = 0.5f * (deviceInfo.targetFrustumLeft.top - deviceInfo.targetFrustumLeft.bottom);
		zero.z = deviceInfo.targetFrustumLeft.near;
		Vector3 foveatedGazeDirection = eyePoseData.foveatedGazeDirection;
		float num = Vector3.Dot(foveatedGazeDirection, Vector3.forward);
		if (num > float.Epsilon)
		{
			eyePoint = foveatedGazeDirection * (zero.z / num);
			eyePoint.x /= zero.x;
			eyePoint.y /= zero.y;
		}
		return eyePoint;
	}

	private EyeDeviceInfo GetDeviceInfo()
	{
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeHFoV / 2f * ((float)Math.PI / 180f));
		EyeDeviceInfo result = default(EyeDeviceInfo);
		result.targetFrustumLeft.left = 0f - LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.right = LeftEyeCamera.nearClipPlane * num2;
		result.targetFrustumLeft.top = LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.bottom = 0f - LeftEyeCamera.nearClipPlane * num;
		result.targetFrustumLeft.near = LeftEyeCamera.nearClipPlane;
		result.targetFrustumLeft.far = LeftEyeCamera.farClipPlane;
		result.targetFrustumRight.left = 0f - RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.right = RightEyeCamera.nearClipPlane * num2;
		result.targetFrustumRight.top = RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.bottom = 0f - RightEyeCamera.nearClipPlane * num;
		result.targetFrustumRight.near = RightEyeCamera.nearClipPlane;
		result.targetFrustumRight.far = RightEyeCamera.farClipPlane;
		return result;
	}

	private void CreateFadeMesh()
	{
		fadeMaterial = new Material(Shader.Find("Pvr_UnitySDK/Fade"));
		fadeMeshFilter = base.gameObject.AddComponent<MeshFilter>();
		fadeMeshRenderer = base.gameObject.AddComponent<MeshRenderer>();
		Mesh mesh = new Mesh();
		fadeMeshFilter.mesh = mesh;
		Vector3[] array = new Vector3[4];
		float num = 2f;
		float num2 = 2f;
		float z = 1f;
		array[0] = new Vector3(0f - num, 0f - num2, z);
		array[1] = new Vector3(num, 0f - num2, z);
		array[2] = new Vector3(0f - num, num2, z);
		array[3] = new Vector3(num, num2, z);
		mesh.vertices = array;
		mesh.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
		mesh.normals = new Vector3[4]
		{
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward,
			-Vector3.forward
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(1f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f)
		};
	}

	private void DestoryFadeMesh()
	{
		if (fadeMeshRenderer != null)
		{
			UnityEngine.Object.Destroy(fadeMeshRenderer);
		}
		if (fadeMaterial != null)
		{
			UnityEngine.Object.Destroy(fadeMaterial);
		}
		if (fadeMeshFilter != null)
		{
			UnityEngine.Object.Destroy(fadeMeshFilter);
		}
	}

	public void SetCurrentAlpha(float alpha)
	{
		currentAlpha = alpha;
		SetMaterialAlpha();
	}

	private IEnumerator ScreenFade(float startAlpha, float endAlpha)
	{
		float elapsedTime = 0f;
		while (elapsedTime < fadeTime)
		{
			elapsedTime += Time.deltaTime;
			nowFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
			SetMaterialAlpha();
			yield return new WaitForEndOfFrame();
		}
	}

	private void SetMaterialAlpha()
	{
		Color color = fadeColor;
		color.a = Mathf.Max(currentAlpha, nowFadeAlpha);
		isFading = color.a > 0f;
		if (fadeMaterial != null)
		{
			fadeMaterial.color = color;
			fadeMaterial.renderQueue = renderQueue;
			fadeMeshRenderer.material = fadeMaterial;
			fadeMeshRenderer.enabled = isFading;
		}
	}

	public bool GfxDeviceAdvanceFrameGLES()
	{
		MethodInfo[] methods = typeof(AndroidDevice).GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			if (methodInfo.Name == "VRDeviceUseOwnSurface")
			{
				PLOG.I("Use VRDeviceUseOwnSurface");
				methodInfo.Invoke(null, null);
				return true;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKEyeOverlay : MonoBehaviour, IComparable<Pvr_UnitySDKEyeOverlay>
{
	public delegate void ExternalAndroidSurfaceObjectCreated();

	public enum OverlayShape
	{
		Quad,
		Cylinder,
		Equirect
	}

	public enum OverlayType
	{
		Overlay,
		Underlay
	}

	public enum OverlayTexFilterMode
	{
		NotCare,
		Nearest,
		Linear,
		Nearest_Mipmap_Nearest,
		Linear_Mipmap_Nearest,
		Nearest_Mipmap_Linear,
		Linear_Mipmap_Linear
	}

	public static List<Pvr_UnitySDKEyeOverlay> Instances = new List<Pvr_UnitySDKEyeOverlay>();

	public int layerIndex;

	public OverlayType overlayType;

	public OverlayShape overlayShape;

	public Transform layerTransform;

	public Texture[] layerTextures = new Texture[2];

	public int[] layerTextureIds = new int[2];

	public Matrix4x4[] MVMatrixs = new Matrix4x4[2];

	public Vector3[] ModelScales = new Vector3[2];

	public Quaternion[] ModelRotations = new Quaternion[2];

	public Vector3[] ModelTranslations = new Vector3[2];

	public Quaternion[] CameraRotations = new Quaternion[2];

	public Vector3[] CameraTranslations = new Vector3[2];

	public Camera[] layerEyeCamera = new Camera[2];

	public bool overrideColorScaleAndOffset;

	public Vector4 colorScale = Vector4.one;

	public Vector4 colorOffset = Vector4.zero;

	private Vector4 overlayLayerColorScaleDefault = Vector4.one;

	private Vector4 overlayLayerColorOffsetDefault = Vector4.zero;

	public bool isExternalAndroidSurface;

	public IntPtr externalAndroidSurfaceObject = IntPtr.Zero;

	public ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated;

	public int CompareTo(Pvr_UnitySDKEyeOverlay other)
	{
		return layerIndex.CompareTo(other.layerIndex);
	}

	private void Awake()
	{
		Instances.Add(this);
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
		layerTransform = GetComponent<Transform>();
		if (layerTransform != null)
		{
			MeshRenderer component = layerTransform.GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
		}
		InitializeBuffer();
	}

	private void LateUpdate()
	{
		UpdateCoords();
	}

	private void OnDestroy()
	{
		Instances.Remove(this);
	}

	public void RefreshCamera()
	{
		if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.BothEyeCamera;
		}
		else if (Pvr_UnitySDKManager.SDK.Monoscopic)
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.MonoEyeCamera;
		}
		else
		{
			layerEyeCamera[0] = Pvr_UnitySDKEyeManager.Instance.LeftEyeCamera;
			layerEyeCamera[1] = Pvr_UnitySDKEyeManager.Instance.RightEyeCamera;
		}
	}

	private void InitializeBuffer()
	{
		OverlayShape overlayShape = this.overlayShape;
		if ((uint)overlayShape > 2u)
		{
			return;
		}
		for (int i = 0; i < layerTextureIds.Length; i++)
		{
			if (layerTextures[i] != null)
			{
				layerTextureIds[i] = layerTextures[i].GetNativeTexturePtr().ToInt32();
			}
			else
			{
				UnityEngine.Debug.LogWarning($"{(Eye)i} Texture is null!");
			}
		}
	}

	private void UpdateCoords()
	{
		if (layerTransform == null || !layerTransform.gameObject.activeSelf || layerEyeCamera[0] == null || layerEyeCamera[1] == null)
		{
			return;
		}
		for (int i = 0; i < MVMatrixs.Length; i++)
		{
			if (Pvr_UnitySDKRender.Instance.StereoRenderPath == StereoRenderingPathPico.SinglePass)
			{
				Matrix4x4[] stereoWorldToCameraMat = Pvr_UnitySDKSinglePass.GetStereoWorldToCameraMat();
				MVMatrixs[i] = stereoWorldToCameraMat[i] * layerTransform.localToWorldMatrix;
			}
			else
			{
				MVMatrixs[i] = layerEyeCamera[i].worldToCameraMatrix * layerTransform.localToWorldMatrix;
			}
			ModelScales[i] = layerTransform.localScale;
			ModelRotations[i] = layerTransform.rotation;
			ModelTranslations[i] = layerTransform.position;
			CameraRotations[i] = layerEyeCamera[i].transform.rotation;
			CameraTranslations[i] = layerEyeCamera[i].transform.position;
		}
	}

	public void SetTexture(Texture texture)
	{
		for (int i = 0; i < layerTextures.Length; i++)
		{
			layerTextures[i] = texture;
		}
		InitializeBuffer();
	}

	public void SetLayerColorScaleAndOffset(Vector4 scale, Vector4 offset)
	{
		colorScale = scale;
		colorOffset = offset;
	}

	public Vector4 GetLayerColorScale()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorScaleDefault;
		}
		return colorScale;
	}

	public Vector4 GetLayerColorOffset()
	{
		if (!overrideColorScaleAndOffset)
		{
			return overlayLayerColorOffsetDefault;
		}
		return colorOffset;
	}
}
public class Pvr_UnitySDKRender
{
	private static Pvr_UnitySDKRender instance;

	public AndroidJavaObject activity;

	public static AndroidJavaClass javaVrActivityClass;

	public static AndroidJavaClass javaSysActivityClass;

	public static AndroidJavaClass javaserviceClass;

	public static AndroidJavaClass javaVrActivityLongReceiver;

	public static AndroidJavaClass javaVrActivityClientClass;

	private bool canConnecttoActivity;

	private bool isInitrenderThread = true;

	private string model;

	private Vector2 prefinger1 = new Vector2(0f, 0f);

	private Vector2 prefinger2 = new Vector2(0f, 0f);

	public int eyeTextureCount = 6;

	public RenderTexture[] eyeTextures;

	public int[] eyeTextureIds;

	public int currEyeTextureIdx;

	public int nextEyeTextureIdx = 1;

	public int lastEyeTextureIdx;

	public bool isSwitchSDK;

	public int RenderviewNumber;

	public bool isFirstStartup = true;

	public bool isShellMode;

	private StereoRenderingPathPico stereoRenderPath;

	private float rtScaleFactor = 1f;

	private float eyeVFov = 90f;

	private float eyeHFov = 90f;

	public static Pvr_UnitySDKRender Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKRender();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public StereoRenderingPathPico StereoRenderPath => stereoRenderPath;

	public SDKStereoRendering StereoRendering { get; private set; }

	public float RtScaleFactor
	{
		get
		{
			return rtScaleFactor;
		}
		set
		{
			if (value != rtScaleFactor)
			{
				rtScaleFactor = value;
				ReCreateEyeBuffer();
			}
		}
	}

	public float EyeVFoV
	{
		get
		{
			return eyeVFov;
		}
		set
		{
			if (value != eyeVFov)
			{
				eyeVFov = value;
			}
		}
	}

	public float EyeHFoV
	{
		get
		{
			return eyeHFov;
		}
		set
		{
			if (value != eyeHFov)
			{
				eyeHFov = value;
			}
		}
	}

	public Pvr_UnitySDKRender()
	{
		if (!canConnecttoActivity)
		{
			ConnectToAndriod();
			PLOG.I("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		Init();
	}

	public void ConnectToAndriod()
	{
		try
		{
			UnityEngine.Debug.Log("PvrLog SDK Version :  " + Pvr_UnitySDKAPI.System.UPvr_GetSDKVersion().ToString() + "  Unity Script Version :" + Pvr_UnitySDKAPI.System.UPvr_GetUnitySDKVersion().ToString());
			AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			activity = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
			javaVrActivityClass = new AndroidJavaClass("com.psmart.vrlib.VrActivity");
			javaserviceClass = new AndroidJavaClass("com.picovr.picovrlib.hummingbirdclient.UnityClient");
			javaVrActivityLongReceiver = new AndroidJavaClass("com.psmart.vrlib.HomeKeyReceiver");
			javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
			javaVrActivityClientClass = new AndroidJavaClass("com.psmart.vrlib.PvrClient");
			Pvr_UnitySDKAPI.System.Pvr_SetInitActivity(activity.GetRawObject(), javaVrActivityClass.GetRawClass());
			model = javaVrActivityClass.CallStatic<string>("Pvr_GetBuildModel", Array.Empty<object>());
			double[] result = new double[5];
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, javaVrActivityClass, "getDPIParameters", activity);
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			string result2 = "";
			Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result2, javaserviceClass, "getSysproc", "persist.pvr.debug.appfps");
			if (result2 != "")
			{
				Pvr_UnitySDKManager.SDK.systemFPS = Convert.ToBoolean(Convert.ToInt16(result2));
			}
			if (res == 0)
			{
				Render.UPvr_ChangeScreenParameters(model, (int)result[0], (int)result[1], result[2], result[3], result[4]);
				Screen.sleepTimeout = -1;
			}
			if (Pvr_UnitySDKAPI.System.UPvr_IsPicoActivity())
			{
				UnityEngine.Debug.Log("ConnectToAndriod set monoPresentation success ?-------------" + Pvr_UnitySDKAPI.System.UPvr_SetMonoPresentation());
				UnityEngine.Debug.Log("ConnectToAndriod presentation existed ?-------------" + Pvr_UnitySDKAPI.System.UPvr_IsPresentationExisted());
			}
			isShellMode = GetIsShellMode();
			UnityEngine.Debug.Log("ConnectToAndriod isShellMode ?-------------" + isShellMode);
		}
		catch (AndroidJavaException ex)
		{
			PLOG.E("ConnectToAndriod--catch" + ex.Message);
		}
		canConnecttoActivity = true;
	}

	public void Init()
	{
		if (InitRenderAbility())
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Success!");
			isInitrenderThread = false;
		}
		else
		{
			UnityEngine.Debug.Log("PvrLog Init Render Ability Failed!");
		}
	}

	private bool InitRenderAbility()
	{
		if (UpdateRenderParaFrame() && CreateEyeBuffer())
		{
			float num = Pvr_UnitySDKAPI.System.UPvr_GetIPD();
			Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - num) / 2f, 0f, 0f);
			Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(num / 2f, 0f, 0f);
			return true;
		}
		return false;
	}

	private bool UpdateRenderParaFrame()
	{
		EyeVFoV = GetEyeVFOV();
		EyeHFoV = GetEyeHFOV();
		Pvr_UnitySDKManager.SDK.EyesAspect = EyeHFoV / EyeVFoV;
		return true;
	}

	private bool CreateEyeBuffer()
	{
		Vector2 eyeBufferResolution = GetEyeBufferResolution();
		if (isFirstStartup)
		{
			InitSinglePass();
			Pvr_UnitySDKAPI.System.UPvr_SetSinglePassDepthBufferWidthHeight((int)eyeBufferResolution.x, (int)eyeBufferResolution.y);
		}
		eyeTextures = new RenderTexture[eyeTextureCount];
		eyeTextureIds = new int[eyeTextureCount];
		for (int i = 0; i < eyeTextureCount; i++)
		{
			if (null == eyeTextures[i])
			{
				try
				{
					ConfigureEyeBuffer(i, eyeBufferResolution);
				}
				catch (Exception ex)
				{
					PLOG.E("ConfigureEyeBuffer ERROR " + ex.Message);
					throw;
				}
			}
			if (!eyeTextures[i].IsCreated())
			{
				eyeTextures[i].Create();
				eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
			}
			eyeTextureIds[i] = eyeTextures[i].GetNativeTexturePtr().ToInt32();
		}
		return true;
	}

	private void InitSinglePass()
	{
		bool flag = true;
		if (GraphicsSettings.renderPipelineAsset != null)
		{
			flag = false;
			if (!BoundarySystem.UPvr_EnableLWRP(enable: true))
			{
				UnityEngine.Debug.Log("UPvr_EnableLWRP return false");
			}
			Vector2 eyeBufferResolution = GetEyeBufferResolution();
			if (!BoundarySystem.UPvr_SetViewportSize((int)eyeBufferResolution.x, (int)eyeBufferResolution.y))
			{
				UnityEngine.Debug.Log("UPvr_SetViewportSize return false");
			}
		}
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usesinglepass)
		{
			bool flag2 = false;
			if (flag)
			{
				flag2 = Pvr_UnitySDKAPI.System.UPvr_EnableSinglePass(enable: true);
			}
			if (flag2)
			{
				StereoRendering = new Pvr_UnitySDKSinglePass();
				stereoRenderPath = StereoRenderingPathPico.SinglePass;
				eyeTextureCount = 3;
			}
			UnityEngine.Debug.Log("EnableSinglePass supportSinglePass " + flag + " result " + flag2);
		}
	}

	public float GetEyeVFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(1, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeVFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	public float GetEyeHFOV()
	{
		float res = 102f;
		try
		{
			Render.UPvr_GetFloatConfig(2, ref res);
			if (res <= 0f)
			{
				res = 102f;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetEyeHFOV ERROR! " + ex.Message);
			throw;
		}
		return res;
	}

	private void ConfigureEyeBuffer(int eyeTextureIndex, Vector2 resolution)
	{
		int width = (int)resolution.x;
		int height = (int)resolution.y;
		eyeTextures[eyeTextureIndex] = new RenderTexture(width, height, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtBitDepth, Pvr_UnitySDKProjectSetting.GetProjectConfig().rtFormat);
		if (StereoRenderPath == StereoRenderingPathPico.MultiPass)
		{
			eyeTextures[eyeTextureIndex].anisoLevel = 0;
			eyeTextures[eyeTextureIndex].antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
			UnityEngine.Debug.Log("MultiPass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		else if (StereoRenderPath == StereoRenderingPathPico.SinglePass)
		{
			eyeTextures[eyeTextureIndex].useMipMap = false;
			eyeTextures[eyeTextureIndex].wrapMode = TextureWrapMode.Clamp;
			eyeTextures[eyeTextureIndex].filterMode = FilterMode.Bilinear;
			eyeTextures[eyeTextureIndex].anisoLevel = 1;
			eyeTextures[eyeTextureIndex].dimension = TextureDimension.Tex2DArray;
			eyeTextures[eyeTextureIndex].volumeDepth = 2;
			UnityEngine.Debug.Log("SinglePass ConfigureEyeBuffer eyeTextureIndex " + eyeTextureIndex);
		}
		eyeTextures[eyeTextureIndex].Create();
		if (eyeTextures[eyeTextureIndex].IsCreated())
		{
			eyeTextureIds[eyeTextureIndex] = eyeTextures[eyeTextureIndex].GetNativeTexturePtr().ToInt32();
			UnityEngine.Debug.Log("eyeTextureIndex : " + eyeTextureIndex);
		}
	}

	public bool ReCreateEyeBuffer()
	{
		if (!Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			for (int i = 0; i < eyeTextureCount; i++)
			{
				if (eyeTextures[i] != null)
				{
					eyeTextures[i].Release();
				}
			}
			Array.Clear(eyeTextures, 0, eyeTextures.Length);
			return CreateEyeBuffer();
		}
		return false;
	}

	public void ReInit()
	{
		if (canConnecttoActivity && isInitrenderThread)
		{
			Init();
		}
	}

	public void IssueRenderThread()
	{
		if (canConnecttoActivity && !isInitrenderThread)
		{
			switch (QualitySettings.activeColorSpace)
			{
			case ColorSpace.Gamma:
				Render.UPvr_SetColorspaceType(0);
				break;
			case ColorSpace.Linear:
				Render.UPvr_SetColorspaceType(1);
				break;
			}
			Pvr_UnitySDKPluginEvent.Issue(RenderEventType.InitRenderThread);
			isInitrenderThread = true;
			if (StereoRendering != null)
			{
				StereoRendering.OnSDKRenderInited();
			}
			UnityEngine.Debug.Log("PvrLog IssueRenderThread end");
		}
		else
		{
			PLOG.I("PvrLog IssueRenderThread  canConnecttoActivity = " + canConnecttoActivity);
		}
	}

	private void AutoAdpatForPico1s()
	{
		Vector2 position = Input.touches[0].position;
		Vector2 position2 = Input.touches[1].position;
		if (Vector2.Distance(prefinger1, position) > 2f && Vector2.Distance(prefinger2, position2) > 2f)
		{
			float midH = (Input.touches[0].position.x + Input.touches[1].position.x) / (float)Screen.width - 1f;
			float midV = (Input.touches[0].position.y + Input.touches[1].position.y) / (float)Screen.height - 1f;
			Render.UPvr_SetRatio(midH, midV);
		}
		prefinger1 = position;
		prefinger2 = position2;
	}

	public Vector2 GetEyeBufferResolution()
	{
		int res = 1024;
		int res2 = 1024;
		if (Pvr_UnitySDKProjectSetting.GetProjectConfig().usedefaultRenderTexture)
		{
			try
			{
				Render.UPvr_GetIntConfig(0, ref res);
				Render.UPvr_GetIntConfig(1, ref res2);
			}
			catch (Exception ex)
			{
				PLOG.E("GetEyeBufferResolution ERROR! " + ex.Message);
				throw;
			}
		}
		else
		{
			res = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.x * RtScaleFactor);
			res2 = (int)(Pvr_UnitySDKProjectSetting.GetProjectConfig().customRTSize.y * RtScaleFactor);
		}
		Vector2 vector = new Vector2(res, res2);
		Vector2 vector2 = vector;
		UnityEngine.Debug.Log("DISFT Customize RenderTexture:" + vector2.ToString() + ", scaleFactor: " + RtScaleFactor);
		return vector;
	}

	public bool GetUsePredictedMatrix()
	{
		return true;
	}

	public bool GetIsShellMode()
	{
		if (activity == null)
		{
			return false;
		}
		using (AndroidJavaObject androidJavaObject = activity.Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>()).Call<AndroidJavaObject>("getApplicationInfo", new object[2]
		{
			activity.Call<string>("getPackageName", Array.Empty<object>()),
			128
		}))
		{
			AndroidJavaObject androidJavaObject2 = androidJavaObject.Get<AndroidJavaObject>("metaData");
			if (androidJavaObject2 != null)
			{
				if (androidJavaObject2.Call<int>("getInt", new object[1] { "shell_mode" }) == 1)
				{
					return true;
				}
				return false;
			}
		}
		return false;
	}
}
public class Pvr_UnitySDKSinglePass : SDKStereoRendering
{
	private static Camera bothCamera;

	private Matrix4x4[] unity_StereoMatrixP = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixInvP = new Matrix4x4[2];

	private static Matrix4x4[] unity_StereoWorldToCamera = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoCameraToWorld = new Matrix4x4[2];

	private Matrix4x4[] unity_StereoMatrixVP = new Matrix4x4[2];

	private Vector3[] eyesOffset = new Vector3[2];

	private static Matrix4x4[] eyesOffsetMatrix = new Matrix4x4[2];

	private CommandBuffer commandBufferBeforeForwardOpaque;

	private CommandBuffer commandBufferBeforeSkybox;

	private CommandBuffer commandBufferAfterSkybox;

	public override void InitEye(Camera eye)
	{
		bothCamera = eye;
		bothCamera.stereoSeparation = 0.0625f;
		bothCamera.stereoConvergence = 0f;
		bothCamera.allowHDR = false;
		bothCamera.allowDynamicResolution = false;
		SetEyesPosition();
		SetEyeProjection();
		Pvr_UnitySDKSensor.EyeFovChanged = (Action)Delegate.Combine(Pvr_UnitySDKSensor.EyeFovChanged, new Action(SetEyeProjection));
		UnityEngine.Debug.Log("SinglePass Init success! CameraName = " + eye.transform.name + " eye.eyeSide " + eye.GetComponent<Pvr_UnitySDKEye>().eyeSide);
	}

	public override void OnSDKRenderInited()
	{
		OnSDKRenderInited_SinglePass();
	}

	public override void OnSDKPreRender()
	{
		SinglePassPreRender();
	}

	public override void OnSDKPostRender()
	{
		SwitchKeywordAndDeviceView(enable: false);
	}

	public void OnSDKRenderInited_SinglePass()
	{
		Shader.SetGlobalVectorArray("unity_StereoScaleOffset", new Vector4[2]
		{
			new Vector4(1f, 1f, 0f, 0f),
			new Vector4(1f, 1f, 0.5f, 0f)
		});
		SetAntiAliasing();
		UnityEngine.Debug.Log("OnSDKRenderInited_SinglePass");
	}

	private void SetAntiAliasing()
	{
		int antiAliasing = Mathf.Max(QualitySettings.antiAliasing, (int)Pvr_UnitySDKProjectSetting.GetProjectConfig().rtAntiAlising);
		Pvr_UnitySDKAPI.System.UPvr_SetAntiAliasing(antiAliasing);
		UnityEngine.Debug.Log("SetAntiAliasing  antiAliasing = " + antiAliasing);
	}

	public void SetEyesPosition()
	{
		float res = 0.0625f;
		int configsenum = 0;
		if (Render.UPvr_GetFloatConfig(configsenum, ref res) != 0)
		{
			PLOG.E("Cannot get ipd");
			res = 0.0625f;
		}
		bothCamera.stereoSeparation = res;
		Vector3 vector = new Vector3((0f - res) / 2f, 0f, 0f);
		Vector3 vector2 = new Vector3(res / 2f, 0f, 0f);
		Vector3 vector3 = (vector + vector2) / 2f;
		bothCamera.transform.localPosition = vector3;
		bothCamera.transform.localRotation = Quaternion.identity;
		Vector3 vector4 = vector - vector3;
		Vector3 vector5 = vector2 - vector3;
		eyesOffset[0] = vector4;
		eyesOffset[1] = vector5;
		eyesOffsetMatrix[0] = Matrix4x4.TRS(vector4, Quaternion.identity, Vector3.one);
		eyesOffsetMatrix[1] = Matrix4x4.TRS(vector5, Quaternion.identity, Vector3.one);
	}

	public void SetEyeProjection()
	{
		Matrix4x4 projection = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		Matrix4x4 projection2 = GetProjection(bothCamera.nearClipPlane, bothCamera.farClipPlane);
		SetStereoProjectionMatrix(projection, projection2);
	}

	private static Matrix4x4 GetProjection(float near, float far)
	{
		if (near < 0.01f)
		{
			near = 0.01f;
		}
		if (far < 0.02f)
		{
			far = 0.02f;
		}
		_ = Matrix4x4.identity;
		return MakeProjection(near, far);
	}

	public static Matrix4x4 MakeProjection(float n, float f)
	{
		Vector2 eyeBufferResolution = Pvr_UnitySDKRender.Instance.GetEyeBufferResolution();
		float num = Mathf.Tan(Pvr_UnitySDKRender.Instance.EyeVFoV / 2f * ((float)Math.PI / 180f));
		float num2 = 1f / num;
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = num2 / (eyeBufferResolution.x / eyeBufferResolution.y);
		zero[1, 1] = num2;
		zero[2, 2] = (0f - (f + n)) / (f - n);
		zero[2, 3] = -2f * f * n / (f - n);
		zero[3, 2] = -1f;
		return zero;
	}

	public void SetStereoProjectionMatrix(Matrix4x4 left, Matrix4x4 right)
	{
		unity_StereoMatrixP[0] = left;
		unity_StereoMatrixInvP[0] = left.inverse;
		unity_StereoMatrixP[1] = right;
		unity_StereoMatrixInvP[1] = right.inverse;
	}

	private void SwitchKeywordAndDeviceView(bool enable)
	{
		if (enable)
		{
			Shader.EnableKeyword("STEREO_MULTIVIEW_ON");
			Shader.EnableKeyword("UNITY_SINGLE_PASS_STEREO");
			XRSettings.showDeviceView = false;
		}
		else
		{
			XRSettings.showDeviceView = true;
			Shader.DisableKeyword("UNITY_SINGLE_PASS_STEREO");
			Shader.DisableKeyword("STEREO_MULTIVIEW_ON");
		}
	}

	public static Matrix4x4[] GetStereoWorldToCameraMat()
	{
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		return unity_StereoWorldToCamera;
	}

	public void SinglePassPreRender()
	{
		SwitchKeywordAndDeviceView(enable: true);
		Shader.SetGlobalMatrixArray("unity_StereoCameraProjection", unity_StereoMatrixP);
		Shader.SetGlobalMatrixArray("unity_StereoCameraInvProjection", unity_StereoMatrixInvP);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixP", unity_StereoMatrixP);
		Matrix4x4 worldToCameraMatrix = bothCamera.worldToCameraMatrix;
		Matrix4x4 cameraToWorldMatrix = bothCamera.cameraToWorldMatrix;
		unity_StereoCameraToWorld[0] = cameraToWorldMatrix * eyesOffsetMatrix[0];
		unity_StereoCameraToWorld[1] = cameraToWorldMatrix * eyesOffsetMatrix[1];
		Shader.SetGlobalMatrixArray("unity_StereoCameraToWorld", unity_StereoCameraToWorld);
		unity_StereoWorldToCamera[0] = eyesOffsetMatrix[0].inverse * worldToCameraMatrix;
		unity_StereoWorldToCamera[1] = eyesOffsetMatrix[1].inverse * worldToCameraMatrix;
		Shader.SetGlobalMatrixArray("unity_StereoWorldToCamera", unity_StereoWorldToCamera);
		Vector4[] values = new Vector4[2]
		{
			bothCamera.transform.position + eyesOffset[0],
			bothCamera.transform.position + eyesOffset[1]
		};
		Shader.SetGlobalVectorArray("unity_StereoWorldSpaceCameraPos", values);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixV", unity_StereoWorldToCamera);
		Shader.SetGlobalMatrixArray("unity_StereoMatrixInvV", unity_StereoCameraToWorld);
		unity_StereoMatrixVP[0] = unity_StereoMatrixP[0] * unity_StereoWorldToCamera[0];
		unity_StereoMatrixVP[1] = unity_StereoMatrixP[1] * unity_StereoWorldToCamera[1];
		Shader.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		SetRenderTextureWithDepth();
		SetCommandBuffers();
	}

	private void SetCommandBuffers()
	{
		if (commandBufferBeforeForwardOpaque == null)
		{
			commandBufferBeforeForwardOpaque = new CommandBuffer();
			Pvr_UnitySDKPluginEvent.SetSinglePassBeforeForwardOpaque(commandBufferBeforeForwardOpaque);
			commandBufferBeforeForwardOpaque.ClearRenderTarget(clearDepth: true, clearColor: true, bothCamera.backgroundColor);
			commandBufferBeforeForwardOpaque.name = "SinglePassPrepare";
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		bothCamera.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, commandBufferBeforeForwardOpaque);
		if (commandBufferAfterSkybox == null)
		{
			commandBufferAfterSkybox = new CommandBuffer();
		}
		bothCamera.RemoveCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		commandBufferAfterSkybox.Clear();
		commandBufferAfterSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", unity_StereoMatrixVP);
		commandBufferAfterSkybox.name = "SinglePassAfterSkyBox";
		bothCamera.AddCommandBuffer(CameraEvent.AfterSkybox, commandBufferAfterSkybox);
		if (commandBufferBeforeSkybox == null)
		{
			commandBufferBeforeSkybox = new CommandBuffer();
		}
		Matrix4x4 transpose = (Matrix4x4.LookAt(Vector3.zero, bothCamera.transform.forward, bothCamera.transform.up) * Matrix4x4.Scale(new Vector3(1f, 1f, -1f))).transpose;
		Matrix4x4 matrix4x = unity_StereoMatrixP[0];
		Matrix4x4 matrix4x2 = unity_StereoMatrixP[1];
		matrix4x.m22 = -1f;
		matrix4x2.m22 = -1f;
		Matrix4x4[] values = new Matrix4x4[2]
		{
			matrix4x * transpose,
			matrix4x2 * transpose
		};
		bothCamera.RemoveCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
		commandBufferBeforeSkybox.Clear();
		commandBufferBeforeSkybox.SetGlobalMatrixArray("unity_StereoMatrixVP", values);
		commandBufferBeforeSkybox.name = "SinglePassAfterSkybox";
		bothCamera.AddCommandBuffer(CameraEvent.BeforeSkybox, commandBufferBeforeSkybox);
	}

	private void SetRenderTextureWithDepth()
	{
		Pvr_UnitySDKAPI.System.UPvr_SetCurrentRenderTexture((uint)Pvr_UnitySDKRender.Instance.eyeTextureIds[Pvr_UnitySDKRender.Instance.currEyeTextureIdx]);
	}
}
public abstract class SDKStereoRendering
{
	public abstract void InitEye(Camera eye);

	public abstract void OnSDKRenderInited();

	public abstract void OnSDKPreRender();

	public abstract void OnSDKPostRender();
}
public class HighlightAtGaze : MonoBehaviour
{
	public Color HighlightColor = Color.red;

	public float AnimationTime = 0.1f;

	private Renderer myRenderer;

	private Color originalColor;

	private Color targetColor;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		myRenderer = GetComponent<Renderer>();
		originalColor = myRenderer.material.color;
		targetColor = originalColor;
	}

	private void Update()
	{
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		if (Physics.Raycast(new Ray(gazeRay.Origin, gazeRay.Direction), out var hitInfo))
		{
			if (hitInfo.transform.name == base.transform.name)
			{
				if (targetColor != HighlightColor)
				{
					targetColor = HighlightColor;
				}
			}
			else if (targetColor != originalColor)
			{
				targetColor = originalColor;
			}
		}
		else if (targetColor != originalColor)
		{
			targetColor = originalColor;
		}
		myRenderer.material.color = Color.Lerp(myRenderer.material.color, targetColor, Time.deltaTime * (1f / AnimationTime));
	}
}
public class RayVisualizer : MonoBehaviour
{
	private LineRenderer _line;

	private EyeTrackingGazeRay gazeRay;

	private void Start()
	{
		_line = base.gameObject.GetComponent<LineRenderer>();
		_line.startWidth = 0.002f;
		_line.endWidth = 0.002f;
	}

	private void Update()
	{
		Matrix4x4 matrix = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix;
		Pvr_UnitySDKAPI.System.UPvr_getEyeTrackingGazeRay(ref gazeRay);
		_line.SetPosition(0, matrix.MultiplyPoint(new Vector3(0f, -0.05f, 0.2f)));
		_line.SetPosition(1, gazeRay.Origin + gazeRay.Direction * 20f);
	}
}
public class GetSeeThroughImage : MonoBehaviour
{
	public RawImage viewImage_left;

	public RawImage viewImage_right;

	private int width;

	private int height;

	private RenderTexture cameraTex_left;

	private RenderTexture cameraTex_right;

	private bool cameraPreview;

	private void Start()
	{
		CreateTexture();
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.JoystickButton0))
		{
			DrawTexture();
		}
	}

	private void OnDestory()
	{
		if (cameraPreview)
		{
			cameraPreview = false;
			BoundarySystem.UPvr_StopCameraFrame();
		}
	}

	private void CreateTexture()
	{
		width = 600;
		height = 600;
		BoundarySystem.UPvr_BoundarySetCameraImageRect(width, height);
		cameraTex_left = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_right = new RenderTexture(width, height, 24, RenderTextureFormat.Default);
		cameraTex_left.Create();
		cameraTex_right.Create();
		viewImage_left.texture = cameraTex_left;
		viewImage_right.texture = cameraTex_right;
	}

	private void DrawTexture()
	{
		if (!cameraPreview)
		{
			cameraPreview = true;
			BoundarySystem.UPvr_StartCameraFrame();
		}
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(0, cameraTex_left);
		BoundarySystem.UPvr_BoundaryGetSeeThroughData(1, cameraTex_right);
	}
}
public class OverlayExternalSurfaceDemo : MonoBehaviour
{
	public string movieName;

	public Pvr_UnitySDKEyeOverlay.OverlayType overlayType;

	public Pvr_UnitySDKEyeOverlay.OverlayShape overlayShape;

	private Pvr_UnitySDKEyeOverlay overlay;

	private const string TAG = "[ExternalSurface]>>>>>>";

	private void Awake()
	{
		overlay = GetComponent<Pvr_UnitySDKEyeOverlay>();
		if (overlay == null)
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Overlay is null!");
			overlay = base.gameObject.AddComponent<Pvr_UnitySDKEyeOverlay>();
		}
		overlay.overlayType = overlayType;
		overlay.overlayShape = overlayShape;
		overlay.isExternalAndroidSurface = true;
	}

	private void Start()
	{
		if (!string.IsNullOrEmpty(movieName))
		{
			StartPlay(Application.streamingAssetsPath + "/" + movieName, null);
		}
	}

	private void StartPlay(string moviePath, string licenceUrl)
	{
		if (moviePath != string.Empty)
		{
			if (overlay.isExternalAndroidSurface)
			{
				Pvr_UnitySDKEyeOverlay.ExternalAndroidSurfaceObjectCreated externalAndroidSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject created callback is Invoke().");
				};
				if (overlay.externalAndroidSurfaceObject == IntPtr.Zero)
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>Register surfaceObject crreated callback");
					overlay.externalAndroidSurfaceObjectCreated = externalAndroidSurfaceObjectCreated;
				}
				else
				{
					UnityEngine.Debug.Log("[ExternalSurface]>>>>>>SurfaceObject is already created! Invoke callback");
					externalAndroidSurfaceObjectCreated();
				}
			}
		}
		else
		{
			UnityEngine.Debug.LogError("[ExternalSurface]>>>>>>Movie path is null!");
		}
	}
}
public class MoveCylinder : MonoBehaviour
{
	private Vector3 startingPosition;

	private Quaternion startingRotation;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		startingRotation = base.transform.rotation;
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		base.transform.rotation = startingRotation;
	}
}
[RequireComponent(typeof(Collider))]
public class MoveSphere : MonoBehaviour
{
	private Vector3 startingPosition;

	private void Start()
	{
		startingPosition = base.transform.localPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	private void OnTriggerEnter(Collider other)
	{
	}

	public void SetGazedAt(bool gazedAt)
	{
		GetComponent<Renderer>().material.color = (gazedAt ? Color.yellow : Color.blue);
	}

	public void Reset()
	{
		base.transform.localPosition = startingPosition;
		SetGazedAt(gazedAt: false);
		base.gameObject.GetComponent<Rigidbody>().Sleep();
		base.gameObject.GetComponent<Rigidbody>().AddForce(Vector3.right * 120f);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = onUnitSphere * num;
	}
}
public class Resetbutton : MonoBehaviour
{
	public void DemoResetTracking()
	{
		if (Pvr_UnitySDKSensor.Instance != null)
		{
			Pvr_UnitySDKSensor.Instance.ResetUnitySDKSensor();
		}
	}
}
public class UserEntitlementCheck : MonoBehaviour
{
	private void OnEnable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent += HandelEntitlementCheckResult;
	}

	private void OnDisable()
	{
		Pvr_UnitySDKManager.EntitlementCheckResultEvent -= HandelEntitlementCheckResult;
	}

	private void HandelEntitlementCheckResult(int resultCode)
	{
		UnityEngine.Debug.Log("The User Entitlement Check Result is :" + resultCode);
		switch (resultCode)
		{
		case 0:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: success");
			break;
		case -1:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid params");
			break;
		case -2:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: service not exist");
			break;
		case -3:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: bind failed");
			break;
		case -4:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: exception");
			break;
		case -5:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: timeout");
			break;
		case 10:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing package name");
			break;
		case 11:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: missing appid");
			break;
		case 13:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: appid and package name not match");
			break;
		case 20:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not login");
			break;
		case 21:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: not pay");
			break;
		case 31:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: invalid sn");
			break;
		default:
			UnityEngine.Debug.Log("The User Entitlement Check Result is: unknown");
			break;
		}
	}
}
public class Pvr_UnitySDKHeadTrack : MonoBehaviour
{
	[Tooltip("If true, head tracking will affect the rotation of each Pvr_UnitySDK's cameras.")]
	public bool trackRotation = true;

	[Tooltip("If true, head tracking will affect the position of each Pvr_UnitySDK's cameras.")]
	public bool trackPosition = true;

	public Transform target;

	private bool updated;

	private bool dataClock;

	public Ray Gaze
	{
		get
		{
			UpdateHead();
			return new Ray(base.transform.position, base.transform.forward);
		}
	}

	private void Update()
	{
		updated = false;
		UpdateHead();
	}

	private void UpdateHead()
	{
		if (updated)
		{
			return;
		}
		updated = true;
		if (Pvr_UnitySDKManager.SDK == null)
		{
			return;
		}
		if (trackRotation)
		{
			Quaternion orientation = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = orientation;
			}
			else
			{
				base.transform.rotation = orientation * target.rotation;
			}
		}
		else
		{
			Quaternion orientation2 = Pvr_UnitySDKSensor.Instance.HeadPose.Orientation;
			if (target == null)
			{
				base.transform.localRotation = Quaternion.identity;
			}
			else
			{
				base.transform.rotation = orientation2 * target.rotation;
			}
		}
		if (trackPosition)
		{
			Vector3 position = Pvr_UnitySDKSensor.Instance.HeadPose.Position;
			if (target == null)
			{
				base.transform.localPosition = position;
			}
			else
			{
				base.transform.position = target.position + target.rotation * position;
			}
		}
	}
}
public class Pvr_UnitySDKPose
{
	protected static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	public Matrix4x4 RightHandedMatrix => flipZ * Matrix * flipZ;

	public Vector3 Position { get; protected set; }

	public Quaternion Orientation { get; protected set; }

	public Matrix4x4 Matrix { get; protected set; }

	public Pvr_UnitySDKPose(Matrix4x4 matrix)
	{
		Set(matrix);
	}

	public Pvr_UnitySDKPose(Vector3 position, Quaternion orientation)
	{
		Set(position, orientation);
	}

	public void Set(Vector3 position, Quaternion orientation)
	{
		Position = position;
		Orientation = orientation;
		Matrix = Matrix4x4.TRS(position, orientation, Vector3.one);
	}

	protected void Set(Matrix4x4 matrix)
	{
		Matrix = matrix;
		Position = matrix.GetColumn(3);
		Orientation = Quaternion.LookRotation(matrix.GetColumn(2), matrix.GetColumn(1));
	}

	private Quaternion NormalizeQuaternion(ref Quaternion q)
	{
		float num = 0f;
		for (int i = 0; i < 4; i++)
		{
			num += q[i] * q[i];
		}
		float num2 = 1f / Mathf.Sqrt(num);
		for (int j = 0; j < 4; j++)
		{
			q[j] *= num2;
		}
		return q;
	}
}
public class Pvr_UnitySDKSensor
{
	public delegate void Enter3DofModel();

	public delegate void Exit3DofModel();

	private static Pvr_UnitySDKSensor instance;

	private bool SensorStart;

	private bool SensorInit;

	private Quaternion UnityQuaternion = Quaternion.identity;

	private Vector3 UnityPosition = Vector3.zero;

	private Sensorindex sensorIndex;

	private bool dofClock;

	public static Action EyeFovChanged;

	public Pvr_UnitySDKPose HeadPose;

	private float vfov = 102f;

	private float hfov = 102f;

	private float w;

	private float x;

	private float y;

	private float z;

	private float px;

	private float py;

	private float pz;

	public static Pvr_UnitySDKSensor Instance
	{
		get
		{
			if (instance == null)
			{
				instance = new Pvr_UnitySDKSensor();
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}

	public static event Enter3DofModel Enter3DofModelEvent;

	public static event Exit3DofModel Exit3DofModelEvent;

	public Pvr_UnitySDKSensor()
	{
		Init();
	}

	public void Init()
	{
		InitUnitySDK6DofSensor();
		SensorInit = InitUnitySDKSensor();
		SensorStart = StartUnitySDKSensor();
		HeadPose = new Pvr_UnitySDKPose(Vector3.zero, Quaternion.identity);
	}

	public void SensorUpdate()
	{
		if (GetUnitySDKSensorState())
		{
			HeadPose.Set(UnityPosition, UnityQuaternion);
		}
	}

	public bool InitUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_Init((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool InitUnitySDK6DofSensor()
	{
		bool result = false;
		try
		{
			int res = 0;
			Render.UPvr_GetIntConfig(3, ref res);
			if (res == 1)
			{
				if (Sensor.UPvr_Enable6DofModule(!Pvr_UnitySDKManager.SDK.HmdOnlyrot) == 0 && !Pvr_UnitySDKManager.SDK.HmdOnlyrot)
				{
					result = true;
					Pvr_UnitySDKManager.SDK.PVRNeck = false;
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("This platform does not support 6 Dof !");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("InitUnity6DofSDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StartUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StartSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StartUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool StopUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_StopSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("StopUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool ResetUnitySDKSensor()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
				PLOG.E("ResetUnitySDKSensor OK! ");
			}
		}
		catch (Exception ex)
		{
			PLOG.E("ResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool OptionalResetUnitySDKSensor(int resetRot, int resetPos)
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_OptionalResetSensor((int)sensorIndex, resetRot, resetPos) == 0)
			{
				result = true;
				UnityEngine.Debug.Log("PvrLog OptionalResetUnitySDKSensor OK!" + resetRot + resetPos);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("OptionalResetUnitySDKSensor ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	public bool GetUnitySDKSensorState()
	{
		bool result = false;
		if (SensorInit && SensorStart)
		{
			try
			{
				int num = -1;
				if (Pvr_UnitySDKManager.SDK.ShowVideoSeethrough)
				{
					Pvr_BoundarySystem.Instance.CameraFramePtr = Pvr_BoundaryAPI.UPvr_GetCameraData_Ext();
					num = Pvr_BoundaryAPI.UPvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				else
				{
					num = Sensor.UPvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref Pvr_UnitySDKRender.Instance.RenderviewNumber);
				}
				Pvr_UnitySDKManager.SDK.posStatus = Sensor.UPvr_Get6DofSensorQualityStatus();
				if (num == 0)
				{
					if (!Convert.ToBoolean(Pvr_UnitySDKManager.SDK.posStatus & 2))
					{
						if (!dofClock)
						{
							if (Pvr_UnitySDKSensor.Enter3DofModelEvent != null)
							{
								Pvr_UnitySDKSensor.Enter3DofModelEvent();
							}
							dofClock = true;
						}
					}
					else if (dofClock)
					{
						if (Pvr_UnitySDKSensor.Exit3DofModelEvent != null)
						{
							Pvr_UnitySDKSensor.Exit3DofModelEvent();
						}
						dofClock = false;
					}
					RefreshHeadData(x, y, z, w, px, py, pz);
					UnityQuaternion.Set(x, y, 0f - z, 0f - w);
					if (Pvr_UnitySDKRender.Instance.EyeVFoV != vfov)
					{
						Pvr_UnitySDKRender.Instance.EyeVFoV = vfov;
						if (EyeFovChanged != null)
						{
							EyeFovChanged();
						}
					}
					Pvr_UnitySDKRender.Instance.EyeHFoV = hfov;
					Pvr_UnitySDKManager.SDK.EyesAspect = hfov / vfov;
					result = true;
					if (Pvr_UnitySDKManager.SDK.HmdOnlyrot)
					{
						if (Pvr_UnitySDKManager.SDK.PVRNeck)
						{
							if (Pvr_UnitySDKManager.SDK.TrackingOrigin == TrackingOrigin.FloorLevel)
							{
								UnityPosition.Set(0f, py, 0f);
								UnityPosition += UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
							else
							{
								UnityPosition = UnityQuaternion * Pvr_UnitySDKManager.SDK.neckOffset - Pvr_UnitySDKManager.SDK.neckOffset.y * Vector3.up;
							}
						}
					}
					else
					{
						UnityPosition.Set(px, py, 0f - pz);
					}
					if (PLOG.logLevel > 2)
					{
						PLOG.D("posStatus=" + Pvr_UnitySDKManager.SDK.posStatus);
						PLOG.D("PvrLog 6DoFHeadRotation:" + x + "," + y + "," + (0f - z) + "," + (0f - w) + ",Position:" + px + "," + py + "," + (0f - pz) + ",eulerAngles:" + UnityQuaternion.eulerAngles.ToString());
					}
				}
				if (num == -1)
				{
					PLOG.I("PvrLog Sensor update --- GetUnitySDKSensorState  -1 ");
				}
			}
			catch (Exception ex)
			{
				PLOG.E("GetUnitySDKSensorState ERROR! " + ex.Message);
				throw;
			}
		}
		return result;
	}

	public bool GetUnitySDKPSensorState()
	{
		bool result = false;
		try
		{
			if (Sensor.UPvr_ResetSensor((int)sensorIndex) == 0)
			{
				result = true;
			}
		}
		catch (Exception ex)
		{
			PLOG.E("GetUnitySDKPSensorState ERROR! " + ex.Message);
			throw;
		}
		return result;
	}

	private void RefreshHeadData(float x, float y, float z, float w, float px, float py, float pz)
	{
		Pvr_UnitySDKManager.SDK.headData[0] = x;
		Pvr_UnitySDKManager.SDK.headData[1] = y;
		Pvr_UnitySDKManager.SDK.headData[2] = z;
		Pvr_UnitySDKManager.SDK.headData[3] = w;
		Pvr_UnitySDKManager.SDK.headData[4] = px;
		Pvr_UnitySDKManager.SDK.headData[5] = py;
		Pvr_UnitySDKManager.SDK.headData[6] = pz;
	}
}
public class CLoadingAsset : ScriptableObject
{
	public int SplashScreenType;

	public List<Texture2D> splashImage = new List<Texture2D>();

	public Texture2D Inside_background;

	public bool UseSplashText;

	public string DefaultText;

	public string ChineseText;

	public string EnglishText;

	public string JapaneseText;

	public string KoreanText;

	public string FontSize;

	public Color FontColor;

	public string TextHeight;

	public bool UseCarousel;

	public int SplashTextAlignment;
}
[Serializable]
public class Pvr_UnitySDKConfigProfile
{
	public struct Lenses
	{
		public float separation;

		public float offset;

		public float distance;

		public int alignment;

		public const int AlignTop = -1;

		public const int AlignCenter = 0;

		public const int AlignBottom = 1;
	}

	public struct MaxFOV
	{
		public float upper;

		public float lower;

		public float inner;

		public float outer;
	}

	public struct Distortion
	{
		public float k1;

		public float k2;

		public float k3;

		public float k4;

		public float k5;

		public float k6;

		public float distort(float r)
		{
			return 0f;
		}

		public float distort(float r, float dist)
		{
			float num = r * dist * 1000f;
			return (k1 * Mathf.Pow(num, 5f) + k2 * Mathf.Pow(num, 4f) + k3 * Mathf.Pow(num, 3f) + k4 * Mathf.Pow(num, 2f) + k5 * num + k6) / 1000f / dist;
		}

		public float diatortInv(float radious)
		{
			return 0f;
		}
	}

	public struct Device
	{
		public Lenses devLenses;

		public MaxFOV devMaxFov;

		public Distortion devDistortion;

		public Distortion devDistortionInv;
	}

	public static readonly Device SimulateDevice = new Device
	{
		devLenses = 
		{
			separation = 0.062f,
			offset = 0f,
			distance = 0.0403196f,
			alignment = 0
		},
		devMaxFov = 
		{
			upper = 40f,
			lower = 40f,
			inner = 40f,
			outer = 40f
		},
		devDistortion = 
		{
			k1 = 2.333E-06f,
			k2 = -0.000126f,
			k3 = 0.002978f,
			k4 = -0.02615f,
			k5 = 1.089f,
			k6 = -0.0337f
		},
		devDistortionInv = 
		{
			k1 = 1.342E-08f,
			k2 = 1.665E-06f,
			k3 = -0.0002797f,
			k4 = 0.001166f,
			k5 = 0.9945f,
			k6 = 0.004805f
		}
	};

	public Device device;

	public static readonly Pvr_UnitySDKConfigProfile Default = new Pvr_UnitySDKConfigProfile
	{
		device = SimulateDevice
	};

	public Pvr_UnitySDKConfigProfile Clone()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = device
		};
	}

	public static Pvr_UnitySDKConfigProfile GetPicoProfile()
	{
		return new Pvr_UnitySDKConfigProfile
		{
			device = SimulateDevice
		};
	}

	public float[] GetLeftEyeVisibleTanAngles(float width, float height)
	{
		float val = (float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0);
		float val2 = (float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0);
		float val3 = (float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0);
		float val4 = (float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = device.devDistortion.distort((num3 - num) / distance, device.devLenses.distance);
		float val6 = device.devDistortion.distort((num4 + num2) / distance, device.devLenses.distance);
		float val7 = device.devDistortion.distort((num3 + num) / distance, device.devLenses.distance);
		float val8 = device.devDistortion.distort((num4 - num) / distance, device.devLenses.distance);
		float num5 = Math.Max(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public float[] GetLeftEyeNoLensTanAngles(float width, float height)
	{
		float val = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.outer) * Math.PI / 180.0), device.devLenses.distance);
		float val2 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.upper * Math.PI / 180.0), device.devLenses.distance);
		float val3 = device.devDistortionInv.distort((float)Math.Tan((double)device.devMaxFov.inner * Math.PI / 180.0), device.devLenses.distance);
		float val4 = device.devDistortionInv.distort((float)Math.Tan((double)(0f - device.devMaxFov.lower) * Math.PI / 180.0), device.devLenses.distance);
		float num = width / 4f;
		float num2 = height / 2f;
		float num3 = device.devLenses.separation / 2f - num;
		float num4 = 0f;
		float distance = device.devLenses.distance;
		float val5 = (num3 - num) / distance;
		float val6 = (num4 + num2) / distance;
		float val7 = (num3 + num) / distance;
		float val8 = (num4 - num) / distance;
		float num5 = Math.Min(val, val5);
		float num6 = Math.Min(val2, val6);
		float num7 = Math.Min(val3, val7);
		float num8 = Math.Max(val4, val8);
		return new float[4] { num5, num6, num7, num8 };
	}

	public Rect GetLeftEyeVisibleScreenRect(float[] undistortedFrustum, float width, float height)
	{
		float distance = device.devLenses.distance;
		float num = (width - device.devLenses.separation) / 2f;
		float num2 = height / 2f;
		float num3 = (undistortedFrustum[0] * distance + num) / width;
		float num4 = (undistortedFrustum[1] * distance + num2) / height;
		float num5 = (undistortedFrustum[2] * distance + num) / width;
		float num6 = (undistortedFrustum[3] * distance + num2) / height;
		return new Rect(num3, num6, num5 - num3, num4 - num6);
	}
}
[RequireComponent(typeof(Text))]
public class Pvr_UnitySDKFPS : MonoBehaviour
{
	public Text fpsText;

	private float updateInterval = 0.5f;

	private float accum;

	private int frames;

	private float timeLeft;

	private string strFps;

	private void Update()
	{
		if (fpsText != null)
		{
			ShowFps();
		}
	}

	private void ShowFps()
	{
		timeLeft -= Time.unscaledDeltaTime;
		accum += Time.unscaledDeltaTime;
		frames++;
		if ((double)timeLeft <= 0.0)
		{
			float num = (float)frames / accum;
			strFps = $"FPS: {num:f0}";
			fpsText.text = strFps;
			timeLeft += updateInterval;
			accum = 0f;
			frames = 0;
		}
	}
}
public class Pvr_GazeFuse : MonoBehaviour
{
	public GameObject gazeGameObject;

	private Image image;

	private void Start()
	{
		image = GetComponent<Image>();
	}

	private void Update()
	{
		if (gazeGameObject == null || Pvr_GazeInputModule.gazeGameObject == gazeGameObject)
		{
			FuseAmountChanged(Pvr_GazeInputModule.gazeFraction);
		}
	}

	private void FuseAmountChanged(float fuseAmount)
	{
		if (image != null)
		{
			image.fillAmount = fuseAmount;
		}
	}
}
public class Pvr_GazeInputModule : PointerInputModule
{
	public enum Mode
	{
		Click,
		Gaze
	}

	public Mode mode;

	[Header("Click Settings")]
	public string ClickInputName = "Submit";

	[Header("Gaze Settings")]
	public float GazeTimeInSeconds = 2f;

	public RaycastResult CurrentRaycast;

	private PointerEventData pointerEventData;

	private GameObject currentLookAtHandler;

	private float currentLookAtHandlerClickTime;

	public static float gazeFraction { get; private set; }

	public static GameObject gazeGameObject { get; private set; }

	public override void Process()
	{
		HandleLook();
		HandleSelection();
	}

	private void HandleLook()
	{
		if (pointerEventData == null)
		{
			pointerEventData = new PointerEventData(base.eventSystem);
		}
		pointerEventData.position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointerEventData.delta = Vector2.zero;
		List<RaycastResult> list = new List<RaycastResult>();
		base.eventSystem.RaycastAll(pointerEventData, list);
		RaycastResult currentRaycast = (pointerEventData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(list));
		CurrentRaycast = currentRaycast;
		ProcessMove(pointerEventData);
	}

	private void HandleSelection()
	{
		gazeFraction = 0f;
		if (pointerEventData.pointerEnter != null)
		{
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(pointerEventData.pointerEnter);
			if (currentLookAtHandler != eventHandler)
			{
				gazeGameObject = (currentLookAtHandler = eventHandler);
				currentLookAtHandlerClickTime = Time.realtimeSinceStartup + GazeTimeInSeconds;
			}
			if (mode == Mode.Gaze && currentLookAtHandler != null)
			{
				gazeFraction = Mathf.Clamp01(1f - (currentLookAtHandlerClickTime - Time.realtimeSinceStartup) / GazeTimeInSeconds);
			}
			if ((currentLookAtHandler != null && mode == Mode.Gaze && Time.realtimeSinceStartup > currentLookAtHandlerClickTime) || (mode == Mode.Click && Input.GetButtonDown(ClickInputName)))
			{
				_ = EventSystem.current.currentSelectedGameObject != null;
				EventSystem.current.SetSelectedGameObject(currentLookAtHandler);
				gazeFraction = 0f;
				ExecuteEvents.ExecuteHierarchy(currentLookAtHandler, pointerEventData, ExecuteEvents.pointerClickHandler);
				currentLookAtHandlerClickTime = float.MaxValue;
				ExecuteEvents.ExecuteHierarchy(EventSystem.current.currentSelectedGameObject, pointerEventData, ExecuteEvents.deselectHandler);
			}
		}
		else
		{
			gazeGameObject = (currentLookAtHandler = null);
		}
	}
}
[RequireComponent(typeof(Pvr_GazeInputModule))]
public class Pvr_GazeInputModuleCrosshair : MonoBehaviour
{
	public static bool DisplayCrosshair = true;

	[Tooltip("Crosshair GameObject attached to your VR Camera")]
	public Transform Crosshair;

	private Pvr_GazeInputModule gazeInputModule;

	private Vector3 CrosshairOriginalScale;

	private float CrosshairOriginalDistance;

	private void Awake()
	{
		gazeInputModule = GetComponent<Pvr_GazeInputModule>();
	}

	private void Start()
	{
		CrosshairOriginalScale = Crosshair.localScale;
		CrosshairOriginalDistance = Crosshair.localPosition.z;
		Crosshair.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		Crosshair.gameObject.SetActive(DisplayCrosshair);
		if (DisplayCrosshair)
		{
			float crossHairAtDistance = CrosshairOriginalDistance;
			if (gazeInputModule.CurrentRaycast.isValid)
			{
				crossHairAtDistance = gazeInputModule.CurrentRaycast.distance * 0.8f - 0.5f;
			}
			SetCrossHairAtDistance(crossHairAtDistance);
		}
	}

	private void SetCrossHairAtDistance(float dist)
	{
		Vector3 localPosition = Crosshair.localPosition;
		Crosshair.localPosition = new Vector3(localPosition.x, localPosition.y, dist);
		Crosshair.localScale = CrosshairOriginalScale * dist;
	}
}
public enum RenderEventType
{
	InitRenderThread = 1024,
	Pause,
	Resume,
	LeftEyeEndFrame,
	RightEyeEndFrame,
	TimeWarp,
	ResetVrModeParms,
	ShutdownRenderThread,
	BeginEye,
	EndEye,
	BoundaryRenderLeft,
	BoundaryRenderRight,
	BothEyeEndFrame,
	CameraFrameLeft,
	CameraFrameRight,
	StartCameraFrame,
	StopCameraFrame
}
public static class Pvr_UnitySDKPluginEvent
{
	private delegate void RenderEventDelegate(int eventId);

	private const uint IS_DATA_FLAG = 2147483648u;

	private const uint DATA_POS_MASK = 1073741824u;

	private const int DATA_POS_SHIFT = 30;

	private const uint EVENT_TYPE_MASK = 1056899072u;

	private const int EVENT_TYPE_SHIFT = 17;

	private const uint PAYLOAD_MASK = 65535u;

	private const int PAYLOAD_SHIFT = 16;

	private static RenderEventDelegate SetSinglePassBeforeForwardOpaqueHandle = SetSinglePassBeforeForwardOpaque;

	private static IntPtr SetSinglePassBeforeForwardOpaquePtr = Marshal.GetFunctionPointerForDelegate(SetSinglePassBeforeForwardOpaqueHandle);

	public static void Issue(RenderEventType eventType)
	{
		GL.IssuePluginEvent(Pvr_UnitySDKAPI.System.GetRenderEventFunc(), (int)eventType);
	}

	private static int EncodeType(int eventType)
	{
		return eventType & 0x7FFFFFFF;
	}

	private static int EncodeData(int eventId, int eventData, int pos)
	{
		return int.MinValue | ((pos << 30) & 0x40000000) | ((eventId << 17) & 0x3EFF0000) | ((eventData >>> pos * 16) & 0xFFFF);
	}

	private static int DecodeData(int eventData)
	{
		uint num = (uint)(eventData & 0x40000000) >> 30;
		return (eventData & 0xFFFF) << (int)(16 * num);
	}

	[MonoPInvokeCallback(typeof(RenderEventDelegate))]
	private static void SetSinglePassBeforeForwardOpaque(int eventId)
	{
		Pvr_UnitySDKAPI.System.UPvr_SinglePassBeforeForwardOpaque();
	}

	public static void SetSinglePassBeforeForwardOpaque(CommandBuffer cmd)
	{
		cmd.IssuePluginEvent(SetSinglePassBeforeForwardOpaquePtr, 0);
	}
}
public class Pvr_UnitySDKSightInputModule : BaseInputModule
{
	[Tooltip("Optional object to place at raycast intersections as a 3D cursor. Be sure it is on a layer that raycasts will ignore.")]
	public GameObject cursor;

	public int trigger;

	[HideInInspector]
	public float clickTime = 0.1f;

	[HideInInspector]
	public Vector2 hotspot = new Vector2(0.5f, 0.5f);

	private PointerEventData pointerData;

	public override bool ShouldActivateModule()
	{
		if (!base.ShouldActivateModule())
		{
			return false;
		}
		return Pvr_UnitySDKManager.SDK.VRModeEnabled;
	}

	public override void DeactivateModule()
	{
		base.DeactivateModule();
		if (pointerData != null)
		{
			HandlePendingClick();
			HandlePointerExitAndEnter(pointerData, null);
			pointerData = null;
		}
		base.eventSystem.SetSelectedGameObject(null, GetBaseEventData());
		if (cursor != null)
		{
			cursor.SetActive(value: false);
		}
	}

	public override bool IsPointerOverGameObject(int pointerId)
	{
		if (pointerData != null)
		{
			return pointerData.pointerEnter != null;
		}
		return false;
	}

	public override void Process()
	{
		CastRayFromGaze();
		UpdateCurrentObject();
		PlaceCursor();
		HandlePendingClick();
		HandleTrigger();
	}

	private void CastRayFromGaze()
	{
		if (pointerData == null)
		{
			pointerData = new PointerEventData(base.eventSystem);
		}
		pointerData.Reset();
		pointerData.position = new Vector2(hotspot.x * (float)Screen.width, hotspot.y * (float)Screen.height);
		base.eventSystem.RaycastAll(pointerData, m_RaycastResultCache);
		pointerData.pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
	}

	private void UpdateCurrentObject()
	{
		GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
		HandlePointerExitAndEnter(pointerData, gameObject);
		if (ExecuteEvents.GetEventHandler<ISelectHandler>(gameObject) == base.eventSystem.currentSelectedGameObject)
		{
			ExecuteEvents.Execute(base.eventSystem.currentSelectedGameObject, GetBaseEventData(), ExecuteEvents.updateSelectedHandler);
		}
		else
		{
			base.eventSystem.SetSelectedGameObject(null, pointerData);
		}
	}

	private void PlaceCursor()
	{
		if (!(cursor == null))
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			cursor.SetActive(gameObject != null);
			if (cursor.activeInHierarchy)
			{
				Camera enterEventCamera = pointerData.enterEventCamera;
				float num = pointerData.pointerCurrentRaycast.distance + enterEventCamera.nearClipPlane - 0.1f;
				cursor.transform.position = enterEventCamera.transform.position + enterEventCamera.transform.forward * num;
			}
		}
	}

	private void HandlePendingClick()
	{
		if (pointerData.eligibleForClick && (Pvr_UnitySDKManager.SDK.picovrTriggered || !(Time.unscaledTime - pointerData.clickTime < clickTime)))
		{
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerUpHandler);
			ExecuteEvents.Execute(pointerData.pointerPress, pointerData, ExecuteEvents.pointerClickHandler);
			pointerData.pointerPress = null;
			pointerData.rawPointerPress = null;
			pointerData.eligibleForClick = false;
			pointerData.clickCount = 0;
		}
	}

	private void HandleTrigger()
	{
		if (Pvr_UnitySDKManager.SDK.picovrTriggered)
		{
			GameObject gameObject = pointerData.pointerCurrentRaycast.gameObject;
			if (!(gameObject == null) && !(ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject) == null))
			{
				pointerData.pointerPress = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.pressPosition = pointerData.position;
				pointerData.pointerPressRaycast = pointerData.pointerCurrentRaycast;
				pointerData.pointerPress = ExecuteEvents.ExecuteHierarchy(gameObject, pointerData, ExecuteEvents.pointerDownHandler) ?? ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				pointerData.rawPointerPress = gameObject;
				pointerData.eligibleForClick = true;
				pointerData.clickCount = 1;
				pointerData.clickTime = Time.unscaledTime;
			}
		}
	}
}
public class Pvr_ObjImporter
{
	private static Pvr_ObjImporter _instance;

	private List<int> triangles;

	private List<Vector3> vertices;

	private List<Vector2> uv;

	private List<Vector3> normals;

	private List<PvrVector3Int> faceData;

	private List<int> intArray;

	private const int MIN_POW_10 = -16;

	private const int MAX_POW_10 = 16;

	private const int NUM_POWS_10 = 33;

	private static readonly float[] pow10 = GenerateLookupTable();

	public static Pvr_ObjImporter Instance => _instance ?? (_instance = new Pvr_ObjImporter());

	public Mesh ImportFile(string filePath)
	{
		triangles = new List<int>();
		vertices = new List<Vector3>();
		uv = new List<Vector2>();
		normals = new List<Vector3>();
		faceData = new List<PvrVector3Int>();
		intArray = new List<int>();
		LoadMeshData(filePath);
		Vector3[] array = new Vector3[faceData.Count];
		Vector2[] array2 = new Vector2[faceData.Count];
		Vector3[] array3 = new Vector3[faceData.Count];
		for (int i = 0; i < faceData.Count; i++)
		{
			array[i] = vertices[faceData[i].x - 1];
			if (faceData[i].y >= 1)
			{
				array2[i] = uv[faceData[i].y - 1];
			}
			if (faceData[i].z >= 1)
			{
				array3[i] = normals[faceData[i].z - 1];
			}
		}
		Mesh mesh = new Mesh();
		mesh.vertices = array;
		mesh.uv = array2;
		mesh.normals = array3;
		mesh.triangles = triangles.ToArray();
		mesh.RecalculateBounds();
		return mesh;
	}

	private void LoadMeshData(string fileName)
	{
		StringBuilder stringBuilder = new StringBuilder();
		string text = File.ReadAllText(fileName);
		int num = 0;
		string text2 = null;
		int num2 = 0;
		StringBuilder sbInt = new StringBuilder();
		for (int i = 0; i < text.Length; i++)
		{
			if (text[i] != '\n')
			{
				continue;
			}
			stringBuilder.Remove(0, stringBuilder.Length);
			stringBuilder.Append(text, num + 1, i - num);
			num = i;
			if (stringBuilder[0] == 'o' && stringBuilder[1] == ' ')
			{
				sbInt.Remove(0, sbInt.Length);
				for (int j = 2; j < stringBuilder.Length; j++)
				{
					text2 += stringBuilder[j];
				}
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == ' ')
			{
				int start = 2;
				vertices.Add(new Vector3(GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt), GetFloat(stringBuilder, ref start, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 't' && stringBuilder[2] == ' ')
			{
				int start2 = 3;
				uv.Add(new Vector2(GetFloat(stringBuilder, ref start2, ref sbInt), GetFloat(stringBuilder, ref start2, ref sbInt)));
			}
			else if (stringBuilder[0] == 'v' && stringBuilder[1] == 'n' && stringBuilder[2] == ' ')
			{
				int start3 = 3;
				normals.Add(new Vector3(GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt), GetFloat(stringBuilder, ref start3, ref sbInt)));
			}
			else if (stringBuilder[0] == 'f' && stringBuilder[1] == ' ')
			{
				int start4 = 2;
				int num3 = 1;
				intArray.Clear();
				int num4 = 0;
				while (start4 < stringBuilder.Length && char.IsDigit(stringBuilder[start4]))
				{
					faceData.Add(new PvrVector3Int(GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt), GetInt(stringBuilder, ref start4, ref sbInt)));
					num3++;
					intArray.Add(num2);
					num2++;
				}
				num4 += num3;
				for (num3 = 1; num3 + 2 < num4; num3++)
				{
					triangles.Add(intArray[0]);
					triangles.Add(intArray[num3]);
					triangles.Add(intArray[num3 + 1]);
				}
			}
		}
	}

	private float GetFloat(StringBuilder sb, ref int start, ref StringBuilder sbFloat)
	{
		sbFloat.Remove(0, sbFloat.Length);
		while (start < sb.Length && (char.IsDigit(sb[start]) || sb[start] == '-' || sb[start] == '.'))
		{
			sbFloat.Append(sb[start]);
			start++;
		}
		start++;
		return ParseFloat(sbFloat);
	}

	private int GetInt(StringBuilder sb, ref int start, ref StringBuilder sbInt)
	{
		sbInt.Remove(0, sbInt.Length);
		while (start < sb.Length && char.IsDigit(sb[start]))
		{
			sbInt.Append(sb[start]);
			start++;
		}
		start++;
		return IntParseFast(sbInt);
	}

	private static float[] GenerateLookupTable()
	{
		float[] array = new float[320];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = (float)(i / 33) * Mathf.Pow(10f, i % 33 + -16);
		}
		return array;
	}

	private float ParseFloat(StringBuilder value)
	{
		float num = 0f;
		bool flag = false;
		int length = value.Length;
		int num2 = value.Length;
		for (int num3 = length - 1; num3 >= 0; num3--)
		{
			if (value[num3] == '.')
			{
				num2 = num3;
				break;
			}
		}
		int num4 = 16 + num2;
		for (int i = 0; i < num2; i++)
		{
			if (i != num2 && value[i] != '-')
			{
				num += pow10[(value[i] - 48) * 33 + num4 - i - 1];
			}
			else if (value[i] == '-')
			{
				flag = true;
			}
		}
		for (int j = num2 + 1; j < length; j++)
		{
			if (j != num2)
			{
				num += pow10[(value[j] - 48) * 33 + num4 - j];
			}
		}
		if (flag)
		{
			num = 0f - num;
		}
		return num;
	}

	private int IntParseFast(StringBuilder value)
	{
		int num = 0;
		for (int i = 0; i < value.Length; i++)
		{
			num = 10 * num + (value[i] - 48);
		}
		return num;
	}
}
public sealed class PvrVector3Int
{
	public int x { get; set; }

	public int y { get; set; }

	public int z { get; set; }

	public PvrVector3Int()
	{
	}

	public PvrVector3Int(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
public class Pvr_EnumFlags : PropertyAttribute
{
}
public enum ConfirmBtn
{
	App = 1,
	TouchPad = 2,
	Trigger = 4
}
public class Pvr_InputModule : PointerInputModule
{
	public static List<Pvr_UIPointer> pointers = new List<Pvr_UIPointer>();

	[Pvr_EnumFlags]
	public ConfirmBtn confirmBtn = ConfirmBtn.TouchPad;

	private List<RaycastResult> rayCasts = new List<RaycastResult>();

	private RaycastResult rayCastResult;

	public virtual void Initialise()
	{
		pointers.Clear();
	}

	public static void AddPoint(Pvr_UIPointer point)
	{
		if (!pointers.Contains(point))
		{
			pointers.Add(point);
		}
	}

	public static void RemovePoint(Pvr_UIPointer point)
	{
		if (pointers.Contains(point))
		{
			pointers.Remove(point);
		}
	}

	public override void Process()
	{
		if (Pvr_UnitySDKManager.SDK.isHasController)
		{
			if ((confirmBtn & ConfirmBtn.App) == ConfirmBtn.App)
			{
				Pvr_UIPointer.AppBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.APP);
			}
			if ((confirmBtn & ConfirmBtn.TouchPad) == ConfirmBtn.TouchPad)
			{
				Pvr_UIPointer.TouchBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TOUCHPAD);
			}
			if ((confirmBtn & ConfirmBtn.Trigger) == ConfirmBtn.Trigger)
			{
				Pvr_UIPointer.TriggerBtnValue = Controller.UPvr_GetKey(Pvr_ControllerManager.controllerlink.mainHandID, Pvr_KeyCode.TRIGGER);
			}
		}
		for (int i = 0; i < pointers.Count; i++)
		{
			Pvr_UIPointer pvr_UIPointer = pointers[i];
			if (pvr_UIPointer.gameObject.activeInHierarchy && pvr_UIPointer.enabled)
			{
				List<RaycastResult> results = new List<RaycastResult>();
				if (pvr_UIPointer.PointerActive())
				{
					results = CheckRaycasts(pvr_UIPointer);
				}
				Hover(pvr_UIPointer, results);
				Click(pvr_UIPointer, results);
				Drag(pvr_UIPointer, results);
			}
		}
	}

	protected virtual List<RaycastResult> CheckRaycasts(Pvr_UIPointer pointer)
	{
		rayCastResult.worldPosition = pointer.GetOriginPosition();
		rayCastResult.worldNormal = pointer.GetOriginForward();
		pointer.pointerEventData.pointerCurrentRaycast = rayCastResult;
		base.eventSystem.RaycastAll(pointer.pointerEventData, rayCasts);
		return rayCasts;
	}

	protected virtual bool CheckTransformTree(Transform target, Transform source)
	{
		if (target == null)
		{
			return false;
		}
		if (target.Equals(source))
		{
			return true;
		}
		return CheckTransformTree(target.transform.parent, source);
	}

	protected virtual bool NoValidCollision(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (results.Count != 0)
		{
			return !CheckTransformTree(results[0].gameObject.transform, pointer.pointerEventData.pointerEnter.transform);
		}
		return true;
	}

	protected virtual bool IsHovering(Pvr_UIPointer pointer)
	{
		foreach (GameObject item in pointer.pointerEventData.hovered)
		{
			if ((bool)pointer.pointerEventData.pointerEnter && (bool)item && CheckTransformTree(item.transform, pointer.pointerEventData.pointerEnter.transform))
			{
				return true;
			}
		}
		return false;
	}

	protected virtual bool ValidElement(GameObject obj)
	{
		Pvr_UICanvas componentInParent = obj.GetComponentInParent<Pvr_UICanvas>();
		if (!componentInParent || !componentInParent.enabled)
		{
			return false;
		}
		return true;
	}

	protected virtual void CheckPointerHoverClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.hoverDurationTimer > 0f)
		{
			pointer.hoverDurationTimer -= Time.deltaTime;
		}
		if (pointer.canClickOnHover && pointer.hoverDurationTimer <= 0f)
		{
			pointer.canClickOnHover = false;
			ClickOnDown(pointer, results, forceClick: true);
		}
	}

	protected virtual void Hover(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if ((bool)pointer.pointerEventData.pointerEnter)
		{
			CheckPointerHoverClick(pointer, results);
			if (!ValidElement(pointer.pointerEventData.pointerEnter))
			{
				pointer.pointerEventData.pointerEnter = null;
				return;
			}
			if (NoValidCollision(pointer, results))
			{
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerEnter, pointer.pointerEventData, ExecuteEvents.pointerExitHandler);
				pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
				pointer.pointerEventData.pointerEnter = null;
			}
			if (results.Count <= 0 || !(pointer.pointerEventData.pointerEnter != results[0].gameObject))
			{
				return;
			}
			{
				foreach (RaycastResult result in results)
				{
					if (!ValidElement(result.gameObject))
					{
						continue;
					}
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
					if (gameObject != null)
					{
						Selectable component = gameObject.GetComponent<Selectable>();
						if ((bool)component)
						{
							Navigation navigation = default(Navigation);
							navigation.mode = Navigation.Mode.None;
							component.navigation = navigation;
						}
						pointer.pointerEventData.hovered.Remove(pointer.pointerEventData.pointerEnter);
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, gameObject, pointer.hoveringElement));
						pointer.hoveringElement = gameObject;
						pointer.pointerEventData.pointerCurrentRaycast = result;
						pointer.pointerEventData.pointerEnter = gameObject;
						pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
						break;
					}
					if (result.gameObject != pointer.hoveringElement)
					{
						pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result, result.gameObject, pointer.hoveringElement));
					}
					pointer.hoveringElement = result.gameObject;
				}
				return;
			}
		}
		foreach (RaycastResult result2 in results)
		{
			if (!ValidElement(result2.gameObject))
			{
				continue;
			}
			GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.pointerEnterHandler);
			if (gameObject2 != null)
			{
				Selectable component2 = gameObject2.GetComponent<Selectable>();
				if ((bool)component2)
				{
					Navigation navigation2 = default(Navigation);
					navigation2.mode = Navigation.Mode.None;
					component2.navigation = navigation2;
				}
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, gameObject2, pointer.hoveringElement));
				pointer.hoveringElement = gameObject2;
				pointer.pointerEventData.pointerCurrentRaycast = result2;
				pointer.pointerEventData.pointerEnter = gameObject2;
				pointer.pointerEventData.hovered.Add(pointer.pointerEventData.pointerEnter);
				break;
			}
			if (result2.gameObject != pointer.hoveringElement)
			{
				pointer.OnUIPointerElementEnter(pointer.SetUIPointerEvent(result2, result2.gameObject, pointer.hoveringElement));
			}
			pointer.hoveringElement = result2.gameObject;
		}
		if ((bool)pointer.hoveringElement && results.Count == 0)
		{
			pointer.OnUIPointerElementExit(pointer.SetUIPointerEvent(default(RaycastResult), null, pointer.hoveringElement));
			pointer.hoveringElement = null;
		}
	}

	protected virtual void Click(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		switch (pointer.clickMethod)
		{
		case Pvr_UIPointer.ClickMethods.ClickOnButtonUp:
			ClickOnUp(pointer, results);
			break;
		case Pvr_UIPointer.ClickMethods.ClickOnButtonDown:
			ClickOnDown(pointer, results);
			break;
		}
	}

	protected virtual void ClickOnUp(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.eligibleForClick = pointer.ValidClick(checkLastClick: false);
		if (!AttemptClick(pointer))
		{
			IsEligibleClick(pointer, results);
		}
	}

	protected virtual void ClickOnDown(Pvr_UIPointer pointer, List<RaycastResult> results, bool forceClick = false)
	{
		pointer.pointerEventData.eligibleForClick = forceClick || pointer.ValidClick(checkLastClick: true);
		if (IsEligibleClick(pointer, results))
		{
			pointer.pointerEventData.eligibleForClick = false;
			AttemptClick(pointer);
		}
	}

	protected virtual bool IsEligibleClick(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		if (pointer.pointerEventData.eligibleForClick)
		{
			foreach (RaycastResult result in results)
			{
				if (ValidElement(result.gameObject))
				{
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.pointerDownHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pressPosition = pointer.pointerEventData.position;
						pointer.pointerEventData.pointerPressRaycast = result;
						pointer.pointerEventData.pointerPress = gameObject;
						return true;
					}
				}
			}
		}
		return false;
	}

	protected virtual bool AttemptClick(Pvr_UIPointer pointer)
	{
		if ((bool)pointer.pointerEventData.pointerPress)
		{
			if (!ValidElement(pointer.pointerEventData.pointerPress))
			{
				pointer.pointerEventData.pointerPress = null;
				return true;
			}
			if (pointer.pointerEventData.eligibleForClick)
			{
				if (!IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
					pointer.pointerEventData.pointerPress = null;
				}
			}
			else
			{
				pointer.OnUIPointerElementClick(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, pointer.pointerEventData.pointerPress));
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerClickHandler);
				ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerPress, pointer.pointerEventData, ExecuteEvents.pointerUpHandler);
				pointer.pointerEventData.pointerPress = null;
			}
			return true;
		}
		return false;
	}

	protected virtual void Drag(Pvr_UIPointer pointer, List<RaycastResult> results)
	{
		pointer.pointerEventData.dragging = pointer.IsSelectionButtonPressed() && pointer.pointerEventData.delta != Vector2.zero;
		if ((bool)pointer.pointerEventData.pointerDrag)
		{
			if (!ValidElement(pointer.pointerEventData.pointerDrag))
			{
				pointer.pointerEventData.pointerDrag = null;
				return;
			}
			if (pointer.pointerEventData.dragging)
			{
				if (IsHovering(pointer))
				{
					ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
				}
				return;
			}
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.dragHandler);
			ExecuteEvents.ExecuteHierarchy(pointer.pointerEventData.pointerDrag, pointer.pointerEventData, ExecuteEvents.endDragHandler);
			foreach (RaycastResult result in results)
			{
				ExecuteEvents.ExecuteHierarchy(result.gameObject, pointer.pointerEventData, ExecuteEvents.dropHandler);
			}
			pointer.pointerEventData.pointerDrag = null;
		}
		else
		{
			if (!pointer.pointerEventData.dragging)
			{
				return;
			}
			foreach (RaycastResult result2 in results)
			{
				if (ValidElement(result2.gameObject))
				{
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.initializePotentialDrag);
					ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.beginDragHandler);
					GameObject gameObject = ExecuteEvents.ExecuteHierarchy(result2.gameObject, pointer.pointerEventData, ExecuteEvents.dragHandler);
					if (gameObject != null)
					{
						pointer.pointerEventData.pointerDrag = gameObject;
						break;
					}
				}
			}
		}
	}
}
public class Pvr_UICanvas : MonoBehaviour
{
	public bool clickOnPointerCollision;

	public float autoActivateWithinDistance;

	protected BoxCollider canvasBoxCollider;

	protected Rigidbody canvasRigidBody;

	protected Coroutine draggablePanelCreation;

	protected const string CANVAS_DRAGGABLE_PANEL = "UICANVAS_DRAGGABLE_PANEL";

	protected virtual void OnEnable()
	{
		SetupCanvas();
	}

	protected virtual void OnDisable()
	{
		RemoveCanvas();
	}

	protected virtual void OnDestroy()
	{
		RemoveCanvas();
	}

	protected virtual void SetupCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component && component.renderMode == RenderMode.WorldSpace)
		{
			RectTransform component2 = component.GetComponent<RectTransform>();
			Vector2 sizeDelta = component2.sizeDelta;
			GraphicRaycaster component3 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster pvr_UIGraphicRaycaster = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if (!pvr_UIGraphicRaycaster)
			{
				pvr_UIGraphicRaycaster = component.gameObject.AddComponent<Pvr_UIGraphicRaycaster>();
			}
			if ((bool)component3 && component3.enabled)
			{
				pvr_UIGraphicRaycaster.ignoreReversedGraphics = component3.ignoreReversedGraphics;
				pvr_UIGraphicRaycaster.blockingObjects = component3.blockingObjects;
				component3.enabled = false;
			}
			if (!component.gameObject.GetComponent<BoxCollider>())
			{
				float z = 0.1f / component2.localScale.z;
				canvasBoxCollider = component.gameObject.AddComponent<BoxCollider>();
				canvasBoxCollider.size = new Vector3(sizeDelta.x, sizeDelta.y, z);
				canvasBoxCollider.isTrigger = true;
			}
			if (!component.gameObject.GetComponent<Rigidbody>())
			{
				canvasRigidBody = component.gameObject.AddComponent<Rigidbody>();
				canvasRigidBody.isKinematic = true;
			}
			draggablePanelCreation = StartCoroutine(CreateDraggablePanel(component, sizeDelta));
		}
	}

	protected virtual IEnumerator CreateDraggablePanel(Canvas canvas, Vector2 canvasSize)
	{
		if ((bool)canvas && !canvas.transform.Find("UICANVAS_DRAGGABLE_PANEL"))
		{
			yield return null;
			GameObject obj = new GameObject("UICANVAS_DRAGGABLE_PANEL", typeof(RectTransform));
			obj.AddComponent<LayoutElement>().ignoreLayout = true;
			obj.AddComponent<Image>().color = Color.clear;
			obj.AddComponent<EventTrigger>();
			obj.transform.SetParent(canvas.transform);
			obj.GetComponent<RectTransform>().sizeDelta = canvasSize;
			obj.transform.localPosition = Vector3.zero;
			obj.transform.localRotation = Quaternion.identity;
			obj.transform.localScale = Vector3.one;
			obj.transform.SetAsFirstSibling();
		}
	}

	protected virtual void RemoveCanvas()
	{
		Canvas component = GetComponent<Canvas>();
		if ((bool)component)
		{
			GraphicRaycaster component2 = component.gameObject.GetComponent<GraphicRaycaster>();
			Pvr_UIGraphicRaycaster component3 = component.gameObject.GetComponent<Pvr_UIGraphicRaycaster>();
			if ((bool)component3)
			{
				UnityEngine.Object.Destroy(component3);
			}
			if ((bool)component2 && !component2.enabled)
			{
				component2.enabled = true;
			}
			if ((bool)canvasBoxCollider)
			{
				UnityEngine.Object.Destroy(canvasBoxCollider);
			}
			if ((bool)canvasRigidBody)
			{
				UnityEngine.Object.Destroy(canvasRigidBody);
			}
			StopCoroutine(draggablePanelCreation);
			Transform transform = component.transform.Find("UICANVAS_DRAGGABLE_PANEL");
			if ((bool)transform)
			{
				UnityEngine.Object.Destroy(transform.gameObject);
			}
		}
	}
}
public struct UIDraggableItemEventArgs
{
	public GameObject target;
}
public delegate void UIDraggableItemEventHandler(object sender, UIDraggableItemEventArgs e);
public class Pvr_UIDraggableItem : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public bool restrictToDropZone;

	public bool restrictToOriginalCanvas;

	public float moveOffset = 0.1f;

	[HideInInspector]
	public GameObject validDropZone;

	protected RectTransform dragTransform;

	protected Vector3 startPosition;

	protected Quaternion startRotation;

	protected GameObject startDropZone;

	protected Transform startParent;

	protected Canvas startCanvas;

	protected CanvasGroup canvasGroup;

	protected Pvr_InputModule currentInputmodule;

	public event UIDraggableItemEventHandler DraggableItemDropped;

	public event UIDraggableItemEventHandler DraggableItemReset;

	public virtual void OnDraggableItemDropped(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemDropped != null)
		{
			this.DraggableItemDropped(this, e);
		}
	}

	public virtual void OnDraggableItemReset(UIDraggableItemEventArgs e)
	{
		if (this.DraggableItemReset != null)
		{
			this.DraggableItemReset(this, e);
		}
	}

	public void OnBeginDrag(PointerEventData eventData)
	{
		startPosition = base.transform.position;
		startRotation = base.transform.rotation;
		startParent = base.transform.parent;
		startCanvas = GetComponentInParent<Canvas>();
		canvasGroup.blocksRaycasts = false;
		if (restrictToDropZone)
		{
			startDropZone = GetComponentInParent<Pvr_UIDropZone>().gameObject;
			validDropZone = startDropZone;
		}
		SetDragPosition(eventData);
		Pvr_UIPointer pointer = GetPointer();
		if (pointer != null)
		{
			pointer.OnUIPointerElementDragStart(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		SetDragPosition(eventData);
	}

	public void OnEndDrag(PointerEventData eventData)
	{
		canvasGroup.blocksRaycasts = true;
		dragTransform = null;
		base.transform.position += base.transform.forward * moveOffset;
		bool flag = true;
		if (restrictToDropZone)
		{
			if (validDropZone != null && validDropZone != startDropZone)
			{
				base.transform.SetParent(validDropZone.transform);
			}
			else
			{
				ResetElement();
				flag = false;
			}
		}
		Canvas canvas = ((eventData.pointerEnter != null) ? eventData.pointerEnter.GetComponentInParent<Canvas>() : null);
		if (restrictToOriginalCanvas && canvas != null && canvas != startCanvas)
		{
			ResetElement();
			flag = false;
		}
		if (canvas == null)
		{
			ResetElement();
			flag = false;
		}
		if (flag)
		{
			Pvr_UIPointer pointer = GetPointer();
			if (pointer != null)
			{
				pointer.OnUIPointerElementDragEnd(pointer.SetUIPointerEvent(pointer.pointerEventData.pointerPressRaycast, base.gameObject));
			}
			OnDraggableItemDropped(SetEventPayload(validDropZone));
		}
		validDropZone = null;
		startParent = null;
		startCanvas = null;
	}

	protected virtual void OnEnable()
	{
		canvasGroup = GetComponent<CanvasGroup>();
		if (restrictToDropZone && GetComponentInParent<Pvr_UIDropZone>() == null)
		{
			base.enabled = false;
		}
		currentInputmodule = UnityEngine.Object.FindObjectOfType<Pvr_InputModule>();
	}

	protected virtual Pvr_UIPointer GetPointer()
	{
		foreach (Pvr_UIPointer pointer in Pvr_InputModule.pointers)
		{
			if (pointer.gameObject.activeInHierarchy && (bool)pointer)
			{
				return pointer;
			}
		}
		return null;
	}

	protected virtual void SetDragPosition(PointerEventData eventData)
	{
		if (eventData.pointerEnter != null && eventData.pointerEnter.transform as RectTransform != null)
		{
			dragTransform = eventData.pointerEnter.transform as RectTransform;
		}
		if (dragTransform != null && RectTransformUtility.ScreenPointToWorldPointInRectangle(dragTransform, eventData.position, eventData.pressEventCamera, out var worldPoint))
		{
			base.transform.position = worldPoint - base.transform.forward * moveOffset;
			base.transform.rotation = dragTransform.rotation;
		}
	}

	protected virtual void ResetElement()
	{
		base.transform.position = startPosition;
		base.transform.rotation = startRotation;
		base.transform.SetParent(startParent);
		OnDraggableItemReset(SetEventPayload(startParent.gameObject));
	}

	protected virtual UIDraggableItemEventArgs SetEventPayload(GameObject target)
	{
		UIDraggableItemEventArgs result = default(UIDraggableItemEventArgs);
		result.target = target;
		return result;
	}
}
public class Pvr_UIDropZone : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	protected Pvr_UIDraggableItem droppableItem;

	public void OnPointerEnter(PointerEventData eventData)
	{
		if ((bool)eventData.pointerDrag)
		{
			Pvr_UIDraggableItem component = eventData.pointerDrag.GetComponent<Pvr_UIDraggableItem>();
			if ((bool)component && component.restrictToDropZone)
			{
				component.validDropZone = base.gameObject;
				droppableItem = component;
			}
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if ((bool)droppableItem)
		{
			droppableItem.validDropZone = null;
		}
		droppableItem = null;
	}
}
public class Pvr_UIGraphicRaycaster : GraphicRaycaster
{
	protected Canvas currentCanvas;

	protected Vector2 lastKnownPosition;

	protected const float UI_CONTROL_OFFSET = 1E-05f;

	[NonSerialized]
	private static List<RaycastResult> s_RaycastResults = new List<RaycastResult>();

	protected virtual Canvas canvas
	{
		get
		{
			if (currentCanvas != null)
			{
				return currentCanvas;
			}
			currentCanvas = base.gameObject.GetComponent<Canvas>();
			return currentCanvas;
		}
	}

	public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
	{
		if (!(canvas == null))
		{
			Raycast(ray: new Ray(eventData.pointerCurrentRaycast.worldPosition, eventData.pointerCurrentRaycast.worldNormal), canvas: canvas, eventCamera: eventCamera, results: ref s_RaycastResults);
			SetNearestRaycast(ref eventData, ref resultAppendList, ref s_RaycastResults);
			s_RaycastResults.Clear();
		}
	}

	protected virtual void SetNearestRaycast(ref PointerEventData eventData, ref List<RaycastResult> resultAppendList, ref List<RaycastResult> raycastResults)
	{
		RaycastResult? raycastResult = null;
		for (int i = 0; i < raycastResults.Count; i++)
		{
			RaycastResult raycastResult2 = raycastResults[i];
			raycastResult2.index = resultAppendList.Count;
			if (!raycastResult.HasValue || raycastResult2.distance < raycastResult.Value.distance)
			{
				raycastResult = raycastResult2;
			}
			resultAppendList.Add(raycastResult2);
		}
		if (raycastResult.HasValue)
		{
			eventData.position = raycastResult.Value.screenPosition;
			eventData.delta = eventData.position - lastKnownPosition;
			lastKnownPosition = eventData.position;
			eventData.pointerCurrentRaycast = raycastResult.Value;
		}
	}

	protected virtual float GetHitDistance(Ray ray)
	{
		float result = float.MaxValue;
		if (canvas.renderMode != 0 && base.blockingObjects != 0)
		{
			float num = Vector3.Distance(ray.origin, canvas.transform.position);
			if (base.blockingObjects == BlockingObjects.ThreeD || base.blockingObjects == BlockingObjects.All)
			{
				Physics.Raycast(ray, out var hitInfo, num);
				if ((bool)hitInfo.collider)
				{
					result = hitInfo.distance;
				}
			}
			if (base.blockingObjects == BlockingObjects.TwoD || base.blockingObjects == BlockingObjects.All)
			{
				RaycastHit2D raycastHit2D = Physics2D.Raycast(ray.origin, ray.direction, num);
				if (raycastHit2D.collider != null)
				{
					result = raycastHit2D.fraction * num;
				}
			}
		}
		return result;
	}

	protected virtual void Raycast(Canvas canvas, Camera eventCamera, Ray ray, ref List<RaycastResult> results)
	{
		float hitDistance = GetHitDistance(ray);
		IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(canvas);
		for (int i = 0; i < graphicsForCanvas.Count; i++)
		{
			Graphic graphic = graphicsForCanvas[i];
			if (graphic.depth == -1 || !graphic.raycastTarget)
			{
				continue;
			}
			Transform transform = graphic.transform;
			Vector3 forward = transform.forward;
			float num = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
			if (!(num < 0f) && !(num - 1E-05f > hitDistance))
			{
				Vector3 point = ray.GetPoint(num);
				Vector2 vector = eventCamera.WorldToScreenPoint(point);
				if (RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, vector, eventCamera) && graphic.Raycast(vector, eventCamera))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = graphic.gameObject;
					raycastResult.module = this;
					raycastResult.distance = num;
					raycastResult.screenPosition = vector;
					raycastResult.worldPosition = point;
					raycastResult.depth = graphic.depth;
					raycastResult.sortingLayer = canvas.sortingLayerID;
					raycastResult.sortingOrder = canvas.sortingOrder;
					RaycastResult item = raycastResult;
					results.Add(item);
				}
			}
		}
		results.Sort((RaycastResult g1, RaycastResult g2) => g2.depth.CompareTo(g1.depth));
	}
}
public struct UIPointerEventArgs
{
	public bool isActive;

	public GameObject currentTarget;

	public GameObject previousTarget;

	public RaycastResult raycastResult;
}
public delegate void UIPointerEventHandler(object sender, UIPointerEventArgs e);
public class Pvr_UIPointer : MonoBehaviour
{
	public enum ClickMethods
	{
		ClickOnButtonUp,
		ClickOnButtonDown
	}

	public ClickMethods clickMethod;

	[HideInInspector]
	public bool collisionClick;

	[HideInInspector]
	public bool pressToDrag;

	[HideInInspector]
	public GameObject autoActivatingCanvas;

	[HideInInspector]
	public PointerEventData pointerEventData;

	[HideInInspector]
	public GameObject hoveringElement;

	[HideInInspector]
	public float hoverDurationTimer;

	[HideInInspector]
	public bool canClickOnHover;

	public Transform pointerOriginTransform;

	protected bool pointerClicked;

	protected bool beamEnabledState;

	protected bool lastPointerPressState;

	protected bool lastPointerClickState;

	protected GameObject currentTarget;

	protected EventSystem cachedEventSystem;

	protected Pvr_InputModule cachedVRInputModule;

	protected Transform originalPointerOriginTransform;

	public static bool TouchBtnValue;

	public static bool AppBtnValue;

	public static bool TriggerBtnValue;

	public event UIPointerEventHandler UIPointerElementEnter;

	public event UIPointerEventHandler UIPointerElementExit;

	public event UIPointerEventHandler UIPointerElementClick;

	public event UIPointerEventHandler UIPointerElementDragStart;

	public event UIPointerEventHandler UIPointerElementDragEnd;

	public virtual bool PointerActive()
	{
		return true;
	}

	public virtual bool IsSelectionButtonPressed()
	{
		if (!Input.GetMouseButton(0) && !Input.GetKey(KeyCode.JoystickButton0) && !TouchBtnValue && !AppBtnValue)
		{
			return TriggerBtnValue;
		}
		return true;
	}

	public virtual Vector3 GetOriginPosition()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.position;
		}
		return pointerOriginTransform.position;
	}

	public virtual Vector3 GetOriginForward()
	{
		if (!pointerOriginTransform)
		{
			return base.transform.forward;
		}
		return pointerOriginTransform.forward;
	}

	public virtual bool ValidClick(bool checkLastClick, bool lastClickState = false)
	{
		bool result = (collisionClick ? collisionClick : IsSelectionButtonPressed());
		if (!checkLastClick)
		{
			return result;
		}
		return result;
	}

	protected virtual void ResetHoverTimer()
	{
		hoverDurationTimer = 0f;
		canClickOnHover = false;
	}

	public virtual void OnUIPointerElementEnter(UIPointerEventArgs e)
	{
		if (e.currentTarget != currentTarget)
		{
			ResetHoverTimer();
		}
		currentTarget = e.currentTarget;
		if (this.UIPointerElementEnter != null)
		{
			this.UIPointerElementEnter(this, e);
		}
	}

	public virtual void OnUIPointerElementExit(UIPointerEventArgs e)
	{
		if (e.previousTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementExit != null)
		{
			this.UIPointerElementExit(this, e);
		}
	}

	public virtual void OnUIPointerElementClick(UIPointerEventArgs e)
	{
		if (e.currentTarget == currentTarget)
		{
			ResetHoverTimer();
		}
		if (this.UIPointerElementClick != null)
		{
			this.UIPointerElementClick(this, e);
		}
	}

	public virtual void OnUIPointerElementDragStart(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragStart != null)
		{
			this.UIPointerElementDragStart(this, e);
		}
	}

	public virtual void OnUIPointerElementDragEnd(UIPointerEventArgs e)
	{
		if (this.UIPointerElementDragEnd != null)
		{
			this.UIPointerElementDragEnd(this, e);
		}
	}

	public virtual UIPointerEventArgs SetUIPointerEvent(RaycastResult currentRaycastResult, GameObject currentTarget, GameObject lastTarget = null)
	{
		UIPointerEventArgs result = default(UIPointerEventArgs);
		result.isActive = PointerActive();
		result.currentTarget = currentTarget;
		result.previousTarget = lastTarget;
		result.raycastResult = currentRaycastResult;
		return result;
	}

	protected virtual void Awake()
	{
		originalPointerOriginTransform = pointerOriginTransform;
	}

	protected virtual void OnEnable()
	{
		pointerOriginTransform = originalPointerOriginTransform;
		ConfigureEventSystem();
		pointerClicked = false;
		lastPointerPressState = false;
		lastPointerClickState = false;
		beamEnabledState = false;
	}

	protected virtual void OnDisable()
	{
		Pvr_InputModule.RemovePoint(this);
	}

	protected virtual void ConfigureEventSystem()
	{
		if (!cachedEventSystem)
		{
			cachedEventSystem = UnityEngine.Object.FindObjectOfType<EventSystem>();
		}
		if (!cachedVRInputModule)
		{
			cachedVRInputModule = cachedEventSystem.GetComponent<Pvr_InputModule>();
		}
		if ((bool)cachedEventSystem && (bool)cachedVRInputModule && pointerEventData == null)
		{
			pointerEventData = new PointerEventData(cachedEventSystem);
		}
		Pvr_InputModule.AddPoint(this);
	}
}
[ExecuteInEditMode]
public class Pvr_UnitySDKEditor : MonoBehaviour
{
	private bool vrModeEnabled = true;

	private float mouseX;

	private float mouseY;

	private float mouseZ;

	private float neckModelScale;

	private bool autoUntiltHead;

	private static readonly Vector3 neckOffset = new Vector3(0f, 0.075f, 0.0805f);

	[HideInInspector]
	public Matrix4x4 headView;

	[HideInInspector]
	public Matrix4x4 leftEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 rightEyeUndistortedProj;

	[HideInInspector]
	public Matrix4x4 leftEyeProj;

	[HideInInspector]
	public Matrix4x4 rightEyeProj;

	private const float TOUCH_TIME_LIMIT = 0.2f;

	private float touchStartTime;

	public Matrix4x4 UndistortedProjection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeUndistortedProj;
		}
		return leftEyeUndistortedProj;
	}

	public Matrix4x4 Projection(Eye eye)
	{
		if (eye != 0)
		{
			return rightEyeProj;
		}
		return leftEyeProj;
	}

	private void Awake()
	{
		InitEyePara();
		InitEditorSensorPara();
	}

	private void Update()
	{
		SimulateInput();
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public void InitEyePara()
	{
		ComputeEyesFromProfile();
		InitForEye(ref Pvr_UnitySDKManager.SDK.Eyematerial, ref Pvr_UnitySDKManager.SDK.Middlematerial);
		if (Pvr_UnitySDKRender.Instance == null)
		{
			PLOG.I("pvr_UnitySDKRender init failed");
		}
		if (Pvr_UnitySDKSensor.Instance == null)
		{
			PLOG.I("pvr_UnitySDKSensor init failed");
		}
		FovAdjust();
	}

	private void InitEditorSensorPara()
	{
		Pvr_UnitySDKManager.SDK.picovrTriggered = Pvr_UnitySDKManager.SDK.newPicovrTriggered;
		Pvr_UnitySDKManager.SDK.newPicovrTriggered = false;
	}

	public static Matrix4x4 MakeProjection(float l, float t, float r, float b, float n, float f)
	{
		Matrix4x4 zero = Matrix4x4.zero;
		zero[0, 0] = 2f * n / (r - l);
		zero[1, 1] = 2f * n / (t - b);
		zero[0, 2] = (r + l) / (r - l);
		zero[1, 2] = (t + b) / (t - b);
		zero[2, 2] = (n + f) / (n - f);
		zero[2, 3] = 2f * n * f / (n - f);
		zero[3, 2] = -1f;
		return zero;
	}

	public bool UpdateStatesensor()
	{
		UpdateSimulatedSensor();
		return true;
	}

	public void ComputeEyesFromProfile()
	{
		Vector2 vector = new Vector2(0.11f, 0.062f);
		Pvr_UnitySDKManager.SDK.leftEyeView = Matrix4x4.identity;
		Pvr_UnitySDKManager.SDK.leftEyeView[0, 3] = (0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f;
		float[] leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleTanAngles(vector.x, vector.y);
		leftEyeProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		leftEyeVisibleTanAngles = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeNoLensTanAngles(vector.x, vector.y);
		leftEyeUndistortedProj = MakeProjection(leftEyeVisibleTanAngles[0], leftEyeVisibleTanAngles[1], leftEyeVisibleTanAngles[2], leftEyeVisibleTanAngles[3], 1f, 1000f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.GetLeftEyeVisibleScreenRect(leftEyeVisibleTanAngles, vector.x, vector.y);
		Pvr_UnitySDKManager.SDK.rightEyeView = Pvr_UnitySDKManager.SDK.leftEyeView;
		Pvr_UnitySDKManager.SDK.rightEyeView[0, 3] *= -1f;
		rightEyeProj = leftEyeProj;
		rightEyeProj[0, 2] *= -1f;
		rightEyeUndistortedProj = leftEyeUndistortedProj;
		rightEyeUndistortedProj[0, 2] *= -1f;
		Rect leftEyeRect = new Rect(0f, 0f, 0.5f, 1f);
		Rect rightEyeRect = new Rect(0.5f, 0f, 0.5f, 1f);
		Pvr_UnitySDKManager.SDK.leftEyeRect = leftEyeRect;
		Pvr_UnitySDKManager.SDK.rightEyeRect = rightEyeRect;
		Pvr_UnitySDKManager.SDK.leftEyeOffset = new Vector3((0f - Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation) / 2f, 0f, 0f);
		Pvr_UnitySDKManager.SDK.rightEyeOffset = new Vector3(Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devLenses.separation / 2f, 0f, 0f);
	}

	public bool ResetUnitySDKSensor()
	{
		mouseX = (mouseY = (mouseZ = 0f));
		return true;
	}

	private void SimulateInput()
	{
		if (Input.GetMouseButtonDown(0) && (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt)))
		{
			EnableVEmodel();
		}
		if (Input.GetMouseButtonDown(0))
		{
			touchStartTime = Time.time;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			if (Time.time - touchStartTime <= 0.2f)
			{
				Pvr_UnitySDKManager.SDK.newPicovrTriggered = true;
			}
			touchStartTime = 0f;
		}
		UpdateSimulatedSensor();
	}

	private void FovAdjust()
	{
		Pvr_UnitySDKRender.Instance.EyeVFoV = 2f * Pvr_UnitySDKManager.SDK.pvr_UnitySDKConfig.device.devMaxFov.upper;
	}

	private Rect RectAdjust(Rect eyeRect)
	{
		Rect result = new Rect(0f, 0f, 0.5f, 1f);
		result.width *= 2f * eyeRect.width;
		result.x = eyeRect.x + 2f * result.x * eyeRect.width;
		result.height *= eyeRect.height;
		result.y = eyeRect.y + result.y * eyeRect.height;
		return result;
	}

	private void UpdateSimulatedSensor()
	{
		bool flag = false;
		if (Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt))
		{
			mouseX += Input.GetAxis("Mouse X") * 5f;
			if (mouseX <= -180f)
			{
				mouseX += 360f;
			}
			else if (mouseX > 180f)
			{
				mouseX -= 360f;
			}
			mouseY -= Input.GetAxis("Mouse Y") * 2.4f;
			mouseY = Mathf.Clamp(mouseY, -91f, 91f);
		}
		else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
		{
			flag = true;
			mouseZ += Input.GetAxis("Mouse X") * 5f;
			mouseZ = Mathf.Clamp(mouseZ, -91f, 91f);
		}
		if (!flag && autoUntiltHead)
		{
			mouseZ = Mathf.Lerp(mouseZ, 0f, Time.deltaTime / (Time.deltaTime + 0.1f));
		}
		Quaternion quaternion = Quaternion.Euler(mouseY, mouseX, mouseZ);
		Matrix4x4 matrix = Matrix4x4.TRS((quaternion * neckOffset - neckOffset.y * Vector3.up) * neckModelScale, quaternion, Vector3.one);
		Pvr_UnitySDKSensor.Instance.HeadPose = new Pvr_UnitySDKPose(matrix);
	}

	private void InitForEye(ref Material mat, ref Material mat1)
	{
		Shader shader = Shader.Find("Pvr_UnitySDK/Undistortion");
		Shader shader2 = Shader.Find("Pvr_UnitySDK/FillColor");
		if (shader == null || shader2 == null)
		{
			PLOG.E("Ths Shader Missing ");
			return;
		}
		mat = new Material(shader);
		mat1 = new Material(shader2);
	}

	private void EnableVEmodel()
	{
		vrModeEnabled = !vrModeEnabled;
		Pvr_UnitySDKManager.SDK.VRModeEnabled = vrModeEnabled;
	}
}
public class Pvr_VolumePowerBrightness : MonoBehaviour
{
	private bool VolEnable;

	private bool BattEnable;

	public Text showResult;

	public Text setVolumnum;

	public Text setBrightnum;

	public string MusicPath;

	private void Awake()
	{
		InitBatteryVolClass();
		string startreceivre = base.gameObject.name;
		StartBatteryReceiver(startreceivre);
		StartAudioReceiver(startreceivre);
	}

	private void OnDisable()
	{
		if (VolEnable)
		{
			StopAudioReceiver();
		}
		if (BattEnable)
		{
			StopBatteryReceiver();
		}
	}

	public void GetMaxVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetMaxVolumeNumber();
		showResult.text = "Maximum volume: " + num;
	}

	public void GetCurrentVolumeNumber()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCurrentVolumeNumber();
		showResult.text = "Current volume" + num;
	}

	public void VolumeUp()
	{
		if (!VolumePowerBrightness.UPvr_VolumeUp())
		{
			PLOG.E("VolumeUp Error");
		}
	}

	public void VolumeDown()
	{
		if (!VolumePowerBrightness.UPvr_VolumeDown())
		{
			PLOG.E("VolumeDown Error");
		}
	}

	public void SetVolumeNum()
	{
		int volume = new System.Random().Next(0, 15);
		setVolumnum.text = "Random number" + volume;
		if (!VolumePowerBrightness.UPvr_SetVolumeNum(volume))
		{
			PLOG.E("SetVolumeNum Error");
		}
	}

	public void SetBrightness()
	{
		int brightness = new System.Random().Next(0, 255);
		setBrightnum.text = "Random number" + brightness;
		if (!VolumePowerBrightness.UPvr_SetCommonBrightness(brightness))
		{
			PLOG.E("SetBrightness Error");
		}
	}

	public void GetCurrentBrightness()
	{
		int num = 0;
		num = VolumePowerBrightness.UPvr_GetCommonBrightness();
		showResult.text = "Current brightness" + num;
	}

	public bool setAudio(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	public bool setBattery(string s)
	{
		PLOG.I(s.ToString());
		return true;
	}

	private bool InitBatteryVolClass()
	{
		return VolumePowerBrightness.UPvr_InitBatteryVolClass();
	}

	private bool StartBatteryReceiver(string startreceivre)
	{
		BattEnable = VolumePowerBrightness.UPvr_StartBatteryReceiver(startreceivre);
		return BattEnable;
	}

	private bool StopBatteryReceiver()
	{
		return VolumePowerBrightness.UPvr_StopBatteryReceiver();
	}

	private bool StartAudioReceiver(string startreceivre)
	{
		VolEnable = VolumePowerBrightness.UPvr_StartAudioReceiver(startreceivre);
		return VolEnable;
	}

	private bool StopAudioReceiver()
	{
		return VolumePowerBrightness.UPvr_StopAudioReceiver();
	}
}
public class Button_Links : MonoBehaviour
{
	public void wikipedia()
	{
		Application.OpenURL("https://en.wikipedia.org/wiki/Arc_de_Triomphe");
	}
}
public class crane_animate : MonoBehaviour
{
	public Animator animator;

	public AnimatorControllerParameter animParam;

	public float rotateYaw;

	public float weight;

	public float dolly;

	public float hook;

	public bool demoMode;

	private float randomYawIncrease;

	private float randomDollyIncrease;

	private float randomHookIncrease;

	private void Start()
	{
		randomYawIncrease = UnityEngine.Random.Range(1, 10);
		randomDollyIncrease = UnityEngine.Random.Range(0.1f, 1f);
		randomHookIncrease = UnityEngine.Random.Range(0.1f, 1f);
	}

	private void Update()
	{
		if (demoMode)
		{
			rotateYaw += Time.deltaTime * randomYawIncrease;
			dolly = (Mathf.Sin(Time.time * randomDollyIncrease) * 100f + 100f) / 2f;
			hook = (Mathf.Sin(Time.time * randomHookIncrease) * 100f + 100f) / 2f;
		}
		animator.SetFloat("Rotate_YAW", Mathf.Abs(rotateYaw) % 360f);
		animator.SetFloat("weight", weight);
		animator.SetFloat("dolly", dolly);
		animator.SetFloat("hook", hook);
	}
}
public class crane_animate1 : MonoBehaviour
{
	public Animator animator;

	public AnimatorControllerParameter animParam;

	public float rotateYaw;

	public float dolly;

	public float hook;

	public bool demoMode;

	private float randomYawIncrease;

	private float randomDollyIncrease;

	private float randomHookIncrease;

	private void Start()
	{
		randomYawIncrease = UnityEngine.Random.Range(1, 10);
		randomDollyIncrease = UnityEngine.Random.Range(0.1f, 1f);
		randomHookIncrease = UnityEngine.Random.Range(0.1f, 1f);
	}

	private void Update()
	{
		if (demoMode)
		{
			rotateYaw += Time.deltaTime * randomYawIncrease;
			dolly = (Mathf.Sin(Time.time * randomDollyIncrease) * 100f + 100f) / 2f;
			hook = (Mathf.Sin(Time.time * randomHookIncrease) * 100f + 100f) / 2f;
		}
		animator.SetFloat("Rotate_YAW", Mathf.Abs(rotateYaw) % 360f);
		animator.SetFloat("dolly", dolly);
		animator.SetFloat("hook", hook);
	}
}
public class crane_animate2 : MonoBehaviour
{
	public Animator animator;

	public AnimatorControllerParameter animParam;

	public float rotateYaw;

	public float pitch;

	public float hook;

	public bool demoMode;

	private float randomYawIncrease;

	private float randomPitchIncrease;

	private float randomHookIncrease;

	private void Start()
	{
		randomYawIncrease = UnityEngine.Random.Range(1, 10);
		randomPitchIncrease = UnityEngine.Random.Range(0.1f, 1f);
		randomHookIncrease = UnityEngine.Random.Range(0.1f, 1f);
	}

	private void Update()
	{
		if (demoMode)
		{
			rotateYaw += Time.deltaTime * randomYawIncrease;
			pitch = (Mathf.Sin(Time.time * randomPitchIncrease) * 100f + 100f) / 2f;
			hook = (Mathf.Sin(Time.time * randomHookIncrease) * 100f + 100f) / 2f;
		}
		animator.SetFloat("Rotate_YAW", Mathf.Abs(rotateYaw) % 360f);
		animator.SetFloat("pitch", pitch);
		animator.SetFloat("hook", hook);
	}
}
internal class Tiled_Texture_Animation : MonoBehaviour
{
	public int _uvTieX = 1;

	public int _uvTieY = 1;

	public float _fps = 10f;

	public float mWaitBeforeStart;

	public int mLoopStartFrame = 3;

	private float mStartWait;

	private float iX;

	private float iY = 1f;

	private int mMaxFrames;

	private int mFrameCntr;

	private Vector2 _size;

	private Renderer _myRenderer;

	private int mLastCntr = -1;

	private void Start()
	{
		mStartWait = mWaitBeforeStart;
		_size = new Vector2(1f / (float)_uvTieX, 1f / (float)_uvTieY);
		_myRenderer = GetComponent<Renderer>();
		if (_myRenderer == null)
		{
			base.enabled = false;
		}
		_myRenderer.material.SetTextureScale("_MainTex", _size);
		Vector2 value = new Vector2(0f, 1f - _size.y);
		_myRenderer.material.SetTextureOffset("_MainTex", value);
		mMaxFrames = _uvTieX * _uvTieY;
		if (mLoopStartFrame >= mMaxFrames)
		{
			UnityEngine.Debug.Log("mLoopStartFrame error!!");
			mLoopStartFrame = 0;
		}
		mFrameCntr = 0;
	}

	private void Update()
	{
		if (mStartWait > 0f)
		{
			mStartWait -= Time.deltaTime;
			if (!(mStartWait < 0f))
			{
				return;
			}
			mStartWait = 0f;
		}
		int num = (int)(Time.timeSinceLevelLoad * _fps) % (_uvTieX * _uvTieY);
		if (num != mLastCntr)
		{
			iX = mFrameCntr % _uvTieX;
			iY = (mFrameCntr / _uvTieX + 1) % _uvTieY;
			Vector2 value = new Vector2(iX * _size.x, 1f - _size.y * iY);
			_myRenderer.material.SetTextureOffset("_MainTex", value);
			mFrameCntr++;
			if (mFrameCntr == mMaxFrames)
			{
				iX = mLoopStartFrame % _uvTieX;
				iY = (mLoopStartFrame / _uvTieX + 1) % _uvTieY;
				mFrameCntr = mLoopStartFrame;
			}
			mLastCntr = num;
		}
	}
}
public class CarAttach : MonoBehaviour
{
	public GameObject Player;

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == Player)
		{
			Player.transform.parent = base.transform;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject == Player)
		{
			Player.transform.parent = null;
		}
	}
}
public class FerrisSpin : MonoBehaviour
{
	public float speed = 10f;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(new Vector3(0f, 0f, -1f), speed * Time.deltaTime);
	}
}
public class opencloseDoor : MonoBehaviour
{
	public Animator openandclose;

	public bool open;

	public Transform Player;

	private void Start()
	{
		open = false;
	}

	private void OnMouseOver()
	{
		if (!Player || !(Vector3.Distance(Player.position, base.transform.position) < 15f))
		{
			return;
		}
		if (!open)
		{
			if (Input.GetMouseButtonDown(0))
			{
				StartCoroutine(opening());
			}
		}
		else if (open && Input.GetMouseButtonDown(0))
		{
			StartCoroutine(closing());
		}
	}

	private IEnumerator opening()
	{
		MonoBehaviour.print("you are opening the door");
		openandclose.Play("Opening");
		open = true;
		yield return new WaitForSeconds(0.5f);
	}

	private IEnumerator closing()
	{
		MonoBehaviour.print("you are closing the door");
		openandclose.Play("Closing");
		open = false;
		yield return new WaitForSeconds(0.5f);
	}
}
public class opencloseDoor1 : MonoBehaviour
{
	public Animator openandclose1;

	public bool open;

	public Transform Player;

	private void Start()
	{
		open = false;
	}

	private void OnMouseOver()
	{
		if (!Player || !(Vector3.Distance(Player.position, base.transform.position) < 15f))
		{
			return;
		}
		if (!open)
		{
			if (Input.GetMouseButtonDown(0))
			{
				StartCoroutine(opening());
			}
		}
		else if (open && Input.GetMouseButtonDown(0))
		{
			StartCoroutine(closing());
		}
	}

	private IEnumerator opening()
	{
		MonoBehaviour.print("you are opening the door");
		openandclose1.Play("Opening 1");
		open = true;
		yield return new WaitForSeconds(0.5f);
	}

	private IEnumerator closing()
	{
		MonoBehaviour.print("you are closing the door");
		openandclose1.Play("Closing 1");
		open = false;
		yield return new WaitForSeconds(0.5f);
	}
}
public class Drawer_Pull_X : MonoBehaviour
{
	public Animator pull_01;

	public bool open;

	public Transform Player;

	private void Start()
	{
		open = false;
	}

	private void OnMouseOver()
	{
		if (!Player || !(Vector3.Distance(Player.position, base.transform.position) < 10f))
		{
			return;
		}
		MonoBehaviour.print("object name");
		if (!open)
		{
			if (Input.GetMouseButtonDown(0))
			{
				StartCoroutine(opening());
			}
		}
		else if (open && Input.GetMouseButtonDown(0))
		{
			StartCoroutine(closing());
		}
	}

	private IEnumerator opening()
	{
		MonoBehaviour.print("you are opening the door");
		pull_01.Play("openpull_01");
		open = true;
		yield return new WaitForSeconds(0.5f);
	}

	private IEnumerator closing()
	{
		MonoBehaviour.print("you are closing the door");
		pull_01.Play("closepush_01");
		open = false;
		yield return new WaitForSeconds(0.5f);
	}
}
public class Drawer_Pull_Z : MonoBehaviour
{
	public Animator pull;

	public bool open;

	public Transform Player;

	private void Start()
	{
		open = false;
	}

	private void OnMouseOver()
	{
		if (!Player || !(Vector3.Distance(Player.position, base.transform.position) < 10f))
		{
			return;
		}
		MonoBehaviour.print("object name");
		if (!open)
		{
			if (Input.GetMouseButtonDown(0))
			{
				StartCoroutine(opening());
			}
		}
		else if (open && Input.GetMouseButtonDown(0))
		{
			StartCoroutine(closing());
		}
	}

	private IEnumerator opening()
	{
		MonoBehaviour.print("you are opening the door");
		pull.Play("openpull");
		open = true;
		yield return new WaitForSeconds(0.5f);
	}

	private IEnumerator closing()
	{
		MonoBehaviour.print("you are closing the door");
		pull.Play("closepush");
		open = false;
		yield return new WaitForSeconds(0.5f);
	}
}
public class opencloseWindow1 : MonoBehaviour
{
	public Animator openandclosewindow1;

	public bool open;

	public Transform Player;

	private void Start()
	{
		open = false;
	}

	private void OnMouseOver()
	{
		if (!Player || !(Vector3.Distance(Player.position, base.transform.position) < 15f))
		{
			return;
		}
		if (!open)
		{
			if (Input.GetMouseButtonDown(0))
			{
				StartCoroutine(opening());
			}
		}
		else if (open && Input.GetMouseButtonDown(0))
		{
			StartCoroutine(closing());
		}
	}

	private IEnumerator opening()
	{
		MonoBehaviour.print("you are opening the Window");
		openandclosewindow1.Play("Openingwindow 1");
		open = true;
		yield return new WaitForSeconds(0.5f);
	}

	private IEnumerator closing()
	{
		MonoBehaviour.print("you are closing the Window");
		openandclosewindow1.Play("Closingwindow 1");
		open = false;
		yield return new WaitForSeconds(0.5f);
	}
}
public class CameraFreeflight : MonoBehaviour
{
	public float speedNormal = 10f;

	public float speedFast = 50f;

	public float mouseSensitivityX = 5f;

	public float mouseSensitivityY = 5f;

	private float rotY;

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void Update()
	{
		if (Input.GetMouseButton(1))
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * mouseSensitivityX;
			rotY += Input.GetAxis("Mouse Y") * mouseSensitivityY;
			rotY = Mathf.Clamp(rotY, -89.5f, 89.5f);
			base.transform.localEulerAngles = new Vector3(0f - rotY, y, 0f);
		}
		float axis = Input.GetAxis("Vertical");
		float axis2 = Input.GetAxis("Horizontal");
		if (axis != 0f)
		{
			float num = (Input.GetKey(KeyCode.LeftShift) ? speedFast : speedNormal);
			Vector3 vector = new Vector3(0f, 0f, axis * num * Time.deltaTime);
			base.gameObject.transform.localPosition += base.gameObject.transform.localRotation * vector;
		}
		if (axis2 != 0f)
		{
			float num2 = (Input.GetKey(KeyCode.LeftShift) ? speedFast : speedNormal);
			Vector3 vector2 = new Vector3(axis2 * num2 * Time.deltaTime, 0f, 0f);
			base.gameObject.transform.localPosition += base.gameObject.transform.localRotation * vector2;
		}
	}
}
public class EpiShowcase : MonoBehaviour
{
	[Header("General Setup")]
	public GameObject[] showcaseObjects;

	public KeyCode nextKey = KeyCode.D;

	public KeyCode prevKey = KeyCode.A;

	[Header("Camera Rotation - Optional")]
	public bool useObjectRotation;

	public GameObject rotationObject;

	public float rotationSpeed;

	private int index;

	private void Update()
	{
		if (useObjectRotation)
		{
			rotationObject.transform.Rotate(Vector3.up, rotationSpeed);
		}
		if (Input.GetKeyDown(nextKey))
		{
			showcaseObjects[index].SetActive(value: false);
			index++;
			if (index >= showcaseObjects.Length)
			{
				index = 0;
			}
			showcaseObjects[index].SetActive(value: true);
		}
		if (Input.GetKeyDown(prevKey))
		{
			showcaseObjects[index].SetActive(value: false);
			index--;
			if (index < 0)
			{
				index = showcaseObjects.Length - 1;
			}
			showcaseObjects[index].SetActive(value: true);
		}
	}
}
public class NextPrefab : MonoBehaviour
{
	public GameObject[] m_PrefabList;

	private int m_CurrentElementIndex = -1;

	private int m_CurrentParticleIndex = -1;

	private GameObject[] m_CurrentElementList;

	private GameObject m_CurrentParticle;

	public Text m_ParticleName;

	private void Start()
	{
		if (m_PrefabList.Length != 0)
		{
			m_CurrentElementIndex = 0;
			m_CurrentParticleIndex = 0;
			ShowParticle();
		}
	}

	private void Update()
	{
		if (m_CurrentElementIndex != -1 && m_CurrentParticleIndex != -1)
		{
			if (Input.GetKeyUp(KeyCode.Z))
			{
				m_CurrentParticleIndex--;
				ShowParticle();
			}
			else if (Input.GetKeyUp(KeyCode.X))
			{
				m_CurrentParticleIndex++;
				ShowParticle();
			}
		}
	}

	private void ShowParticle()
	{
		if (m_CurrentElementIndex == 0)
		{
			m_CurrentElementList = m_PrefabList;
		}
		if (m_CurrentParticleIndex >= m_CurrentElementList.Length)
		{
			m_CurrentParticleIndex = 0;
		}
		else if (m_CurrentParticleIndex < 0)
		{
			m_CurrentParticleIndex = m_CurrentElementList.Length - 1;
		}
		m_ParticleName.text = m_CurrentElementList[m_CurrentParticleIndex].name;
		if (m_CurrentParticle != null)
		{
			UnityEngine.Object.Destroy(m_CurrentParticle);
		}
		m_CurrentParticle = UnityEngine.Object.Instantiate(m_CurrentElementList[m_CurrentParticleIndex]);
	}
}
public class Rotation : MonoBehaviour
{
	[Range(-1f, 1f)]
	public float xForceDirection;

	[Range(-1f, 1f)]
	public float yForceDirection;

	[Range(-1f, 1f)]
	public float zForceDirection;

	public float speedMultiplier = 1f;

	public bool worldPivote;

	private Space spacePivot = Space.Self;

	private void Start()
	{
		if (worldPivote)
		{
			spacePivot = Space.World;
		}
	}

	private void Update()
	{
		base.transform.Rotate(xForceDirection * speedMultiplier, yForceDirection * speedMultiplier, zForceDirection * speedMultiplier, spacePivot);
	}
}
public class UserCamera : MonoBehaviour
{
	public Transform target;

	public float targetHeight = 1.7f;

	public float distance = 12f;

	public float offsetFromWall = 0.1f;

	public float maxDistance = 20f;

	public float minDistance = 0.6f;

	public float xSpeed = 200f;

	public float ySpeed = 200f;

	public float yMinLimit = -80f;

	public float yMaxLimit = 80f;

	public float zoomRate = 40f;

	public float rotationDampening = 3f;

	public float zoomDampening = 5f;

	private LayerMask collisionLayers = -1;

	public bool lockToRearOfTarget;

	public bool allowMouseInputX = true;

	public bool allowMouseInputY = true;

	private float xDeg;

	private float yDeg;

	private float currentDistance;

	public float desiredDistance;

	private float correctedDistance;

	public GameObject userModel;

	public bool inFirstPerson;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		xDeg = eulerAngles.x;
		yDeg = eulerAngles.y;
		currentDistance = distance;
		desiredDistance = distance;
		correctedDistance = distance;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void Update()
	{
		if (Input.GetAxis("Mouse ScrollWheel") < 0f && inFirstPerson)
		{
			minDistance = 10f;
			desiredDistance = 15f;
			userModel.SetActive(value: true);
			inFirstPerson = false;
		}
		if (desiredDistance == 10f)
		{
			minDistance = 0f;
			desiredDistance = 0f;
			userModel.SetActive(value: false);
			inFirstPerson = true;
		}
	}

	private void LateUpdate()
	{
		if (!target)
		{
			return;
		}
		if (GUIUtility.hotControl == 0 && !Input.GetKey(KeyCode.LeftControl) && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			if (allowMouseInputX)
			{
				xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			}
			if (allowMouseInputY)
			{
				yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			}
		}
		ClampAngle(yDeg);
		Quaternion quaternion = Quaternion.Euler(yDeg, xDeg, 0f);
		desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * zoomRate * Mathf.Abs(desiredDistance);
		desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
		correctedDistance = desiredDistance;
		Vector3 vector = new Vector3(0f, 0f - targetHeight, 0f);
		Vector3 end = target.position - (quaternion * Vector3.forward * desiredDistance + vector);
		Vector3 vector2 = new Vector3(target.position.x, target.position.y + targetHeight, target.position.z);
		bool flag = false;
		if (Physics.Linecast(vector2, end, out var hitInfo, collisionLayers))
		{
			correctedDistance = Vector3.Distance(vector2, hitInfo.point) - offsetFromWall;
			flag = true;
		}
		currentDistance = ((!flag || correctedDistance > currentDistance) ? Mathf.Lerp(currentDistance, correctedDistance, Time.deltaTime * zoomDampening) : correctedDistance);
		currentDistance = Mathf.Clamp(currentDistance, minDistance, maxDistance);
		end = target.position - (quaternion * Vector3.forward * currentDistance + vector);
		base.transform.rotation = quaternion;
		base.transform.position = end;
	}

	private void ClampAngle(float angle)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		yDeg = Mathf.Clamp(angle, -60f, 80f);
	}
}
public class Consumer : MonoBehaviour
{
	private GameObject[] portions;

	private int currentIndex;

	private float lastChange;

	private float interval = 1f;

	private void Start()
	{
		bool flag = base.transform.childCount > 4;
		portions = new GameObject[flag ? (base.transform.childCount - 1) : base.transform.childCount];
		for (int i = 0; i < portions.Length; i++)
		{
			portions[i] = base.transform.GetChild(flag ? (i + 1) : i).gameObject;
			if (portions[i].activeInHierarchy)
			{
				currentIndex = i;
			}
		}
	}

	private void Update()
	{
		if (Time.time - lastChange > interval)
		{
			Consume();
			lastChange = Time.time;
		}
	}

	private void Consume()
	{
		if (currentIndex != portions.Length)
		{
			portions[currentIndex].SetActive(value: false);
		}
		currentIndex++;
		if (currentIndex > portions.Length)
		{
			currentIndex = 0;
		}
		else if (currentIndex == portions.Length)
		{
			return;
		}
		portions[currentIndex].SetActive(value: true);
	}
}
public class Rotator : MonoBehaviour
{
	private Transform[] weapons;

	private float rotateSpeed = 100f;

	private void Start()
	{
		weapons = new Transform[base.transform.childCount];
		for (int i = 0; i < weapons.Length; i++)
		{
			weapons[i] = base.transform.GetChild(i);
		}
	}

	private void Update()
	{
		for (int i = 0; i < weapons.Length; i++)
		{
			weapons[i].Rotate(Vector3.up * Time.deltaTime * rotateSpeed, Space.World);
		}
	}
}
public class FreeCamera : MonoBehaviour
{
	public bool enableInputCapture = true;

	public bool holdRightMouseCapture;

	public float lookSpeed = 5f;

	public float moveSpeed = 5f;

	public float sprintSpeed = 50f;

	private bool m_inputCaptured;

	private float m_yaw;

	private float m_pitch;

	private void Awake()
	{
		base.enabled = enableInputCapture;
	}

	private void OnValidate()
	{
		if (Application.isPlaying)
		{
			base.enabled = enableInputCapture;
		}
	}

	private void CaptureInput()
	{
		Cursor.lockState = CursorLockMode.Locked;
		Cursor.visible = false;
		m_inputCaptured = true;
		m_yaw = base.transform.eulerAngles.y;
		m_pitch = base.transform.eulerAngles.x;
	}

	private void ReleaseInput()
	{
		Cursor.lockState = CursorLockMode.None;
		Cursor.visible = true;
		m_inputCaptured = false;
	}

	private void OnApplicationFocus(bool focus)
	{
		if (m_inputCaptured && !focus)
		{
			ReleaseInput();
		}
	}

	private void Update()
	{
		if (!m_inputCaptured)
		{
			if (!holdRightMouseCapture && Input.GetMouseButtonDown(0))
			{
				CaptureInput();
			}
			else if (holdRightMouseCapture && Input.GetMouseButtonDown(1))
			{
				CaptureInput();
			}
		}
		if (!m_inputCaptured)
		{
			return;
		}
		if (m_inputCaptured)
		{
			if (!holdRightMouseCapture && Input.GetKeyDown(KeyCode.Escape))
			{
				ReleaseInput();
			}
			else if (holdRightMouseCapture && Input.GetMouseButtonUp(1))
			{
				ReleaseInput();
			}
		}
		float axis = Input.GetAxis("Mouse X");
		float axis2 = Input.GetAxis("Mouse Y");
		m_yaw = (m_yaw + lookSpeed * axis) % 360f;
		m_pitch = (m_pitch - lookSpeed * axis2) % 360f;
		base.transform.rotation = Quaternion.AngleAxis(m_yaw, Vector3.up) * Quaternion.AngleAxis(m_pitch, Vector3.right);
		float num = Time.deltaTime * (Input.GetKey(KeyCode.LeftShift) ? sprintSpeed : moveSpeed);
		float num2 = num * Input.GetAxis("Vertical");
		float num3 = num * Input.GetAxis("Horizontal");
		float num4 = num * ((Input.GetKey(KeyCode.E) ? 1f : 0f) - (Input.GetKey(KeyCode.Q) ? 1f : 0f));
		base.transform.position += base.transform.forward * num2 + base.transform.right * num3 + Vector3.up * num4;
	}
}
public class JetPack : MonoBehaviour
{
	[Header("Jetpack")]
	public string axisName;

	public string speedAxisName;

	public string otherAxisName;

	public int picoControllerID;

	public int picoOtherControllerID;

	public Rigidbody _rigidbody;

	public Transform target;

	public float rocketModifier = -1f;

	public float upwardMultiplier = 1f;

	public float boosterStrength = 5f;

	private bool fly;

	private bool doubleFly;

	[HideInInspector]
	public bool speedFly;

	private AudioSource audio;

	private void Start()
	{
		audio = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (Controller.UPvr_GetKey(picoControllerID, Pvr_KeyCode.TRIGGER))
		{
			audio.volume = 0.2f;
			fly = true;
			if (Controller.UPvr_GetKey(picoControllerID, Pvr_KeyCode.TOUCHPAD) || Controller.UPvr_GetKey(picoControllerID, Pvr_KeyCode.Left) || Controller.UPvr_GetKey(picoControllerID, Pvr_KeyCode.Right))
			{
				speedFly = true;
			}
			else
			{
				speedFly = false;
			}
		}
		else
		{
			audio.volume = 0f;
			fly = false;
			speedFly = false;
		}
		if (_rigidbody.GetComponent<Player>().currentBurst <= 0f)
		{
			speedFly = false;
		}
		if (Controller.UPvr_GetKey(picoOtherControllerID, Pvr_KeyCode.TRIGGER))
		{
			doubleFly = true;
		}
		else
		{
			doubleFly = false;
		}
		if (fly)
		{
			GetComponentInChildren<ParticleSystem>().Play();
		}
		else
		{
			GetComponentInChildren<ParticleSystem>().Stop();
		}
	}

	private void FixedUpdate()
	{
		float num = 1f;
		if (speedFly)
		{
			num = boosterStrength;
		}
		if (doubleFly)
		{
			num *= 0.75f;
		}
		if (fly)
		{
			Vector3 force = Vector3.up * upwardMultiplier + target.forward * rocketModifier * num;
			_rigidbody.AddForce(force);
		}
	}
}
public class Player : MonoBehaviour
{
	public enum MenuState
	{
		Normal,
		InMenu
	}

	[HideInInspector]
	public int level;

	public float maxSpeed = 10f;

	public float maxBurst = 100f;

	public float maxHeight = 100f;

	public float burstCounterSpeed = 1f;

	[ReadOnly]
	public float burstLevel = 5f;

	public JetPack jetpackL;

	public JetPack jetpackR;

	public Image speedImage;

	public Text speedText;

	public Image boostImage;

	public Text boostText;

	public Image heightImage;

	public Text heightText;

	public float heightOffset;

	public Text moneyText;

	private Rigidbody _rigidbody;

	[HideInInspector]
	public float currentBurst;

	[HideInInspector]
	public bool speedFly;

	[HideInInspector]
	public TriggerActivator currentActivator;

	private bool boostCooldown;

	private MenuState menuState;

	public GameObject menuB;

	public GameObject menuX;

	public GameObject menuY;

	[HideInInspector]
	public bool inMission;

	[HideInInspector]
	public Mission mission;

	private bool loading;

	private void Start()
	{
		_rigidbody = GetComponent<Rigidbody>();
		menuState = MenuState.Normal;
	}

	private void Update()
	{
		if (loading)
		{
			return;
		}
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A) && currentActivator != null)
		{
			UnityEngine.Debug.LogError("Activator Button!");
			currentActivator.Activate();
		}
		if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y))
		{
			if (menuState == MenuState.Normal)
			{
				menuState = MenuState.InMenu;
				menuB.SetActive(value: true);
				menuY.SetActive(value: true);
				if (inMission)
				{
					menuX.SetActive(value: true);
				}
			}
			else if (menuState == MenuState.InMenu)
			{
				menuState = MenuState.Normal;
				menuB.SetActive(value: false);
				menuX.SetActive(value: false);
				menuY.SetActive(value: false);
			}
		}
		else
		{
			if (menuState != MenuState.InMenu)
			{
				return;
			}
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B))
			{
				UnityEngine.Debug.LogError("PRESS B");
				UnityEngine.Debug.LogError("Mission Button!");
				loading = true;
				SceneManager.LoadSceneAsync(0);
			}
			if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X))
			{
				UnityEngine.Debug.LogError("PRESS X");
				if (mission != null)
				{
					mission.Finish();
				}
			}
		}
	}

	private void FixedUpdate()
	{
		speedFly = false;
		if (!boostCooldown)
		{
			if (jetpackL.speedFly || jetpackR.speedFly)
			{
				currentBurst -= burstCounterSpeed * Time.deltaTime * 2f;
				if (currentBurst > 0f)
				{
					speedFly = true;
				}
				else
				{
					boostCooldown = true;
					Invoke("ResetCooldown", 5f - (float)level * 0.4f);
				}
			}
			else
			{
				currentBurst += burstCounterSpeed * Time.deltaTime;
				if (currentBurst > maxBurst)
				{
					currentBurst = maxBurst;
				}
			}
		}
		if (_rigidbody.velocity.magnitude > maxSpeed)
		{
			float num = maxSpeed;
			if (speedFly)
			{
				num *= 1f + burstLevel * 0.05f;
			}
			_rigidbody.velocity = Vector3.ClampMagnitude(_rigidbody.velocity, num);
		}
		if (_rigidbody.velocity.y > 0f)
		{
			if (base.gameObject.transform.position.y + heightOffset > maxHeight * 2f)
			{
				_rigidbody.velocity = new Vector3(_rigidbody.velocity.x, 0f, _rigidbody.velocity.z);
			}
			if (base.gameObject.transform.position.y + heightOffset > maxHeight)
			{
				_rigidbody.velocity = new Vector3(_rigidbody.velocity.x, _rigidbody.velocity.y * (2f - base.gameObject.transform.position.y / (maxHeight - heightOffset)), _rigidbody.velocity.z);
			}
		}
		heightText.color = Color.Lerp(Color.red, Color.white, 1.8f - base.gameObject.transform.position.y / (maxHeight - heightOffset));
		string translation = LocalizationManager.GetTranslation("ui53");
		string translation2 = LocalizationManager.GetTranslation("Controls4");
		string translation3 = LocalizationManager.GetTranslation("ui23");
		speedText.text = translation + " " + (int)(_rigidbody.velocity.magnitude * 10f);
		speedImage.fillAmount = _rigidbody.velocity.magnitude / (maxSpeed * (1f + burstLevel * 0.05f));
		boostText.text = translation2 + " " + (int)currentBurst;
		boostImage.fillAmount = currentBurst / maxBurst;
		heightText.text = translation3 + " " + (int)(base.gameObject.transform.position.y + heightOffset);
		heightImage.fillAmount = (base.gameObject.transform.position.y + heightOffset) / (maxHeight * 1.5f);
	}

	public void ResetCooldown()
	{
		boostCooldown = false;
	}
}
public class CausticDecal : MonoBehaviour
{
	public float maxAngle = 90f;

	public float pushDistance = 0.009f;

	public LayerMask affectedLayers = -1;

	private void OnDrawGizmosSelected()
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
	}

	public Bounds GetBounds()
	{
		Vector3 lossyScale = base.transform.lossyScale;
		Vector3 vector = -lossyScale / 2f;
		Vector3 vector2 = lossyScale / 2f;
		Vector3[] array = new Vector3[8]
		{
			new Vector3(vector.x, vector.y, vector.z),
			new Vector3(vector2.x, vector.y, vector.z),
			new Vector3(vector.x, vector2.y, vector.z),
			new Vector3(vector2.x, vector2.y, vector.z),
			new Vector3(vector.x, vector.y, vector2.z),
			new Vector3(vector2.x, vector.y, vector2.z),
			new Vector3(vector.x, vector2.y, vector2.z),
			new Vector3(vector2.x, vector2.y, vector2.z)
		};
		for (int i = 0; i < 8; i++)
		{
			array[i] = base.transform.TransformDirection(array[i]);
		}
		vector = (vector2 = array[0]);
		Vector3[] array2 = array;
		foreach (Vector3 rhs in array2)
		{
			vector = Vector3.Min(vector, rhs);
			vector2 = Vector3.Max(vector2, rhs);
		}
		return new Bounds(base.transform.position, vector2 - vector);
	}
}
public class BoatSimulator : MonoBehaviour
{
	private Rigidbody rigid;

	private bool keyPressedW;

	private bool keyPressedA;

	private bool keyPressedS;

	private bool keyPressedD;

	private void Start()
	{
		rigid = GetComponent<Rigidbody>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.W))
		{
			keyPressedW = true;
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			keyPressedA = true;
		}
		if (Input.GetKeyDown(KeyCode.S))
		{
			keyPressedS = true;
		}
		if (Input.GetKeyDown(KeyCode.D))
		{
			keyPressedD = true;
		}
		if (Input.GetKeyUp(KeyCode.W))
		{
			keyPressedW = false;
		}
		if (Input.GetKeyUp(KeyCode.A))
		{
			keyPressedA = false;
		}
		if (Input.GetKeyUp(KeyCode.S))
		{
			keyPressedS = false;
		}
		if (Input.GetKeyUp(KeyCode.D))
		{
			keyPressedD = false;
		}
		if (keyPressedW)
		{
			rigid.AddForce(base.transform.right * 500f * Time.deltaTime);
		}
		if (keyPressedS)
		{
			rigid.AddForce(-base.transform.right * 500f * Time.deltaTime);
		}
		if (keyPressedD)
		{
			rigid.AddTorque(base.transform.up * 200f * Time.deltaTime);
		}
		if (keyPressedA)
		{
			rigid.AddTorque(-base.transform.up * 200f * Time.deltaTime);
		}
	}
}
public class CubeGenerator : MonoBehaviour
{
	public GameObject cubes;

	private void Start()
	{
		InvokeRepeating("UpdateCube", 1f, 2f);
	}

	private void UpdateCube()
	{
		Vector3 position = base.transform.position;
		position.y += 10f;
		position.z -= 4f;
		position += UnityEngine.Random.insideUnitSphere * 7f;
		GameObject obj = UnityEngine.Object.Instantiate(cubes, position, Quaternion.Euler(UnityEngine.Random.Range(0, 360), UnityEngine.Random.Range(0, 360), UnityEngine.Random.Range(0, 360)));
		obj.AddComponent<Buoyancy>().Density = UnityEngine.Random.Range(700, 850);
		obj.AddComponent<Rigidbody>().mass = UnityEngine.Random.Range(100, 150);
		UnityEngine.Object.Destroy(obj, 30f);
	}
}
public class DemoGUIWater : MonoBehaviour
{
	public float UpdateInterval = 0.5f;

	public int MaxScenes = 2;

	public bool IsMobileScene;

	public Light Sun;

	public GameObject SunTransform;

	public GameObject Boat;

	public GameObject water1;

	public GameObject water2;

	public float angle = 130f;

	private bool canUpdateTestMaterial;

	private GameObject cam;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private Material currentWaterMaterial;

	private Material causticMaterial;

	private GameObject currentWater;

	private float transparent;

	private float fadeBlend;

	private float refl;

	private float refraction;

	private float waterWaveScaleXZ = 1f;

	private Vector4 waterDirection;

	private Vector4 causticDirection;

	private Vector4 foamDirection;

	private Vector4 ABDirection;

	private Vector4 CDDirection;

	private float direction = 1f;

	private Color reflectionColor;

	private Vector3 oldCausticScale;

	private float oldTextureScale;

	private float oldWaveScale;

	private GameObject caustic;

	private float startSunIntencity;

	private void Start()
	{
		guiStyleHeader.fontSize = 18;
		guiStyleHeader.normal.textColor = new Color(1f, 0f, 0f);
		UpdateCurrentWater();
	}

	private void UpdateCurrentWater()
	{
		if (Boat != null)
		{
			Boat.SetActive(value: false);
			Boat.SetActive(value: true);
		}
		startSunIntencity = Sun.intensity;
		currentWater = GameObject.Find("Water");
		currentWaterMaterial = currentWater.GetComponent<Renderer>().material;
		refl = currentWaterMaterial.GetColor("_ReflectionColor").r;
		if (!IsMobileScene)
		{
			transparent = currentWaterMaterial.GetFloat("_DepthTransperent");
		}
		if (!IsMobileScene)
		{
			fadeBlend = currentWaterMaterial.GetFloat("_FadeDepth");
		}
		refraction = currentWaterMaterial.GetFloat("_Distortion");
		oldTextureScale = currentWaterMaterial.GetFloat("_TexturesScale");
		oldWaveScale = currentWaterMaterial.GetFloat("_WaveScale");
		GameObject gameObject = GameObject.Find("InfiniteWaterMesh");
		if (gameObject != null)
		{
			gameObject.GetComponent<Renderer>().material = currentWaterMaterial;
		}
		GameObject gameObject2 = GameObject.Find("ProjectorCausticScale");
		if (gameObject2 != null)
		{
			oldCausticScale = gameObject2.transform.localScale;
		}
		caustic = GameObject.Find("Caustic");
		if (IsMobileScene)
		{
			caustic.SetActive(value: true);
		}
		if (!IsMobileScene)
		{
			causticMaterial = caustic.GetComponent<Projector>().material;
		}
		waterDirection = currentWaterMaterial.GetVector("_Direction");
		if (!IsMobileScene)
		{
			foamDirection = currentWaterMaterial.GetVector("_FoamDirection");
		}
		if (!IsMobileScene)
		{
			causticDirection = causticMaterial.GetVector("_CausticDirection");
		}
		ABDirection = currentWaterMaterial.GetVector("_GDirectionAB");
		CDDirection = currentWaterMaterial.GetVector("_GDirectionCD");
	}

	private void OnGUI()
	{
		if (IsMobileScene)
		{
			GUIMobile();
		}
		else
		{
			GUIPC();
		}
	}

	private void GUIMobile()
	{
		if (currentWaterMaterial == null)
		{
			return;
		}
		if (GUI.Button(new Rect(10f, 35f, 150f, 40f), "On/Off Ripples"))
		{
			caustic.SetActive(value: true);
			water1.SetActive(!water1.activeSelf);
			water2.SetActive(!water2.activeSelf);
			caustic = GameObject.Find("Caustic");
			if (IsMobileScene)
			{
				caustic.SetActive(value: true);
			}
		}
		if (GUI.Button(new Rect(10f, 190f, 150f, 40f), "On/Off caustic"))
		{
			caustic.SetActive(!caustic.activeSelf);
		}
		GUIStyle gUIStyle = new GUIStyle();
		gUIStyle.normal.textColor = new Color(1f, 1f, 1f);
		angle = GUI.HorizontalSlider(new Rect(10f, 102f, 120f, 15f), angle, 30f, 240f);
		GUI.Label(new Rect(140f, 100f, 30f, 30f), "Day Time", gUIStyle);
		float value = Mathf.Sin((angle - 60f) / 50f);
		Sun.intensity = Mathf.Clamp01(value) * startSunIntencity + 0.05f;
		SunTransform.transform.rotation = Quaternion.Euler(0f, 0f, angle);
		refl = GUI.HorizontalSlider(new Rect(10f, 122f, 120f, 15f), refl, 0f, 1f);
		reflectionColor = new Color(refl, refl, refl, 1f);
		GUI.Label(new Rect(140f, 120f, 30f, 30f), "Reflection", gUIStyle);
		currentWaterMaterial.SetColor("_ReflectionColor", reflectionColor);
		refraction = GUI.HorizontalSlider(new Rect(10f, 142f, 120f, 15f), refraction, 0f, 700f);
		GUI.Label(new Rect(140f, 140f, 30f, 30f), "Distortion", gUIStyle);
		currentWaterMaterial.SetFloat("_Distortion", refraction);
		waterWaveScaleXZ = GUI.HorizontalSlider(new Rect(10f, 162f, 120f, 15f), waterWaveScaleXZ, 0.3f, 3f);
		GUI.Label(new Rect(140f, 160f, 30f, 30f), "Scale", gUIStyle);
		currentWaterMaterial.SetFloat("_WaveScale", oldWaveScale * waterWaveScaleXZ);
		currentWaterMaterial.SetFloat("_TexturesScale", oldTextureScale * waterWaveScaleXZ);
	}

	private void GUIPC()
	{
		if (currentWaterMaterial == null)
		{
			return;
		}
		if (GUI.Button(new Rect(10f, 35f, 150f, 40f), "Change Scene "))
		{
			if (Application.loadedLevel == MaxScenes - 1)
			{
				Application.LoadLevel(0);
			}
			else
			{
				Application.LoadLevel(Application.loadedLevel + 1);
			}
			UpdateCurrentWater();
		}
		GUIStyle gUIStyle = new GUIStyle();
		gUIStyle.normal.textColor = new Color(1f, 1f, 1f);
		angle = GUI.HorizontalSlider(new Rect(10f, 102f, 120f, 15f), angle, 30f, 240f);
		GUI.Label(new Rect(140f, 100f, 30f, 30f), "Day Time", gUIStyle);
		float value = Mathf.Sin((angle - 60f) / 50f);
		Sun.intensity = Mathf.Clamp01(value) * startSunIntencity + 0.05f;
		SunTransform.transform.rotation = Quaternion.Euler(0f, 0f, angle);
		transparent = GUI.HorizontalSlider(new Rect(10f, 122f, 120f, 15f), transparent, 0f, 1f);
		GUI.Label(new Rect(140f, 120f, 30f, 30f), "Depth Transperent", gUIStyle);
		currentWaterMaterial.SetFloat("_DepthTransperent", transparent);
		fadeBlend = GUI.HorizontalSlider(new Rect(10f, 142f, 120f, 15f), fadeBlend, 0f, 1f);
		GUI.Label(new Rect(140f, 140f, 30f, 30f), "Fade Depth", gUIStyle);
		currentWaterMaterial.SetFloat("_FadeDepth", fadeBlend);
		refl = GUI.HorizontalSlider(new Rect(10f, 162f, 120f, 15f), refl, 0f, 1f);
		reflectionColor = new Color(refl, refl, refl, 1f);
		GUI.Label(new Rect(140f, 160f, 30f, 30f), "Reflection", gUIStyle);
		currentWaterMaterial.SetColor("_ReflectionColor", reflectionColor);
		refraction = GUI.HorizontalSlider(new Rect(10f, 182f, 120f, 15f), refraction, 0f, 700f);
		GUI.Label(new Rect(140f, 180f, 30f, 30f), "Distortion", gUIStyle);
		currentWaterMaterial.SetFloat("_Distortion", refraction);
		waterWaveScaleXZ = GUI.HorizontalSlider(new Rect(10f, 202f, 120f, 15f), waterWaveScaleXZ, 0.3f, 3f);
		GUI.Label(new Rect(140f, 200f, 30f, 30f), "Scale", gUIStyle);
		currentWaterMaterial.SetFloat("_WaveScale", oldWaveScale * waterWaveScaleXZ);
		currentWaterMaterial.SetFloat("_TexturesScale", oldTextureScale * waterWaveScaleXZ);
		GameObject gameObject = GameObject.Find("ProjectorCausticScale");
		Vector3 vector = oldCausticScale * waterWaveScaleXZ;
		if ((double)(gameObject.transform.localScale - vector).magnitude > 0.01)
		{
			gameObject.transform.localScale = vector;
			caustic.GetComponent<ProjectorMatrix>().UpdateMatrix();
		}
		direction = GUI.HorizontalSlider(new Rect(10f, 222f, 120f, 15f), direction, 1f, -1f);
		GUI.Label(new Rect(140f, 220f, 30f, 30f), "Direction", gUIStyle);
		currentWaterMaterial.SetVector("_Direction", waterDirection * direction);
		currentWaterMaterial.SetVector("_FoamDirection", foamDirection * direction);
		causticMaterial.SetVector("_CausticDirection", causticDirection * direction);
		currentWaterMaterial.SetVector("_GDirectionAB", ABDirection * direction);
		currentWaterMaterial.SetVector("_GDirectionCD", CDDirection * direction);
	}

	private void OnDestroy()
	{
		if (!IsMobileScene)
		{
			causticMaterial.SetVector("_CausticDirection", causticDirection);
		}
	}

	private void OnSetColorMain(Color color)
	{
		currentWaterMaterial.SetColor("_Color", color);
	}
}
public class FPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 0f, 0f);
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}
public class Buoyancy : MonoBehaviour
{
	public float Density = 700f;

	public int SlicesPerAxis = 2;

	public bool IsConcave;

	public int VoxelsLimit = 16;

	public float WaveVelocity = 0.05f;

	private const float Dampfer = 0.1f;

	private const float WaterDensity = 1000f;

	private float voxelHalfHeight;

	private float localArchimedesForce;

	private List<Vector3> voxels;

	private bool isMeshCollider;

	private List<Vector3[]> forces;

	private WaterRipples waterRipples;

	private void Start()
	{
		forces = new List<Vector3[]>();
		Quaternion rotation = base.transform.rotation;
		Vector3 position = base.transform.position;
		base.transform.rotation = Quaternion.identity;
		base.transform.position = Vector3.zero;
		if (GetComponent<Collider>() == null)
		{
			base.gameObject.AddComponent<MeshCollider>();
			UnityEngine.Debug.LogWarning($"[Buoyancy.cs] Object \"{base.name}\" had no collider. MeshCollider has been added.");
		}
		isMeshCollider = GetComponent<MeshCollider>() != null;
		Bounds bounds = GetComponent<Collider>().bounds;
		if (bounds.size.x < bounds.size.y)
		{
			voxelHalfHeight = bounds.size.x;
		}
		else
		{
			voxelHalfHeight = bounds.size.y;
		}
		if (bounds.size.z < voxelHalfHeight)
		{
			voxelHalfHeight = bounds.size.z;
		}
		voxelHalfHeight /= 2 * SlicesPerAxis;
		if (GetComponent<Rigidbody>() == null)
		{
			base.gameObject.AddComponent<Rigidbody>();
			UnityEngine.Debug.LogWarning($"[Buoyancy.cs] Object \"{base.name}\" had no Rigidbody. Rigidbody has been added.");
		}
		GetComponent<Rigidbody>().centerOfMass = new Vector3(0f, (0f - bounds.extents.y) * 0f, 0f) + base.transform.InverseTransformPoint(bounds.center);
		voxels = SliceIntoVoxels(isMeshCollider && IsConcave);
		base.transform.rotation = rotation;
		base.transform.position = position;
		float num = GetComponent<Rigidbody>().mass / Density;
		WeldPoints(voxels, VoxelsLimit);
		float num2 = 1000f * Mathf.Abs(Physics.gravity.y) * num;
		localArchimedesForce = num2 / (float)voxels.Count;
	}

	private List<Vector3> SliceIntoVoxels(bool concave)
	{
		List<Vector3> list = new List<Vector3>(SlicesPerAxis * SlicesPerAxis * SlicesPerAxis);
		if (concave)
		{
			MeshCollider component = GetComponent<MeshCollider>();
			bool convex = component.convex;
			component.convex = false;
			Bounds bounds = GetComponent<Collider>().bounds;
			for (int i = 0; i < SlicesPerAxis; i++)
			{
				for (int j = 0; j < SlicesPerAxis; j++)
				{
					for (int k = 0; k < SlicesPerAxis; k++)
					{
						float x = bounds.min.x + bounds.size.x / (float)SlicesPerAxis * (0.5f + (float)i);
						float y = bounds.min.y + bounds.size.y / (float)SlicesPerAxis * (0.5f + (float)j);
						float z = bounds.min.z + bounds.size.z / (float)SlicesPerAxis * (0.5f + (float)k);
						Vector3 vector = base.transform.InverseTransformPoint(new Vector3(x, y, z));
						if (PointIsInsideMeshCollider(component, vector))
						{
							list.Add(vector);
						}
					}
				}
			}
			if (list.Count == 0)
			{
				list.Add(bounds.center);
			}
			component.convex = convex;
		}
		else
		{
			Bounds bounds2 = GetComponent<Collider>().bounds;
			for (int l = 0; l < SlicesPerAxis; l++)
			{
				for (int m = 0; m < SlicesPerAxis; m++)
				{
					for (int n = 0; n < SlicesPerAxis; n++)
					{
						float x2 = bounds2.min.x + bounds2.size.x / (float)SlicesPerAxis * (0.5f + (float)l);
						float y2 = bounds2.min.y + bounds2.size.y / (float)SlicesPerAxis * (0.5f + (float)m);
						float z2 = bounds2.min.z + bounds2.size.z / (float)SlicesPerAxis * (0.5f + (float)n);
						Vector3 item = base.transform.InverseTransformPoint(new Vector3(x2, y2, z2));
						list.Add(item);
					}
				}
			}
		}
		return list;
	}

	private static bool PointIsInsideMeshCollider(Collider c, Vector3 p)
	{
		Vector3[] array = new Vector3[6]
		{
			Vector3.up,
			Vector3.down,
			Vector3.left,
			Vector3.right,
			Vector3.forward,
			Vector3.back
		};
		foreach (Vector3 vector in array)
		{
			if (!c.Raycast(new Ray(p - vector * 1000f, vector), out var _, 1000f))
			{
				return false;
			}
		}
		return true;
	}

	private static void FindClosestPoints(IList<Vector3> list, out int firstIndex, out int secondIndex)
	{
		float num = float.MaxValue;
		float num2 = float.MinValue;
		firstIndex = 0;
		secondIndex = 1;
		for (int i = 0; i < list.Count - 1; i++)
		{
			for (int j = i + 1; j < list.Count; j++)
			{
				float num3 = Vector3.Distance(list[i], list[j]);
				if (num3 < num)
				{
					num = num3;
					firstIndex = i;
					secondIndex = j;
				}
				if (num3 > num2)
				{
					num2 = num3;
				}
			}
		}
	}

	private static void WeldPoints(IList<Vector3> list, int targetCount)
	{
		if (list.Count > 2 && targetCount >= 2)
		{
			while (list.Count > targetCount)
			{
				FindClosestPoints(list, out var firstIndex, out var secondIndex);
				Vector3 item = (list[firstIndex] + list[secondIndex]) * 0.5f;
				list.RemoveAt(secondIndex);
				list.RemoveAt(firstIndex);
				list.Add(item);
			}
		}
	}

	private Vector3 GetNormal(Vector3 a, Vector3 b, Vector3 c)
	{
		Vector3 lhs = b - a;
		Vector3 rhs = c - a;
		return Vector3.Cross(lhs, rhs).normalized;
	}

	private void FixedUpdate()
	{
		if (waterRipples == null)
		{
			return;
		}
		forces.Clear();
		int count = voxels.Count;
		Vector3[] array = new Vector3[count];
		for (int i = 0; i < count; i++)
		{
			Vector3 position = base.transform.TransformPoint(voxels[i]);
			array[i] = waterRipples.GetOffsetByPosition(position);
		}
		Vector3 normalized = (GetNormal(array[0], array[1], array[2]) * WaveVelocity + Vector3.up).normalized;
		for (int j = 0; j < count; j++)
		{
			Vector3 vector = base.transform.TransformPoint(voxels[j]);
			float y = array[j].y;
			if (vector.y - voxelHalfHeight < y)
			{
				float num = (y - vector.y) / (2f * voxelHalfHeight) + 0.5f;
				if (num > 1f)
				{
					num = 1f;
				}
				else if (num < 0f)
				{
					num = 0f;
				}
				Vector3 vector2 = -GetComponent<Rigidbody>().GetPointVelocity(vector) * 0.1f * GetComponent<Rigidbody>().mass + Mathf.Sqrt(num) * (normalized * localArchimedesForce);
				GetComponent<Rigidbody>().AddForceAtPosition(vector2, vector);
				forces.Add(new Vector3[2] { vector, vector2 });
			}
		}
	}

	private void OnDrawGizmos()
	{
		if (voxels == null || forces == null)
		{
			return;
		}
		Gizmos.color = Color.yellow;
		foreach (Vector3 voxel in voxels)
		{
			Gizmos.DrawCube(base.transform.TransformPoint(voxel), new Vector3(0.05f, 0.05f, 0.05f));
		}
		Gizmos.color = Color.cyan;
		foreach (Vector3[] force in forces)
		{
			Gizmos.DrawCube(force[0], new Vector3(0.05f, 0.05f, 0.05f));
			Gizmos.DrawLine(force[0], force[0] + force[1] / GetComponent<Rigidbody>().mass);
		}
	}

	private void OnTriggerEnter(Collider collidedObj)
	{
		WaterRipples component = collidedObj.GetComponent<WaterRipples>();
		if (component != null)
		{
			waterRipples = component;
		}
	}

	private void OnEnable()
	{
		waterRipples = null;
	}
}
[ExecuteInEditMode]
public class DepthFix : MonoBehaviour
{
	private void OnWillRenderObject()
	{
		Camera.current.depthTextureMode |= DepthTextureMode.Depth;
	}
}
public class MoveCameraToCharacter : MonoBehaviour
{
	public GameObject Target;

	private void Update()
	{
		base.transform.position = Target.transform.position;
	}
}
public class MoveWaterToCamera : MonoBehaviour
{
	public GameObject CurrenCamera;

	private void Update()
	{
		if (!(CurrenCamera == null))
		{
			Vector3 position = base.transform.position;
			position.x = CurrenCamera.transform.position.x;
			position.z = CurrenCamera.transform.position.z;
			base.transform.position = position;
			Quaternion rotation = CurrenCamera.transform.rotation;
			rotation.eulerAngles = new Vector3(rotation.eulerAngles.x, 0f, rotation.eulerAngles.z);
		}
	}
}
[ExecuteInEditMode]
public class ProjectorMatrix : MonoBehaviour
{
	public enum matrixName
	{
		_projectiveMatrWaves,
		_projectiveMatrCausticScale
	}

	public matrixName GlobalMatrixName;

	public Transform ProjectiveTranform;

	public bool UpdateOnStart;

	public bool CanUpdate = true;

	private Transform t;

	private void Start()
	{
		t = base.transform;
		if (UpdateOnStart)
		{
			UpdateMatrix();
		}
	}

	private void Update()
	{
		if (!UpdateOnStart)
		{
			UpdateMatrix();
		}
	}

	public void UpdateMatrix()
	{
		if (CanUpdate)
		{
			Shader.SetGlobalMatrix(GlobalMatrixName.ToString(), ProjectiveTranform.worldToLocalMatrix * t.localToWorldMatrix);
		}
	}
}
public class ReflectionCamera : MonoBehaviour
{
	public LayerMask CullingMask = -17;

	public bool HDR;

	[Range(0.1f, 1f)]
	public float TextureScale = 1f;

	private RenderTexture reflectionTexture;

	private GameObject goCam;

	private Camera reflectionCamera;

	private Vector3 oldPos;

	private static float ClipPlaneOffset = 0.07f;

	private void UpdateCamera(Camera cam)
	{
		CheckCamera(cam);
		if (!(cam == null))
		{
			GL.invertCulling = true;
			Transform transform = base.transform;
			Vector3 eulerAngles = cam.transform.eulerAngles;
			reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
			reflectionCamera.transform.position = cam.transform.position;
			Vector3 position = transform.transform.position;
			position.y = transform.position.y;
			Vector3 up = transform.transform.up;
			float w = 0f - Vector3.Dot(up, position) - ClipPlaneOffset;
			Vector4 plane = new Vector4(up.x, up.y, up.z, w);
			Matrix4x4 zero = Matrix4x4.zero;
			zero = CalculateReflectionMatrix(zero, plane);
			oldPos = cam.transform.position;
			Vector3 position2 = zero.MultiplyPoint(oldPos);
			reflectionCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
			Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
			Matrix4x4 projectionMatrix = cam.projectionMatrix;
			projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
			reflectionCamera.projectionMatrix = projectionMatrix;
			reflectionCamera.transform.position = position2;
			Vector3 eulerAngles2 = cam.transform.eulerAngles;
			reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
			reflectionCamera.Render();
			GL.invertCulling = false;
		}
	}

	private void CheckCamera(Camera cam)
	{
		if (goCam == null)
		{
			reflectionTexture = new RenderTexture((int)((float)Screen.width * TextureScale), (int)((float)Screen.height * TextureScale), 16, RenderTextureFormat.Default);
			reflectionTexture.DiscardContents();
			goCam = new GameObject("Water Refl Camera");
			goCam.hideFlags = HideFlags.DontSave;
			goCam.transform.position = base.transform.position;
			goCam.transform.rotation = base.transform.rotation;
			reflectionCamera = goCam.AddComponent<Camera>();
			reflectionCamera.depth = cam.depth - 10f;
			reflectionCamera.renderingPath = cam.renderingPath;
			reflectionCamera.depthTextureMode = DepthTextureMode.None;
			reflectionCamera.cullingMask = CullingMask;
			reflectionCamera.allowHDR = HDR;
			reflectionCamera.useOcclusionCulling = false;
			reflectionCamera.enabled = false;
			reflectionCamera.targetTexture = reflectionTexture;
			Shader.SetGlobalTexture("_ReflectionTex", reflectionTexture);
		}
	}

	private static float Sgn(float a)
	{
		if (a > 0f)
		{
			return 1f;
		}
		if (a < 0f)
		{
			return -1f;
		}
		return 0f;
	}

	private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
	{
		Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
		Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
		projection[2] = vector.x - projection[3];
		projection[6] = vector.y - projection[7];
		projection[10] = vector.z - projection[11];
		projection[14] = vector.w - projection[15];
		return projection;
	}

	private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
		return reflectionMat;
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private void SafeDestroy<T>(T component) where T : UnityEngine.Object
	{
		if (!(component == null))
		{
			if (!Application.isPlaying)
			{
				UnityEngine.Object.DestroyImmediate(component);
			}
			else
			{
				UnityEngine.Object.Destroy(component);
			}
		}
	}

	private void ClearCamera()
	{
		if ((bool)goCam)
		{
			SafeDestroy(goCam);
			goCam = null;
		}
		if ((bool)reflectionTexture)
		{
			SafeDestroy(reflectionTexture);
			reflectionTexture = null;
		}
	}

	public void OnWillRenderObject()
	{
		UpdateCamera(Camera.main);
	}

	private void OnEnable()
	{
		Shader.EnableKeyword("cubeMap_off");
	}

	private void OnDisable()
	{
		ClearCamera();
		Shader.DisableKeyword("cubeMap_off");
	}
}
public class RippleCreator : MonoBehaviour
{
	private class ReversedRipple
	{
		public Vector3 Position;

		public float Velocity;
	}

	public bool IsReversedRipple;

	public float RippleStrenght = 0.1f;

	public float MaxVelocity = 1.5f;

	public float RandomRipplesInterval;

	public float reversedRippleDelay = 0.2f;

	public GameObject SplashEffect;

	public GameObject SplashEffectMoved;

	public AudioSource SplashAudioSource;

	private int fadeInVelocityLimit = 10;

	private int fadeInVelocity = 1;

	private WaterRipples waterRipples;

	private Vector3 oldPos;

	private float currentVelocity;

	private Transform t;

	private Queue<ReversedRipple> reversedVelocityQueue;

	private float triggeredTime;

	private bool canUpdate;

	private float randomRipplesCurrentTime;

	private bool canInstantiateRandomRipple;

	private GameObject splashMovedInstance;

	private ParticleSystem splashParticleSystem;

	public float splashSizeMultiplier = 2f;

	private void Start()
	{
		t = base.transform;
		reversedVelocityQueue = new Queue<ReversedRipple>();
	}

	private void FixedUpdate()
	{
		if (waterRipples == null)
		{
			return;
		}
		if (RandomRipplesInterval > 0.0001f && Time.time - randomRipplesCurrentTime > RandomRipplesInterval)
		{
			randomRipplesCurrentTime = Time.time;
			canInstantiateRandomRipple = true;
		}
		if (canUpdate)
		{
			currentVelocity = (t.position - oldPos).magnitude / Time.fixedDeltaTime * RippleStrenght;
			if (currentVelocity > MaxVelocity)
			{
				currentVelocity = MaxVelocity;
			}
			if (IsReversedRipple)
			{
				currentVelocity = 0f - currentVelocity;
			}
			reversedVelocityQueue.Enqueue(new ReversedRipple
			{
				Position = t.position,
				Velocity = (0f - currentVelocity) / (float)fadeInVelocity
			});
			oldPos = t.position;
			waterRipples.CreateRippleByPosition(t.position, currentVelocity / (float)fadeInVelocity);
			if (canInstantiateRandomRipple)
			{
				waterRipples.CreateRippleByPosition(t.position, UnityEngine.Random.Range(currentVelocity / 5f, currentVelocity));
			}
			UpdateMovedSplash();
		}
		if (Time.time - triggeredTime > reversedRippleDelay)
		{
			ReversedRipple reversedRipple = reversedVelocityQueue.Dequeue();
			if (IsReversedRipple)
			{
				reversedRipple.Velocity = 0f - reversedRipple.Velocity;
			}
			waterRipples.CreateRippleByPosition(reversedRipple.Position, reversedRipple.Velocity);
			if (canInstantiateRandomRipple)
			{
				waterRipples.CreateRippleByPosition(reversedRipple.Position, UnityEngine.Random.Range(reversedRipple.Velocity / 5f, reversedRipple.Velocity));
			}
		}
		fadeInVelocity++;
		if (fadeInVelocity > fadeInVelocityLimit)
		{
			fadeInVelocity = 1;
		}
		if (canInstantiateRandomRipple)
		{
			canInstantiateRandomRipple = false;
		}
	}

	private void OnTriggerEnter(Collider collidedObj)
	{
		WaterRipples component = collidedObj.GetComponent<WaterRipples>();
		if (component != null)
		{
			waterRipples = component;
			canUpdate = true;
			reversedVelocityQueue.Clear();
			triggeredTime = Time.time;
			fadeInVelocity = 1;
			if (SplashAudioSource != null)
			{
				SplashAudioSource.Play();
			}
			if (SplashEffect != null)
			{
				Vector3 offsetByPosition = waterRipples.GetOffsetByPosition(t.position);
				offsetByPosition.x = t.position.x;
				offsetByPosition.z = t.position.z;
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(SplashEffect, offsetByPosition, default(Quaternion)), 2f);
			}
			UpdateMovedSplash();
		}
	}

	private void UpdateMovedSplash()
	{
		if (splashMovedInstance != null)
		{
			Vector3 offsetByPosition = waterRipples.GetOffsetByPosition(t.position);
			offsetByPosition.x = t.position.x;
			offsetByPosition.z = t.position.z;
			splashMovedInstance.transform.position = offsetByPosition;
			splashParticleSystem.startSize = currentVelocity * splashSizeMultiplier;
		}
		else if (SplashEffectMoved != null)
		{
			splashMovedInstance = UnityEngine.Object.Instantiate(SplashEffectMoved, t.position, default(Quaternion));
			splashMovedInstance.transform.parent = waterRipples.transform;
			Vector3 offsetByPosition2 = waterRipples.GetOffsetByPosition(t.position);
			offsetByPosition2.x = t.position.x;
			offsetByPosition2.z = t.position.z;
			splashMovedInstance.transform.position = offsetByPosition2;
			splashParticleSystem = splashMovedInstance.GetComponentInChildren<ParticleSystem>();
			splashParticleSystem.startSize = currentVelocity * splashSizeMultiplier;
		}
	}

	private void OnEnable()
	{
		waterRipples = null;
		canUpdate = false;
		if (splashMovedInstance != null)
		{
			UnityEngine.Object.Destroy(splashMovedInstance);
		}
	}

	private void OnDisable()
	{
		if (splashMovedInstance != null)
		{
			UnityEngine.Object.Destroy(splashMovedInstance);
		}
	}

	private void OnDestroy()
	{
		if (splashMovedInstance != null)
		{
			UnityEngine.Object.Destroy(splashMovedInstance);
		}
	}
}
public class TextureScale
{
	public class ThreadData
	{
		public int start;

		public int end;

		public ThreadData(int s, int e)
		{
			start = s;
			end = e;
		}
	}

	private static Color[] texColors;

	private static Color[] newColors;

	private static int w;

	private static float ratioX;

	private static float ratioY;

	private static int w2;

	private static int finishCount;

	public static void Point(Texture2D tex, int newWidth, int newHeight)
	{
		ThreadedScale(tex, newWidth, newHeight, useBilinear: false);
	}

	public static void Bilinear(Texture2D tex, int newWidth, int newHeight)
	{
		ThreadedScale(tex, newWidth, newHeight, useBilinear: true);
	}

	private static void ThreadedScale(Texture2D tex, int newWidth, int newHeight, bool useBilinear)
	{
		texColors = tex.GetPixels();
		newColors = new Color[newWidth * newHeight];
		if (useBilinear)
		{
			ratioX = 1f / ((float)newWidth / (float)(tex.width - 1));
			ratioY = 1f / ((float)newHeight / (float)(tex.height - 1));
		}
		else
		{
			ratioX = (float)tex.width / (float)newWidth;
			ratioY = (float)tex.height / (float)newHeight;
		}
		w = tex.width;
		w2 = newWidth;
		ThreadData obj = new ThreadData(0, newHeight);
		if (useBilinear)
		{
			BilinearScale(obj);
		}
		else
		{
			PointScale(obj);
		}
		tex.Resize(newWidth, newHeight);
		tex.SetPixels(newColors);
		tex.Apply();
	}

	public static void BilinearScale(object obj)
	{
		ThreadData threadData = (ThreadData)obj;
		for (int i = threadData.start; i < threadData.end; i++)
		{
			int num = (int)Mathf.Floor((float)i * ratioY);
			int num2 = num * w;
			int num3 = (num + 1) * w;
			int num4 = i * w2;
			for (int j = 0; j < w2; j++)
			{
				int num5 = (int)Mathf.Floor((float)j * ratioX);
				float value = (float)j * ratioX - (float)num5;
				newColors[num4 + j] = ColorLerpUnclamped(ColorLerpUnclamped(texColors[num2 + num5], texColors[num2 + num5 + 1], value), ColorLerpUnclamped(texColors[num3 + num5], texColors[num3 + num5 + 1], value), (float)i * ratioY - (float)num);
			}
		}
		finishCount++;
	}

	public static void PointScale(object obj)
	{
		ThreadData threadData = (ThreadData)obj;
		for (int i = threadData.start; i < threadData.end; i++)
		{
			int num = (int)(ratioY * (float)i) * w;
			int num2 = i * w2;
			for (int j = 0; j < w2; j++)
			{
				newColors[num2 + j] = texColors[(int)((float)num + ratioX * (float)j)];
			}
		}
		finishCount++;
	}

	private static Color ColorLerpUnclamped(Color c1, Color c2, float value)
	{
		return new Color(c1.r + (c2.r - c1.r) * value, c1.g + (c2.g - c1.g) * value, c1.b + (c2.b - c1.b) * value, c1.a + (c2.a - c1.a) * value);
	}
}
public class Underwater : MonoBehaviour
{
	public float UnderwaterLevel;

	public Color FogColor = new Color(0f, 0.4f, 0.7f, 1f);

	public float FogDensity = 0.04f;

	public FogMode FogMode = FogMode.Exponential;

	private bool defaultFog;

	private Color defaultFogColor;

	private float defaultFogDensity;

	private FogMode defaultFogMod;

	private Material defaultSkybox;

	private void Start()
	{
		defaultFog = RenderSettings.fog;
		defaultFogColor = RenderSettings.fogColor;
		defaultFogDensity = RenderSettings.fogDensity;
		defaultFogMod = RenderSettings.fogMode;
	}

	private void Update()
	{
		if (base.transform.position.y < UnderwaterLevel)
		{
			RenderSettings.fog = true;
			RenderSettings.fogColor = FogColor;
			RenderSettings.fogDensity = FogDensity;
			RenderSettings.fogMode = FogMode;
		}
		else
		{
			RenderSettings.fog = defaultFog;
			RenderSettings.fogColor = defaultFogColor;
			RenderSettings.fogDensity = defaultFogDensity;
			RenderSettings.fogMode = defaultFogMod;
			RenderSettings.fogStartDistance = -300f;
		}
	}
}
public class UnderwaterPostEffects : MonoBehaviour
{
	public Color FogColor = new Color(29f / 85f, 38f / 51f, 73f / 85f, 1f);

	public float FogDensity = 0.05f;

	public bool UseSunShafts = true;

	public float ShuftsIntensity = 5f;

	public WFX_SunShafts.ShaftsScreenBlendMode SunShuftsScreenBlend;

	private Vector3 SunShaftTargetPosition = new Vector3(0f, 7f, 10f);

	private Camera cam;

	private WFX_SunShafts SunShafts;

	private void OnEnable()
	{
		cam = Camera.main;
		SunShafts = cam.gameObject.AddComponent<WFX_SunShafts>();
		SunShafts.sunShaftIntensity = ShuftsIntensity;
		GameObject gameObject = new GameObject("SunShaftTarget");
		SunShafts.sunTransform = gameObject.transform;
		gameObject.transform.parent = cam.transform;
		gameObject.transform.localPosition = SunShaftTargetPosition;
		SunShafts.screenBlendMode = SunShuftsScreenBlend;
		SunShafts.sunShaftsShader = Shader.Find("Hidden/SunShaftsComposite");
		SunShafts.simpleClearShader = Shader.Find("Hidden/SimpleClear");
		Underwater underwater = cam.gameObject.AddComponent<Underwater>();
		underwater.UnderwaterLevel = base.transform.position.y;
		underwater.FogColor = FogColor;
		underwater.FogDensity = FogDensity;
	}

	private void Update()
	{
		if (cam == null)
		{
			return;
		}
		if (cam.transform.position.y < base.transform.position.y)
		{
			if (!SunShafts.enabled)
			{
				SunShafts.enabled = true;
			}
		}
		else if (SunShafts.enabled)
		{
			SunShafts.enabled = false;
		}
	}
}
public class WFX_SunShafts : MonoBehaviour
{
	public enum SunShaftsResolution
	{
		Low,
		Normal,
		High
	}

	public enum ShaftsScreenBlendMode
	{
		Screen,
		Add
	}

	public SunShaftsResolution resolution = SunShaftsResolution.Normal;

	public ShaftsScreenBlendMode screenBlendMode;

	public Transform sunTransform;

	public int radialBlurIterations = 2;

	public Color sunColor = Color.white;

	public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

	public float sunShaftBlurRadius = 2.5f;

	public float sunShaftIntensity = 1.15f;

	public float maxRadius = 0.75f;

	public bool useDepthTexture = true;

	public Shader sunShaftsShader;

	private Material sunShaftsMaterial;

	public Shader simpleClearShader;

	private Material simpleClearMaterial;

	private bool supportHDRTextures = true;

	private bool supportDX11;

	private bool isSupported = true;

	private List<Material> createdMaterials = new List<Material>();

	protected void NotSupported()
	{
		base.enabled = false;
		isSupported = false;
	}

	private bool CheckSupport(bool needDepth)
	{
		isSupported = true;
		supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
		supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
		if (!SystemInfo.supportsImageEffects)
		{
			NotSupported();
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			NotSupported();
			return false;
		}
		if (needDepth)
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
		}
		return true;
	}

	protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
	{
		if (!s)
		{
			UnityEngine.Debug.Log("Missing shader in " + ToString());
			base.enabled = false;
			return null;
		}
		if (s.isSupported && (bool)m2Create && m2Create.shader == s)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			NotSupported();
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
			return null;
		}
		m2Create = new Material(s);
		createdMaterials.Add(m2Create);
		m2Create.hideFlags = HideFlags.DontSave;
		return m2Create;
	}

	protected void ReportAutoDisable()
	{
		UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
	}

	public bool CheckResources()
	{
		CheckSupport(useDepthTexture);
		sunShaftsShader = Shader.Find("Hidden/SunShaftsComposite");
		simpleClearShader = Shader.Find("Hidden/SimpleClear");
		sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
		simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
		if (!isSupported)
		{
			ReportAutoDisable();
		}
		return isSupported;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (!CheckResources())
		{
			Graphics.Blit(source, destination);
			return;
		}
		if (useDepthTexture)
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
		}
		int num = 4;
		if (resolution == SunShaftsResolution.Normal)
		{
			num = 2;
		}
		else if (resolution == SunShaftsResolution.High)
		{
			num = 1;
		}
		Vector3 vector = Vector3.one * 0.5f;
		vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
		int width = source.width / num;
		int height = source.height / num;
		RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
		sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
		sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
		sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
		if (!useDepthTexture)
		{
			RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
			GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
			sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
			Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
		else
		{
			Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
		}
		radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
		float num2 = sunShaftBlurRadius * 0.0013020834f;
		sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
		sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
		for (int i = 0; i < radialBlurIterations; i++)
		{
			RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
			Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
			RenderTexture.ReleaseTemporary(temporary);
			num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			temporary = RenderTexture.GetTemporary(width, height, 0);
			Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
			RenderTexture.ReleaseTemporary(temporary3);
			num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
		}
		if (vector.z >= 0f)
		{
			sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
		}
		else
		{
			sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
		}
		sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
		Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
		RenderTexture.ReleaseTemporary(temporary);
	}
}
public class WaterRipples : MonoBehaviour
{
	[Range(20f, 200f)]
	public int UpdateFPS = 30;

	public bool Multithreading = true;

	public int DisplacementResolution = 128;

	public float Damping = 0.005f;

	[Range(0.0001f, 2f)]
	public float Speed = 1.5f;

	public bool UseSmoothWaves;

	public bool UseProjectedWaves;

	public Texture2D CutOutTexture;

	private Transform t;

	private float textureColorMultiplier = 10f;

	private Texture2D displacementTexture;

	private Vector2[,] waveAcceleration;

	private Color[] col;

	private Vector3[] wavePoints;

	private Vector3 scaleBounds;

	private float inversedDamping;

	private float[] cutOutTextureGray;

	private bool cutOutTextureInitialized;

	private Thread thread;

	private bool canUpdate = true;

	private double threadDeltaTime;

	private DateTime oldDateTime;

	private Vector2 movedObjPos;

	private Vector2 projectorPosition;

	private Vector4 _GAmplitude;

	private Vector4 _GFrequency;

	private Vector4 _GSteepness;

	private Vector4 _GSpeed;

	private Vector4 _GDirectionAB;

	private Vector4 _GDirectionCD;

	private void OnEnable()
	{
		canUpdate = true;
		Shader.EnableKeyword("ripples_on");
		Renderer component = GetComponent<Renderer>();
		_GAmplitude = component.sharedMaterial.GetVector("_GAmplitude");
		_GFrequency = component.sharedMaterial.GetVector("_GFrequency");
		_GSteepness = component.sharedMaterial.GetVector("_GSteepness");
		_GSpeed = component.sharedMaterial.GetVector("_GSpeed");
		_GDirectionAB = component.sharedMaterial.GetVector("_GDirectionAB");
		_GDirectionCD = component.sharedMaterial.GetVector("_GDirectionCD");
		t = base.transform;
		scaleBounds = GetComponent<MeshRenderer>().bounds.size;
		InitializeRipple();
		if (Multithreading)
		{
			thread = new Thread(UpdateRipples);
			thread.Start();
		}
	}

	public Vector3 GetOffsetByPosition(Vector3 position)
	{
		Vector3 result = GerstnerOffset4(new Vector2(position.x, position.z), _GSteepness, _GAmplitude, _GFrequency, _GSpeed, _GDirectionAB, _GDirectionCD);
		result.y += GetTextureHeightByPosition(position.x, position.z);
		result.y += t.position.y;
		return result;
	}

	public void CreateRippleByPosition(Vector3 position, float velocity)
	{
		position.x += scaleBounds.x / 2f - t.position.x;
		position.z += scaleBounds.z / 2f - t.position.z;
		position.x /= scaleBounds.x;
		position.z /= scaleBounds.z;
		position.x *= DisplacementResolution;
		position.z *= DisplacementResolution;
		SetRippleTexture((int)position.x, (int)position.z, velocity);
	}

	private void InitializeRipple()
	{
		inversedDamping = 1f - Damping;
		displacementTexture = new Texture2D(DisplacementResolution, DisplacementResolution, TextureFormat.RGBA32, mipChain: false);
		displacementTexture.wrapMode = TextureWrapMode.Clamp;
		displacementTexture.filterMode = FilterMode.Bilinear;
		Shader.SetGlobalTexture("_WaterDisplacementTexture", displacementTexture);
		wavePoints = new Vector3[DisplacementResolution * DisplacementResolution];
		col = new Color[DisplacementResolution * DisplacementResolution];
		waveAcceleration = new Vector2[DisplacementResolution, DisplacementResolution];
		for (int i = 0; i < DisplacementResolution * DisplacementResolution; i++)
		{
			col[i] = new Color(0f, 0f, 0f);
			wavePoints[i] = new Vector3(0f, 0f);
		}
		for (int j = 0; j < DisplacementResolution; j++)
		{
			for (int k = 0; k < DisplacementResolution; k++)
			{
				waveAcceleration[j, k] = new Vector2(0f, 0f);
			}
		}
		if (CutOutTexture != null)
		{
			Color[] pixels = ScaleTexture(CutOutTexture, DisplacementResolution, DisplacementResolution).GetPixels();
			cutOutTextureGray = new float[DisplacementResolution * DisplacementResolution];
			for (int l = 0; l < pixels.Length; l++)
			{
				cutOutTextureGray[l] = pixels[l].r * 0.299f + pixels[l].g * 0.587f + pixels[l].b * 0.114f;
			}
			cutOutTextureInitialized = true;
		}
	}

	private Texture2D ScaleTexture(Texture2D source, int targetWidth, int targetHeight)
	{
		Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipChain: false);
		Color[] pixels = source.GetPixels();
		texture2D.SetPixels(pixels);
		TextureScale.Bilinear(texture2D, targetWidth, targetHeight);
		texture2D.Apply();
		return texture2D;
	}

	private void UpdateRipples()
	{
		oldDateTime = DateTime.UtcNow;
		while (canUpdate)
		{
			threadDeltaTime = (DateTime.UtcNow - oldDateTime).TotalMilliseconds / 1000.0;
			oldDateTime = DateTime.UtcNow;
			int num = (int)((double)(1000f / (float)UpdateFPS) - threadDeltaTime);
			if (num > 0)
			{
				Thread.Sleep(num);
			}
			RippleTextureRecalculate();
		}
	}

	private void FixedUpdate()
	{
		if (!Multithreading)
		{
			RippleTextureRecalculate();
		}
		displacementTexture.SetPixels(col);
		displacementTexture.Apply(updateMipmaps: false);
	}

	private void Update()
	{
		movedObjPos = new Vector2(t.position.x, t.position.z);
	}

	private void UpdateProjector()
	{
		int num = (int)((float)DisplacementResolution * movedObjPos.x / scaleBounds.x - projectorPosition.x);
		int num2 = (int)((float)DisplacementResolution * movedObjPos.y / scaleBounds.z - projectorPosition.y);
		projectorPosition.x += num;
		projectorPosition.y += num2;
		if (num == 0 && num2 == 0)
		{
			return;
		}
		if (num >= 0 && num2 >= 0)
		{
			for (int i = 1; i < DisplacementResolution; i++)
			{
				for (int j = 0; j < DisplacementResolution; j++)
				{
					if (i + num2 > 0 && i + num2 < DisplacementResolution && j + num > 0 && j + num < DisplacementResolution)
					{
						waveAcceleration[j, i] = waveAcceleration[j + num, i + num2];
						wavePoints[j + i * DisplacementResolution] = wavePoints[j + num + (i + num2) * DisplacementResolution];
					}
				}
			}
		}
		if (num >= 0 && num2 < 0)
		{
			for (int num3 = DisplacementResolution - 1; num3 >= 0; num3--)
			{
				for (int k = 0; k < DisplacementResolution; k++)
				{
					if (num3 + num2 > 0 && num3 + num2 < DisplacementResolution && k + num > 0 && k + num < DisplacementResolution)
					{
						waveAcceleration[k, num3] = waveAcceleration[k + num, num3 + num2];
						wavePoints[k + num3 * DisplacementResolution] = wavePoints[k + num + (num3 + num2) * DisplacementResolution];
					}
				}
			}
		}
		if (num < 0 && num2 >= 0)
		{
			for (int l = 0; l < DisplacementResolution; l++)
			{
				for (int num4 = DisplacementResolution - 1; num4 >= 0; num4--)
				{
					if (l + num2 > 0 && l + num2 < DisplacementResolution && num4 + num > 0 && num4 + num < DisplacementResolution)
					{
						waveAcceleration[num4, l] = waveAcceleration[num4 + num, l + num2];
						wavePoints[num4 + l * DisplacementResolution] = wavePoints[num4 + num + (l + num2) * DisplacementResolution];
					}
				}
			}
		}
		if (num < 0 && num2 < 0)
		{
			for (int num5 = DisplacementResolution - 1; num5 >= 0; num5--)
			{
				for (int num6 = DisplacementResolution - 1; num6 >= 0; num6--)
				{
					if (num5 + num2 > 0 && num5 + num2 < DisplacementResolution && num6 + num > 0 && num6 + num < DisplacementResolution)
					{
						waveAcceleration[num6, num5] = waveAcceleration[num6 + num, num5 + num2];
						wavePoints[num6 + num5 * DisplacementResolution] = wavePoints[num6 + num + (num5 + num2) * DisplacementResolution];
					}
				}
			}
		}
		Vector2 zero = Vector2.zero;
		for (int m = 0; m < DisplacementResolution; m++)
		{
			waveAcceleration[0, m] = zero;
			wavePoints[m * DisplacementResolution] = zero;
			waveAcceleration[DisplacementResolution - 1, m] = zero;
			wavePoints[DisplacementResolution - 1 + m * DisplacementResolution] = zero;
			waveAcceleration[m, 0] = zero;
			wavePoints[m] = zero;
			waveAcceleration[m, DisplacementResolution - 1] = zero;
			wavePoints[DisplacementResolution - 1 + m] = zero;
		}
	}

	private void OnDestroy()
	{
		canUpdate = false;
	}

	private void OnDisable()
	{
		Shader.DisableKeyword("ripples_on");
		canUpdate = false;
	}

	private void RippleTextureRecalculate()
	{
		if (UseProjectedWaves)
		{
			UpdateProjector();
		}
		int num = wavePoints.Length;
		int num2 = DisplacementResolution + 1;
		int num3 = DisplacementResolution - 2;
		int num4 = num - (DisplacementResolution + 1);
		for (int i = 0; i < num; i++)
		{
			if (i >= num2 && i < num4 && i % DisplacementResolution > 0)
			{
				int num5 = i % DisplacementResolution;
				int num6 = i / DisplacementResolution;
				float num7 = (wavePoints[i - 1].y + wavePoints[i + 1].y + wavePoints[i - DisplacementResolution].y + wavePoints[i + DisplacementResolution].y) / 4f;
				waveAcceleration[num5, num6].y += num7 - waveAcceleration[num5, num6].x;
			}
		}
		float num8 = Speed;
		if (!Multithreading)
		{
			num8 *= Time.fixedDeltaTime * (float)UpdateFPS;
		}
		for (int j = 0; j < DisplacementResolution; j++)
		{
			for (int k = 0; k < DisplacementResolution; k++)
			{
				waveAcceleration[k, j].x += waveAcceleration[k, j].y * num8;
				if (cutOutTextureInitialized)
				{
					waveAcceleration[k, j].x *= cutOutTextureGray[k + j * DisplacementResolution];
				}
				waveAcceleration[k, j].y *= inversedDamping;
				waveAcceleration[k, j].x *= inversedDamping;
				wavePoints[k + j * DisplacementResolution].y = waveAcceleration[k, j].x;
				if (!UseSmoothWaves)
				{
					float num9 = waveAcceleration[k, j].x * textureColorMultiplier;
					if (num9 >= 0f)
					{
						col[k + j * DisplacementResolution].r = num9;
					}
					else
					{
						col[k + j * DisplacementResolution].g = 0f - num9;
					}
				}
			}
		}
		if (!UseSmoothWaves)
		{
			return;
		}
		for (int l = 2; l < num3; l++)
		{
			for (int m = 2; m < num3; m++)
			{
				float num9 = (wavePoints[m + l * DisplacementResolution - 2].y * 0.2f + wavePoints[m + l * DisplacementResolution - 1].y * 0.4f + wavePoints[m + l * DisplacementResolution].y * 0.6f + wavePoints[m + l * DisplacementResolution + 1].y * 0.4f + wavePoints[m + l * DisplacementResolution + 2].y * 0.2f) / 1.6f * textureColorMultiplier;
				if (num9 >= 0f)
				{
					col[m + l * DisplacementResolution].r = num9;
				}
				else
				{
					col[m + l * DisplacementResolution].g = 0f - num9;
				}
			}
		}
		for (int n = 2; n < num3; n++)
		{
			for (int num10 = 2; num10 < num3; num10++)
			{
				float num9 = (wavePoints[num10 + n * DisplacementResolution - 2].y * 0.2f + wavePoints[num10 + n * DisplacementResolution - 1].y * 0.4f + wavePoints[num10 + n * DisplacementResolution].y * 0.6f + wavePoints[num10 + n * DisplacementResolution + 1].y * 0.4f + wavePoints[num10 + n * DisplacementResolution + 2].y * 0.2f) / 1.6f * textureColorMultiplier;
				if (num9 >= 0f)
				{
					col[num10 + n * DisplacementResolution].r = num9;
				}
				else
				{
					col[num10 + n * DisplacementResolution].g = 0f - num9;
				}
			}
		}
	}

	private void SetRippleTexture(int x, int y, float strength)
	{
		strength /= 100f;
		if (x >= 2 && x < DisplacementResolution - 2 && y >= 2 && y < DisplacementResolution - 2)
		{
			waveAcceleration[x, y].y -= strength;
			waveAcceleration[x + 1, y].y -= strength * 0.8f;
			waveAcceleration[x - 1, y].y -= strength * 0.8f;
			waveAcceleration[x, y + 1].y -= strength * 0.8f;
			waveAcceleration[x, y - 1].y -= strength * 0.8f;
			waveAcceleration[x + 1, y + 1].y -= strength * 0.7f;
			waveAcceleration[x + 1, y - 1].y -= strength * 0.7f;
			waveAcceleration[x - 1, y + 1].y -= strength * 0.7f;
			waveAcceleration[x - 1, y - 1].y -= strength * 0.7f;
			if (x >= 3 && x < DisplacementResolution - 3 && y >= 3 && y < DisplacementResolution - 3)
			{
				waveAcceleration[x + 2, y].y -= strength * 0.5f;
				waveAcceleration[x - 2, y].y -= strength * 0.5f;
				waveAcceleration[x, y + 2].y -= strength * 0.5f;
				waveAcceleration[x, y - 2].y -= strength * 0.5f;
			}
		}
	}

	private float GetTextureHeightByPosition(float x, float y)
	{
		x /= scaleBounds.x;
		y /= scaleBounds.y;
		x *= (float)DisplacementResolution;
		y *= (float)DisplacementResolution;
		if (x >= (float)DisplacementResolution || y >= (float)DisplacementResolution || x < 0f || y < 0f)
		{
			return 0f;
		}
		return waveAcceleration[(int)x, (int)y].x * textureColorMultiplier;
	}

	private Vector3 GerstnerOffset4(Vector2 xzVtx, Vector4 _GSteepness, Vector4 _GAmplitude, Vector4 _GFrequency, Vector4 _GSpeed, Vector4 _GDirectionAB, Vector4 _GDirectionCD)
	{
		Vector3 result = default(Vector3);
		float num = _GSteepness.x * _GAmplitude.x;
		float num2 = _GSteepness.y * _GAmplitude.y;
		Vector4 vector = new Vector4(num * _GDirectionAB.x, num * _GDirectionAB.y, num2 * _GDirectionAB.z, num2 * _GDirectionAB.w);
		Vector4 vector2 = new Vector4(_GSteepness.z * _GAmplitude.z * _GDirectionCD.x, _GSteepness.z * _GAmplitude.z * _GDirectionCD.y, _GSteepness.w * _GAmplitude.w * _GDirectionCD.z, _GSteepness.w * _GAmplitude.w * _GDirectionCD.w);
		float num3 = Vector2.Dot(new Vector2(_GDirectionAB.x, _GDirectionAB.y), xzVtx);
		float num4 = Vector2.Dot(new Vector2(_GDirectionAB.z, _GDirectionAB.w), xzVtx);
		float num5 = Vector2.Dot(new Vector2(_GDirectionCD.x, _GDirectionCD.y), xzVtx);
		float num6 = Vector2.Dot(new Vector2(_GDirectionCD.z, _GDirectionCD.w), xzVtx);
		Vector4 vector3 = new Vector4(num3 * _GFrequency.x, num4 * _GFrequency.y, num5 * _GFrequency.z, num6 * _GFrequency.w);
		Vector4 vector4 = new Vector4(Time.time * _GSpeed.x % 6.2831f, Time.time * _GSpeed.y % 6.2831f, Time.time * _GSpeed.z % 6.2831f, Time.time * _GSpeed.w % 6.2831f);
		Vector4 a = new Vector4(Mathf.Cos(vector3.x + vector4.x), Mathf.Cos(vector3.y + vector4.y), Mathf.Cos(vector3.z + vector4.z), Mathf.Cos(vector3.w + vector4.w));
		Vector4 a2 = new Vector4(Mathf.Sin(vector3.x + vector4.x), Mathf.Sin(vector3.y + vector4.y), Mathf.Sin(vector3.z + vector4.z), Mathf.Sin(vector3.w + vector4.w));
		result.x = Vector4.Dot(a, new Vector4(vector.x, vector.z, vector2.x, vector2.z));
		result.z = Vector4.Dot(a, new Vector4(vector.y, vector.w, vector2.y, vector2.w));
		result.y = Vector4.Dot(a2, _GAmplitude);
		return result;
	}
}
[ExecuteInEditMode]
public class Water_DistortionAndBloom : MonoBehaviour
{
	[Range(0.05f, 1f)]
	[Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.5f;

	public LayerMask CullingMask = -17;

	private RenderTexture source;

	private RenderTexture depth;

	private RenderTexture destination;

	private int previuosFrameWidth;

	private int previuosFrameHeight;

	private float previousScale;

	private Camera addCamera;

	private GameObject tempGO;

	private bool HDRSupported;

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	private GUIStyle guiStyleHeader = new GUIStyle();

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void OnDisable()
	{
		if (tempGO != null)
		{
			UnityEngine.Object.DestroyImmediate(tempGO);
		}
		Shader.DisableKeyword("DISTORT_OFF");
		Shader.DisableKeyword("_MOBILEDEPTH_ON");
	}

	private void Start()
	{
		InitializeRenderTarget();
	}

	private void LateUpdate()
	{
		if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
		{
			InitializeRenderTarget();
			previuosFrameWidth = Screen.width;
			previuosFrameHeight = Screen.height;
			previousScale = RenderTextureResolutoinFactor;
		}
		Shader.EnableKeyword("DISTORT_OFF");
		Shader.EnableKeyword("_MOBILEDEPTH_ON");
		GrabImage();
		Shader.SetGlobalTexture("_GrabTexture", source);
		Shader.SetGlobalTexture("_CameraDepthTexture", depth);
		Shader.SetGlobalFloat("_GrabTextureScale", RenderTextureResolutoinFactor);
		Shader.DisableKeyword("DISTORT_OFF");
	}

	private void InitializeRenderTarget()
	{
		int width = (int)((float)Screen.width * RenderTextureResolutoinFactor);
		int height = (int)((float)Screen.height * RenderTextureResolutoinFactor);
		HDRSupported = false;
		source = new RenderTexture(width, height, 0, RenderTextureFormat.RGB565);
		depth = new RenderTexture(width, height, 8, RenderTextureFormat.Depth);
	}

	private void GrabImage()
	{
		Camera camera = Camera.current;
		if (camera == null)
		{
			camera = Camera.main;
		}
		if (tempGO == null)
		{
			tempGO = new GameObject();
			tempGO.hideFlags = HideFlags.HideAndDontSave;
			addCamera = tempGO.AddComponent<Camera>();
			addCamera.enabled = false;
		}
		else
		{
			addCamera = tempGO.GetComponent<Camera>();
		}
		addCamera.CopyFrom(camera);
		addCamera.SetTargetBuffers(source.colorBuffer, depth.depthBuffer);
		addCamera.depth--;
		addCamera.cullingMask = CullingMask;
		addCamera.Render();
	}
}
public class BalloonFXSceneSelect : MonoBehaviour
{
	public void LoadBallonDemo01()
	{
		SceneManager.LoadScene("BalloonFX01");
	}

	public void LoadBallonDemo02()
	{
		SceneManager.LoadScene("BalloonFX02");
	}

	public void LoadBallonDemo03()
	{
		SceneManager.LoadScene("BalloonFX03");
	}

	public void LoadBallonDemo04()
	{
		SceneManager.LoadScene("BalloonFX04");
	}
}
[ExecuteInEditMode]
public class CameraTarget : MonoBehaviour
{
	public Transform m_TargetOffset;

	private void LateUpdate()
	{
		base.transform.LookAt(m_TargetOffset);
	}
}
[Serializable]
public class EffectData
{
	public bool m_bFoldoutOpen = true;

	public float m_fTimeSec;

	public GameObject m_goEffect;

	public bool m_bTransformFoldout = true;

	public Vector3 m_goPos = new Vector3(0f, 0f, 0f);

	public Vector3 m_goRotation = new Vector3(0f, 0f, 0f);

	public Vector3 m_goScale = new Vector3(1f, 1f, 1f);

	public bool m_bSortingFoldout = true;

	public int m_SortingLayerID;

	public int m_SortingOrder;
}
public class EffectController : MonoBehaviour
{
	public int m_nNumOfEffects;

	public bool m_bLockNums;

	public List<EffectData> m_kEffectGenList = new List<EffectData>();

	private int m_nNowIndex;

	private void Awake()
	{
		for (int i = 0; i < m_kEffectGenList.Count; i++)
		{
			Invoke("GenEffect", m_kEffectGenList[i].m_fTimeSec);
		}
		Comp comparer = new Comp();
		m_kEffectGenList.Sort(comparer);
	}

	private void Update()
	{
		CheckTransfromUpdate();
	}

	private void GenEffect()
	{
		EffectData effectData = m_kEffectGenList[m_nNowIndex];
		if (effectData != null)
		{
			if (effectData.m_goEffect != null)
			{
				GameObject obj = UnityEngine.Object.Instantiate(effectData.m_goEffect);
				obj.transform.parent = base.transform;
				obj.name = m_nNowIndex.ToString();
				UpdateEffectTransformByIndex(m_nNowIndex);
				UPdateRenderLayerByIndex(m_nNowIndex);
			}
			m_nNowIndex++;
		}
	}

	private void CheckTransfromUpdate()
	{
		foreach (Transform item in base.transform)
		{
			int index = int.Parse(item.name);
			EffectData effectData = m_kEffectGenList[index];
			if (effectData == null)
			{
				break;
			}
			if (item.position != effectData.m_goPos)
			{
				effectData.m_goPos = item.position;
			}
			if (item.localRotation.eulerAngles != effectData.m_goRotation)
			{
				effectData.m_goRotation = item.localRotation.eulerAngles;
			}
			if (item.localScale != effectData.m_goScale)
			{
				effectData.m_goScale = item.localScale;
			}
		}
	}

	public void UpdateEffectTransformByIndex(int nIndex)
	{
		Transform transform = base.transform.Find(nIndex.ToString());
		if (!(transform == null))
		{
			EffectData effectData = m_kEffectGenList[nIndex];
			if (effectData != null)
			{
				transform.position = effectData.m_goPos;
				Quaternion localRotation = default(Quaternion);
				localRotation.eulerAngles = effectData.m_goRotation;
				transform.localRotation = localRotation;
				transform.localScale = effectData.m_goScale;
			}
		}
	}

	public ParticleSystem CheckHasParticleSystem(int nIndex)
	{
		Transform transform = base.transform.Find(nIndex.ToString());
		if (transform == null)
		{
			return null;
		}
		return transform.gameObject.GetComponent<ParticleSystem>();
	}

	public RenderEffect CheckHasRenderEffectScript(int nIndex)
	{
		Transform transform = base.transform.Find(nIndex.ToString());
		if (transform == null)
		{
			return null;
		}
		return transform.gameObject.GetComponent<RenderEffect>();
	}

	public void UPdateRenderLayerByIndex(int nIndex)
	{
		Transform transform = base.transform.Find(nIndex.ToString());
		if (!(transform == null))
		{
			EffectData effectData = m_kEffectGenList[nIndex];
			if (effectData != null)
			{
				Renderer component = transform.gameObject.GetComponent<Renderer>();
				component.sortingLayerID = effectData.m_SortingLayerID;
				component.sortingOrder = effectData.m_SortingOrder;
			}
		}
	}
}
public class Comp : IComparer<EffectData>
{
	public int Compare(EffectData x, EffectData y)
	{
		if (x == null)
		{
			if (y == null)
			{
				return 0;
			}
			return 1;
		}
		if (y == null)
		{
			return -1;
		}
		float num = x.m_fTimeSec.CompareTo(y.m_fTimeSec);
		if (num > 0f)
		{
			return 1;
		}
		if (num < 0f)
		{
			return -1;
		}
		return 0;
	}
}
[ExecuteInEditMode]
public class EffectDemo : MonoBehaviour
{
	public const string EFFECT_ASSET_PATH = "Assets/Prefab/";

	public List<GameObject> m_EffectPrefabList = new List<GameObject>();

	public bool m_LookAtEffect = true;

	private GameObject m_NowShowEffect;

	private int m_NowIndex;

	private string m_NowEffectName;

	private void Awake()
	{
		if (Application.isPlaying)
		{
			m_NowIndex = 1;
			GenPrevEffect();
		}
	}

	private void OnDestroy()
	{
		UnityEngine.Object.DestroyImmediate(m_NowShowEffect);
	}

	private void LateUpdate()
	{
		if (Application.isPlaying && m_LookAtEffect && (bool)m_NowShowEffect)
		{
			base.transform.LookAt(m_NowShowEffect.transform.position);
		}
	}

	private void OnGUI()
	{
		if (Application.isPlaying)
		{
			if (GUI.Button(new Rect(0f, 25f, 80f, 50f), "Prev"))
			{
				GenPrevEffect();
			}
			if (GUI.Button(new Rect(90f, 25f, 80f, 50f), "Next"))
			{
				GenNextEffect();
			}
			GUI.Label(new Rect(5f, 0f, 350f, 50f), m_NowEffectName);
		}
	}

	private void GenPrevEffect()
	{
		m_NowIndex--;
		if (m_NowIndex < 0)
		{
			m_NowIndex = 0;
			return;
		}
		if (m_NowShowEffect != null)
		{
			UnityEngine.Object.Destroy(m_NowShowEffect);
		}
		m_NowShowEffect = UnityEngine.Object.Instantiate(m_EffectPrefabList[m_NowIndex]);
		m_NowEffectName = m_NowShowEffect.name;
	}

	private void GenNextEffect()
	{
		m_NowIndex++;
		if (m_NowIndex >= m_EffectPrefabList.Count)
		{
			m_NowIndex = m_EffectPrefabList.Count - 1;
			return;
		}
		if (m_NowShowEffect != null)
		{
			UnityEngine.Object.Destroy(m_NowShowEffect);
		}
		m_NowShowEffect = UnityEngine.Object.Instantiate(m_EffectPrefabList[m_NowIndex]);
		m_NowEffectName = m_NowShowEffect.name;
	}
}
public class EffectShaderPropertyStr
{
	public const string ColorStr = "_TintColor";

	public const string MainTexStr = "_MainTex";

	public const string CutTexStr = "_CutTex";

	public const string CutOffStr = "_Cutoff";

	public const string MainRotationStr = "_MainRotation";

	public const string CutRotationStr = "_CutRotation";

	public const string UVScrollX = "_UVScrollX";

	public const string UVScrollY = "_UVScrollY";

	public const string UVCutScrollX = "_UVCutScrollX";

	public const string UVCutScrollY = "_UVCutScrollY";

	public const string CutParticleSoftValue = "_InvFade";

	public const string UVMirrorX = "_UVMirrorX";

	public const string UVMirrorY = "_UVMirrorY";

	public const string DissolveSrc = "_DissolveSrc";

	public const string SpecColor = "_SpecColor";

	public const string Shininess = "_Shininess";

	public const string Amount = "_Amount";

	public const string StartAmount = "_StartAmount";

	public const string DissColor = "_DissColor";

	public const string Illuminate = "_Illuminate";

	public const string EmissionGain = "_EmissionGain";

	public const string ShadowColor = "_ShadowColor";

	public const string SpecularPower = "_SpecularPower";

	public const string EdgeThickness = "_EdgeThickness";

	public const string EdgeSaturtion = "_EdgeSaturtion";

	public const string EdgeBrightness = "_EdgeBrightness";

	public const string FalloffSampler = "_FalloffSampler";

	public const string RimLightSampler = "_RimLightSampler";

	public const string ColorFactor = "_ColorFactor";

	public const string EnableAlphaMaskStr = "Enable_AlphaMask";

	public const string EnableUVRotationStr = "Enable_UVRotation";

	public const string EnableUVScrollStr = "Enable_UVScroll";

	public const string EnableUVMirror = "Enable_UVMirror";

	public const string EnableBloom = "Enable_Bloom";

	public static readonly int Material_Color = Shader.PropertyToID("_TintColor");

	public static readonly int Material_Color_Factor = Shader.PropertyToID("_ColorFactor");
}
public enum RenderBillBoardType
{
	Normal,
	Horizontal,
	Vertical
}
[Serializable]
public class MaterialEffect
{
	public Material m_EffectMaterial;

	public bool m_EnableAlphaAnimation;

	public float m_AlphaAnimationTimeScale = 1f;

	public AnimationCurve m_AlphaCurve = new AnimationCurve();

	public Texture m_MainTexture;

	public Texture m_MaskTexutre;

	public TextureWrapMode m_MainTexWrapMode;

	public TextureWrapMode m_MaskTexWrapMode;

	public bool m_EnableUVScroll;

	public Vector2 m_UVScrollMainTex;

	public Vector2 m_UVScrollCutTex;

	public MaterialEffect(Material material)
	{
	}

	public void ReInitMaterial(Material material)
	{
		if (!(material == null))
		{
			m_EffectMaterial = material;
			if (material.HasProperty("_MainTex"))
			{
				m_MainTexture = material.GetTexture("_MainTex");
			}
			if (material.HasProperty("_CutTex"))
			{
				m_MaskTexutre = material.GetTexture("_CutTex");
			}
		}
	}

	public void UpdateEffect(float execueTime)
	{
		if (m_MainTexture != null && m_MainTexWrapMode != m_MainTexture.wrapMode)
		{
			m_MainTexture.wrapMode = m_MainTexWrapMode;
		}
		if (m_MaskTexutre != null && m_MaskTexWrapMode != m_MaskTexutre.wrapMode)
		{
			m_MaskTexutre.wrapMode = m_MaskTexWrapMode;
		}
		if (m_EnableUVScroll)
		{
			if ((bool)m_MainTexture)
			{
				m_EffectMaterial.SetTextureOffset("_MainTex", m_UVScrollMainTex * execueTime);
			}
			if ((bool)m_MaskTexutre)
			{
				m_EffectMaterial.SetTextureOffset("_CutTex", m_UVScrollCutTex * execueTime);
			}
		}
	}

	private void SetAlpha(float value)
	{
		Color color = m_EffectMaterial.color;
		color.a = value;
		m_EffectMaterial.color = color;
	}
}
[ExecuteInEditMode]
public class RenderEffect : MonoBehaviour
{
	public RenderBillBoardType m_BillBoardType;

	private Camera m_ReferenceCamera;

	public bool m_EnableBillBoard;

	public bool m_EnableSetSortLayer = true;

	public Renderer m_Render;

	public List<MaterialEffect> m_MaterialEffects = new List<MaterialEffect>();

	private float m_TimeLine;

	[HideInInspector]
	public int m_SortingLayerID;

	[HideInInspector]
	public int m_SortingOrder;

	private void Awake()
	{
		m_ReferenceCamera = Camera.main;
		m_Render = GetComponent<Renderer>();
		_ = m_Render == null;
	}

	private void OnEnable()
	{
		RefreshMaterial();
	}

	public void UpdateRenderLayer()
	{
		if (m_EnableSetSortLayer)
		{
			m_Render.sortingLayerID = m_SortingLayerID;
			m_Render.sortingOrder = m_SortingOrder;
		}
	}

	public void RefreshMaterial()
	{
		if (m_Render == null)
		{
			m_Render = GetComponent<Renderer>();
			if (m_Render == null)
			{
				return;
			}
		}
		int num = 0;
		for (num = 0; num < m_Render.sharedMaterials.Length; num++)
		{
			if (m_MaterialEffects.Count <= num)
			{
				MaterialEffect item = new MaterialEffect(m_Render.sharedMaterials[num]);
				m_MaterialEffects.Add(item);
			}
			else
			{
				m_MaterialEffects[num].ReInitMaterial(m_Render.sharedMaterials[num]);
			}
		}
		int num2 = m_MaterialEffects.Count - 1;
		while (num <= num2)
		{
			m_MaterialEffects.RemoveAt(num2);
			num2--;
		}
		UpdateRenderLayer();
	}

	private void UpdateBillBoard()
	{
		if (m_EnableBillBoard)
		{
			if (m_ReferenceCamera == null)
			{
				m_ReferenceCamera = Camera.main;
			}
			if (m_BillBoardType == RenderBillBoardType.Normal)
			{
				Vector3 worldPosition = base.transform.position + m_ReferenceCamera.transform.rotation * Vector3.forward;
				Vector3 worldUp = m_ReferenceCamera.transform.rotation * Vector3.up;
				base.transform.LookAt(worldPosition, worldUp);
			}
			else if (m_BillBoardType == RenderBillBoardType.Vertical)
			{
				Vector3 forward = m_ReferenceCamera.transform.forward;
				forward.y = 0f;
				base.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
			}
			else if (m_BillBoardType == RenderBillBoardType.Horizontal)
			{
				Vector3 worldPosition2 = base.transform.position + m_ReferenceCamera.transform.rotation * Vector3.down;
				Vector3 worldUp2 = m_ReferenceCamera.transform.rotation * Vector3.up;
				base.transform.LookAt(worldPosition2, worldUp2);
				Vector3 eulerAngles = base.transform.rotation.eulerAngles;
				eulerAngles.x = 90f;
				base.transform.rotation = Quaternion.Euler(eulerAngles);
			}
		}
	}

	private void Update()
	{
		m_TimeLine += Time.deltaTime;
		foreach (MaterialEffect materialEffect in m_MaterialEffects)
		{
			materialEffect.UpdateEffect(m_TimeLine);
		}
	}

	private void LateUpdate()
	{
		UpdateBillBoard();
	}

	public void Sim(float timer)
	{
		UpdateBillBoard();
		foreach (MaterialEffect materialEffect in m_MaterialEffects)
		{
			materialEffect.UpdateEffect(timer);
		}
	}
}
public static class TransformExtension
{
	public static Transform FindChildByRecursive(this Transform aParent, string aName)
	{
		Transform transform = aParent.Find(aName);
		if (transform != null)
		{
			return transform;
		}
		foreach (Transform item in aParent)
		{
			transform = item.FindChildByRecursive(aName);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
public class DemoScene : MonoBehaviour
{
	public GameObject[] prefabs;

	public Text txtLabel;

	public void ShowEffect1()
	{
		prefabs[0].SetActive(value: true);
		prefabs[1].SetActive(value: false);
		txtLabel.text = "Petals Prefab 1";
	}

	public void ShowEffect2()
	{
		prefabs[0].SetActive(value: false);
		prefabs[1].SetActive(value: true);
		txtLabel.text = "Petals Prefab 2";
	}

	public void ShowEffect3()
	{
		prefabs[0].SetActive(value: true);
		prefabs[1].SetActive(value: true);
		txtLabel.text = "Petals Prefab 1+2";
	}
}
public class ExampleWheelController : MonoBehaviour
{
	private static class Uniforms
	{
		internal static readonly int _MotionAmount = Shader.PropertyToID("_MotionAmount");
	}

	public float acceleration;

	public Renderer motionVectorRenderer;

	private Rigidbody m_Rigidbody;

	private void Start()
	{
		m_Rigidbody = GetComponent<Rigidbody>();
		m_Rigidbody.maxAngularVelocity = 100f;
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.UpArrow))
		{
			m_Rigidbody.AddRelativeTorque(new Vector3(-1f * acceleration, 0f, 0f), ForceMode.Acceleration);
		}
		else if (Input.GetKey(KeyCode.DownArrow))
		{
			m_Rigidbody.AddRelativeTorque(new Vector3(1f * acceleration, 0f, 0f), ForceMode.Acceleration);
		}
		float value = (0f - m_Rigidbody.angularVelocity.x) / 100f;
		if ((bool)motionVectorRenderer)
		{
			motionVectorRenderer.material.SetFloat(Uniforms._MotionAmount, Mathf.Clamp(value, -0.25f, 0.25f));
		}
	}
}
public class FollowShip : MonoBehaviour
{
	public Transform target;

	public static float distance = 10f;

	public static float height = 14f;

	private float heightDamping = 2f;

	private float rotationDamping = 3f;

	private void LateUpdate()
	{
		if ((bool)target)
		{
			float y = target.eulerAngles.y;
			float b = target.position.y + height;
			float y2 = base.transform.eulerAngles.y;
			float y3 = base.transform.position.y;
			y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
			y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
			Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
			base.transform.position = target.position;
			base.transform.position -= quaternion * Vector3.forward * distance;
			base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
			base.transform.LookAt(target);
		}
	}
}
public class DelayedLoader : MonoBehaviour
{
	public float[] delays;

	public int[] additiveLevelIndex;

	private void Start()
	{
		for (int i = 0; i < delays.Length; i++)
		{
			StartCoroutine(LoadAdaptive(i));
		}
	}

	public IEnumerator LoadAdaptive(int index)
	{
		yield return new WaitForSeconds(delays[index]);
		SceneManager.LoadSceneAsync(additiveLevelIndex[index], LoadSceneMode.Additive);
	}
}
[RequireComponent(typeof(Collider))]
public class EpiActivator : MonoBehaviour
{
	public string activationTag = "Player";

	public UnityEvent onTriggerEnter;

	public UnityEvent onTriggerExit;

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == activationTag)
		{
			onTriggerEnter.Invoke();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == activationTag)
		{
			onTriggerExit.Invoke();
		}
	}
}
public class CatAchievement : MonoBehaviour
{
	[Header("General")]
	public string ID;

	public UnlockHelper unlockHelper;

	[Header("Representation")]
	public GameObject cat;

	private Text totalText;

	private Text moneyText;

	[Header("Events")]
	public UnityEvent onActivation;

	public UnityEvent onStarUnlock;

	private void Start()
	{
		if (PlayerPrefs.GetInt(Globals.UNLOCKNAME + ID) == 1)
		{
			cat.SetActive(value: false);
		}
		moneyText = GameObject.FindGameObjectWithTag("MoneyText").GetComponent<Text>();
		totalText = GameObject.FindGameObjectWithTag("CatText").GetComponent<Text>();
		totalText.text = PlayerPrefs.GetInt(Globals.TOTALHIDDENCATS).ToString() ?? "";
	}

	public void Collect()
	{
		PlayerPrefs.SetInt(Globals.UNLOCKNAME + ID, 1);
		PlayerPrefs.SetInt(Globals.TOTALHIDDENCATS, PlayerPrefs.GetInt(Globals.TOTALHIDDENCATS) + 1);
		PlayerPrefs.SetInt(Globals.TOTALMONEY, PlayerPrefs.GetInt(Globals.TOTALMONEY) + 100);
		PlayerPrefs.Save();
		CheckUnlockStar();
		onActivation.Invoke();
		if (totalText != null)
		{
			totalText.text = PlayerPrefs.GetInt(Globals.TOTALHIDDENCATS).ToString() ?? "";
		}
		moneyText.text = PlayerPrefs.GetInt(Globals.TOTALMONEY).ToString() ?? "";
	}

	public void CheckUnlockStar()
	{
		if (PlayerPrefs.GetInt(Globals.TOTALHIDDENCATS) % 4 == 0)
		{
			PlayerPrefs.SetInt(Globals.TOTALSTARS, PlayerPrefs.GetInt(Globals.TOTALSTARS) + 1);
			PlayerPrefs.Save();
			unlockHelper.CheckUnlock();
			unlockHelper.PlayUnlockSound();
			unlockHelper.FadeInTextOverlay();
			onStarUnlock.Invoke();
		}
	}
}
public class EasyBullet : MonoBehaviour
{
	public float lifetime = 5f;

	public float speed = 1f;

	private void Start()
	{
		UnityEngine.Object.Destroy(this, lifetime);
		GetComponent<Rigidbody>().velocity = base.gameObject.transform.forward * speed;
	}
}
public class EasyGun : MonoBehaviour
{
	public GameObject spawnPoint;

	public GameObject bullet;

	public KeyCode shootKey;

	public float cooldown = 0.5f;

	private float counter;

	private void Update()
	{
		if (counter == 0f)
		{
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X))
			{
				UnityEngine.Object.Instantiate(bullet, spawnPoint.transform.position, base.gameObject.transform.rotation, null);
				counter = cooldown;
			}
		}
		else
		{
			counter -= Time.deltaTime;
			if (counter < 0f)
			{
				counter = 0f;
			}
		}
	}
}
public class EnableOne : MonoBehaviour
{
	public GameObject[] objects;

	private void Start()
	{
		objects[UnityEngine.Random.Range(0, objects.Length)].SetActive(value: true);
	}
}
public class EpiBoss_Blow : MonoBehaviour
{
	public enum BossState
	{
		Move,
		Stop,
		Blow
	}

	public bool isActive;

	public GameObject target;

	public BossState state;

	public Animator unicornAnimator;

	public GameObject blowElement;

	public AudioSource inAudio;

	public AudioSource outAudio;

	private void Update()
	{
		if (isActive)
		{
			float num = 0.5f;
			if (state == BossState.Move || state == BossState.Stop)
			{
				num = 2f;
			}
			Quaternion b = Quaternion.LookRotation(target.transform.position - base.transform.position - Vector3.up * 2f);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, num * Time.deltaTime);
		}
	}

	public void UpdateState()
	{
		if (state == BossState.Move)
		{
			state = BossState.Stop;
			unicornAnimator.SetInteger("animation", 3);
			inAudio.Play();
		}
		else if (state == BossState.Stop)
		{
			state = BossState.Blow;
			unicornAnimator.SetInteger("animation", 4);
			blowElement.SetActive(value: true);
			outAudio.Play();
		}
		else if (state == BossState.Blow)
		{
			state = BossState.Move;
			unicornAnimator.SetInteger("animation", 1);
			blowElement.SetActive(value: false);
		}
	}

	public void SetActive(bool a)
	{
		if (isActive != a)
		{
			isActive = a;
			if (isActive)
			{
				InvokeRepeating("UpdateState", 3f, 3f);
			}
			else
			{
				CancelInvoke("UpdateState");
			}
		}
	}
}
public class EpiBoss_BlowElement : MonoBehaviour
{
	public Transform unicorn;

	public float strength;

	private void OnTriggerStay(Collider other)
	{
		if (other.tag == "Player")
		{
			UnityEngine.Debug.Log(" ############################################### Player found ############################################### ");
			Vector3 vector = other.transform.position - unicorn.transform.position;
			other.GetComponent<Rigidbody>().AddForce(vector.normalized * strength);
		}
	}
}
public class EpiGravitationTrigger : MonoBehaviour
{
	public string activationTag = "Player";

	public Vector3 insideGravitation;

	private Vector3 outSideGravitation;

	public void OnTriggerEnter(Collider other)
	{
		if (other.tag == activationTag)
		{
			outSideGravitation = Physics.gravity;
			Physics.gravity = insideGravitation;
		}
	}

	public void OnTriggerExit(Collider other)
	{
		if (other.tag == activationTag)
		{
			Physics.gravity = outSideGravitation;
		}
	}
}
public class EpiObjectCuller : MonoBehaviour
{
	[Serializable]
	public struct ObjectGroup
	{
		public GameObject[] objects;

		public float cullDistance;
	}

	public GameObject player;

	public ObjectGroup[] objectGroups;

	private void Start()
	{
		ObjectGroup[] array = objectGroups;
		for (int i = 0; i < array.Length; i++)
		{
			GameObject[] objects = array[i].objects;
			for (int j = 0; j < objects.Length; j++)
			{
				objects[j].SetActive(value: false);
			}
		}
		InvokeRepeating("Check", 1f, 1f);
	}

	public void Check()
	{
		ObjectGroup[] array = objectGroups;
		for (int i = 0; i < array.Length; i++)
		{
			ObjectGroup objectGroup = array[i];
			GameObject[] objects = objectGroup.objects;
			foreach (GameObject gameObject in objects)
			{
				if (Vector3.Distance(gameObject.transform.position, player.transform.position) < objectGroup.cullDistance)
				{
					gameObject.SetActive(value: true);
				}
				else
				{
					gameObject.SetActive(value: false);
				}
			}
		}
	}
}
public class EpiTextureRandomizer : MonoBehaviour
{
	public bool randomizeTexture;

	public Texture2D[] textures;

	public bool randomizeMaterial;

	public Material[] materials;

	private void Start()
	{
		if (randomizeTexture)
		{
			GetComponent<Renderer>().material.SetTexture("_MainTex", textures[UnityEngine.Random.Range(0, textures.Length)]);
		}
		if (randomizeMaterial)
		{
			GetComponent<Renderer>().material = materials[UnityEngine.Random.Range(0, materials.Length)];
		}
	}
}
public static class Globals
{
	public static string UNLOCKNAME = "CatAchievement";

	public static string TOTALSTARS = "Stars";

	public static string TOTALHIDDENCATS = "TotalCatAchievements";

	public static string TOTALTHRUSTER = "TotalThruster";

	public static string TOTALSKINS = "TotalSkins";

	public static string MISSIONSTARS = "MissionStarsForMissionID";

	public static string TOTALMONEY = "TotalMoney";

	public static string THRUSTERUNLOCKED = "TrusterUnlocked";

	public static string THRUSTERLEVEL = "TrusterLevel";

	public static string THRUSTERSKINUNLOCKED = "ThrusterSkinUnlocked";

	public static bool GetSkinUnlocked(int truster, int skin)
	{
		if (PlayerPrefs.GetInt(THRUSTERSKINUNLOCKED + truster + "_" + skin) == 1)
		{
			return true;
		}
		return false;
	}

	public static void SetSkinUnlocked(int truster, int skin, int state)
	{
		PlayerPrefs.SetInt(THRUSTERSKINUNLOCKED + truster + "_" + skin, state);
	}
}
public class Mission : MonoBehaviour
{
	public enum MissionType
	{
		HideAndSeek,
		Rings,
		Catch,
		Shoot
	}

	[Header("Unique Identifier")]
	public int languageID;

	public string ID;

	public MissionType missionType;

	public string missionName;

	public string missionDescription;

	public string unitName;

	public Sprite preview;

	[Header("Availability")]
	public int unlockAmount;

	public GameObject unlocked;

	public GameObject locked;

	public TextMeshPro lockedCounter;

	[HorizontalLine(2f, EColor.White)]
	[Header("Game Definition")]
	public float startTime;

	public GameObject[] spawnObjects;

	public bool spawnAllObjects;

	public int alternativeSpawnAmount;

	public GameObject[] additionalObjects;

	public GameObject[] additionalRemoveObjects;

	[HorizontalLine(2f, EColor.White)]
	[Header("Reward Definition")]
	public int starValue = 1000;

	public int goal1star = 1;

	public int goal2star = 2;

	public int goal3star = 3;

	[HorizontalLine(2f, EColor.White)]
	[Header("Representation")]
	public MissionRepresentation rep;

	[HorizontalLine(2f, EColor.White)]
	[Header("Additional Events")]
	public UnityEvent endEvent;

	public bool zombieHotfix;

	private float timer;

	private int pointCounter;

	private bool running;

	private bool inCountdown;

	private int tmpStars;

	private bool waitForInput;

	private int earnedMoney;

	private List<GameObject> disabledObjects;

	private int newStars;

	private void Start()
	{
		GameObject[] array = spawnObjects;
		foreach (GameObject gameObject in array)
		{
			if (gameObject.GetComponentInChildren<MissionTarget>() != null)
			{
				gameObject.GetComponentInChildren<MissionTarget>().Init(this);
			}
		}
		if (lockedCounter != null)
		{
			lockedCounter.text = unlockAmount.ToString() ?? "";
		}
		CheckUnlock();
		CheckLanguage();
	}

	public void CheckUnlock()
	{
		if (PlayerPrefs.GetInt(Globals.TOTALSTARS) >= unlockAmount)
		{
			unlocked.SetActive(value: true);
			locked.SetActive(value: false);
		}
		else
		{
			unlocked.SetActive(value: false);
			locked.SetActive(value: true);
		}
	}

	public void CheckLanguage()
	{
		missionName = LocalizationManager.GetTranslation("MissionName" + languageID);
		missionDescription = LocalizationManager.GetTranslation("MissionDescription" + languageID);
		unitName = LocalizationManager.GetTranslation("Unit" + languageID);
	}

	public void SetupMissionUI()
	{
		rep.startMissionName.text = missionName;
		rep.startMissionType.text = missionType.ToString();
		rep.startMissionDescription.text = missionDescription;
		rep.startGoal1.text = goal1star + " " + unitName;
		rep.startGoal2.text = goal2star + " " + unitName;
		rep.startGoal3.text = goal3star + " " + unitName;
		rep.endMissionName.text = missionName;
		rep.endMissionType.text = missionType.ToString();
		rep.startStar1.SetActive(value: false);
		rep.startStar2.SetActive(value: false);
		rep.startStar3.SetActive(value: false);
		if (PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID) >= 1)
		{
			rep.startStar1.SetActive(value: true);
		}
		if (PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID) >= 2)
		{
			rep.startStar2.SetActive(value: true);
		}
		if (PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID) >= 3)
		{
			rep.startStar3.SetActive(value: true);
		}
		rep.endStar1.SetBool("FadeIn", value: false);
		rep.endStar2.SetBool("FadeIn", value: false);
		rep.endStar3.SetBool("FadeIn", value: false);
		rep.missionPreview.sprite = preview;
	}

	public void StartMission()
	{
		rep.player.inMission = true;
		rep.player.mission = this;
		if (rep.endAnimation.gameObject.activeSelf || running || inCountdown)
		{
			return;
		}
		inCountdown = true;
		DisableEverything();
		GameObject[] array = additionalObjects;
		foreach (GameObject gameObject in array)
		{
			gameObject.SetActive(value: true);
			if (gameObject.GetComponent<Animator>() != null)
			{
				gameObject.GetComponent<Animator>().SetBool("FadeIn", value: true);
			}
		}
		array = additionalRemoveObjects;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		pointCounter = 0;
		timer = startTime;
		rep.timerText.text = timer.ToString("000.00");
		if (spawnAllObjects)
		{
			alternativeSpawnAmount = spawnObjects.Length;
		}
		rep.pointsText.text = pointCounter + " / " + alternativeSpawnAmount;
		rep.ShowMissionUI(ac: false);
		if (missionType == MissionType.HideAndSeek || missionType == MissionType.Shoot)
		{
			SetupSelectedTargets();
		}
		else if (missionType == MissionType.Rings || missionType == MissionType.Catch)
		{
			SetupFirstTargets();
		}
		if (missionType == MissionType.Shoot)
		{
			rep.gunRight.SetActive(value: true);
			rep.gunLeft.SetActive(value: true);
			rep.shootIntro.SetBool("FadeIn", value: true);
		}
		if (missionType == MissionType.Rings)
		{
			rep.ringArrow.SetActive(value: true);
		}
		rep.missionIntro.SetBool("FadeIn", value: true);
		Invoke("StartAnimation", 1f);
		Invoke("PlayBeep", 1f);
		Invoke("PlayBeep", 2f);
		Invoke("PlayBeep", 3f);
		Invoke("PlayBeep", 4f);
		Invoke("ShowMiddleBG", 4f);
		Invoke("StartRunning", 6f);
		EpiActivator[] componentsInChildren = GetComponentsInChildren<EpiActivator>();
		foreach (EpiActivator epiActivator in componentsInChildren)
		{
			if (epiActivator.gameObject.name == "Activator")
			{
				epiActivator.onTriggerExit.Invoke();
			}
		}
		if (zombieHotfix)
		{
			Invoke("DisableZombieAnimator", 0.2f);
			Invoke("EnableZombieAnimator", 0.25f);
		}
	}

	public void SetupSelectedTargets()
	{
		if (spawnObjects.Length != 0)
		{
			Shuffle();
			for (int i = 0; i < alternativeSpawnAmount; i++)
			{
				spawnObjects[i].SetActive(value: true);
				spawnObjects[i].GetComponent<ObjectReference>().reference.SetActive(value: true);
				spawnObjects[i].GetComponentInChildren<Animator>().SetBool("FadeIn", value: true);
			}
		}
	}

	public void SetupFirstTargets()
	{
		if (spawnObjects.Length != 0)
		{
			spawnObjects[0].SetActive(value: true);
			spawnObjects[0].GetComponent<ObjectReference>().reference.SetActive(value: true);
			spawnObjects[0].GetComponentInChildren<Animator>().SetBool("FadeIn", value: true);
		}
	}

	private void Update()
	{
		if (waitForInput && Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A))
		{
			rep.middleBG.SetBool("FadeIn", value: false);
			rep.endAnimation.SetBool("FadeIn", value: false);
			StartCoroutine(rep.Disable(rep.endAnimation, 1f));
			waitForInput = false;
			if (rep.unlockHelper.NewMissionUnlocked(PlayerPrefs.GetInt(Globals.TOTALSTARS) - newStars, newStars))
			{
				PlayUnlockSound();
				FadeInTextOverlay();
			}
		}
		if (timer < 0f)
		{
			Finish();
			timer = 0f;
		}
		if (timer > 0f && running)
		{
			if (timer < 12f && !rep.timeUpAudio.isPlaying)
			{
				rep.timeUpAudio.Play();
			}
			timer -= Time.deltaTime;
			rep.timerText.text = timer.ToString("000.00");
			rep.pointsText.text = pointCounter + " / " + alternativeSpawnAmount;
		}
		if (missionType == MissionType.Rings)
		{
			rep.ringArrow.transform.LookAt(spawnObjects[pointCounter].transform);
		}
	}

	public void GetPoint(GameObject sender)
	{
		pointCounter++;
		if (sender != null)
		{
			sender.GetComponentInChildren<Animator>().SetBool("FadeIn", value: false);
			StartCoroutine(Disable(sender, 1f));
		}
		if ((missionType == MissionType.HideAndSeek || missionType == MissionType.Shoot) && pointCounter >= goal3star)
		{
			Finish();
		}
		if (missionType != MissionType.Rings && missionType != MissionType.Catch)
		{
			return;
		}
		if (pointCounter < spawnObjects.Length)
		{
			if (missionType == MissionType.Catch)
			{
				Invoke("FadeInNext", 3f);
			}
			if (missionType == MissionType.Rings)
			{
				spawnObjects[pointCounter].SetActive(value: true);
				spawnObjects[pointCounter].GetComponent<ObjectReference>().reference.SetActive(value: true);
				spawnObjects[pointCounter].GetComponentInChildren<Animator>().SetBool("FadeIn", value: true);
			}
		}
		else
		{
			Finish();
		}
	}

	public void FadeInNext()
	{
		spawnObjects[pointCounter].SetActive(value: true);
		spawnObjects[pointCounter].GetComponent<ObjectReference>().reference.SetActive(value: true);
		spawnObjects[pointCounter].GetComponentInChildren<Animator>().SetBool("FadeIn", value: true);
	}

	public IEnumerator Disable(GameObject g, float delay)
	{
		yield return new WaitForSeconds(delay);
		g.SetActive(value: false);
	}

	public void Finish()
	{
		rep.player.inMission = false;
		rep.player.mission = null;
		running = false;
		waitForInput = true;
		EnableEverything();
		GameObject[] array = spawnObjects;
		foreach (GameObject gameObject in array)
		{
			UnityEngine.Debug.Log(gameObject.name);
			gameObject.GetComponentInChildren<Animator>().SetBool("FadeIn", value: false);
			StartCoroutine(Disable(gameObject, 1f));
		}
		rep.startAnimation.SetTrigger("Finish");
		StartCoroutine(rep.Disable(rep.startAnimation, 1f));
		rep.endAnimation.gameObject.SetActive(value: true);
		rep.endAnimation.SetBool("FadeIn", value: true);
		rep.middleBG.SetBool("FadeIn", value: false);
		if (missionType == MissionType.Shoot)
		{
			rep.gunRight.SetActive(value: false);
			rep.gunLeft.SetActive(value: false);
		}
		if (missionType == MissionType.Rings)
		{
			rep.ringArrow.SetActive(value: false);
		}
		tmpStars = 0;
		if (missionType == MissionType.Rings)
		{
			if (timer >= (float)goal3star)
			{
				tmpStars = 3;
			}
			else if (timer >= (float)goal2star)
			{
				tmpStars = 2;
			}
			else if (timer >= (float)goal1star)
			{
				tmpStars = 1;
			}
		}
		else if (pointCounter >= goal3star)
		{
			tmpStars = 3;
		}
		else if (pointCounter >= goal2star)
		{
			tmpStars = 2;
		}
		else if (pointCounter >= goal1star)
		{
			tmpStars = 1;
		}
		newStars = tmpStars - PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID);
		StartCoroutine(EndAnimation());
		if (tmpStars == 0)
		{
			rep.loseAudio.Play();
		}
		else
		{
			rep.winAudio.Play();
			Win();
		}
		array = additionalObjects;
		foreach (GameObject gameObject2 in array)
		{
			if (gameObject2.GetComponent<Animator>() != null)
			{
				gameObject2.GetComponent<Animator>().SetBool("FadeIn", value: false);
			}
			StartCoroutine(Disable(gameObject2, 1f));
		}
		array = additionalRemoveObjects;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
		endEvent.Invoke();
		timer = 0f;
	}

	public IEnumerator EndAnimation()
	{
		rep.endMoney.text = "0";
		rep.endPoints.text = "0/" + alternativeSpawnAmount;
		rep.endTime.text = "0s";
		yield return new WaitForSeconds(1f);
		if (tmpStars >= 1)
		{
			rep.endStar1.SetBool("FadeIn", value: true);
		}
		float counterB = 0f;
		while (counterB < startTime - timer)
		{
			counterB += 1f;
			rep.endTime.text = counterB + "s";
			yield return new WaitForSeconds(0.01f);
		}
		if (tmpStars >= 2)
		{
			rep.endStar2.SetBool("FadeIn", value: true);
		}
		float counterA = 0f;
		while (counterA < (float)pointCounter)
		{
			counterA += 1f;
			rep.endPoints.text = counterA + "/" + alternativeSpawnAmount;
			yield return new WaitForSeconds(0.1f);
		}
		if (tmpStars >= 3)
		{
			rep.endStar3.SetBool("FadeIn", value: true);
		}
		float counterC = 0f;
		while (counterC < (float)earnedMoney)
		{
			counterC += 1f;
			rep.endMoney.text = counterC.ToString() ?? "";
			yield return new WaitForSeconds(0.005f);
		}
		timer = 0f;
	}

	public void Win()
	{
		rep.winParticle.Play();
		if (tmpStars > PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID))
		{
			earnedMoney = (tmpStars - PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID)) * starValue;
			PlayerPrefs.SetInt(Globals.TOTALMONEY, PlayerPrefs.GetInt(Globals.TOTALMONEY) + earnedMoney);
			PlayerPrefs.Save();
			rep.moneyText.text = PlayerPrefs.GetInt(Globals.TOTALMONEY).ToString() ?? "";
			PlayerPrefs.SetInt(Globals.TOTALSTARS, PlayerPrefs.GetInt(Globals.TOTALSTARS) + (tmpStars - PlayerPrefs.GetInt(Globals.MISSIONSTARS + ID)));
			PlayerPrefs.SetInt(Globals.MISSIONSTARS + ID, tmpStars);
			PlayerPrefs.Save();
			rep.starsText.text = PlayerPrefs.GetInt(Globals.TOTALSTARS).ToString() ?? "";
			rep.unlockHelper.CheckUnlock();
		}
	}

	public void StartRunning()
	{
		running = true;
		inCountdown = false;
		rep.startAudio.Play();
		rep.missionIntro.SetBool("FadeIn", value: false);
		rep.shootIntro.SetBool("FadeIn", value: false);
	}

	public void PlayBeep()
	{
		rep.beepAudio.Play();
	}

	public void PlayStar()
	{
		rep.starAudio.Play();
	}

	public void ShowMiddleBG()
	{
		rep.middleBG.SetBool("FadeIn", value: true);
	}

	public void StartAnimation()
	{
		rep.startAnimation.gameObject.SetActive(value: true);
		rep.startAnimation.SetTrigger("Start");
	}

	private void Shuffle()
	{
		for (int i = 0; i < spawnObjects.Length; i++)
		{
			GameObject gameObject = spawnObjects[i];
			int num = UnityEngine.Random.Range(i, spawnObjects.Length);
			spawnObjects[i] = spawnObjects[num];
			spawnObjects[num] = gameObject;
		}
	}

	private void DisableEverything()
	{
		disabledObjects = new List<GameObject>();
		CatAchievement[] array = UnityEngine.Object.FindObjectsOfType<CatAchievement>();
		foreach (CatAchievement catAchievement in array)
		{
			disabledObjects.Add(catAchievement.transform.parent.gameObject);
		}
		Mission[] array2 = UnityEngine.Object.FindObjectsOfType<Mission>();
		foreach (Mission mission in array2)
		{
			if (mission != this)
			{
				disabledObjects.Add(mission.gameObject);
			}
		}
		foreach (GameObject disabledObject in disabledObjects)
		{
			disabledObject.SetActive(value: false);
		}
	}

	private void EnableEverything()
	{
		foreach (GameObject disabledObject in disabledObjects)
		{
			disabledObject.SetActive(value: true);
		}
	}

	public void SetTimerZero()
	{
		timer = -1f;
	}

	private void DisableZombieAnimator()
	{
		for (int i = 0; i < alternativeSpawnAmount; i++)
		{
			spawnObjects[i].GetComponent<ObjectReference>().reference.gameObject.SetActive(value: false);
		}
	}

	private void EnableZombieAnimator()
	{
		for (int i = 0; i < alternativeSpawnAmount; i++)
		{
			spawnObjects[i].GetComponent<ObjectReference>().reference.gameObject.SetActive(value: true);
		}
	}

	public void PlayUnlockSound()
	{
		rep.missionUnlockAudio.Play();
	}

	public void FadeInTextOverlay()
	{
		rep.missionUnlockOverlay.SetBool("FadeIn", value: true);
		Invoke("FadeOutTextOverlay", 3f);
	}

	public void FadeOutTextOverlay()
	{
		rep.missionUnlockOverlay.SetBool("FadeIn", value: false);
	}
}
public class MissionRepresentation : MonoBehaviour
{
	[Header("Controller")]
	public Player player;

	public GameObject rocketRight;

	public GameObject rocketLeft;

	public GameObject gunRight;

	public GameObject gunLeft;

	public UnlockHelper unlockHelper;

	public GameObject ringArrow;

	[Header("UI")]
	public Text pointsText;

	public Text timerText;

	public Text starsText;

	public Text moneyText;

	public Text startMissionName;

	public Text startMissionType;

	public Text startMissionDescription;

	public Text startGoal1;

	public Text startGoal2;

	public Text startGoal3;

	public GameObject startStar1;

	public GameObject startStar2;

	public GameObject startStar3;

	public Text endMissionName;

	public Text endMissionType;

	public Text endPoints;

	public Text endTime;

	public Text endMoney;

	public Image missionPreview;

	[Header("Audio")]
	public AudioSource startAudio;

	public AudioSource beepAudio;

	public AudioSource timeUpAudio;

	public AudioSource starAudio;

	public AudioSource winAudio;

	public AudioSource loseAudio;

	public AudioSource missionUnlockAudio;

	[Header("Animators")]
	public Animator missionAnimation;

	public Animator startAnimation;

	public Animator endAnimation;

	public Animator middleBG;

	public Animator endStar1;

	public Animator endStar2;

	public Animator endStar3;

	public Animator missionIntro;

	public Animator shootIntro;

	public Animator missionUnlockOverlay;

	[Header("Particle Systems")]
	public ParticleSystem winParticle;

	public void ShowMissionUI(bool ac)
	{
		if (!endAnimation.gameObject.activeSelf)
		{
			SetAnimation(missionAnimation, ac);
		}
	}

	private void Start()
	{
		starsText.text = PlayerPrefs.GetInt(Globals.TOTALSTARS).ToString() ?? "";
		moneyText.text = PlayerPrefs.GetInt(Globals.TOTALMONEY).ToString() ?? "";
	}

	public void SetAnimation(Animator a, bool active)
	{
		if (active)
		{
			a.gameObject.SetActive(value: true);
			a.SetBool("FadeIn", value: true);
		}
		else
		{
			a.SetBool("FadeIn", value: false);
			StartCoroutine(Disable(a, 1f));
		}
	}

	public IEnumerator Disable(Animator a, float delay)
	{
		yield return new WaitForSeconds(delay);
		a.gameObject.SetActive(value: false);
	}
}
public class MissionTarget : MonoBehaviour
{
	private Mission controller;

	public bool used;

	public void Init(Mission c)
	{
		controller = c;
	}

	public void Collect(GameObject animator)
	{
		if (!used)
		{
			used = true;
			Invoke("Reset", 2f);
			controller.GetPoint(animator);
		}
	}

	public void Collect()
	{
		if (!used)
		{
			used = true;
			Invoke("Reset", 2f);
			controller.GetPoint(null);
		}
	}

	public void Reset()
	{
		used = false;
	}
}
public class ObjectReference : MonoBehaviour
{
	public GameObject reference;
}
public class PlayerPrefsManager : MonoBehaviour
{
	[Button(null)]
	public void DeleteAll()
	{
		PlayerPrefs.DeleteAll();
	}
}
public class Rotate : MonoBehaviour
{
	public float speed = 50f;

	private void Update()
	{
		base.transform.Rotate(Vector3.up, speed);
	}
}
public class StatsUpdater : MonoBehaviour
{
	public bool updateStatsRepeatingly;

	public TextMeshPro stars;

	public TextMeshPro cats;

	public TextMeshPro thruster;

	public TextMeshPro skins;

	public TextMeshPro progress;

	private void Start()
	{
		UpdateAsync();
		if (updateStatsRepeatingly)
		{
			InvokeRepeating("UpdateAsync", 5f, 5f);
		}
	}

	private void UpdateAsync()
	{
		int @int = PlayerPrefs.GetInt(Globals.TOTALSTARS);
		int int2 = PlayerPrefs.GetInt(Globals.TOTALHIDDENCATS);
		int num = PlayerPrefs.GetInt(Globals.TOTALTHRUSTER) + 1;
		int int3 = PlayerPrefs.GetInt(Globals.TOTALSKINS);
		int num2 = (@int + int2 + num + int3) / 242 * 100;
		stars.text = @int + " / 100";
		cats.text = int2 + " / 100";
		thruster.text = num.ToString() ?? "";
		skins.text = int3.ToString() ?? "";
		progress.text = num2 + " / 100%";
	}
}
public class ThrusterInventar : MonoBehaviour
{
	[Header("Debug Options")]
	public bool switchThrusterWithA;

	public bool disableThrusterLevelLoading = true;

	[Header("Values Per Point")]
	public float maxSpeedPerPoint = 1f;

	public float accelerationPerPoint = 1f;

	public float maxAltitudePerPoint = 1f;

	public float boostStrengthPerPoint = 1f;

	public float boostRegenerationPerPoint = 1f;

	public float boostCapacityPerPoint = 1f;

	[Header("Trusters")]
	public ThrusterModelClass[] trusterDefinitions;

	[Header("Representation")]
	public GameObject meshL;

	public GameObject meshR;

	public GameObject gunL;

	public GameObject gunR;

	public GameObject pointerR;

	public GameObject pointerRLaser;

	public JetPack jetpackL;

	public JetPack jetpackR;

	private int i;

	[HideInInspector]
	public int currentThrusterIndex;

	private void Start()
	{
		SetupTruster(3);
		i = 4;
		if (!disableThrusterLevelLoading)
		{
			SetThrusterLevels();
		}
	}

	public void SetupTruster(int index)
	{
		currentThrusterIndex = index;
		ThrusterModelClass thrusterModelClass = trusterDefinitions[index];
		GetComponent<Player>().level = thrusterModelClass.level;
		meshL.GetComponent<MeshFilter>().mesh = thrusterModelClass.mesh;
		meshR.GetComponent<MeshFilter>().mesh = thrusterModelClass.mesh;
		meshL.GetComponent<Renderer>().material = thrusterModelClass.materials[0];
		meshR.GetComponent<Renderer>().material = thrusterModelClass.materials[0];
		gunL.GetComponent<Renderer>().material = thrusterModelClass.gunMaterials[0];
		gunR.GetComponent<Renderer>().material = thrusterModelClass.gunMaterials[0];
		pointerR.GetComponent<Renderer>().material = thrusterModelClass.gunMaterials[0];
		meshL.GetComponent<Transform>().localScale = new Vector3(thrusterModelClass.scale, thrusterModelClass.scale, thrusterModelClass.scale);
		meshR.GetComponent<Transform>().localScale = new Vector3(thrusterModelClass.scale, thrusterModelClass.scale, thrusterModelClass.scale);
		GetComponent<Player>().maxHeight = (thrusterModelClass.baseMaxAltitude + (float)thrusterModelClass.level * thrusterModelClass.addMaxAltitude) * maxAltitudePerPoint;
		GetComponent<Player>().maxSpeed = (thrusterModelClass.baseMaxSpeed + (float)thrusterModelClass.level * thrusterModelClass.addMaxSpeed) * maxSpeedPerPoint;
		GetComponent<Player>().burstCounterSpeed = (thrusterModelClass.baseBoostRegeneration + (float)thrusterModelClass.level * thrusterModelClass.addBoostRegeneration) * boostRegenerationPerPoint;
		GetComponent<Player>().maxBurst = (thrusterModelClass.baseBoostCapacity + (float)thrusterModelClass.level * thrusterModelClass.addBoostCapacity) * boostCapacityPerPoint;
		jetpackL.rocketModifier = (thrusterModelClass.baseAcceleration + (float)thrusterModelClass.level * thrusterModelClass.addAcceleration) * accelerationPerPoint * -1f;
		jetpackR.rocketModifier = (thrusterModelClass.baseAcceleration + (float)thrusterModelClass.level * thrusterModelClass.addAcceleration) * accelerationPerPoint * -1f;
		jetpackL.boosterStrength = (thrusterModelClass.baseBoostStrength + (float)thrusterModelClass.level * thrusterModelClass.addBoostStrength) * boostStrengthPerPoint;
		jetpackR.boosterStrength = (thrusterModelClass.baseBoostStrength + (float)thrusterModelClass.level * thrusterModelClass.addBoostStrength) * boostStrengthPerPoint;
		GetComponent<Player>().burstLevel = thrusterModelClass.baseBoostStrength + (float)thrusterModelClass.level;
	}

	public void SetSkin(int ID)
	{
		ThrusterModelClass thrusterModelClass = trusterDefinitions[currentThrusterIndex];
		meshL.GetComponent<Renderer>().material = thrusterModelClass.materials[ID];
		meshR.GetComponent<Renderer>().material = thrusterModelClass.materials[ID];
		gunL.GetComponent<Renderer>().material = thrusterModelClass.gunMaterials[ID];
		gunR.GetComponent<Renderer>().material = thrusterModelClass.gunMaterials[ID];
		pointerR.GetComponent<Renderer>().material = thrusterModelClass.gunMaterials[ID];
	}

	public void SetThrusterLevels()
	{
		for (int i = 0; i < trusterDefinitions.Length; i++)
		{
			trusterDefinitions[i].level = PlayerPrefs.GetInt(Globals.THRUSTERLEVEL + i);
			SetupTruster(currentThrusterIndex);
		}
	}

	public void SetDefaultThrusterLevelsTo3()
	{
		for (int i = 0; i < trusterDefinitions.Length; i++)
		{
			PlayerPrefs.SetInt(Globals.THRUSTERLEVEL + i, 3);
		}
	}

	[Button(null)]
	public void LoadTruster0()
	{
		SetupTruster(0);
	}

	[Button(null)]
	public void LoadTruster1()
	{
		SetupTruster(1);
	}

	[Button(null)]
	public void LoadTruster2()
	{
		SetupTruster(2);
	}

	[Button(null)]
	public void LoadTruster3()
	{
		SetupTruster(3);
	}

	[Button(null)]
	public void LoadTruster4()
	{
		SetupTruster(4);
	}

	[Button(null)]
	public void LoadTruster5()
	{
		SetupTruster(5);
	}
}
[Serializable]
public class ThrusterModelClass
{
	public string name;

	public string description;

	public int level;

	public float buyPrice = 3000f;

	public float upgradePrice = 1000f;

	public Mesh mesh;

	public Material[] materials;

	public Material[] gunMaterials;

	public float[] skinPrices;

	public float scale = 0.1f;

	[Header("Base Values")]
	public float baseMaxSpeed = 1f;

	public float baseAcceleration = 1f;

	public float baseMaxAltitude = 1f;

	public float baseBoostStrength = 1f;

	public float baseBoostRegeneration = 1f;

	public float baseBoostCapacity = 1f;

	[Header("Level Up")]
	public float addMaxSpeed = 1f;

	public float addAcceleration = 1f;

	public float addMaxAltitude = 1f;

	public float addBoostStrength = 1f;

	public float addBoostRegeneration = 1f;

	public float addBoostCapacity = 1f;
}
public class ThrusterShop : MonoBehaviour
{
	[Header("General Setup")]
	public int thrusterID;

	public GameObject mainThrusterRep;

	public TextMeshPro mainPriceLabel;

	public TextMeshPro unlockSign;

	public ThrusterShopItem[] thrusters;

	public ThrusterInventar inventar;

	public ThrusterShopReferences rep;

	public GameObject[] skins;

	public GameObject[] skinPrices;

	[ReadOnly]
	public ThrusterShopItem selecteditem;

	[Header("Availability")]
	public int unlockAmount;

	public GameObject unlocked;

	public GameObject locked;

	public int state;

	private ThrusterShopItem savedSelectedItem;

	private void Start()
	{
		Invoke("LateStart", 1f);
	}

	public void LateStart()
	{
		unlockSign.text = unlockAmount + " Stars Required";
		CheckUnlockThrusterUpgrade();
		UpdateAllSkins();
		SetupSkins(inventar.currentThrusterIndex);
		CheckUnlock();
	}

	public void CheckUnlock()
	{
		if (PlayerPrefs.GetInt(Globals.TOTALSTARS) >= unlockAmount)
		{
			unlocked.SetActive(value: true);
			locked.SetActive(value: false);
		}
	}

	private bool GetA1()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A))
		{
			return true;
		}
		return false;
	}

	private bool GetA2()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A))
		{
			return true;
		}
		return false;
	}

	private bool GetB()
	{
		if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B))
		{
			return true;
		}
		return false;
	}

	private void Update()
	{
		if (state == 1)
		{
			if (GetA1() && selecteditem != null)
			{
				state = 2;
				savedSelectedItem = selecteditem;
				rep.SetAnimation(rep.thrusterSelection, active: true);
				ThrusterModelClass thrusterModelClass = inventar.trusterDefinitions[selecteditem.ID];
				rep.sHeader.text = thrusterModelClass.name;
				rep.sDescription.text = thrusterModelClass.description;
				for (int i = 0; i < 10; i++)
				{
					if (thrusterModelClass.baseMaxSpeed + thrusterModelClass.addMaxSpeed * 5f >= (float)i)
					{
						rep.sMaxSpeedImages[i].enabled = true;
					}
					else
					{
						rep.sMaxSpeedImages[i].enabled = false;
					}
					if (thrusterModelClass.baseAcceleration + thrusterModelClass.addAcceleration * 5f >= (float)i)
					{
						rep.sAccelerationImages[i].enabled = true;
					}
					else
					{
						rep.sAccelerationImages[i].enabled = false;
					}
					if (thrusterModelClass.baseMaxAltitude + thrusterModelClass.addMaxAltitude * 5f >= (float)i)
					{
						rep.sMaxAltitudeImages[i].enabled = true;
					}
					else
					{
						rep.sMaxAltitudeImages[i].enabled = false;
					}
					if (thrusterModelClass.baseBoostStrength + thrusterModelClass.addBoostStrength * 5f >= (float)i)
					{
						rep.sMaxBoost[i].enabled = true;
					}
					else
					{
						rep.sMaxBoost[i].enabled = false;
					}
					if (thrusterModelClass.baseBoostRegeneration + thrusterModelClass.addBoostRegeneration * (float)thrusterModelClass.level >= (float)i)
					{
						rep.sBoostRefill[i].enabled = true;
					}
					else
					{
						rep.sBoostRefill[i].enabled = false;
					}
					if (thrusterModelClass.baseBoostCapacity + thrusterModelClass.addBoostCapacity * 5f >= (float)i)
					{
						rep.sBoostCapacity[i].enabled = true;
					}
					else
					{
						rep.sBoostCapacity[i].enabled = false;
					}
				}
				for (int j = 0; j < 10; j++)
				{
					if (thrusterModelClass.baseMaxSpeed + thrusterModelClass.addMaxSpeed * (float)thrusterModelClass.level >= (float)j)
					{
						rep.sMaxSpeedImages[j].sprite = rep.unlocked;
					}
					else if (thrusterModelClass.baseMaxSpeed + thrusterModelClass.addMaxSpeed * 5f >= (float)j)
					{
						rep.sMaxSpeedImages[j].sprite = rep.locked;
					}
					if (thrusterModelClass.baseAcceleration + thrusterModelClass.addAcceleration * (float)thrusterModelClass.level >= (float)j)
					{
						rep.sAccelerationImages[j].sprite = rep.unlocked;
					}
					else if (thrusterModelClass.baseAcceleration + thrusterModelClass.addAcceleration * 5f >= (float)j)
					{
						rep.sAccelerationImages[j].sprite = rep.locked;
					}
					if (thrusterModelClass.baseMaxAltitude + thrusterModelClass.addMaxAltitude * (float)thrusterModelClass.level >= (float)j)
					{
						rep.sMaxAltitudeImages[j].sprite = rep.unlocked;
					}
					else if (thrusterModelClass.baseMaxAltitude + thrusterModelClass.addMaxAltitude * 5f >= (float)j)
					{
						rep.sMaxAltitudeImages[j].sprite = rep.locked;
					}
					if (thrusterModelClass.baseBoostStrength + thrusterModelClass.addBoostStrength * (float)thrusterModelClass.level >= (float)j)
					{
						rep.sMaxBoost[j].sprite = rep.unlocked;
					}
					else if (thrusterModelClass.baseBoostStrength + thrusterModelClass.addBoostStrength * 5f >= (float)j)
					{
						rep.sMaxBoost[j].sprite = rep.locked;
					}
					if (thrusterModelClass.baseBoostRegeneration + thrusterModelClass.addBoostRegeneration * (float)thrusterModelClass.level >= (float)j)
					{
						rep.sBoostRefill[j].sprite = rep.unlocked;
					}
					else if (thrusterModelClass.baseBoostRegeneration + thrusterModelClass.addBoostRegeneration * 5f >= (float)j)
					{
						rep.sBoostRefill[j].sprite = rep.locked;
					}
					if (thrusterModelClass.baseBoostCapacity + thrusterModelClass.addBoostCapacity * (float)thrusterModelClass.level >= (float)j)
					{
						rep.sBoostCapacity[j].sprite = rep.unlocked;
					}
					else if (thrusterModelClass.baseBoostCapacity + thrusterModelClass.addBoostCapacity * 5f >= (float)j)
					{
						rep.sBoostCapacity[j].sprite = rep.locked;
					}
				}
			}
		}
		else if (state == 2)
		{
			if (GetA2())
			{
				rep.SetAnimation(rep.thrusterSelection, active: false);
				inventar.SetupTruster(savedSelectedItem.ID);
				SetupSkins(savedSelectedItem.ID);
				rep.equipSound.Play();
				state = 0;
				StartCoroutine(RefreshPointer());
			}
			if (GetB())
			{
				rep.SetAnimation(rep.thrusterSelection, active: false);
				state = 0;
				StartCoroutine(RefreshPointer());
			}
		}
		if (state == 3)
		{
			if (GetA1() && selecteditem != null)
			{
				state = 4;
				savedSelectedItem = selecteditem;
				rep.SetAnimation(rep.thrusterUpdate, active: true);
				ThrusterModelClass thrusterModelClass2 = inventar.trusterDefinitions[selecteditem.ID];
				rep.pHeader.text = thrusterModelClass2.name;
				rep.pDescription.text = thrusterModelClass2.description;
				if (PlayerPrefs.GetInt(Globals.THRUSTERUNLOCKED + thrusterID) == 0)
				{
					rep.pPrice.text = ((int)inventar.trusterDefinitions[savedSelectedItem.ID].buyPrice).ToString() ?? "";
				}
				else
				{
					rep.pPrice.text = ((int)inventar.trusterDefinitions[savedSelectedItem.ID].upgradePrice).ToString() ?? "";
				}
				for (int k = 0; k < 10; k++)
				{
					if (thrusterModelClass2.baseMaxSpeed + thrusterModelClass2.addMaxSpeed * 5f >= (float)k)
					{
						rep.pMaxSpeedImages[k].enabled = true;
					}
					else
					{
						rep.pMaxSpeedImages[k].enabled = false;
					}
					if (thrusterModelClass2.baseAcceleration + thrusterModelClass2.addAcceleration * 5f >= (float)k)
					{
						rep.pAccelerationImages[k].enabled = true;
					}
					else
					{
						rep.pAccelerationImages[k].enabled = false;
					}
					if (thrusterModelClass2.baseMaxAltitude + thrusterModelClass2.addMaxAltitude * 5f >= (float)k)
					{
						rep.pMaxAltitudeImages[k].enabled = true;
					}
					else
					{
						rep.pMaxAltitudeImages[k].enabled = false;
					}
					if (thrusterModelClass2.baseBoostStrength + thrusterModelClass2.addBoostStrength * 5f >= (float)k)
					{
						rep.pMaxBoost[k].enabled = true;
					}
					else
					{
						rep.pMaxBoost[k].enabled = false;
					}
					if (thrusterModelClass2.baseBoostRegeneration + thrusterModelClass2.addBoostRegeneration * 5f >= (float)k)
					{
						rep.pBoostRefill[k].enabled = true;
					}
					else
					{
						rep.pBoostRefill[k].enabled = false;
					}
					if (thrusterModelClass2.baseBoostCapacity + thrusterModelClass2.addBoostCapacity * 5f >= (float)k)
					{
						rep.pBoostCapacity[k].enabled = true;
					}
					else
					{
						rep.pBoostCapacity[k].enabled = false;
					}
				}
				for (int l = 0; l < 10; l++)
				{
					if (thrusterModelClass2.baseMaxSpeed + thrusterModelClass2.addMaxSpeed * (float)thrusterModelClass2.level >= (float)l)
					{
						rep.pMaxSpeedImages[l].sprite = rep.unlocked;
					}
					else if (thrusterModelClass2.baseMaxSpeed + thrusterModelClass2.addMaxSpeed * (float)(thrusterModelClass2.level + 1) >= (float)l)
					{
						rep.pMaxSpeedImages[l].sprite = rep.toBeUnlocked;
					}
					else if (thrusterModelClass2.baseMaxSpeed + thrusterModelClass2.addMaxSpeed * 5f >= (float)l)
					{
						rep.pMaxSpeedImages[l].sprite = rep.locked;
					}
					if (thrusterModelClass2.baseAcceleration + thrusterModelClass2.addAcceleration * (float)thrusterModelClass2.level >= (float)l)
					{
						rep.pAccelerationImages[l].sprite = rep.unlocked;
					}
					else if (thrusterModelClass2.baseAcceleration + thrusterModelClass2.addAcceleration * (float)(thrusterModelClass2.level + 1) >= (float)l)
					{
						rep.pAccelerationImages[l].sprite = rep.toBeUnlocked;
					}
					else if (thrusterModelClass2.baseAcceleration + thrusterModelClass2.addAcceleration * 5f >= (float)l)
					{
						rep.pAccelerationImages[l].sprite = rep.locked;
					}
					if (thrusterModelClass2.baseMaxAltitude + thrusterModelClass2.addMaxAltitude * (float)thrusterModelClass2.level >= (float)l)
					{
						rep.pMaxAltitudeImages[l].sprite = rep.unlocked;
					}
					else if (thrusterModelClass2.baseMaxAltitude + thrusterModelClass2.addMaxAltitude * (float)(thrusterModelClass2.level + 1) >= (float)l)
					{
						rep.pMaxAltitudeImages[l].sprite = rep.toBeUnlocked;
					}
					else if (thrusterModelClass2.baseMaxAltitude + thrusterModelClass2.addMaxAltitude * 5f >= (float)l)
					{
						rep.pMaxAltitudeImages[l].sprite = rep.locked;
					}
					if (thrusterModelClass2.baseBoostStrength + thrusterModelClass2.addBoostStrength * (float)thrusterModelClass2.level >= (float)l)
					{
						rep.pMaxBoost[l].sprite = rep.unlocked;
					}
					else if (thrusterModelClass2.baseBoostStrength + thrusterModelClass2.addBoostStrength * (float)(thrusterModelClass2.level + 1) >= (float)l)
					{
						rep.pMaxBoost[l].sprite = rep.toBeUnlocked;
					}
					else if (thrusterModelClass2.baseBoostStrength + thrusterModelClass2.addBoostStrength * 5f >= (float)l)
					{
						rep.pMaxBoost[l].sprite = rep.locked;
					}
					if (thrusterModelClass2.baseBoostRegeneration + thrusterModelClass2.addBoostRegeneration * (float)thrusterModelClass2.level >= (float)l)
					{
						rep.pBoostRefill[l].sprite = rep.unlocked;
					}
					else if (thrusterModelClass2.baseBoostRegeneration + thrusterModelClass2.addBoostRegeneration * (float)(thrusterModelClass2.level + 1) >= (float)l)
					{
						rep.pBoostRefill[l].sprite = rep.toBeUnlocked;
					}
					else if (thrusterModelClass2.baseBoostRegeneration + thrusterModelClass2.addBoostRegeneration * 5f >= (float)l)
					{
						rep.pBoostRefill[l].sprite = rep.locked;
					}
					if (thrusterModelClass2.baseBoostCapacity + thrusterModelClass2.addBoostCapacity * (float)thrusterModelClass2.level >= (float)l)
					{
						rep.pBoostCapacity[l].sprite = rep.unlocked;
					}
					else if (thrusterModelClass2.baseBoostCapacity + thrusterModelClass2.addBoostCapacity * (float)(thrusterModelClass2.level + 1) >= (float)l)
					{
						rep.pBoostCapacity[l].sprite = rep.toBeUnlocked;
					}
					else if (thrusterModelClass2.baseBoostCapacity + thrusterModelClass2.addBoostCapacity * 5f >= (float)l)
					{
						rep.pBoostCapacity[l].sprite = rep.locked;
					}
				}
			}
		}
		else if (state == 4)
		{
			if (GetA2())
			{
				if ((PlayerPrefs.GetInt(Globals.THRUSTERUNLOCKED + thrusterID) == 0 && (float)PlayerPrefs.GetInt(Globals.TOTALMONEY) >= inventar.trusterDefinitions[savedSelectedItem.ID].buyPrice) || (PlayerPrefs.GetInt(Globals.THRUSTERUNLOCKED + thrusterID) > 0 && (float)PlayerPrefs.GetInt(Globals.TOTALMONEY) >= inventar.trusterDefinitions[savedSelectedItem.ID].upgradePrice))
				{
					rep.SetAnimation(rep.thrusterUpdate, active: false);
					if (PlayerPrefs.GetInt(Globals.THRUSTERUNLOCKED + thrusterID) == 0)
					{
						PlayerPrefs.SetInt(Globals.TOTALMONEY, PlayerPrefs.GetInt(Globals.TOTALMONEY) - (int)inventar.trusterDefinitions[savedSelectedItem.ID].buyPrice);
						PlayerPrefs.Save();
						rep.moneyText.text = PlayerPrefs.GetInt(Globals.TOTALMONEY) + "$";
						UnityEngine.Debug.LogError("Buy Item");
						PlayerPrefs.SetInt(Globals.TOTALTHRUSTER, PlayerPrefs.GetInt(Globals.TOTALTHRUSTER) + 1);
						PlayerPrefs.SetInt(Globals.THRUSTERUNLOCKED + thrusterID, 1);
						PlayerPrefs.Save();
					}
					else
					{
						PlayerPrefs.SetInt(Globals.TOTALMONEY, PlayerPrefs.GetInt(Globals.TOTALMONEY) - (int)inventar.trusterDefinitions[savedSelectedItem.ID].upgradePrice);
						PlayerPrefs.Save();
						rep.moneyText.text = PlayerPrefs.GetInt(Globals.TOTALMONEY) + "$";
						PlayerPrefs.SetInt(Globals.THRUSTERLEVEL + thrusterID, PlayerPrefs.GetInt(Globals.THRUSTERLEVEL + thrusterID) + 1);
						PlayerPrefs.Save();
						UnityEngine.Debug.LogError("Buy Item to level: " + PlayerPrefs.GetInt(Globals.THRUSTERLEVEL + thrusterID));
					}
					inventar.SetThrusterLevels();
					UpdateAllThrusters();
					CheckUnlockThrusterUpgrade();
					state = 0;
					StartCoroutine(RefreshPointer());
					rep.winParticle.Play();
					rep.winAudio.Play();
				}
				else
				{
					rep.SetAnimation(rep.thrusterUpdate, active: false);
					state = 0;
					StartCoroutine(RefreshPointer());
					rep.failAudio.Play();
				}
			}
			if (GetB())
			{
				rep.SetAnimation(rep.thrusterUpdate, active: false);
				state = 0;
				StartCoroutine(RefreshPointer());
			}
		}
		if (state == 5)
		{
			if (GetA1() && selecteditem != null)
			{
				if (Globals.GetSkinUnlocked(inventar.currentThrusterIndex, selecteditem.ID))
				{
					inventar.SetSkin(selecteditem.ID);
					state = 0;
					StartCoroutine(RefreshPointer());
				}
				else
				{
					state = 6;
					savedSelectedItem = selecteditem;
					rep.SetAnimation(rep.skinPurchase, active: true);
					ThrusterModelClass thrusterModelClass3 = inventar.trusterDefinitions[inventar.currentThrusterIndex];
					rep.dPrice.text = thrusterModelClass3.skinPrices[savedSelectedItem.ID].ToString();
				}
			}
		}
		else
		{
			if (state != 6)
			{
				return;
			}
			if (GetA2())
			{
				if ((float)PlayerPrefs.GetInt(Globals.TOTALMONEY) >= inventar.trusterDefinitions[inventar.currentThrusterIndex].skinPrices[savedSelectedItem.ID])
				{
					PlayerPrefs.SetInt(Globals.TOTALMONEY, PlayerPrefs.GetInt(Globals.TOTALMONEY) - (int)inventar.trusterDefinitions[inventar.currentThrusterIndex].skinPrices[savedSelectedItem.ID]);
					PlayerPrefs.Save();
					rep.moneyText.text = PlayerPrefs.GetInt(Globals.TOTALMONEY) + "$";
					rep.SetAnimation(rep.skinPurchase, active: false);
					UnityEngine.Debug.LogError("Buy Skin");
					PlayerPrefs.SetInt(Globals.TOTALSKINS, PlayerPrefs.GetInt(Globals.TOTALSKINS) + 1);
					Globals.SetSkinUnlocked(inventar.currentThrusterIndex, savedSelectedItem.ID, 1);
					PlayerPrefs.Save();
					inventar.SetSkin(savedSelectedItem.ID);
					skinPrices[savedSelectedItem.ID].SetActive(value: false);
					state = 0;
					StartCoroutine(RefreshPointer());
					rep.winParticle.Play();
					rep.winAudio.Play();
				}
				else
				{
					rep.SetAnimation(rep.skinPurchase, active: false);
					state = 0;
					StartCoroutine(RefreshPointer());
					rep.failAudio.Play();
				}
			}
			if (GetB())
			{
				rep.SetAnimation(rep.skinPurchase, active: false);
				state = 0;
				StartCoroutine(RefreshPointer());
			}
		}
	}

	public void UpdateAllThrusters()
	{
		ThrusterShopItem[] array = thrusters;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CheckUnlock();
		}
		SetupSkins(inventar.currentThrusterIndex);
	}

	public void UpdateAllSkins()
	{
		for (int i = 0; i < skins.Length; i++)
		{
			skinPrices[i].SetActive(Globals.GetSkinUnlocked(inventar.currentThrusterIndex, i));
		}
	}

	public void CheckUnlockThrusterUpgrade()
	{
		if (LocalizationManager.CurrentLanguageCode == "zh")
		{
			mainPriceLabel.text = "";
		}
		else if (LocalizationManager.CurrentLanguageCode == "ja")
		{
			mainPriceLabel.text = "";
		}
		else if (LocalizationManager.CurrentLanguageCode == "ko")
		{
			mainPriceLabel.text = "  ";
		}
		else
		{
			mainPriceLabel.text = "BUY & Upgrade!";
		}
		if (PlayerPrefs.GetInt(Globals.THRUSTERLEVEL + thrusterID) >= 5)
		{
			mainThrusterRep.SetActive(value: false);
			if (LocalizationManager.CurrentLanguageCode == "zh")
			{
				mainPriceLabel.text = "";
			}
			else if (LocalizationManager.CurrentLanguageCode == "ja")
			{
				mainPriceLabel.text = "";
			}
			else if (LocalizationManager.CurrentLanguageCode == "ko")
			{
				mainPriceLabel.text = "";
			}
			else
			{
				mainPriceLabel.text = "Sold Out";
			}
		}
	}

	public void SetupSkins(int ID)
	{
		ThrusterModelClass thrusterModelClass = inventar.trusterDefinitions[ID];
		for (int i = 0; i < skins.Length; i++)
		{
			if (i < thrusterModelClass.materials.Length)
			{
				skins[i].SetActive(value: true);
				skins[i].GetComponent<Renderer>().material = thrusterModelClass.materials[i];
				skins[i].GetComponent<MeshFilter>().mesh = thrusterModelClass.mesh;
				if (Globals.GetSkinUnlocked(inventar.currentThrusterIndex, i))
				{
					skinPrices[i].SetActive(value: false);
					continue;
				}
				skinPrices[i].SetActive(value: true);
				skinPrices[i].GetComponent<Text>().text = thrusterModelClass.skinPrices[i].ToString() ?? "";
			}
			else
			{
				skins[i].SetActive(value: false);
				skinPrices[i].SetActive(value: false);
			}
		}
	}

	public void SetState_In(int i)
	{
		if (state != 2 && state != 4 && state != 6)
		{
			state = i;
		}
	}

	public IEnumerator RefreshPointer()
	{
		selecteditem = null;
		inventar.pointerRLaser.SetActive(value: false);
		yield return new WaitForSeconds(1f);
		inventar.pointerRLaser.SetActive(value: true);
	}

	public void CloseShop()
	{
		state = 0;
		selecteditem = null;
		rep.thrusterSelection.SetBool("FadeIn", value: false);
		rep.thrusterPurchase.SetBool("FadeIn", value: false);
		rep.thrusterUpdate.SetBool("FadeIn", value: false);
		rep.skinPurchase.SetBool("FadeIn", value: false);
	}
}
public class ThrusterShopItem : MonoBehaviour
{
	public enum ItemType
	{
		OldThruster,
		NewThruster,
		Skin
	}

	public ItemType itemType;

	public int ID;

	public bool useUnlock;

	public GameObject unlockedObject;

	public GameObject lockedObject;

	public ThrusterShop shop;

	private void Start()
	{
		Invoke("LateStart", 1f);
	}

	public void LateStart()
	{
		CheckUnlock();
	}

	public void CheckUnlock()
	{
		if (itemType != ItemType.NewThruster && itemType != ItemType.Skin)
		{
			unlockedObject.SetActive(value: true);
			lockedObject.SetActive(value: false);
			if (useUnlock && PlayerPrefs.GetInt(Globals.THRUSTERUNLOCKED + ID) == 0)
			{
				unlockedObject.SetActive(value: false);
				lockedObject.SetActive(value: true);
			}
		}
	}

	public void Select()
	{
		UnityEngine.Debug.Log("IN");
		if (shop.selecteditem != null && Vector3.Distance(base.transform.position, shop.inventar.transform.position) < Vector3.Distance(shop.selecteditem.transform.position, shop.inventar.transform.position))
		{
			shop.selecteditem = this;
			if (itemType == ItemType.OldThruster)
			{
				shop.SetState_In(1);
			}
			if (itemType == ItemType.NewThruster)
			{
				shop.SetState_In(3);
			}
			if (itemType == ItemType.Skin)
			{
				shop.SetState_In(5);
			}
		}
		if (shop.selecteditem == null)
		{
			shop.selecteditem = this;
			if (itemType == ItemType.OldThruster)
			{
				shop.SetState_In(1);
			}
			if (itemType == ItemType.NewThruster)
			{
				shop.SetState_In(3);
			}
			if (itemType == ItemType.Skin)
			{
				shop.SetState_In(5);
			}
		}
	}

	public void Unselect()
	{
		if (shop.selecteditem == this)
		{
			shop.selecteditem = null;
		}
	}
}
public class ThrusterShopPointer : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<ThrusterShopItem>() != null)
		{
			other.GetComponent<ThrusterShopItem>().Select();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.GetComponent<ThrusterShopItem>() != null)
		{
			other.GetComponent<ThrusterShopItem>().Unselect();
		}
	}
}
public class ThrusterShopReferences : MonoBehaviour
{
	[Header("Player")]
	public Text moneyText;

	public Player player;

	[Header("Animators")]
	public Animator thrusterSelection;

	public Animator thrusterPurchase;

	public Animator thrusterUpdate;

	public Animator skinPurchase;

	[Header("Thruster Selection")]
	public Text sHeader;

	public Text sDescription;

	public Image[] sMaxSpeedImages;

	public Image[] sAccelerationImages;

	public Image[] sMaxAltitudeImages;

	public Image[] sMaxBoost;

	public Image[] sBoostRefill;

	public Image[] sBoostCapacity;

	[Header("Thruster Purchase & Upgrade")]
	public Text pHeader;

	public Text pDescription;

	public Text pPrice;

	public Image[] pMaxSpeedImages;

	public Image[] pAccelerationImages;

	public Image[] pMaxAltitudeImages;

	public Image[] pMaxBoost;

	public Image[] pBoostRefill;

	public Image[] pBoostCapacity;

	[Header("Design Purchase")]
	public Text dHeader;

	public Text dDescription;

	public Text dPrice;

	[Header("Prototype Designs")]
	public Sprite unlocked;

	public Sprite toBeUnlocked;

	public Sprite locked;

	public Sprite unreachable;

	[Header("Particle Systems")]
	public ParticleSystem winParticle;

	[Header("Audio")]
	public AudioSource winAudio;

	public AudioSource failAudio;

	public AudioSource equipSound;

	public void SetAnimation(Animator a, bool active)
	{
		if (active)
		{
			a.gameObject.SetActive(value: true);
			a.SetBool("FadeIn", value: true);
		}
		else
		{
			a.SetBool("FadeIn", value: false);
			StartCoroutine(Disable(a, 1f));
		}
	}

	public IEnumerator Disable(Animator a, float delay)
	{
		yield return new WaitForSeconds(delay);
		a.gameObject.SetActive(value: false);
	}
}
public class TriggerActivator : MonoBehaviour
{
	public new string tag = "Player";

	public bool onlyActivateOnButton;

	public UnityEvent collectTrigger;

	public UnityEvent onTriggerExit;

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == tag)
		{
			if (onlyActivateOnButton)
			{
				other.GetComponent<Player>().currentActivator = this;
			}
			else
			{
				Activate();
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == tag)
		{
			onTriggerExit.Invoke();
			if (onlyActivateOnButton)
			{
				other.GetComponent<Player>().currentActivator = null;
			}
		}
	}

	public void Activate()
	{
		collectTrigger.Invoke();
	}
}
public class UnlockHelper : MonoBehaviour
{
	public AudioSource starUnlockAudio;

	public Animator textOverlay;

	public Text starsText;

	private List<ThrusterShop> shops;

	private List<Mission> missions;

	private void Start()
	{
		shops = new List<ThrusterShop>();
		missions = new List<Mission>();
		ThrusterShop[] array = UnityEngine.Object.FindObjectsOfType<ThrusterShop>();
		foreach (ThrusterShop item in array)
		{
			shops.Add(item);
		}
		Mission[] array2 = UnityEngine.Object.FindObjectsOfType<Mission>();
		foreach (Mission item2 in array2)
		{
			missions.Add(item2);
		}
	}

	public void CheckUnlock()
	{
		starsText.text = PlayerPrefs.GetInt(Globals.TOTALSTARS).ToString() ?? "";
		foreach (ThrusterShop shop in shops)
		{
			shop.CheckUnlock();
		}
		foreach (Mission mission in missions)
		{
			mission.CheckUnlock();
		}
	}

	public bool NewMissionUnlocked(int oldStars, int newStars)
	{
		foreach (Mission mission in missions)
		{
			if (mission.unlockAmount > oldStars && mission.unlockAmount < oldStars + newStars)
			{
				return true;
			}
		}
		return false;
	}

	public void PlayUnlockSound()
	{
		starUnlockAudio.Play();
	}

	public void FadeInTextOverlay()
	{
		textOverlay.SetBool("FadeIn", value: true);
		Invoke("FadeOutTextOverlay", 3f);
	}

	public void FadeOutTextOverlay()
	{
		textOverlay.SetBool("FadeIn", value: false);
	}
}
public class LanguageChanger : MonoBehaviour
{
	public AudioSource audio;

	private bool used;

	private void Update()
	{
		if (!used)
		{
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A))
			{
				LocalizationManager.CurrentLanguageCode = "en";
				PlayerPrefs.SetString("Language", "en");
				PlayerPrefs.Save();
				used = true;
				audio.Play();
				SceneManager.LoadSceneAsync(1);
			}
			if (Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.B))
			{
				LocalizationManager.CurrentLanguageCode = "zh";
				PlayerPrefs.SetString("Language", "zh");
				PlayerPrefs.Save();
				used = true;
				audio.Play();
				SceneManager.LoadSceneAsync(1);
			}
			if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X))
			{
				LocalizationManager.CurrentLanguageCode = "ko";
				PlayerPrefs.SetString("Language", "ko");
				PlayerPrefs.Save();
				used = true;
				audio.Play();
				SceneManager.LoadSceneAsync(1);
			}
			if (Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.Y))
			{
				LocalizationManager.CurrentLanguageCode = "ja";
				PlayerPrefs.SetString("Language", "ja");
				PlayerPrefs.Save();
				used = true;
				audio.Play();
				SceneManager.LoadSceneAsync(1);
			}
		}
	}
}
public class LanguageUpdater : MonoBehaviour
{
	private void Update()
	{
		LocalizationManager.CurrentLanguageCode = PlayerPrefs.GetString("Language");
	}
}
public class CinemaController : MonoBehaviour
{
	public GameObject text;

	public float textSpeed;

	public float delayBeforeText;

	public float delayBeforeSceneChange;

	private float counter;

	private bool used;

	private void Start()
	{
	}

	private void Update()
	{
		counter += Time.deltaTime;
		if (counter > delayBeforeText)
		{
			text.transform.position = text.transform.position + Vector3.up * textSpeed;
		}
		if (counter > delayBeforeSceneChange && !used)
		{
			used = true;
			SceneManager.LoadSceneAsync(0);
		}
	}
}
public class EpiAnimatorHelper : MonoBehaviour
{
	public Animator[] animators;

	private void Update()
	{
		Animator[] array = animators;
		foreach (Animator animator in array)
		{
			if (animator.GetBool("FadeIn"))
			{
				animator.gameObject.SetActive(value: true);
			}
			else
			{
				animator.gameObject.SetActive(value: false);
			}
		}
	}
}
public class EpiLevelLoader : MonoBehaviour
{
	public Animator fadeOver;

	private bool used;

	public void LoadLevel(int ID)
	{
		if (!used)
		{
			used = true;
			FadeIn();
			StartCoroutine(LoadLevelAsync(ID, 1f));
		}
	}

	public IEnumerator LoadLevelAsync(int ID, float delay)
	{
		yield return new WaitForSeconds(delay);
		UnityEngine.AsyncOperation AO = SceneManager.LoadSceneAsync(ID, LoadSceneMode.Single);
		AO.allowSceneActivation = false;
		while (AO.progress < 0.9f)
		{
			yield return null;
		}
		AO.allowSceneActivation = true;
	}

	public void FadeIn()
	{
		fadeOver.SetBool("FadeIn", value: true);
	}
}
public class EpiVRMenu : MonoBehaviour
{
	[ReadOnly]
	public SelectionBox activeBox;

	public AudioMixer mainMixer;

	public Text volume;

	public Text sfx;

	public Text music;

	public Text quality;

	private int currentQuality;

	private void Start()
	{
	}

	private void Update()
	{
		if ((Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.A) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.X) || Controller.UPvr_GetKeyDown(0, Pvr_KeyCode.TRIGGER) || Controller.UPvr_GetKeyDown(1, Pvr_KeyCode.TRIGGER)) && activeBox != null)
		{
			activeBox.Activate();
		}
	}

	public void LoadScene(int i)
	{
		SceneManager.LoadSceneAsync(i);
	}

	public void Quit()
	{
		Application.Quit();
	}

	public void ChangeVolume(float value)
	{
		float value2 = 0f;
		mainMixer.GetFloat("Volume", out value2);
		value2 += value;
		mainMixer.SetFloat("Volume", value2);
		volume.text = (100f + value2).ToString() ?? "";
	}

	public void ChangeSfx(float value)
	{
		float value2 = 0f;
		mainMixer.GetFloat("Sfx", out value2);
		value2 += value;
		mainMixer.SetFloat("Sfx", value2);
		sfx.text = (100f + value2).ToString() ?? "";
	}

	public void ChangeMusic(float value)
	{
		float value2 = 0f;
		mainMixer.GetFloat("Music", out value2);
		value2 += value;
		mainMixer.SetFloat("Music", value2);
		music.text = (100f + value2).ToString() ?? "";
	}
}
public class SelectionBox : MonoBehaviour
{
	public EpiVRMenu controller;

	public string activationTag = "Selector";

	public bool onlyOnce;

	public UnityEvent hoverTrigger;

	public UnityEvent hoverExitTrigger;

	public UnityEvent clickTrigger;

	private bool used;

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == activationTag)
		{
			controller.activeBox = this;
			hoverTrigger.Invoke();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.tag == activationTag)
		{
			controller.activeBox = null;
			hoverExitTrigger.Invoke();
		}
	}

	public void Activate()
	{
		if (!onlyOnce || (onlyOnce && !used))
		{
			used = true;
			clickTrigger.Invoke();
		}
	}
}
public class EpiStickyFeed : MonoBehaviour
{
	public PhysicMaterial normal;

	public PhysicMaterial sticky;

	private void OnTriggerEnter(Collider other)
	{
		if (other.GetComponent<Collider>() != null)
		{
			other.GetComponent<Collider>().material = sticky;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.GetComponent<Collider>() != null)
		{
			other.GetComponent<Collider>().material = normal;
		}
	}
}
public class OVRAdditionalSettings : MonoBehaviour
{
}
public class OVRDisablePP : MonoBehaviour
{
	private void Start()
	{
		GetComponent<PostProcessLayer>().enabled = false;
	}
}
public class OculusController : MonoBehaviour
{
	public GameObject controllerL;

	public GameObject controllerR;

	private bool lastInputFocus;

	private bool lastPresent;
}
public class OculusStarter : EpiGenericSingleton<OculusStarter>
{
}
public class SizeUpdater : MonoBehaviour
{
	[SerializeField]
	public Vector3 size;

	private void Update()
	{
		base.gameObject.transform.localScale = size;
	}
}
public class LanguageObjectChanger : MonoBehaviour
{
	public GameObject en;

	public GameObject zh;

	public GameObject ja;

	public GameObject ko;

	private void Start()
	{
		en.SetActive(value: false);
		zh.SetActive(value: false);
		ja.SetActive(value: false);
		ko.SetActive(value: false);
		if (LocalizationManager.CurrentLanguageCode == "zh")
		{
			zh.SetActive(value: true);
		}
		else if (LocalizationManager.CurrentLanguageCode == "ja")
		{
			ja.SetActive(value: true);
		}
		else if (LocalizationManager.CurrentLanguageCode == "ko")
		{
			ko.SetActive(value: true);
		}
		else
		{
			en.SetActive(value: true);
		}
	}
}
public class PicoNeoObjectChanger : MonoBehaviour
{
	public bool enableForPicoNeo3;

	public bool enableForEverythingElse;

	private void Start()
	{
		if (Controller.UPvr_GetDeviceType() == 5)
		{
			if (enableForPicoNeo3)
			{
				base.gameObject.SetActive(value: true);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
		else if (enableForEverythingElse)
		{
			base.gameObject.SetActive(value: true);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class ViveModifier : MonoBehaviour
{
	public GameObject cam;

	private void Start()
	{
		Invoke("AdjustHeight", 0.1f);
	}

	public void AdjustHeight()
	{
	}
}
public class ViveObjectExchanger : MonoBehaviour
{
	public GameObject oculusObject;

	public GameObject viveObject;

	public GameObject picoObject;

	public void Start()
	{
		if (oculusObject != null)
		{
			oculusObject.SetActive(value: false);
		}
		if (viveObject != null)
		{
			viveObject.SetActive(value: false);
		}
		if (picoObject != null)
		{
			picoObject.SetActive(value: true);
		}
	}
}
public class InfoAttribute : PropertyAttribute
{
}
public class ReadOnlyAttribute : PropertyAttribute
{
}
[AddComponentMenu("WTF/OVNote")]
public class EpiNote : MonoBehaviour
{
	[Space(10f)]
	[SerializeField]
	[TextArea(7, 7)]
	private string note;

	[ContextMenu("Clear Text")]
	private void Clear()
	{
		note = "";
	}
}
public class EpiGenericSingleton<T> : MonoBehaviour where T : UnityEngine.Component
{
	private static T instance;

	public static T Instance
	{
		get
		{
			if (instance == null)
			{
				instance = UnityEngine.Object.FindObjectOfType<T>();
				if (instance == null)
				{
					instance = new GameObject
					{
						name = typeof(T).Name
					}.AddComponent<T>();
				}
			}
			return instance;
		}
	}

	public virtual void Awake()
	{
		if (instance == null)
		{
			instance = this as T;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class FPSCounter : MonoBehaviour
{
	[SerializeField]
	private Text _fpsText;

	[SerializeField]
	private float _hudRefreshRate = 1f;

	private float _timer;

	private void Update()
	{
		if (Time.unscaledTime > _timer)
		{
			int num = (int)(1f / Time.unscaledDeltaTime);
			_fpsText.text = "FPS: " + num;
			_timer = Time.unscaledTime + _hudRefreshRate;
		}
	}
}
public class EpiMenuController : EpiGenericSingleton<EpiMenuController>
{
	public enum State
	{
		MainMenu,
		PauseMenu,
		NoMenu
	}

	private State state;

	public int firstScene;

	[Header("Event System")]
	public EventSystem eventSystem;

	public Animator loadingCanvas;

	public Animator mainMenuCanvas;

	public Animator pauseMenuCanvas;

	public GameObject firstMainMenuResponder;

	public GameObject firstPauseMenuResponder;

	[Header("Audio")]
	public AudioMixer mixer;

	public AudioSource hoverAudio;

	public AudioSource clickAudio;

	public Slider volumeSlider;

	public Slider sfxSlider;

	public Slider musicSlider;

	[Header("Resolution")]
	public Text resolutionText;

	public Text qualityText;

	private int currentResolution;

	private int currentQuality;

	[Header("Mouse Settings")]
	public Slider mouseSlider;

	public Toggle mouseInvertToggle;

	private void OnEnable()
	{
		SceneManager.sceneLoaded += OnSceneLoaded;
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		if (SceneManager.GetActiveScene().Equals(SceneManager.GetSceneByBuildIndex(firstScene)))
		{
			state = State.MainMenu;
			FadeIn(mainMenuCanvas);
			Select(firstMainMenuResponder);
		}
		else
		{
			state = State.NoMenu;
		}
		FadeOut(loadingCanvas);
	}

	private void Start()
	{
		Load();
		if (Input.GetJoystickNames().Length != 0)
		{
			eventSystem.GetComponent<StandaloneInputModule>().forceModuleActive = true;
			eventSystem.SetSelectedGameObject(firstMainMenuResponder);
		}
	}

	private void OnDisable()
	{
		SceneManager.sceneLoaded -= OnSceneLoaded;
	}

	private void Update()
	{
		if (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f))
		{
			loadingCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f);
		}
		if (!SceneManager.GetActiveScene().Equals(SceneManager.GetSceneByBuildIndex(firstScene)) && (Input.GetKeyDown(KeyCode.Escape) || Input.GetKeyDown(KeyCode.JoystickButton7) || Input.GetKeyDown(KeyCode.Joystick1Button7)))
		{
			Pause();
			Resume();
		}
	}

	public void Load()
	{
		if (PlayerPrefs.GetInt("LAUNCHEDBEFORE") == 1)
		{
			SetSlider(volumeSlider, PlayerPrefs.GetFloat("VOLUME"));
			SetSlider(musicSlider, PlayerPrefs.GetFloat("MUSIC"));
			SetSlider(sfxSlider, PlayerPrefs.GetFloat("SFX"));
			currentResolution = PlayerPrefs.GetInt("RESOLUTION");
			currentQuality = PlayerPrefs.GetInt("QUALITY");
		}
		else
		{
			PlayerPrefs.SetInt("LAUNCHEDBEFORE", 1);
			SetSlider(volumeSlider, 0f);
			SetSlider(musicSlider, 0f);
			SetSlider(sfxSlider, 0f);
			PlayerPrefs.SetInt("RESOLUTION", Screen.resolutions.Length - 1);
			currentResolution = Screen.resolutions.Length - 1;
			PlayerPrefs.SetInt("QUALITY", Screen.resolutions.Length - 1);
			currentQuality = Screen.resolutions.Length - 1;
			PlayerPrefs.Save();
		}
		if (currentResolution >= Screen.resolutions.Length)
		{
			currentResolution = Screen.resolutions.Length - 1;
		}
		ChangeResolution(0);
		if (currentQuality >= QualitySettings.names.Length)
		{
			currentQuality = QualitySettings.names.Length - 1;
		}
		ChangeQuality(0);
	}

	public void SetSlider(Slider slider, float value)
	{
		slider.value = value;
	}

	public void SetVolume(float value)
	{
		mixer.SetFloat("Volume", value);
		PlayerPrefs.SetFloat("VOLUME", value);
		PlayerPrefs.Save();
	}

	public void SetSfx(float value)
	{
		mixer.SetFloat("Sfx", value);
		PlayerPrefs.SetFloat("SFX", value);
		PlayerPrefs.Save();
	}

	public void SetMusic(float value)
	{
		mixer.SetFloat("Music", value);
		PlayerPrefs.SetFloat("MUSIC", value);
		PlayerPrefs.Save();
	}

	public void SetMouseSens(float value)
	{
		PlayerPrefs.SetFloat("MOUSE", value);
		PlayerPrefs.Save();
	}

	public void SetMouseInvert(bool value)
	{
		int value2 = 0;
		if (value)
		{
			value2 = 1;
		}
		PlayerPrefs.SetInt("INVERT", value2);
		PlayerPrefs.Save();
	}

	public void ChangeResolution(int i)
	{
		currentResolution += i;
		if (currentResolution >= Screen.resolutions.Length)
		{
			currentResolution = 0;
		}
		else if (currentResolution < 0)
		{
			currentResolution = Screen.resolutions.Length - 1;
		}
		Screen.SetResolution(Screen.resolutions[currentResolution].width, Screen.resolutions[currentResolution].height, fullscreen: true);
		resolutionText.text = Screen.resolutions[currentResolution].ToString();
		PlayerPrefs.SetInt("RESOLUTION", currentResolution);
		PlayerPrefs.Save();
	}

	public void ChangeQuality(int i)
	{
	}

	public void LoadLevel(int i)
	{
		FadeIn(loadingCanvas);
		Time.timeScale = 0f;
		SceneManager.LoadScene(i);
	}

	public void Quit(bool sure)
	{
		Application.Quit();
	}

	public void Resume()
	{
		if (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(1f))
		{
			Unselect();
			state = State.NoMenu;
			FadeOut(pauseMenuCanvas);
		}
	}

	public void Pause()
	{
		if (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f))
		{
			Select(firstPauseMenuResponder);
			state = State.PauseMenu;
			FadeIn(pauseMenuCanvas);
			Time.timeScale = 0f;
		}
	}

	private void StopKeyBlock(CanvasGroup canvasGroup)
	{
		canvasGroup.blocksRaycasts = false;
	}

	public void FadeIn(Animator animator)
	{
		animator.SetBool("FadeIn", value: true);
	}

	public void FadeOut(Animator animator)
	{
		animator.SetBool("FadeIn", value: false);
	}

	public void FadeInFirstMenu()
	{
		if (state == State.MainMenu)
		{
			FadeIn(mainMenuCanvas);
			Select(firstMainMenuResponder);
		}
		else
		{
			FadeIn(pauseMenuCanvas);
			Select(firstPauseMenuResponder);
		}
	}

	public void Unselect()
	{
		if (Input.GetJoystickNames().Length != 0)
		{
			BaseEventData eventData = new BaseEventData(eventSystem);
			if (eventSystem != null && eventSystem.currentSelectedGameObject != null && eventSystem.currentSelectedGameObject.GetComponent<Selectable>() != null)
			{
				eventSystem.currentSelectedGameObject.GetComponent<Selectable>().OnDeselect(eventData);
			}
		}
	}

	public void Select(GameObject g)
	{
		if (Input.GetJoystickNames().Length != 0)
		{
			Unselect();
			StartCoroutine(SelectDelayed(g));
		}
	}

	private IEnumerator SelectDelayed(GameObject g)
	{
		yield return new WaitForSeconds(0.05f);
		eventSystem.SetSelectedGameObject(g);
		BaseEventData eventData = new BaseEventData(eventSystem);
		g.GetComponent<Selectable>().OnSelect(eventData);
	}

	public void SetEventSystem(GameObject g)
	{
		eventSystem.SetSelectedGameObject(g);
	}

	public void PlayHoverSound()
	{
		if (!hoverAudio.isPlaying)
		{
			hoverAudio.Play();
		}
	}

	public void PlayClickSound()
	{
		if (!clickAudio.isPlaying)
		{
			clickAudio.Play();
		}
	}
}
public class EpiPlatformDependance : MonoBehaviour
{
	[Header("Editor")]
	public bool editor;

	[Header("PC Setup")]
	public bool pc;

	public bool steam;

	[Header("Console Setup")]
	public bool xbox;

	public bool nintendoSwitch;

	public bool playstation;

	public bool uwp;

	[Header("VR Setup")]
	public bool oculus;

	public bool vive;

	public bool springboardvr;

	[Header("Mobile Setup")]
	public bool ios;

	public bool android;

	[Header("Additional Event Trigger")]
	public UnityEvent triggerEvents;

	private void Awake()
	{
		bool flag = false;
		base.gameObject.SetActive(flag);
		if (flag)
		{
			triggerEvents.Invoke();
		}
	}
}
public class EpiPlatformDependantSpawner : MonoBehaviour
{
	public bool spawnOnAwake = true;

	[Header("Editor Setup")]
	public GameObject[] editor;

	[Header("PC Setup")]
	public GameObject[] pc;

	public GameObject[] steam;

	[Header("Console Setup")]
	public GameObject[] xbox;

	public GameObject[] nintendoSwitch;

	public GameObject[] playstation;

	public GameObject[] uwp;

	[Header("VR Setup")]
	public GameObject[] oculus;

	public GameObject[] vive;

	public GameObject[] springboardvr;

	[Header("Mobile Setup")]
	public GameObject[] ios;

	public GameObject[] android;

	private void Awake()
	{
		Spawn();
	}

	public void Spawn()
	{
		List<GameObject> list = new List<GameObject>();
		if (list.Count != 0)
		{
			foreach (GameObject item in list)
			{
				UnityEngine.Object.Instantiate(item, null).name = item.name;
			}
		}
		base.gameObject.SetActive(value: false);
	}
}
namespace Battlehub.UIControls
{
	public delegate void ItemEventHandler(ItemContainer sender, PointerEventData eventData);
	[RequireComponent(typeof(RectTransform), typeof(LayoutElement))]
	public class ItemContainer : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler, IBeginDragHandler, IDragHandler, IDropHandler, IEndDragHandler
	{
		public bool CanDrag = true;

		private LayoutElement m_layoutElement;

		private RectTransform m_rectTransform;

		private bool m_isSelected;

		public LayoutElement LayoutElement => m_layoutElement;

		public RectTransform RectTransform => m_rectTransform;

		public virtual bool IsSelected
		{
			get
			{
				return m_isSelected;
			}
			set
			{
				if (m_isSelected == value)
				{
					return;
				}
				m_isSelected = value;
				if (m_isSelected)
				{
					if (ItemContainer.Selected != null)
					{
						ItemContainer.Selected(this, EventArgs.Empty);
					}
				}
				else if (ItemContainer.Unselected != null)
				{
					ItemContainer.Unselected(this, EventArgs.Empty);
				}
			}
		}

		public object Item { get; set; }

		public static event EventHandler Selected;

		public static event EventHandler Unselected;

		public static event ItemEventHandler PointerDown;

		public static event ItemEventHandler PointerUp;

		public static event ItemEventHandler PointerEnter;

		public static event ItemEventHandler PointerExit;

		public static event ItemEventHandler BeginDrag;

		public static event ItemEventHandler Drag;

		public static event ItemEventHandler Drop;

		public static event ItemEventHandler EndDrag;

		private void Awake()
		{
			m_rectTransform = GetComponent<RectTransform>();
			m_layoutElement = GetComponent<LayoutElement>();
			AwakeOverride();
		}

		protected virtual void AwakeOverride()
		{
		}

		private void Start()
		{
			StartOverride();
		}

		protected virtual void StartOverride()
		{
		}

		void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
		{
			if (ItemContainer.PointerDown != null)
			{
				ItemContainer.PointerDown(this, eventData);
			}
		}

		void IPointerUpHandler.OnPointerUp(PointerEventData eventData)
		{
			if (ItemContainer.PointerUp != null)
			{
				ItemContainer.PointerUp(this, eventData);
			}
		}

		void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
		{
			if (CanDrag && ItemContainer.BeginDrag != null)
			{
				ItemContainer.BeginDrag(this, eventData);
			}
		}

		void IDropHandler.OnDrop(PointerEventData eventData)
		{
			if (CanDrag && ItemContainer.Drop != null)
			{
				ItemContainer.Drop(this, eventData);
			}
		}

		void IDragHandler.OnDrag(PointerEventData eventData)
		{
			if (CanDrag && ItemContainer.Drag != null)
			{
				ItemContainer.Drag(this, eventData);
			}
		}

		void IEndDragHandler.OnEndDrag(PointerEventData eventData)
		{
			if (CanDrag && ItemContainer.EndDrag != null)
			{
				ItemContainer.EndDrag(this, eventData);
			}
		}

		void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
		{
			if (ItemContainer.PointerEnter != null)
			{
				ItemContainer.PointerEnter(this, eventData);
			}
		}

		void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
		{
			if (ItemContainer.PointerExit != null)
			{
				ItemContainer.PointerExit(this, eventData);
			}
		}
	}
	public enum ItemDropAction
	{
		None,
		SetLastChild,
		SetPrevSibling,
		SetNextSibling
	}
	[RequireComponent(typeof(RectTransform))]
	public class ItemDropMarker : MonoBehaviour
	{
		private Canvas m_parentCanvas;

		private ItemsControl m_itemsControl;

		public GameObject SiblingGraphics;

		private ItemDropAction m_action;

		private RectTransform m_rectTransform;

		private ItemContainer m_item;

		protected Canvas ParentCanvas => m_parentCanvas;

		public virtual ItemDropAction Action
		{
			get
			{
				return m_action;
			}
			set
			{
				m_action = value;
			}
		}

		public RectTransform RectTransform => m_rectTransform;

		protected ItemContainer Item => m_item;

		private void Awake()
		{
			m_rectTransform = GetComponent<RectTransform>();
			SiblingGraphics.SetActive(value: true);
			m_parentCanvas = GetComponentInParent<Canvas>();
			m_itemsControl = GetComponentInParent<ItemsControl>();
			AwakeOverride();
		}

		protected virtual void AwakeOverride()
		{
		}

		public virtual void SetTraget(ItemContainer item)
		{
			base.gameObject.SetActive(item != null);
			m_item = item;
			if (m_item == null)
			{
				Action = ItemDropAction.None;
			}
		}

		public virtual void SetPosition(Vector2 position)
		{
			if (m_item == null)
			{
				return;
			}
			RectTransform rectTransform = Item.RectTransform;
			Camera cam = null;
			if (ParentCanvas.renderMode == RenderMode.WorldSpace)
			{
				cam = m_itemsControl.Camera;
			}
			if (RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, position, cam, out var localPoint))
			{
				if (localPoint.y > (0f - rectTransform.rect.height) / 2f)
				{
					Action = ItemDropAction.SetPrevSibling;
					RectTransform.position = rectTransform.position;
				}
				else
				{
					Action = ItemDropAction.SetNextSibling;
					RectTransform.position = rectTransform.position - new Vector3(0f, rectTransform.rect.height, 0f);
				}
			}
		}
	}
	public class SelectionChangedEventArgs : EventArgs
	{
		public object[] OldItems { get; private set; }

		public object[] NewItems { get; private set; }

		public object OldItem
		{
			get
			{
				if (OldItems == null)
				{
					return null;
				}
				return OldItems[0];
			}
		}

		public object NewItem
		{
			get
			{
				if (NewItems == null)
				{
					return null;
				}
				return NewItems[0];
			}
		}

		public SelectionChangedEventArgs(object[] oldItems, object[] newItems)
		{
			OldItems = oldItems;
			NewItems = newItems;
		}

		public SelectionChangedEventArgs(object oldItem, object newItem)
		{
			OldItems = new object[1] { oldItem };
			NewItems = new object[1] { newItem };
		}
	}
	public class ItemAddEventArgs : EventArgs
	{
		public int Index { get; private set; }

		public ItemAddEventArgs(int index)
		{
			Index = index;
		}
	}
	public class ItemsRemovedArgs : EventArgs
	{
		public object[] Items { get; private set; }

		public ItemsRemovedArgs(object[] items)
		{
			Items = items;
		}
	}
	public class ItemDataBindingArgs : EventArgs
	{
		public object Item { get; set; }

		public GameObject ItemPresenter { get; set; }
	}
	public class ItemDragArgs : EventArgs
	{
		public object DragItem { get; private set; }

		public ItemDragArgs(object[] dragItem)
		{
			DragItem = dragItem;
		}
	}
	public class ItemDropArgs : EventArgs
	{
		public object[] DragItems { get; private set; }

		public object DropTarget { get; private set; }

		public ItemDropAction Action { get; private set; }

		public bool IsExternal { get; private set; }

		public ItemDropArgs(object[] dragItems, object dropTarget, ItemDropAction action, bool isExternal)
		{
			DragItems = dragItems;
			DropTarget = dropTarget;
			Action = action;
			IsExternal = isExternal;
		}
	}
	public class CancelEventArgs : EventArgs
	{
		public bool Cancel { get; set; }
	}
	public class ItemsControl : ItemsControl<ItemDataBindingArgs>
	{
	}
	public class ItemsControl<TDataBindingArgs> : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IDropHandler where TDataBindingArgs : ItemDataBindingArgs, new()
	{
		private enum ScrollDir
		{
			None,
			Up,
			Down,
			Left,
			Right
		}

		public KeyCode MultiselectKey = KeyCode.LeftControl;

		public KeyCode RangeselectKey = KeyCode.LeftShift;

		public KeyCode RemoveKey = KeyCode.Delete;

		private bool m_prevCanDrag;

		public bool CanDrag = true;

		private bool m_isDropInProgress;

		[SerializeField]
		private GameObject ItemContainerPrefab;

		public Transform Panel;

		private float m_width;

		private Canvas m_canvas;

		public Camera Camera;

		public float ScrollSpeed = 100f;

		private ScrollDir m_scrollDir;

		private ScrollRect m_scrollRect;

		private List<ItemContainer> m_itemContainers;

		private ItemDropMarker m_dropMarker;

		private ItemContainer m_dropTarget;

		private ItemContainer[] m_dragItems;

		private IList<object> m_items;

		private bool m_selectionLocked;

		private List<object> m_selectedItems;

		private ItemContainer m_selectedItem;

		private int m_selectedIndex = -1;

		public bool IsDropInProgress => m_isDropInProgress;

		protected ItemDropMarker DropMarker => m_dropMarker;

		public IEnumerable Items
		{
			get
			{
				return m_items;
			}
			set
			{
				m_items = value.OfType<object>().ToList();
				DataBind();
			}
		}

		public int ItemsCount
		{
			get
			{
				if (m_items == null)
				{
					return 0;
				}
				return m_items.Count;
			}
		}

		public int SelectedItemsCount
		{
			get
			{
				if (m_selectedItems == null)
				{
					return 0;
				}
				return m_selectedItems.Count;
			}
		}

		public IEnumerable SelectedItems
		{
			get
			{
				return m_selectedItems;
			}
			set
			{
				if (m_selectionLocked)
				{
					return;
				}
				m_selectionLocked = true;
				IList selectedItems = m_selectedItems;
				if (value != null)
				{
					m_selectedItems = value.OfType<object>().ToList();
					for (int num = m_selectedItems.Count - 1; num >= 0; num--)
					{
						object obj = m_selectedItems[num];
						ItemContainer itemContainer = GetItemContainer(obj);
						if (itemContainer == null)
						{
							m_selectedItems.Remove(obj);
						}
						else
						{
							itemContainer.IsSelected = true;
						}
					}
					if (m_selectedItems.Count == 0)
					{
						m_selectedItem = null;
						m_selectedIndex = -1;
					}
					else
					{
						m_selectedItem = GetItemContainer(m_selectedItems[0]);
						m_selectedIndex = IndexOf(m_selectedItem.Item);
					}
				}
				else
				{
					m_selectedItems = null;
					m_selectedItem = null;
					m_selectedIndex = -1;
				}
				List<object> list = new List<object>();
				if (selectedItems != null)
				{
					if (m_selectedItems != null)
					{
						for (int i = 0; i < selectedItems.Count; i++)
						{
							object obj2 = selectedItems[i];
							if (!m_selectedItems.Contains(obj2))
							{
								list.Add(obj2);
								GetItemContainer(obj2).IsSelected = false;
							}
						}
					}
					else
					{
						list.AddRange(selectedItems.OfType<object>());
					}
				}
				if (this.SelectionChanged != null)
				{
					object[] newItems = ((m_selectedItems == null) ? new object[0] : m_selectedItems.ToArray());
					this.SelectionChanged(this, new SelectionChangedEventArgs(list.ToArray(), newItems));
				}
				m_selectionLocked = false;
			}
		}

		public object SelectedItem
		{
			get
			{
				if (m_selectedItem == null)
				{
					return null;
				}
				return m_selectedItem.Item;
			}
			set
			{
				SelectedIndex = IndexOf(value);
			}
		}

		public int SelectedIndex
		{
			get
			{
				if (m_selectedItem == null)
				{
					return -1;
				}
				return m_selectedIndex;
			}
			set
			{
				if (m_selectedIndex == value)
				{
					return;
				}
				ItemContainer selectedItem = m_selectedItem;
				if (selectedItem != null)
				{
					selectedItem.IsSelected = false;
				}
				m_selectedIndex = value;
				object obj = null;
				if (m_selectedIndex >= 0 && m_selectedIndex < m_items.Count)
				{
					obj = m_items[m_selectedIndex];
					m_selectedItem = GetItemContainer(obj);
					if (m_selectedItem != null)
					{
						m_selectedItem.IsSelected = true;
					}
				}
				object[] array = ((obj == null) ? new object[0] : new object[1] { obj });
				object[] array2 = ((m_selectedItems == null) ? new object[0] : m_selectedItems.Except(array).ToArray());
				foreach (object obj2 in array2)
				{
					GetItemContainer(obj2).IsSelected = false;
				}
				m_selectedItems = array.ToList();
				if (this.SelectionChanged != null)
				{
					this.SelectionChanged(this, new SelectionChangedEventArgs(array2, array));
				}
			}
		}

		public event EventHandler<ItemDragArgs> ItemBeginDrag;

		public event EventHandler<ItemDropArgs> ItemDrop;

		public event EventHandler<ItemDragArgs> ItemEndDrag;

		public event EventHandler<TDataBindingArgs> ItemDataBinding;

		public event EventHandler<SelectionChangedEventArgs> SelectionChanged;

		public event EventHandler<ItemsRemovedArgs> ItemsRemoved;

		protected void RemoveItemAt(int index)
		{
			m_items.RemoveAt(index);
		}

		protected void RemoveItemContainerAt(int index)
		{
			m_itemContainers.RemoveAt(index);
		}

		protected void InsertItem(int index, object value)
		{
			m_items.Insert(index, value);
		}

		protected void InsertItemContainerAt(int index, ItemContainer container)
		{
			m_itemContainers.Insert(index, container);
		}

		public int IndexOf(object obj)
		{
			if (m_items == null)
			{
				return -1;
			}
			if (obj == null)
			{
				return -1;
			}
			return m_items.IndexOf(obj);
		}

		public ItemContainer GetItemContainer(object obj)
		{
			return m_itemContainers.Where((ItemContainer ic) => ic.Item == obj).FirstOrDefault();
		}

		public ItemContainer LastItemContainer()
		{
			if (m_itemContainers == null || m_itemContainers.Count == 0)
			{
				return null;
			}
			return m_itemContainers[m_itemContainers.Count - 1];
		}

		public ItemContainer GetItemContainer(int siblingIndex)
		{
			if (siblingIndex < 0 || siblingIndex >= m_itemContainers.Count)
			{
				return null;
			}
			return m_itemContainers[siblingIndex];
		}

		public ItemContainer Add(object item)
		{
			if (m_items == null)
			{
				m_items = new List<object>();
				m_itemContainers = new List<ItemContainer>();
			}
			return Insert(m_items.Count, item);
		}

		public ItemContainer Insert(int index, object item)
		{
			if (m_items == null)
			{
				m_items = new List<object>();
				m_itemContainers = new List<ItemContainer>();
			}
			object obj = m_items.ElementAtOrDefault(index);
			ItemContainer itemContainer = GetItemContainer(obj);
			int siblingIndex = ((!(itemContainer != null)) ? m_itemContainers.Count : m_itemContainers.IndexOf(itemContainer));
			m_items.Insert(index, item);
			itemContainer = InstantiateItemContainer(siblingIndex);
			if (itemContainer != null)
			{
				itemContainer.Item = item;
				DataBindItem(item, itemContainer);
			}
			return itemContainer;
		}

		public void Remove(object item)
		{
			if (item != null && m_items != null && m_items.Contains(item))
			{
				DestroyItem(item);
			}
		}

		public void RemoveAt(int index)
		{
			if (m_items != null)
			{
				if (index >= m_items.Count || index < 0)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				Remove(m_items[index]);
			}
		}

		private void Awake()
		{
			if (Panel == null)
			{
				Panel = base.transform;
			}
			m_itemContainers = GetComponentsInChildren<ItemContainer>().ToList();
			m_dropMarker = GetComponentInChildren<ItemDropMarker>(includeInactive: true);
			m_scrollRect = GetComponent<ScrollRect>();
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			m_prevCanDrag = CanDrag;
			OnCanDragChanged();
			AwakeOverride();
		}

		private void Start()
		{
			m_canvas = GetComponentInParent<Canvas>();
			StartOverride();
		}

		private void Update()
		{
			if (m_scrollDir != 0)
			{
				float num = m_scrollRect.content.rect.height - m_scrollRect.viewport.rect.height;
				float num2 = 0f;
				if (num > 0f)
				{
					num2 = ScrollSpeed / 10f * (1f / num);
				}
				float num3 = m_scrollRect.content.rect.width - m_scrollRect.viewport.rect.width;
				float num4 = 0f;
				if (num3 > 0f)
				{
					num4 = ScrollSpeed / 10f * (1f / num3);
				}
				if (m_scrollDir == ScrollDir.Up)
				{
					m_scrollRect.verticalNormalizedPosition += num2;
					if (m_scrollRect.verticalNormalizedPosition > 1f)
					{
						m_scrollRect.verticalNormalizedPosition = 1f;
						m_scrollDir = ScrollDir.None;
					}
				}
				else if (m_scrollDir == ScrollDir.Down)
				{
					m_scrollRect.verticalNormalizedPosition -= num2;
					if (m_scrollRect.verticalNormalizedPosition < 0f)
					{
						m_scrollRect.verticalNormalizedPosition = 0f;
						m_scrollDir = ScrollDir.None;
					}
				}
				else if (m_scrollDir == ScrollDir.Left)
				{
					m_scrollRect.horizontalNormalizedPosition -= num4;
					if (m_scrollRect.horizontalNormalizedPosition < 0f)
					{
						m_scrollRect.horizontalNormalizedPosition = 0f;
						m_scrollDir = ScrollDir.None;
					}
				}
				if (m_scrollDir == ScrollDir.Right)
				{
					m_scrollRect.horizontalNormalizedPosition += num4;
					if (m_scrollRect.horizontalNormalizedPosition > 1f)
					{
						m_scrollRect.horizontalNormalizedPosition = 1f;
						m_scrollDir = ScrollDir.None;
					}
				}
			}
			if (Input.GetKeyDown(RemoveKey))
			{
				DestroySelectedItems();
			}
			if (m_scrollRect.viewport.rect.width != m_width)
			{
				m_width = m_scrollRect.viewport.rect.width;
				if (m_itemContainers != null)
				{
					for (int i = 0; i < m_itemContainers.Count; i++)
					{
						ItemContainer itemContainer = m_itemContainers[i];
						if (itemContainer != null)
						{
							itemContainer.LayoutElement.minWidth = m_width;
						}
					}
				}
			}
			if (m_prevCanDrag != CanDrag)
			{
				OnCanDragChanged();
				m_prevCanDrag = CanDrag;
			}
			UpdateOverride();
		}

		private void OnEnable()
		{
			ItemContainer.Selected += OnItemSelected;
			ItemContainer.Unselected += OnItemUnselected;
			ItemContainer.PointerUp += OnItemPointerUp;
			ItemContainer.PointerDown += OnItemPointerDown;
			ItemContainer.PointerEnter += OnPointerEnter;
			ItemContainer.PointerExit += OnPointerExit;
			ItemContainer.BeginDrag += OnItemBeginDrag;
			ItemContainer.Drag += OnItemDrag;
			ItemContainer.Drop += OnItemDrop;
			ItemContainer.EndDrag += OnItemEndDrag;
			OnEnableOverride();
		}

		private void OnDisable()
		{
			ItemContainer.Selected -= OnItemSelected;
			ItemContainer.Unselected -= OnItemUnselected;
			ItemContainer.PointerUp -= OnItemPointerUp;
			ItemContainer.PointerDown -= OnItemPointerDown;
			ItemContainer.PointerEnter -= OnPointerEnter;
			ItemContainer.PointerExit -= OnPointerExit;
			ItemContainer.BeginDrag -= OnItemBeginDrag;
			ItemContainer.Drag -= OnItemDrag;
			ItemContainer.Drop -= OnItemDrop;
			ItemContainer.EndDrag -= OnItemEndDrag;
			OnDisableOverride();
		}

		protected virtual void AwakeOverride()
		{
		}

		protected virtual void StartOverride()
		{
		}

		protected virtual void UpdateOverride()
		{
		}

		protected virtual void OnEnableOverride()
		{
		}

		protected virtual void OnDisableOverride()
		{
		}

		private void OnCanDragChanged()
		{
			for (int i = 0; i < m_itemContainers.Count; i++)
			{
				ItemContainer itemContainer = m_itemContainers[i];
				if (itemContainer != null)
				{
					itemContainer.CanDrag = CanDrag;
				}
			}
		}

		protected bool CanHandleEvent(object sender)
		{
			ItemContainer itemContainer = sender as ItemContainer;
			if (!itemContainer)
			{
				return false;
			}
			return itemContainer.transform.IsChildOf(Panel);
		}

		private void OnItemSelected(object sender, EventArgs e)
		{
			if (!m_selectionLocked && CanHandleEvent(sender))
			{
				if (Input.GetKey(MultiselectKey))
				{
					IList list = ((m_selectedItems != null) ? m_selectedItems.ToList() : new List<object>());
					list.Add(((ItemContainer)sender).Item);
					SelectedItems = list;
				}
				else if (Input.GetKey(RangeselectKey))
				{
					SelectRange((ItemContainer)sender);
				}
				else
				{
					SelectedIndex = IndexOf(((ItemContainer)sender).Item);
				}
			}
		}

		private void SelectRange(ItemContainer itemContainer)
		{
			if (m_selectedItems != null && m_selectedItems.Count > 0)
			{
				List<object> list = new List<object>();
				int num = IndexOf(m_selectedItems[0]);
				object item = itemContainer.Item;
				int num2 = IndexOf(item);
				int num3 = Mathf.Min(num, num2);
				int num4 = Math.Max(num, num2);
				list.Add(m_selectedItems[0]);
				for (int i = num3; i < num; i++)
				{
					list.Add(m_items[i]);
				}
				for (int j = num + 1; j <= num4; j++)
				{
					list.Add(m_items[j]);
				}
				SelectedItems = list;
			}
			else
			{
				SelectedIndex = IndexOf(itemContainer.Item);
			}
		}

		private void OnItemUnselected(object sender, EventArgs e)
		{
			if (!m_selectionLocked && CanHandleEvent(sender))
			{
				IList list = ((m_selectedItems != null) ? m_selectedItems.ToList() : new List<object>());
				list.Remove(((ItemContainer)sender).Item);
				SelectedItems = list;
			}
		}

		private void OnItemPointerDown(ItemContainer sender, PointerEventData e)
		{
			if (CanHandleEvent(sender))
			{
				if (Input.GetKey(RangeselectKey))
				{
					SelectRange(sender);
				}
				else if (Input.GetKey(MultiselectKey))
				{
					sender.IsSelected = !sender.IsSelected;
				}
				else
				{
					sender.IsSelected = true;
				}
			}
		}

		private void OnItemPointerUp(ItemContainer sender, PointerEventData e)
		{
			if (CanHandleEvent(sender) && m_dragItems == null && !Input.GetKey(MultiselectKey) && !Input.GetKey(RangeselectKey) && m_selectedItems != null && m_selectedItems.Count > 1)
			{
				SelectedItem = sender.Item;
			}
		}

		private void OnPointerEnter(ItemContainer sender, PointerEventData eventData)
		{
			if (CanHandleEvent(sender))
			{
				m_dropTarget = sender;
				if (m_dragItems != null && m_scrollDir == ScrollDir.None)
				{
					m_dropMarker.SetTraget(m_dropTarget);
				}
			}
		}

		private void OnPointerExit(ItemContainer sender, PointerEventData eventData)
		{
			if (CanHandleEvent(sender))
			{
				m_dropTarget = null;
				if (m_dragItems != null)
				{
					m_dropMarker.SetTraget(null);
				}
			}
		}

		private void OnItemBeginDrag(ItemContainer sender, PointerEventData eventData)
		{
			eventData.Reset();
			if (!CanHandleEvent(sender))
			{
				return;
			}
			if (m_dropTarget != null)
			{
				m_dropMarker.SetTraget(m_dropTarget);
				m_dropMarker.SetPosition(eventData.position);
			}
			m_dragItems = GetDragItems();
			if (this.ItemBeginDrag != null)
			{
				this.ItemBeginDrag(this, new ItemDragArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray()));
			}
		}

		private void OnItemDrag(ItemContainer sender, PointerEventData eventData)
		{
			if (!CanHandleEvent(sender))
			{
				return;
			}
			if (m_dropTarget != null)
			{
				m_dropMarker.SetPosition(eventData.position);
			}
			float height = m_scrollRect.viewport.rect.height;
			float width = m_scrollRect.viewport.rect.width;
			Camera cam = null;
			if (m_canvas.renderMode == RenderMode.WorldSpace)
			{
				cam = Camera;
			}
			if (RectTransformUtility.ScreenPointToLocalPointInRectangle(m_scrollRect.viewport, eventData.position, cam, out var localPoint))
			{
				if (localPoint.y >= 0f)
				{
					m_scrollDir = ScrollDir.Up;
					m_dropMarker.SetTraget(null);
				}
				else if (localPoint.y < 0f - height)
				{
					m_scrollDir = ScrollDir.Down;
					m_dropMarker.SetTraget(null);
				}
				else if (localPoint.x <= 0f)
				{
					m_scrollDir = ScrollDir.Left;
				}
				else if (localPoint.x >= width)
				{
					m_scrollDir = ScrollDir.Right;
				}
				else
				{
					m_scrollDir = ScrollDir.None;
				}
			}
		}

		private void OnItemDrop(ItemContainer sender, PointerEventData eventData)
		{
			if (!CanHandleEvent(sender))
			{
				return;
			}
			m_isDropInProgress = true;
			try
			{
				if (CanDrop(m_dragItems, m_dropTarget))
				{
					Drop(m_dragItems, m_dropTarget, m_dropMarker.Action);
					if (this.ItemDrop != null)
					{
						this.ItemDrop(this, new ItemDropArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray(), m_dropTarget.Item, m_dropMarker.Action, isExternal: false));
					}
				}
				RaiseEndDrag();
			}
			finally
			{
				m_isDropInProgress = false;
			}
		}

		private void OnItemEndDrag(ItemContainer sender, PointerEventData eventData)
		{
			if (CanHandleEvent(sender))
			{
				RaiseEndDrag();
			}
		}

		private void RaiseEndDrag()
		{
			if (m_dragItems == null)
			{
				return;
			}
			if (this.ItemEndDrag != null)
			{
				this.ItemEndDrag(this, new ItemDragArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray()));
			}
			m_dropMarker.SetTraget(null);
			m_dragItems = null;
			m_scrollDir = ScrollDir.None;
		}

		void IDropHandler.OnDrop(PointerEventData eventData)
		{
			if (m_dragItems == null)
			{
				GameObject pointerDrag = eventData.pointerDrag;
				if (!(pointerDrag != null))
				{
					return;
				}
				ItemContainer component = pointerDrag.GetComponent<ItemContainer>();
				if (component != null && component.Item != null)
				{
					object item = component.Item;
					if (this.ItemDrop != null)
					{
						this.ItemDrop(this, new ItemDropArgs(new object[1] { item }, null, ItemDropAction.SetLastChild, isExternal: true));
					}
				}
				return;
			}
			if (m_itemContainers != null && m_itemContainers.Count > 0)
			{
				m_dropTarget = m_itemContainers.Last();
				m_dropMarker.Action = ItemDropAction.SetNextSibling;
			}
			m_isDropInProgress = true;
			try
			{
				if (CanDrop(m_dragItems, m_dropTarget))
				{
					if (this.ItemDrop != null)
					{
						this.ItemDrop(this, new ItemDropArgs(m_dragItems.Select((ItemContainer di) => di.Item).ToArray(), m_dropTarget.Item, m_dropMarker.Action, isExternal: false));
					}
					Drop(m_dragItems, m_dropTarget, m_dropMarker.Action);
				}
				m_dropMarker.SetTraget(null);
				m_dragItems = null;
			}
			finally
			{
				m_isDropInProgress = false;
			}
		}

		void IPointerDownHandler.OnPointerDown(PointerEventData eventData)
		{
			SelectedIndex = -1;
		}

		protected virtual bool CanDrop(ItemContainer[] dragItems, ItemContainer dropTarget)
		{
			if (dropTarget == null)
			{
				return true;
			}
			if (dragItems == null)
			{
				return false;
			}
			if (dragItems.Contains(dropTarget.Item))
			{
				return false;
			}
			return true;
		}

		protected ItemContainer[] GetDragItems()
		{
			ItemContainer[] array = new ItemContainer[m_selectedItems.Count];
			if (m_selectedItems != null)
			{
				for (int i = 0; i < m_selectedItems.Count; i++)
				{
					array[i] = GetItemContainer(m_selectedItems[i]);
				}
			}
			return array.OrderBy((ItemContainer di) => di.transform.GetSiblingIndex()).ToArray();
		}

		protected virtual void DropItemAfter(ItemContainer dropTarget, ItemContainer dragItem)
		{
			int num = IndexOf(dragItem.Item);
			int num2 = IndexOf(dropTarget.Item);
			RemoveItemAt(num);
			if (num < num2)
			{
				num2--;
			}
			InsertItem(num2 + 1, dragItem.Item);
			int num3 = dropTarget.transform.GetSiblingIndex();
			int siblingIndex = dragItem.transform.GetSiblingIndex();
			RemoveItemContainerAt(siblingIndex);
			if (siblingIndex > num3)
			{
				num3++;
			}
			dragItem.transform.SetSiblingIndex(num3);
			InsertItemContainerAt(num3, dragItem);
		}

		protected virtual void DropItemBefore(ItemContainer dropTarget, ItemContainer dragItem)
		{
			int num = IndexOf(dragItem.Item);
			int num2 = IndexOf(dropTarget.Item);
			RemoveItemAt(num);
			if (num < num2)
			{
				num2--;
			}
			InsertItem(num2, dragItem.Item);
			int num3 = dropTarget.transform.GetSiblingIndex();
			int siblingIndex = dragItem.transform.GetSiblingIndex();
			RemoveItemContainerAt(siblingIndex);
			if (siblingIndex < num3)
			{
				num3--;
			}
			dragItem.transform.SetSiblingIndex(num3);
			InsertItemContainerAt(num3, dragItem);
		}

		protected virtual void Drop(ItemContainer[] dragItems, ItemContainer dropTarget, ItemDropAction action)
		{
			switch (action)
			{
			case ItemDropAction.SetPrevSibling:
				foreach (ItemContainer dragItem2 in dragItems)
				{
					DropItemBefore(dropTarget, dragItem2);
				}
				break;
			case ItemDropAction.SetNextSibling:
				foreach (ItemContainer dragItem in dragItems)
				{
					DropItemAfter(dropTarget, dragItem);
				}
				break;
			}
			UpdateSelectedItemIndex();
		}

		protected void UpdateSelectedItemIndex()
		{
			m_selectedIndex = IndexOf(SelectedItem);
		}

		protected virtual void DataBind()
		{
			m_itemContainers = GetComponentsInChildren<ItemContainer>().ToList();
			if (m_items == null)
			{
				for (int i = 0; i < m_itemContainers.Count; i++)
				{
					UnityEngine.Object.Destroy(m_itemContainers[i].gameObject);
				}
			}
			else
			{
				int num = m_items.Count - m_itemContainers.Count;
				if (num > 0)
				{
					for (int j = 0; j < num; j++)
					{
						InstantiateItemContainer(m_itemContainers.Count);
					}
				}
				else
				{
					int num2 = m_itemContainers.Count + num;
					for (int num3 = m_itemContainers.Count - 1; num3 >= num2; num3--)
					{
						DestroyItemContainer(num3);
					}
				}
			}
			for (int k = 0; k < m_items.Count; k++)
			{
				object item = m_items[k];
				ItemContainer itemContainer = m_itemContainers[k];
				itemContainer.CanDrag = CanDrag;
				if (itemContainer != null)
				{
					itemContainer.Item = item;
					DataBindItem(item, itemContainer);
				}
			}
		}

		protected virtual void DataBindItem(object item, ItemContainer itemContainer)
		{
			RaiseItemDataBinding(new TDataBindingArgs
			{
				Item = item,
				ItemPresenter = itemContainer.gameObject
			});
		}

		protected void RaiseItemDataBinding(TDataBindingArgs args)
		{
			if (this.ItemDataBinding != null)
			{
				this.ItemDataBinding(this, args);
			}
		}

		protected ItemContainer InstantiateItemContainer(int siblingIndex)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(ItemContainerPrefab);
			gameObject.name = "ItemContainer";
			gameObject.transform.SetParent(Panel, worldPositionStays: false);
			gameObject.transform.SetSiblingIndex(siblingIndex);
			ItemContainer itemContainer = InstantiateItemContainerOverride(gameObject);
			itemContainer.CanDrag = CanDrag;
			itemContainer.LayoutElement.minWidth = m_width;
			m_itemContainers.Insert(siblingIndex, itemContainer);
			return itemContainer;
		}

		protected void DestroyItemContainer(int siblingIndex)
		{
			if (m_itemContainers != null && siblingIndex >= 0 && siblingIndex < m_itemContainers.Count)
			{
				UnityEngine.Object.DestroyImmediate(m_itemContainers[siblingIndex].gameObject);
				m_itemContainers.RemoveAt(siblingIndex);
			}
		}

		protected virtual ItemContainer InstantiateItemContainerOverride(GameObject container)
		{
			ItemContainer itemContainer = container.GetComponent<ItemContainer>();
			if (itemContainer == null)
			{
				itemContainer = container.AddComponent<ItemContainer>();
			}
			return itemContainer;
		}

		private void DestroySelectedItems()
		{
			if (m_selectedItems == null)
			{
				return;
			}
			object[] array = m_selectedItems.ToArray();
			if (array.Length != 0)
			{
				SelectedItems = null;
				foreach (object item in array)
				{
					DestroyItem(item);
				}
				if (this.ItemsRemoved != null)
				{
					this.ItemsRemoved(this, new ItemsRemovedArgs(array));
				}
			}
		}

		protected virtual void DestroyItem(object item)
		{
			if (m_selectedItems != null && m_selectedItems.Contains(item))
			{
				m_selectedItems.Remove(item);
				if (m_selectedItems.Count == 0)
				{
					m_selectedItem = null;
					m_selectedIndex = -1;
				}
				else
				{
					m_selectedItem = GetItemContainer(m_selectedItems[0]);
					m_selectedIndex = IndexOf(m_selectedItem.Item);
				}
			}
			ItemContainer itemContainer = GetItemContainer(item);
			if (itemContainer != null)
			{
				int siblingIndex = itemContainer.transform.GetSiblingIndex();
				DestroyItemContainer(siblingIndex);
				m_items.Remove(item);
			}
		}
	}
	public class ListBox : ItemsControl
	{
	}
	public class ListBoxItem : ItemContainer
	{
		private Toggle m_toggle;

		public override bool IsSelected
		{
			get
			{
				return base.IsSelected;
			}
			set
			{
				if (base.IsSelected != value)
				{
					m_toggle.isOn = value;
					base.IsSelected = value;
				}
			}
		}

		protected override void AwakeOverride()
		{
			m_toggle = GetComponent<Toggle>();
			m_toggle.interactable = false;
			m_toggle.isOn = IsSelected;
		}
	}
	public class ItemExpandingArgs : EventArgs
	{
		public object Item { get; private set; }

		public IEnumerable Children { get; set; }

		public ItemExpandingArgs(object item)
		{
			Item = item;
		}
	}
	public class TreeViewItemDataBindingArgs : ItemDataBindingArgs
	{
		public bool HasChildren { get; set; }
	}
	public class TreeView : ItemsControl<TreeViewItemDataBindingArgs>
	{
		public int Indent = 20;

		private bool m_expandSilently;

		public event EventHandler<ItemExpandingArgs> ItemExpanding;

		protected override void OnEnableOverride()
		{
			base.OnEnableOverride();
			TreeViewItem.ParentChanged += OnTreeViewItemParentChanged;
		}

		protected override void OnDisableOverride()
		{
			base.OnDisableOverride();
			TreeViewItem.ParentChanged -= OnTreeViewItemParentChanged;
		}

		public void AddChild(object parent, object item)
		{
			if (parent == null)
			{
				Add(item);
				return;
			}
			TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(parent);
			if (treeViewItem == null)
			{
				return;
			}
			int num = -1;
			if (treeViewItem.IsExpanded)
			{
				if (treeViewItem.HasChildren)
				{
					TreeViewItem treeViewItem2 = treeViewItem.LastChild();
					num = IndexOf(treeViewItem2.Item) + 1;
				}
				else
				{
					num = IndexOf(treeViewItem.Item) + 1;
				}
			}
			else
			{
				treeViewItem.CanExpand = true;
			}
			if (num > -1)
			{
				((TreeViewItem)Insert(num, item)).Parent = treeViewItem;
			}
		}

		public void ChangeParent(object parent, object item)
		{
			if (base.IsDropInProgress)
			{
				return;
			}
			ItemContainer itemContainer = GetItemContainer(item);
			if (!(itemContainer == null))
			{
				ItemContainer itemContainer2 = GetItemContainer(parent);
				ItemContainer[] dragItems = new ItemContainer[1] { itemContainer };
				if (CanDrop(dragItems, itemContainer2))
				{
					Drop(dragItems, itemContainer2, ItemDropAction.SetLastChild);
				}
			}
		}

		public void Expand(TreeViewItem item)
		{
			if (m_expandSilently || this.ItemExpanding == null)
			{
				return;
			}
			ItemExpandingArgs itemExpandingArgs = new ItemExpandingArgs(item.Item);
			this.ItemExpanding(this, itemExpandingArgs);
			IEnumerable children = itemExpandingArgs.Children;
			int num = item.transform.GetSiblingIndex();
			int num2 = IndexOf(item.Item);
			item.CanExpand = children != null;
			if (!item.CanExpand)
			{
				return;
			}
			foreach (object item2 in children)
			{
				num++;
				num2++;
				TreeViewItem treeViewItem = (TreeViewItem)InstantiateItemContainer(num);
				treeViewItem.Parent = item;
				treeViewItem.Item = item2;
				InsertItem(num2, item2);
				DataBindItem(item2, treeViewItem);
			}
			UpdateSelectedItemIndex();
		}

		public void Collapse(TreeViewItem item)
		{
			int siblingIndex = item.transform.GetSiblingIndex();
			int num = IndexOf(item.Item);
			if (base.SelectedItems != null)
			{
				List<object> selectedItems = base.SelectedItems.OfType<object>().ToList();
				int containerIndex = siblingIndex + 1;
				int itemIndex = num + 1;
				Unselect(selectedItems, item, ref containerIndex, ref itemIndex);
				base.SelectedItems = selectedItems;
			}
			Collapse(item, siblingIndex + 1, num + 1);
		}

		private void Unselect(List<object> selectedItems, TreeViewItem item, ref int containerIndex, ref int itemIndex)
		{
			while (true)
			{
				TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(containerIndex);
				if (!(treeViewItem == null) && !(treeViewItem.Parent != item))
				{
					containerIndex++;
					itemIndex++;
					selectedItems.Remove(treeViewItem.Item);
					Unselect(selectedItems, treeViewItem, ref containerIndex, ref itemIndex);
					continue;
				}
				break;
			}
		}

		private void Collapse(TreeViewItem item, int containerIndex, int itemIndex)
		{
			while (true)
			{
				TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(containerIndex);
				if (!(treeViewItem == null) && !(treeViewItem.Parent != item))
				{
					Collapse(treeViewItem, containerIndex + 1, itemIndex + 1);
					RemoveItemAt(itemIndex);
					DestroyItemContainer(containerIndex);
					continue;
				}
				break;
			}
		}

		protected override ItemContainer InstantiateItemContainerOverride(GameObject container)
		{
			TreeViewItem treeViewItem = container.GetComponent<TreeViewItem>();
			if (treeViewItem == null)
			{
				treeViewItem = container.AddComponent<TreeViewItem>();
				treeViewItem.gameObject.name = "TreeViewItem";
			}
			return treeViewItem;
		}

		protected override void DestroyItem(object item)
		{
			TreeViewItem treeViewItem = (TreeViewItem)GetItemContainer(item);
			if (treeViewItem != null)
			{
				Collapse(treeViewItem);
				base.DestroyItem(item);
				if (treeViewItem.Parent != null && !treeViewItem.Parent.HasChildren)
				{
					treeViewItem.Parent.CanExpand = false;
				}
			}
		}

		protected override void DataBindItem(object item, ItemContainer itemContainer)
		{
			TreeViewItemDataBindingArgs treeViewItemDataBindingArgs = new TreeViewItemDataBindingArgs();
			treeViewItemDataBindingArgs.Item = item;
			treeViewItemDataBindingArgs.ItemPresenter = itemContainer.gameObject;
			RaiseItemDataBinding(treeViewItemDataBindingArgs);
			((TreeViewItem)itemContainer).CanExpand = treeViewItemDataBindingArgs.HasChildren;
		}

		protected override bool CanDrop(ItemContainer[] dragItems, ItemContainer dropTarget)
		{
			if (!base.CanDrop(dragItems, dropTarget))
			{
				return false;
			}
			TreeViewItem treeViewItem = (TreeViewItem)dropTarget;
			if (treeViewItem == null)
			{
				return true;
			}
			for (int i = 0; i < dragItems.Length; i++)
			{
				TreeViewItem parent = (TreeViewItem)dragItems[i];
				if (treeViewItem.IsDescendantOf(parent))
				{
					return false;
				}
			}
			return true;
		}

		private void OnTreeViewItemParentChanged(object sender, ParentChangedEventArgs e)
		{
			TreeViewItem treeViewItem = (TreeViewItem)sender;
			if (!CanHandleEvent(treeViewItem))
			{
				return;
			}
			TreeViewItem oldParent = e.OldParent;
			if (oldParent != null && !oldParent.HasChildren)
			{
				oldParent.CanExpand = false;
			}
			if (base.DropMarker.Action != ItemDropAction.SetLastChild && base.DropMarker.Action != 0)
			{
				return;
			}
			TreeViewItem newParent = e.NewParent;
			if (newParent != null)
			{
				if (newParent.CanExpand)
				{
					newParent.IsExpanded = true;
				}
				else
				{
					newParent.CanExpand = true;
					m_expandSilently = true;
					newParent.IsExpanded = true;
					m_expandSilently = false;
				}
			}
			TreeViewItem treeViewItem2 = treeViewItem.FirstChild();
			TreeViewItem treeViewItem3 = null;
			if (newParent != null)
			{
				treeViewItem3 = newParent.LastChild();
				if (treeViewItem3 == null)
				{
					treeViewItem3 = newParent;
				}
			}
			else
			{
				treeViewItem3 = (TreeViewItem)LastItemContainer();
			}
			if (treeViewItem3 != treeViewItem)
			{
				DropItemAfter(treeViewItem3, treeViewItem);
			}
			if (treeViewItem2 != null)
			{
				MoveSubtree(treeViewItem, treeViewItem2);
			}
		}

		private void MoveSubtree(TreeViewItem parent, TreeViewItem child)
		{
			int siblingIndex = parent.transform.GetSiblingIndex();
			int num = child.transform.GetSiblingIndex();
			bool flag = false;
			if (siblingIndex < num)
			{
				flag = true;
			}
			TreeViewItem treeViewItem = parent;
			while (child != null && child.IsDescendantOf(parent) && !(treeViewItem == child))
			{
				DropItemAfter(treeViewItem, child);
				treeViewItem = child;
				if (flag)
				{
					num++;
				}
				child = (TreeViewItem)GetItemContainer(num);
			}
		}

		protected override void Drop(ItemContainer[] dragItems, ItemContainer dropTarget, ItemDropAction action)
		{
			TreeViewItem treeViewItem = (TreeViewItem)dropTarget;
			switch (action)
			{
			case ItemDropAction.SetLastChild:
			{
				for (int i = 0; i < dragItems.Length; i++)
				{
					((TreeViewItem)dragItems[i]).Parent = treeViewItem;
				}
				break;
			}
			case ItemDropAction.SetPrevSibling:
			{
				for (int j = 0; j < dragItems.Length; j++)
				{
					TreeViewItem treeViewItem4 = (TreeViewItem)dragItems[j];
					TreeViewItem treeViewItem5 = treeViewItem4.FirstChild();
					DropItemBefore(treeViewItem, treeViewItem4);
					if (treeViewItem5 != null)
					{
						MoveSubtree(treeViewItem4, treeViewItem5);
					}
					treeViewItem4.Parent = treeViewItem.Parent;
				}
				break;
			}
			case ItemDropAction.SetNextSibling:
			{
				for (int num = dragItems.Length - 1; num >= 0; num--)
				{
					TreeViewItem treeViewItem2 = (TreeViewItem)dragItems[num];
					TreeViewItem treeViewItem3 = treeViewItem2.FirstChild();
					DropItemAfter(treeViewItem, treeViewItem2);
					if (treeViewItem3 != null)
					{
						MoveSubtree(treeViewItem2, treeViewItem3);
					}
					treeViewItem2.Parent = treeViewItem.Parent;
				}
				break;
			}
			}
			UpdateSelectedItemIndex();
		}
	}
	[RequireComponent(typeof(RectTransform))]
	public class TreeViewDropMarker : ItemDropMarker
	{
		private TreeView m_treeView;

		private RectTransform m_siblingGraphicsRectTransform;

		public GameObject ChildGraphics;

		public override ItemDropAction Action
		{
			get
			{
				return base.Action;
			}
			set
			{
				base.Action = value;
				ChildGraphics.SetActive(base.Action == ItemDropAction.SetLastChild);
				SiblingGraphics.SetActive(base.Action != ItemDropAction.SetLastChild);
			}
		}

		protected override void AwakeOverride()
		{
			base.AwakeOverride();
			m_treeView = GetComponentInParent<TreeView>();
			m_siblingGraphicsRectTransform = SiblingGraphics.GetComponent<RectTransform>();
		}

		public override void SetTraget(ItemContainer item)
		{
			base.SetTraget(item);
			if (!(item == null))
			{
				TreeViewItem treeViewItem = (TreeViewItem)item;
				if (treeViewItem != null)
				{
					m_siblingGraphicsRectTransform.offsetMin = new Vector2(treeViewItem.Indent, m_siblingGraphicsRectTransform.offsetMin.y);
				}
				else
				{
					m_siblingGraphicsRectTransform.offsetMin = new Vector2(0f, m_siblingGraphicsRectTransform.offsetMin.y);
				}
			}
		}

		public override void SetPosition(Vector2 position)
		{
			if (base.Item == null)
			{
				return;
			}
			RectTransform rectTransform = base.Item.RectTransform;
			TreeViewItem treeViewItem = (TreeViewItem)base.Item;
			Camera cam = null;
			if (base.ParentCanvas.renderMode == RenderMode.WorldSpace)
			{
				cam = m_treeView.Camera;
			}
			if (RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, position, cam, out var localPoint))
			{
				if (localPoint.y > (0f - rectTransform.rect.height) / 4f)
				{
					Action = ItemDropAction.SetPrevSibling;
					base.RectTransform.position = rectTransform.position;
				}
				else if (localPoint.y < rectTransform.rect.height / 4f - rectTransform.rect.height && !treeViewItem.HasChildren)
				{
					Action = ItemDropAction.SetNextSibling;
					base.RectTransform.position = rectTransform.position - new Vector3(0f, rectTransform.rect.height, 0f);
				}
				else
				{
					Action = ItemDropAction.SetLastChild;
					base.RectTransform.position = rectTransform.position;
				}
			}
		}
	}
	[RequireComponent(typeof(Toggle))]
	public class TreeViewExpander : MonoBehaviour
	{
		public Graphic OffGraphic;

		private Toggle m_toggle;

		private bool m_canExpand;

		public bool CanExpand
		{
			get
			{
				return m_canExpand;
			}
			set
			{
				m_canExpand = value;
				if (!m_canExpand)
				{
					if (m_toggle != null)
					{
						m_toggle.isOn = false;
						m_toggle.enabled = false;
					}
				}
				else if (m_toggle != null)
				{
					m_toggle.enabled = true;
					if (!IsOn)
					{
						OffGraphic.enabled = true;
					}
				}
			}
		}

		public bool IsOn
		{
			get
			{
				return m_toggle.isOn;
			}
			set
			{
				m_toggle.isOn = value && m_canExpand;
			}
		}

		private void Start()
		{
			m_toggle = GetComponent<Toggle>();
			if (!m_canExpand)
			{
				m_toggle.isOn = false;
				m_toggle.enabled = false;
			}
			if (OffGraphic != null)
			{
				OffGraphic.enabled = !m_toggle.isOn && m_canExpand;
			}
			m_toggle.onValueChanged.AddListener(OnValueChanged);
		}

		private void OnEnable()
		{
			if (m_toggle != null)
			{
				if (OffGraphic != null)
				{
					OffGraphic.enabled = !m_toggle.isOn && m_canExpand;
				}
				if (!m_canExpand)
				{
					m_toggle.onValueChanged.RemoveListener(OnValueChanged);
					m_toggle.isOn = true;
					m_toggle.isOn = false;
					m_toggle.onValueChanged.AddListener(OnValueChanged);
					m_toggle.enabled = false;
				}
			}
		}

		private void OnDestroy()
		{
			if (m_toggle != null)
			{
				m_toggle.onValueChanged.RemoveListener(OnValueChanged);
			}
		}

		private void OnValueChanged(bool value)
		{
			if (!m_canExpand)
			{
				m_toggle.isOn = false;
				m_toggle.enabled = false;
			}
			if (OffGraphic != null)
			{
				OffGraphic.enabled = !value && m_canExpand;
			}
		}
	}
	public class ParentChangedEventArgs : EventArgs
	{
		public TreeViewItem OldParent { get; private set; }

		public TreeViewItem NewParent { get; private set; }

		public ParentChangedEventArgs(TreeViewItem oldParent, TreeViewItem newParent)
		{
			OldParent = oldParent;
			NewParent = newParent;
		}
	}
	public class TreeViewItem : ItemContainer
	{
		private TreeViewExpander m_expander;

		[SerializeField]
		private HorizontalLayoutGroup m_itemLayout;

		private Toggle m_toggle;

		private TreeView m_treeView;

		private int m_indent;

		private TreeViewItem m_parent;

		private bool m_canExpand;

		private bool m_isExpanded;

		public int Indent => m_indent;

		public TreeViewItem Parent
		{
			get
			{
				return m_parent;
			}
			set
			{
				if (m_parent == value)
				{
					return;
				}
				TreeViewItem parent = m_parent;
				m_parent = value;
				if (m_parent != null && m_treeView != null && m_itemLayout != null)
				{
					m_indent = m_parent.m_indent + m_treeView.Indent;
					m_itemLayout.padding = new RectOffset(m_indent, m_itemLayout.padding.right, m_itemLayout.padding.top, m_itemLayout.padding.bottom);
					int siblingIndex = base.transform.GetSiblingIndex();
					SetIndent(this, ref siblingIndex);
				}
				else
				{
					m_indent = 0;
					if (m_itemLayout != null)
					{
						m_itemLayout.padding = new RectOffset(m_indent, m_itemLayout.padding.right, m_itemLayout.padding.top, m_itemLayout.padding.bottom);
					}
				}
				if (m_treeView != null && TreeViewItem.ParentChanged != null)
				{
					TreeViewItem.ParentChanged(this, new ParentChangedEventArgs(parent, m_parent));
				}
			}
		}

		public override bool IsSelected
		{
			get
			{
				return base.IsSelected;
			}
			set
			{
				if (base.IsSelected != value)
				{
					m_toggle.isOn = value;
					base.IsSelected = value;
				}
			}
		}

		public bool CanExpand
		{
			get
			{
				return m_canExpand;
			}
			set
			{
				if (m_canExpand != value)
				{
					m_canExpand = value;
					if (m_expander != null)
					{
						m_expander.CanExpand = m_canExpand;
					}
					if (!m_canExpand)
					{
						IsExpanded = false;
					}
				}
			}
		}

		public bool IsExpanded
		{
			get
			{
				return m_isExpanded;
			}
			set
			{
				if (m_isExpanded == value)
				{
					return;
				}
				m_isExpanded = value && m_canExpand;
				if (m_expander != null)
				{
					m_expander.IsOn = value && m_canExpand;
				}
				if (m_treeView != null)
				{
					if (m_isExpanded)
					{
						m_treeView.Expand(this);
					}
					else
					{
						m_treeView.Collapse(this);
					}
				}
			}
		}

		public bool HasChildren
		{
			get
			{
				int siblingIndex = base.transform.GetSiblingIndex();
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex + 1);
				if (treeViewItem != null)
				{
					return treeViewItem.Parent == this;
				}
				return false;
			}
		}

		public static event EventHandler<ParentChangedEventArgs> ParentChanged;

		private void SetIndent(TreeViewItem parent, ref int siblingIndex)
		{
			while (true)
			{
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex + 1);
				if (treeViewItem == null || treeViewItem.Parent != parent)
				{
					break;
				}
				treeViewItem.m_indent = parent.m_indent + m_treeView.Indent;
				treeViewItem.m_itemLayout.padding.left = treeViewItem.m_indent;
				siblingIndex++;
				SetIndent(treeViewItem, ref siblingIndex);
			}
		}

		public bool IsDescendantOf(TreeViewItem parent)
		{
			if (parent == null)
			{
				return true;
			}
			TreeViewItem treeViewItem = this;
			while (treeViewItem != null)
			{
				if (parent == treeViewItem)
				{
					return true;
				}
				treeViewItem = treeViewItem.Parent;
			}
			return false;
		}

		public TreeViewItem FirstChild()
		{
			if (!HasChildren)
			{
				return null;
			}
			int siblingIndex = base.transform.GetSiblingIndex();
			siblingIndex++;
			return (TreeViewItem)m_treeView.GetItemContainer(siblingIndex);
		}

		public TreeViewItem NextChild(TreeViewItem currentChild)
		{
			if (currentChild == null)
			{
				throw new ArgumentNullException("currentChild");
			}
			int siblingIndex = currentChild.transform.GetSiblingIndex();
			siblingIndex++;
			TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex);
			while (treeViewItem != null && treeViewItem.IsDescendantOf(this))
			{
				if (treeViewItem.Parent == this)
				{
					return treeViewItem;
				}
				siblingIndex++;
				treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(siblingIndex);
			}
			return null;
		}

		public TreeViewItem LastChild()
		{
			if (!HasChildren)
			{
				return null;
			}
			int num = base.transform.GetSiblingIndex();
			TreeViewItem result = null;
			while (true)
			{
				num++;
				TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(num);
				if (treeViewItem == null || treeViewItem.Parent != this)
				{
					break;
				}
				result = treeViewItem;
			}
			return result;
		}

		protected override void AwakeOverride()
		{
			m_toggle = GetComponent<Toggle>();
			m_toggle.interactable = false;
			m_toggle.isOn = IsSelected;
			m_expander = GetComponentInChildren<TreeViewExpander>();
			if (m_expander != null)
			{
				m_expander.CanExpand = m_canExpand;
			}
		}

		protected override void StartOverride()
		{
			m_treeView = GetComponentInParent<TreeView>();
			if (IsExpanded)
			{
				m_treeView.Expand(this);
			}
			if (Parent != null)
			{
				m_indent = Parent.m_indent + m_treeView.Indent;
				m_itemLayout.padding.left = m_indent;
			}
		}
	}
}
namespace Battlehub.Utils
{
	[ExecuteInEditMode]
	public class SaveInPlayMode : MonoBehaviour
	{
	}
	public class EditorStopwatch
	{
		public static EditorStopwatch Main;

		static EditorStopwatch()
		{
			Main = new EditorStopwatch();
		}

		public void Start()
		{
		}

		public void Stop(string output)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Property)]
	public class ExposePropertyAttribute : Attribute
	{
	}
	public class QuaternionAnimationInfo : AnimationInfo<object, Quaternion>
	{
		public QuaternionAnimationInfo(Quaternion from, Quaternion to, float duration, Func<float, float> easingFunction, AnimationCallback<object, Quaternion> callback, object target = null)
			: base(from, to, duration, easingFunction, callback, target)
		{
		}

		protected override Quaternion Lerp(Quaternion from, Quaternion to, float t)
		{
			return Quaternion.Lerp(from, to, t);
		}
	}
	public class Vector3SlerpAnimationInfo : AnimationInfo<object, Vector3>
	{
		public Vector3SlerpAnimationInfo(Vector3 from, Vector3 to, float duration, Func<float, float> easingFunction, AnimationCallback<object, Vector3> callback, object target = null)
			: base(from, to, duration, easingFunction, callback, target)
		{
		}

		protected override Vector3 Lerp(Vector3 from, Vector3 to, float t)
		{
			return Vector3.Slerp(from, to, t);
		}
	}
	public class Vector3AnimationInfo : AnimationInfo<object, Vector3>
	{
		public Vector3AnimationInfo(Vector3 from, Vector3 to, float duration, Func<float, float> easingFunction, AnimationCallback<object, Vector3> callback, object target = null)
			: base(from, to, duration, easingFunction, callback, target)
		{
		}

		protected override Vector3 Lerp(Vector3 from, Vector3 to, float t)
		{
			return Vector3.Lerp(from, to, t);
		}
	}
	public class FloatAnimationInfo : AnimationInfo<object, float>
	{
		public FloatAnimationInfo(float from, float to, float duration, Func<float, float> easingFunction, AnimationCallback<object, float> callback, object target = null)
			: base(from, to, duration, easingFunction, callback, target)
		{
		}

		protected override float Lerp(float from, float to, float t)
		{
			return to * t + from * (1f - t);
		}
	}
	public delegate void AnimationCallback<TObj, TValue>(TObj obj, TValue value, float t, bool completed);
	public abstract class AnimationInfo<TObj, TValue> : IAnimationInfo
	{
		private float m_duration;

		private float m_t;

		private TObj m_target;

		private TValue m_from;

		private TValue m_to;

		private AnimationCallback<TObj, TValue> m_callback;

		private Func<float, float> m_easingFunction;

		float IAnimationInfo.Duration => m_duration;

		float IAnimationInfo.T
		{
			get
			{
				return m_t;
			}
			set
			{
				m_t = value;
				if (m_t < 0f)
				{
					m_t = 0f;
				}
				if (!float.IsNaN(m_t))
				{
					bool flag = m_t >= m_duration;
					float t = (flag ? 1f : m_easingFunction(m_t / m_duration));
					TValue value2 = Lerp(m_from, m_to, t);
					m_callback(m_target, value2, m_t, flag);
				}
			}
		}

		public bool InProgress
		{
			get
			{
				if (m_t > 0f)
				{
					return m_t < m_duration;
				}
				return false;
			}
		}

		public static float EaseLinear(float t)
		{
			return t;
		}

		public static float EaseInQuad(float t)
		{
			return t * t;
		}

		public static float EaseOutQuad(float t)
		{
			return t * (2f - t);
		}

		public static float EaseInOutQuad(float t)
		{
			if (!((double)t < 0.5))
			{
				return -1f + (4f - 2f * t) * t;
			}
			return 2f * t * t;
		}

		public static float EaseInCubic(float t)
		{
			return t * t * t;
		}

		public static float EaseOutCubic(float t)
		{
			return (t -= 1f) * t * t + 1f;
		}

		public static float EaseInOutCubic(float t)
		{
			if (!((double)t < 0.5))
			{
				return (t - 1f) * (2f * t - 2f) * (2f * t - 2f) + 1f;
			}
			return 4f * t * t * t;
		}

		public static float EaseInQuart(float t)
		{
			return t * t * t * t;
		}

		public static float EaseOutQuart(float t)
		{
			return 1f - (t -= 1f) * t * t * t;
		}

		public static float EaseInOutQuart(float t)
		{
			if (!((double)t < 0.5))
			{
				return 1f - 8f * (t -= 1f) * t * t * t;
			}
			return 8f * t * t * t * t;
		}

		public static float ElasticEaseIn(float t)
		{
			return Mathf.Sin((float)Math.PI * 26f * t) * Mathf.Pow(2f, 10f * (t - 1f));
		}

		public static float ElasticEaseOut(float t)
		{
			return Mathf.Sin((float)Math.PI * -26f * (t + 1f)) * Mathf.Pow(2f, -10f * t) + 1f;
		}

		public static float ElasticEaseInOut(float t)
		{
			if ((double)t < 0.5)
			{
				return 0.5f * Mathf.Sin((float)Math.PI * 26f * (2f * t)) * Mathf.Pow(2f, 10f * (2f * t - 1f));
			}
			return 0.5f * (Mathf.Sin((float)Math.PI * -26f * (2f * t - 1f + 1f)) * Mathf.Pow(2f, -10f * (2f * t - 1f)) + 2f);
		}

		protected abstract TValue Lerp(TValue from, TValue to, float t);

		public void Abort()
		{
			m_t = float.NaN;
		}

		public AnimationInfo(TValue from, TValue to, float duration, Func<float, float> easingFunction, AnimationCallback<TObj, TValue> callback, TObj target)
		{
			if (callback == null)
			{
				throw new ArgumentNullException("callback");
			}
			if (easingFunction == null)
			{
				throw new ArgumentNullException("easingFunction");
			}
			m_target = target;
			m_from = from;
			m_to = to;
			m_duration = duration;
			m_callback = callback;
			m_easingFunction = easingFunction;
		}
	}
	public interface IAnimationInfo
	{
		float Duration { get; }

		float T { get; set; }

		bool InProgress { get; }

		void Abort();
	}
	[ExecuteInEditMode]
	public class Run : MonoBehaviour
	{
		private static Run m_instance;

		private List<IAnimationInfo> m_animations;

		public static Run Instance => m_instance;

		public void Animation(IAnimationInfo animation)
		{
			if (!m_animations.Contains(animation))
			{
				m_animations.Add(animation);
			}
		}

		public void Remove(IAnimationInfo animation)
		{
			m_animations.Remove(animation);
		}

		private void Awake()
		{
			if (m_instance != null)
			{
				UnityEngine.Debug.LogWarning("Another instance of Animation already exist");
			}
			m_instance = this;
			m_animations = new List<IAnimationInfo>();
		}

		private void Update()
		{
			for (int i = 0; i < m_animations.Count; i++)
			{
				IAnimationInfo animationInfo = m_animations[i];
				animationInfo.T += Time.deltaTime;
				if (animationInfo.T >= animationInfo.Duration)
				{
					m_animations.Remove(animationInfo);
				}
			}
		}
	}
}
namespace Battlehub.RTHandles
{
	public enum RuntimeTool
	{
		None,
		Move,
		Rotate,
		Scale,
		View
	}
	public enum RuntimePivotRotation
	{
		Local,
		Global
	}
	public delegate void RuntimeToolChanged();
	public delegate void RuntimePivotRotationChanged();
	public static class RuntimeTools
	{
		private static RuntimeTool m_current;

		private static RuntimePivotRotation m_pivotRotation;

		public static bool IsLocked { get; set; }

		public static bool IsDragDrop { get; set; }

		public static bool IsSceneGizmoSelected { get; set; }

		public static RuntimeTool Current
		{
			get
			{
				return m_current;
			}
			set
			{
				if (m_current != value)
				{
					m_current = value;
					if (RuntimeTools.ToolChanged != null)
					{
						RuntimeTools.ToolChanged();
					}
				}
			}
		}

		public static RuntimePivotRotation PivotRotation
		{
			get
			{
				return m_pivotRotation;
			}
			set
			{
				if (m_pivotRotation != value)
				{
					m_pivotRotation = value;
					if (RuntimeTools.PivotRotationChanged != null)
					{
						RuntimeTools.PivotRotationChanged();
					}
				}
			}
		}

		public static event RuntimeToolChanged ToolChanged;

		public static event RuntimePivotRotationChanged PivotRotationChanged;
	}
	public abstract class BaseHandle : MonoBehaviour, IGL
	{
		public KeyCode SnapToGridKey = KeyCode.LeftControl;

		public Camera Camera;

		public float SelectionMargin = 10f;

		public Transform[] Targets;

		private static BaseHandle m_draggingTool;

		private RuntimeHandleAxis m_selectedAxis;

		private bool m_isDragging;

		private Plane m_dragPlane;

		protected float EffectiveGridSize { get; private set; }

		public Transform Target => Targets[0];

		public bool IsDragging => m_isDragging;

		protected abstract RuntimeTool Tool { get; }

		protected Quaternion Rotation
		{
			get
			{
				if (Targets == null || Targets.Length == 0 || Target == null)
				{
					return Quaternion.identity;
				}
				if (RuntimeTools.PivotRotation != 0)
				{
					return Quaternion.identity;
				}
				return Target.rotation;
			}
		}

		protected RuntimeHandleAxis SelectedAxis
		{
			get
			{
				return m_selectedAxis;
			}
			set
			{
				m_selectedAxis = value;
			}
		}

		protected Plane DragPlane
		{
			get
			{
				return m_dragPlane;
			}
			set
			{
				m_dragPlane = value;
			}
		}

		protected abstract float CurrentGridSize { get; }

		private void Start()
		{
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			if (GLRenderer.Instance == null)
			{
				GameObject obj = new GameObject();
				obj.name = "GLRenderer";
				obj.AddComponent<GLRenderer>();
			}
			if (Camera != null && !Camera.GetComponent<GLCamera>())
			{
				Camera.gameObject.AddComponent<GLCamera>();
			}
			if (Targets == null || Targets.Length == 0)
			{
				Targets = new Transform[1] { base.transform };
			}
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Add(this);
			}
			if (Targets[0].position != base.transform.position)
			{
				base.transform.position = Targets[0].position;
			}
			StartOverride();
		}

		protected virtual void StartOverride()
		{
		}

		private void OnEnable()
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Add(this);
			}
			OnEnableOverride();
		}

		protected virtual void OnEnableOverride()
		{
		}

		private void OnDisable()
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Remove(this);
			}
			OnDisableOverride();
		}

		protected virtual void OnDisableOverride()
		{
		}

		private void OnDestroy()
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Remove(this);
			}
			OnDestroyOverride();
		}

		protected virtual void OnDestroyOverride()
		{
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				if ((RuntimeTools.Current != Tool && RuntimeTools.Current != 0) || RuntimeTools.IsLocked)
				{
					return;
				}
				if (Camera == null)
				{
					UnityEngine.Debug.LogError("Camera is null");
					return;
				}
				if (m_draggingTool != null)
				{
					return;
				}
				m_isDragging = OnBeginDrag();
				if (m_isDragging)
				{
					m_draggingTool = this;
				}
			}
			else if (Input.GetMouseButtonUp(0))
			{
				OnDrop();
				m_isDragging = false;
				m_draggingTool = null;
			}
			else if (m_isDragging)
			{
				if (Input.GetKey(SnapToGridKey))
				{
					EffectiveGridSize = CurrentGridSize;
				}
				else
				{
					EffectiveGridSize = 0f;
				}
				OnDrag();
			}
			UpdateOverride();
		}

		protected virtual bool OnBeginDrag()
		{
			return false;
		}

		protected virtual void OnDrag()
		{
		}

		protected virtual void OnDrop()
		{
		}

		protected virtual void UpdateOverride()
		{
			if (Targets == null || Targets.Length == 0 || !(Targets[0] != null) || !(Targets[0].position != base.transform.position))
			{
				return;
			}
			if (IsDragging)
			{
				Vector3 vector = base.transform.position - Targets[0].position;
				Targets[0].position = base.transform.position;
				for (int i = 1; i < Targets.Length; i++)
				{
					Targets[i].position += vector;
				}
			}
			else
			{
				base.transform.position = Targets[0].position;
				base.transform.rotation = Targets[0].rotation;
			}
		}

		protected bool HitCenter()
		{
			Vector2 vector = Camera.WorldToScreenPoint(base.transform.position);
			return ((Vector2)Input.mousePosition - vector).magnitude <= SelectionMargin;
		}

		protected bool HitAxis(Vector3 axis, Matrix4x4 matrix, out float distanceToAxis)
		{
			axis = matrix.MultiplyVector(axis);
			Vector2 vector = Camera.WorldToScreenPoint(base.transform.position);
			Vector3 vector2 = (Vector2)Camera.WorldToScreenPoint(axis + base.transform.position) - vector;
			float magnitude = vector2.magnitude;
			vector2.Normalize();
			if (vector2 != Vector3.zero)
			{
				Vector2 normalized = PerpendicularClockwise(vector2).normalized;
				Vector2 vector3 = (Vector2)Input.mousePosition - vector;
				distanceToAxis = Mathf.Abs(Vector2.Dot(normalized, vector3));
				Vector2 rhs = vector3 - normalized * distanceToAxis;
				float num = Vector2.Dot(vector2, rhs);
				int num2;
				if (num <= magnitude + SelectionMargin && num >= 0f - SelectionMargin)
				{
					num2 = ((distanceToAxis <= SelectionMargin) ? 1 : 0);
					if (num2 != 0)
					{
						if (magnitude < SelectionMargin)
						{
							distanceToAxis = 0f;
						}
						return (byte)num2 != 0;
					}
				}
				else
				{
					num2 = 0;
				}
				distanceToAxis = float.PositiveInfinity;
				return (byte)num2 != 0;
			}
			Vector2 vector4 = Input.mousePosition;
			distanceToAxis = (vector - vector4).magnitude;
			bool num3 = distanceToAxis <= SelectionMargin;
			if (!num3)
			{
				distanceToAxis = float.PositiveInfinity;
				return num3;
			}
			distanceToAxis = 0f;
			return num3;
		}

		protected Plane GetDragPlane(Matrix4x4 matrix, Vector3 axis)
		{
			return new Plane(matrix.MultiplyVector(axis).normalized, matrix.MultiplyPoint(Vector3.zero));
		}

		protected Plane GetDragPlane()
		{
			return new Plane(Camera.cameraToWorldMatrix.MultiplyVector(Vector3.forward).normalized, base.transform.position);
		}

		protected bool GetPointOnDragPlane(Vector3 screenPos, out Vector3 point)
		{
			return GetPointOnDragPlane(m_dragPlane, screenPos, out point);
		}

		protected bool GetPointOnDragPlane(Plane dragPlane, Vector3 screenPos, out Vector3 point)
		{
			Ray ray = Camera.ScreenPointToRay(screenPos);
			if (dragPlane.Raycast(ray, out var enter))
			{
				point = ray.GetPoint(enter);
				return true;
			}
			point = Vector3.zero;
			return false;
		}

		private static Vector2 PerpendicularClockwise(Vector2 vector2)
		{
			return new Vector2(0f - vector2.y, vector2.x);
		}

		void IGL.Draw()
		{
			DrawOverride();
		}

		protected virtual void DrawOverride()
		{
		}
	}
	[ExecuteInEditMode]
	public class GLCamera : MonoBehaviour
	{
		public int CullingMask = -1;

		private Camera m_camera;

		private void Awake()
		{
			m_camera = GetComponent<Camera>();
			RenderPipelineManager.endCameraRendering += OnEndCameraRendering;
		}

		private void OnDestroy()
		{
			RenderPipelineManager.endCameraRendering -= OnEndCameraRendering;
		}

		private void OnEndCameraRendering(ScriptableRenderContext context, Camera camera)
		{
			if (m_camera == camera)
			{
				Camera.SetupCurrent(camera);
				if (GLRenderer.Instance != null)
				{
					GLRenderer.Instance.Draw();
				}
			}
		}

		private void OnPostRender()
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Draw();
			}
		}
	}
	public interface IGL
	{
		void Draw();
	}
	[ExecuteInEditMode]
	public class GLRenderer : MonoBehaviour
	{
		private static GLRenderer m_instance;

		private List<IGL> m_renderObjects;

		public static GLRenderer Instance => m_instance;

		public void Add(IGL gl)
		{
			if (!m_renderObjects.Contains(gl))
			{
				m_renderObjects.Add(gl);
			}
		}

		public void Remove(IGL line)
		{
			m_renderObjects.Remove(line);
		}

		private void Awake()
		{
			if (m_instance != null)
			{
				UnityEngine.Debug.LogWarning("Another instance of GLLinesRenderer aleready exist");
			}
			m_instance = this;
			m_renderObjects = new List<IGL>();
		}

		private void OnDestroy()
		{
			m_instance = null;
		}

		public void Draw()
		{
			if (m_renderObjects == null)
			{
				return;
			}
			GL.PushMatrix();
			try
			{
				for (int i = 0; i < m_renderObjects.Count; i++)
				{
					m_renderObjects[i].Draw();
				}
			}
			finally
			{
				GL.PopMatrix();
			}
		}
	}
	[RequireComponent(typeof(Camera))]
	public class Grid : MonoBehaviour
	{
		private Camera m_camera;

		public Camera Camera;

		private void Start()
		{
			m_camera = GetComponent<Camera>();
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			m_camera.clearFlags = CameraClearFlags.Nothing;
			m_camera.renderingPath = RenderingPath.Forward;
			m_camera.cullingMask = 0;
			SetupCamera();
		}

		private void OnPreRender()
		{
			m_camera.farClipPlane = RuntimeHandles.GetGridFarPlane();
		}

		private void OnPostRender()
		{
			RuntimeHandles.DrawGrid();
		}

		private void Update()
		{
			SetupCamera();
		}

		private void SetupCamera()
		{
			m_camera.transform.position = Camera.transform.position;
			m_camera.transform.rotation = Camera.transform.rotation;
			m_camera.transform.localScale = Camera.transform.localScale;
			if (m_camera.fieldOfView != Camera.fieldOfView)
			{
				m_camera.fieldOfView = Camera.fieldOfView;
			}
			if (m_camera.orthographic != Camera.orthographic)
			{
				m_camera.orthographic = Camera.orthographic;
			}
			if (m_camera.orthographicSize != Camera.orthographicSize)
			{
				m_camera.orthographicSize = Camera.orthographicSize;
			}
			if (m_camera.rect != Camera.rect)
			{
				m_camera.rect = Camera.rect;
			}
		}
	}
	public class PositionHandle : BaseHandle
	{
		public float GridSize = 1f;

		private Vector3 m_cursorPosition;

		private Vector3 m_currentPosition;

		private Vector3 m_prevPoint;

		private Matrix4x4 m_matrix;

		private Matrix4x4 m_inverse;

		public static PositionHandle Current { get; private set; }

		protected override RuntimeTool Tool => RuntimeTool.Move;

		protected override float CurrentGridSize => GridSize;

		protected override void StartOverride()
		{
			Current = this;
		}

		protected override void OnDestroyOverride()
		{
			if (Current == this)
			{
				Current = null;
			}
		}

		private bool HitQuad(Vector3 axis, Matrix4x4 matrix, float size)
		{
			Ray ray = Camera.ScreenPointToRay(Input.mousePosition);
			Plane plane = new Plane(matrix.MultiplyVector(axis).normalized, matrix.MultiplyPoint(Vector3.zero));
			if (!plane.Raycast(ray, out var enter))
			{
				return false;
			}
			Vector3 point = ray.GetPoint(enter);
			point = matrix.inverse.MultiplyPoint(point);
			Vector3 lhs = Camera.transform.position - base.transform.position;
			float num = Mathf.Sign(Vector3.Dot(lhs, Vector3.right));
			float num2 = Mathf.Sign(Vector3.Dot(lhs, Vector3.up));
			float num3 = Mathf.Sign(Vector3.Dot(lhs, Vector3.forward));
			point.x *= num;
			point.y *= num2;
			point.z *= num3;
			float num4 = -0.01f;
			int num5;
			if (point.x >= num4 && point.x <= size && point.y >= num4 && point.y <= size && point.z >= num4)
			{
				num5 = ((point.z <= size) ? 1 : 0);
				if (num5 != 0)
				{
					base.DragPlane = GetDragPlane(matrix, axis);
				}
			}
			else
			{
				num5 = 0;
			}
			return (byte)num5 != 0;
		}

		protected override bool OnBeginDrag()
		{
			m_cursorPosition = base.transform.position;
			m_currentPosition = m_cursorPosition;
			float screenScale = RuntimeHandles.GetScreenScale(base.transform.position, Camera);
			m_matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, Vector3.one);
			m_inverse = m_matrix.inverse;
			Matrix4x4 matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, new Vector3(screenScale, screenScale, screenScale));
			float size = 0.3f * screenScale;
			if (HitQuad(Vector3.up, m_matrix, size))
			{
				base.SelectedAxis = RuntimeHandleAxis.XZ;
				return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
			}
			if (HitQuad(Vector3.right, m_matrix, size))
			{
				base.SelectedAxis = RuntimeHandleAxis.YZ;
				return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
			}
			if (HitQuad(Vector3.forward, m_matrix, size))
			{
				base.SelectedAxis = RuntimeHandleAxis.XY;
				return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
			}
			if (HitAxis(Vector3.up, matrix, out var distanceToAxis) | HitAxis(Vector3.forward, matrix, out var distanceToAxis2) | HitAxis(Vector3.right, matrix, out var distanceToAxis3))
			{
				if (distanceToAxis <= distanceToAxis2 && distanceToAxis <= distanceToAxis3)
				{
					base.SelectedAxis = RuntimeHandleAxis.Y;
				}
				else if (distanceToAxis3 <= distanceToAxis && distanceToAxis3 <= distanceToAxis2)
				{
					base.SelectedAxis = RuntimeHandleAxis.X;
				}
				else
				{
					base.SelectedAxis = RuntimeHandleAxis.Z;
				}
				base.DragPlane = GetDragPlane();
				return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
			}
			base.SelectedAxis = RuntimeHandleAxis.None;
			return false;
		}

		protected override void OnDrag()
		{
			if (!GetPointOnDragPlane(Input.mousePosition, out var point))
			{
				return;
			}
			Vector3 vector = m_inverse.MultiplyVector(point - m_prevPoint);
			float magnitude = vector.magnitude;
			if (base.SelectedAxis == RuntimeHandleAxis.X)
			{
				vector.y = (vector.z = 0f);
			}
			else if (base.SelectedAxis == RuntimeHandleAxis.Y)
			{
				vector.x = (vector.z = 0f);
			}
			else if (base.SelectedAxis == RuntimeHandleAxis.Z)
			{
				vector.x = (vector.y = 0f);
			}
			if ((double)base.EffectiveGridSize == 0.0)
			{
				vector = m_matrix.MultiplyVector(vector).normalized * magnitude;
				base.transform.position += vector;
				m_prevPoint = point;
				return;
			}
			vector = m_matrix.MultiplyVector(vector).normalized * magnitude;
			m_cursorPosition += vector;
			Vector3 vector2 = m_cursorPosition - m_currentPosition;
			if (vector2.magnitude * 1.5f >= base.EffectiveGridSize)
			{
				m_currentPosition += vector2.normalized * base.EffectiveGridSize;
				base.transform.position = m_currentPosition;
			}
			m_prevPoint = point;
		}

		protected override void DrawOverride()
		{
			RuntimeHandles.DoPositionHandle(base.transform.position, base.Rotation, base.SelectedAxis);
		}
	}
	public class RotationHandle : BaseHandle
	{
		public float GridSize = 15f;

		public float XSpeed = 10f;

		public float YSpeed = 10f;

		private Matrix4x4 m_targetInverse;

		private Matrix4x4 m_matrix;

		private Matrix4x4 m_inverse;

		private const float innerRadius = 1f;

		private const float outerRadius = 1.2f;

		private const float hitDot = 0.2f;

		private float m_deltaX;

		private float m_deltaY;

		public static RotationHandle Current { get; private set; }

		protected override RuntimeTool Tool => RuntimeTool.Rotate;

		protected override float CurrentGridSize => GridSize;

		protected override void StartOverride()
		{
			Current = this;
		}

		protected override void OnDestroyOverride()
		{
			if (Current == this)
			{
				Current = null;
			}
		}

		protected override void OnEnableOverride()
		{
			base.OnEnableOverride();
		}

		private bool Intersect(Ray r, Vector3 sphereCenter, float sphereRadius, out float hit1Distance, out float hit2Distance)
		{
			hit1Distance = 0f;
			hit2Distance = 0f;
			Vector3 vector = sphereCenter - r.origin;
			float num = Vector3.Dot(vector, r.direction);
			if ((double)num < 0.0)
			{
				return false;
			}
			float num2 = Vector3.Dot(vector, vector) - num * num;
			float num3 = sphereRadius * sphereRadius;
			if (num2 > num3)
			{
				return false;
			}
			float num4 = Mathf.Sqrt(num3 - num2);
			hit1Distance = num - num4;
			hit2Distance = num + num4;
			return true;
		}

		private RuntimeHandleAxis Hit()
		{
			Ray r = Camera.ScreenPointToRay(Input.mousePosition);
			float screenScale = RuntimeHandles.GetScreenScale(base.Target.position, Camera);
			if (Intersect(r, base.Target.position, 1.2f * screenScale, out var hit1Distance, out var hit2Distance))
			{
				GetPointOnDragPlane(GetDragPlane(), Input.mousePosition, out var point);
				if ((point - base.Target.position).magnitude <= 1f * screenScale)
				{
					Intersect(r, base.Target.position, 1f * screenScale, out hit1Distance, out hit2Distance);
					Vector3 normalized = m_targetInverse.MultiplyPoint(r.GetPoint(hit1Distance)).normalized;
					float num = Mathf.Abs(Vector3.Dot(normalized, Vector3.right));
					float num2 = Mathf.Abs(Vector3.Dot(normalized, Vector3.up));
					float num3 = Mathf.Abs(Vector3.Dot(normalized, Vector3.forward));
					if (num < 0.2f)
					{
						return RuntimeHandleAxis.X;
					}
					if (num2 < 0.2f)
					{
						return RuntimeHandleAxis.Y;
					}
					if (num3 < 0.2f)
					{
						return RuntimeHandleAxis.Z;
					}
					return RuntimeHandleAxis.Free;
				}
				return RuntimeHandleAxis.Screen;
			}
			return RuntimeHandleAxis.None;
		}

		protected override bool OnBeginDrag()
		{
			m_targetInverse = Matrix4x4.TRS(base.Target.position, base.Target.rotation, Vector3.one).inverse;
			base.SelectedAxis = Hit();
			m_deltaX = 0f;
			m_deltaY = 0f;
			if (base.SelectedAxis == RuntimeHandleAxis.Screen)
			{
				Vector2 vector = Camera.WorldToScreenPoint(base.Target.position);
				Vector2 vector2 = Input.mousePosition;
				float num = Mathf.Atan2(vector2.y - vector.y, vector2.x - vector.x);
				m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.AngleAxis(57.29578f * num, Vector3.forward), Vector3.one);
			}
			else
			{
				m_matrix = Matrix4x4.TRS(Vector3.zero, base.Target.rotation, Vector3.one);
			}
			m_inverse = m_matrix.inverse;
			return base.SelectedAxis != RuntimeHandleAxis.None;
		}

		protected override void OnDrag()
		{
			float axis = Input.GetAxis("Mouse X");
			float axis2 = Input.GetAxis("Mouse Y");
			axis *= XSpeed;
			axis2 *= YSpeed;
			m_deltaX += axis;
			m_deltaY += axis2;
			Vector3 vector = m_inverse.MultiplyVector(Camera.cameraToWorldMatrix.MultiplyVector(new Vector3(m_deltaY, 0f - m_deltaX, 0f)));
			Quaternion quaternion;
			if (base.SelectedAxis == RuntimeHandleAxis.X)
			{
				if (base.EffectiveGridSize != 0f)
				{
					if (Mathf.Abs(vector.x) >= base.EffectiveGridSize)
					{
						vector.x = Mathf.Sign(vector.x) * base.EffectiveGridSize;
						m_deltaX = 0f;
						m_deltaY = 0f;
					}
					else
					{
						vector.x = 0f;
					}
				}
				quaternion = Quaternion.Euler(vector.x, 0f, 0f);
			}
			else if (base.SelectedAxis == RuntimeHandleAxis.Y)
			{
				if (base.EffectiveGridSize != 0f)
				{
					if (Mathf.Abs(vector.y) >= base.EffectiveGridSize)
					{
						vector.y = Mathf.Sign(vector.y) * base.EffectiveGridSize;
						m_deltaX = 0f;
						m_deltaY = 0f;
					}
					else
					{
						vector.y = 0f;
					}
				}
				quaternion = Quaternion.Euler(0f, vector.y, 0f);
			}
			else if (base.SelectedAxis == RuntimeHandleAxis.Z)
			{
				if (base.EffectiveGridSize != 0f)
				{
					if (Mathf.Abs(vector.z) >= base.EffectiveGridSize)
					{
						vector.z = Mathf.Sign(vector.z) * base.EffectiveGridSize;
						m_deltaX = 0f;
						m_deltaY = 0f;
					}
					else
					{
						vector.z = 0f;
					}
				}
				quaternion = Quaternion.Euler(0f, 0f, vector.z);
			}
			else if (base.SelectedAxis == RuntimeHandleAxis.Free)
			{
				quaternion = Quaternion.Euler(vector.x, vector.y, vector.z);
				m_deltaX = 0f;
				m_deltaY = 0f;
			}
			else
			{
				vector = m_inverse.MultiplyVector(new Vector3(m_deltaY, 0f - m_deltaX, 0f));
				if (base.EffectiveGridSize != 0f)
				{
					if (Mathf.Abs(vector.x) >= base.EffectiveGridSize)
					{
						vector.x = Mathf.Sign(vector.x) * base.EffectiveGridSize;
						m_deltaX = 0f;
						m_deltaY = 0f;
					}
					else
					{
						vector.x = 0f;
					}
				}
				Vector3 axis3 = m_targetInverse.MultiplyVector(Camera.cameraToWorldMatrix.MultiplyVector(-Vector3.forward));
				quaternion = Quaternion.AngleAxis(vector.x, axis3);
			}
			if (base.EffectiveGridSize == 0f)
			{
				m_deltaX = 0f;
				m_deltaY = 0f;
			}
			for (int i = 0; i < Targets.Length; i++)
			{
				Targets[i].rotation *= quaternion;
			}
		}

		protected override void DrawOverride()
		{
			RuntimeHandles.DoRotationHandle(base.Target.rotation, base.Target.position, base.SelectedAxis);
		}
	}
	public enum RuntimeHandleAxis
	{
		None,
		X,
		Y,
		Z,
		XY,
		XZ,
		YZ,
		Screen,
		Free
	}
	public static class RuntimeHandles
	{
		public static readonly Color32 XColor;

		public static readonly Color32 XColorTransparent;

		public static readonly Color32 YColor;

		public static readonly Color32 YColorTransparent;

		public static readonly Color32 ZColor;

		public static readonly Color32 ZColorTransparent;

		public static readonly Color32 AltColor;

		public static readonly Color32 SelectionColor;

		private static readonly Mesh Arrows;

		private static readonly Mesh SelectionArrowY;

		private static readonly Mesh SelectionArrowX;

		private static readonly Mesh SelectionArrowZ;

		private static readonly Mesh SelectionCube;

		private static readonly Mesh CubeX;

		private static readonly Mesh CubeY;

		private static readonly Mesh CubeZ;

		private static readonly Mesh CubeUniform;

		private static readonly Mesh SceneGizmoSelectedAxis;

		private static readonly Mesh SceneGizmoXAxis;

		private static readonly Mesh SceneGizmoYAxis;

		private static readonly Mesh SceneGizmoZAxis;

		private static readonly Mesh SceneGizmoCube;

		private static readonly Mesh SceneGizmoSelectedCube;

		private static readonly Mesh SceneGizmoQuad;

		private static readonly Material ShapesMaterialZTest;

		private static readonly Material ShapesMaterialZTest2;

		private static readonly Material ShapesMaterialZTest3;

		private static readonly Material ShapesMaterialZTest4;

		private static readonly Material ShapesMaterialZTestOffset;

		private static readonly Material ShapesMaterial;

		private static readonly Material LinesMaterial;

		private static readonly Material LinesClipMaterial;

		private static readonly Material LinesBillboardMaterial;

		private static readonly Material XMaterial;

		private static readonly Material YMaterial;

		private static readonly Material ZMaterial;

		private static readonly Material GridMaterial;

		static RuntimeHandles()
		{
			XColor = new Color32(187, 70, 45, byte.MaxValue);
			XColorTransparent = new Color32(187, 70, 45, 128);
			YColor = new Color32(139, 206, 74, byte.MaxValue);
			YColorTransparent = new Color32(139, 206, 74, 128);
			ZColor = new Color32(55, 115, 244, byte.MaxValue);
			ZColorTransparent = new Color32(55, 115, 244, 128);
			AltColor = new Color32(192, 192, 192, 224);
			SelectionColor = new Color32(239, 238, 64, byte.MaxValue);
			LinesMaterial = new Material(Shader.Find("Battlehub/RTHandles/VertexColor"));
			LinesMaterial.color = Color.white;
			LinesClipMaterial = new Material(Shader.Find("Battlehub/RTHandles/VertexColorClip"));
			LinesClipMaterial.color = Color.white;
			LinesBillboardMaterial = new Material(Shader.Find("Battlehub/RTHandles/VertexColorBillboard"));
			LinesBillboardMaterial.color = Color.white;
			ShapesMaterial = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
			ShapesMaterial.color = Color.white;
			ShapesMaterialZTest = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
			ShapesMaterialZTest.color = new Color(1f, 1f, 1f, 0f);
			ShapesMaterialZTest.SetFloat("_ZTest", 4f);
			ShapesMaterialZTest.SetFloat("_ZWrite", 1f);
			ShapesMaterialZTestOffset = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
			ShapesMaterialZTestOffset.color = new Color(1f, 1f, 1f, 1f);
			ShapesMaterialZTestOffset.SetFloat("_ZTest", 4f);
			ShapesMaterialZTestOffset.SetFloat("_ZWrite", 1f);
			ShapesMaterialZTestOffset.SetFloat("_OFactors", -1f);
			ShapesMaterialZTestOffset.SetFloat("_OUnits", -1f);
			ShapesMaterialZTest2 = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
			ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, 0f);
			ShapesMaterialZTest2.SetFloat("_ZTest", 4f);
			ShapesMaterialZTest2.SetFloat("_ZWrite", 1f);
			ShapesMaterialZTest3 = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
			ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, 0f);
			ShapesMaterialZTest3.SetFloat("_ZTest", 4f);
			ShapesMaterialZTest3.SetFloat("_ZWrite", 1f);
			ShapesMaterialZTest4 = new Material(Shader.Find("Battlehub/RTHandles/Shape"));
			ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, 0f);
			ShapesMaterialZTest4.SetFloat("_ZTest", 4f);
			ShapesMaterialZTest4.SetFloat("_ZWrite", 1f);
			XMaterial = new Material(Shader.Find("Battlehub/RTHandles/Billboard"));
			XMaterial.color = Color.white;
			XMaterial.mainTexture = Resources.Load<Texture>("Battlehub.RuntimeHandles.x");
			YMaterial = new Material(Shader.Find("Battlehub/RTHandles/Billboard"));
			YMaterial.color = Color.white;
			YMaterial.mainTexture = Resources.Load<Texture>("Battlehub.RuntimeHandles.y");
			ZMaterial = new Material(Shader.Find("Battlehub/RTHandles/Billboard"));
			ZMaterial.color = Color.white;
			ZMaterial.mainTexture = Resources.Load<Texture>("Battlehub.RuntimeHandles.z");
			GridMaterial = new Material(Shader.Find("Battlehub/RTHandles/Grid"));
			GridMaterial.color = Color.white;
			Mesh mesh = CreateConeMesh(SelectionColor);
			CombineInstance combineInstance = new CombineInstance
			{
				mesh = mesh,
				transform = Matrix4x4.TRS(Vector3.up, Quaternion.identity, Vector3.one)
			};
			SelectionArrowY = new Mesh();
			SelectionArrowY.CombineMeshes(new CombineInstance[1] { combineInstance }, mergeSubMeshes: true);
			SelectionArrowY.RecalculateNormals();
			CombineInstance combineInstance2 = new CombineInstance
			{
				mesh = mesh,
				transform = Matrix4x4.TRS(Vector3.right, Quaternion.AngleAxis(-90f, Vector3.forward), Vector3.one)
			};
			SelectionArrowX = new Mesh();
			SelectionArrowX.CombineMeshes(new CombineInstance[1] { combineInstance2 }, mergeSubMeshes: true);
			SelectionArrowX.RecalculateNormals();
			CombineInstance combineInstance3 = new CombineInstance
			{
				mesh = mesh,
				transform = Matrix4x4.TRS(Vector3.forward, Quaternion.AngleAxis(90f, Vector3.right), Vector3.one)
			};
			SelectionArrowZ = new Mesh();
			SelectionArrowZ.CombineMeshes(new CombineInstance[1] { combineInstance3 }, mergeSubMeshes: true);
			SelectionArrowZ.RecalculateNormals();
			combineInstance.mesh = CreateConeMesh(YColor);
			combineInstance2.mesh = CreateConeMesh(XColor);
			combineInstance3.mesh = CreateConeMesh(ZColor);
			Arrows = new Mesh();
			Arrows.CombineMeshes(new CombineInstance[3] { combineInstance, combineInstance2, combineInstance3 }, mergeSubMeshes: true);
			Arrows.RecalculateNormals();
			SelectionCube = CreateCubeMesh(SelectionColor, 0.1f, 0.1f, 0.1f);
			CubeX = CreateCubeMesh(XColor, 0.1f, 0.1f, 0.1f);
			CubeY = CreateCubeMesh(YColor, 0.1f, 0.1f, 0.1f);
			CubeZ = CreateCubeMesh(ZColor, 0.1f, 0.1f, 0.1f);
			CubeUniform = CreateCubeMesh(AltColor, 0.1f, 0.1f, 0.1f);
			SceneGizmoSelectedAxis = CreateSceneGizmoHalfAxis(SelectionColor, Quaternion.AngleAxis(90f, Vector3.right));
			SceneGizmoXAxis = CreateSceneGizmoAxis(XColor, AltColor, Quaternion.AngleAxis(-90f, Vector3.forward));
			SceneGizmoYAxis = CreateSceneGizmoAxis(YColor, AltColor, Quaternion.identity);
			SceneGizmoZAxis = CreateSceneGizmoAxis(ZColor, AltColor, Quaternion.AngleAxis(90f, Vector3.right));
			SceneGizmoCube = CreateCubeMesh(AltColor);
			SceneGizmoSelectedCube = CreateCubeMesh(SelectionColor);
			SceneGizmoQuad = CreateQuadMesh();
		}

		private static Mesh CreateQuadMesh(float quadWidth = 1f, float cubeHeight = 1f)
		{
			Vector3 vector = new Vector3((0f - quadWidth) * 0.5f, (0f - cubeHeight) * 0.5f, 0f);
			Vector3 vector2 = new Vector3(quadWidth * 0.5f, (0f - cubeHeight) * 0.5f, 0f);
			Vector3 vector3 = new Vector3((0f - quadWidth) * 0.5f, cubeHeight * 0.5f, 0f);
			Vector3 vector4 = new Vector3(quadWidth * 0.5f, cubeHeight * 0.5f, 0f);
			Vector3[] vertices = new Vector3[4] { vector3, vector4, vector2, vector };
			int[] triangles = new int[6] { 3, 1, 0, 3, 2, 1 };
			Vector2[] uv = new Vector2[4]
			{
				new Vector2(1f, 0f),
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f)
			};
			Mesh mesh = new Mesh();
			mesh.name = "quad";
			mesh.vertices = vertices;
			mesh.triangles = triangles;
			mesh.uv = uv;
			mesh.RecalculateNormals();
			return mesh;
		}

		private static Mesh CreateCubeMesh(Color color, float cubeLength = 1f, float cubeWidth = 1f, float cubeHeight = 1f)
		{
			Vector3 vector = new Vector3((0f - cubeLength) * 0.5f, (0f - cubeWidth) * 0.5f, cubeHeight * 0.5f);
			Vector3 vector2 = new Vector3(cubeLength * 0.5f, (0f - cubeWidth) * 0.5f, cubeHeight * 0.5f);
			Vector3 vector3 = new Vector3(cubeLength * 0.5f, (0f - cubeWidth) * 0.5f, (0f - cubeHeight) * 0.5f);
			Vector3 vector4 = new Vector3((0f - cubeLength) * 0.5f, (0f - cubeWidth) * 0.5f, (0f - cubeHeight) * 0.5f);
			Vector3 vector5 = new Vector3((0f - cubeLength) * 0.5f, cubeWidth * 0.5f, cubeHeight * 0.5f);
			Vector3 vector6 = new Vector3(cubeLength * 0.5f, cubeWidth * 0.5f, cubeHeight * 0.5f);
			Vector3 vector7 = new Vector3(cubeLength * 0.5f, cubeWidth * 0.5f, (0f - cubeHeight) * 0.5f);
			Vector3 vector8 = new Vector3((0f - cubeLength) * 0.5f, cubeWidth * 0.5f, (0f - cubeHeight) * 0.5f);
			Vector3[] array = new Vector3[24]
			{
				vector, vector2, vector3, vector4, vector8, vector5, vector, vector4, vector5, vector6,
				vector2, vector, vector7, vector8, vector4, vector3, vector6, vector7, vector3, vector2,
				vector8, vector7, vector6, vector5
			};
			int[] triangles = new int[36]
			{
				3, 1, 0, 3, 2, 1, 7, 5, 4, 7,
				6, 5, 11, 9, 8, 11, 10, 9, 15, 13,
				12, 15, 14, 13, 19, 17, 16, 19, 18, 17,
				23, 21, 20, 23, 22, 21
			};
			Color[] array2 = new Color[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = color;
			}
			Mesh mesh = new Mesh();
			mesh.name = "cube";
			mesh.vertices = array;
			mesh.triangles = triangles;
			mesh.colors = array2;
			mesh.RecalculateNormals();
			return mesh;
		}

		private static Mesh CreateConeMesh(Color color)
		{
			int num = 12;
			float num2 = 0.2f;
			Vector3[] array = new Vector3[num * 3 + 1];
			int[] array2 = new int[num * 6];
			Color[] array3 = new Color[array.Length];
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i] = color;
			}
			float num3 = num2 / 2.6f;
			float num4 = num2;
			float num5 = (float)Math.PI * 2f / (float)num;
			float y = 0f - num4;
			array[array.Length - 1] = new Vector3(0f, 0f - num4, 0f);
			for (int j = 0; j < num; j++)
			{
				float f = (float)j * num5;
				float x = Mathf.Cos(f) * num3;
				float z = Mathf.Sin(f) * num3;
				array[j] = new Vector3(x, y, z);
				array[num + j] = new Vector3(0f, 0.01f, 0f);
				array[2 * num + j] = array[j];
			}
			for (int k = 0; k < num; k++)
			{
				array2[k * 6] = k;
				array2[k * 6 + 1] = num + k;
				array2[k * 6 + 2] = (k + 1) % num;
				array2[k * 6 + 3] = array.Length - 1;
				array2[k * 6 + 4] = 2 * num + k;
				array2[k * 6 + 5] = 2 * num + (k + 1) % num;
			}
			return new Mesh
			{
				name = "Cone",
				vertices = array,
				triangles = array2,
				colors = array3
			};
		}

		private static Mesh CreateSceneGizmoHalfAxis(Color color, Quaternion rotation)
		{
			Mesh mesh = CreateConeMesh(color);
			CombineInstance combineInstance = default(CombineInstance);
			combineInstance.mesh = mesh;
			combineInstance.transform = Matrix4x4.TRS(Vector3.up * 0.1f, Quaternion.AngleAxis(180f, Vector3.right), Vector3.one);
			Mesh mesh2 = new Mesh();
			mesh2.CombineMeshes(new CombineInstance[1] { combineInstance }, mergeSubMeshes: true);
			CombineInstance combineInstance2 = default(CombineInstance);
			combineInstance2.mesh = mesh2;
			combineInstance2.transform = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
			mesh2 = new Mesh();
			mesh2.CombineMeshes(new CombineInstance[1] { combineInstance2 }, mergeSubMeshes: true);
			mesh2.RecalculateNormals();
			return mesh2;
		}

		private static Mesh CreateSceneGizmoAxis(Color axisColor, Color altColor, Quaternion rotation)
		{
			Mesh mesh = CreateConeMesh(axisColor);
			Mesh mesh2 = CreateConeMesh(altColor);
			CombineInstance combineInstance = default(CombineInstance);
			combineInstance.mesh = mesh;
			combineInstance.transform = Matrix4x4.TRS(Vector3.up * 0.1f, Quaternion.AngleAxis(180f, Vector3.right), Vector3.one);
			CombineInstance combineInstance2 = default(CombineInstance);
			combineInstance2.mesh = mesh2;
			combineInstance2.transform = Matrix4x4.TRS(Vector3.down * 0.1f, Quaternion.identity, Vector3.one);
			Mesh mesh3 = new Mesh();
			mesh3.CombineMeshes(new CombineInstance[2] { combineInstance, combineInstance2 }, mergeSubMeshes: true);
			CombineInstance combineInstance3 = default(CombineInstance);
			combineInstance3.mesh = mesh3;
			combineInstance3.transform = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
			mesh3 = new Mesh();
			mesh3.CombineMeshes(new CombineInstance[1] { combineInstance3 }, mergeSubMeshes: true);
			mesh3.RecalculateNormals();
			return mesh3;
		}

		public static float GetScreenScale(Vector3 position, Camera camera)
		{
			float num = camera.pixelHeight;
			if (camera.orthographic)
			{
				return camera.orthographicSize * 2f / num * 90f;
			}
			Transform transform = camera.transform;
			float num2 = Vector3.Dot(position - transform.position, transform.forward);
			return 2f * num2 * Mathf.Tan(camera.fieldOfView * 0.5f * ((float)Math.PI / 180f)) / num * 90f;
		}

		private static void DoAxes(Vector3 position, Matrix4x4 transform, RuntimeHandleAxis selectedAxis)
		{
			Vector3 right = Vector3.right;
			Vector3 up = Vector3.up;
			Vector3 forward = Vector3.forward;
			right = transform.MultiplyVector(right);
			up = transform.MultiplyVector(up);
			forward = transform.MultiplyVector(forward);
			GL.Color((selectedAxis != RuntimeHandleAxis.X) ? XColor : SelectionColor);
			GL.Vertex(position);
			GL.Vertex(position + right);
			GL.Color((selectedAxis != RuntimeHandleAxis.Y) ? YColor : SelectionColor);
			GL.Vertex(position);
			GL.Vertex(position + up);
			GL.Color((selectedAxis != RuntimeHandleAxis.Z) ? ZColor : SelectionColor);
			GL.Vertex(position);
			GL.Vertex(position + forward);
		}

		public static void DoPositionHandle(Vector3 position, Quaternion rotation, RuntimeHandleAxis selectedAxis = RuntimeHandleAxis.None)
		{
			float screenScale = GetScreenScale(position, Camera.current);
			Matrix4x4 matrix4x = Matrix4x4.TRS(position, rotation, new Vector3(screenScale, screenScale, screenScale));
			LinesMaterial.SetPass(0);
			GL.Begin(1);
			DoAxes(position, matrix4x, selectedAxis);
			Vector3 vector = Vector3.right * 0.2f;
			Vector3 vector2 = Vector3.up * 0.2f;
			Vector3 vector3 = Vector3.forward * 0.2f;
			Vector3 lhs = Camera.current.transform.position - position;
			float num = Mathf.Sign(Vector3.Dot(lhs, vector));
			float num2 = Mathf.Sign(Vector3.Dot(lhs, vector2));
			float num3 = Mathf.Sign(Vector3.Dot(lhs, vector3));
			vector.x *= num;
			vector2.y *= num2;
			vector3.z *= num3;
			Vector3 point = vector + vector2;
			Vector3 point2 = vector + vector3;
			Vector3 point3 = vector2 + vector3;
			vector = matrix4x.MultiplyPoint(vector);
			vector2 = matrix4x.MultiplyPoint(vector2);
			vector3 = matrix4x.MultiplyPoint(vector3);
			point = matrix4x.MultiplyPoint(point);
			point2 = matrix4x.MultiplyPoint(point2);
			point3 = matrix4x.MultiplyPoint(point3);
			GL.Color((selectedAxis != RuntimeHandleAxis.XZ) ? YColor : SelectionColor);
			GL.Vertex(position);
			GL.Vertex(vector3);
			GL.Vertex(vector3);
			GL.Vertex(point2);
			GL.Vertex(point2);
			GL.Vertex(vector);
			GL.Vertex(vector);
			GL.Vertex(position);
			GL.Color((selectedAxis != RuntimeHandleAxis.XY) ? ZColor : SelectionColor);
			GL.Vertex(position);
			GL.Vertex(vector2);
			GL.Vertex(vector2);
			GL.Vertex(point);
			GL.Vertex(point);
			GL.Vertex(vector);
			GL.Vertex(vector);
			GL.Vertex(position);
			GL.Color((selectedAxis != RuntimeHandleAxis.YZ) ? XColor : SelectionColor);
			GL.Vertex(position);
			GL.Vertex(vector2);
			GL.Vertex(vector2);
			GL.Vertex(point3);
			GL.Vertex(point3);
			GL.Vertex(vector3);
			GL.Vertex(vector3);
			GL.Vertex(position);
			GL.End();
			GL.Begin(7);
			GL.Color(YColorTransparent);
			GL.Vertex(position);
			GL.Vertex(vector3);
			GL.Vertex(point2);
			GL.Vertex(vector);
			GL.Color(ZColorTransparent);
			GL.Vertex(position);
			GL.Vertex(vector2);
			GL.Vertex(point);
			GL.Vertex(vector);
			GL.Color(XColorTransparent);
			GL.Vertex(position);
			GL.Vertex(vector2);
			GL.Vertex(point3);
			GL.Vertex(vector3);
			GL.End();
			ShapesMaterial.SetPass(0);
			Graphics.DrawMeshNow(Arrows, matrix4x);
			switch (selectedAxis)
			{
			case RuntimeHandleAxis.X:
				Graphics.DrawMeshNow(SelectionArrowX, matrix4x);
				break;
			case RuntimeHandleAxis.Y:
				Graphics.DrawMeshNow(SelectionArrowY, matrix4x);
				break;
			case RuntimeHandleAxis.Z:
				Graphics.DrawMeshNow(SelectionArrowZ, matrix4x);
				break;
			}
		}

		public static void DoRotationHandle(Quaternion rotation, Vector3 position, RuntimeHandleAxis selectedAxis = RuntimeHandleAxis.None)
		{
			float screenScale = GetScreenScale(position, Camera.current);
			float num = 1f;
			Vector3 s = new Vector3(screenScale, screenScale, screenScale);
			Matrix4x4 transform = Matrix4x4.TRS(Vector3.zero, rotation * Quaternion.AngleAxis(-90f, Vector3.up), Vector3.one);
			Matrix4x4 transform2 = Matrix4x4.TRS(Vector3.zero, rotation * Quaternion.AngleAxis(-90f, Vector3.right), Vector3.one);
			Matrix4x4 transform3 = Matrix4x4.TRS(Vector3.zero, rotation, Vector3.one);
			Matrix4x4 m = Matrix4x4.TRS(position, Quaternion.identity, s);
			LinesClipMaterial.SetPass(0);
			GL.PushMatrix();
			GL.MultMatrix(m);
			GL.Begin(1);
			GL.Color((selectedAxis != RuntimeHandleAxis.X) ? XColor : SelectionColor);
			DrawCircle(transform, num);
			GL.Color((selectedAxis != RuntimeHandleAxis.Y) ? YColor : SelectionColor);
			DrawCircle(transform2, num);
			GL.Color((selectedAxis != RuntimeHandleAxis.Z) ? ZColor : SelectionColor);
			DrawCircle(transform3, num);
			GL.End();
			GL.PopMatrix();
			LinesBillboardMaterial.SetPass(0);
			GL.PushMatrix();
			GL.MultMatrix(m);
			GL.Begin(1);
			GL.Color((selectedAxis != RuntimeHandleAxis.Free) ? AltColor : SelectionColor);
			DrawCircle(Matrix4x4.identity, num);
			GL.Color((selectedAxis != RuntimeHandleAxis.Screen) ? AltColor : SelectionColor);
			DrawCircle(Matrix4x4.identity, num * 1.1f);
			GL.End();
			GL.PopMatrix();
		}

		private static void DrawCircle(Matrix4x4 transform, float radius)
		{
			float num = 0f;
			float z = 0f;
			Vector3 v = transform.MultiplyPoint(new Vector3(radius, 0f, z));
			for (int i = 0; i < 32; i++)
			{
				GL.Vertex(v);
				num += (float)Math.PI / 16f;
				float x = radius * Mathf.Cos(num);
				float y = radius * Mathf.Sin(num);
				Vector3 vector = transform.MultiplyPoint(new Vector3(x, y, z));
				GL.Vertex(vector);
				v = vector;
			}
		}

		public static void DoScaleHandle(Vector3 scale, Vector3 position, Quaternion rotation, RuntimeHandleAxis selectedAxis = RuntimeHandleAxis.None)
		{
			float screenScale = GetScreenScale(position, Camera.current);
			Matrix4x4 transform = Matrix4x4.TRS(position, rotation, scale * screenScale);
			LinesMaterial.SetPass(0);
			GL.Begin(1);
			DoAxes(position, transform, selectedAxis);
			GL.End();
			Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.zero, rotation, scale);
			ShapesMaterial.SetPass(0);
			Vector3 vector = new Vector3(screenScale, screenScale, screenScale);
			Vector3 vector2 = matrix4x.MultiplyVector(Vector3.right) * screenScale;
			Vector3 vector3 = matrix4x.MultiplyVector(Vector3.up) * screenScale;
			Vector3 vector4 = matrix4x.MultiplyVector(Vector3.forward) * screenScale;
			switch (selectedAxis)
			{
			case RuntimeHandleAxis.X:
				Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position + vector2, rotation, vector));
				Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
				Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
				Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
				break;
			case RuntimeHandleAxis.Y:
				Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
				Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position + vector3, rotation, vector));
				Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
				Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
				break;
			case RuntimeHandleAxis.Z:
				Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
				Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
				Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position + vector4, rotation, vector));
				Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
				break;
			case RuntimeHandleAxis.Free:
				Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
				Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
				Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
				Graphics.DrawMeshNow(SelectionCube, Matrix4x4.TRS(position, rotation, vector * 1.35f));
				break;
			default:
				Graphics.DrawMeshNow(CubeX, Matrix4x4.TRS(position + vector2, rotation, vector));
				Graphics.DrawMeshNow(CubeY, Matrix4x4.TRS(position + vector3, rotation, vector));
				Graphics.DrawMeshNow(CubeZ, Matrix4x4.TRS(position + vector4, rotation, vector));
				Graphics.DrawMeshNow(CubeUniform, Matrix4x4.TRS(position, rotation, vector * 1.35f));
				break;
			}
		}

		public static void DoSceneGizmo(Vector3 position, Quaternion rotation, Vector3 selection, float gizmoScale, float xAlpha = 1f, float yAlpha = 1f, float zAlpha = 1f)
		{
			float num = GetScreenScale(position, Camera.current) * gizmoScale;
			Vector3 vector = new Vector3(num, num, num);
			float billboardOffset = 0.4f;
			if (Camera.current.orthographic)
			{
				billboardOffset = 0.42f;
			}
			if (selection != Vector3.zero)
			{
				if (selection == Vector3.one)
				{
					ShapesMaterialZTestOffset.SetPass(0);
					Graphics.DrawMeshNow(SceneGizmoSelectedCube, Matrix4x4.TRS(position, rotation, vector * 0.15f));
				}
				else if ((xAlpha == 1f || xAlpha == 0f) && (yAlpha == 1f || yAlpha == 0f) && (zAlpha == 1f || zAlpha == 0f))
				{
					ShapesMaterialZTestOffset.SetPass(0);
					Graphics.DrawMeshNow(SceneGizmoSelectedAxis, Matrix4x4.TRS(position, rotation * Quaternion.LookRotation(selection, Vector3.up), vector));
				}
			}
			ShapesMaterialZTest.SetPass(0);
			ShapesMaterialZTest.color = Color.white;
			Graphics.DrawMeshNow(SceneGizmoCube, Matrix4x4.TRS(position, rotation, vector * 0.15f));
			if (xAlpha == 1f && yAlpha == 1f && zAlpha == 1f)
			{
				Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
				Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
				Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
			}
			else if (xAlpha < 1f)
			{
				ShapesMaterialZTest3.SetPass(0);
				ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, yAlpha);
				Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
				ShapesMaterialZTest4.SetPass(0);
				ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, zAlpha);
				Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
				ShapesMaterialZTest2.SetPass(0);
				ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, xAlpha);
				Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
				XMaterial.SetPass(0);
			}
			else if (yAlpha < 1f)
			{
				ShapesMaterialZTest4.SetPass(0);
				ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, zAlpha);
				Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
				ShapesMaterialZTest2.SetPass(0);
				ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, xAlpha);
				Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
				ShapesMaterialZTest3.SetPass(0);
				ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, yAlpha);
				Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
			}
			else
			{
				ShapesMaterialZTest2.SetPass(0);
				ShapesMaterialZTest2.color = new Color(1f, 1f, 1f, xAlpha);
				Graphics.DrawMeshNow(SceneGizmoXAxis, Matrix4x4.TRS(position, rotation, vector));
				ShapesMaterialZTest3.SetPass(0);
				ShapesMaterialZTest3.color = new Color(1f, 1f, 1f, yAlpha);
				Graphics.DrawMeshNow(SceneGizmoYAxis, Matrix4x4.TRS(position, rotation, vector));
				ShapesMaterialZTest4.SetPass(0);
				ShapesMaterialZTest4.color = new Color(1f, 1f, 1f, zAlpha);
				Graphics.DrawMeshNow(SceneGizmoZAxis, Matrix4x4.TRS(position, rotation, vector));
			}
			XMaterial.SetPass(0);
			XMaterial.color = new Color(1f, 1f, 1f, xAlpha);
			DragSceneGizmoAxis(position, rotation, Vector3.right, gizmoScale, 0.125f, billboardOffset, num);
			YMaterial.SetPass(0);
			YMaterial.color = new Color(1f, 1f, 1f, yAlpha);
			DragSceneGizmoAxis(position, rotation, Vector3.up, gizmoScale, 0.125f, billboardOffset, num);
			ZMaterial.SetPass(0);
			ZMaterial.color = new Color(1f, 1f, 1f, zAlpha);
			DragSceneGizmoAxis(position, rotation, Vector3.forward, gizmoScale, 0.125f, billboardOffset, num);
		}

		private static void DragSceneGizmoAxis(Vector3 position, Quaternion rotation, Vector3 axis, float gizmoScale, float billboardScale, float billboardOffset, float sScale)
		{
			Vector3 vector = Vector3.Reflect(Camera.current.transform.forward, axis) * 0.1f;
			float num = Vector3.Dot(Camera.current.transform.forward, axis);
			if (num > 0f)
			{
				if (Camera.current.orthographic)
				{
					vector += axis * num * 0.4f;
				}
				else
				{
					vector = axis * num * 0.7f;
				}
			}
			else if (Camera.current.orthographic)
			{
				vector -= axis * num * 0.1f;
			}
			else
			{
				vector = Vector3.zero;
			}
			Vector3 vector2 = position + (axis + vector) * billboardOffset * sScale;
			float num2 = GetScreenScale(vector2, Camera.current) * gizmoScale;
			Graphics.DrawMeshNow(matrix: Matrix4x4.TRS(vector2, rotation, new Vector3(num2, num2, num2) * billboardScale), mesh: SceneGizmoQuad);
		}

		public static float GetGridFarPlane()
		{
			float num = CountOfDigits(Camera.current.transform.position.y);
			return Mathf.Pow(10f, num - 1f) * 150f;
		}

		public static void DrawGrid()
		{
			Vector3 position = Camera.current.transform.position;
			float y = position.y;
			y = Mathf.Abs(y);
			y = Mathf.Max(1f, y);
			float num = CountOfDigits(y);
			float num2 = Mathf.Pow(10f, num - 1f);
			float num3 = Mathf.Pow(10f, num);
			float num4 = Mathf.Pow(10f, num + 1f);
			float alpha = 1f - (y - num2) / (num3 - num2);
			float alpha2 = (y * 10f - num3) / (num4 - num3);
			DrawGrid(position, num2, alpha, y * 20f);
			DrawGrid(position, num3, alpha2, y * 20f);
		}

		private static void DrawGrid(Vector3 cameraPosition, float spacing, float alpha, float fadeDisance)
		{
			cameraPosition.y = 0f;
			GridMaterial.SetFloat("_FadeDistance", fadeDisance);
			GridMaterial.SetPass(0);
			GL.Begin(1);
			GL.Color(new Color(1f, 1f, 1f, 0.1f * alpha));
			cameraPosition.x = Mathf.Floor(cameraPosition.x / spacing) * spacing;
			cameraPosition.z = Mathf.Floor(cameraPosition.z / spacing) * spacing;
			for (int i = -150; i < 150; i++)
			{
				GL.Vertex(cameraPosition + new Vector3((float)i * spacing, 0f, -150f * spacing));
				GL.Vertex(cameraPosition + new Vector3((float)i * spacing, 0f, 150f * spacing));
				GL.Vertex(cameraPosition + new Vector3(-150f * spacing, 0f, (float)i * spacing));
				GL.Vertex(cameraPosition + new Vector3(150f * spacing, 0f, (float)i * spacing));
			}
			GL.End();
		}

		public static float CountOfDigits(float number)
		{
			if (number != 0f)
			{
				return Mathf.Ceil(Mathf.Log10(Mathf.Abs(number) + 0.5f));
			}
			return 1f;
		}
	}
	public class ScaleHandle : BaseHandle
	{
		public float GridSize = 0.1f;

		private Vector3 m_prevPoint;

		private Matrix4x4 m_matrix;

		private Matrix4x4 m_inverse;

		private Vector3 m_roundedScale;

		private Vector3 m_scale;

		private Vector3[] m_refScales;

		private float m_screenScale;

		public static ScaleHandle Current { get; private set; }

		protected override RuntimeTool Tool => RuntimeTool.Scale;

		protected override float CurrentGridSize => GridSize;

		protected override void StartOverride()
		{
			Current = this;
			m_scale = Vector3.one;
			m_roundedScale = m_scale;
		}

		protected override void OnDestroyOverride()
		{
			if (Current == this)
			{
				Current = null;
			}
		}

		protected override bool OnBeginDrag()
		{
			m_screenScale = RuntimeHandles.GetScreenScale(base.transform.position, Camera);
			m_matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, Vector3.one);
			m_inverse = m_matrix.inverse;
			Matrix4x4 matrix = Matrix4x4.TRS(base.transform.position, base.Rotation, new Vector3(m_screenScale, m_screenScale, m_screenScale));
			if (HitCenter())
			{
				base.SelectedAxis = RuntimeHandleAxis.Free;
				base.DragPlane = GetDragPlane();
			}
			else
			{
				if (!(HitAxis(Vector3.up, matrix, out var distanceToAxis) | HitAxis(Vector3.forward, matrix, out var distanceToAxis2) | HitAxis(Vector3.right, matrix, out var distanceToAxis3)))
				{
					base.SelectedAxis = RuntimeHandleAxis.None;
					return false;
				}
				if (distanceToAxis <= distanceToAxis2 && distanceToAxis <= distanceToAxis3)
				{
					base.SelectedAxis = RuntimeHandleAxis.Y;
				}
				else if (distanceToAxis3 <= distanceToAxis && distanceToAxis3 <= distanceToAxis2)
				{
					base.SelectedAxis = RuntimeHandleAxis.X;
				}
				else
				{
					base.SelectedAxis = RuntimeHandleAxis.Z;
				}
			}
			m_refScales = new Vector3[Targets.Length];
			for (int i = 0; i < m_refScales.Length; i++)
			{
				Quaternion quaternion = ((RuntimeTools.PivotRotation == RuntimePivotRotation.Global) ? Targets[i].rotation : Quaternion.identity);
				m_refScales[i] = quaternion * base.Target.localScale;
			}
			base.DragPlane = GetDragPlane();
			return GetPointOnDragPlane(Input.mousePosition, out m_prevPoint);
		}

		protected override void OnDrag()
		{
			if (GetPointOnDragPlane(Input.mousePosition, out var point))
			{
				Vector3 vector = m_inverse.MultiplyVector((point - m_prevPoint) / m_screenScale);
				float magnitude = vector.magnitude;
				if (base.SelectedAxis == RuntimeHandleAxis.X)
				{
					vector.y = (vector.z = 0f);
					m_scale.x += Mathf.Sign(vector.x) * magnitude;
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Y)
				{
					vector.x = (vector.z = 0f);
					m_scale.y += Mathf.Sign(vector.y) * magnitude;
				}
				else if (base.SelectedAxis == RuntimeHandleAxis.Z)
				{
					vector.x = (vector.y = 0f);
					m_scale.z += Mathf.Sign(vector.z) * magnitude;
				}
				if (base.SelectedAxis == RuntimeHandleAxis.Free)
				{
					float num = Mathf.Sign(vector.x + vector.y);
					m_scale.x += num * magnitude;
					m_scale.y += num * magnitude;
					m_scale.z += num * magnitude;
				}
				m_roundedScale = m_scale;
				if ((double)base.EffectiveGridSize > 0.01)
				{
					m_roundedScale.x = (float)Mathf.RoundToInt(m_roundedScale.x / base.EffectiveGridSize) * base.EffectiveGridSize;
					m_roundedScale.y = (float)Mathf.RoundToInt(m_roundedScale.y / base.EffectiveGridSize) * base.EffectiveGridSize;
					m_roundedScale.z = (float)Mathf.RoundToInt(m_roundedScale.z / base.EffectiveGridSize) * base.EffectiveGridSize;
				}
				for (int i = 0; i < m_refScales.Length; i++)
				{
					Quaternion rotation = ((RuntimeTools.PivotRotation == RuntimePivotRotation.Global) ? Targets[i].rotation : Quaternion.identity);
					Targets[i].localScale = Quaternion.Inverse(rotation) * Vector3.Scale(m_refScales[i], m_roundedScale);
				}
				m_prevPoint = point;
			}
		}

		protected override void OnDrop()
		{
			m_scale = Vector3.one;
			m_roundedScale = m_scale;
		}

		protected override void DrawOverride()
		{
			RuntimeHandles.DoScaleHandle(m_roundedScale, base.transform.position, base.Rotation, base.SelectedAxis);
		}
	}
	[RequireComponent(typeof(Camera))]
	public class SceneGizmo : MonoBehaviour
	{
		public Camera SceneCamera;

		public Transform Pivot;

		public Vector2 Size = new Vector2(96f, 96f);

		public UnityEvent OrientationChanging;

		public UnityEvent OrientationChanged;

		public UnityEvent ProjectionChanged;

		private float m_aspect;

		private Camera m_camera;

		private float m_xAlpha = 1f;

		private float m_yAlpha = 1f;

		private float m_zAlpha = 1f;

		private float m_animationDuration = 0.2f;

		private GUIStyle m_buttonStyle;

		private GUIStyle m_oldButtonStyle;

		private Rect m_buttonRect;

		private bool m_mouseOver;

		private Vector3 m_selectedAxis;

		private GameObject m_collidersGO;

		private BoxCollider m_colliderProj;

		private BoxCollider m_colliderUp;

		private BoxCollider m_colliderDown;

		private BoxCollider m_colliderForward;

		private BoxCollider m_colliderBackward;

		private BoxCollider m_colliderLeft;

		private BoxCollider m_colliderRight;

		private Collider[] m_colliders;

		private Vector3 m_position;

		private Quaternion m_rotation;

		private Vector3 m_gizmoPosition;

		private IAnimationInfo m_rotateAnimation;

		private IAnimationInfo m_positionAnimation;

		private float m_screenHeight;

		private float m_screenWidth;

		private bool IsOrthographic
		{
			get
			{
				return m_camera.orthographic;
			}
			set
			{
				m_camera.orthographic = value;
				SceneCamera.orthographic = value;
				if (ProjectionChanged != null)
				{
					ProjectionChanged.Invoke();
					InitColliders();
				}
			}
		}

		private void Awake()
		{
			if (SceneCamera == null)
			{
				SceneCamera = Camera.main;
			}
			if (Pivot == null)
			{
				Pivot = base.transform;
			}
			m_collidersGO = new GameObject();
			m_collidersGO.transform.SetParent(base.transform, worldPositionStays: false);
			m_collidersGO.transform.position = GetGizmoPosition();
			m_collidersGO.transform.rotation = Quaternion.identity;
			m_collidersGO.name = "Colliders";
			m_colliderProj = m_collidersGO.AddComponent<BoxCollider>();
			m_colliderUp = m_collidersGO.AddComponent<BoxCollider>();
			m_colliderDown = m_collidersGO.AddComponent<BoxCollider>();
			m_colliderLeft = m_collidersGO.AddComponent<BoxCollider>();
			m_colliderRight = m_collidersGO.AddComponent<BoxCollider>();
			m_colliderForward = m_collidersGO.AddComponent<BoxCollider>();
			m_colliderBackward = m_collidersGO.AddComponent<BoxCollider>();
			Collider[] colliders = new BoxCollider[7] { m_colliderProj, m_colliderUp, m_colliderDown, m_colliderRight, m_colliderLeft, m_colliderForward, m_colliderBackward };
			m_colliders = colliders;
			DisableColliders();
			m_camera = GetComponent<Camera>();
			m_camera.clearFlags = CameraClearFlags.Depth;
			m_camera.renderingPath = RenderingPath.Forward;
			m_camera.cullingMask = 0;
			SceneCamera.orthographic = m_camera.orthographic;
			m_screenHeight = Screen.height;
			m_screenWidth = Screen.width;
			UpdateLayout();
			InitColliders();
			UpdateAlpha(ref m_xAlpha, Vector3.right, 1f);
			UpdateAlpha(ref m_yAlpha, Vector3.up, 1f);
			UpdateAlpha(ref m_zAlpha, Vector3.forward, 1f);
		}

		private void Start()
		{
			if (Run.Instance == null)
			{
				GameObject obj = new GameObject();
				obj.name = "Run";
				obj.AddComponent<Run>();
			}
		}

		public void UpdateLayout()
		{
			if (!(m_camera == null))
			{
				m_aspect = m_camera.aspect;
				m_camera.pixelRect = new Rect(SceneCamera.pixelRect.min.x + (float)SceneCamera.pixelWidth - Size.x, SceneCamera.pixelRect.min.y + (float)SceneCamera.pixelHeight - Size.y, Size.x, Size.y);
				m_camera.depth = SceneCamera.depth + 1f;
				m_aspect = m_camera.aspect;
				m_buttonRect = new Rect(SceneCamera.pixelRect.min.x + (float)SceneCamera.pixelWidth - Size.x / 2f - 20f, (float)Screen.height - SceneCamera.pixelRect.yMax + Size.y - 5f, 40f, 30f);
				m_buttonStyle = new GUIStyle();
				m_buttonStyle.alignment = TextAnchor.MiddleCenter;
				m_buttonStyle.normal.textColor = new Color(0.8f, 0.8f, 0.8f, 0.8f);
				m_buttonStyle.fontSize = 12;
			}
		}

		private Vector3 GetGizmoPosition()
		{
			return base.transform.TransformPoint(Vector3.forward * 5f);
		}

		private void OnPostRender()
		{
			RuntimeHandles.DoSceneGizmo(GetGizmoPosition(), Quaternion.identity, m_selectedAxis, Size.y / 96f, m_xAlpha, m_yAlpha, m_zAlpha);
		}

		private void OnGUI()
		{
			if (SceneCamera.orthographic)
			{
				if (GUI.Button(m_buttonRect, "Iso", m_buttonStyle))
				{
					IsOrthographic = false;
				}
			}
			else if (GUI.Button(m_buttonRect, "Persp", m_buttonStyle))
			{
				IsOrthographic = true;
			}
		}

		private void Update()
		{
			if (m_position != base.transform.position || m_rotation != base.transform.rotation)
			{
				InitColliders();
				m_position = base.transform.position;
				m_rotation = base.transform.rotation;
			}
			if (m_screenHeight != (float)Screen.height || m_screenWidth != (float)Screen.width)
			{
				m_screenHeight = Screen.height;
				m_screenWidth = Screen.width;
				UpdateLayout();
			}
			if (m_aspect != m_camera.aspect)
			{
				m_camera.pixelRect = new Rect((float)SceneCamera.pixelWidth - Size.x, (float)SceneCamera.pixelHeight - Size.y, Size.x, Size.y);
				m_aspect = m_camera.aspect;
			}
			float delta = Time.deltaTime / m_animationDuration;
			bool flag = UpdateAlpha(ref m_xAlpha, Vector3.right, delta);
			flag |= UpdateAlpha(ref m_yAlpha, Vector3.up, delta);
			flag |= UpdateAlpha(ref m_zAlpha, Vector3.forward, delta);
			m_camera.transform.rotation = SceneCamera.transform.rotation;
			Vector2 vector = Input.mousePosition;
			vector.y = (float)Screen.height - vector.y;
			bool flag3 = (RuntimeTools.IsSceneGizmoSelected = m_buttonRect.Contains(vector, allowInverse: true));
			if (m_camera.pixelRect.Contains(Input.mousePosition))
			{
				if (!m_mouseOver || flag)
				{
					EnableColliders();
				}
				Collider collider = HitTest();
				if (collider == null || (m_rotateAnimation != null && m_rotateAnimation.InProgress))
				{
					m_selectedAxis = Vector3.zero;
				}
				else if (collider == m_colliderProj)
				{
					m_selectedAxis = Vector3.one;
				}
				else if (collider == m_colliderUp)
				{
					m_selectedAxis = Vector3.up;
				}
				else if (collider == m_colliderDown)
				{
					m_selectedAxis = Vector3.down;
				}
				else if (collider == m_colliderForward)
				{
					m_selectedAxis = Vector3.forward;
				}
				else if (collider == m_colliderBackward)
				{
					m_selectedAxis = Vector3.back;
				}
				else if (collider == m_colliderRight)
				{
					m_selectedAxis = Vector3.right;
				}
				else if (collider == m_colliderLeft)
				{
					m_selectedAxis = Vector3.left;
				}
				if (m_selectedAxis != Vector3.zero || flag3)
				{
					RuntimeTools.IsSceneGizmoSelected = true;
				}
				else
				{
					RuntimeTools.IsSceneGizmoSelected = false;
				}
				if (Input.GetMouseButtonUp(0) && m_selectedAxis != Vector3.zero)
				{
					if (m_selectedAxis == Vector3.one)
					{
						IsOrthographic = !IsOrthographic;
					}
					else
					{
						if ((m_rotateAnimation == null || !m_rotateAnimation.InProgress) && OrientationChanging != null)
						{
							OrientationChanging.Invoke();
						}
						if (m_rotateAnimation != null)
						{
							m_rotateAnimation.Abort();
						}
						Vector3 pivot = Pivot.transform.position;
						Vector3 radiusVector = Vector3.back * (SceneCamera.transform.position - pivot).magnitude;
						Quaternion to = Quaternion.LookRotation(-m_selectedAxis, Vector3.up);
						m_rotateAnimation = new QuaternionAnimationInfo(SceneCamera.transform.rotation, to, 0.4f, AnimationInfo<object, Quaternion>.EaseOutCubic, delegate(object target, Quaternion value, float t, bool completed)
						{
							SceneCamera.transform.position = pivot + value * radiusVector;
							SceneCamera.transform.rotation = value;
							if (completed)
							{
								DisableColliders();
								EnableColliders();
								if (OrientationChanged != null)
								{
									OrientationChanged.Invoke();
								}
							}
						});
						Run.Instance.Animation(m_rotateAnimation);
					}
				}
				m_mouseOver = true;
			}
			else
			{
				if (m_mouseOver)
				{
					DisableColliders();
					RuntimeTools.IsSceneGizmoSelected = false;
				}
				m_mouseOver = false;
			}
		}

		private void EnableColliders()
		{
			m_colliderProj.enabled = true;
			if (m_zAlpha == 1f)
			{
				m_colliderForward.enabled = true;
				m_colliderBackward.enabled = true;
			}
			if (m_yAlpha == 1f)
			{
				m_colliderUp.enabled = true;
				m_colliderDown.enabled = true;
			}
			if (m_xAlpha == 1f)
			{
				m_colliderRight.enabled = true;
				m_colliderLeft.enabled = true;
			}
		}

		private void DisableColliders()
		{
			for (int i = 0; i < m_colliders.Length; i++)
			{
				m_colliders[i].enabled = false;
			}
		}

		private Collider HitTest()
		{
			Ray ray = m_camera.ScreenPointToRay(Input.mousePosition);
			float num = float.MaxValue;
			Collider result = null;
			for (int i = 0; i < m_colliders.Length; i++)
			{
				if (m_colliders[i].Raycast(ray, out var hitInfo, m_gizmoPosition.magnitude * 5f) && hitInfo.distance < num)
				{
					num = hitInfo.distance;
					result = hitInfo.collider;
				}
			}
			return result;
		}

		private void InitColliders()
		{
			m_gizmoPosition = GetGizmoPosition();
			float num = RuntimeHandles.GetScreenScale(m_gizmoPosition, m_camera) * Size.y / 96f;
			m_collidersGO.transform.rotation = Quaternion.identity;
			m_collidersGO.transform.position = GetGizmoPosition();
			m_colliderProj.size = new Vector3(0.15f, 0.15f, 0.15f) * num;
			m_colliderUp.size = new Vector3(0.15f, 0.3f, 0.15f) * num;
			m_colliderUp.center = new Vector3(0f, 0.22500001f, 0f) * num;
			m_colliderDown.size = new Vector3(0.15f, 0.3f, 0.15f) * num;
			m_colliderDown.center = new Vector3(0f, -0.22500001f, 0f) * num;
			m_colliderForward.size = new Vector3(0.15f, 0.15f, 0.3f) * num;
			m_colliderForward.center = new Vector3(0f, 0f, 0.22500001f) * num;
			m_colliderBackward.size = new Vector3(0.15f, 0.15f, 0.3f) * num;
			m_colliderBackward.center = new Vector3(0f, 0f, -0.22500001f) * num;
			m_colliderRight.size = new Vector3(0.3f, 0.15f, 0.15f) * num;
			m_colliderRight.center = new Vector3(0.22500001f, 0f, 0f) * num;
			m_colliderLeft.size = new Vector3(0.3f, 0.15f, 0.15f) * num;
			m_colliderLeft.center = new Vector3(-0.22500001f, 0f, 0f) * num;
		}

		private bool UpdateAlpha(ref float alpha, Vector3 axis, float delta)
		{
			if ((double)Math.Abs(Vector3.Dot(SceneCamera.transform.forward, axis)) > 0.9)
			{
				if (alpha > 0f)
				{
					alpha -= delta;
					if (alpha < 0f)
					{
						alpha = 0f;
					}
					return true;
				}
			}
			else if (alpha < 1f)
			{
				alpha += delta;
				if (alpha > 1f)
				{
					alpha = 1f;
				}
				return true;
			}
			return false;
		}
	}
}
namespace Battlehub.RTEditor
{
	public class DragField : MonoBehaviour, IDragHandler, IEventSystemHandler, IBeginDragHandler, IDropHandler, IEndDragHandler, IPointerEnterHandler, IPointerExitHandler
	{
		public InputField Field;

		public float IncrementFactor = 0.1f;

		public Texture2D DragCursor;

		private void Start()
		{
			if (Field == null)
			{
				UnityEngine.Debug.LogWarning("Set Field");
			}
		}

		void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
		{
		}

		void IDropHandler.OnDrop(PointerEventData eventData)
		{
		}

		void IEndDragHandler.OnEndDrag(PointerEventData eventData)
		{
		}

		void IDragHandler.OnDrag(PointerEventData eventData)
		{
			if (!(Field == null) && Field.contentType == InputField.ContentType.DecimalNumber && float.TryParse(Field.text, out var result))
			{
				result += IncrementFactor * eventData.delta.x;
				Field.text = result.ToString();
			}
		}

		void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
		{
			Cursor.SetCursor(DragCursor, new Vector2(24f, 24f), CursorMode.Auto);
		}

		void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
		{
			Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
		}
	}
	public delegate void ExposeToEditorChangeEvent<T>(ExposeToEditor obj, T oldValue, T newValue);
	public delegate void ExposeToEditorEvent(ExposeToEditor obj);
	[DisallowMultipleComponent]
	public class ExposeToEditor : MonoBehaviour
	{
		public bool AddColliders;

		public bool DisableOnAwake;

		private bool m_applicationQuit;

		private Collider[] m_colliders;

		private HierarchyItem m_hierarchyItem;

		private List<ExposeToEditor> m_children = new List<ExposeToEditor>();

		private ExposeToEditor m_parent;

		public int ChildCount => m_children.Count;

		public ExposeToEditor Parent
		{
			get
			{
				return m_parent;
			}
			set
			{
				if (m_parent != value)
				{
					ExposeToEditor parent = m_parent;
					m_parent = value;
					if (parent != null)
					{
						parent.m_children.Remove(this);
					}
					if (m_parent != null)
					{
						m_parent.m_children.Add(this);
					}
					if (ExposeToEditor.ParentChanged != null)
					{
						ExposeToEditor.ParentChanged(this, parent, m_parent);
					}
				}
			}
		}

		public static event ExposeToEditorEvent NameChanged;

		public static event ExposeToEditorEvent TransformChanged;

		public static event ExposeToEditorEvent Awaked;

		public static event ExposeToEditorEvent Started;

		public static event ExposeToEditorEvent Enabled;

		public static event ExposeToEditorEvent Disabled;

		public static event ExposeToEditorEvent Destroyed;

		public static event ExposeToEditorChangeEvent<ExposeToEditor> ParentChanged;

		public ExposeToEditor GetChild(int index)
		{
			return m_children[index];
		}

		public ExposeToEditor[] GetChildren()
		{
			return m_children.OrderBy((ExposeToEditor c) => c.transform.GetSiblingIndex()).ToArray();
		}

		private void Awake()
		{
			if (DisableOnAwake)
			{
				base.gameObject.SetActive(value: false);
			}
			List<Collider> list = new List<Collider>();
			MeshFilter component = GetComponent<MeshFilter>();
			bool flag = GetComponent<Rigidbody>() != null;
			if (component != null && !flag && AddColliders)
			{
				MeshCollider meshCollider = base.gameObject.AddComponent<MeshCollider>();
				meshCollider.convex = flag;
				meshCollider.sharedMesh = component.mesh;
				list.Add(meshCollider);
			}
			SkinnedMeshRenderer component2 = GetComponent<SkinnedMeshRenderer>();
			if (component2 != null && !flag && AddColliders)
			{
				MeshCollider meshCollider2 = base.gameObject.AddComponent<MeshCollider>();
				meshCollider2.convex = flag;
				meshCollider2.sharedMesh = component2.sharedMesh;
				list.Add(meshCollider2);
			}
			m_colliders = list.ToArray();
			if (base.transform.parent != null)
			{
				ExposeToEditor componentInParent = base.transform.parent.GetComponentInParent<ExposeToEditor>();
				if (m_parent != componentInParent)
				{
					m_parent = componentInParent;
					if (m_parent != null)
					{
						m_parent.m_children.Add(this);
					}
				}
			}
			m_hierarchyItem = base.gameObject.GetComponent<HierarchyItem>();
			if (m_hierarchyItem == null)
			{
				m_hierarchyItem = base.gameObject.AddComponent<HierarchyItem>();
			}
			if (ExposeToEditor.Awaked != null)
			{
				ExposeToEditor.Awaked(this);
			}
		}

		private void Start()
		{
			if (ExposeToEditor.Started != null)
			{
				ExposeToEditor.Started(this);
			}
		}

		private void OnEnable()
		{
			if (ExposeToEditor.Enabled != null)
			{
				ExposeToEditor.Enabled(this);
			}
		}

		private void OnDisable()
		{
			if (ExposeToEditor.Disabled != null)
			{
				ExposeToEditor.Disabled(this);
			}
		}

		private void OnApplicationQuit()
		{
			m_applicationQuit = true;
		}

		private void OnDestroy()
		{
			if (m_applicationQuit)
			{
				return;
			}
			Parent = null;
			for (int i = 0; i < m_colliders.Length; i++)
			{
				Collider collider = m_colliders[i];
				if (collider != null)
				{
					UnityEngine.Object.Destroy(collider);
				}
			}
			if (m_hierarchyItem != null)
			{
				UnityEngine.Object.Destroy(m_hierarchyItem);
			}
			if (ExposeToEditor.Destroyed != null)
			{
				ExposeToEditor.Destroyed(this);
			}
		}

		private void Update()
		{
			if (ExposeToEditor.TransformChanged != null && base.transform.hasChanged)
			{
				base.transform.hasChanged = false;
				if (ExposeToEditor.TransformChanged != null)
				{
					ExposeToEditor.TransformChanged(this);
				}
			}
		}

		public void SetName(string name)
		{
			base.gameObject.name = name;
			if (ExposeToEditor.NameChanged != null)
			{
				ExposeToEditor.NameChanged(this);
			}
		}
	}
	public class HierarchyItem : MonoBehaviour
	{
		private ExposeToEditor m_parentExp;

		private ExposeToEditor m_exposeToEditor;

		private Transform m_parentTransform;

		private bool m_isAwaked;

		private void Awake()
		{
			m_exposeToEditor = GetComponent<ExposeToEditor>();
			if (base.transform.parent != null)
			{
				m_parentExp = CreateChainToParent(base.transform.parent);
				m_parentTransform = base.transform.parent;
			}
			m_isAwaked = true;
		}

		private ExposeToEditor CreateChainToParent(Transform parent)
		{
			ExposeToEditor exposeToEditor = null;
			if (parent != null)
			{
				exposeToEditor = parent.GetComponentInParent<ExposeToEditor>();
			}
			if (exposeToEditor == null)
			{
				return null;
			}
			while (parent != null && parent.gameObject != exposeToEditor.gameObject)
			{
				if (!parent.GetComponent<ExposeToEditor>() && !parent.GetComponent<HierarchyItem>())
				{
					parent.gameObject.AddComponent<HierarchyItem>();
				}
				parent = parent.parent;
			}
			return exposeToEditor;
		}

		private void TryDestroyChainToParent(Transform parent, ExposeToEditor parentExp)
		{
			if (parentExp == null)
			{
				return;
			}
			while (parent != null && parent.gameObject != parentExp.gameObject)
			{
				if (!parent.GetComponent<ExposeToEditor>())
				{
					HierarchyItem component = parent.GetComponent<HierarchyItem>();
					if ((bool)component && !HasExposeToEditorChildren(parent))
					{
						UnityEngine.Object.Destroy(component);
					}
				}
				parent = parent.parent;
			}
		}

		private bool HasExposeToEditorChildren(Transform parentTransform)
		{
			int childCount = parentTransform.childCount;
			if (childCount == 0)
			{
				return false;
			}
			for (int i = 0; i < childCount; i++)
			{
				Transform child = parentTransform.GetChild(i);
				if (child.GetComponent<ExposeToEditor>() != null)
				{
					return true;
				}
				if (child.GetComponent<HierarchyItem>() != null && HasExposeToEditorChildren(child))
				{
					return true;
				}
			}
			return false;
		}

		private void UpdateChildren(Transform parentTransform, ExposeToEditor parentExp)
		{
			int childCount = parentTransform.childCount;
			if (childCount == 0)
			{
				return;
			}
			for (int i = 0; i < childCount; i++)
			{
				Transform child = parentTransform.GetChild(i);
				ExposeToEditor component = child.GetComponent<ExposeToEditor>();
				HierarchyItem component2 = child.GetComponent<HierarchyItem>();
				if (component != null)
				{
					component.Parent = parentExp;
					component2.m_parentExp = parentExp;
				}
				else if (component2 != null)
				{
					UpdateChildren(child, parentExp);
				}
			}
		}

		private void OnTransformParentChanged()
		{
			if (!m_isAwaked || !(base.transform.parent != m_parentTransform))
			{
				return;
			}
			if (m_parentTransform != null && m_parentExp != null)
			{
				TryDestroyChainToParent(m_parentTransform, m_parentExp);
			}
			ExposeToEditor exposeToEditor = CreateChainToParent(base.transform.parent);
			if (exposeToEditor != m_parentExp)
			{
				if (m_exposeToEditor == null)
				{
					UpdateChildren(base.transform, exposeToEditor);
				}
				else
				{
					m_exposeToEditor.Parent = exposeToEditor;
				}
				m_parentExp = exposeToEditor;
			}
			m_parentTransform = base.transform.parent;
		}
	}
	[AddComponentMenu("Camera-Control/Mouse Orbit with zoom")]
	public class MouseOrbit : MonoBehaviour
	{
		private Camera m_camera;

		public Transform Target;

		public float Distance = 5f;

		public float XSpeed = 5f;

		public float YSpeed = 5f;

		public float YMinLimit = -360f;

		public float YMaxLimit = 360f;

		public float DistanceMin = 0.5f;

		public float DistanceMax = 5000f;

		private float m_x;

		private float m_y;

		private void Awake()
		{
			m_camera = GetComponent<Camera>();
		}

		private void Start()
		{
			SyncAngles();
		}

		public void SyncAngles()
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			m_x = eulerAngles.y;
			m_y = eulerAngles.x;
		}

		private void LateUpdate()
		{
			float axis = Input.GetAxis("Mouse X");
			float axis2 = Input.GetAxis("Mouse Y");
			axis *= XSpeed;
			axis2 *= YSpeed;
			m_x += axis;
			m_y -= axis2;
			m_y = ClampAngle(m_y, YMinLimit, YMaxLimit);
			Zoom();
		}

		public void Zoom()
		{
			Quaternion quaternion = Quaternion.Euler(m_y, m_x, 0f);
			base.transform.rotation = quaternion;
			float axis = Input.GetAxis("Mouse ScrollWheel");
			if (m_camera.orthographic)
			{
				m_camera.orthographicSize -= axis * m_camera.orthographicSize;
				if (m_camera.orthographicSize < 0.01f)
				{
					m_camera.orthographicSize = 0.01f;
				}
			}
			Distance = Mathf.Clamp(Distance - axis * Distance, DistanceMin, DistanceMax);
			Vector3 vector = new Vector3(0f, 0f, 0f - Distance);
			Vector3 position = quaternion * vector + Target.position;
			base.transform.position = position;
		}

		public static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class Placeholder : MonoBehaviour
	{
		public static string CommandsPlaceholder = "Commands";

		public string Id;
	}
	public class RuntimeEditor : MonoBehaviour
	{
		public UnityEvent Opened;

		public UnityEvent Closed;

		public GameObject[] Prefabs;

		public GameObject Grid;

		public GameObject SceneGizmo;

		public GameObject EditButton;

		public GameObject CloseButton;

		public GameObject EditorRoot;

		public Camera SceneCamera;

		public RuntimeSceneView SceneView;

		public KeyCode MultiselectKey = KeyCode.LeftControl;

		public KeyCode RangeSelectKey = KeyCode.LeftShift;

		public KeyCode DuplicateKey = KeyCode.D;

		public KeyCode DuplicateKey2 = KeyCode.LeftShift;

		private LayerMask m_raycastLayerMask = int.MinValue;

		private int m_raycastLayer = 31;

		private bool m_isOn;

		private static RuntimeEditor m_instance;

		public int RaycastLayer
		{
			get
			{
				return m_raycastLayer;
			}
			set
			{
				m_raycastLayer = value;
				m_raycastLayerMask = 1 << value;
			}
		}

		public bool IsOn
		{
			get
			{
				return m_isOn;
			}
			set
			{
				if (m_isOn != value)
				{
					m_isOn = value;
					if (m_isOn)
					{
						ShowEditor();
					}
					else
					{
						CloseEditor();
					}
				}
			}
		}

		public static RuntimeEditor Instance => m_instance;

		private void Awake()
		{
			ExposeToEditor.Started += OnObjectStarted;
			if (m_instance != null)
			{
				UnityEngine.Debug.LogWarning("Another instance of RuntimeEditor exists");
			}
			m_instance = this;
			if (SceneCamera == null)
			{
				SceneCamera = Camera.main;
			}
			SceneView.Camera = SceneCamera;
		}

		private void Start()
		{
			ShowEditor();
			CloseEditor();
			ExposeToEditor.Awaked += OnObjectAwaked;
			ExposeToEditor.Enabled += OnObjectEnabled;
			ExposeToEditor.Disabled += OnObjectDisabled;
			ExposeToEditor.Destroyed += OnObjectDestroyed;
			if (m_isOn)
			{
				ShowEditor();
			}
			else
			{
				CloseEditor();
			}
		}

		private void LateUpdate()
		{
			if (Input.GetKeyDown(DuplicateKey) && Input.GetKey(DuplicateKey2))
			{
				UnityEngine.Object[] objects = RuntimeSelection.objects;
				if (objects != null && objects.Length != 0)
				{
					UnityEngine.Object[] array = new UnityEngine.Object[objects.Length];
					for (int i = 0; i < array.Length; i++)
					{
						GameObject gameObject = objects[i] as GameObject;
						UnityEngine.Object @object = UnityEngine.Object.Instantiate(objects[i]);
						GameObject gameObject2 = @object as GameObject;
						if (gameObject != null && gameObject2 != null && gameObject.transform.parent != null)
						{
							gameObject2.transform.SetParent(gameObject.transform.parent, worldPositionStays: true);
						}
						array[i] = @object;
					}
					RuntimeSelection.objects = array;
				}
			}
			if (!Input.GetMouseButtonDown(0) || (PositionHandle.Current != null && PositionHandle.Current.IsDragging) || (ScaleHandle.Current != null && ScaleHandle.Current.IsDragging) || (RotationHandle.Current != null && RotationHandle.Current.IsDragging) || (!SceneView.IsPointerOver && EventSystem.current != null && EventSystem.current.IsPointerOverGameObject()) || RuntimeTools.IsLocked || RuntimeTools.IsSceneGizmoSelected)
			{
				return;
			}
			bool key = Input.GetKey(RangeSelectKey);
			bool flag = Input.GetKey(MultiselectKey) || key;
			if (Physics.Raycast(SceneCamera.ScreenPointToRay(Input.mousePosition), out var hitInfo, float.MaxValue, m_raycastLayerMask.value))
			{
				ExposeToEditor component = hitInfo.collider.gameObject.GetComponent<ExposeToEditor>();
				if (component != null)
				{
					if (flag)
					{
						List<UnityEngine.Object> list = ((RuntimeSelection.objects == null) ? new List<UnityEngine.Object>() : RuntimeSelection.objects.ToList());
						if (list.Contains(component.gameObject))
						{
							list.Remove(component.gameObject);
							if (key)
							{
								list.Insert(0, component.gameObject);
							}
						}
						else
						{
							list.Insert(0, component.gameObject);
						}
						RuntimeSelection.Select(component.gameObject, list.ToArray());
					}
					else
					{
						RuntimeSelection.activeObject = component.gameObject;
					}
				}
				else if (!flag)
				{
					RuntimeSelection.activeObject = null;
				}
			}
			else if (!flag)
			{
				RuntimeSelection.activeObject = null;
			}
		}

		private void Destroy()
		{
			ExposeToEditor.Awaked -= OnObjectAwaked;
			ExposeToEditor.Started -= OnObjectStarted;
			ExposeToEditor.Enabled -= OnObjectEnabled;
			ExposeToEditor.Disabled -= OnObjectDisabled;
			ExposeToEditor.Destroyed -= OnObjectDestroyed;
		}

		private void OnApplicationQuit()
		{
			ExposeToEditor.Awaked -= OnObjectAwaked;
			ExposeToEditor.Started -= OnObjectStarted;
			ExposeToEditor.Enabled -= OnObjectEnabled;
			ExposeToEditor.Disabled -= OnObjectDisabled;
			ExposeToEditor.Destroyed -= OnObjectDestroyed;
		}

		private void OnObjectAwaked(ExposeToEditor obj)
		{
		}

		private void OnObjectStarted(ExposeToEditor obj)
		{
			obj.gameObject.layer = m_raycastLayer;
		}

		private void OnObjectEnabled(ExposeToEditor obj)
		{
			obj.gameObject.layer = m_raycastLayer;
		}

		private void OnObjectDisabled(ExposeToEditor obj)
		{
		}

		private void OnObjectDestroyed(ExposeToEditor obj)
		{
		}

		private void ShowEditor()
		{
			if (SceneGizmo != null)
			{
				SceneGizmo.SetActive(value: true);
			}
			if (Grid != null)
			{
				Grid.SetActive(value: true);
			}
			EditButton.SetActive(value: false);
			EditorRoot.SetActive(value: true);
			Opened.Invoke();
		}

		private void CloseEditor()
		{
			if (SceneGizmo != null)
			{
				SceneGizmo.SetActive(value: false);
			}
			if (Grid != null)
			{
				Grid.SetActive(value: false);
			}
			EditButton.SetActive(value: true);
			EditorRoot.SetActive(value: false);
			Closed.Invoke();
		}
	}
	public class RuntimeHierarchy : MonoBehaviour
	{
		public GameObject TreeViewPrefab;

		private TreeView m_treeView;

		public Type TypeCriteria = typeof(GameObject);

		public Color DisabledItemColor = new Color(0.5f, 0.5f, 0.5f);

		public Color EnabledItemColor = new Color(0.2f, 0.2f, 0.2f);

		private bool m_lockSelection;

		private void Start()
		{
			if (!TreeViewPrefab)
			{
				UnityEngine.Debug.LogError("Set TreeViewPrefab field");
				return;
			}
			m_treeView = UnityEngine.Object.Instantiate(TreeViewPrefab).GetComponent<TreeView>();
			m_treeView.transform.SetParent(base.transform, worldPositionStays: false);
			m_treeView.ItemDataBinding += OnItemDataBinding;
			m_treeView.SelectionChanged += OnSelectionChanged;
			m_treeView.ItemsRemoved += OnItemsRemoved;
			m_treeView.ItemExpanding += OnItemExpanding;
			m_treeView.ItemBeginDrag += OnItemBeginDrag;
			m_treeView.ItemDrop += OnItemDrop;
			m_treeView.ItemEndDrag += OnItemEndDrag;
			RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
			HashSet<GameObject> hashSet = new HashSet<GameObject>();
			GameObject[] array = Resources.FindObjectsOfTypeAll<GameObject>();
			foreach (GameObject gameObject in array)
			{
				if (gameObject == null || RuntimePrefabs.IsPrefab(gameObject.transform))
				{
					continue;
				}
				if (TypeCriteria == typeof(GameObject))
				{
					hashSet.Add(gameObject);
					continue;
				}
				UnityEngine.Component component = gameObject.GetComponent(TypeCriteria);
				if ((bool)component && !hashSet.Contains(component.gameObject))
				{
					hashSet.Add(component.gameObject);
				}
			}
			m_treeView.Items = from f in hashSet
				where f.transform.parent == null && CanExposeToEditor(f)
				select f into t
				orderby t.transform.GetSiblingIndex()
				select t;
			ExposeToEditor.Awaked += OnObjectAwaked;
			ExposeToEditor.Started += OnObjectStarted;
			ExposeToEditor.Enabled += OnObjectEnabled;
			ExposeToEditor.Disabled += OnObjectDisabled;
			ExposeToEditor.Destroyed += OnObjectDestroyed;
			ExposeToEditor.ParentChanged += OnParentChanged;
			ExposeToEditor.NameChanged += OnNameChanged;
		}

		private bool CanExposeToEditor(GameObject go)
		{
			return go.GetComponent<ExposeToEditor>() != null;
		}

		private void OnDestroy()
		{
			if ((bool)m_treeView)
			{
				m_treeView.ItemDataBinding -= OnItemDataBinding;
				m_treeView.SelectionChanged -= OnSelectionChanged;
				m_treeView.ItemsRemoved -= OnItemsRemoved;
				m_treeView.ItemExpanding -= OnItemExpanding;
				m_treeView.ItemBeginDrag -= OnItemBeginDrag;
				m_treeView.ItemDrop -= OnItemDrop;
				m_treeView.ItemEndDrag -= OnItemEndDrag;
				RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
				ExposeToEditor.Awaked -= OnObjectAwaked;
				ExposeToEditor.Started -= OnObjectStarted;
				ExposeToEditor.Enabled -= OnObjectEnabled;
				ExposeToEditor.Disabled -= OnObjectDisabled;
				ExposeToEditor.Destroyed -= OnObjectDestroyed;
				ExposeToEditor.ParentChanged -= OnParentChanged;
				ExposeToEditor.NameChanged -= OnNameChanged;
			}
		}

		private void OnApplicationQuit()
		{
			ExposeToEditor.Awaked -= OnObjectAwaked;
			ExposeToEditor.Started -= OnObjectStarted;
			ExposeToEditor.Enabled -= OnObjectEnabled;
			ExposeToEditor.Disabled -= OnObjectDisabled;
			ExposeToEditor.Destroyed -= OnObjectDestroyed;
			ExposeToEditor.ParentChanged -= OnParentChanged;
			ExposeToEditor.NameChanged -= OnNameChanged;
		}

		private void OnItemExpanding(object sender, ItemExpandingArgs e)
		{
			ExposeToEditor component = ((GameObject)e.Item).GetComponent<ExposeToEditor>();
			if (component.ChildCount > 0)
			{
				e.Children = from obj in component.GetChildren()
					select obj.gameObject;
				OnTreeViewSelectionChanged(m_treeView.SelectedItems, m_treeView.SelectedItems);
			}
		}

		private void OnEditorSelectionChanged()
		{
			if (!m_lockSelection)
			{
				m_lockSelection = true;
				m_lockSelection = false;
			}
		}

		private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
		{
			if (!m_lockSelection)
			{
				m_lockSelection = true;
				m_treeView.SelectedItems = RuntimeSelection.gameObjects;
				m_lockSelection = false;
			}
		}

		private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			OnTreeViewSelectionChanged(e.OldItems, e.NewItems);
		}

		private void OnTreeViewSelectionChanged(IEnumerable oldItems, IEnumerable newItems)
		{
			if (!m_lockSelection)
			{
				m_lockSelection = true;
				if (newItems == null)
				{
					newItems = new GameObject[0];
				}
				UnityEngine.Object[] objects = newItems.OfType<GameObject>().ToArray();
				RuntimeSelection.objects = objects;
				m_lockSelection = false;
			}
		}

		private void OnItemsRemoved(object sender, ItemsRemovedArgs e)
		{
			for (int i = 0; i < e.Items.Length; i++)
			{
				GameObject gameObject = (GameObject)e.Items[i];
				if (gameObject != null)
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}
		}

		private void OnItemDataBinding(object sender, TreeViewItemDataBindingArgs e)
		{
			GameObject gameObject = e.Item as GameObject;
			if (gameObject != null)
			{
				Text componentInChildren = e.ItemPresenter.GetComponentInChildren<Text>(includeInactive: true);
				componentInChildren.text = gameObject.name;
				if (gameObject.activeInHierarchy)
				{
					componentInChildren.color = EnabledItemColor;
				}
				else
				{
					componentInChildren.color = DisabledItemColor;
				}
				e.HasChildren = gameObject.GetComponent<ExposeToEditor>().ChildCount > 0;
			}
		}

		private void OnItemBeginDrag(object sender, ItemDragArgs e)
		{
		}

		private void OnItemDrop(object sender, ItemDropArgs e)
		{
			if (e.IsExternal)
			{
				if (e.DragItems == null)
				{
					return;
				}
				for (int i = 0; i < e.DragItems.Length; i++)
				{
					GameObject gameObject = e.DragItems[i] as GameObject;
					if (gameObject != null && RuntimePrefabs.IsPrefab(gameObject.transform))
					{
						GameObject obj = UnityEngine.Object.Instantiate(gameObject);
						ExposeToEditor component = obj.GetComponent<ExposeToEditor>();
						if (component != null)
						{
							component.SetName(gameObject.name);
						}
						obj.transform.position = gameObject.transform.position;
						obj.transform.rotation = gameObject.transform.rotation;
						obj.transform.localScale = gameObject.transform.localScale;
						RuntimeSelection.activeGameObject = obj;
					}
				}
				return;
			}
			Transform transform = ((GameObject)e.DropTarget).transform;
			if (e.Action == ItemDropAction.SetLastChild)
			{
				for (int j = 0; j < e.DragItems.Length; j++)
				{
					Transform obj2 = ((GameObject)e.DragItems[j]).transform;
					obj2.SetParent(transform, worldPositionStays: true);
					obj2.SetAsLastSibling();
				}
			}
			else if (e.Action == ItemDropAction.SetNextSibling)
			{
				for (int k = 0; k < e.DragItems.Length; k++)
				{
					Transform transform2 = ((GameObject)e.DragItems[k]).transform;
					if (transform2.parent != transform.parent)
					{
						transform2.SetParent(transform.parent, worldPositionStays: true);
					}
					int siblingIndex = transform.GetSiblingIndex();
					transform2.SetSiblingIndex(siblingIndex + 1);
				}
			}
			else
			{
				if (e.Action != ItemDropAction.SetPrevSibling)
				{
					return;
				}
				for (int l = 0; l < e.DragItems.Length; l++)
				{
					Transform transform3 = ((GameObject)e.DragItems[l]).transform;
					if (transform3.parent != transform.parent)
					{
						transform3.SetParent(transform.parent, worldPositionStays: true);
					}
					int siblingIndex2 = transform.GetSiblingIndex();
					transform3.SetSiblingIndex(siblingIndex2);
				}
			}
		}

		private void OnItemEndDrag(object sender, ItemDragArgs e)
		{
		}

		private void OnObjectAwaked(ExposeToEditor obj)
		{
			GameObject parent = null;
			if (obj.Parent != null)
			{
				parent = obj.Parent.gameObject;
			}
			m_treeView.AddChild(parent, obj.gameObject);
		}

		private void OnObjectStarted(ExposeToEditor obj)
		{
		}

		private void OnObjectEnabled(ExposeToEditor obj)
		{
			TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(obj.gameObject);
			if (!(treeViewItem == null))
			{
				treeViewItem.GetComponentInChildren<Text>().color = EnabledItemColor;
			}
		}

		private void OnObjectDisabled(ExposeToEditor obj)
		{
			TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(obj.gameObject);
			if (!(treeViewItem == null))
			{
				treeViewItem.GetComponentInChildren<Text>().color = DisabledItemColor;
			}
		}

		private void OnObjectDestroyed(ExposeToEditor obj)
		{
			m_treeView.Remove(obj.gameObject);
		}

		private void OnParentChanged(ExposeToEditor obj, ExposeToEditor oldParent, ExposeToEditor newParent)
		{
			GameObject parent = null;
			if (newParent != null)
			{
				parent = newParent.gameObject;
			}
			m_treeView.ChangeParent(parent, obj.gameObject);
		}

		private void OnNameChanged(ExposeToEditor obj)
		{
			TreeViewItem treeViewItem = (TreeViewItem)m_treeView.GetItemContainer(obj.gameObject);
			if (!(treeViewItem == null))
			{
				treeViewItem.GetComponentInChildren<Text>().text = obj.gameObject.name;
			}
		}
	}
	public class RuntimePrefabs : MonoBehaviour
	{
		public GameObject ListBoxPrefab;

		private ListBox m_listBox;

		public Type TypeCriteria = typeof(GameObject);

		public RuntimeEditor Editor;

		private bool m_lockSelection;

		public static bool IsPrefab(Transform This)
		{
			if (Application.isEditor && !Application.isPlaying)
			{
				throw new InvalidOperationException("Does not work in edit mode");
			}
			return This.gameObject.scene.buildIndex < 0;
		}

		private void Start()
		{
			if (!ListBoxPrefab)
			{
				UnityEngine.Debug.LogError("Set ListBoxPrefab field");
				return;
			}
			m_listBox = UnityEngine.Object.Instantiate(ListBoxPrefab).GetComponent<ListBox>();
			m_listBox.CanDrag = false;
			m_listBox.MultiselectKey = KeyCode.None;
			m_listBox.RangeselectKey = KeyCode.None;
			m_listBox.RemoveKey = KeyCode.None;
			m_listBox.transform.SetParent(base.transform, worldPositionStays: false);
			m_listBox.ItemDataBinding += OnItemDataBinding;
			m_listBox.SelectionChanged += OnSelectionChanged;
			m_listBox.ItemsRemoved += OnItemsRemoved;
			m_listBox.ItemBeginDrag += OnItemBeginDrag;
			m_listBox.ItemDrop += OnItemDrop;
			m_listBox.ItemEndDrag += OnItemEndDrag;
			RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
			if (Editor != null)
			{
				if (Editor.Prefabs != null)
				{
					for (int i = 0; i < Editor.Prefabs.Length; i++)
					{
						GameObject gameObject = Editor.Prefabs[i];
						if (gameObject != null && !gameObject.GetComponent<ExposeToEditor>())
						{
							gameObject.AddComponent<ExposeToEditor>();
						}
					}
				}
				m_listBox.Items = Editor.Prefabs;
			}
			ExposeToEditor.Destroyed += OnObjectDestroyed;
		}

		private void OnDestroy()
		{
			if ((bool)m_listBox)
			{
				m_listBox.ItemDataBinding -= OnItemDataBinding;
				m_listBox.SelectionChanged -= OnSelectionChanged;
				m_listBox.ItemsRemoved -= OnItemsRemoved;
				m_listBox.ItemBeginDrag -= OnItemBeginDrag;
				m_listBox.ItemDrop -= OnItemDrop;
				m_listBox.ItemEndDrag -= OnItemEndDrag;
				RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
				ExposeToEditor.Destroyed -= OnObjectDestroyed;
			}
		}

		private void OnApplicationQuit()
		{
			ExposeToEditor.Destroyed -= OnObjectDestroyed;
		}

		private void OnEditorSelectionChanged()
		{
			if (!m_lockSelection)
			{
				m_lockSelection = true;
				m_lockSelection = false;
			}
		}

		private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
		{
			if (!m_lockSelection)
			{
				m_lockSelection = true;
				m_listBox.SelectedItems = RuntimeSelection.gameObjects;
				m_lockSelection = false;
			}
		}

		private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
		{
			OnListBoxSelectionChanged(e.OldItems, e.NewItems);
		}

		private void OnListBoxSelectionChanged(IEnumerable oldItems, IEnumerable newItems)
		{
			if (!m_lockSelection)
			{
				m_lockSelection = true;
				if (newItems == null)
				{
					newItems = new GameObject[0];
				}
				UnityEngine.Object[] objects = newItems.OfType<GameObject>().ToArray();
				RuntimeSelection.objects = objects;
				m_lockSelection = false;
			}
		}

		private void OnItemsRemoved(object sender, ItemsRemovedArgs e)
		{
			for (int i = 0; i < e.Items.Length; i++)
			{
				GameObject gameObject = (GameObject)e.Items[i];
				if (gameObject != null)
				{
					UnityEngine.Object.Destroy(gameObject);
				}
			}
		}

		private void OnItemDataBinding(object sender, ItemDataBindingArgs e)
		{
			GameObject gameObject = e.Item as GameObject;
			if (gameObject != null)
			{
				e.ItemPresenter.GetComponentInChildren<Text>(includeInactive: true).text = gameObject.name;
			}
		}

		private void OnItemBeginDrag(object sender, ItemDragArgs e)
		{
		}

		private void OnItemDrop(object sender, ItemDropArgs e)
		{
			Transform transform = ((GameObject)e.DropTarget).transform;
			if (e.Action == ItemDropAction.SetLastChild)
			{
				for (int i = 0; i < e.DragItems.Length; i++)
				{
					Transform obj = ((GameObject)e.DragItems[i]).transform;
					obj.SetParent(transform, worldPositionStays: true);
					obj.SetAsLastSibling();
				}
			}
			else if (e.Action == ItemDropAction.SetNextSibling)
			{
				for (int j = 0; j < e.DragItems.Length; j++)
				{
					Transform transform2 = ((GameObject)e.DragItems[j]).transform;
					if (transform2.parent != transform.parent)
					{
						transform2.SetParent(transform.parent, worldPositionStays: true);
					}
					int siblingIndex = transform.GetSiblingIndex();
					transform2.SetSiblingIndex(siblingIndex + 1);
				}
			}
			else
			{
				if (e.Action != ItemDropAction.SetPrevSibling)
				{
					return;
				}
				for (int k = 0; k < e.DragItems.Length; k++)
				{
					Transform transform3 = ((GameObject)e.DragItems[k]).transform;
					if (transform3.parent != transform.parent)
					{
						transform3.SetParent(transform.parent, worldPositionStays: true);
					}
					int siblingIndex2 = transform.GetSiblingIndex();
					transform3.SetSiblingIndex(siblingIndex2);
				}
			}
		}

		private void OnItemEndDrag(object sender, ItemDragArgs e)
		{
		}

		private void OnObjectDestroyed(ExposeToEditor obj)
		{
			m_listBox.Remove(obj.gameObject);
		}
	}
	public delegate void UnityEditorToolChanged();
	public class UnityEditorToolsListener
	{
		public static event UnityEditorToolChanged ToolChanged;

		public static void Update()
		{
		}
	}
	public delegate void RuntimeSelectionChanged(UnityEngine.Object[] unselectedObjects);
	public static class RuntimeSelection
	{
		private static UnityEngine.Object m_activeObject;

		private static UnityEngine.Object[] m_objects;

		public static GameObject activeGameObject
		{
			get
			{
				return activeObject as GameObject;
			}
			set
			{
				activeObject = value;
			}
		}

		public static UnityEngine.Object activeObject
		{
			get
			{
				return m_activeObject;
			}
			set
			{
				if (m_activeObject != value)
				{
					m_activeObject = value;
					UnityEngine.Object[] unselectedObjects = m_objects;
					if (m_activeObject != null)
					{
						m_objects = new UnityEngine.Object[1] { value };
					}
					else
					{
						m_objects = new UnityEngine.Object[0];
					}
					if (RuntimeSelection.SelectionChanged != null)
					{
						RuntimeSelection.SelectionChanged(unselectedObjects);
					}
				}
			}
		}

		public static UnityEngine.Object[] objects
		{
			get
			{
				return m_objects;
			}
			set
			{
				UnityEngine.Object[] array = m_objects;
				if (value == null)
				{
					m_objects = null;
					m_activeObject = null;
				}
				else
				{
					m_objects = value.ToArray();
					if (m_activeObject == null || !m_objects.Contains(m_activeObject))
					{
						m_activeObject = m_objects.OfType<GameObject>().FirstOrDefault();
					}
				}
				if (array == m_objects || RuntimeSelection.SelectionChanged == null)
				{
					return;
				}
				if (array == null || m_objects == null)
				{
					RuntimeSelection.SelectionChanged(array);
					return;
				}
				if (array.Length != m_objects.Length)
				{
					RuntimeSelection.SelectionChanged(array);
					return;
				}
				for (int i = 0; i < m_objects.Length; i++)
				{
					if (m_objects[i] != array[i])
					{
						RuntimeSelection.SelectionChanged(array);
						break;
					}
				}
			}
		}

		public static GameObject[] gameObjects
		{
			get
			{
				if (m_objects == null)
				{
					return null;
				}
				return m_objects.OfType<GameObject>().ToArray();
			}
		}

		public static Transform activeTransform
		{
			get
			{
				if (m_activeObject == null)
				{
					return null;
				}
				if (m_activeObject is GameObject)
				{
					return ((GameObject)m_activeObject).transform;
				}
				return null;
			}
			set
			{
				if ((bool)value)
				{
					m_activeObject = value.gameObject;
				}
				else
				{
					m_activeObject = null;
				}
			}
		}

		public static event RuntimeSelectionChanged SelectionChanged;

		public static void Select(UnityEngine.Object activeGameObject, UnityEngine.Object[] selection)
		{
			m_activeObject = activeGameObject;
			objects = selection;
		}
	}
	public class RuntimeSceneView : MonoBehaviour, IDropHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler
	{
		private bool m_isPointerOverSceneView;

		public Texture2D ViewTexture;

		public Texture2D MoveTexture;

		public Camera Camera;

		public Transform Pivot;

		private bool m_pan;

		private bool m_rotate;

		private bool m_handleInput;

		private bool m_lockInput;

		private Vector3 m_lastMousePosition;

		private MouseOrbit m_mouseOrbit;

		public float RotationSensitivity = 1f;

		public float ZoomSensitivity = 8f;

		public float PanSensitivity = 100f;

		private PositionHandle m_positionHandle;

		private RotationHandle m_rotationHandle;

		private ScaleHandle m_scaleHandle;

		public bool IsPointerOver => m_isPointerOverSceneView;

		private void Awake()
		{
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			if (Run.Instance == null)
			{
				GameObject obj = new GameObject();
				obj.name = "Run";
				obj.AddComponent<Run>();
			}
			RuntimeTools.Current = RuntimeTool.View;
			GameObject gameObject = new GameObject();
			gameObject.name = "PositionHandle";
			gameObject.transform.SetParent(base.transform, worldPositionStays: false);
			m_positionHandle = gameObject.AddComponent<PositionHandle>();
			gameObject.SetActive(value: false);
			GameObject gameObject2 = new GameObject();
			gameObject2.name = "RotationHandle";
			gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
			m_rotationHandle = gameObject2.AddComponent<RotationHandle>();
			gameObject2.SetActive(value: false);
			GameObject gameObject3 = new GameObject();
			gameObject3.name = "ScaleHandle";
			gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
			m_scaleHandle = gameObject3.AddComponent<ScaleHandle>();
			gameObject3.SetActive(value: false);
			RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
			RuntimeTools.ToolChanged += OnRuntimeToolChanged;
			UnityEditorToolsListener.ToolChanged += OnUnityEditorToolChanged;
			RuntimeTools.Current = RuntimeTool.Move;
			Camera.fieldOfView = 60f;
			OnProjectionChanged();
		}

		private void OnDestroy()
		{
			RuntimeTools.Current = RuntimeTool.None;
			RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
			RuntimeTools.ToolChanged -= OnRuntimeToolChanged;
			UnityEditorToolsListener.ToolChanged -= OnUnityEditorToolChanged;
		}

		private void Start()
		{
			m_mouseOrbit = Camera.gameObject.GetComponent<MouseOrbit>();
			if (m_mouseOrbit == null)
			{
				m_mouseOrbit = Camera.gameObject.AddComponent<MouseOrbit>();
			}
			UnlockInput();
			m_mouseOrbit.enabled = false;
		}

		private void Update()
		{
			HandleInput();
		}

		public void LockInput()
		{
			m_lockInput = true;
		}

		public void UnlockInput()
		{
			m_lockInput = false;
			if (m_mouseOrbit != null)
			{
				Pivot.position = Camera.transform.position + Camera.transform.forward * m_mouseOrbit.Distance;
				m_mouseOrbit.Target = Pivot;
				m_mouseOrbit.SyncAngles();
			}
		}

		public void OnProjectionChanged()
		{
			float num = Camera.fieldOfView * ((float)Math.PI / 180f);
			float orthographicSize = (Camera.transform.position - Pivot.position).magnitude * Mathf.Sin(num / 2f);
			Camera.orthographicSize = orthographicSize;
		}

		private void OnRuntimeToolChanged()
		{
			SetCursor();
			if (RuntimeSelection.activeTransform == null)
			{
				return;
			}
			if (m_positionHandle != null)
			{
				m_positionHandle.gameObject.SetActive(value: false);
				if (RuntimeTools.Current == RuntimeTool.Move)
				{
					m_positionHandle.transform.position = RuntimeSelection.activeTransform.position;
					m_positionHandle.Targets = (from g in RuntimeSelection.gameObjects
						where g.GetComponent<ExposeToEditor>()
						select g.transform into g
						orderby RuntimeSelection.activeTransform == g descending
						select g).ToArray();
					m_positionHandle.gameObject.SetActive(m_positionHandle.Targets.Length != 0);
				}
			}
			if (m_rotationHandle != null)
			{
				m_rotationHandle.gameObject.SetActive(value: false);
				if (RuntimeTools.Current == RuntimeTool.Rotate)
				{
					m_rotationHandle.transform.position = RuntimeSelection.activeTransform.position;
					m_rotationHandle.Targets = (from g in RuntimeSelection.gameObjects
						where g.GetComponent<ExposeToEditor>()
						select g.transform into g
						orderby RuntimeSelection.activeTransform == g descending
						select g).ToArray();
					m_rotationHandle.gameObject.SetActive(m_rotationHandle.Targets.Length != 0);
				}
			}
			if (!(m_scaleHandle != null))
			{
				return;
			}
			m_scaleHandle.gameObject.SetActive(value: false);
			if (RuntimeTools.Current == RuntimeTool.Scale)
			{
				m_scaleHandle.transform.position = RuntimeSelection.activeTransform.position;
				m_scaleHandle.Targets = (from g in RuntimeSelection.gameObjects
					where g.GetComponent<ExposeToEditor>()
					select g.transform into g
					orderby RuntimeSelection.activeTransform == g descending
					select g).ToArray();
				m_scaleHandle.gameObject.SetActive(m_scaleHandle.Targets.Length != 0);
			}
		}

		private void OnUnityEditorToolChanged()
		{
		}

		private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
		{
			if (RuntimeSelection.activeGameObject == null || RuntimePrefabs.IsPrefab(RuntimeSelection.activeGameObject.transform))
			{
				if (m_positionHandle != null)
				{
					m_positionHandle.gameObject.SetActive(value: false);
				}
				if (m_rotationHandle != null)
				{
					m_rotationHandle.gameObject.SetActive(value: false);
				}
				if (m_scaleHandle != null)
				{
					m_scaleHandle.gameObject.SetActive(value: false);
				}
			}
			else
			{
				OnRuntimeToolChanged();
			}
		}

		private void HandleInput()
		{
			if (Input.GetMouseButtonUp(0) || Input.GetMouseButtonUp(1) || Input.GetMouseButtonUp(2))
			{
				m_handleInput = false;
				m_mouseOrbit.enabled = false;
				m_rotate = false;
				SetCursor();
			}
			else
			{
				if (m_lockInput)
				{
					return;
				}
				if (Input.GetKeyDown(KeyCode.F))
				{
					Focus();
				}
				bool flag = Input.GetMouseButton(2) || Input.GetMouseButton(1) || (Input.GetMouseButton(0) && RuntimeTools.Current == RuntimeTool.View);
				bool flag2 = Input.GetKey(KeyCode.AltGr) || Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt);
				if (flag != m_pan)
				{
					m_pan = flag;
					if (m_pan && RuntimeTools.Current != RuntimeTool.View)
					{
						m_rotate = false;
					}
					SetCursor();
				}
				else if (flag2 != m_rotate)
				{
					m_rotate = flag2;
					SetCursor();
				}
				bool flag4 = (RuntimeTools.IsLocked = m_rotate || flag);
				if (!flag4)
				{
					if (Input.GetKeyDown(KeyCode.Q))
					{
						RuntimeTools.Current = RuntimeTool.View;
					}
					else if (Input.GetKeyDown(KeyCode.W))
					{
						RuntimeTools.Current = RuntimeTool.Move;
					}
					else if (Input.GetKeyDown(KeyCode.E))
					{
						RuntimeTools.Current = RuntimeTool.Rotate;
					}
					else if (Input.GetKeyDown(KeyCode.R))
					{
						RuntimeTools.Current = RuntimeTool.Scale;
					}
				}
				if (!m_isPointerOverSceneView)
				{
					return;
				}
				if (Input.GetKeyDown(KeyCode.X))
				{
					if (RuntimeTools.PivotRotation == RuntimePivotRotation.Local)
					{
						RuntimeTools.PivotRotation = RuntimePivotRotation.Global;
					}
					else
					{
						RuntimeTools.PivotRotation = RuntimePivotRotation.Local;
					}
				}
				if (Input.GetMouseButtonDown(0) || Input.GetMouseButtonDown(1) || Input.GetMouseButtonDown(2))
				{
					m_handleInput = !m_positionHandle.IsDragging;
					m_lastMousePosition = Input.mousePosition;
					if (m_rotate)
					{
						m_mouseOrbit.enabled = true;
					}
				}
				if (Input.GetAxis("Mouse ScrollWheel") != 0f && (!EventSystem.current || !EventSystem.current.IsPointerOverGameObject() || m_isPointerOverSceneView))
				{
					m_mouseOrbit.Zoom();
				}
				if (m_handleInput && flag4 && m_pan && (!m_rotate || RuntimeTools.Current != RuntimeTool.View))
				{
					Pan();
				}
			}
		}

		private void Focus()
		{
			if (RuntimeSelection.activeTransform == null)
			{
				return;
			}
			Bounds bounds = CalculateBounds(RuntimeSelection.activeTransform);
			float num = Camera.fieldOfView * ((float)Math.PI / 180f);
			float num2 = Mathf.Max(bounds.extents.y, bounds.extents.x, bounds.extents.z) * 2f;
			float num3 = Mathf.Abs(num2 / Mathf.Sin(num / 2f));
			Pivot.position = bounds.center;
			Run.Instance.Animation(new Vector3AnimationInfo(Camera.transform.position, Pivot.position - num3 * Camera.transform.forward, 0.5f, AnimationInfo<object, Vector3>.EaseOutCubic, delegate(object target, Vector3 value, float t, bool completed)
			{
				if ((bool)Camera)
				{
					Camera.transform.position = value;
				}
			}));
			Run.Instance.Animation(new FloatAnimationInfo(m_mouseOrbit.Distance, num3, 0.5f, AnimationInfo<object, Vector3>.EaseOutCubic, delegate(object target, float value, float t, bool completed)
			{
				if ((bool)m_mouseOrbit)
				{
					m_mouseOrbit.Distance = value;
				}
			}));
			Run.Instance.Animation(new FloatAnimationInfo(Camera.orthographicSize, num2, 0.5f, AnimationInfo<object, Vector3>.EaseOutCubic, delegate(object target, float value, float t, bool completed)
			{
				if ((bool)Camera)
				{
					Camera.orthographicSize = value;
				}
			}));
		}

		private Bounds CalculateBounds(Transform t)
		{
			Renderer componentInChildren = t.GetComponentInChildren<Renderer>();
			if ((bool)componentInChildren)
			{
				Bounds totalBounds = componentInChildren.bounds;
				if (totalBounds.size == Vector3.zero && totalBounds.center != componentInChildren.transform.position)
				{
					totalBounds = TransformBounds(componentInChildren.transform.localToWorldMatrix, totalBounds);
				}
				CalculateBounds(t, ref totalBounds);
				if (totalBounds.extents == Vector3.zero)
				{
					totalBounds.extents = new Vector3(0.5f, 0.5f, 0.5f);
				}
				return totalBounds;
			}
			return new Bounds(t.position, new Vector3(0.5f, 0.5f, 0.5f));
		}

		private void CalculateBounds(Transform t, ref Bounds totalBounds)
		{
			foreach (Transform item in t)
			{
				Renderer component = item.GetComponent<Renderer>();
				if ((bool)component)
				{
					Bounds bounds = component.bounds;
					if (bounds.size == Vector3.zero && bounds.center != component.transform.position)
					{
						bounds = TransformBounds(component.transform.localToWorldMatrix, bounds);
					}
					totalBounds.Encapsulate(bounds.min);
					totalBounds.Encapsulate(bounds.max);
				}
				CalculateBounds(item, ref totalBounds);
			}
		}

		public static Bounds TransformBounds(Matrix4x4 matrix, Bounds bounds)
		{
			Vector3 center = matrix.MultiplyPoint(bounds.center);
			Vector3 extents = bounds.extents;
			Vector3 vector = matrix.MultiplyVector(new Vector3(extents.x, 0f, 0f));
			Vector3 vector2 = matrix.MultiplyVector(new Vector3(0f, extents.y, 0f));
			Vector3 vector3 = matrix.MultiplyVector(new Vector3(0f, 0f, extents.z));
			extents.x = Mathf.Abs(vector.x) + Mathf.Abs(vector2.x) + Mathf.Abs(vector3.x);
			extents.y = Mathf.Abs(vector.y) + Mathf.Abs(vector2.y) + Mathf.Abs(vector3.y);
			extents.z = Mathf.Abs(vector.z) + Mathf.Abs(vector2.z) + Mathf.Abs(vector3.z);
			Bounds result = default(Bounds);
			result.center = center;
			result.extents = extents;
			return result;
		}

		private void Pan()
		{
			Vector3 vector = m_lastMousePosition - Input.mousePosition;
			vector /= Mathf.Sqrt(Camera.pixelHeight * Camera.pixelHeight + Camera.pixelWidth * Camera.pixelWidth);
			vector *= PanSensitivity;
			vector = Camera.cameraToWorldMatrix.MultiplyVector(vector);
			Camera.transform.position += vector;
			Pivot.position += vector;
			m_lastMousePosition = Input.mousePosition;
		}

		void IDropHandler.OnDrop(PointerEventData eventData)
		{
			GameObject pointerDrag = eventData.pointerDrag;
			if (!(pointerDrag != null))
			{
				return;
			}
			ItemContainer component = pointerDrag.GetComponent<ItemContainer>();
			if (!(component != null) || component.Item == null)
			{
				return;
			}
			object item = component.Item;
			if (item == null || !(item is GameObject))
			{
				return;
			}
			GameObject gameObject = item as GameObject;
			if (RuntimePrefabs.IsPrefab(gameObject.transform))
			{
				Ray ray = Camera.ScreenPointToRay(Input.mousePosition);
				float distance = 15f;
				Vector3 point = ray.GetPoint(distance);
				GameObject obj = UnityEngine.Object.Instantiate(gameObject);
				ExposeToEditor component2 = obj.GetComponent<ExposeToEditor>();
				if (component2 != null)
				{
					component2.SetName(gameObject.name);
				}
				obj.transform.position = point;
				obj.transform.rotation = gameObject.transform.rotation;
				obj.transform.localScale = gameObject.transform.localScale;
				RuntimeSelection.activeGameObject = obj;
			}
		}

		void IPointerEnterHandler.OnPointerEnter(PointerEventData eventData)
		{
			m_isPointerOverSceneView = true;
			SetCursor();
		}

		private void SetCursor()
		{
			if (!m_isPointerOverSceneView)
			{
				Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
			}
			else if (m_pan)
			{
				if (m_rotate && RuntimeTools.Current == RuntimeTool.View)
				{
					Cursor.SetCursor(ViewTexture, Vector2.zero, CursorMode.Auto);
				}
				else
				{
					Cursor.SetCursor(MoveTexture, Vector2.zero, CursorMode.Auto);
				}
			}
			else if (m_rotate)
			{
				Cursor.SetCursor(ViewTexture, Vector2.zero, CursorMode.Auto);
			}
			else if (RuntimeTools.Current == RuntimeTool.View)
			{
				Cursor.SetCursor(MoveTexture, Vector2.zero, CursorMode.Auto);
			}
			else
			{
				Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
			}
		}

		void IPointerExitHandler.OnPointerExit(PointerEventData eventData)
		{
			Cursor.SetCursor(null, Vector2.zero, CursorMode.Auto);
			m_isPointerOverSceneView = false;
		}
	}
	public class RuntimeToolsPanel : MonoBehaviour
	{
		private bool m_handleValueChange = true;

		public Toggle ViewToggle;

		public Toggle MoveToggle;

		public Toggle RotateToggle;

		public Toggle ScaleToggle;

		public Toggle PivotRotationToggle;

		public Toggle WireframeToggle;

		private void OnEnable()
		{
			OnRuntimeToolChanged();
			OnPivotRotationChanged();
			RuntimeTools.ToolChanged += OnRuntimeToolChanged;
			RuntimeTools.PivotRotationChanged += OnPivotRotationChanged;
			if (ViewToggle != null)
			{
				ViewToggle.onValueChanged.AddListener(OnViewToggleValueChanged);
			}
			if (MoveToggle != null)
			{
				MoveToggle.onValueChanged.AddListener(OnMoveToggleValueChanged);
			}
			if (RotateToggle != null)
			{
				RotateToggle.onValueChanged.AddListener(OnRotateToggleValueChanged);
			}
			if (ScaleToggle != null)
			{
				ScaleToggle.onValueChanged.AddListener(OnScaleToggleValueChanged);
			}
			if (PivotRotationToggle != null)
			{
				PivotRotationToggle.onValueChanged.AddListener(OnPivotRotationToggleValueChanged);
			}
			if (WireframeToggle != null)
			{
				WireframeToggle.onValueChanged.AddListener(OnWireframeToggleValueChanged);
			}
		}

		private void OnDisable()
		{
			RuntimeTools.ToolChanged -= OnRuntimeToolChanged;
			RuntimeTools.PivotRotationChanged -= OnPivotRotationChanged;
			if (ViewToggle != null)
			{
				ViewToggle.onValueChanged.RemoveListener(OnViewToggleValueChanged);
			}
			if (MoveToggle != null)
			{
				MoveToggle.onValueChanged.RemoveListener(OnMoveToggleValueChanged);
			}
			if (RotateToggle != null)
			{
				RotateToggle.onValueChanged.RemoveListener(OnRotateToggleValueChanged);
			}
			if (ScaleToggle != null)
			{
				ScaleToggle.onValueChanged.RemoveListener(OnScaleToggleValueChanged);
			}
			if (PivotRotationToggle != null)
			{
				PivotRotationToggle.onValueChanged.RemoveListener(OnPivotRotationToggleValueChanged);
			}
			if (WireframeToggle != null)
			{
				WireframeToggle.onValueChanged.RemoveListener(OnWireframeToggleValueChanged);
			}
		}

		private void OnViewToggleValueChanged(bool value)
		{
			if (m_handleValueChange)
			{
				if (value)
				{
					RuntimeTools.Current = RuntimeTool.View;
					m_handleValueChange = false;
					RotateToggle.isOn = false;
					ScaleToggle.isOn = false;
					MoveToggle.isOn = false;
					m_handleValueChange = true;
				}
				else if (RuntimeTools.Current == RuntimeTool.View)
				{
					ViewToggle.isOn = true;
				}
			}
		}

		private void OnMoveToggleValueChanged(bool value)
		{
			if (m_handleValueChange)
			{
				if (value)
				{
					RuntimeTools.Current = RuntimeTool.Move;
					m_handleValueChange = false;
					RotateToggle.isOn = false;
					ScaleToggle.isOn = false;
					ViewToggle.isOn = false;
					m_handleValueChange = true;
				}
				else if (RuntimeTools.Current == RuntimeTool.Move)
				{
					MoveToggle.isOn = true;
				}
			}
		}

		private void OnRotateToggleValueChanged(bool value)
		{
			if (m_handleValueChange)
			{
				if (value)
				{
					RuntimeTools.Current = RuntimeTool.Rotate;
					m_handleValueChange = false;
					ViewToggle.isOn = false;
					ScaleToggle.isOn = false;
					MoveToggle.isOn = false;
					m_handleValueChange = true;
				}
				else if (RuntimeTools.Current == RuntimeTool.Rotate)
				{
					RotateToggle.isOn = true;
				}
			}
		}

		private void OnScaleToggleValueChanged(bool value)
		{
			if (m_handleValueChange)
			{
				if (value)
				{
					RuntimeTools.Current = RuntimeTool.Scale;
					m_handleValueChange = false;
					ViewToggle.isOn = false;
					RotateToggle.isOn = false;
					MoveToggle.isOn = false;
					m_handleValueChange = true;
				}
				else if (RuntimeTools.Current == RuntimeTool.Scale)
				{
					ScaleToggle.isOn = true;
				}
			}
		}

		private void OnPivotRotationToggleValueChanged(bool value)
		{
			if (value)
			{
				RuntimeTools.PivotRotation = RuntimePivotRotation.Global;
			}
			else
			{
				RuntimeTools.PivotRotation = RuntimePivotRotation.Local;
			}
		}

		private void OnWireframeToggleValueChanged(bool value)
		{
		}

		private void OnPivotRotationChanged()
		{
			if (PivotRotationToggle != null)
			{
				if (RuntimeTools.PivotRotation == RuntimePivotRotation.Global)
				{
					PivotRotationToggle.isOn = true;
				}
				else
				{
					PivotRotationToggle.isOn = false;
				}
			}
		}

		private void OnRuntimeToolChanged()
		{
			if (m_handleValueChange)
			{
				if (ViewToggle != null)
				{
					ViewToggle.isOn = RuntimeTools.Current == RuntimeTool.View;
				}
				if (MoveToggle != null)
				{
					MoveToggle.isOn = RuntimeTools.Current == RuntimeTool.Move;
				}
				if (RotateToggle != null)
				{
					RotateToggle.isOn = RuntimeTools.Current == RuntimeTool.Rotate;
				}
				if (ScaleToggle != null)
				{
					ScaleToggle.isOn = RuntimeTools.Current == RuntimeTool.Scale;
				}
			}
		}
	}
	public class TransformComponent : MonoBehaviour
	{
		public Toggle EnableDisableToggle;

		public GameObject TransformComponentUI;

		public InputField PositionX;

		public InputField PositionY;

		public InputField PositionZ;

		public InputField RotationX;

		public InputField RotationY;

		public InputField RotationZ;

		public InputField ScaleX;

		public InputField ScaleY;

		public InputField ScaleZ;

		public Button Reset;

		private Transform[] m_transforms;

		private HashSet<GameObject> m_selectedGameObjects = new HashSet<GameObject>();

		private bool m_handleTransformChange = true;

		private void Awake()
		{
			RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
		}

		private void OnDestroy()
		{
			RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
		}

		private void OnEnable()
		{
			ExposeToEditor.TransformChanged += OnTransformChanged;
			PositionX.onValueChanged.AddListener(OnPositionXChanged);
			PositionY.onValueChanged.AddListener(OnPositionYChanged);
			PositionZ.onValueChanged.AddListener(OnPositionZChanged);
			RotationX.onValueChanged.AddListener(OnRotationXChanged);
			RotationY.onValueChanged.AddListener(OnRotationYChanged);
			RotationZ.onValueChanged.AddListener(OnRotationZChanged);
			ScaleX.onValueChanged.AddListener(OnScaleXChanged);
			ScaleY.onValueChanged.AddListener(OnScaleYChanged);
			ScaleZ.onValueChanged.AddListener(OnScaleZChanged);
			PositionX.onEndEdit.AddListener(OnEndEdit);
			PositionY.onEndEdit.AddListener(OnEndEdit);
			PositionZ.onEndEdit.AddListener(OnEndEdit);
			RotationX.onEndEdit.AddListener(OnEndEdit);
			RotationY.onEndEdit.AddListener(OnEndEdit);
			RotationZ.onEndEdit.AddListener(OnEndEdit);
			ScaleX.onEndEdit.AddListener(OnEndEdit);
			ScaleY.onEndEdit.AddListener(OnEndEdit);
			ScaleZ.onEndEdit.AddListener(OnEndEdit);
			Reset.onClick.AddListener(OnResetClick);
			EnableDisableToggle.onValueChanged.AddListener(OnEnableDisableValueChanged);
			OnRuntimeSelectionChanged(null);
		}

		private void OnDisable()
		{
			ExposeToEditor.TransformChanged -= OnTransformChanged;
			PositionX.onValueChanged.RemoveListener(OnPositionXChanged);
			PositionY.onValueChanged.RemoveListener(OnPositionYChanged);
			PositionZ.onValueChanged.RemoveListener(OnPositionZChanged);
			RotationX.onValueChanged.RemoveListener(OnRotationXChanged);
			RotationY.onValueChanged.RemoveListener(OnRotationYChanged);
			RotationZ.onValueChanged.RemoveListener(OnRotationZChanged);
			ScaleX.onValueChanged.RemoveListener(OnScaleXChanged);
			ScaleY.onValueChanged.RemoveListener(OnScaleYChanged);
			ScaleZ.onValueChanged.RemoveListener(OnScaleZChanged);
			PositionX.onEndEdit.RemoveListener(OnEndEdit);
			PositionY.onEndEdit.RemoveListener(OnEndEdit);
			PositionZ.onEndEdit.RemoveListener(OnEndEdit);
			RotationX.onEndEdit.RemoveListener(OnEndEdit);
			RotationY.onEndEdit.RemoveListener(OnEndEdit);
			RotationZ.onEndEdit.RemoveListener(OnEndEdit);
			ScaleX.onEndEdit.RemoveListener(OnEndEdit);
			ScaleY.onEndEdit.RemoveListener(OnEndEdit);
			ScaleZ.onEndEdit.RemoveListener(OnEndEdit);
			Reset.onClick.RemoveListener(OnResetClick);
			EnableDisableToggle.onValueChanged.RemoveListener(OnEnableDisableValueChanged);
		}

		private void HandlePositionChanged()
		{
			if (m_handleTransformChange && m_transforms != null && m_transforms.Length != 0 && float.TryParse(PositionX.text, out var result) && float.TryParse(PositionY.text, out var result2) && float.TryParse(PositionZ.text, out var result3))
			{
				for (int i = 0; i < m_transforms.Length; i++)
				{
					m_transforms[i].position = new Vector3(result, result2, result3);
				}
			}
		}

		private void HandleRotationChanged()
		{
			if (m_handleTransformChange && m_transforms != null && m_transforms.Length != 0 && float.TryParse(RotationX.text, out var result) && float.TryParse(RotationY.text, out var result2) && float.TryParse(RotationZ.text, out var result3))
			{
				for (int i = 0; i < m_transforms.Length; i++)
				{
					m_transforms[i].rotation = Quaternion.Euler(result, result2, result3);
				}
			}
		}

		private void HandleScaleChanged()
		{
			if (m_handleTransformChange && m_transforms != null && m_transforms.Length != 0 && float.TryParse(ScaleX.text, out var result) && float.TryParse(ScaleY.text, out var result2) && float.TryParse(ScaleZ.text, out var result3))
			{
				for (int i = 0; i < m_transforms.Length; i++)
				{
					m_transforms[i].localScale = new Vector3(result, result2, result3);
				}
			}
		}

		private void EndEditField(InputField field)
		{
			if (!float.TryParse(field.text, out var _))
			{
				field.text = "0";
			}
		}

		private void OnEndEdit(string value)
		{
			EndEditField(PositionX);
			EndEditField(PositionY);
			EndEditField(PositionZ);
			EndEditField(RotationX);
			EndEditField(RotationY);
			EndEditField(RotationZ);
			EndEditField(ScaleX);
			EndEditField(ScaleY);
			EndEditField(ScaleZ);
		}

		private void OnPositionXChanged(string value)
		{
			HandlePositionChanged();
		}

		private void OnPositionYChanged(string value)
		{
			HandlePositionChanged();
		}

		private void OnPositionZChanged(string value)
		{
			HandlePositionChanged();
		}

		private void OnRotationXChanged(string value)
		{
			HandleRotationChanged();
		}

		private void OnRotationYChanged(string value)
		{
			HandleRotationChanged();
		}

		private void OnRotationZChanged(string value)
		{
			HandleRotationChanged();
		}

		private void OnScaleXChanged(string value)
		{
			HandleScaleChanged();
		}

		private void OnScaleYChanged(string value)
		{
			HandleScaleChanged();
		}

		private void OnScaleZChanged(string value)
		{
			HandleScaleChanged();
		}

		private void OnTransformChanged(ExposeToEditor obj)
		{
			if (m_selectedGameObjects.Contains(obj.gameObject))
			{
				m_handleTransformChange = false;
				UpdateAllFields();
				m_handleTransformChange = true;
			}
		}

		private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
		{
			GameObject[] gameObjects = RuntimeSelection.gameObjects;
			if (gameObjects == null)
			{
				m_selectedGameObjects.Clear();
				EnableDisableToggle.gameObject.SetActive(value: false);
				TransformComponentUI.gameObject.SetActive(value: false);
				m_transforms = null;
				return;
			}
			m_selectedGameObjects.Clear();
			m_transforms = (from g in gameObjects
				where g.GetComponent<ExposeToEditor>()
				select g.GetComponent<Transform>() into t
				where t.GetType() == typeof(Transform)
				select t).ToArray();
			for (int i = 0; i < m_transforms.Length; i++)
			{
				m_selectedGameObjects.Add(m_transforms[i].gameObject);
			}
			if (m_transforms.Length != 0)
			{
				EnableDisableToggle.gameObject.SetActive(value: true);
				TransformComponentUI.gameObject.SetActive(value: true);
				m_handleTransformChange = false;
				UpdateAllFields();
				m_handleTransformChange = true;
			}
			else
			{
				EnableDisableToggle.gameObject.SetActive(value: false);
				TransformComponentUI.gameObject.SetActive(value: false);
			}
		}

		private void UpdateAllFields()
		{
			IEnumerable<float> values = m_transforms.Select((Transform t) => t.position.x);
			IEnumerable<float> values2 = m_transforms.Select((Transform t) => t.position.y);
			IEnumerable<float> values3 = m_transforms.Select((Transform t) => t.position.z);
			IEnumerable<float> values4 = m_transforms.Select((Transform t) => t.rotation.eulerAngles.x);
			IEnumerable<float> values5 = m_transforms.Select((Transform t) => t.rotation.eulerAngles.y);
			IEnumerable<float> values6 = m_transforms.Select((Transform t) => t.rotation.eulerAngles.z);
			IEnumerable<float> values7 = m_transforms.Select((Transform t) => t.localScale.x);
			IEnumerable<float> values8 = m_transforms.Select((Transform t) => t.localScale.y);
			IEnumerable<float> values9 = m_transforms.Select((Transform t) => t.localScale.z);
			SetFieldValue(PositionX, values);
			SetFieldValue(PositionY, values2);
			SetFieldValue(PositionZ, values3);
			SetFieldValue(RotationX, values4);
			SetFieldValue(RotationY, values5);
			SetFieldValue(RotationZ, values6);
			SetFieldValue(ScaleX, values7);
			SetFieldValue(ScaleY, values8);
			SetFieldValue(ScaleZ, values9);
			EnableDisableToggle.isOn = m_transforms.All((Transform t) => t.gameObject.activeSelf);
		}

		private void SetFieldValue(InputField field, IEnumerable<float> values)
		{
			if (values.Any((float p) => p != values.First()))
			{
				field.text = string.Empty;
			}
			else
			{
				field.text = values.First().ToString();
			}
		}

		private void OnResetClick()
		{
			float num = 0f;
			float num2 = 1f;
			PositionX.text = num.ToString();
			PositionY.text = num.ToString();
			PositionZ.text = num.ToString();
			RotationX.text = num.ToString();
			RotationY.text = num.ToString();
			RotationZ.text = num.ToString();
			ScaleX.text = num2.ToString();
			ScaleY.text = num2.ToString();
			ScaleZ.text = num2.ToString();
		}

		private void OnEnableDisableValueChanged(bool value)
		{
			for (int i = 0; i < m_transforms.Length; i++)
			{
				m_transforms[i].gameObject.SetActive(value);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(RectTransform))]
	public class ViewportFitter : MonoBehaviour
	{
		public UnityEvent ViewportRectChanged;

		private RectTransform m_viewport;

		private Vector3 m_viewportPosition;

		private float m_viewportWidth;

		private float m_viewportHeight;

		public Camera Camera;

		private void Awake()
		{
			m_viewport = GetComponent<RectTransform>();
			if (Camera == null)
			{
				Camera = Camera.main;
			}
			if (Camera == null)
			{
				UnityEngine.Debug.LogWarning("Set Camera");
				return;
			}
			Canvas componentInParent = m_viewport.GetComponentInParent<Canvas>();
			if (componentInParent == null)
			{
				base.gameObject.SetActive(value: false);
			}
			else if (componentInParent.renderMode != 0)
			{
				base.gameObject.SetActive(value: false);
				UnityEngine.Debug.LogWarning("ViewportFitter requires canvas.renderMode -> RenderMode.ScreenSpaceOverlay");
			}
			else
			{
				Camera.pixelRect = new Rect(new Vector2(0f, 0f), new Vector2(Screen.width, Screen.height));
			}
		}

		private void OnEnable()
		{
			Rect rect = m_viewport.rect;
			UpdateViewport();
			m_viewportHeight = rect.height;
			m_viewportWidth = rect.width;
			m_viewportPosition = m_viewport.position;
		}

		private void Start()
		{
			Rect rect = m_viewport.rect;
			UpdateViewport();
			m_viewportHeight = rect.height;
			m_viewportWidth = rect.width;
			m_viewportPosition = m_viewport.position;
		}

		private void OnDisable()
		{
			if (Camera != null)
			{
				Camera.rect = new Rect(0f, 0f, 1f, 1f);
				ViewportRectChanged.Invoke();
			}
		}

		private void OnGUI()
		{
			if (m_viewport != null)
			{
				Rect rect = m_viewport.rect;
				if (m_viewportHeight != rect.height || m_viewportWidth != rect.width || m_viewportPosition != m_viewport.position)
				{
					UpdateViewport();
					m_viewportHeight = rect.height;
					m_viewportWidth = rect.width;
					m_viewportPosition = m_viewport.position;
				}
			}
		}

		private void UpdateViewport()
		{
			if (!(Camera == null))
			{
				Vector3[] array = new Vector3[4];
				m_viewport.GetWorldCorners(array);
				Camera.pixelRect = new Rect(array[0], new Vector2(array[2].x - array[0].x, array[1].y - array[0].y));
				ViewportRectChanged.Invoke();
			}
		}
	}
}
namespace Battlehub.SplineEditor
{
	public class EpiSplineHelper : MonoBehaviour
	{
		public SplineFollow splineFollow;

		public float speedMultiplier = 5f;

		public float speedUpTime = 5f;

		private float initialSpeed;

		private void Start()
		{
			initialSpeed = splineFollow.Speed;
		}

		public void SpeedUp()
		{
			splineFollow.Speed = initialSpeed * speedMultiplier;
			Invoke("ResetSpeed", speedUpTime);
		}

		public void ResetSpeed()
		{
			splineFollow.Speed = initialSpeed;
		}
	}
	public class EpiSplineObject : MonoBehaviour
	{
		public SplineBase spline;

		public GameObject spawnObject;

		public float offset;

		public bool test;

		public void Update()
		{
			if (test)
			{
				Spawn();
				test = false;
			}
		}

		public void Spawn()
		{
			int num = 0;
			int index = num + 1;
			Twist twist = spline.GetTwist(num);
			Vector3 controlPoint = spline.GetControlPoint(num);
			Vector3 controlPoint2 = spline.GetControlPoint(index);
			SplineFollow component = UnityEngine.Object.Instantiate(spawnObject, spline.GetPoint(0f), Quaternion.AngleAxis(twist.Data, controlPoint2 - controlPoint) * Quaternion.LookRotation(controlPoint2 - controlPoint)).GetComponent<SplineFollow>();
			component.Spline = spline;
			component.Offset = offset;
		}
	}
	public class Greedy : MonoBehaviour
	{
		public void OnFork(ForkEventArgs args)
		{
			float num = float.MaxValue;
			int selectBranchIndex = -1;
			if (args.NextCurveIndex != -1)
			{
				num = args.Spline.EvalCurveLength(args.NextCurveIndex);
			}
			for (int i = 0; i < args.Branches.Length; i++)
			{
				float num2 = args.Branches[i].EvalCurveLength(0);
				if (num2 < num)
				{
					num = num2;
					selectBranchIndex = i;
				}
			}
			args.SelectBranchIndex = selectBranchIndex;
		}
	}
	public class MapGen : MonoBehaviour
	{
		public GameObject BuildingPrefab;

		public int Rows = 10;

		public int Cols = 10;

		public float Density = 0.2f;

		public float Width = 2f;

		public float Length = 2f;

		public float MinHeight = 8f;

		public float MaxHeight = 16f;

		public void Generate()
		{
			for (int num = base.transform.childCount - 1; num >= 0; num--)
			{
				UnityEngine.Object.DestroyImmediate(base.transform.GetChild(num).gameObject);
			}
			for (int i = 0; i < Rows; i++)
			{
				for (int j = 0; j < Cols; j++)
				{
					if (UnityEngine.Random.value < Density)
					{
						float x = (float)(-Rows) * Width / 2f + (float)i * Width;
						float z = (float)(-Cols) * Length / 2f + (float)j * Length;
						float y = MinHeight + UnityEngine.Random.value * (MaxHeight - MinHeight);
						GameObject obj = UnityEngine.Object.Instantiate(BuildingPrefab, new Vector3(x, 0f, z), Quaternion.identity);
						obj.transform.localScale = new Vector3(Width / 2f, y, Length / 2f);
						obj.transform.SetParent(base.transform, worldPositionStays: true);
					}
				}
			}
		}
	}
	public class Paperplane : MonoBehaviour
	{
		public GameObject ExplosionPrefab;

		public void Destroy()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo) && hitInfo.transform == base.transform)
			{
				Explode();
			}
		}

		private void OnTriggerEnter(Collider collision)
		{
			Explode();
		}

		private void Explode()
		{
			if (ExplosionPrefab != null)
			{
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(ExplosionPrefab, base.transform.position, base.transform.rotation), 3f);
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class PaperplaneSpawn : MonoBehaviour
	{
		public float Interval = 2f;

		private float m_timeElapsed;

		public SmoothFollow SmoothFollow;

		public GameObject PaperplanePrefab;

		private SplineBase m_spline;

		public string SplineName = "Spline";

		private void Start()
		{
			if (m_spline == null)
			{
				GameObject gameObject = GameObject.Find(SplineName);
				if (gameObject != null)
				{
					m_spline = gameObject.GetComponent<SplineBase>();
				}
				if (m_spline == null)
				{
					UnityEngine.Debug.LogError("Unable to find spline " + m_spline);
					base.enabled = false;
					return;
				}
			}
			Spawn();
		}

		private void Update()
		{
			m_timeElapsed += Time.deltaTime;
			if (m_timeElapsed >= Interval)
			{
				Spawn();
				m_timeElapsed = 0f;
			}
		}

		private void Spawn()
		{
			int num = 0;
			int index = num + 1;
			Twist twist = m_spline.GetTwist(num);
			Vector3 controlPoint = m_spline.GetControlPoint(num);
			Vector3 controlPoint2 = m_spline.GetControlPoint(index);
			GameObject gameObject = UnityEngine.Object.Instantiate(PaperplanePrefab, m_spline.GetPoint(0f), Quaternion.AngleAxis(twist.Data, controlPoint2 - controlPoint) * Quaternion.LookRotation(controlPoint2 - controlPoint));
			gameObject.GetComponent<SplineFollow>().Spline = m_spline;
			if (!SmoothFollow.enabled)
			{
				SmoothFollow.SetTarget(gameObject.transform);
				SmoothFollow.enabled = true;
			}
		}
	}
	public class Rand : MonoBehaviour
	{
		public void OnFork(ForkEventArgs args)
		{
			int selectBranchIndex = UnityEngine.Random.Range((args.NextCurveIndex != -1) ? (-1) : 0, args.Branches.Length);
			args.SelectBranchIndex = selectBranchIndex;
		}
	}
	public class SmoothFollow : MonoBehaviour
	{
		private bool m_wait;

		private Transform target;

		[SerializeField]
		private float distance = 10f;

		[SerializeField]
		private float height = 5f;

		[SerializeField]
		private float rotationDamping;

		[SerializeField]
		private float heightDamping;

		private void Start()
		{
		}

		public void SetTarget(Transform tr)
		{
			target = tr;
		}

		private IEnumerator ChangeTaget()
		{
			yield return new WaitForSeconds(1f);
			m_wait = false;
			if (!target)
			{
				Paperplane paperplane = UnityEngine.Object.FindObjectOfType<Paperplane>();
				if (paperplane != null)
				{
					SetTarget(paperplane.transform);
				}
				else
				{
					base.enabled = false;
				}
			}
		}

		private void LateUpdate()
		{
			if (RuntimeEditor.Instance != null && RuntimeEditor.Instance.IsOn)
			{
				return;
			}
			if (!target)
			{
				if (!m_wait)
				{
					StartCoroutine(ChangeTaget());
					m_wait = true;
				}
				return;
			}
			float y = target.eulerAngles.y;
			float b = target.position.y + height;
			float y2 = base.transform.eulerAngles.y;
			float y3 = base.transform.position.y;
			y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
			y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
			Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
			base.transform.position = target.position;
			base.transform.position -= quaternion * Vector3.forward * distance;
			base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
			base.transform.LookAt(target);
		}
	}
	[Serializable]
	public class ForkEventArgs
	{
		private SplineBase[] m_branches;

		private SplineBase m_spline;

		private int m_nextCurveIndex;

		public SplineBase[] Branches => m_branches;

		public SplineBase Spline => m_spline;

		public int NextCurveIndex => m_nextCurveIndex;

		public int SelectBranchIndex { get; set; }

		public ForkEventArgs(SplineBase spline, int pointIndex)
		{
			m_spline = spline;
			m_nextCurveIndex = pointIndex / 3;
			SplineBranch[] branches = spline.GetBranches(pointIndex);
			if (branches == null || branches.Length == 0)
			{
				m_branches = new SplineBase[0];
			}
			else
			{
				List<SplineBase> list = new List<SplineBase>();
				for (int i = 0; i < branches.Length; i++)
				{
					SplineBranch branch = branches[i];
					if (!branch.Inbound)
					{
						list.Add(spline.BranchToSpline(branch));
					}
				}
				m_branches = list.ToArray();
			}
			if (m_nextCurveIndex >= spline.CurveCount)
			{
				if (m_branches.Length != 0)
				{
					SelectBranchIndex = 0;
				}
				SelectBranchIndex = -1;
				m_nextCurveIndex = -1;
			}
			else
			{
				SelectBranchIndex = -1;
			}
		}
	}
	[Serializable]
	public class ForkEvent : UnityEvent<ForkEventArgs>
	{
	}
	public class SplineFollow : MonoBehaviour
	{
		public float Speed = 5f;

		public SplineBase Spline;

		public float Offset;

		public bool IsRunning = true;

		public bool IsLoop;

		public ForkEvent Fork;

		public UnityEvent Completed;

		private SplineBase m_spline;

		private bool m_isRunning;

		private bool m_isCompleted;

		private float m_t;

		private int m_curveIndex;

		private void Start()
		{
			if (!Spline)
			{
				UnityEngine.Debug.LogError("Set Spline Field!");
				base.enabled = false;
			}
			else
			{
				m_isCompleted = true;
			}
		}

		private void Update()
		{
			if (IsRunning != m_isRunning)
			{
				if (m_isCompleted)
				{
					Restart();
				}
				m_isRunning = IsRunning;
			}
			if (IsRunning)
			{
				Move();
			}
		}

		private void Restart()
		{
			m_spline = Spline;
			m_t = Offset % 1f;
			m_curveIndex = Spline.ToCurveIndex(m_t);
			m_isCompleted = false;
			IsRunning = true;
		}

		private void Move()
		{
			int num = m_spline.ToCurveIndex(m_t);
			if (m_curveIndex != num || m_t >= 1f)
			{
				CheckBranches(num);
			}
			float t = m_t;
			UpdatePosition(t);
			float magnitude = m_spline.GetVelocity(t).magnitude;
			magnitude *= (float)m_spline.CurveCount;
			if (m_t >= 1f)
			{
				if (m_spline.NextSpline != null)
				{
					int nextControlPointIndex = m_spline.NextControlPointIndex;
					m_curveIndex = nextControlPointIndex / 3;
					m_spline = m_spline.NextSpline;
					if (m_spline.NextControlPointIndex > 0)
					{
						m_t = (float)m_curveIndex / (float)m_spline.CurveCount;
						m_curveIndex++;
					}
					else
					{
						m_t = (float)m_curveIndex / (float)m_spline.CurveCount;
					}
					UnityEngine.Debug.Log("Next Spline " + m_curveIndex);
					CheckBranches(m_curveIndex);
					return;
				}
				m_t = m_t - 1f + Time.deltaTime * Speed / magnitude;
				if (!m_spline.Loop && !IsLoop)
				{
					m_t = 1f;
					m_isCompleted = true;
					IsRunning = false;
					m_isRunning = false;
					Completed.Invoke();
				}
				if (IsLoop && m_spline != Spline)
				{
					Restart();
				}
			}
			else
			{
				m_t += Time.deltaTime * Speed / magnitude;
			}
		}

		private void CheckBranches(int curveIndex)
		{
			int num = curveIndex * 3;
			if (m_t >= 1f)
			{
				num += 3;
			}
			m_curveIndex = curveIndex;
			if (m_spline.HasBranches(num))
			{
				ForkEventArgs forkEventArgs = new ForkEventArgs(m_spline, num);
				Fork.Invoke(forkEventArgs);
				if (forkEventArgs.SelectBranchIndex > -1 && forkEventArgs.SelectBranchIndex < forkEventArgs.Branches.Length)
				{
					UnityEngine.Debug.Log("CurveIndex " + m_curveIndex);
					UnityEngine.Debug.Log("Selected Branch " + forkEventArgs.SelectBranchIndex);
					m_spline = forkEventArgs.Branches[forkEventArgs.SelectBranchIndex];
					m_t = 0f;
					m_curveIndex = 0;
				}
			}
		}

		private void UpdatePosition(float t)
		{
			Vector3 point = m_spline.GetPoint(t);
			Vector3 direction = m_spline.GetDirection(t);
			float twist = m_spline.GetTwist(t);
			base.transform.position = point;
			base.transform.LookAt(point + direction);
			base.transform.RotateAround(point, direction, twist);
		}
	}
	public static class CurveUtils
	{
		public static float GetT(this SplineBase spline, int curveIndex, Vector3 testPoint, float eps = 0.01f)
		{
			float num = 1f / (float)spline.CurveCount * (float)curveIndex;
			float tEnd = num + 1f / (float)spline.CurveCount;
			int iter = 0;
			return spline.GetT(num, tEnd, testPoint, ref iter, eps);
		}

		private static float GetT(this SplineBase spline, float tStart, float tEnd, Vector3 testPoint, ref int iter, float eps = 0.01f)
		{
			iter++;
			float num = eps * eps;
			Vector3 point = spline.GetPoint(tStart);
			Vector3 point2 = spline.GetPoint(tEnd);
			Vector3 vector = point - testPoint;
			Vector3 vector2 = point2 - testPoint;
			if (vector.sqrMagnitude < vector2.sqrMagnitude)
			{
				if ((point2 - point).sqrMagnitude <= num)
				{
					return tStart;
				}
				return spline.GetT(tStart, (tStart + tEnd) / 2f, testPoint, ref iter, eps);
			}
			if ((point2 - point).sqrMagnitude <= num)
			{
				return tEnd;
			}
			return spline.GetT((tStart + tEnd) / 2f, tEnd, testPoint, ref iter, eps);
		}

		public static Vector3 GetPoint(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return num * num * num * p0 + 3f * num * num * t * p1 + 3f * num * t * t * p2 + t * t * t * p3;
		}

		public static Vector3 GetFirstDerivative(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			return 3f * num * num * (p1 - p0) + 6f * num * t * (p2 - p1) + 3f * t * t * (p3 - p2);
		}
	}
	[ExecuteInEditMode]
	public class Spline : SplineBase
	{
		private const float Mag = 5f;

		public void Append()
		{
			AppendCurve(5f, enforceNeighbour: false);
		}

		public void AppendThorugh(Transform t)
		{
			Vector3[] array = new Vector3[3];
			AlignWithEnding(array, base.CurveCount - 1, 5f);
			Vector3 pointLocal = GetPointLocal(1f);
			Vector3 vector = (array[2] = base.transform.InverseTransformPoint(t.position - t.forward));
			array[1] = vector - base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (1f / 3f);
			array[0] = vector - base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (2f / 3f);
			AppendCurve(array, enforceNeighbour: false);
		}

		public void Insert(int curveIndex)
		{
			PrependCurve(5f, curveIndex, enforceNeighbour: false, shrinkPreceding: true);
		}

		public void Prepend()
		{
			if (!Loop)
			{
				PrependCurve(5f, 0, enforceNeighbour: false, shrinkPreceding: false);
			}
			else
			{
				AppendCurve(5f, enforceNeighbour: false);
			}
		}

		public void PrependThrough(Transform t)
		{
			if (!Loop)
			{
				Vector3[] array = new Vector3[3];
				AlignWithBeginning(array, 0, 5f);
				Vector3 pointLocal = GetPointLocal(0f);
				Vector3 vector = (array[0] = base.transform.InverseTransformPoint(t.position + t.forward));
				array[1] = vector + base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (1f / 3f);
				array[2] = vector + base.transform.InverseTransformVector(t.forward).normalized * (vector - pointLocal).magnitude * (2f / 3f);
				PrependCurve(array, 0, 5f, enforceNeighbour: false, shrinkPreceding: false);
			}
			else
			{
				AppendThorugh(t);
			}
		}

		public bool Remove(int curveIndex)
		{
			return RemoveCurve(curveIndex);
		}

		public override void Load(SplineSnapshot snapshot)
		{
			LoadSpline(snapshot);
		}

		protected override void OnCurveChanged()
		{
		}

		protected override float GetMag()
		{
			return 5f;
		}

		private void AppendCurve(float mag, bool enforceNeighbour)
		{
			Vector3[] points = new Vector3[3];
			AlignWithEnding(points, base.CurveCount - 1, mag);
			AppendCurve(points, enforceNeighbour);
		}

		private void PrependCurve(float mag, int curveIndex, bool enforceNeighbour, bool shrinkPreceding)
		{
			Vector3[] points = new Vector3[3];
			if (!shrinkPreceding)
			{
				AlignWithBeginning(points, curveIndex, mag);
			}
			PrependCurve(points, curveIndex, mag, enforceNeighbour, shrinkPreceding);
		}
	}
	public enum ControlPointMode
	{
		Free,
		Aligned,
		Mirrored
	}
	public enum ExtendAction
	{
		Append,
		Prepend,
		Insert
	}
	[Serializable]
	public struct Vector3Serialziable
	{
		public float X;

		public float Y;

		public float Z;

		public Vector3Serialziable(float x, float y, float z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		public static implicit operator Vector3(Vector3Serialziable v)
		{
			return new Vector3(v.X, v.Y, v.Z);
		}

		public static implicit operator Vector3Serialziable(Vector3 v)
		{
			return new Vector3Serialziable(v.x, v.y, v.z);
		}
	}
	[Serializable]
	public struct SplineSnapshot
	{
		[SerializeField]
		private Vector3[] m_points;

		[SerializeField]
		private ControlPointSetting[] m_controlPointSettings;

		[SerializeField]
		private ControlPointMode[] m_modes;

		[SerializeField]
		private bool m_loop;

		public int CurveCount => (m_points.Length - 1) / 3;

		public Vector3[] Points => m_points;

		public ControlPointSetting[] ControlPointSettings => m_controlPointSettings;

		public ControlPointMode[] Modes => m_modes;

		public bool Loop => m_loop;

		public SplineSnapshot(Vector3[] points, ControlPointSetting[] settings, ControlPointMode[] modes, bool loop)
		{
			int num = (points.Length - 1) / 3;
			int num2 = (points.Length - 1) / 2;
			int num3 = num * 3 + 1;
			num++;
			if (num < 1)
			{
				throw new ArgumentException("too few points. at least 4 required");
			}
			m_points = points;
			if (num3 != m_points.Length)
			{
				Array.Resize(ref points, num3);
			}
			m_controlPointSettings = settings;
			if (num2 != m_controlPointSettings.Length)
			{
				Array.Resize(ref settings, num2);
			}
			m_modes = modes;
			if (num != m_modes.Length)
			{
				Array.Resize(ref m_modes, num);
			}
			m_loop = loop;
		}
	}
	public delegate void ControlPointChanged(int pointIndex);
	[Serializable]
	public struct Twist
	{
		public static readonly Twist Null;

		public float Data;

		public float T1;

		public float T2;

		public Twist(float data, float t1, float t2)
		{
			Data = data;
			T1 = t1;
			T2 = t2;
		}
	}
	[Serializable]
	public struct Thickness
	{
		public static readonly Thickness Null;

		public Vector3Serialziable Data;

		public float T1;

		public float T2;

		public Thickness(Vector3 data, float t1, float t2)
		{
			Data = data;
			T1 = t1;
			T2 = t2;
		}
	}
	[Serializable]
	public struct SplineBranch
	{
		public int SplineIndex;

		public bool Inbound;

		public SplineBranch(int splineIndex, bool inbound)
		{
			SplineIndex = splineIndex;
			Inbound = inbound;
		}
	}
	[Serializable]
	public struct ControlPointSetting
	{
		public Twist Twist;

		public Thickness Thickness;

		public SplineBranch[] Branches;

		public ControlPointSetting(Twist twist, Thickness thickness, SplineBranch[] connections)
		{
			Twist = twist;
			Thickness = thickness;
			Branches = connections;
		}

		public ControlPointSetting(Twist twist, Thickness thickness)
		{
			Twist = twist;
			Thickness = thickness;
			Branches = null;
		}
	}
	[ExecuteInEditMode]
	public class SplineBase : MonoBehaviour, IGL
	{
		private static readonly Color SplineColor = Color.green;

		private static float Smoothness = 5f;

		private static Material m_splineMaterial;

		private static SplineBase m_convergingSpline;

		private static SplineBase m_activeSpline;

		private static int m_activeControlPointIndex = -1;

		[SerializeField]
		[HideInInspector]
		private ControlPointMode[] m_modes;

		[SerializeField]
		[HideInInspector]
		private Vector3[] m_points;

		[SerializeField]
		[HideInInspector]
		private ControlPointSetting[] m_settings;

		[SerializeField]
		[HideInInspector]
		private bool m_loop;

		private bool m_isSelected;

		[SerializeField]
		[HideInInspector]
		private SplineBase m_prevSpline;

		[SerializeField]
		[HideInInspector]
		private int m_prevControlPointIndex;

		[SerializeField]
		[HideInInspector]
		private SplineBase m_nextSpline;

		[SerializeField]
		[HideInInspector]
		private int m_nextControlPointIndex;

		[SerializeField]
		[HideInInspector]
		private SplineBase[] m_branches;

		[SerializeField]
		[HideInInspector]
		private SplineBase m_parent;

		[SerializeField]
		[HideInInspector]
		private SplineBase[] m_children;

		private bool m_isApplicationQuit;

		public static SplineBase ActiveSpline
		{
			get
			{
				return m_activeSpline;
			}
			set
			{
				m_activeSpline = value;
			}
		}

		public static int ActiveControlPointIndex
		{
			get
			{
				return m_activeControlPointIndex;
			}
			set
			{
				m_activeControlPointIndex = value;
			}
		}

		public static SplineBase ConvergingSpline
		{
			get
			{
				return m_convergingSpline;
			}
			set
			{
				if (m_convergingSpline != value)
				{
					m_convergingSpline = value;
					if (SplineBase.ConvergingSplineChanged != null)
					{
						SplineBase.ConvergingSplineChanged(null, EventArgs.Empty);
					}
				}
			}
		}

		public static Material SplineMaterial => m_splineMaterial;

		public static bool SplineMaterialZTest
		{
			get
			{
				return PlayerPrefs.GetInt("Battehub.SplineEditor.SplineMaterialZTest", 0) == 1;
			}
			set
			{
				if (SplineMaterial != null)
				{
					SetSplieMaterialZTest(value);
				}
				PlayerPrefs.SetInt("Battehub.SplineEditor.SplineMaterialZTest", value ? 1 : 0);
			}
		}

		public int NextControlPointIndex => m_nextControlPointIndex;

		public SplineBase NextSpline => m_nextSpline;

		public int PrevControlPointIndex => m_prevControlPointIndex;

		public SplineBase PrevSpline => m_prevSpline;

		public bool IsSelected => m_isSelected;

		public virtual bool Loop
		{
			get
			{
				return m_loop;
			}
			set
			{
				m_loop = value;
				if (m_loop)
				{
					Disconnect(0);
					Disconnect(ControlPointCount - 1);
					if (PrevSpline != null)
					{
						PrevSpline.Disconnect(this, isInbound: false);
					}
					if (NextSpline != null)
					{
						NextSpline.Disconnect(this, isInbound: true);
					}
					ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
					m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
					m_modes[m_modes.Length - 1] = m_modes[0];
					RaiseControlPointModeChanged(m_modes.Length - 1);
					_SetControlPointLocalUnchecked(m_points.Length - 1, m_points[0]);
				}
			}
		}

		public int CurveCount => (m_points.Length - 1) / 3;

		public int ControlPointCount => m_points.Length;

		public SplineBase Root
		{
			get
			{
				SplineBase splineBase = this;
				while (splineBase.Parent != null)
				{
					splineBase = splineBase.Parent;
				}
				return splineBase;
			}
		}

		public SplineBase Parent => m_parent;

		public SplineBase[] Children => m_children;

		public static event EventHandler ConvergingSplineChanged;

		public event ControlPointChanged ControlPointPositionChanged;

		public event ControlPointChanged ControlPointModeChanged;

		public event ControlPointChanged ControlPointConnectionChanged;

		public event ControlPointChanged ControlPointThicknessChanged;

		public event ControlPointChanged ControlPointTwistChanged;

		private static void SetSplieMaterialZTest(bool value)
		{
			if (value)
			{
				SplineMaterial.SetInt("_ZTest", 4);
			}
			else
			{
				SplineMaterial.SetInt("_ZTest", 8);
			}
		}

		private static void InitSplineMaterial()
		{
			m_splineMaterial = new Material(Shader.Find("Battlehub/SplineEditor/Spline"));
			m_splineMaterial.name = "SplineMaterial";
			m_splineMaterial.color = SplineColor;
			SetSplieMaterialZTest(SplineMaterialZTest);
			if (UnityEngine.Object.FindObjectOfType<GLRenderer>() == null)
			{
				GameObject obj = new GameObject();
				obj.name = "GLRenderer";
				obj.AddComponent<GLRenderer>();
			}
		}

		void IGL.Draw()
		{
			if (m_points.Length < 2)
			{
				return;
			}
			if (m_splineMaterial == null)
			{
				InitSplineMaterial();
			}
			m_splineMaterial.SetPass(0);
			GL.PushMatrix();
			GL.MultMatrix(base.transform.localToWorldMatrix);
			GL.Begin(1);
			Vector3 v = m_points[0];
			for (int i = 1; i < m_points.Length; i += 3)
			{
				Vector3 v2 = m_points[i];
				Vector3 v3 = m_points[i + 1];
				Vector3 vector = m_points[i + 2];
				if (!ConvergingSpline)
				{
					GL.Color(SplineRuntimeEditor.ControlPointLineColor);
					GL.Vertex(v);
					GL.Vertex(v2);
					GL.Color(SplineRuntimeEditor.ControlPointLineColor);
					GL.Vertex(v3);
					GL.Vertex(vector);
				}
				v = vector;
			}
			GL.End();
			GL.Begin(1);
			GL.Color(SplineColor);
			v = m_points[0];
			for (int j = 1; j < m_points.Length; j += 3)
			{
				Vector3 vector2 = m_points[j];
				Vector3 vector3 = m_points[j + 1];
				Vector3 vector4 = m_points[j + 2];
				float num = (v - vector2).magnitude + (vector2 - vector3).magnitude + (vector3 - vector4).magnitude;
				int num2 = Mathf.CeilToInt(Smoothness * num);
				if (num2 <= 0)
				{
					num2 = 1;
				}
				for (int k = 0; k < num2; k++)
				{
					float t = (float)k / (float)num2;
					GL.Vertex(CurveUtils.GetPoint(v, vector2, vector3, vector4, t));
					t = ((float)k + 1f) / (float)num2;
					GL.Vertex(CurveUtils.GetPoint(v, vector2, vector3, vector4, t));
				}
				v = vector4;
			}
			ShowTwistAngles();
			GL.End();
			GL.PopMatrix();
		}

		protected virtual void ShowTwistAngles()
		{
			GL.Color(SplineRuntimeEditor.ControlPointLineColor);
			int num = GetStepsPerCurve() * CurveCount;
			for (int i = 0; i <= num; i++)
			{
				DrawTwistAngle(i, num);
			}
			if (m_activeSpline == this && m_activeControlPointIndex > -1 && m_activeControlPointIndex < m_activeSpline.ControlPointCount)
			{
				GL.Color(SplineColor);
				int val = (m_activeControlPointIndex + 1) / 3;
				val = Math.Min(val, CurveCount - 1);
				num = GetStepsPerCurve() * 5;
				Twist twist = GetTwist(m_activeControlPointIndex);
				int num2 = Mathf.CeilToInt(twist.T1 * (float)num);
				int num3 = Mathf.CeilToInt(twist.T2 * (float)num);
				for (int j = num2; j <= num3; j++)
				{
					DrawTwistAngle(val, j, num);
				}
			}
		}

		private void DrawTwistAngle(int i, int steps)
		{
			float t = (float)i / (float)steps;
			Vector3 direction = GetDirection(t);
			Vector3 pointLocal = GetPointLocal(t);
			float twist = GetTwist(t);
			Vector3 upVector = GetUpVector();
			Vector3 forward = ((!(Math.Abs(Vector3.Dot(direction, upVector)) < 1f)) ? Vector3.Cross(direction, GetSideVector()).normalized : Vector3.Cross(direction, upVector).normalized);
			if (!(direction == Vector3.zero))
			{
				GL.Vertex(pointLocal);
				GL.Vertex(pointLocal + Quaternion.AngleAxis(twist, direction) * Quaternion.LookRotation(forward, upVector) * Vector3.forward * 0.5f);
			}
		}

		private void DrawTwistAngle(int curveIndex, int i, int steps)
		{
			float t = (float)i / (float)steps;
			Vector3 direction = GetDirection(t, curveIndex);
			Vector3 pointLocal = GetPointLocal(t, curveIndex);
			float twist = GetTwist(t, curveIndex);
			Vector3 upVector = GetUpVector();
			Vector3 forward = ((!(Math.Abs(Vector3.Dot(direction, upVector)) < 1f)) ? Vector3.Cross(direction, GetSideVector()).normalized : Vector3.Cross(direction, upVector).normalized);
			if (!(direction == Vector3.zero))
			{
				GL.Vertex(pointLocal);
				GL.Vertex(pointLocal + Quaternion.AngleAxis(twist, direction) * Quaternion.LookRotation(forward, upVector) * Vector3.forward * 0.5f);
			}
		}

		protected virtual int GetStepsPerCurve()
		{
			return 5;
		}

		protected virtual Vector3 GetUpVector()
		{
			return Vector3.up;
		}

		protected virtual Vector3 GetSideVector()
		{
			return Vector3.forward;
		}

		private void RaiseControlPointThicknessChanged(int index)
		{
			if (this.ControlPointThicknessChanged != null)
			{
				this.ControlPointThicknessChanged(index);
			}
		}

		private void RaisControlPointTwistChanged(int index)
		{
			if (this.ControlPointTwistChanged != null)
			{
				this.ControlPointTwistChanged(index);
			}
		}

		private void RaiseControlPointChanged(int index)
		{
			if (this.ControlPointPositionChanged != null)
			{
				this.ControlPointPositionChanged(index);
			}
		}

		private void RaiseControlPointModeChanged(int modeIndex)
		{
			if (this.ControlPointModeChanged != null)
			{
				int num = modeIndex * 3 - 1;
				this.ControlPointModeChanged(num);
				this.ControlPointModeChanged(num + 1);
				this.ControlPointModeChanged(num + 2);
			}
		}

		private void RaiseControlPointConnectionChanged(int index)
		{
			if (this.ControlPointConnectionChanged != null)
			{
				this.ControlPointConnectionChanged(index);
			}
		}

		private void Awake()
		{
			if (m_splineMaterial == null)
			{
				InitSplineMaterial();
			}
			if (m_branches == null)
			{
				m_branches = new SplineBase[0];
			}
			UpdateChildrenAndParent();
			SplineRuntimeEditor.Created += OnRuntimeEditorCreated;
			SplineRuntimeEditor.Destroyed += OnRuntimeEditorDestroyed;
			if (SplineRuntimeEditor.Instance != null && !GetComponent<ExposeToEditor>())
			{
				base.gameObject.AddComponent<ExposeToEditor>();
			}
			SyncArrays();
			AwakeOverride();
		}

		private void OnApplicationQuit()
		{
			m_isApplicationQuit = true;
		}

		private void OnDestroy()
		{
			SplineRuntimeEditor.Created -= OnRuntimeEditorCreated;
			SplineRuntimeEditor.Destroyed -= OnRuntimeEditorDestroyed;
			bool flag = false;
			if (!m_isApplicationQuit && !flag)
			{
				UnselectRecursive(Root);
				if (m_prevSpline != null)
				{
					m_prevSpline.Disconnect(this);
				}
				if (m_nextSpline != null)
				{
					m_nextSpline.Disconnect(this);
				}
			}
			OnDestroyOverride();
		}

		private void OnEnable()
		{
			if (m_isSelected && GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Add(this);
			}
			OnEnableOverride();
		}

		private void OnDisable()
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Remove(this);
			}
			OnDisableOverride();
		}

		private void Start()
		{
			StartOverride();
			if (PrevSpline != null && (PrevSpline.m_branches == null || !PrevSpline.m_branches.Contains(this)))
			{
				PrevSpline.Connect(this, PrevControlPointIndex, isInbound: false);
			}
			if (NextSpline != null && (NextSpline.m_branches == null || !NextSpline.m_branches.Contains(this)))
			{
				NextSpline.Connect(this, NextControlPointIndex, isInbound: true);
			}
		}

		private void OnTransformChildrenChanged()
		{
			UpdateChildrenAndParent();
		}

		private void OnTransformParentChanged()
		{
			UpdateChildrenAndParent();
		}

		private void Update()
		{
			UpdateOverride();
		}

		private void Reset()
		{
			SplineBase[] branches = m_branches;
			SplineBase nextSpline = m_nextSpline;
			SplineBase prevSpline = m_prevSpline;
			if (branches != null)
			{
				foreach (SplineBase splineBase in branches)
				{
					if (splineBase != null)
					{
						splineBase.Disconnect(this);
					}
				}
			}
			if (nextSpline != null)
			{
				nextSpline.Disconnect(this);
			}
			if (prevSpline != null)
			{
				prevSpline.Disconnect(this);
			}
			m_branches = new SplineBase[0];
			m_nextSpline = null;
			m_nextControlPointIndex = -1;
			m_prevSpline = null;
			m_prevControlPointIndex = -1;
			m_points = new Vector3[4]
			{
				new Vector3(0f, 0f, 0f),
				new Vector3(1f / 3f * GetMag(), 0f, 0f),
				new Vector3(2f / 3f * GetMag(), 0f, 0f),
				new Vector3(1f * GetMag(), 0f, 0f)
			};
			m_settings = new ControlPointSetting[2]
			{
				new ControlPointSetting(new Twist(0f, 0f, 1f), new Thickness(Vector3.one, 0f, 1f), new SplineBranch[0]),
				new ControlPointSetting(new Twist(0f, 0f, 1f), new Thickness(Vector3.one, 0f, 1f), new SplineBranch[0])
			};
			m_modes = new ControlPointMode[2];
			ResetOverride();
			SyncCtrlPoints();
		}

		protected virtual float GetMag()
		{
			return 1f;
		}

		protected virtual void AwakeOverride()
		{
		}

		protected virtual void OnDestroyOverride()
		{
		}

		protected virtual void OnEnableOverride()
		{
		}

		protected virtual void OnDisableOverride()
		{
		}

		protected virtual void StartOverride()
		{
		}

		protected virtual void UpdateOverride()
		{
		}

		protected virtual void ResetOverride()
		{
		}

		private void OnRuntimeEditorCreated(object sender, EventArgs e)
		{
			if (m_isSelected && GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Add(this);
			}
			if ((bool)this && !GetComponent<ExposeToEditor>())
			{
				base.gameObject.AddComponent<ExposeToEditor>();
			}
		}

		private void OnRuntimeEditorDestroyed(object sender, EventArgs e)
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Remove(this);
			}
			if ((bool)this)
			{
				ExposeToEditor component = GetComponent<ExposeToEditor>();
				if ((bool)component)
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
			}
		}

		private void SyncArrays()
		{
			if (m_points == null || m_points.Length == 0)
			{
				return;
			}
			int num = m_points.Length / 3 + 1;
			if (m_modes.Length != num)
			{
				UnityEngine.Debug.Log("Synchronize modes");
				Array.Resize(ref m_modes, num);
			}
			if (m_settings == null)
			{
				m_settings = new ControlPointSetting[0];
			}
			if (m_settings.Length != num)
			{
				UnityEngine.Debug.Log("Synchronize settings");
				int num2 = m_settings.Length;
				Array.Resize(ref m_settings, num);
				for (int i = num2; i < m_settings.Length; i++)
				{
					m_settings[i].Thickness = new Thickness(Vector3.one, 0f, 1f);
					m_settings[i].Twist = new Twist(0f, 0f, 1f);
				}
			}
		}

		public void Select()
		{
			if (!m_isSelected)
			{
				SelectRecursive(Root);
			}
		}

		private void SelectRecursive(SplineBase spline)
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Add(spline);
			}
			SplineControlPoint[] splineControlPoints = spline.GetSplineControlPoints();
			for (int i = 0; i < splineControlPoints.Length; i++)
			{
				splineControlPoints[i].gameObject.SetActive(value: true);
			}
			spline.m_isSelected = true;
			for (int j = 0; j < spline.m_children.Length; j++)
			{
				SelectRecursive(spline.m_children[j]);
			}
		}

		public void Unselect()
		{
			if (m_isSelected)
			{
				UnselectRecursive(Root);
			}
		}

		private void UnselectRecursive(SplineBase spline)
		{
			if (GLRenderer.Instance != null)
			{
				GLRenderer.Instance.Remove(spline);
			}
			SplineControlPoint[] splineControlPoints = spline.GetSplineControlPoints();
			foreach (SplineControlPoint splineControlPoint in splineControlPoints)
			{
				if ((bool)splineControlPoint)
				{
					splineControlPoint.gameObject.SetActive(value: false);
				}
			}
			spline.m_isSelected = false;
			for (int j = 0; j < spline.m_children.Length; j++)
			{
				UnselectRecursive(spline.m_children[j]);
			}
		}

		public Vector3 GetPoint(float t, int curveIndex)
		{
			curveIndex *= 3;
			return base.transform.TransformPoint(CurveUtils.GetPoint(m_points[curveIndex], m_points[curveIndex + 1], m_points[curveIndex + 2], m_points[curveIndex + 3], t));
		}

		public Vector3 GetPointLocal(float t, int curveIndex)
		{
			curveIndex *= 3;
			return CurveUtils.GetPoint(m_points[curveIndex], m_points[curveIndex + 1], m_points[curveIndex + 2], m_points[curveIndex + 3], t);
		}

		public int ToCurveIndex(ref float t)
		{
			int num;
			if (t >= 1f)
			{
				t = 1f;
				num = (m_points.Length - 1) / 3 - 1;
			}
			else
			{
				t = Mathf.Clamp01(t) * (float)CurveCount;
				num = (int)t;
				t -= num;
			}
			return num;
		}

		public int ToCurveIndex(float t)
		{
			int num;
			if (t >= 1f)
			{
				t = 1f;
				num = (m_points.Length - 1) / 3 - 1;
			}
			else
			{
				t = Mathf.Clamp01(t) * (float)CurveCount;
				num = (int)t;
				t -= (float)num;
			}
			return num;
		}

		public Vector3 GetPoint(float t)
		{
			int curveIndex = ToCurveIndex(ref t);
			return GetPoint(t, curveIndex);
		}

		public Vector3 GetPointLocal(float t)
		{
			int curveIndex = ToCurveIndex(ref t);
			return GetPointLocal(t, curveIndex);
		}

		public float GetTwist(float t, int curveIndex)
		{
			Twist twist = m_settings[curveIndex].Twist;
			Twist twist2 = m_settings[curveIndex + 1].Twist;
			float num = Mathf.Clamp01(twist.T1);
			float num2 = Mathf.Clamp01(twist.T2);
			t = ((t <= num) ? 0f : ((!(t >= num2)) ? Mathf.Clamp01((t - num) / (num2 - num)) : 1f));
			return Mathf.Lerp(twist.Data, twist2.Data, t);
		}

		public float GetTwist(float t)
		{
			int curveIndex = ToCurveIndex(ref t);
			return GetTwist(t, curveIndex);
		}

		public Vector3 GetThickness(float t, int curveIndex)
		{
			Thickness thickness = m_settings[curveIndex].Thickness;
			Thickness thickness2 = m_settings[curveIndex + 1].Thickness;
			float num = Mathf.Clamp01(thickness.T1);
			float num2 = Mathf.Clamp01(thickness.T2);
			t = ((t <= num) ? 0f : ((!(t >= num2)) ? Mathf.Clamp01((t - num) / (num2 - num)) : 1f));
			return Vector3.Lerp(thickness.Data, thickness2.Data, t);
		}

		public Vector3 GetThickness(float t)
		{
			int curveIndex = ToCurveIndex(ref t);
			return GetThickness(t, curveIndex);
		}

		public Vector3 GetControlPoint(int index)
		{
			return base.transform.TransformPoint(m_points[index]);
		}

		public Vector3 GetControlPointLocal(int index)
		{
			return m_points[index];
		}

		public ControlPointSetting GetSetting(int index)
		{
			return m_settings[(index + 1) / 3];
		}

		public SplineBranch[] GetBranches(int index)
		{
			return m_settings[(index + 1) / 3].Branches;
		}

		public bool HasBranches(int index)
		{
			int num = (index + 1) / 3;
			if (num >= m_settings.Length || num < 0)
			{
				return false;
			}
			ControlPointSetting controlPointSetting = m_settings[num];
			if (controlPointSetting.Branches == null)
			{
				return false;
			}
			return controlPointSetting.Branches.Length != 0;
		}

		public SplineBase BranchToSpline(SplineBranch branch)
		{
			return m_branches[branch.SplineIndex];
		}

		public Twist GetTwist(int index)
		{
			return m_settings[(index + 1) / 3].Twist;
		}

		public Thickness GetThickness(int index)
		{
			return m_settings[(index + 1) / 3].Thickness;
		}

		public void SetTwist(int index, Twist twist)
		{
			SetValue(index, twist, delegate(int i, Twist val, bool r)
			{
				int num2 = (index + 1) / 3;
				m_settings[num2].Twist = val;
			}, delegate(int i, Twist val, SplineBase branch, bool r)
			{
				branch.SetTwist(i, val);
			}, GetTwist);
			if (m_loop)
			{
				int num = (index + 1) / 3;
				if (num == m_settings.Length - 1)
				{
					ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
					m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
				}
				else if (num == 0)
				{
					ControlPointSetting controlPointSetting2 = m_settings[0];
					m_settings[m_settings.Length - 1] = new ControlPointSetting(controlPointSetting2.Twist, controlPointSetting2.Thickness, m_settings[m_settings.Length - 1].Branches);
				}
			}
			RaisControlPointTwistChanged(index);
			OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
		}

		public void SetThickness(int index, Thickness thickness)
		{
			SetValue(index, thickness, delegate(int i, Thickness val, bool r)
			{
				int num2 = (index + 1) / 3;
				m_settings[num2].Thickness = val;
			}, delegate(int i, Thickness val, SplineBase branch, bool r)
			{
				branch.SetThickness(i, val);
			}, GetThickness);
			if (m_loop)
			{
				int num = (index + 1) / 3;
				if (num == m_settings.Length - 1)
				{
					ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
					m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
				}
				else if (num == 0)
				{
					ControlPointSetting controlPointSetting2 = m_settings[0];
					m_settings[m_settings.Length - 1] = new ControlPointSetting(controlPointSetting2.Twist, controlPointSetting2.Thickness, m_settings[m_settings.Length - 1].Branches);
				}
			}
			RaiseControlPointThicknessChanged(index);
			OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
		}

		public bool SetControlPoint(int index, Vector3 point)
		{
			return SetControlPointLocal(index, base.transform.InverseTransformPoint(point));
		}

		private bool _SetControlPointUnchecked(int index, Vector3 point)
		{
			return _SetControlPointLocalUnchecked(index, base.transform.InverseTransformPoint(point));
		}

		public bool SetControlPointLocal(int index, Vector3 point)
		{
			if (IsControlPointLocked(index))
			{
				return false;
			}
			return _SetControlPointLocalUnchecked(index, point);
		}

		private bool _SetControlPointLocalUnchecked(int index, Vector3 point)
		{
			if (index % 3 == 0)
			{
				Vector3 delta = point - m_points[index];
				if (m_loop)
				{
					if (index == 0)
					{
						JustChangeControlPointValue(1, delta);
						RaiseControlPointChanged(1);
						JustChangeControlPointValue(m_points.Length - 2, delta);
						RaiseControlPointChanged(m_points.Length - 2);
						SetControlPointValue(m_points.Length - 1, point);
						RaiseControlPointChanged(m_points.Length - 1);
					}
					else if (index == m_points.Length - 1)
					{
						SetControlPointValue(0, point);
						RaiseControlPointChanged(0);
						JustChangeControlPointValue(1, delta);
						RaiseControlPointChanged(1);
						JustChangeControlPointValue(index - 1, delta);
						RaiseControlPointChanged(index - 1);
					}
					else
					{
						JustChangeControlPointValue(index - 1, delta);
						RaiseControlPointChanged(index - 1);
						JustChangeControlPointValue(index + 1, delta);
						RaiseControlPointChanged(index + 1);
					}
				}
				else
				{
					if (index > 0)
					{
						JustChangeControlPointValue(index - 1, delta);
						RaiseControlPointChanged(index - 1);
					}
					if (index + 1 < m_points.Length)
					{
						JustChangeControlPointValue(index + 1, delta);
						RaiseControlPointChanged(index + 1);
					}
				}
			}
			SetControlPointValue(index, point);
			RaiseControlPointChanged(index);
			EnforceMode(index);
			OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
			return true;
		}

		public ControlPointMode GetControlPointMode(int index)
		{
			return m_modes[(index + 1) / 3];
		}

		public void SetControlPointMode(ControlPointMode mode)
		{
			SetControlPointModeRecursive(this, mode);
		}

		private void SetControlPointModeRecursive(SplineBase spline, ControlPointMode mode)
		{
			for (int i = 0; i <= spline.CurveCount; i++)
			{
				spline.SetControlPointMode(i * 3, mode);
			}
			if (spline.Children != null)
			{
				for (int j = 0; j < spline.Children.Length; j++)
				{
					SetControlPointModeRecursive(spline.Children[j], mode);
				}
			}
		}

		public void SetControlPointMode(int index, ControlPointMode mode, bool raiseCurveChanged = true)
		{
			SetControlPointModeValue(index, mode, raiseCurveChanged);
			int num = (index + 1) / 3;
			RaiseControlPointModeChanged(num);
			if (m_loop)
			{
				if (num == 0)
				{
					SetControlPointModeValue(ControlPointCount - 1, mode, raiseCurveChanged);
					RaiseControlPointModeChanged(m_modes.Length - 1);
				}
				else if (num == m_modes.Length - 1)
				{
					SetControlPointModeValue(0, mode, raiseCurveChanged);
					RaiseControlPointModeChanged(0);
				}
			}
			EnforceMode(index);
			if (raiseCurveChanged)
			{
				OnCurveChanged(index, Math.Max(0, (index - 1) / 3));
			}
		}

		private void SetControlPointModeValue(int index, ControlPointMode mode, bool raiseCurveChanged)
		{
			int num = (index + 1) / 3;
			if (m_modes[num] != mode)
			{
				m_modes[num] = mode;
				SetBranchControlPointModes(index, mode, raiseCurveChanged);
			}
		}

		private void SetBranchControlPointModes(int index, ControlPointMode mode, bool raiseCurveChanged)
		{
			int num = (index + 1) / 3;
			SplineBranch[] branches = m_settings[num].Branches;
			if (branches != null)
			{
				for (int i = 0; i < branches.Length; i++)
				{
					SplineBranch splineBranch = branches[i];
					SplineBase splineBase = m_branches[splineBranch.SplineIndex];
					if (splineBase != null)
					{
						if (splineBranch.Inbound)
						{
							splineBase.SetControlPointMode(splineBase.ControlPointCount - 1, mode, raiseCurveChanged);
						}
						else
						{
							splineBase.SetControlPointMode(0, mode, raiseCurveChanged);
						}
					}
				}
			}
			if (num == 0 && PrevSpline != null)
			{
				PrevSpline.SetControlPointMode(PrevControlPointIndex, mode, raiseCurveChanged);
			}
			if (num == m_settings.Length - 1 && NextSpline != null)
			{
				NextSpline.SetControlPointMode(NextControlPointIndex, mode, raiseCurveChanged);
			}
		}

		public Vector3 GetVelocity(float t, int curveIndex)
		{
			int num = curveIndex * 3;
			return base.transform.TransformVector(CurveUtils.GetFirstDerivative(m_points[num], m_points[num + 1], m_points[num + 2], m_points[num + 3], t));
		}

		public Vector3 GetVelocity(float t)
		{
			int num;
			if (t >= 1f)
			{
				t = 1f;
				num = (m_points.Length - 1) / 3 - 1;
			}
			else
			{
				t = Mathf.Clamp01(t) * (float)CurveCount;
				num = (int)t;
				t -= (float)num;
			}
			return GetVelocity(t, num);
		}

		public Vector3 GetDirection(float t, int curveIndex)
		{
			return GetVelocity(t, curveIndex).normalized;
		}

		public Vector3 GetDirection(float t)
		{
			return GetVelocity(t).normalized;
		}

		public virtual SplineControlPoint[] GetSplineControlPoints()
		{
			List<SplineControlPoint> list = new List<SplineControlPoint>(base.transform.childCount);
			foreach (Transform item in base.transform)
			{
				SplineControlPoint component = item.GetComponent<SplineControlPoint>();
				if (component != null)
				{
					list.Add(component);
				}
			}
			return list.ToArray();
		}

		public void AlignWithNextSpline()
		{
			if (!(NextSpline == null))
			{
				if (m_nextControlPointIndex == 0)
				{
					NextSpline.AlignWithBeginning(m_points, (m_nextControlPointIndex - 1) / 3, GetMag());
				}
				else
				{
					NextSpline.AlignWithBeginning(m_points, (m_nextControlPointIndex - 1) / 3, GetMag(), 1f);
				}
				for (int i = 0; i < m_points.Length; i++)
				{
					m_points[i] = base.transform.InverseTransformPoint(NextSpline.transform.TransformPoint(m_points[i]));
				}
				EnforceMode(ControlPointCount - 1);
			}
		}

		public void AlignWithPrevSpline()
		{
			if (!(PrevSpline == null))
			{
				if (m_prevControlPointIndex == 0)
				{
					PrevSpline.AlignWithEnding(m_points, (m_prevControlPointIndex - 1) / 3, GetMag(), 0f);
				}
				else
				{
					PrevSpline.AlignWithEnding(m_points, (m_prevControlPointIndex - 1) / 3, GetMag());
				}
				for (int i = 0; i < m_points.Length; i++)
				{
					m_points[i] = base.transform.InverseTransformPoint(PrevSpline.transform.TransformPoint(m_points[i]));
				}
				EnforceMode(0);
			}
		}

		public bool IsControlPointLocked(int index)
		{
			if (index >= 2 && index <= ControlPointCount - 3)
			{
				return false;
			}
			if (index % 3 != 0 && GetControlPointMode(index) == ControlPointMode.Free)
			{
				return false;
			}
			if (PrevSpline != null)
			{
				if (PrevControlPointIndex == PrevSpline.ControlPointCount - 1)
				{
					SplineBranch[] branches = PrevSpline.GetBranches(PrevControlPointIndex);
					SplineBase splineBase = null;
					for (int i = 0; i < branches.Length; i++)
					{
						if (!branches[i].Inbound)
						{
							splineBase = PrevSpline.BranchToSpline(branches[i]);
						}
					}
					if (splineBase == this)
					{
						if (index < 1)
						{
							return true;
						}
						if (Loop && index > ControlPointCount - 2)
						{
							return true;
						}
					}
					else
					{
						if (index < 2)
						{
							return true;
						}
						if (Loop && index > ControlPointCount - 3)
						{
							return true;
						}
					}
				}
				else
				{
					if (index < 2)
					{
						return true;
					}
					if (Loop && index > ControlPointCount - 3)
					{
						return true;
					}
				}
			}
			if (NextSpline != null)
			{
				if (NextControlPointIndex == 0)
				{
					SplineBranch[] branches2 = NextSpline.GetBranches(NextControlPointIndex);
					SplineBase splineBase2 = null;
					for (int j = 0; j < branches2.Length; j++)
					{
						if (branches2[j].Inbound)
						{
							splineBase2 = NextSpline.BranchToSpline(branches2[j]);
						}
					}
					if (splineBase2 == this)
					{
						if (index > ControlPointCount - 2)
						{
							return true;
						}
						if (Loop && index < 1)
						{
							return true;
						}
					}
					else
					{
						if (index > ControlPointCount - 3)
						{
							return true;
						}
						if (Loop && index < 2)
						{
							return true;
						}
					}
				}
				else
				{
					if (index > ControlPointCount - 3)
					{
						return true;
					}
					if (Loop && index < 2)
					{
						return true;
					}
				}
			}
			return false;
		}

		public void SetBranch(SplineBase branch, int connectionPointIndex, bool isInbound)
		{
			if (branch == this)
			{
				throw new InvalidOperationException("branch == this");
			}
			if (branch.Loop)
			{
				throw new InvalidOperationException("Unable to connect branch. Branch has loop");
			}
			SplineBranch[] branches = GetBranches(connectionPointIndex);
			SplineBranch[] branches2 = branch.GetBranches(isInbound ? (branch.ControlPointCount - 1) : 0);
			if (branches != null && branches2 != null)
			{
				for (int i = 0; i < branches.Length; i++)
				{
					SplineBase splineBase = m_branches[branches[i].SplineIndex];
					for (int j = 0; j < branches2.Length; j++)
					{
						if (branch.m_branches[branches2[j].SplineIndex] == splineBase)
						{
							UnityEngine.Debug.LogError("Unable to connect branch. Connection will lead to illegal structure");
							return;
						}
					}
				}
			}
			connectionPointIndex = (connectionPointIndex + 1) / 3 * 3;
			Vector3 controlPoint = GetControlPoint(connectionPointIndex);
			branch.transform.SetParent(base.transform, worldPositionStays: true);
			Vector3 vector = branch.transform.InverseTransformPoint(controlPoint);
			Thickness thickness = GetThickness(connectionPointIndex);
			thickness.T1 = 0f;
			thickness.T2 = 1f;
			Twist twist = GetTwist(connectionPointIndex);
			twist.T1 = 0f;
			twist.T2 = 1f;
			if (isInbound)
			{
				branch.SetThickness(branch.ControlPointCount - 1, thickness);
				branch.SetTwist(branch.ControlPointCount - 1, twist);
				branch.SetControlPointValue(branch.ControlPointCount - 1, vector);
				branch.RaiseControlPointChanged(branch.ControlPointCount - 1);
				ControlPointMode controlPointMode = GetControlPointMode(connectionPointIndex);
				if (controlPointMode == ControlPointMode.Free || (connectionPointIndex == 0 && controlPointMode != ControlPointMode.Mirrored))
				{
					Vector3 delta = vector - branch.GetControlPointLocal(branch.ControlPointCount - 1);
					branch.ChangeControlPointValue(branch.ControlPointCount - 2, delta);
					branch.RaiseControlPointChanged(branch.ControlPointCount - 2);
				}
				else if (controlPointMode == ControlPointMode.Aligned)
				{
					branch.SetControlPointValue(branch.ControlPointCount - 2, branch.transform.InverseTransformPoint(GetControlPoint(connectionPointIndex - 1)));
					branch.RaiseControlPointChanged(branch.ControlPointCount - 2);
				}
			}
			else
			{
				branch.SetThickness(0, thickness);
				branch.SetTwist(0, twist);
				branch.SetControlPointValue(0, vector);
				branch.RaiseControlPointChanged(0);
				ControlPointMode controlPointMode2 = GetControlPointMode(connectionPointIndex);
				if (controlPointMode2 == ControlPointMode.Free || (connectionPointIndex == ControlPointCount - 1 && controlPointMode2 != ControlPointMode.Mirrored))
				{
					Vector3 delta2 = vector - branch.GetControlPointLocal(0);
					branch.ChangeControlPointValue(1, delta2);
					branch.RaiseControlPointChanged(1);
				}
				else if (controlPointMode2 == ControlPointMode.Aligned)
				{
					branch.SetControlPointValue(1, branch.transform.InverseTransformPoint(GetControlPoint(connectionPointIndex + 1)));
					branch.RaiseControlPointChanged(1);
				}
			}
			Reconnect(branch, connectionPointIndex, isInbound);
			if (isInbound)
			{
				branch.SetControlPointMode(branch.ControlPointCount - 1, GetControlPointMode(connectionPointIndex));
			}
			else
			{
				branch.SetControlPointMode(0, GetControlPointMode(connectionPointIndex));
			}
			if (m_isSelected)
			{
				branch.Select();
			}
		}

		private void Reconnect(SplineBase branch, int connectionPointIndex, bool isInbound)
		{
			if (isInbound)
			{
				if (branch.m_nextSpline != null)
				{
					branch.m_nextSpline.Disconnect(branch, isInbound);
				}
				branch.m_nextSpline = this;
				branch.m_nextControlPointIndex = connectionPointIndex;
			}
			else
			{
				if (branch.m_prevSpline != null)
				{
					branch.m_prevSpline.Disconnect(branch, isInbound);
				}
				branch.m_prevSpline = this;
				branch.m_prevControlPointIndex = connectionPointIndex;
			}
			Connect(branch, connectionPointIndex, isInbound);
			EnforceBranchModes(connectionPointIndex);
		}

		private void Connect(SplineBase branch, int connectionPointIndex, bool isInbound)
		{
			int num = Array.IndexOf(m_branches, branch);
			if (num < 0)
			{
				Array.Resize(ref m_branches, m_branches.Length + 1);
				num = m_branches.Length - 1;
				m_branches[num] = branch;
			}
			int num2 = (connectionPointIndex + 1) / 3;
			ControlPointSetting controlPointSetting = m_settings[num2];
			if (controlPointSetting.Branches == null)
			{
				controlPointSetting.Branches = new SplineBranch[1];
			}
			else
			{
				Array.Resize(ref controlPointSetting.Branches, controlPointSetting.Branches.Length + 1);
			}
			controlPointSetting.Branches[controlPointSetting.Branches.Length - 1] = new SplineBranch(num, isInbound);
			m_settings[num2] = controlPointSetting;
			RaiseControlPointConnectionChanged(connectionPointIndex);
			if (isInbound)
			{
				branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 1);
				branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 2);
			}
			else
			{
				branch.RaiseControlPointConnectionChanged(0);
				branch.RaiseControlPointConnectionChanged(1);
			}
		}

		public void Disconnect(int index)
		{
			SplineBranch[] branches = GetBranches(index);
			if (branches != null && branches.Length != 0)
			{
				for (int num = branches.Length - 1; num >= 0; num--)
				{
					SplineBranch splineBranch = branches[num];
					SplineBase branch = m_branches[splineBranch.SplineIndex];
					Disconnect(branch, splineBranch.Inbound);
				}
			}
		}

		public void Disconnect(SplineBase spline)
		{
			Disconnect(spline, isInbound: true);
			Disconnect(spline, isInbound: false);
		}

		public void Disconnect(SplineBase branch, bool isInbound)
		{
			int num = Array.IndexOf(m_branches, branch);
			if (num < 0)
			{
				return;
			}
			int num2;
			if (isInbound)
			{
				num2 = (branch.m_nextControlPointIndex + 1) / 3;
				branch.m_nextSpline = null;
				branch.m_nextControlPointIndex = -1;
			}
			else
			{
				num2 = (branch.m_prevControlPointIndex + 1) / 3;
				branch.m_prevSpline = null;
				branch.m_prevControlPointIndex = -1;
			}
			if (num2 >= m_settings.Length)
			{
				return;
			}
			ControlPointSetting controlPointSetting = m_settings[num2];
			int num3 = -1;
			for (int i = 0; i < controlPointSetting.Branches.Length; i++)
			{
				SplineBranch splineBranch = controlPointSetting.Branches[i];
				if (splineBranch.SplineIndex == num && splineBranch.Inbound == isInbound)
				{
					num3 = i;
				}
			}
			if (num3 >= 0)
			{
				for (int j = num3; j < controlPointSetting.Branches.Length - 1; j++)
				{
					controlPointSetting.Branches[j] = controlPointSetting.Branches[j + 1];
				}
				Array.Resize(ref controlPointSetting.Branches, controlPointSetting.Branches.Length - 1);
				m_settings[num2] = controlPointSetting;
			}
			if (branch.m_nextSpline == null && branch.m_prevSpline == null)
			{
				for (int k = num; k < m_branches.Length - 1; k++)
				{
					m_branches[k] = m_branches[k + 1];
				}
				Array.Resize(ref m_branches, m_branches.Length - 1);
				CleanupSplineConnections(num);
			}
			RaiseControlPointConnectionChanged(num2 * 3);
			if (isInbound)
			{
				branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 1);
				branch.RaiseControlPointConnectionChanged(branch.ControlPointCount - 2);
			}
			else
			{
				branch.RaiseControlPointConnectionChanged(0);
				branch.RaiseControlPointConnectionChanged(1);
			}
		}

		private void UpdateChildrenAndParent()
		{
			if (base.transform.parent != null)
			{
				m_parent = base.transform.parent.GetComponentInParent<SplineBase>();
			}
			else
			{
				m_parent = null;
			}
			List<SplineBase> list = new List<SplineBase>();
			foreach (Transform item in base.transform)
			{
				SplineBase component = item.GetComponent<SplineBase>();
				if (component != null)
				{
					list.Add(component);
				}
			}
			m_children = list.ToArray();
		}

		private void ShiftConnectionIndices(int settingIndex, int offset)
		{
			for (int i = 0; i < m_branches.Length; i++)
			{
				SplineBase splineBase = m_branches[i];
				if (splineBase.PrevSpline == this && splineBase.m_prevControlPointIndex >= settingIndex * 3)
				{
					splineBase.m_prevControlPointIndex += offset;
				}
				if (splineBase.NextSpline == this && splineBase.m_nextControlPointIndex >= settingIndex * 3)
				{
					splineBase.m_nextControlPointIndex += offset;
				}
			}
		}

		private void CleanupSplineConnections(int splineIndex)
		{
			for (int i = 0; i < m_settings.Length; i++)
			{
				ControlPointSetting controlPointSetting = m_settings[i];
				if (controlPointSetting.Branches == null)
				{
					continue;
				}
				for (int j = 0; j < controlPointSetting.Branches.Length; j++)
				{
					SplineBranch splineBranch = controlPointSetting.Branches[j];
					if (splineBranch.SplineIndex == splineIndex)
					{
						throw new InvalidOperationException("connection.SplineIndex == splineIndex. SplineConnection with index " + splineIndex + " should be removed");
					}
					if (splineBranch.SplineIndex > splineIndex)
					{
						splineBranch.SplineIndex--;
						controlPointSetting.Branches[j] = splineBranch;
					}
				}
				m_settings[i] = controlPointSetting;
			}
		}

		public void Smooth()
		{
			Vector3 vector = m_points[0];
			ShiftPoints(-vector);
			int num = m_points.Length / 3;
			float[] array = new float[num];
			float[] array2 = new float[num];
			float[] array3 = new float[num];
			Vector3[] array4 = new Vector3[num];
			array[0] = 0f;
			array2[0] = 2f;
			array3[0] = 1f;
			array4[0] = m_points[0] + 2f * m_points[3];
			for (int i = 1; i < num - 1; i++)
			{
				array[i] = 1f;
				array2[i] = 4f;
				array3[i] = 1f;
				array4[i] = 4f * m_points[i * 3] + 2f * m_points[(i + 1) * 3];
			}
			array[num - 1] = 2f;
			array2[num - 1] = 7f;
			array3[num - 1] = 0f;
			array4[num - 1] = 8f * m_points[(num - 1) * 3] + m_points[num * 3];
			for (int j = 1; j < num; j++)
			{
				float num2 = array[j] / array2[j - 1];
				array2[j] -= num2 * array3[j - 1];
				array4[j] -= num2 * array4[j - 1];
			}
			m_points[(num - 1) * 3 + 1] = array4[num - 1] / array2[num - 1];
			for (int num3 = num - 2; num3 >= 0; num3--)
			{
				m_points[num3 * 3 + 1] = (array4[num3] - array3[num3] * m_points[(num3 + 1) * 3 + 1]) / array2[num3];
			}
			for (int k = 0; k < num - 1; k++)
			{
				m_points[k * 3 + 2] = 2f * m_points[(k + 1) * 3] - m_points[(k + 1) * 3 + 1];
			}
			m_points[(num - 1) * 3 + 2] = 0.5f * (m_points[num * 3] + m_points[(num - 1) * 3 + 1]);
			ShiftPoints(vector);
			if (Loop)
			{
				EnforceMode(m_points.Length - 2);
			}
			SyncCtrlPoints();
			OnCurveChanged();
			if (Children != null)
			{
				for (int l = 0; l < Children.Length; l++)
				{
					Children[l].Smooth();
				}
			}
			EnforceModeRecursive();
		}

		private void EnforceModeRecursive()
		{
			EnforceMode(1);
			if (Children != null)
			{
				for (int i = 0; i < Children.Length; i++)
				{
					Children[i].EnforceModeRecursive();
				}
			}
		}

		private void ShiftPoints(Vector3 offset)
		{
			for (int i = 0; i < m_points.Length; i++)
			{
				m_points[i] += offset;
			}
		}

		public float EvalDistance(int curveIndex)
		{
			Vector3 point = GetPoint(0f, curveIndex);
			return (GetPoint(1f, curveIndex) - point).magnitude;
		}

		public float EvalDistance()
		{
			Vector3 point = GetPoint(0f);
			return (GetPoint(1f) - point).magnitude;
		}

		public float EvalCurveLength(int curveIndex, int steps = 4)
		{
			if (steps < 1)
			{
				steps = 1;
			}
			float num = 0f;
			Vector3 vector = GetPoint(0f, curveIndex);
			for (int i = 1; i <= steps; i++)
			{
				float num2 = i;
				num2 /= 3f;
				Vector3 point = GetPoint(num2, curveIndex);
				num += (point - vector).magnitude;
				vector = point;
			}
			return num;
		}

		public float EvalSplineLength(int steps = 4)
		{
			if (steps < 1)
			{
				steps = 1;
			}
			float num = 0f;
			for (int i = 0; i < CurveCount; i++)
			{
				num += EvalCurveLength(i, steps);
			}
			return num;
		}

		public virtual SplineSnapshot Save()
		{
			return new SplineSnapshot(m_points, m_settings, m_modes, m_loop);
		}

		public virtual void Load(SplineSnapshot snapshot)
		{
			LoadSpline(snapshot);
		}

		protected void LoadSpline(SplineSnapshot settings)
		{
			m_points = settings.Points;
			m_settings = settings.ControlPointSettings;
			m_modes = settings.Modes;
			m_loop = settings.Loop;
			SyncCtrlPoints();
		}

		protected void SetPoints(int curveIndex, Vector3[] points, ControlPointMode mode, bool raiseCurveChanged)
		{
			int num = curveIndex * 3;
			for (int i = 0; i < points.Length; i++)
			{
				SetControlPointValue(num, points[i]);
				RaiseControlPointChanged(num);
				SetControlPointMode(num, mode, raiseCurveChanged);
				num++;
			}
			EnforceMode(num);
			if (raiseCurveChanged)
			{
				OnCurveChanged(num, Math.Max(0, (num - 1) / 3));
			}
		}

		private void JustChangeControlPointValue(int index, Vector3 delta)
		{
			m_points[index] += delta;
		}

		private void ChangeControlPointValue(int index, Vector3 delta)
		{
			SetControlPointValue(index, m_points[index] + delta);
		}

		private void JustSetControlPointValue(int index, Vector3 point)
		{
			m_points[index] = point;
		}

		private void SetControlPointValue(int index, Vector3 point)
		{
			if (!(m_points[index] == point))
			{
				m_points[index] = point;
				SetBranchControlPoints(index, point);
			}
		}

		private void SetBranchControlPoints(int index, Vector3 point)
		{
			int num = (index + 1) / 3;
			int num2 = num * 3;
			SplineBranch[] branches = m_settings[num].Branches;
			if (branches == null)
			{
				return;
			}
			for (int i = 0; i < branches.Length; i++)
			{
				SplineBranch splineBranch = branches[i];
				SplineBase splineBase = m_branches[splineBranch.SplineIndex];
				if (!(splineBase != null))
				{
					continue;
				}
				if (splineBranch.Inbound)
				{
					if ((splineBase.m_nextControlPointIndex + 1) / 3 == num)
					{
						if (index == num2)
						{
							splineBase._SetControlPointUnchecked(splineBase.ControlPointCount - 1, base.transform.TransformPoint(point));
						}
						else if (index == num2 - 1 && GetControlPointMode(index) != 0)
						{
							splineBase._SetControlPointUnchecked(splineBase.ControlPointCount - 2, base.transform.TransformPoint(point));
						}
					}
				}
				else if ((splineBase.m_prevControlPointIndex + 1) / 3 == num)
				{
					if (index == num2)
					{
						splineBase._SetControlPointUnchecked(0, base.transform.TransformPoint(point));
					}
					else if (index == num2 + 1 && GetControlPointMode(index) != 0)
					{
						splineBase._SetControlPointUnchecked(1, base.transform.TransformPoint(point));
					}
				}
			}
		}

		private void EnforceMode(int index)
		{
			int num = (index + 1) / 3;
			ControlPointMode controlPointMode = m_modes[num];
			bool flag = num == 0 || num == m_modes.Length - 1;
			if (controlPointMode == ControlPointMode.Free || (!m_loop && flag))
			{
				if (flag)
				{
					EnforceBranchModes(index);
				}
				return;
			}
			int num2 = num * 3;
			int num3;
			int num4;
			if (index <= num2)
			{
				num3 = num2 - 1;
				if (num3 < 0)
				{
					num3 = m_points.Length - 2;
				}
				num4 = num2 + 1;
				if (num4 >= m_points.Length)
				{
					num4 = 1;
				}
			}
			else
			{
				num3 = num2 + 1;
				if (num3 >= m_points.Length)
				{
					num3 = 1;
				}
				num4 = num2 - 1;
				if (num4 < 0)
				{
					num4 = m_points.Length - 2;
				}
			}
			Vector3 vector = m_points[num2];
			Vector3 vector2 = vector - m_points[num3];
			if (controlPointMode == ControlPointMode.Aligned)
			{
				vector2 = vector2.normalized * Vector3.Distance(vector, m_points[num4]);
			}
			SetControlPointValue(num4, vector + vector2);
			RaiseControlPointChanged(num4);
			if (flag)
			{
				EnforceBranchModes(index);
				EnforceBranchModes(num4);
			}
		}

		private void EnforceBranchModes(int index)
		{
			int num = (index + 1) / 3;
			ControlPointMode controlPointMode = m_modes[num];
			if (controlPointMode == ControlPointMode.Free)
			{
				return;
			}
			ControlPointSetting controlPointSetting = m_settings[num];
			if (controlPointSetting.Branches == null)
			{
				return;
			}
			int num2 = num * 3;
			for (int i = 0; i < controlPointSetting.Branches.Length; i++)
			{
				SplineBranch splineBranch = controlPointSetting.Branches[i];
				SplineBase splineBase = m_branches[splineBranch.SplineIndex];
				int fixedIndex;
				int enforcedIndex;
				if (splineBranch.Inbound)
				{
					fixedIndex = num2 + 1;
					enforcedIndex = splineBase.ControlPointCount - 2;
				}
				else
				{
					fixedIndex = num2 - 1;
					enforcedIndex = 1;
				}
				EnforceBranchMode(controlPointMode, num2, splineBase, fixedIndex, enforcedIndex);
			}
			if (num == 0)
			{
				if (PrevSpline != null)
				{
					EnforceBranchMode(controlPointMode, num2, PrevSpline, num2 + 1, m_prevControlPointIndex - 1);
				}
				else if (NextSpline != null && Loop)
				{
					int num3 = (m_modes.Length - 1) * 3;
					EnforceBranchMode(controlPointMode, num3, NextSpline, num3 - 1, m_nextControlPointIndex + 1);
				}
			}
			else if (num == m_modes.Length - 1)
			{
				if (NextSpline != null)
				{
					EnforceBranchMode(controlPointMode, num2, NextSpline, num2 - 1, m_nextControlPointIndex + 1);
				}
				else if (PrevSpline != null && Loop)
				{
					int num4 = 0;
					EnforceBranchMode(controlPointMode, num4, PrevSpline, num4 + 1, m_prevControlPointIndex - 1);
				}
			}
		}

		private void EnforceBranchMode(ControlPointMode mode, int middleIndex, SplineBase branch, int fixedIndex, int enforcedIndex)
		{
			if (fixedIndex < 0 || fixedIndex >= m_points.Length)
			{
				fixedIndex = ((fixedIndex < 0) ? 1 : (m_points.Length - 2));
				Vector3 vector = branch.transform.InverseTransformPoint(base.transform.TransformPoint(m_points[fixedIndex]));
				if (branch.m_points[enforcedIndex] != vector)
				{
					branch._SetControlPointLocalUnchecked(enforcedIndex, vector);
				}
				return;
			}
			if (enforcedIndex < 0 || enforcedIndex >= branch.m_points.Length)
			{
				enforcedIndex = ((enforcedIndex < 0) ? 1 : (branch.m_points.Length - 2));
				Vector3 vector2 = branch.transform.InverseTransformPoint(base.transform.TransformPoint(m_points[fixedIndex]));
				if (branch.m_points[enforcedIndex] != vector2)
				{
					branch._SetControlPointLocalUnchecked(enforcedIndex, vector2);
				}
				return;
			}
			Vector3 vector3 = m_points[middleIndex];
			Vector3 vector4 = vector3 - m_points[fixedIndex];
			if (mode == ControlPointMode.Aligned)
			{
				Vector3 b = base.transform.InverseTransformPoint(branch.transform.TransformPoint(branch.m_points[enforcedIndex]));
				vector4 = vector4.normalized * Vector3.Distance(vector3, b);
			}
			Vector3 vector5 = branch.transform.InverseTransformPoint(base.transform.TransformPoint(vector3 + vector4));
			if (branch.m_points[enforcedIndex] != vector5)
			{
				branch._SetControlPointLocalUnchecked(enforcedIndex, vector5);
			}
		}

		protected void AlignCurve(int curveIndex, float length, bool toLast = true)
		{
			int num = curveIndex * 3;
			int num2 = num + 3;
			Vector3 vector = m_points[num2];
			Vector3 vector2 = m_points[num];
			Vector3 vector3 = ((!toLast) ? base.transform.InverseTransformDirection(GetDirection(0f, curveIndex)) : base.transform.InverseTransformDirection(GetDirection(1f, curveIndex)));
			if (toLast)
			{
				for (int num3 = num2 - 1; num3 >= num; num3--)
				{
					vector -= vector3 * length / 3f;
					SetControlPointValue(num3, vector);
					RaiseControlPointChanged(num3);
				}
				Vector3 vector4 = vector2 - m_points[num];
				for (int num4 = num - 1; num4 >= 0; num4--)
				{
					ChangeControlPointValue(num4, -vector4);
					RaiseControlPointChanged(num4);
				}
			}
			else
			{
				for (int i = num + 1; i <= num2; i++)
				{
					vector2 += vector3 * length / 3f;
					SetControlPointValue(i, vector2);
					RaiseControlPointChanged(i);
				}
				Vector3 vector5 = vector - m_points[num2];
				for (int j = num2 + 1; j < m_points.Length; j++)
				{
					ChangeControlPointValue(j, -vector5);
					RaiseControlPointChanged(j);
				}
			}
			EnforceMode(num - 1);
			EnforceMode(num2 + 1);
		}

		protected bool RemoveCurve(int curveIndex)
		{
			if (m_points.Length <= 4)
			{
				return false;
			}
			if (curveIndex >= CurveCount || curveIndex < 0)
			{
				throw new ArgumentOutOfRangeException("curveIndex");
			}
			if (curveIndex == 0)
			{
				if (m_prevSpline != null)
				{
					m_prevSpline.Disconnect(this, isInbound: false);
				}
			}
			else if (curveIndex == CurveCount - 1 && m_nextSpline != null)
			{
				m_nextSpline.Disconnect(this, isInbound: true);
			}
			int num = curveIndex * 3;
			bool flag = true;
			if (curveIndex == CurveCount - 1)
			{
				flag = false;
				num += 3;
			}
			for (int i = num; i < m_points.Length - 3; i++)
			{
				JustSetControlPointValue(i, m_points[i + 3]);
			}
			if (curveIndex == 0)
			{
				Disconnect(0);
				ShiftConnectionIndices(0, -3);
			}
			if (curveIndex == CurveCount - 1)
			{
				int num2 = curveIndex + 1;
				Disconnect(num2 * 3);
			}
			else
			{
				Disconnect(curveIndex * 3);
				ShiftConnectionIndices(curveIndex * 3, -3);
			}
			for (int j = (num + 1) / 3; j < m_modes.Length - 1; j++)
			{
				m_settings[j] = m_settings[j + 1];
				m_modes[j] = m_modes[j + 1];
				RaiseControlPointModeChanged(j);
			}
			Array.Resize(ref m_points, m_points.Length - 3);
			Array.Resize(ref m_settings, m_settings.Length - 1);
			Array.Resize(ref m_modes, m_modes.Length - 1);
			if (flag)
			{
				EnforceMode(num + 1);
			}
			if (m_loop)
			{
				SetControlPointValue(m_points.Length - 1, m_points[0]);
				ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
				m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
				m_modes[m_modes.Length - 1] = m_modes[0];
				RaiseControlPointModeChanged(m_modes.Length - 1);
				EnforceMode(1);
			}
			SyncCtrlPoints();
			return true;
		}

		protected void Subdivide(int firstCurveIndex, int lastCurveIndex, int curveCount)
		{
			int num = firstCurveIndex * 3;
			int num2 = lastCurveIndex * 3 + 3;
			int num3 = m_points.Length;
			int num4 = num2 - num - 1;
			int num5 = curveCount * 3 - 1;
			int num6 = num5 - num4;
			Vector3[] array = new Vector3[num5];
			Vector3 a = m_points[num];
			Vector3 b = m_points[num2];
			ControlPointSetting controlPointSetting = m_settings[(num + 1) / 3];
			ControlPointSetting controlPointSetting2 = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness);
			ControlPointMode controlPointMode = m_modes[(num + 1) / 3];
			float num7 = 1f / (float)(num5 + 1);
			float num8 = 0f;
			for (int i = 0; i < num5; i++)
			{
				num8 += num7;
				array[i] = Vector3.Lerp(a, b, num8);
			}
			if (num6 > 0)
			{
				Array.Resize(ref m_points, m_points.Length + num6);
				Array.Resize(ref m_settings, m_settings.Length + num6 / 3);
				Array.Resize(ref m_modes, m_modes.Length + num6 / 3);
				for (int num9 = num3 - 1; num9 >= num2; num9--)
				{
					SetControlPointValue(num9 + num6, m_points[num9]);
				}
				for (int num10 = num3 / 3; num10 >= (num2 + 1) / 3; num10--)
				{
					m_settings[num10 + num6 / 3] = m_settings[num10];
					m_modes[num10 + num6 / 3] = m_modes[num10];
					RaiseControlPointModeChanged(num10 + num6 / 3);
				}
			}
			else if (num6 < 0)
			{
				for (int j = num2; j < num3; j++)
				{
					SetControlPointValue(j + num6, m_points[j]);
				}
				for (int k = (num2 + 1) / 3; k < (num3 + 1) / 3; k++)
				{
					m_settings[k + num6 / 3] = m_settings[k];
					m_modes[k + num6 / 3] = m_modes[k];
					RaiseControlPointModeChanged(k + num6 / 3);
				}
				Array.Resize(ref m_points, m_points.Length + num6);
				Array.Resize(ref m_settings, m_settings.Length + num6 / 3);
				Array.Resize(ref m_modes, m_modes.Length + num6 / 3);
			}
			for (int l = 0; l < num5; l++)
			{
				SetControlPointValue(num + l + 1, array[l]);
			}
			for (int m = 0; m < num5 / 3; m++)
			{
				m_settings[(num + 1) / 3 + m + 1] = controlPointSetting2;
				m_modes[(num + 1) / 3 + m + 1] = controlPointMode;
				RaiseControlPointModeChanged((num + 1) / 3 + m + 1);
			}
			int num11 = num - 1;
			int num12 = num + num5 + 2;
			if (m_loop)
			{
				if (num11 == -1)
				{
					num11 = m_points.Length - 1;
				}
				if (num12 == m_points.Length)
				{
					num12 = 0;
				}
			}
			if (num12 < m_points.Length)
			{
				EnforceMode(num12);
			}
			if (num11 >= 0)
			{
				EnforceMode(num11);
			}
			SyncCtrlPoints();
		}

		private void InsertCurve(Vector3[] points, ControlPointSetting setting, ControlPointMode mode, int curveIndex, float length, bool enforceNeighbour, bool shrinkPreceding)
		{
			if (curveIndex == 0 && shrinkPreceding)
			{
				curveIndex = ((!Loop) ? 1 : CurveCount);
			}
			int num = curveIndex * 3;
			int num2 = curveIndex - 1;
			int num3 = num2 * 3;
			Array.Resize(ref m_points, m_points.Length + points.Length);
			Array.Resize(ref m_settings, m_settings.Length + points.Length / 3);
			Array.Resize(ref m_modes, m_modes.Length + points.Length / 3);
			int num4 = (num + 1) / 3;
			ShiftConnectionIndices(num4, points.Length);
			for (int num5 = m_modes.Length - 1; num5 >= num4 + points.Length / 3; num5--)
			{
				m_settings[num5] = m_settings[num5 - points.Length / 3];
				m_modes[num5] = m_modes[num5 - points.Length / 3];
			}
			for (int num6 = m_points.Length - 1; num6 >= num + points.Length; num6--)
			{
				JustSetControlPointValue(num6, m_points[num6 - points.Length]);
			}
			if (shrinkPreceding)
			{
				float num7 = points.Length + 3;
				for (int num8 = points.Length - 1; num8 >= 0; num8--)
				{
					points[num8] = GetPointLocal((float)(num8 + 4) / num7, num2);
				}
				Vector3[] array = new Vector3[3];
				for (int num9 = 2; num9 >= 0; num9--)
				{
					array[num9] = GetPointLocal((float)(num9 + 1) / num7, num2);
				}
				for (int num10 = num; num10 >= num - 2; num10--)
				{
					SetControlPointValue(num10, array[2 + num10 - num]);
				}
			}
			for (int num11 = m_modes.Length - 1; num11 >= num4 + points.Length / 3; num11--)
			{
				RaiseControlPointModeChanged(num11);
			}
			for (int i = num4; i < num4 + points.Length / 3; i++)
			{
				m_settings[i] = setting;
				m_modes[i] = mode;
			}
			if (shrinkPreceding)
			{
				for (int j = num; j < num + points.Length; j++)
				{
					SetControlPointValue(j + 1, points[j - num]);
				}
			}
			else
			{
				for (int k = num; k < num + points.Length; k++)
				{
					SetControlPointValue(k, points[k - num]);
				}
				Vector3 vector = base.transform.InverseTransformDirection(GetDirection(0f, curveIndex));
				for (int num12 = num - 1; num12 >= 0; num12--)
				{
					ChangeControlPointValue(num12, -vector * length);
				}
			}
			for (int l = num4; l < num4 + points.Length / 3; l++)
			{
				RaiseControlPointModeChanged(l);
			}
			if (shrinkPreceding)
			{
				EnforceMode(num + points.Length + 1);
				EnforceMode(num - 1);
				EnforceMode(num3 - 1);
			}
			else if (enforceNeighbour)
			{
				EnforceMode(num + points.Length + 1);
			}
			else
			{
				EnforceMode(num + points.Length - 1);
			}
			if (m_loop)
			{
				ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
				m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
				m_modes[m_modes.Length - 1] = m_modes[0];
				SetControlPointValue(m_points.Length - 1, m_points[0]);
				RaiseControlPointModeChanged(m_modes.Length - 1);
				EnforceMode(1);
			}
			SyncCtrlPoints();
		}

		protected void PrependCurve(Vector3[] points, int curveIndex, float length, bool enforceNeighbour, bool shrinkPreceding)
		{
			if (m_prevSpline != null && curveIndex == 0)
			{
				throw new InvalidOperationException("Can't prepend curve to the connected end of the spline. Previous spline " + m_prevSpline.name);
			}
			ControlPointSetting setting = GetSetting(curveIndex * 3);
			setting.Branches = new SplineBranch[0];
			InsertCurve(points, setting, GetControlPointMode(curveIndex * 3), curveIndex, length, enforceNeighbour, shrinkPreceding);
		}

		protected void AppendCurve(Vector3[] points, bool enforceNeighbour)
		{
			ControlPointSetting setting = GetSetting(m_points.Length - 1);
			AppendCurve(points, new ControlPointSetting(setting.Twist, setting.Thickness), GetControlPointMode(m_points.Length - 1), enforceNeighbour);
		}

		private void AppendCurve(Vector3[] points, ControlPointSetting setting, ControlPointMode mode, bool enforceNeighbour)
		{
			if (m_nextSpline != null)
			{
				throw new InvalidOperationException("Can't append curve to the connected end of the spline. Next spline " + m_nextSpline.name);
			}
			Array.Resize(ref m_points, m_points.Length + points.Length);
			Array.Resize(ref m_settings, m_settings.Length + points.Length / 3);
			Array.Resize(ref m_modes, m_modes.Length + points.Length / 3);
			for (int i = 0; i < points.Length / 3; i++)
			{
				m_settings[m_settings.Length - points.Length / 3 + i] = setting;
				m_modes[m_modes.Length - points.Length / 3 + i] = mode;
			}
			for (int j = 0; j < points.Length; j++)
			{
				SetControlPointValue(m_points.Length - points.Length + j, points[j]);
			}
			for (int k = 0; k < points.Length / 3; k++)
			{
				RaiseControlPointModeChanged(m_modes.Length - points.Length / 3 + k);
			}
			if (enforceNeighbour)
			{
				EnforceMode(m_points.Length - points.Length - 2);
			}
			else
			{
				EnforceMode(m_points.Length - points.Length);
			}
			if (m_loop)
			{
				ControlPointSetting controlPointSetting = m_settings[m_settings.Length - 1];
				m_settings[0] = new ControlPointSetting(controlPointSetting.Twist, controlPointSetting.Thickness, m_settings[0].Branches);
				m_modes[0] = m_modes[m_modes.Length - 1];
				SetControlPointValue(0, m_points[m_points.Length - 1]);
				RaiseControlPointModeChanged(0);
				EnforceMode(m_points.Length - 1);
			}
			SyncCtrlPoints();
		}

		protected void AlignWithEnding(Vector3[] points, int curveIndex, float mag, float offset = 1f)
		{
			if (points.Length != 0)
			{
				Vector3 vector = base.transform.InverseTransformDirection(GetDirection(offset, curveIndex));
				Vector3 pointLocal = GetPointLocal(offset, curveIndex);
				float num = 1f / 3f;
				float num2 = num;
				if (points.Length % 2 == 0)
				{
					num2 = 0f;
				}
				for (int i = 0; i < points.Length; i++)
				{
					points[i] = pointLocal + vector * mag * num2;
					num2 += num;
				}
			}
		}

		protected void AlignWithBeginning(Vector3[] points, int curveIndex, float mag, float offset = 0f)
		{
			if (points.Length != 0)
			{
				Vector3 direction = GetDirection(offset, curveIndex);
				Vector3 pointLocal = GetPointLocal(offset, curveIndex);
				direction = base.transform.InverseTransformDirection(direction);
				float num = 1f / 3f;
				float num2 = 1f;
				for (int i = 0; i < points.Length; i++)
				{
					points[i] = pointLocal - direction * mag * num2;
					num2 -= num;
				}
			}
		}

		protected virtual void OnCurveChanged(int pointIndex, int curveIndex)
		{
		}

		protected virtual void OnCurveChanged()
		{
		}

		protected virtual void AddControlPointComponent(GameObject ctrlPoint)
		{
			ctrlPoint.AddComponent<SplineControlPoint>();
		}

		private void SyncCtrlPoints(bool silent = false)
		{
			SplineRuntimeEditor instance = SplineRuntimeEditor.Instance;
			SplineControlPoint[] splineControlPoints = GetSplineControlPoints();
			int num = ControlPointCount - splineControlPoints.Length;
			if (num > 0)
			{
				for (int i = 0; i < num; i++)
				{
					GameObject gameObject = new GameObject();
					gameObject.SetActive(m_isSelected);
					gameObject.transform.parent = base.transform;
					gameObject.transform.rotation = Quaternion.identity;
					gameObject.transform.localScale = Vector3.one;
					if (instance != null)
					{
						MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
						gameObject.AddComponent<MeshFilter>().sharedMesh = instance.ControlPointMesh;
						meshRenderer.sharedMaterial = instance.NormalMaterial;
						meshRenderer.enabled = true;
					}
					gameObject.name = "ctrl point";
					AddControlPointComponent(gameObject);
				}
				splineControlPoints = GetSplineControlPoints();
			}
			else if (num < 0)
			{
				num = -num;
				for (int j = 0; j < num; j++)
				{
					SplineControlPoint splineControlPoint = splineControlPoints[j];
					if (splineControlPoint.gameObject != null)
					{
						UnityEngine.Object.DestroyImmediate(splineControlPoint.gameObject);
					}
				}
				splineControlPoints = GetSplineControlPoints();
			}
			for (int k = 0; k < ControlPointCount; k++)
			{
				splineControlPoints[k].Index = k;
				RaiseControlPointChanged(k);
				RaiseControlPointModeChanged(k);
			}
		}

		private void SetValue<T>(int controlPointIndex, T value, Action<int, T, bool> setter, Action<int, T, SplineBase, bool> branchSetter, Func<int, T> getter, bool raiseCurveChanged = true)
		{
			if (!getter(controlPointIndex).Equals(value))
			{
				setter(controlPointIndex, value, raiseCurveChanged);
				SetBranchValues(controlPointIndex, value, branchSetter, raiseCurveChanged);
			}
		}

		private void SetBranchValues<T>(int controlPointIndex, T value, Action<int, T, SplineBase, bool> branchSetter, bool raiseCurveChanged)
		{
			int num = (controlPointIndex + 1) / 3;
			SplineBranch[] branches = m_settings[num].Branches;
			if (branches != null)
			{
				for (int i = 0; i < branches.Length; i++)
				{
					SplineBranch splineBranch = branches[i];
					SplineBase splineBase = m_branches[splineBranch.SplineIndex];
					if (splineBase != null)
					{
						if (splineBranch.Inbound)
						{
							branchSetter(splineBase.ControlPointCount - 1, value, splineBase, raiseCurveChanged);
						}
						else
						{
							branchSetter(0, value, splineBase, raiseCurveChanged);
						}
					}
				}
			}
			if (num == 0 && PrevSpline != null)
			{
				branchSetter(PrevControlPointIndex, value, PrevSpline, raiseCurveChanged);
			}
			if (num == m_settings.Length - 1 && NextSpline != null)
			{
				branchSetter(NextControlPointIndex, value, NextSpline, raiseCurveChanged);
			}
		}
	}
	[ExecuteInEditMode]
	public class SplineControlPoint : MonoBehaviour
	{
		private MeshRenderer m_renderer;

		private SplineBase m_spline;

		private Vector3 m_localPosition;

		private Quaternion m_rotation;

		private bool m_updateAngle = true;

		[SerializeField]
		[HideInInspector]
		private int m_index;

		public int Index
		{
			get
			{
				return m_index;
			}
			set
			{
				m_index = value;
				UpdateMaterial();
			}
		}

		private void OnEnable()
		{
			m_spline = GetComponentInParent<SplineBase>();
			if (!(m_spline == null))
			{
				m_spline.ControlPointTwistChanged -= OnControlPointTwistChanged;
				m_spline.ControlPointTwistChanged += OnControlPointTwistChanged;
				m_spline.ControlPointThicknessChanged -= OnControlPointThicknessChanged;
				m_spline.ControlPointThicknessChanged += OnControlPointThicknessChanged;
				m_spline.ControlPointModeChanged -= OnControlPointModeChanged;
				m_spline.ControlPointModeChanged += OnControlPointModeChanged;
				m_spline.ControlPointPositionChanged -= OnControlPointPositionChanged;
				m_spline.ControlPointPositionChanged += OnControlPointPositionChanged;
				m_spline.ControlPointConnectionChanged -= OnControlPointConnectionChanged;
				m_spline.ControlPointConnectionChanged += OnControlPointConnectionChanged;
				UpdateRenderersState();
			}
		}

		private void Start()
		{
			SplineRuntimeEditor.Created += OnRuntimeEditorCreated;
			SplineBase.ConvergingSplineChanged += OnIsConvergingChanged;
			CreateRuntimeComponents();
			if (m_spline == null)
			{
				m_spline = GetComponentInParent<SplineBase>();
				if (m_spline == null)
				{
					UnityEngine.Debug.LogError("Is not a child of gameobject with Spline or MeshDeformer component");
					return;
				}
				m_spline.ControlPointTwistChanged -= OnControlPointTwistChanged;
				m_spline.ControlPointTwistChanged += OnControlPointTwistChanged;
				m_spline.ControlPointThicknessChanged -= OnControlPointThicknessChanged;
				m_spline.ControlPointThicknessChanged += OnControlPointThicknessChanged;
				m_spline.ControlPointModeChanged -= OnControlPointModeChanged;
				m_spline.ControlPointModeChanged += OnControlPointModeChanged;
				m_spline.ControlPointPositionChanged -= OnControlPointPositionChanged;
				m_spline.ControlPointPositionChanged += OnControlPointPositionChanged;
				m_spline.ControlPointConnectionChanged -= OnControlPointConnectionChanged;
				m_spline.ControlPointConnectionChanged += OnControlPointConnectionChanged;
			}
			m_localPosition = m_spline.GetControlPointLocal(m_index);
			base.transform.localPosition = m_localPosition;
			UpdateRenderersState();
			UpdateAngle(forceUpdateAngle: true);
			m_rotation = base.transform.rotation;
			Thickness thickness = m_spline.GetThickness(m_index);
			base.transform.localScale = thickness.Data;
			if (!m_spline.IsSelected)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		protected void OnDestroy()
		{
			if (m_spline != null)
			{
				m_spline.ControlPointTwistChanged -= OnControlPointTwistChanged;
				m_spline.ControlPointThicknessChanged -= OnControlPointThicknessChanged;
				m_spline.ControlPointModeChanged -= OnControlPointModeChanged;
				m_spline.ControlPointPositionChanged -= OnControlPointPositionChanged;
				m_spline.ControlPointConnectionChanged -= OnControlPointConnectionChanged;
			}
			SplineBase.ConvergingSplineChanged -= OnIsConvergingChanged;
			SplineRuntimeEditor.Created -= OnRuntimeEditorCreated;
		}

		private void Update()
		{
			if (m_spline == null)
			{
				return;
			}
			if (base.transform.localPosition != m_localPosition)
			{
				if (m_spline.SetControlPointLocal(m_index, base.transform.localPosition))
				{
					m_localPosition = base.transform.localPosition;
				}
				else
				{
					base.transform.localPosition = m_localPosition;
				}
			}
			if (base.transform.rotation != m_rotation)
			{
				if (m_index % 3 == 0)
				{
					Vector3 vector = Vector3.back;
					int num = m_index - 1;
					if (num < 0)
					{
						num = m_index + 1;
						vector = Vector3.forward;
					}
					Vector3 controlPoint = m_spline.GetControlPoint(num);
					Vector3 controlPoint2 = m_spline.GetControlPoint(m_index);
					Vector3 vector2 = (base.transform.rotation * vector).normalized * (controlPoint2 - controlPoint).magnitude;
					Twist twist = m_spline.GetTwist(m_index);
					m_rotation = base.transform.rotation;
					twist.Data = base.transform.eulerAngles.z;
					m_updateAngle = false;
					m_spline.SetTwist(m_index, twist);
					m_spline.SetControlPoint(num, controlPoint2 + vector2);
					m_updateAngle = true;
				}
				else
				{
					base.transform.rotation = m_rotation;
				}
			}
			Thickness thickness = m_spline.GetThickness(m_index);
			Vector3 vector3 = thickness.Data;
			if (base.transform.localScale != vector3)
			{
				thickness.Data = base.transform.localScale;
				m_spline.SetThickness(m_index, thickness);
			}
		}

		private void OnControlPointThicknessChanged(int pointIndex)
		{
			if ((m_index + 1) / 3 == (pointIndex + 1) / 3)
			{
				base.transform.localScale = m_spline.GetThickness(pointIndex).Data;
			}
		}

		private void OnControlPointTwistChanged(int pointIndex)
		{
			if (m_updateAngle && (m_index + 1) % 3 == (pointIndex + 1) % 3)
			{
				UpdateAngle();
			}
		}

		private void OnRuntimeEditorCreated(object sender, EventArgs e)
		{
			CreateRuntimeComponents();
		}

		private void OnIsConvergingChanged(object sender, EventArgs e)
		{
			if (m_spline.IsSelected)
			{
				UpdateRenderersState();
			}
		}

		private void OnControlPointModeChanged(int pointIndex)
		{
			if (pointIndex == m_index)
			{
				UpdateRenderersState();
			}
		}

		private void OnControlPointPositionChanged(int pointIndex)
		{
			if (!(m_spline == null) && m_updateAngle)
			{
				if (pointIndex == m_index)
				{
					m_localPosition = m_spline.GetControlPointLocal(pointIndex);
					base.transform.localPosition = m_localPosition;
					UpdateAngle();
				}
				else if (pointIndex == m_index - 1 || pointIndex == m_index + 1)
				{
					UpdateAngle();
				}
			}
		}

		private void OnControlPointConnectionChanged(int pointIndex)
		{
			if (pointIndex == m_index)
			{
				UpdateRenderersState();
			}
		}

		public void UpdateAngle(bool forceUpdateAngle = false)
		{
			if (m_spline == null)
			{
				return;
			}
			Twist twist = m_spline.GetTwist(m_index);
			int num = m_index % 3;
			if (num == 0)
			{
				int num2 = m_index - 1;
				if (num2 > 0)
				{
					Vector3 controlPoint = m_spline.GetControlPoint(num2);
					Vector3 controlPoint2 = m_spline.GetControlPoint(m_index);
					m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint2 - controlPoint) * Quaternion.LookRotation(controlPoint2 - controlPoint);
					base.transform.rotation = m_rotation;
				}
				else
				{
					int index = m_index + 1;
					Vector3 controlPoint3 = m_spline.GetControlPoint(m_index);
					Vector3 controlPoint4 = m_spline.GetControlPoint(index);
					m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint4 - controlPoint3) * Quaternion.LookRotation(controlPoint4 - controlPoint3);
					base.transform.rotation = m_rotation;
				}
			}
			else if (true || forceUpdateAngle)
			{
				if (num == 1)
				{
					int index2 = m_index - 1;
					Vector3 controlPoint5 = m_spline.GetControlPoint(index2);
					Vector3 controlPoint6 = m_spline.GetControlPoint(m_index);
					m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint6 - controlPoint5) * Quaternion.LookRotation(controlPoint6 - controlPoint5);
					base.transform.rotation = m_rotation;
				}
				else
				{
					int index3 = m_index + 1;
					Vector3 controlPoint7 = m_spline.GetControlPoint(m_index);
					Vector3 controlPoint8 = m_spline.GetControlPoint(index3);
					m_rotation = Quaternion.AngleAxis(twist.Data, controlPoint8 - controlPoint7) * Quaternion.LookRotation(controlPoint8 - controlPoint7);
					base.transform.rotation = m_rotation;
				}
			}
		}

		private void UpdateRenderersState()
		{
			if (m_index == 0 || m_index == 1)
			{
				if (m_spline.PrevSpline != null)
				{
					if (m_renderer != null)
					{
						m_renderer.enabled = !m_spline.IsControlPointLocked(m_index);
					}
				}
				else if (m_renderer != null && !m_renderer.enabled)
				{
					m_renderer.enabled = true;
				}
			}
			else if (m_index == m_spline.ControlPointCount - 1 || m_index == m_spline.ControlPointCount - 2)
			{
				if (m_spline.NextSpline != null)
				{
					if (m_renderer != null)
					{
						m_renderer.enabled = !m_spline.IsControlPointLocked(m_index);
					}
				}
				else if (m_renderer != null && !m_renderer.enabled)
				{
					m_renderer.enabled = true;
				}
			}
			else if (m_renderer != null && !m_renderer.enabled)
			{
				m_renderer.enabled = true;
			}
			if ((bool)SplineBase.ConvergingSpline)
			{
				if (m_spline.Loop && (m_index == 0 || m_index == m_spline.ControlPointCount - 1) && m_renderer != null)
				{
					m_renderer.enabled = false;
				}
				if ((m_index % 3 != 0 || m_spline == SplineBase.ConvergingSpline) && m_renderer != null)
				{
					m_renderer.enabled = false;
				}
			}
			UpdateMaterial();
		}

		private void UpdateMaterial()
		{
			if (!(m_renderer != null))
			{
				return;
			}
			SplineRuntimeEditor instance = SplineRuntimeEditor.Instance;
			if (!(instance != null))
			{
				return;
			}
			if (m_index % 3 == 0)
			{
				if (m_spline.HasBranches(m_index))
				{
					m_renderer.sharedMaterial = instance.ConnectedMaterial;
				}
				else
				{
					m_renderer.sharedMaterial = instance.NormalMaterial;
				}
			}
			else if (m_index < m_spline.ControlPointCount)
			{
				switch (m_spline.GetControlPointMode(m_index))
				{
				case ControlPointMode.Mirrored:
					m_renderer.sharedMaterial = instance.MirroredModeMaterial;
					break;
				case ControlPointMode.Aligned:
					m_renderer.sharedMaterial = instance.AlignedModeMaterial;
					break;
				default:
					m_renderer.sharedMaterial = instance.FreeModeMaterial;
					break;
				}
			}
		}

		private void CreateRuntimeComponents()
		{
			SplineRuntimeEditor instance = SplineRuntimeEditor.Instance;
			if (instance != null)
			{
				m_renderer = GetComponent<MeshRenderer>();
				if (!m_renderer)
				{
					m_renderer = base.gameObject.AddComponent<MeshRenderer>();
				}
				MeshFilter meshFilter = GetComponent<MeshFilter>();
				if (!meshFilter)
				{
					meshFilter = base.gameObject.AddComponent<MeshFilter>();
				}
				if (!meshFilter.sharedMesh)
				{
					meshFilter.sharedMesh = instance.ControlPointMesh;
					UpdateMaterial();
				}
				if (!base.gameObject.GetComponent<ExposeToEditor>())
				{
					base.gameObject.AddComponent<ExposeToEditor>();
				}
			}
		}

		public void DestroyRuntimeComponents()
		{
			MeshRenderer component = GetComponent<MeshRenderer>();
			if ((bool)component)
			{
				UnityEngine.Object.DestroyImmediate(component);
			}
			MeshFilter component2 = GetComponent<MeshFilter>();
			if ((bool)component2)
			{
				UnityEngine.Object.DestroyImmediate(component2);
			}
			ExposeToEditor component3 = base.gameObject.GetComponent<ExposeToEditor>();
			if ((bool)component3)
			{
				UnityEngine.Object.DestroyImmediate(component3);
			}
		}
	}
	public class SplineRuntimeCmd : MonoBehaviour
	{
		[Serializable]
		public class SplineSnapshots
		{
			public SplineSnapshot[] Data;

			public SplineSnapshots()
			{
				Data = new SplineSnapshot[0];
			}
		}

		public Spline m_spline;

		public SplineControlPoint m_controlPoint;

		private Spline GetSelectedSpline()
		{
			if (RuntimeSelection.activeGameObject == null)
			{
				return null;
			}
			return RuntimeSelection.activeGameObject.GetComponentInParent<Spline>();
		}

		private SplineControlPoint GetSelectedControlPoint()
		{
			if (RuntimeSelection.activeGameObject == null)
			{
				return null;
			}
			return RuntimeSelection.activeGameObject.GetComponentInParent<SplineControlPoint>();
		}

		public void Awake()
		{
			m_spline = GetSelectedSpline();
			RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
		}

		public void OnDestroy()
		{
			SplineBase.ConvergingSpline = null;
			RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
		}

		private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselectedObjects)
		{
			if ((bool)SplineBase.ConvergingSpline)
			{
				SplineControlPoint selectedControlPoint = GetSelectedControlPoint();
				Spline selectedSpline = GetSelectedSpline();
				if (selectedControlPoint == null || m_controlPoint == null || m_spline == null)
				{
					SplineBase.ConvergingSpline = null;
				}
				else if (Converge(selectedSpline, m_spline, selectedControlPoint.Index, m_controlPoint.Index))
				{
					SplineBase.ConvergingSpline = null;
					m_spline = selectedSpline;
					m_controlPoint = selectedControlPoint;
				}
				else
				{
					SplineBase.ConvergingSpline = null;
				}
			}
			else
			{
				m_controlPoint = GetSelectedControlPoint();
				m_spline = GetSelectedSpline();
			}
		}

		public void RunAction<T>(Action<T, GameObject> action)
		{
			GameObject[] gameObjects = RuntimeSelection.gameObjects;
			if (gameObjects == null)
			{
				return;
			}
			foreach (GameObject gameObject in gameObjects)
			{
				if (!(gameObject == null))
				{
					T componentInParent = gameObject.GetComponentInParent<T>();
					if (componentInParent != null)
					{
						action?.Invoke(componentInParent, gameObject);
					}
				}
			}
		}

		public virtual void Append()
		{
			RunAction(delegate(Spline spline, GameObject go)
			{
				if (spline.NextSpline == null)
				{
					spline.Append();
				}
			});
		}

		public virtual void Insert()
		{
			RunAction(delegate(Spline spline, GameObject go)
			{
				if (go != null)
				{
					SplineControlPoint component = go.GetComponent<SplineControlPoint>();
					if (component != null)
					{
						spline.Insert((component.Index + 2) / 3);
					}
				}
			});
		}

		public virtual void Prepend()
		{
			RunAction(delegate(Spline spline, GameObject go)
			{
				if (spline.PrevSpline == null)
				{
					spline.Prepend();
				}
			});
		}

		public virtual void Remove()
		{
			RunAction(delegate(Spline spline, GameObject go)
			{
				if (go != null)
				{
					SplineControlPoint component = go.GetComponent<SplineControlPoint>();
					if (component != null)
					{
						int curveIndex = Mathf.Min((component.Index + 1) / 3, spline.CurveCount - 1);
						spline.Remove(curveIndex);
					}
					RuntimeSelection.activeObject = spline.gameObject;
				}
			});
		}

		public virtual void Smooth()
		{
			RunAction(delegate(SplineBase spline, GameObject go)
			{
				spline.Root.Smooth();
			});
		}

		public virtual void SetMirroredMode()
		{
			RunAction(delegate(SplineBase spline, GameObject go)
			{
				spline.Root.SetControlPointMode(ControlPointMode.Mirrored);
			});
		}

		public virtual void SetAlignedMode()
		{
			RunAction(delegate(SplineBase spline, GameObject go)
			{
				spline.Root.SetControlPointMode(ControlPointMode.Aligned);
			});
		}

		public virtual void SetFreeMode()
		{
			RunAction(delegate(SplineBase spline, GameObject go)
			{
				spline.Root.SetControlPointMode(ControlPointMode.Free);
			});
		}

		public virtual void OutBranch()
		{
			throw new NotImplementedException("Implement after Save/Load enchancements");
		}

		public virtual void BranchIn()
		{
			throw new NotImplementedException("Implement after Save/Load enchancements");
		}

		public virtual void Converge()
		{
			SplineBase.ConvergingSpline = m_spline;
		}

		public virtual void Separate()
		{
			if (m_spline != null && m_controlPoint != null)
			{
				Separate(m_spline, m_controlPoint.Index);
			}
		}

		public static bool Converge(SplineBase spline, SplineBase branch, int splineIndex, int branchIndex)
		{
			if (spline == branch)
			{
				return false;
			}
			if (branch.PrevSpline != null && branch.NextSpline != null)
			{
				return false;
			}
			if (branchIndex == 0)
			{
				if (branch.PrevSpline != null)
				{
					return false;
				}
				spline.SetBranch(branch, splineIndex, isInbound: false);
				return true;
			}
			if (branchIndex == branch.ControlPointCount - 1)
			{
				if (branch.NextSpline != null)
				{
					return false;
				}
				spline.SetBranch(branch, splineIndex, isInbound: true);
				return true;
			}
			UnityEngine.Debug.LogError("branchIndex should be equal to 0 or branch.ControlPointCount - 1");
			return false;
		}

		public static void Separate(SplineBase spline, int controlPointIndex)
		{
			spline.Unselect();
			spline.Disconnect(controlPointIndex);
			spline.Select();
		}

		public virtual void Load()
		{
			string @string = PlayerPrefs.GetString("SplineEditorSave");
			if (string.IsNullOrEmpty(@string))
			{
				return;
			}
			SplineBase[] array = UnityEngine.Object.FindObjectsOfType<SplineBase>();
			SplineSnapshots splineSnapshots = DeserializeFromString<SplineSnapshots>(@string);
			if (array.Length != splineSnapshots.Data.Length)
			{
				UnityEngine.Debug.LogError("Wrong data in save file");
				return;
			}
			for (int i = 0; i < splineSnapshots.Data.Length; i++)
			{
				array[i].Load(splineSnapshots.Data[i]);
			}
		}

		public virtual void Save()
		{
			SplineBase[] array = UnityEngine.Object.FindObjectsOfType<SplineBase>();
			SplineSnapshots splineSnapshots = new SplineSnapshots
			{
				Data = new SplineSnapshot[array.Length]
			};
			for (int i = 0; i < splineSnapshots.Data.Length; i++)
			{
				splineSnapshots.Data[i] = array[i].Save();
			}
			string value = SerializeToString(splineSnapshots);
			PlayerPrefs.SetString("SplineEditorSave", value);
		}

		private static TData DeserializeFromString<TData>(string settings)
		{
			return (TData)JsonUtility.FromJson(settings, typeof(TData));
		}

		private static string SerializeToString<TData>(TData settings)
		{
			return JsonUtility.ToJson(settings, prettyPrint: false);
		}
	}
	[ExecuteInEditMode]
	public class SplineRuntimeEditor : MonoBehaviour
	{
		public Camera Camera;

		public float SelectionMargin = 20f;

		public static readonly Color MirroredModeColor = Color.red;

		public static readonly Color AlignedModeColor = Color.blue;

		public static readonly Color FreeModeColor = Color.yellow;

		public static readonly Color ControlPointLineColor = Color.gray;

		private Material m_connectedMaterial;

		private Material m_normalMaterial;

		private Material m_mirroredModeMaterial;

		private Material m_alignedModeMaterial;

		private Material m_freeModeMaterial;

		private Mesh m_controlPointMesh;

		private bool m_isApplicationQuit;

		private static SplineRuntimeEditor m_instance;

		public Mesh ControlPointMesh => m_controlPointMesh;

		public Material ConnectedMaterial => m_connectedMaterial;

		public Material MirroredModeMaterial => m_mirroredModeMaterial;

		public Material AlignedModeMaterial => m_alignedModeMaterial;

		public Material FreeModeMaterial => m_freeModeMaterial;

		public Material NormalMaterial => m_normalMaterial;

		public static SplineRuntimeEditor Instance => m_instance;

		public static event EventHandler Created;

		public static event EventHandler Destroyed;

		private void Awake()
		{
			if (Camera == null)
			{
				Camera = Camera.main;
				if (Camera.main == null)
				{
					UnityEngine.Debug.LogError("Add Camera with MainCamera Tag");
				}
			}
			if (m_instance != null)
			{
				UnityEngine.Debug.LogWarning("Another instance of SplineEditorSettings already exist");
			}
			if (m_mirroredModeMaterial == null)
			{
				Shader shader = Shader.Find("Battlehub/SplineEditor/SSBillboard");
				m_mirroredModeMaterial = new Material(shader);
				m_mirroredModeMaterial.name = "MirroredModeMaterial";
				m_mirroredModeMaterial.color = MirroredModeColor;
				m_mirroredModeMaterial.SetInt("_Cull", 0);
				m_mirroredModeMaterial.SetInt("_ZWrite", 1);
				m_mirroredModeMaterial.SetInt("_ZTest", 8);
			}
			if (m_alignedModeMaterial == null)
			{
				m_alignedModeMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
				m_alignedModeMaterial.name = "AlignedModeMaterial";
				m_alignedModeMaterial.color = AlignedModeColor;
			}
			if (m_freeModeMaterial == null)
			{
				m_freeModeMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
				m_freeModeMaterial.name = "FreeModeMaterial";
				m_freeModeMaterial.color = FreeModeColor;
			}
			if (m_normalMaterial == null)
			{
				m_normalMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
				m_normalMaterial.name = "SplineMaterial";
				m_normalMaterial.color = Color.green;
			}
			if (m_connectedMaterial == null)
			{
				m_connectedMaterial = UnityEngine.Object.Instantiate(m_mirroredModeMaterial);
				m_connectedMaterial.name = "BranchMaterial";
				m_connectedMaterial.color = new Color32(165, 0, byte.MaxValue, byte.MaxValue);
			}
			if (m_controlPointMesh == null)
			{
				m_controlPointMesh = new Mesh();
				m_controlPointMesh.name = "control point mesh";
				m_controlPointMesh.vertices = new Vector3[4]
				{
					new Vector3(0f, 0f, 0f),
					new Vector3(0f, 0f, 0f),
					new Vector3(0f, 0f, 0f),
					new Vector3(0f, 0f, 0f)
				};
				m_controlPointMesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
				m_controlPointMesh.uv = new Vector2[4]
				{
					new Vector2(-1f, -1f),
					new Vector2(1f, -1f),
					new Vector2(1f, 1f),
					new Vector2(-1f, 1f)
				};
				m_controlPointMesh.RecalculateBounds();
			}
			m_instance = this;
			EnableRuntimeEditing();
			RuntimeSelection.SelectionChanged += OnRuntimeSelectionChanged;
		}

		private void Start()
		{
			if (SplineRuntimeEditor.Created != null)
			{
				SplineRuntimeEditor.Created(this, EventArgs.Empty);
			}
		}

		private void OnApplicationQuit()
		{
			m_isApplicationQuit = true;
		}

		private void OnDestroy()
		{
			if (!Application.isPlaying)
			{
				DisableRuntimeEditing();
			}
			bool flag = false;
			if (!m_isApplicationQuit && !flag)
			{
				SplineControlPoint[] array = Resources.FindObjectsOfTypeAll<SplineControlPoint>();
				foreach (SplineControlPoint splineControlPoint in array)
				{
					if (splineControlPoint != null)
					{
						splineControlPoint.DestroyRuntimeComponents();
					}
				}
			}
			if (SplineRuntimeEditor.Destroyed != null)
			{
				SplineRuntimeEditor.Destroyed(this, EventArgs.Empty);
			}
			RuntimeSelection.SelectionChanged -= OnRuntimeSelectionChanged;
			m_instance = null;
		}

		private void DisableRuntimeEditing()
		{
			if (Camera != null)
			{
				GLCamera component = Camera.GetComponent<GLCamera>();
				if (component != null)
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
			}
		}

		private void EnableRuntimeEditing()
		{
			if (!(Camera == null) && !Camera.GetComponent<GLCamera>())
			{
				Camera.gameObject.AddComponent<GLCamera>();
			}
		}

		private void LateUpdate()
		{
			if (!(m_instance == null))
			{
				return;
			}
			m_instance = this;
			SplineBase[] array = UnityEngine.Object.FindObjectsOfType<SplineBase>();
			foreach (SplineBase splineBase in array)
			{
				if (splineBase.IsSelected)
				{
					splineBase.Select();
				}
			}
		}

		private void OnRuntimeSelectionChanged(UnityEngine.Object[] unselected)
		{
			SplineBase splineBase = null;
			int minIndex = -1;
			float num = float.PositiveInfinity;
			if (unselected != null)
			{
				GameObject[] array = unselected.OfType<GameObject>().ToArray();
				foreach (GameObject gameObject in array)
				{
					if (gameObject == null)
					{
						continue;
					}
					SplineBase componentInParent = gameObject.GetComponentInParent<SplineBase>();
					if (!(componentInParent == null))
					{
						componentInParent.Select();
						float resultDistance = num;
						SplineBase resultSpline;
						int num2 = HitTestRecursive(componentInParent.Root, num, out resultSpline, out resultDistance);
						if (resultDistance < num && num2 != -1)
						{
							num = resultDistance;
							minIndex = num2;
							splineBase = resultSpline;
						}
						componentInParent.Unselect();
					}
				}
				if (splineBase != null)
				{
					SplineControlPoint splineControlPoint = (from p in splineBase.GetSplineControlPoints()
						where p.Index == minIndex
						select p).FirstOrDefault();
					if (splineControlPoint != null)
					{
						RuntimeSelection.activeObject = splineControlPoint.gameObject;
					}
					splineBase.Select();
					return;
				}
			}
			if (RuntimeSelection.gameObjects == null)
			{
				return;
			}
			GameObject[] gameObjects = RuntimeSelection.gameObjects;
			if (gameObjects == null)
			{
				return;
			}
			for (int j = 0; j < gameObjects.Length; j++)
			{
				SplineBase componentInParent2 = gameObjects[j].GetComponentInParent<SplineBase>();
				if (componentInParent2 != null)
				{
					componentInParent2.Select();
				}
			}
		}

		private int HitTestRecursive(SplineBase spline, float distance, out SplineBase resultSpline, out float resultDistance)
		{
			resultSpline = null;
			resultDistance = float.MaxValue;
			int result = -1;
			float minDistance;
			int num = HitTest(spline, out minDistance);
			if (num > -1 && minDistance < distance)
			{
				resultSpline = spline;
				resultDistance = minDistance;
				distance = minDistance;
				result = num;
			}
			if (spline.Children != null)
			{
				for (int i = 0; i < spline.Children.Length; i++)
				{
					SplineBase spline2 = spline.Children[i];
					SplineBase resultSpline2;
					float resultDistance2;
					int num2 = HitTestRecursive(spline2, distance, out resultSpline2, out resultDistance2);
					if (num2 > -1)
					{
						resultSpline = resultSpline2;
						resultDistance = resultDistance2;
						distance = minDistance;
						result = num2;
					}
				}
			}
			return result;
		}

		private int HitTest(SplineBase spline, out float minDistance)
		{
			minDistance = float.PositiveInfinity;
			if (Camera == null)
			{
				UnityEngine.Debug.LogError("Camera is null");
				return -1;
			}
			if (RuntimeSelection.gameObjects == null)
			{
				return -1;
			}
			Vector3[] array = new Vector3[spline.ControlPointCount];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = spline.GetControlPoint(i);
			}
			minDistance = SelectionMargin * SelectionMargin;
			int result = -1;
			Vector2 vector = Input.mousePosition;
			for (int j = 0; j < array.Length; j++)
			{
				Vector3 position = array[j];
				if (!spline.IsControlPointLocked(j))
				{
					float sqrMagnitude = ((Vector2)Camera.WorldToScreenPoint(position) - vector).sqrMagnitude;
					if (sqrMagnitude < minDistance)
					{
						minDistance = sqrMagnitude;
						result = j;
					}
				}
			}
			return result;
		}

		public void OnClosed()
		{
			if (RuntimeSelection.gameObjects == null)
			{
				return;
			}
			GameObject[] array = RuntimeSelection.gameObjects.OfType<GameObject>().ToArray();
			foreach (GameObject gameObject in array)
			{
				if (!(gameObject == null))
				{
					SplineBase componentInParent = gameObject.GetComponentInParent<SplineBase>();
					if (!(componentInParent == null))
					{
						componentInParent.Unselect();
					}
				}
			}
		}

		public void OnOpened()
		{
		}
	}
}
namespace UnityEngine.PostProcessing
{
	public sealed class GetSetAttribute : PropertyAttribute
	{
		public readonly string name;

		public bool dirty;

		public GetSetAttribute(string name)
		{
			this.name = name;
		}
	}
	public sealed class TrackballAttribute : PropertyAttribute
	{
		public readonly string method;

		public TrackballAttribute(string method)
		{
			this.method = method;
		}
	}
	public sealed class TrackballGroupAttribute : PropertyAttribute
	{
	}
	public sealed class AmbientOcclusionComponent : PostProcessingComponentCommandBuffer<AmbientOcclusionModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Intensity = Shader.PropertyToID("_Intensity");

			internal static readonly int _Radius = Shader.PropertyToID("_Radius");

			internal static readonly int _FogParams = Shader.PropertyToID("_FogParams");

			internal static readonly int _Downsample = Shader.PropertyToID("_Downsample");

			internal static readonly int _SampleCount = Shader.PropertyToID("_SampleCount");

			internal static readonly int _OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

			internal static readonly int _OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

			internal static readonly int _OcclusionTexture = Shader.PropertyToID("_OcclusionTexture");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
		}

		private enum OcclusionSource
		{
			DepthTexture,
			DepthNormalsTexture,
			GBuffer
		}

		private const string k_BlitShaderString = "Hidden/Post FX/Blit";

		private const string k_ShaderString = "Hidden/Post FX/Ambient Occlusion";

		private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[2]
		{
			BuiltinRenderTextureType.GBuffer0,
			BuiltinRenderTextureType.CameraTarget
		};

		private OcclusionSource occlusionSource
		{
			get
			{
				if (context.isGBufferAvailable && !base.model.settings.forceForwardCompatibility)
				{
					return OcclusionSource.GBuffer;
				}
				if (base.model.settings.highPrecision && (!context.isGBufferAvailable || base.model.settings.forceForwardCompatibility))
				{
					return OcclusionSource.DepthTexture;
				}
				return OcclusionSource.DepthNormalsTexture;
			}
		}

		private bool ambientOnlySupported
		{
			get
			{
				if (context.isHdr && base.model.settings.ambientOnly && context.isGBufferAvailable)
				{
					return !base.model.settings.forceForwardCompatibility;
				}
				return false;
			}
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			DepthTextureMode depthTextureMode = DepthTextureMode.None;
			if (occlusionSource == OcclusionSource.DepthTexture)
			{
				depthTextureMode |= DepthTextureMode.Depth;
			}
			if (occlusionSource != OcclusionSource.GBuffer)
			{
				depthTextureMode |= DepthTextureMode.DepthNormals;
			}
			return depthTextureMode;
		}

		public override string GetName()
		{
			return "Ambient Occlusion";
		}

		public override CameraEvent GetCameraEvent()
		{
			if (!ambientOnlySupported || context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
			{
				return CameraEvent.BeforeImageEffectsOpaque;
			}
			return CameraEvent.BeforeReflections;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			AmbientOcclusionModel.Settings settings = base.model.settings;
			Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
			Material material = context.materialFactory.Get("Hidden/Post FX/Ambient Occlusion");
			material.shaderKeywords = null;
			material.SetFloat(Uniforms._Intensity, settings.intensity);
			material.SetFloat(Uniforms._Radius, settings.radius);
			material.SetFloat(Uniforms._Downsample, settings.downsampling ? 0.5f : 1f);
			material.SetInt(Uniforms._SampleCount, (int)settings.sampleCount);
			if (!context.isGBufferAvailable && RenderSettings.fog)
			{
				material.SetVector(Uniforms._FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
				switch (RenderSettings.fogMode)
				{
				case FogMode.Linear:
					material.EnableKeyword("FOG_LINEAR");
					break;
				case FogMode.Exponential:
					material.EnableKeyword("FOG_EXP");
					break;
				case FogMode.ExponentialSquared:
					material.EnableKeyword("FOG_EXP2");
					break;
				}
			}
			else
			{
				material.EnableKeyword("FOG_OFF");
			}
			int width = context.width;
			int height = context.height;
			int num = ((!settings.downsampling) ? 1 : 2);
			int occlusionTexture = Uniforms._OcclusionTexture1;
			cb.GetTemporaryRT(occlusionTexture, width / num, height / num, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.Blit(null, occlusionTexture, material, (int)occlusionSource);
			int occlusionTexture2 = Uniforms._OcclusionTexture2;
			cb.GetTemporaryRT(occlusionTexture2, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
			cb.Blit(occlusionTexture, occlusionTexture2, material, (occlusionSource == OcclusionSource.GBuffer) ? 4 : 3);
			cb.ReleaseTemporaryRT(occlusionTexture);
			occlusionTexture = Uniforms._OcclusionTexture;
			cb.GetTemporaryRT(occlusionTexture, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture2);
			cb.Blit(occlusionTexture2, occlusionTexture, material, 5);
			cb.ReleaseTemporaryRT(occlusionTexture2);
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
			{
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
				cb.Blit(occlusionTexture, BuiltinRenderTextureType.CameraTarget, material, 8);
				context.Interrupt();
			}
			else if (ambientOnlySupported)
			{
				cb.SetRenderTarget(m_MRT, BuiltinRenderTextureType.CameraTarget);
				cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 7);
			}
			else
			{
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				int tempRT = Uniforms._TempRT;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				cb.SetGlobalTexture(Uniforms._MainTex, tempRT);
				cb.Blit(tempRT, BuiltinRenderTextureType.CameraTarget, material, 6);
				cb.ReleaseTemporaryRT(tempRT);
			}
			cb.ReleaseTemporaryRT(occlusionTexture);
		}
	}
	public sealed class BloomComponent : PostProcessingComponentRenderTexture<BloomModel>
	{
		private static class Uniforms
		{
			internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

			internal static readonly int _Threshold = Shader.PropertyToID("_Threshold");

			internal static readonly int _Curve = Shader.PropertyToID("_Curve");

			internal static readonly int _PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");

			internal static readonly int _SampleScale = Shader.PropertyToID("_SampleScale");

			internal static readonly int _BaseTex = Shader.PropertyToID("_BaseTex");

			internal static readonly int _BloomTex = Shader.PropertyToID("_BloomTex");

			internal static readonly int _Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

			internal static readonly int _Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

			internal static readonly int _Bloom_DirtIntensity = Shader.PropertyToID("_Bloom_DirtIntensity");
		}

		private const int k_MaxPyramidBlurLevel = 16;

		private readonly RenderTexture[] m_BlurBuffer1 = new RenderTexture[16];

		private readonly RenderTexture[] m_BlurBuffer2 = new RenderTexture[16];

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.bloom.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void Prepare(RenderTexture source, Material uberMaterial, Texture autoExposure)
		{
			BloomModel.BloomSettings bloom = base.model.settings.bloom;
			BloomModel.LensDirtSettings lensDirt = base.model.settings.lensDirt;
			Material material = context.materialFactory.Get("Hidden/Post FX/Bloom");
			material.shaderKeywords = null;
			material.SetTexture(Uniforms._AutoExposure, autoExposure);
			int width = context.width / 2;
			int num = context.height / 2;
			bool isMobilePlatform = Application.isMobilePlatform;
			bool flag = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float);
			RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : (flag ? RenderTextureFormat.RGB111110Float : RenderTextureFormat.DefaultHDR));
			float num2 = Mathf.Log(num, 2f) + bloom.radius - 8f;
			int num3 = (int)num2;
			int num4 = Mathf.Clamp(num3, 1, 16);
			float thresholdLinear = bloom.thresholdLinear;
			material.SetFloat(Uniforms._Threshold, thresholdLinear);
			float num5 = thresholdLinear * bloom.softKnee + 1E-05f;
			material.SetVector(value: new Vector3(thresholdLinear - num5, num5 * 2f, 0.25f / num5), nameID: Uniforms._Curve);
			material.SetFloat(Uniforms._PrefilterOffs, bloom.antiFlicker ? (-0.5f) : 0f);
			float num6 = 0.5f + num2 - (float)num3;
			material.SetFloat(Uniforms._SampleScale, num6);
			if (bloom.antiFlicker)
			{
				material.EnableKeyword("ANTI_FLICKER");
			}
			RenderTexture renderTexture = context.renderTextureFactory.Get(width, num, 0, format);
			Graphics.Blit(source, renderTexture, material, 0);
			RenderTexture renderTexture2 = renderTexture;
			for (int i = 0; i < num4; i++)
			{
				m_BlurBuffer1[i] = context.renderTextureFactory.Get(renderTexture2.width / 2, renderTexture2.height / 2, 0, format);
				int pass = ((i == 0) ? 1 : 2);
				Graphics.Blit(renderTexture2, m_BlurBuffer1[i], material, pass);
				renderTexture2 = m_BlurBuffer1[i];
			}
			for (int num7 = num4 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture3 = m_BlurBuffer1[num7];
				material.SetTexture(Uniforms._BaseTex, renderTexture3);
				m_BlurBuffer2[num7] = context.renderTextureFactory.Get(renderTexture3.width, renderTexture3.height, 0, format);
				Graphics.Blit(renderTexture2, m_BlurBuffer2[num7], material, 3);
				renderTexture2 = m_BlurBuffer2[num7];
			}
			RenderTexture renderTexture4 = renderTexture2;
			for (int j = 0; j < 16; j++)
			{
				if (m_BlurBuffer1[j] != null)
				{
					context.renderTextureFactory.Release(m_BlurBuffer1[j]);
				}
				if (m_BlurBuffer2[j] != null && m_BlurBuffer2[j] != renderTexture4)
				{
					context.renderTextureFactory.Release(m_BlurBuffer2[j]);
				}
				m_BlurBuffer1[j] = null;
				m_BlurBuffer2[j] = null;
			}
			context.renderTextureFactory.Release(renderTexture);
			uberMaterial.SetTexture(Uniforms._BloomTex, renderTexture4);
			uberMaterial.SetVector(Uniforms._Bloom_Settings, new Vector2(num6, bloom.intensity));
			if (lensDirt.intensity > 0f && lensDirt.texture != null)
			{
				uberMaterial.SetTexture(Uniforms._Bloom_DirtTex, lensDirt.texture);
				uberMaterial.SetFloat(Uniforms._Bloom_DirtIntensity, lensDirt.intensity);
				uberMaterial.EnableKeyword("BLOOM_LENS_DIRT");
			}
			else
			{
				uberMaterial.EnableKeyword("BLOOM");
			}
		}
	}
	public sealed class BuiltinDebugViewsComponent : PostProcessingComponentCommandBuffer<BuiltinDebugViewsModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DepthScale = Shader.PropertyToID("_DepthScale");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

			internal static readonly int _Opacity = Shader.PropertyToID("_Opacity");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _TempRT2 = Shader.PropertyToID("_TempRT2");

			internal static readonly int _Amplitude = Shader.PropertyToID("_Amplitude");

			internal static readonly int _Scale = Shader.PropertyToID("_Scale");
		}

		private enum Pass
		{
			Depth,
			Normals,
			MovecOpacity,
			MovecImaging,
			MovecArrows
		}

		private class ArrowArray
		{
			public Mesh mesh { get; private set; }

			public int columnCount { get; private set; }

			public int rowCount { get; private set; }

			public void BuildMesh(int columns, int rows)
			{
				Vector3[] array = new Vector3[6]
				{
					new Vector3(0f, 0f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(-1f, 1f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(1f, 1f, 0f)
				};
				int num = 6 * columns * rows;
				List<Vector3> list = new List<Vector3>(num);
				List<Vector2> list2 = new List<Vector2>(num);
				for (int i = 0; i < rows; i++)
				{
					for (int j = 0; j < columns; j++)
					{
						Vector2 item = new Vector2((0.5f + (float)j) / (float)columns, (0.5f + (float)i) / (float)rows);
						for (int k = 0; k < 6; k++)
						{
							list.Add(array[k]);
							list2.Add(item);
						}
					}
				}
				int[] array2 = new int[num];
				for (int l = 0; l < num; l++)
				{
					array2[l] = l;
				}
				mesh = new Mesh
				{
					hideFlags = HideFlags.DontSave
				};
				mesh.SetVertices(list);
				mesh.SetUVs(0, list2);
				mesh.SetIndices(array2, MeshTopology.Lines, 0);
				mesh.UploadMeshData(markNoLongerReadable: true);
				columnCount = columns;
				rowCount = rows;
			}

			public void Release()
			{
				GraphicsUtils.Destroy(mesh);
				mesh = null;
			}
		}

		private const string k_ShaderString = "Hidden/Post FX/Builtin Debug Views";

		private ArrowArray m_Arrows;

		public override bool active
		{
			get
			{
				if (!base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Depth) && !base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Normals))
				{
					return base.model.IsModeActive(BuiltinDebugViewsModel.Mode.MotionVectors);
				}
				return true;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			BuiltinDebugViewsModel.Mode mode = base.model.settings.mode;
			DepthTextureMode depthTextureMode = DepthTextureMode.None;
			switch (mode)
			{
			case BuiltinDebugViewsModel.Mode.Normals:
				depthTextureMode |= DepthTextureMode.DepthNormals;
				break;
			case BuiltinDebugViewsModel.Mode.MotionVectors:
				depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
				break;
			case BuiltinDebugViewsModel.Mode.Depth:
				depthTextureMode |= DepthTextureMode.Depth;
				break;
			}
			return depthTextureMode;
		}

		public override CameraEvent GetCameraEvent()
		{
			if (base.model.settings.mode != BuiltinDebugViewsModel.Mode.MotionVectors)
			{
				return CameraEvent.BeforeImageEffectsOpaque;
			}
			return CameraEvent.BeforeImageEffects;
		}

		public override string GetName()
		{
			return "Builtin Debug Views";
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			BuiltinDebugViewsModel.Settings settings = base.model.settings;
			Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			material.shaderKeywords = null;
			if (context.isGBufferAvailable)
			{
				material.EnableKeyword("SOURCE_GBUFFER");
			}
			switch (settings.mode)
			{
			case BuiltinDebugViewsModel.Mode.Depth:
				DepthPass(cb);
				break;
			case BuiltinDebugViewsModel.Mode.Normals:
				DepthNormalsPass(cb);
				break;
			case BuiltinDebugViewsModel.Mode.MotionVectors:
				MotionVectorsPass(cb);
				break;
			}
			context.Interrupt();
		}

		private void DepthPass(CommandBuffer cb)
		{
			Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			BuiltinDebugViewsModel.DepthSettings depth = base.model.settings.depth;
			cb.SetGlobalFloat(Uniforms._DepthScale, 1f / depth.scale);
			cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 0);
		}

		private void DepthNormalsPass(CommandBuffer cb)
		{
			Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 1);
		}

		private void MotionVectorsPass(CommandBuffer cb)
		{
			Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
			BuiltinDebugViewsModel.MotionVectorsSettings motionVectors = base.model.settings.motionVectors;
			int num = Uniforms._TempRT;
			cb.GetTemporaryRT(num, context.width, context.height, 0, FilterMode.Bilinear);
			cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.sourceOpacity);
			cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, num, material, 2);
			if (motionVectors.motionImageOpacity > 0f && motionVectors.motionImageAmplitude > 0f)
			{
				int tempRT = Uniforms._TempRT2;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear);
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionImageOpacity);
				cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionImageAmplitude);
				cb.SetGlobalTexture(Uniforms._MainTex, num);
				cb.Blit(num, tempRT, material, 3);
				cb.ReleaseTemporaryRT(num);
				num = tempRT;
			}
			if (motionVectors.motionVectorsOpacity > 0f && motionVectors.motionVectorsAmplitude > 0f)
			{
				PrepareArrows();
				float num2 = 1f / (float)motionVectors.motionVectorsResolution;
				float x = num2 * (float)context.height / (float)context.width;
				cb.SetGlobalVector(Uniforms._Scale, new Vector2(x, num2));
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionVectorsOpacity);
				cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionVectorsAmplitude);
				cb.DrawMesh(m_Arrows.mesh, Matrix4x4.identity, material, 0, 4);
			}
			cb.SetGlobalTexture(Uniforms._MainTex, num);
			cb.Blit(num, BuiltinRenderTextureType.CameraTarget);
			cb.ReleaseTemporaryRT(num);
		}

		private void PrepareArrows()
		{
			int motionVectorsResolution = base.model.settings.motionVectors.motionVectorsResolution;
			int num = motionVectorsResolution * Screen.width / Screen.height;
			if (m_Arrows == null)
			{
				m_Arrows = new ArrowArray();
			}
			if (m_Arrows.columnCount != num || m_Arrows.rowCount != motionVectorsResolution)
			{
				m_Arrows.Release();
				m_Arrows.BuildMesh(num, motionVectorsResolution);
			}
		}

		public override void OnDisable()
		{
			if (m_Arrows != null)
			{
				m_Arrows.Release();
			}
			m_Arrows = null;
		}
	}
	public sealed class ChromaticAberrationComponent : PostProcessingComponentRenderTexture<ChromaticAberrationModel>
	{
		private static class Uniforms
		{
			internal static readonly int _ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

			internal static readonly int _ChromaticAberration_Spectrum = Shader.PropertyToID("_ChromaticAberration_Spectrum");
		}

		private Texture2D m_SpectrumLut;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_SpectrumLut);
			m_SpectrumLut = null;
		}

		public override void Prepare(Material uberMaterial)
		{
			ChromaticAberrationModel.Settings settings = base.model.settings;
			Texture2D texture2D = settings.spectralTexture;
			if (texture2D == null)
			{
				if (m_SpectrumLut == null)
				{
					m_SpectrumLut = new Texture2D(3, 1, TextureFormat.RGB24, mipChain: false)
					{
						name = "Chromatic Aberration Spectrum Lookup",
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0,
						hideFlags = HideFlags.DontSave
					};
					Color[] pixels = new Color[3]
					{
						new Color(1f, 0f, 0f),
						new Color(0f, 1f, 0f),
						new Color(0f, 0f, 1f)
					};
					m_SpectrumLut.SetPixels(pixels);
					m_SpectrumLut.Apply();
				}
				texture2D = m_SpectrumLut;
			}
			uberMaterial.EnableKeyword("CHROMATIC_ABERRATION");
			uberMaterial.SetFloat(Uniforms._ChromaticAberration_Amount, settings.intensity * 0.03f);
			uberMaterial.SetTexture(Uniforms._ChromaticAberration_Spectrum, texture2D);
		}
	}
	public sealed class ColorGradingComponent : PostProcessingComponentRenderTexture<ColorGradingModel>
	{
		private static class Uniforms
		{
			internal static readonly int _LutParams = Shader.PropertyToID("_LutParams");

			internal static readonly int _NeutralTonemapperParams1 = Shader.PropertyToID("_NeutralTonemapperParams1");

			internal static readonly int _NeutralTonemapperParams2 = Shader.PropertyToID("_NeutralTonemapperParams2");

			internal static readonly int _HueShift = Shader.PropertyToID("_HueShift");

			internal static readonly int _Saturation = Shader.PropertyToID("_Saturation");

			internal static readonly int _Contrast = Shader.PropertyToID("_Contrast");

			internal static readonly int _Balance = Shader.PropertyToID("_Balance");

			internal static readonly int _Lift = Shader.PropertyToID("_Lift");

			internal static readonly int _InvGamma = Shader.PropertyToID("_InvGamma");

			internal static readonly int _Gain = Shader.PropertyToID("_Gain");

			internal static readonly int _Slope = Shader.PropertyToID("_Slope");

			internal static readonly int _Power = Shader.PropertyToID("_Power");

			internal static readonly int _Offset = Shader.PropertyToID("_Offset");

			internal static readonly int _ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

			internal static readonly int _ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

			internal static readonly int _ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

			internal static readonly int _Curves = Shader.PropertyToID("_Curves");

			internal static readonly int _LogLut = Shader.PropertyToID("_LogLut");

			internal static readonly int _LogLut_Params = Shader.PropertyToID("_LogLut_Params");

			internal static readonly int _ExposureEV = Shader.PropertyToID("_ExposureEV");
		}

		private const int k_InternalLogLutSize = 32;

		private const int k_CurvePrecision = 128;

		private const float k_CurveStep = 1f / 128f;

		private Texture2D m_GradingCurves;

		private Color[] m_pixels = new Color[256];

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		private float StandardIlluminantY(float x)
		{
			return 2.87f * x - 3f * x * x - 0.27509508f;
		}

		private Vector3 CIExyToLMS(float x, float y)
		{
			float num = 1f;
			float num2 = num * x / y;
			float num3 = num * (1f - x - y) / y;
			float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
			float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
			float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
			return new Vector3(x2, y2, z);
		}

		private Vector3 CalculateColorBalance(float temperature, float tint)
		{
			float num = temperature / 55f;
			float num2 = tint / 55f;
			float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
			float y = StandardIlluminantY(x) + num2 * 0.05f;
			Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
			Vector3 vector2 = CIExyToLMS(x, y);
			return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
		}

		private static Color NormalizeColor(Color c)
		{
			float num = (c.r + c.g + c.b) / 3f;
			if (Mathf.Approximately(num, 0f))
			{
				return new Color(1f, 1f, 1f, c.a);
			}
			Color result = default(Color);
			result.r = c.r / num;
			result.g = c.g / num;
			result.b = c.b / num;
			result.a = c.a;
			return result;
		}

		private static Vector3 ClampVector(Vector3 v, float min, float max)
		{
			return new Vector3(Mathf.Clamp(v.x, min, max), Mathf.Clamp(v.y, min, max), Mathf.Clamp(v.z, min, max));
		}

		public static Vector3 GetLiftValue(Color lift)
		{
			Color color = NormalizeColor(lift);
			float num = (color.r + color.g + color.b) / 3f;
			float x = (color.r - num) * 0.1f + lift.a;
			float y = (color.g - num) * 0.1f + lift.a;
			float z = (color.b - num) * 0.1f + lift.a;
			return ClampVector(new Vector3(x, y, z), -1f, 1f);
		}

		public static Vector3 GetGammaValue(Color gamma)
		{
			Color color = NormalizeColor(gamma);
			float num = (color.r + color.g + color.b) / 3f;
			gamma.a *= ((gamma.a < 0f) ? 0.8f : 5f);
			float b = Mathf.Pow(2f, (color.r - num) * 0.5f) + gamma.a;
			float b2 = Mathf.Pow(2f, (color.g - num) * 0.5f) + gamma.a;
			float b3 = Mathf.Pow(2f, (color.b - num) * 0.5f) + gamma.a;
			float x = 1f / Mathf.Max(0.01f, b);
			float y = 1f / Mathf.Max(0.01f, b2);
			float z = 1f / Mathf.Max(0.01f, b3);
			return ClampVector(new Vector3(x, y, z), 0f, 5f);
		}

		public static Vector3 GetGainValue(Color gain)
		{
			Color color = NormalizeColor(gain);
			float num = (color.r + color.g + color.b) / 3f;
			gain.a *= ((gain.a > 0f) ? 3f : 1f);
			float x = Mathf.Pow(2f, (color.r - num) * 0.5f) + gain.a;
			float y = Mathf.Pow(2f, (color.g - num) * 0.5f) + gain.a;
			float z = Mathf.Pow(2f, (color.b - num) * 0.5f) + gain.a;
			return ClampVector(new Vector3(x, y, z), 0f, 4f);
		}

		public static void CalculateLiftGammaGain(Color lift, Color gamma, Color gain, out Vector3 outLift, out Vector3 outGamma, out Vector3 outGain)
		{
			outLift = GetLiftValue(lift);
			outGamma = GetGammaValue(gamma);
			outGain = GetGainValue(gain);
		}

		public static Vector3 GetSlopeValue(Color slope)
		{
			Color color = NormalizeColor(slope);
			float num = (color.r + color.g + color.b) / 3f;
			slope.a *= 0.5f;
			float x = (color.r - num) * 0.1f + slope.a + 1f;
			float y = (color.g - num) * 0.1f + slope.a + 1f;
			float z = (color.b - num) * 0.1f + slope.a + 1f;
			return ClampVector(new Vector3(x, y, z), 0f, 2f);
		}

		public static Vector3 GetPowerValue(Color power)
		{
			Color color = NormalizeColor(power);
			float num = (color.r + color.g + color.b) / 3f;
			power.a *= 0.5f;
			float b = (color.r - num) * 0.1f + power.a + 1f;
			float b2 = (color.g - num) * 0.1f + power.a + 1f;
			float b3 = (color.b - num) * 0.1f + power.a + 1f;
			float x = 1f / Mathf.Max(0.01f, b);
			float y = 1f / Mathf.Max(0.01f, b2);
			float z = 1f / Mathf.Max(0.01f, b3);
			return ClampVector(new Vector3(x, y, z), 0.5f, 2.5f);
		}

		public static Vector3 GetOffsetValue(Color offset)
		{
			Color color = NormalizeColor(offset);
			float num = (color.r + color.g + color.b) / 3f;
			offset.a *= 0.5f;
			float x = (color.r - num) * 0.05f + offset.a;
			float y = (color.g - num) * 0.05f + offset.a;
			float z = (color.b - num) * 0.05f + offset.a;
			return ClampVector(new Vector3(x, y, z), -0.8f, 0.8f);
		}

		public static void CalculateSlopePowerOffset(Color slope, Color power, Color offset, out Vector3 outSlope, out Vector3 outPower, out Vector3 outOffset)
		{
			outSlope = GetSlopeValue(slope);
			outPower = GetPowerValue(power);
			outOffset = GetOffsetValue(offset);
		}

		private TextureFormat GetCurveFormat()
		{
			if (SystemInfo.SupportsTextureFormat(TextureFormat.RGBAHalf))
			{
				return TextureFormat.RGBAHalf;
			}
			return TextureFormat.RGBA32;
		}

		private Texture2D GetCurveTexture()
		{
			if (m_GradingCurves == null)
			{
				m_GradingCurves = new Texture2D(128, 2, GetCurveFormat(), mipChain: false, linear: true)
				{
					name = "Internal Curves Texture",
					hideFlags = HideFlags.DontSave,
					anisoLevel = 0,
					wrapMode = TextureWrapMode.Clamp,
					filterMode = FilterMode.Bilinear
				};
			}
			ColorGradingModel.CurvesSettings curves = base.model.settings.curves;
			curves.hueVShue.Cache();
			curves.hueVSsat.Cache();
			for (int i = 0; i < 128; i++)
			{
				float t = (float)i * (1f / 128f);
				float r = curves.hueVShue.Evaluate(t);
				float g = curves.hueVSsat.Evaluate(t);
				float b = curves.satVSsat.Evaluate(t);
				float a = curves.lumVSsat.Evaluate(t);
				m_pixels[i] = new Color(r, g, b, a);
				float a2 = curves.master.Evaluate(t);
				float r2 = curves.red.Evaluate(t);
				float g2 = curves.green.Evaluate(t);
				float b2 = curves.blue.Evaluate(t);
				m_pixels[i + 128] = new Color(r2, g2, b2, a2);
			}
			m_GradingCurves.SetPixels(m_pixels);
			m_GradingCurves.Apply(updateMipmaps: false, makeNoLongerReadable: false);
			return m_GradingCurves;
		}

		private bool IsLogLutValid(RenderTexture lut)
		{
			if (lut != null && lut.IsCreated())
			{
				return lut.height == 32;
			}
			return false;
		}

		private RenderTextureFormat GetLutFormat()
		{
			if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				return RenderTextureFormat.ARGBHalf;
			}
			return RenderTextureFormat.ARGB32;
		}

		private void GenerateLut()
		{
			ColorGradingModel.Settings settings = base.model.settings;
			if (!IsLogLutValid(base.model.bakedLut))
			{
				GraphicsUtils.Destroy(base.model.bakedLut);
				base.model.bakedLut = new RenderTexture(1024, 32, 0, GetLutFormat())
				{
					name = "Color Grading Log LUT",
					hideFlags = HideFlags.DontSave,
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Clamp,
					anisoLevel = 0
				};
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Lut Generator");
			material.SetVector(Uniforms._LutParams, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
			material.shaderKeywords = null;
			ColorGradingModel.TonemappingSettings tonemapping = settings.tonemapping;
			switch (tonemapping.tonemapper)
			{
			case ColorGradingModel.Tonemapper.Neutral:
			{
				material.EnableKeyword("TONEMAPPING_NEUTRAL");
				float num = tonemapping.neutralBlackIn * 20f + 1f;
				float num2 = tonemapping.neutralBlackOut * 10f + 1f;
				float num3 = tonemapping.neutralWhiteIn / 20f;
				float num4 = 1f - tonemapping.neutralWhiteOut / 20f;
				float t = num / num2;
				float t2 = num3 / num4;
				float y = Mathf.Max(0f, Mathf.LerpUnclamped(0.57f, 0.37f, t));
				float z = Mathf.LerpUnclamped(0.01f, 0.24f, t2);
				float w = Mathf.Max(0f, Mathf.LerpUnclamped(0.02f, 0.2f, t));
				material.SetVector(Uniforms._NeutralTonemapperParams1, new Vector4(0.2f, y, z, w));
				material.SetVector(Uniforms._NeutralTonemapperParams2, new Vector4(0.02f, 0.3f, tonemapping.neutralWhiteLevel, tonemapping.neutralWhiteClip / 10f));
				break;
			}
			case ColorGradingModel.Tonemapper.ACES:
				material.EnableKeyword("TONEMAPPING_FILMIC");
				break;
			}
			material.SetFloat(Uniforms._HueShift, settings.basic.hueShift / 360f);
			material.SetFloat(Uniforms._Saturation, settings.basic.saturation);
			material.SetFloat(Uniforms._Contrast, settings.basic.contrast);
			material.SetVector(Uniforms._Balance, CalculateColorBalance(settings.basic.temperature, settings.basic.tint));
			CalculateLiftGammaGain(settings.colorWheels.linear.lift, settings.colorWheels.linear.gamma, settings.colorWheels.linear.gain, out var outLift, out var outGamma, out var outGain);
			material.SetVector(Uniforms._Lift, outLift);
			material.SetVector(Uniforms._InvGamma, outGamma);
			material.SetVector(Uniforms._Gain, outGain);
			CalculateSlopePowerOffset(settings.colorWheels.log.slope, settings.colorWheels.log.power, settings.colorWheels.log.offset, out var outSlope, out var outPower, out var outOffset);
			material.SetVector(Uniforms._Slope, outSlope);
			material.SetVector(Uniforms._Power, outPower);
			material.SetVector(Uniforms._Offset, outOffset);
			material.SetVector(Uniforms._ChannelMixerRed, settings.channelMixer.red);
			material.SetVector(Uniforms._ChannelMixerGreen, settings.channelMixer.green);
			material.SetVector(Uniforms._ChannelMixerBlue, settings.channelMixer.blue);
			material.SetTexture(Uniforms._Curves, GetCurveTexture());
			Graphics.Blit(null, base.model.bakedLut, material, 0);
		}

		public override void Prepare(Material uberMaterial)
		{
			if (base.model.isDirty || !IsLogLutValid(base.model.bakedLut))
			{
				GenerateLut();
				base.model.isDirty = false;
			}
			uberMaterial.EnableKeyword(context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.PreGradingLog) ? "COLOR_GRADING_LOG_VIEW" : "COLOR_GRADING");
			RenderTexture bakedLut = base.model.bakedLut;
			uberMaterial.SetTexture(Uniforms._LogLut, bakedLut);
			uberMaterial.SetVector(Uniforms._LogLut_Params, new Vector3(1f / (float)bakedLut.width, 1f / (float)bakedLut.height, (float)bakedLut.height - 1f));
			float value = Mathf.Exp(base.model.settings.basic.postExposure * 0.6931472f);
			uberMaterial.SetFloat(Uniforms._ExposureEV, value);
		}

		public void OnGUI()
		{
			RenderTexture bakedLut = base.model.bakedLut;
			GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, bakedLut.width, bakedLut.height), bakedLut);
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_GradingCurves);
			GraphicsUtils.Destroy(base.model.bakedLut);
			m_GradingCurves = null;
			base.model.bakedLut = null;
		}
	}
	public sealed class DepthOfFieldComponent : PostProcessingComponentRenderTexture<DepthOfFieldModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

			internal static readonly int _DepthOfFieldCoCTex = Shader.PropertyToID("_DepthOfFieldCoCTex");

			internal static readonly int _Distance = Shader.PropertyToID("_Distance");

			internal static readonly int _LensCoeff = Shader.PropertyToID("_LensCoeff");

			internal static readonly int _MaxCoC = Shader.PropertyToID("_MaxCoC");

			internal static readonly int _RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

			internal static readonly int _RcpAspect = Shader.PropertyToID("_RcpAspect");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _CoCTex = Shader.PropertyToID("_CoCTex");

			internal static readonly int _TaaParams = Shader.PropertyToID("_TaaParams");

			internal static readonly int _DepthOfFieldParams = Shader.PropertyToID("_DepthOfFieldParams");
		}

		private const string k_ShaderString = "Hidden/Post FX/Depth Of Field";

		private RenderTexture m_CoCHistory;

		private const float k_FilmHeight = 0.024f;

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		private float CalculateFocalLength()
		{
			DepthOfFieldModel.Settings settings = base.model.settings;
			if (!settings.useCameraFov)
			{
				return settings.focalLength / 1000f;
			}
			float num = context.camera.fieldOfView * ((float)Math.PI / 180f);
			return 0.012f / Mathf.Tan(0.5f * num);
		}

		private float CalculateMaxCoCRadius(int screenHeight)
		{
			float num = (float)base.model.settings.kernelSize * 4f + 6f;
			return Mathf.Min(0.05f, num / (float)screenHeight);
		}

		private bool CheckHistory(int width, int height)
		{
			if (m_CoCHistory != null && m_CoCHistory.IsCreated() && m_CoCHistory.width == width)
			{
				return m_CoCHistory.height == height;
			}
			return false;
		}

		private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
		{
			if (SystemInfo.SupportsRenderTextureFormat(primary))
			{
				return primary;
			}
			if (SystemInfo.SupportsRenderTextureFormat(secondary))
			{
				return secondary;
			}
			return RenderTextureFormat.Default;
		}

		public void Prepare(RenderTexture source, Material uberMaterial, bool antialiasCoC, Vector2 taaJitter, float taaBlending)
		{
			DepthOfFieldModel.Settings settings = base.model.settings;
			RenderTextureFormat format = RenderTextureFormat.DefaultHDR;
			RenderTextureFormat format2 = SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf);
			float num = CalculateFocalLength();
			float num2 = Mathf.Max(settings.focusDistance, num);
			float num3 = (float)source.width / (float)source.height;
			float num4 = num * num / (settings.aperture * (num2 - num) * 0.024f * 2f);
			float num5 = CalculateMaxCoCRadius(source.height);
			Material material = context.materialFactory.Get("Hidden/Post FX/Depth Of Field");
			material.SetFloat(Uniforms._Distance, num2);
			material.SetFloat(Uniforms._LensCoeff, num4);
			material.SetFloat(Uniforms._MaxCoC, num5);
			material.SetFloat(Uniforms._RcpMaxCoC, 1f / num5);
			material.SetFloat(Uniforms._RcpAspect, 1f / num3);
			RenderTexture renderTexture = context.renderTextureFactory.Get(context.width, context.height, 0, format2, RenderTextureReadWrite.Linear);
			Graphics.Blit(null, renderTexture, material, 0);
			if (antialiasCoC)
			{
				material.SetTexture(Uniforms._CoCTex, renderTexture);
				float z = (CheckHistory(context.width, context.height) ? taaBlending : 0f);
				material.SetVector(Uniforms._TaaParams, new Vector3(taaJitter.x, taaJitter.y, z));
				RenderTexture temporary = RenderTexture.GetTemporary(context.width, context.height, 0, format2);
				Graphics.Blit(m_CoCHistory, temporary, material, 1);
				context.renderTextureFactory.Release(renderTexture);
				if (m_CoCHistory != null)
				{
					RenderTexture.ReleaseTemporary(m_CoCHistory);
				}
				renderTexture = (m_CoCHistory = temporary);
			}
			RenderTexture renderTexture2 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
			material.SetTexture(Uniforms._CoCTex, renderTexture);
			Graphics.Blit(source, renderTexture2, material, 2);
			RenderTexture renderTexture3 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
			Graphics.Blit(renderTexture2, renderTexture3, material, (int)(3 + settings.kernelSize));
			Graphics.Blit(renderTexture3, renderTexture2, material, 7);
			uberMaterial.SetVector(Uniforms._DepthOfFieldParams, new Vector3(num2, num4, num5));
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.FocusPlane))
			{
				uberMaterial.EnableKeyword("DEPTH_OF_FIELD_COC_VIEW");
				context.Interrupt();
			}
			else
			{
				uberMaterial.SetTexture(Uniforms._DepthOfFieldTex, renderTexture2);
				uberMaterial.SetTexture(Uniforms._DepthOfFieldCoCTex, renderTexture);
				uberMaterial.EnableKeyword("DEPTH_OF_FIELD");
			}
			context.renderTextureFactory.Release(renderTexture3);
		}

		public override void OnDisable()
		{
			if (m_CoCHistory != null)
			{
				RenderTexture.ReleaseTemporary(m_CoCHistory);
			}
			m_CoCHistory = null;
		}
	}
	public sealed class DitheringComponent : PostProcessingComponentRenderTexture<DitheringModel>
	{
		private static class Uniforms
		{
			internal static readonly int _DitheringTex = Shader.PropertyToID("_DitheringTex");

			internal static readonly int _DitheringCoords = Shader.PropertyToID("_DitheringCoords");
		}

		private Texture2D[] noiseTextures;

		private int textureIndex;

		private const int k_TextureCount = 64;

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			noiseTextures = null;
		}

		private void LoadNoiseTextures()
		{
			noiseTextures = new Texture2D[64];
			for (int i = 0; i < 64; i++)
			{
				noiseTextures[i] = Resources.Load<Texture2D>("Bluenoise64/LDR_LLL1_" + i);
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			if (++textureIndex >= 64)
			{
				textureIndex = 0;
			}
			float value = Random.value;
			float value2 = Random.value;
			if (noiseTextures == null)
			{
				LoadNoiseTextures();
			}
			Texture2D texture2D = noiseTextures[textureIndex];
			uberMaterial.EnableKeyword("DITHERING");
			uberMaterial.SetTexture(Uniforms._DitheringTex, texture2D);
			uberMaterial.SetVector(Uniforms._DitheringCoords, new Vector4((float)context.width / (float)texture2D.width, (float)context.height / (float)texture2D.height, value, value2));
		}
	}
	public sealed class EyeAdaptationComponent : PostProcessingComponentRenderTexture<EyeAdaptationModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Params = Shader.PropertyToID("_Params");

			internal static readonly int _Speed = Shader.PropertyToID("_Speed");

			internal static readonly int _ExposureCompensation = Shader.PropertyToID("_ExposureCompensation");

			internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

			internal static readonly int _DebugWidth = Shader.PropertyToID("_DebugWidth");

			internal static readonly int _Histogram = Shader.PropertyToID("_Histogram");

			internal static readonly int _Source = Shader.PropertyToID("_Source");

			internal static readonly int _ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");
		}

		private ComputeShader m_EyeCompute;

		private ComputeBuffer m_HistogramBuffer;

		private readonly RenderTexture[] m_AutoExposurePool = new RenderTexture[2];

		private int m_AutoExposurePingPing;

		private RenderTexture m_CurrentAutoExposure;

		private RenderTexture m_DebugHistogram;

		private int m_FrameCount;

		private const int k_HistogramBins = 64;

		private const int k_HistogramThreadX = 16;

		private const int k_HistogramThreadY = 16;

		public override bool active
		{
			get
			{
				if (base.model.enabled && SystemInfo.supportsComputeShaders)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void ResetHistory()
		{
			m_FrameCount = 0;
		}

		public override void OnEnable()
		{
			m_FrameCount = 0;
		}

		public override void OnDisable()
		{
			RenderTexture[] autoExposurePool = m_AutoExposurePool;
			for (int i = 0; i < autoExposurePool.Length; i++)
			{
				GraphicsUtils.Destroy(autoExposurePool[i]);
			}
			if (m_HistogramBuffer != null)
			{
				m_HistogramBuffer.Release();
			}
			m_HistogramBuffer = null;
			if (m_DebugHistogram != null)
			{
				m_DebugHistogram.Release();
			}
			m_DebugHistogram = null;
		}

		private Vector4 GetHistogramScaleOffsetRes()
		{
			EyeAdaptationModel.Settings settings = base.model.settings;
			float num = settings.logMax - settings.logMin;
			float num2 = 1f / num;
			float y = (float)(-settings.logMin) * num2;
			return new Vector4(num2, y, Mathf.Floor((float)context.width / 2f), Mathf.Floor((float)context.height / 2f));
		}

		public Texture Prepare(RenderTexture source, Material uberMaterial)
		{
			EyeAdaptationModel.Settings settings = base.model.settings;
			if (m_EyeCompute == null)
			{
				m_EyeCompute = Resources.Load<ComputeShader>("Shaders/EyeHistogram");
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Eye Adaptation");
			material.shaderKeywords = null;
			if (m_HistogramBuffer == null)
			{
				m_HistogramBuffer = new ComputeBuffer(64, 4);
			}
			Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes();
			RenderTexture renderTexture = context.renderTextureFactory.Get((int)histogramScaleOffsetRes.z, (int)histogramScaleOffsetRes.w, 0, source.format);
			Graphics.Blit(source, renderTexture);
			if (m_AutoExposurePool[0] == null || !m_AutoExposurePool[0].IsCreated())
			{
				m_AutoExposurePool[0] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
			}
			if (m_AutoExposurePool[1] == null || !m_AutoExposurePool[1].IsCreated())
			{
				m_AutoExposurePool[1] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
			}
			int kernelIndex = m_EyeCompute.FindKernel("KEyeHistogramClear");
			m_EyeCompute.SetBuffer(kernelIndex, Uniforms._Histogram, m_HistogramBuffer);
			m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt(4f), 1, 1);
			kernelIndex = m_EyeCompute.FindKernel("KEyeHistogram");
			m_EyeCompute.SetBuffer(kernelIndex, Uniforms._Histogram, m_HistogramBuffer);
			m_EyeCompute.SetTexture(kernelIndex, Uniforms._Source, renderTexture);
			m_EyeCompute.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
			m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt((float)renderTexture.width / 16f), Mathf.CeilToInt((float)renderTexture.height / 16f), 1);
			context.renderTextureFactory.Release(renderTexture);
			settings.highPercent = Mathf.Clamp(settings.highPercent, 1.01f, 99f);
			settings.lowPercent = Mathf.Clamp(settings.lowPercent, 1f, settings.highPercent - 0.01f);
			material.SetBuffer(Uniforms._Histogram, m_HistogramBuffer);
			material.SetVector(Uniforms._Params, new Vector4(settings.lowPercent * 0.01f, settings.highPercent * 0.01f, Mathf.Exp(settings.minLuminance * 0.6931472f), Mathf.Exp(settings.maxLuminance * 0.6931472f)));
			material.SetVector(Uniforms._Speed, new Vector2(settings.speedDown, settings.speedUp));
			material.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
			material.SetFloat(Uniforms._ExposureCompensation, settings.keyValue);
			if (settings.dynamicKeyValue)
			{
				material.EnableKeyword("AUTO_KEY_VALUE");
			}
			if (m_FrameCount < 2 || !Application.isPlaying)
			{
				m_CurrentAutoExposure = m_AutoExposurePool[0];
				Graphics.Blit(null, m_CurrentAutoExposure, material, 1);
				Graphics.Blit(m_AutoExposurePool[0], m_AutoExposurePool[1]);
			}
			else
			{
				int autoExposurePingPing = m_AutoExposurePingPing;
				RenderTexture source2 = m_AutoExposurePool[++autoExposurePingPing % 2];
				RenderTexture renderTexture2 = m_AutoExposurePool[++autoExposurePingPing % 2];
				Graphics.Blit(source2, renderTexture2, material, (int)settings.adaptationType);
				m_AutoExposurePingPing = ++autoExposurePingPing % 2;
				m_CurrentAutoExposure = renderTexture2;
			}
			if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
			{
				if (m_DebugHistogram == null || !m_DebugHistogram.IsCreated())
				{
					m_DebugHistogram = new RenderTexture(256, 128, 0, RenderTextureFormat.ARGB32)
					{
						filterMode = FilterMode.Point,
						wrapMode = TextureWrapMode.Clamp
					};
				}
				material.SetFloat(Uniforms._DebugWidth, m_DebugHistogram.width);
				Graphics.Blit(null, m_DebugHistogram, material, 2);
			}
			m_FrameCount++;
			return m_CurrentAutoExposure;
		}

		public void OnGUI()
		{
			if (!(m_DebugHistogram == null) && m_DebugHistogram.IsCreated())
			{
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, m_DebugHistogram.width, m_DebugHistogram.height), m_DebugHistogram);
			}
		}
	}
	public sealed class FogComponent : PostProcessingComponentCommandBuffer<FogModel>
	{
		private static class Uniforms
		{
			internal static readonly int _FogColor = Shader.PropertyToID("_FogColor");

			internal static readonly int _Density = Shader.PropertyToID("_Density");

			internal static readonly int _Start = Shader.PropertyToID("_Start");

			internal static readonly int _End = Shader.PropertyToID("_End");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
		}

		private const string k_ShaderString = "Hidden/Post FX/Fog";

		public override bool active
		{
			get
			{
				if (base.model.enabled && context.isGBufferAvailable && RenderSettings.fog)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override string GetName()
		{
			return "Fog";
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.AfterImageEffectsOpaque;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			FogModel.Settings settings = base.model.settings;
			Material material = context.materialFactory.Get("Hidden/Post FX/Fog");
			material.shaderKeywords = null;
			Color value = (GraphicsUtils.isLinearColorSpace ? RenderSettings.fogColor.linear : RenderSettings.fogColor);
			material.SetColor(Uniforms._FogColor, value);
			material.SetFloat(Uniforms._Density, RenderSettings.fogDensity);
			material.SetFloat(Uniforms._Start, RenderSettings.fogStartDistance);
			material.SetFloat(Uniforms._End, RenderSettings.fogEndDistance);
			switch (RenderSettings.fogMode)
			{
			case FogMode.Linear:
				material.EnableKeyword("FOG_LINEAR");
				break;
			case FogMode.Exponential:
				material.EnableKeyword("FOG_EXP");
				break;
			case FogMode.ExponentialSquared:
				material.EnableKeyword("FOG_EXP2");
				break;
			}
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			cb.GetTemporaryRT(Uniforms._TempRT, context.width, context.height, 24, FilterMode.Bilinear, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, Uniforms._TempRT);
			cb.Blit(Uniforms._TempRT, BuiltinRenderTextureType.CameraTarget, material, settings.excludeSkybox ? 1 : 0);
			cb.ReleaseTemporaryRT(Uniforms._TempRT);
		}
	}
	public sealed class FxaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
	{
		private static class Uniforms
		{
			internal static readonly int _QualitySettings = Shader.PropertyToID("_QualitySettings");

			internal static readonly int _ConsoleSettings = Shader.PropertyToID("_ConsoleSettings");
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Fxaa)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public void Render(RenderTexture source, RenderTexture destination)
		{
			AntialiasingModel.FxaaSettings fxaaSettings = base.model.settings.fxaaSettings;
			Material material = context.materialFactory.Get("Hidden/Post FX/FXAA");
			AntialiasingModel.FxaaQualitySettings fxaaQualitySettings = AntialiasingModel.FxaaQualitySettings.presets[(int)fxaaSettings.preset];
			AntialiasingModel.FxaaConsoleSettings fxaaConsoleSettings = AntialiasingModel.FxaaConsoleSettings.presets[(int)fxaaSettings.preset];
			material.SetVector(Uniforms._QualitySettings, new Vector3(fxaaQualitySettings.subpixelAliasingRemovalAmount, fxaaQualitySettings.edgeDetectionThreshold, fxaaQualitySettings.minimumRequiredLuminance));
			material.SetVector(Uniforms._ConsoleSettings, new Vector4(fxaaConsoleSettings.subpixelSpreadAmount, fxaaConsoleSettings.edgeSharpnessAmount, fxaaConsoleSettings.edgeDetectionThreshold, fxaaConsoleSettings.minimumRequiredLuminance));
			Graphics.Blit(source, destination, material, 0);
		}
	}
	public sealed class GrainComponent : PostProcessingComponentRenderTexture<GrainModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

			internal static readonly int _Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

			internal static readonly int _GrainTex = Shader.PropertyToID("_GrainTex");

			internal static readonly int _Phase = Shader.PropertyToID("_Phase");
		}

		private RenderTexture m_GrainLookupRT;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.intensity > 0f && SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void OnDisable()
		{
			GraphicsUtils.Destroy(m_GrainLookupRT);
			m_GrainLookupRT = null;
		}

		public override void Prepare(Material uberMaterial)
		{
			GrainModel.Settings settings = base.model.settings;
			uberMaterial.EnableKeyword("GRAIN");
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			float value = Random.value;
			float value2 = Random.value;
			if (m_GrainLookupRT == null || !m_GrainLookupRT.IsCreated())
			{
				GraphicsUtils.Destroy(m_GrainLookupRT);
				m_GrainLookupRT = new RenderTexture(192, 192, 0, RenderTextureFormat.ARGBHalf)
				{
					filterMode = FilterMode.Bilinear,
					wrapMode = TextureWrapMode.Repeat,
					anisoLevel = 0,
					name = "Grain Lookup Texture"
				};
				m_GrainLookupRT.Create();
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Grain Generator");
			material.SetFloat(Uniforms._Phase, realtimeSinceStartup / 20f);
			Graphics.Blit(null, m_GrainLookupRT, material, settings.colored ? 1 : 0);
			uberMaterial.SetTexture(Uniforms._GrainTex, m_GrainLookupRT);
			uberMaterial.SetVector(Uniforms._Grain_Params1, new Vector2(settings.luminanceContribution, settings.intensity * 20f));
			uberMaterial.SetVector(Uniforms._Grain_Params2, new Vector4((float)context.width / (float)m_GrainLookupRT.width / settings.size, (float)context.height / (float)m_GrainLookupRT.height / settings.size, value, value2));
		}
	}
	public sealed class MotionBlurComponent : PostProcessingComponentCommandBuffer<MotionBlurModel>
	{
		private static class Uniforms
		{
			internal static readonly int _VelocityScale = Shader.PropertyToID("_VelocityScale");

			internal static readonly int _MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

			internal static readonly int _RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

			internal static readonly int _VelocityTex = Shader.PropertyToID("_VelocityTex");

			internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

			internal static readonly int _Tile2RT = Shader.PropertyToID("_Tile2RT");

			internal static readonly int _Tile4RT = Shader.PropertyToID("_Tile4RT");

			internal static readonly int _Tile8RT = Shader.PropertyToID("_Tile8RT");

			internal static readonly int _TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

			internal static readonly int _TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

			internal static readonly int _TileVRT = Shader.PropertyToID("_TileVRT");

			internal static readonly int _NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

			internal static readonly int _LoopCount = Shader.PropertyToID("_LoopCount");

			internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

			internal static readonly int _History1LumaTex = Shader.PropertyToID("_History1LumaTex");

			internal static readonly int _History2LumaTex = Shader.PropertyToID("_History2LumaTex");

			internal static readonly int _History3LumaTex = Shader.PropertyToID("_History3LumaTex");

			internal static readonly int _History4LumaTex = Shader.PropertyToID("_History4LumaTex");

			internal static readonly int _History1ChromaTex = Shader.PropertyToID("_History1ChromaTex");

			internal static readonly int _History2ChromaTex = Shader.PropertyToID("_History2ChromaTex");

			internal static readonly int _History3ChromaTex = Shader.PropertyToID("_History3ChromaTex");

			internal static readonly int _History4ChromaTex = Shader.PropertyToID("_History4ChromaTex");

			internal static readonly int _History1Weight = Shader.PropertyToID("_History1Weight");

			internal static readonly int _History2Weight = Shader.PropertyToID("_History2Weight");

			internal static readonly int _History3Weight = Shader.PropertyToID("_History3Weight");

			internal static readonly int _History4Weight = Shader.PropertyToID("_History4Weight");
		}

		private enum Pass
		{
			VelocitySetup,
			TileMax1,
			TileMax2,
			TileMaxV,
			NeighborMax,
			Reconstruction,
			FrameCompression,
			FrameBlendingChroma,
			FrameBlendingRaw
		}

		public class ReconstructionFilter
		{
			private RenderTextureFormat m_VectorRTFormat = RenderTextureFormat.RGHalf;

			private RenderTextureFormat m_PackedRTFormat = RenderTextureFormat.ARGB2101010;

			public ReconstructionFilter()
			{
				CheckTextureFormatSupport();
			}

			private void CheckTextureFormatSupport()
			{
				if (!SystemInfo.SupportsRenderTextureFormat(m_PackedRTFormat))
				{
					m_PackedRTFormat = RenderTextureFormat.ARGB32;
				}
			}

			public bool IsSupported()
			{
				return SystemInfo.supportsMotionVectors;
			}

			public void ProcessImage(PostProcessingContext context, CommandBuffer cb, ref MotionBlurModel.Settings settings, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
			{
				int num = (int)(5f * (float)context.height / 100f);
				int num2 = ((num - 1) / 8 + 1) * 8;
				float value = settings.shutterAngle / 360f;
				cb.SetGlobalFloat(Uniforms._VelocityScale, value);
				cb.SetGlobalFloat(Uniforms._MaxBlurRadius, num);
				cb.SetGlobalFloat(Uniforms._RcpMaxBlurRadius, 1f / (float)num);
				int velocityTex = Uniforms._VelocityTex;
				cb.GetTemporaryRT(velocityTex, context.width, context.height, 0, FilterMode.Point, m_PackedRTFormat, RenderTextureReadWrite.Linear);
				cb.Blit(null, velocityTex, material, 0);
				int tile2RT = Uniforms._Tile2RT;
				cb.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, velocityTex);
				cb.Blit(velocityTex, tile2RT, material, 1);
				int tile4RT = Uniforms._Tile4RT;
				cb.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile2RT);
				cb.Blit(tile2RT, tile4RT, material, 2);
				cb.ReleaseTemporaryRT(tile2RT);
				int tile8RT = Uniforms._Tile8RT;
				cb.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile4RT);
				cb.Blit(tile4RT, tile8RT, material, 2);
				cb.ReleaseTemporaryRT(tile4RT);
				Vector2 vector = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
				cb.SetGlobalVector(Uniforms._TileMaxOffs, vector);
				cb.SetGlobalFloat(Uniforms._TileMaxLoop, (int)((float)num2 / 8f));
				int tileVRT = Uniforms._TileVRT;
				cb.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tile8RT);
				cb.Blit(tile8RT, tileVRT, material, 3);
				cb.ReleaseTemporaryRT(tile8RT);
				int neighborMaxTex = Uniforms._NeighborMaxTex;
				int width = context.width / num2;
				int height = context.height / num2;
				cb.GetTemporaryRT(neighborMaxTex, width, height, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, tileVRT);
				cb.Blit(tileVRT, neighborMaxTex, material, 4);
				cb.ReleaseTemporaryRT(tileVRT);
				cb.SetGlobalFloat(Uniforms._LoopCount, Mathf.Clamp(settings.sampleCount / 2, 1, 64));
				cb.SetGlobalTexture(Uniforms._MainTex, source);
				cb.Blit(source, destination, material, 5);
				cb.ReleaseTemporaryRT(velocityTex);
				cb.ReleaseTemporaryRT(neighborMaxTex);
			}
		}

		public class FrameBlendingFilter
		{
			private struct Frame
			{
				public RenderTexture lumaTexture;

				public RenderTexture chromaTexture;

				private float m_Time;

				private RenderTargetIdentifier[] m_MRT;

				public float CalculateWeight(float strength, float currentTime)
				{
					if (Mathf.Approximately(m_Time, 0f))
					{
						return 0f;
					}
					float num = Mathf.Lerp(80f, 16f, strength);
					return Mathf.Exp((m_Time - currentTime) * num);
				}

				public void Release()
				{
					if (lumaTexture != null)
					{
						RenderTexture.ReleaseTemporary(lumaTexture);
					}
					if (chromaTexture != null)
					{
						RenderTexture.ReleaseTemporary(chromaTexture);
					}
					lumaTexture = null;
					chromaTexture = null;
				}

				public void MakeRecord(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
				{
					Release();
					lumaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
					chromaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
					lumaTexture.filterMode = FilterMode.Point;
					chromaTexture.filterMode = FilterMode.Point;
					if (m_MRT == null)
					{
						m_MRT = new RenderTargetIdentifier[2];
					}
					m_MRT[0] = lumaTexture;
					m_MRT[1] = chromaTexture;
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.SetRenderTarget(m_MRT, lumaTexture);
					cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 6);
					m_Time = Time.time;
				}

				public void MakeRecordRaw(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, RenderTextureFormat format)
				{
					Release();
					lumaTexture = RenderTexture.GetTemporary(width, height, 0, format);
					lumaTexture.filterMode = FilterMode.Point;
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, lumaTexture);
					m_Time = Time.time;
				}
			}

			private bool m_UseCompression;

			private RenderTextureFormat m_RawTextureFormat;

			private Frame[] m_FrameList;

			private int m_LastFrameCount;

			public FrameBlendingFilter()
			{
				m_UseCompression = CheckSupportCompression();
				m_RawTextureFormat = GetPreferredRenderTextureFormat();
				m_FrameList = new Frame[4];
			}

			public void Dispose()
			{
				Frame[] frameList = m_FrameList;
				foreach (Frame frame in frameList)
				{
					frame.Release();
				}
			}

			public void PushFrame(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
			{
				int frameCount = Time.frameCount;
				if (frameCount != m_LastFrameCount)
				{
					int num = frameCount % m_FrameList.Length;
					if (m_UseCompression)
					{
						m_FrameList[num].MakeRecord(cb, source, width, height, material);
					}
					else
					{
						m_FrameList[num].MakeRecordRaw(cb, source, width, height, m_RawTextureFormat);
					}
					m_LastFrameCount = frameCount;
				}
			}

			public void BlendFrames(CommandBuffer cb, float strength, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
			{
				float time = Time.time;
				Frame frameRelative = GetFrameRelative(-1);
				Frame frameRelative2 = GetFrameRelative(-2);
				Frame frameRelative3 = GetFrameRelative(-3);
				Frame frameRelative4 = GetFrameRelative(-4);
				cb.SetGlobalTexture(Uniforms._History1LumaTex, frameRelative.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History2LumaTex, frameRelative2.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History3LumaTex, frameRelative3.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History4LumaTex, frameRelative4.lumaTexture);
				cb.SetGlobalTexture(Uniforms._History1ChromaTex, frameRelative.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History2ChromaTex, frameRelative2.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History3ChromaTex, frameRelative3.chromaTexture);
				cb.SetGlobalTexture(Uniforms._History4ChromaTex, frameRelative4.chromaTexture);
				cb.SetGlobalFloat(Uniforms._History1Weight, frameRelative.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History2Weight, frameRelative2.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History3Weight, frameRelative3.CalculateWeight(strength, time));
				cb.SetGlobalFloat(Uniforms._History4Weight, frameRelative4.CalculateWeight(strength, time));
				cb.SetGlobalTexture(Uniforms._MainTex, source);
				cb.Blit(source, destination, material, m_UseCompression ? 7 : 8);
			}

			private static bool CheckSupportCompression()
			{
				if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.R8))
				{
					return SystemInfo.supportedRenderTargetCount > 1;
				}
				return false;
			}

			private static RenderTextureFormat GetPreferredRenderTextureFormat()
			{
				RenderTextureFormat[] array = new RenderTextureFormat[3]
				{
					RenderTextureFormat.RGB565,
					RenderTextureFormat.ARGB1555,
					RenderTextureFormat.ARGB4444
				};
				foreach (RenderTextureFormat renderTextureFormat in array)
				{
					if (SystemInfo.SupportsRenderTextureFormat(renderTextureFormat))
					{
						return renderTextureFormat;
					}
				}
				return RenderTextureFormat.Default;
			}

			private Frame GetFrameRelative(int offset)
			{
				int num = (Time.frameCount + m_FrameList.Length + offset) % m_FrameList.Length;
				return m_FrameList[num];
			}
		}

		private ReconstructionFilter m_ReconstructionFilter;

		private FrameBlendingFilter m_FrameBlendingFilter;

		private int m_FrameCount;

		public ReconstructionFilter reconstructionFilter
		{
			get
			{
				if (m_ReconstructionFilter == null)
				{
					m_ReconstructionFilter = new ReconstructionFilter();
				}
				return m_ReconstructionFilter;
			}
		}

		public FrameBlendingFilter frameBlendingFilter
		{
			get
			{
				if (m_FrameBlendingFilter == null)
				{
					m_FrameBlendingFilter = new FrameBlendingFilter();
				}
				return m_FrameBlendingFilter;
			}
		}

		public override bool active
		{
			get
			{
				MotionBlurModel.Settings settings = base.model.settings;
				if (base.model.enabled && ((settings.shutterAngle > 0f && reconstructionFilter.IsSupported()) || settings.frameBlending > 0f) && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override string GetName()
		{
			return "Motion Blur";
		}

		public void ResetHistory()
		{
			if (m_FrameBlendingFilter != null)
			{
				m_FrameBlendingFilter.Dispose();
			}
			m_FrameBlendingFilter = null;
			m_FrameCount = 0;
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.BeforeImageEffects;
		}

		public override void OnEnable()
		{
			m_FrameCount = 0;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			if (m_FrameCount < 2)
			{
				m_FrameCount++;
				return;
			}
			Material material = context.materialFactory.Get("Hidden/Post FX/Motion Blur");
			Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
			MotionBlurModel.Settings settings = base.model.settings;
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			int tempRT = Uniforms._TempRT;
			cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Point, format);
			if (settings.shutterAngle > 0f && settings.frameBlending > 0f)
			{
				reconstructionFilter.ProcessImage(context, cb, ref settings, BuiltinRenderTextureType.CameraTarget, tempRT, material);
				frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
			}
			else if (settings.shutterAngle > 0f)
			{
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				reconstructionFilter.ProcessImage(context, cb, ref settings, tempRT, BuiltinRenderTextureType.CameraTarget, material);
			}
			else if (settings.frameBlending > 0f)
			{
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
				frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
			}
			cb.ReleaseTemporaryRT(tempRT);
		}

		public override void OnDisable()
		{
			if (m_FrameBlendingFilter != null)
			{
				m_FrameBlendingFilter.Dispose();
			}
		}
	}
	public sealed class ScreenSpaceReflectionComponent : PostProcessingComponentCommandBuffer<ScreenSpaceReflectionModel>
	{
		private static class Uniforms
		{
			internal static readonly int _RayStepSize = Shader.PropertyToID("_RayStepSize");

			internal static readonly int _AdditiveReflection = Shader.PropertyToID("_AdditiveReflection");

			internal static readonly int _BilateralUpsampling = Shader.PropertyToID("_BilateralUpsampling");

			internal static readonly int _TreatBackfaceHitAsMiss = Shader.PropertyToID("_TreatBackfaceHitAsMiss");

			internal static readonly int _AllowBackwardsRays = Shader.PropertyToID("_AllowBackwardsRays");

			internal static readonly int _TraceBehindObjects = Shader.PropertyToID("_TraceBehindObjects");

			internal static readonly int _MaxSteps = Shader.PropertyToID("_MaxSteps");

			internal static readonly int _FullResolutionFiltering = Shader.PropertyToID("_FullResolutionFiltering");

			internal static readonly int _HalfResolution = Shader.PropertyToID("_HalfResolution");

			internal static readonly int _HighlightSuppression = Shader.PropertyToID("_HighlightSuppression");

			internal static readonly int _PixelsPerMeterAtOneMeter = Shader.PropertyToID("_PixelsPerMeterAtOneMeter");

			internal static readonly int _ScreenEdgeFading = Shader.PropertyToID("_ScreenEdgeFading");

			internal static readonly int _ReflectionBlur = Shader.PropertyToID("_ReflectionBlur");

			internal static readonly int _MaxRayTraceDistance = Shader.PropertyToID("_MaxRayTraceDistance");

			internal static readonly int _FadeDistance = Shader.PropertyToID("_FadeDistance");

			internal static readonly int _LayerThickness = Shader.PropertyToID("_LayerThickness");

			internal static readonly int _SSRMultiplier = Shader.PropertyToID("_SSRMultiplier");

			internal static readonly int _FresnelFade = Shader.PropertyToID("_FresnelFade");

			internal static readonly int _FresnelFadePower = Shader.PropertyToID("_FresnelFadePower");

			internal static readonly int _ReflectionBufferSize = Shader.PropertyToID("_ReflectionBufferSize");

			internal static readonly int _ScreenSize = Shader.PropertyToID("_ScreenSize");

			internal static readonly int _InvScreenSize = Shader.PropertyToID("_InvScreenSize");

			internal static readonly int _ProjInfo = Shader.PropertyToID("_ProjInfo");

			internal static readonly int _CameraClipInfo = Shader.PropertyToID("_CameraClipInfo");

			internal static readonly int _ProjectToPixelMatrix = Shader.PropertyToID("_ProjectToPixelMatrix");

			internal static readonly int _WorldToCameraMatrix = Shader.PropertyToID("_WorldToCameraMatrix");

			internal static readonly int _CameraToWorldMatrix = Shader.PropertyToID("_CameraToWorldMatrix");

			internal static readonly int _Axis = Shader.PropertyToID("_Axis");

			internal static readonly int _CurrentMipLevel = Shader.PropertyToID("_CurrentMipLevel");

			internal static readonly int _NormalAndRoughnessTexture = Shader.PropertyToID("_NormalAndRoughnessTexture");

			internal static readonly int _HitPointTexture = Shader.PropertyToID("_HitPointTexture");

			internal static readonly int _BlurTexture = Shader.PropertyToID("_BlurTexture");

			internal static readonly int _FilteredReflections = Shader.PropertyToID("_FilteredReflections");

			internal static readonly int _FinalReflectionTexture = Shader.PropertyToID("_FinalReflectionTexture");

			internal static readonly int _TempTexture = Shader.PropertyToID("_TempTexture");
		}

		private enum PassIndex
		{
			RayTraceStep,
			CompositeFinal,
			Blur,
			CompositeSSR,
			MinMipGeneration,
			HitPointToReflections,
			BilateralKeyPack,
			BlitDepthAsCSZ,
			PoissonBlur
		}

		private bool k_HighlightSuppression;

		private bool k_TraceBehindObjects = true;

		private bool k_TreatBackfaceHitAsMiss;

		private bool k_BilateralUpsample = true;

		private readonly int[] m_ReflectionTextures = new int[5];

		public override bool active
		{
			get
			{
				if (base.model.enabled && context.isGBufferAvailable)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth;
		}

		public override void OnEnable()
		{
			m_ReflectionTextures[0] = Shader.PropertyToID("_ReflectionTexture0");
			m_ReflectionTextures[1] = Shader.PropertyToID("_ReflectionTexture1");
			m_ReflectionTextures[2] = Shader.PropertyToID("_ReflectionTexture2");
			m_ReflectionTextures[3] = Shader.PropertyToID("_ReflectionTexture3");
			m_ReflectionTextures[4] = Shader.PropertyToID("_ReflectionTexture4");
		}

		public override string GetName()
		{
			return "Screen Space Reflection";
		}

		public override CameraEvent GetCameraEvent()
		{
			return CameraEvent.AfterFinalPass;
		}

		public override void PopulateCommandBuffer(CommandBuffer cb)
		{
			ScreenSpaceReflectionModel.Settings settings = base.model.settings;
			Camera camera = context.camera;
			int num = ((settings.reflection.reflectionQuality == ScreenSpaceReflectionModel.SSRResolution.High) ? 1 : 2);
			int num2 = context.width / num;
			int num3 = context.height / num;
			float num4 = context.width;
			float num5 = context.height;
			float num6 = num4 / 2f;
			float num7 = num5 / 2f;
			Material material = context.materialFactory.Get("Hidden/Post FX/Screen Space Reflection");
			material.SetInt(Uniforms._RayStepSize, settings.reflection.stepSize);
			material.SetInt(Uniforms._AdditiveReflection, (settings.reflection.blendType == ScreenSpaceReflectionModel.SSRReflectionBlendType.Additive) ? 1 : 0);
			material.SetInt(Uniforms._BilateralUpsampling, k_BilateralUpsample ? 1 : 0);
			material.SetInt(Uniforms._TreatBackfaceHitAsMiss, k_TreatBackfaceHitAsMiss ? 1 : 0);
			material.SetInt(Uniforms._AllowBackwardsRays, settings.reflection.reflectBackfaces ? 1 : 0);
			material.SetInt(Uniforms._TraceBehindObjects, k_TraceBehindObjects ? 1 : 0);
			material.SetInt(Uniforms._MaxSteps, settings.reflection.iterationCount);
			material.SetInt(Uniforms._FullResolutionFiltering, 0);
			material.SetInt(Uniforms._HalfResolution, (settings.reflection.reflectionQuality != 0) ? 1 : 0);
			material.SetInt(Uniforms._HighlightSuppression, k_HighlightSuppression ? 1 : 0);
			float value = num4 / (-2f * Mathf.Tan(camera.fieldOfView / 180f * (float)Math.PI * 0.5f));
			material.SetFloat(Uniforms._PixelsPerMeterAtOneMeter, value);
			material.SetFloat(Uniforms._ScreenEdgeFading, settings.screenEdgeMask.intensity);
			material.SetFloat(Uniforms._ReflectionBlur, settings.reflection.reflectionBlur);
			material.SetFloat(Uniforms._MaxRayTraceDistance, settings.reflection.maxDistance);
			material.SetFloat(Uniforms._FadeDistance, settings.intensity.fadeDistance);
			material.SetFloat(Uniforms._LayerThickness, settings.reflection.widthModifier);
			material.SetFloat(Uniforms._SSRMultiplier, settings.intensity.reflectionMultiplier);
			material.SetFloat(Uniforms._FresnelFade, settings.intensity.fresnelFade);
			material.SetFloat(Uniforms._FresnelFadePower, settings.intensity.fresnelFadePower);
			Matrix4x4 projectionMatrix = camera.projectionMatrix;
			Vector4 value2 = new Vector4(-2f / (num4 * projectionMatrix[0]), -2f / (num5 * projectionMatrix[5]), (1f - projectionMatrix[2]) / projectionMatrix[0], (1f + projectionMatrix[6]) / projectionMatrix[5]);
			Vector3 vector = (float.IsPositiveInfinity(camera.farClipPlane) ? new Vector3(camera.nearClipPlane, -1f, 1f) : new Vector3(camera.nearClipPlane * camera.farClipPlane, camera.nearClipPlane - camera.farClipPlane, camera.farClipPlane));
			material.SetVector(Uniforms._ReflectionBufferSize, new Vector2(num2, num3));
			material.SetVector(Uniforms._ScreenSize, new Vector2(num4, num5));
			material.SetVector(Uniforms._InvScreenSize, new Vector2(1f / num4, 1f / num5));
			material.SetVector(Uniforms._ProjInfo, value2);
			material.SetVector(Uniforms._CameraClipInfo, vector);
			Matrix4x4 matrix4x = default(Matrix4x4);
			matrix4x.SetRow(0, new Vector4(num6, 0f, 0f, num6));
			matrix4x.SetRow(1, new Vector4(0f, num7, 0f, num7));
			matrix4x.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
			matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
			Matrix4x4 value3 = matrix4x * projectionMatrix;
			material.SetMatrix(Uniforms._ProjectToPixelMatrix, value3);
			material.SetMatrix(Uniforms._WorldToCameraMatrix, camera.worldToCameraMatrix);
			material.SetMatrix(Uniforms._CameraToWorldMatrix, camera.worldToCameraMatrix.inverse);
			RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
			int normalAndRoughnessTexture = Uniforms._NormalAndRoughnessTexture;
			int hitPointTexture = Uniforms._HitPointTexture;
			int blurTexture = Uniforms._BlurTexture;
			int filteredReflections = Uniforms._FilteredReflections;
			int finalReflectionTexture = Uniforms._FinalReflectionTexture;
			int tempTexture = Uniforms._TempTexture;
			cb.GetTemporaryRT(normalAndRoughnessTexture, -1, -1, 0, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
			cb.GetTemporaryRT(hitPointTexture, num2, num3, 0, FilterMode.Bilinear, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
			for (int i = 0; i < 5; i++)
			{
				cb.GetTemporaryRT(m_ReflectionTextures[i], num2 >> i, num3 >> i, 0, FilterMode.Bilinear, format);
			}
			cb.GetTemporaryRT(filteredReflections, num2, num3, 0, (!k_BilateralUpsample) ? FilterMode.Bilinear : FilterMode.Point, format);
			cb.GetTemporaryRT(finalReflectionTexture, num2, num3, 0, FilterMode.Point, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, normalAndRoughnessTexture, material, 6);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, hitPointTexture, material, 0);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, filteredReflections, material, 5);
			cb.Blit(filteredReflections, m_ReflectionTextures[0], material, 8);
			for (int j = 1; j < 5; j++)
			{
				int num8 = m_ReflectionTextures[j - 1];
				int num9 = j;
				cb.GetTemporaryRT(blurTexture, num2 >> num9, num3 >> num9, 0, FilterMode.Bilinear, format);
				cb.SetGlobalVector(Uniforms._Axis, new Vector4(1f, 0f, 0f, 0f));
				cb.SetGlobalFloat(Uniforms._CurrentMipLevel, (float)j - 1f);
				cb.Blit(num8, blurTexture, material, 2);
				cb.SetGlobalVector(Uniforms._Axis, new Vector4(0f, 1f, 0f, 0f));
				num8 = m_ReflectionTextures[j];
				cb.Blit(blurTexture, num8, material, 2);
				cb.ReleaseTemporaryRT(blurTexture);
			}
			cb.Blit(m_ReflectionTextures[0], finalReflectionTexture, material, 3);
			cb.GetTemporaryRT(tempTexture, camera.pixelWidth, camera.pixelHeight, 0, FilterMode.Bilinear, format);
			cb.Blit(BuiltinRenderTextureType.CameraTarget, tempTexture, material, 1);
			cb.Blit(tempTexture, BuiltinRenderTextureType.CameraTarget);
			cb.ReleaseTemporaryRT(tempTexture);
		}
	}
	public sealed class TaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
	{
		private static class Uniforms
		{
			internal static int _Jitter = Shader.PropertyToID("_Jitter");

			internal static int _SharpenParameters = Shader.PropertyToID("_SharpenParameters");

			internal static int _FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

			internal static int _HistoryTex = Shader.PropertyToID("_HistoryTex");

			internal static int _MainTex = Shader.PropertyToID("_MainTex");
		}

		private const string k_ShaderString = "Hidden/Post FX/Temporal Anti-aliasing";

		private const int k_SampleCount = 8;

		private readonly RenderBuffer[] m_MRT = new RenderBuffer[2];

		private int m_SampleIndex;

		private bool m_ResetHistory = true;

		private RenderTexture m_HistoryTexture;

		public override bool active
		{
			get
			{
				if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Taa && SystemInfo.supportsMotionVectors && SystemInfo.supportedRenderTargetCount >= 2)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public Vector2 jitterVector { get; private set; }

		public override DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
		}

		public void ResetHistory()
		{
			m_ResetHistory = true;
		}

		public void SetProjectionMatrix(Func<Vector2, Matrix4x4> jitteredFunc)
		{
			AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
			Vector2 vector = GenerateRandomOffset();
			vector *= taaSettings.jitterSpread;
			context.camera.nonJitteredProjectionMatrix = context.camera.projectionMatrix;
			if (jitteredFunc != null)
			{
				context.camera.projectionMatrix = jitteredFunc(vector);
			}
			else
			{
				context.camera.projectionMatrix = (context.camera.orthographic ? GetOrthographicProjectionMatrix(vector) : GetPerspectiveProjectionMatrix(vector));
			}
			context.camera.useJitteredProjectionMatrixForTransparentRendering = false;
			vector.x /= context.width;
			vector.y /= context.height;
			context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing").SetVector(Uniforms._Jitter, vector);
			jitterVector = vector;
		}

		public void Render(RenderTexture source, RenderTexture destination)
		{
			Material material = context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing");
			material.shaderKeywords = null;
			AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
			if (m_ResetHistory || m_HistoryTexture == null || m_HistoryTexture.width != source.width || m_HistoryTexture.height != source.height)
			{
				if ((bool)m_HistoryTexture)
				{
					RenderTexture.ReleaseTemporary(m_HistoryTexture);
				}
				m_HistoryTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				m_HistoryTexture.name = "TAA History";
				Graphics.Blit(source, m_HistoryTexture, material, 2);
			}
			material.SetVector(Uniforms._SharpenParameters, new Vector4(taaSettings.sharpen, 0f, 0f, 0f));
			material.SetVector(Uniforms._FinalBlendParameters, new Vector4(taaSettings.stationaryBlending, taaSettings.motionBlending, 6000f, 0f));
			material.SetTexture(Uniforms._MainTex, source);
			material.SetTexture(Uniforms._HistoryTex, m_HistoryTexture);
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
			temporary.name = "TAA History";
			m_MRT[0] = destination.colorBuffer;
			m_MRT[1] = temporary.colorBuffer;
			Graphics.SetRenderTarget(m_MRT, source.depthBuffer);
			GraphicsUtils.Blit(material, context.camera.orthographic ? 1 : 0);
			RenderTexture.ReleaseTemporary(m_HistoryTexture);
			m_HistoryTexture = temporary;
			m_ResetHistory = false;
		}

		private float GetHaltonValue(int index, int radix)
		{
			float num = 0f;
			float num2 = 1f / (float)radix;
			while (index > 0)
			{
				num += (float)(index % radix) * num2;
				index /= radix;
				num2 /= (float)radix;
			}
			return num;
		}

		private Vector2 GenerateRandomOffset()
		{
			Vector2 result = new Vector2(GetHaltonValue(m_SampleIndex & 0x3FF, 2), GetHaltonValue(m_SampleIndex & 0x3FF, 3));
			if (++m_SampleIndex >= 8)
			{
				m_SampleIndex = 0;
			}
			return result;
		}

		private Matrix4x4 GetPerspectiveProjectionMatrix(Vector2 offset)
		{
			float num = Mathf.Tan((float)Math.PI / 360f * context.camera.fieldOfView);
			float num2 = num * context.camera.aspect;
			offset.x *= num2 / (0.5f * (float)context.width);
			offset.y *= num / (0.5f * (float)context.height);
			float num3 = (offset.x - num2) * context.camera.nearClipPlane;
			float num4 = (offset.x + num2) * context.camera.nearClipPlane;
			float num5 = (offset.y + num) * context.camera.nearClipPlane;
			float num6 = (offset.y - num) * context.camera.nearClipPlane;
			Matrix4x4 result = default(Matrix4x4);
			result[0, 0] = 2f * context.camera.nearClipPlane / (num4 - num3);
			result[0, 1] = 0f;
			result[0, 2] = (num4 + num3) / (num4 - num3);
			result[0, 3] = 0f;
			result[1, 0] = 0f;
			result[1, 1] = 2f * context.camera.nearClipPlane / (num5 - num6);
			result[1, 2] = (num5 + num6) / (num5 - num6);
			result[1, 3] = 0f;
			result[2, 0] = 0f;
			result[2, 1] = 0f;
			result[2, 2] = (0f - (context.camera.farClipPlane + context.camera.nearClipPlane)) / (context.camera.farClipPlane - context.camera.nearClipPlane);
			result[2, 3] = (0f - 2f * context.camera.farClipPlane * context.camera.nearClipPlane) / (context.camera.farClipPlane - context.camera.nearClipPlane);
			result[3, 0] = 0f;
			result[3, 1] = 0f;
			result[3, 2] = -1f;
			result[3, 3] = 0f;
			return result;
		}

		private Matrix4x4 GetOrthographicProjectionMatrix(Vector2 offset)
		{
			float orthographicSize = context.camera.orthographicSize;
			float num = orthographicSize * context.camera.aspect;
			offset.x *= num / (0.5f * (float)context.width);
			offset.y *= orthographicSize / (0.5f * (float)context.height);
			float left = offset.x - num;
			float right = offset.x + num;
			float top = offset.y + orthographicSize;
			float bottom = offset.y - orthographicSize;
			return Matrix4x4.Ortho(left, right, bottom, top, context.camera.nearClipPlane, context.camera.farClipPlane);
		}

		public override void OnDisable()
		{
			if (m_HistoryTexture != null)
			{
				RenderTexture.ReleaseTemporary(m_HistoryTexture);
			}
			context.camera.useJitteredProjectionMatrixForTransparentRendering = true;
			m_HistoryTexture = null;
			m_SampleIndex = 0;
			ResetHistory();
		}
	}
	public sealed class UserLutComponent : PostProcessingComponentRenderTexture<UserLutModel>
	{
		private static class Uniforms
		{
			internal static readonly int _UserLut = Shader.PropertyToID("_UserLut");

			internal static readonly int _UserLut_Params = Shader.PropertyToID("_UserLut_Params");
		}

		public override bool active
		{
			get
			{
				UserLutModel.Settings settings = base.model.settings;
				if (base.model.enabled && settings.lut != null && settings.contribution > 0f && settings.lut.height == (int)Mathf.Sqrt(settings.lut.width))
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			UserLutModel.Settings settings = base.model.settings;
			uberMaterial.EnableKeyword("USER_LUT");
			uberMaterial.SetTexture(Uniforms._UserLut, settings.lut);
			uberMaterial.SetVector(Uniforms._UserLut_Params, new Vector4(1f / (float)settings.lut.width, 1f / (float)settings.lut.height, (float)settings.lut.height - 1f, settings.contribution));
		}

		public void OnGUI()
		{
			UserLutModel.Settings settings = base.model.settings;
			GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, settings.lut.width, settings.lut.height), settings.lut);
		}
	}
	public sealed class VignetteComponent : PostProcessingComponentRenderTexture<VignetteModel>
	{
		private static class Uniforms
		{
			internal static readonly int _Vignette_Color = Shader.PropertyToID("_Vignette_Color");

			internal static readonly int _Vignette_Center = Shader.PropertyToID("_Vignette_Center");

			internal static readonly int _Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

			internal static readonly int _Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

			internal static readonly int _Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");
		}

		public override bool active
		{
			get
			{
				if (base.model.enabled)
				{
					return !context.interrupted;
				}
				return false;
			}
		}

		public override void Prepare(Material uberMaterial)
		{
			VignetteModel.Settings settings = base.model.settings;
			uberMaterial.SetColor(Uniforms._Vignette_Color, settings.color);
			if (settings.mode == VignetteModel.Mode.Classic)
			{
				uberMaterial.SetVector(Uniforms._Vignette_Center, settings.center);
				uberMaterial.EnableKeyword("VIGNETTE_CLASSIC");
				float z = (1f - settings.roundness) * 6f + settings.roundness;
				uberMaterial.SetVector(Uniforms._Vignette_Settings, new Vector4(settings.intensity * 3f, settings.smoothness * 5f, z, settings.rounded ? 1f : 0f));
			}
			else if (settings.mode == VignetteModel.Mode.Masked && settings.mask != null && settings.opacity > 0f)
			{
				uberMaterial.EnableKeyword("VIGNETTE_MASKED");
				uberMaterial.SetTexture(Uniforms._Vignette_Mask, settings.mask);
				uberMaterial.SetFloat(Uniforms._Vignette_Opacity, settings.opacity);
			}
		}
	}
	[Serializable]
	public class AmbientOcclusionModel : PostProcessingModel
	{
		public enum SampleCount
		{
			Lowest = 3,
			Low = 6,
			Medium = 10,
			High = 16
		}

		[Serializable]
		public struct Settings
		{
			[Range(0f, 4f)]
			[Tooltip("Degree of darkness produced by the effect.")]
			public float intensity;

			[Min(0.0001f)]
			[Tooltip("Radius of sample points, which affects extent of darkened areas.")]
			public float radius;

			[Tooltip("Number of sample points, which affects quality and performance.")]
			public SampleCount sampleCount;

			[Tooltip("Halves the resolution of the effect to increase performance at the cost of visual quality.")]
			public bool downsampling;

			[Tooltip("Forces compatibility with Forward rendered objects when working with the Deferred rendering path.")]
			public bool forceForwardCompatibility;

			[Tooltip("Enables the ambient-only mode in that the effect only affects ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering.")]
			public bool ambientOnly;

			[Tooltip("Toggles the use of a higher precision depth texture with the forward rendering path (may impact performances). Has no effect with the deferred rendering path.")]
			public bool highPrecision;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.intensity = 1f;
					result.radius = 0.3f;
					result.sampleCount = SampleCount.Medium;
					result.downsampling = true;
					result.forceForwardCompatibility = false;
					result.ambientOnly = false;
					result.highPrecision = false;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class AntialiasingModel : PostProcessingModel
	{
		public enum Method
		{
			Fxaa,
			Taa
		}

		public enum FxaaPreset
		{
			ExtremePerformance,
			Performance,
			Default,
			Quality,
			ExtremeQuality
		}

		[Serializable]
		public struct FxaaQualitySettings
		{
			[Tooltip("The amount of desired sub-pixel aliasing removal. Effects the sharpeness of the output.")]
			[Range(0f, 1f)]
			public float subpixelAliasingRemovalAmount;

			[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
			[Range(0.063f, 0.333f)]
			public float edgeDetectionThreshold;

			[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
			[Range(0f, 0.0833f)]
			public float minimumRequiredLuminance;

			public static FxaaQualitySettings[] presets = new FxaaQualitySettings[5]
			{
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0f,
					edgeDetectionThreshold = 0.333f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0.25f,
					edgeDetectionThreshold = 0.25f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 0.75f,
					edgeDetectionThreshold = 0.166f,
					minimumRequiredLuminance = 0.0833f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 1f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.0625f
				},
				new FxaaQualitySettings
				{
					subpixelAliasingRemovalAmount = 1f,
					edgeDetectionThreshold = 0.063f,
					minimumRequiredLuminance = 0.0312f
				}
			};
		}

		[Serializable]
		public struct FxaaConsoleSettings
		{
			[Tooltip("The amount of spread applied to the sampling coordinates while sampling for subpixel information.")]
			[Range(0.33f, 0.5f)]
			public float subpixelSpreadAmount;

			[Tooltip("This value dictates how sharp the edges in the image are kept; a higher value implies sharper edges.")]
			[Range(2f, 8f)]
			public float edgeSharpnessAmount;

			[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
			[Range(0.125f, 0.25f)]
			public float edgeDetectionThreshold;

			[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
			[Range(0.04f, 0.06f)]
			public float minimumRequiredLuminance;

			public static FxaaConsoleSettings[] presets = new FxaaConsoleSettings[5]
			{
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.33f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.25f,
					minimumRequiredLuminance = 0.06f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.33f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.06f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 8f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.05f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 4f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.04f
				},
				new FxaaConsoleSettings
				{
					subpixelSpreadAmount = 0.5f,
					edgeSharpnessAmount = 2f,
					edgeDetectionThreshold = 0.125f,
					minimumRequiredLuminance = 0.04f
				}
			};
		}

		[Serializable]
		public struct FxaaSettings
		{
			public FxaaPreset preset;

			public static FxaaSettings defaultSettings
			{
				get
				{
					FxaaSettings result = default(FxaaSettings);
					result.preset = FxaaPreset.Default;
					return result;
				}
			}
		}

		[Serializable]
		public struct TaaSettings
		{
			[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable but blurrier output.")]
			[Range(0.1f, 1f)]
			public float jitterSpread;

			[Tooltip("Controls the amount of sharpening applied to the color buffer.")]
			[Range(0f, 3f)]
			public float sharpen;

			[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
			[Range(0f, 0.99f)]
			public float stationaryBlending;

			[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
			[Range(0f, 0.99f)]
			public float motionBlending;

			public static TaaSettings defaultSettings
			{
				get
				{
					TaaSettings result = default(TaaSettings);
					result.jitterSpread = 0.75f;
					result.sharpen = 0.3f;
					result.stationaryBlending = 0.95f;
					result.motionBlending = 0.85f;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public Method method;

			public FxaaSettings fxaaSettings;

			public TaaSettings taaSettings;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.method = Method.Fxaa;
					result.fxaaSettings = FxaaSettings.defaultSettings;
					result.taaSettings = TaaSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class BloomModel : PostProcessingModel
	{
		[Serializable]
		public struct BloomSettings
		{
			[Min(0f)]
			[Tooltip("Strength of the bloom filter.")]
			public float intensity;

			[Min(0f)]
			[Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[Range(0f, 1f)]
			[Tooltip("Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft threshold).")]
			public float softKnee;

			[Range(1f, 7f)]
			[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(threshold);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static BloomSettings defaultSettings
			{
				get
				{
					BloomSettings result = default(BloomSettings);
					result.intensity = 0.5f;
					result.threshold = 1.1f;
					result.softKnee = 0.5f;
					result.radius = 4f;
					result.antiFlicker = false;
					return result;
				}
			}
		}

		[Serializable]
		public struct LensDirtSettings
		{
			[Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture texture;

			[Min(0f)]
			[Tooltip("Amount of lens dirtiness.")]
			public float intensity;

			public static LensDirtSettings defaultSettings
			{
				get
				{
					LensDirtSettings result = default(LensDirtSettings);
					result.texture = null;
					result.intensity = 3f;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public BloomSettings bloom;

			public LensDirtSettings lensDirt;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.bloom = BloomSettings.defaultSettings;
					result.lensDirt = LensDirtSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class BuiltinDebugViewsModel : PostProcessingModel
	{
		[Serializable]
		public struct DepthSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Scales the camera far plane before displaying the depth map.")]
			public float scale;

			public static DepthSettings defaultSettings
			{
				get
				{
					DepthSettings result = default(DepthSettings);
					result.scale = 1f;
					return result;
				}
			}
		}

		[Serializable]
		public struct MotionVectorsSettings
		{
			[Range(0f, 1f)]
			[Tooltip("Opacity of the source render.")]
			public float sourceOpacity;

			[Range(0f, 1f)]
			[Tooltip("Opacity of the per-pixel motion vector colors.")]
			public float motionImageOpacity;

			[Min(0f)]
			[Tooltip("Because motion vectors are mainly very small vectors, you can use this setting to make them more visible.")]
			public float motionImageAmplitude;

			[Range(0f, 1f)]
			[Tooltip("Opacity for the motion vector arrows.")]
			public float motionVectorsOpacity;

			[Range(8f, 64f)]
			[Tooltip("The arrow density on screen.")]
			public int motionVectorsResolution;

			[Min(0f)]
			[Tooltip("Tweaks the arrows length.")]
			public float motionVectorsAmplitude;

			public static MotionVectorsSettings defaultSettings
			{
				get
				{
					MotionVectorsSettings result = default(MotionVectorsSettings);
					result.sourceOpacity = 1f;
					result.motionImageOpacity = 0f;
					result.motionImageAmplitude = 16f;
					result.motionVectorsOpacity = 1f;
					result.motionVectorsResolution = 24;
					result.motionVectorsAmplitude = 64f;
					return result;
				}
			}
		}

		public enum Mode
		{
			None,
			Depth,
			Normals,
			MotionVectors,
			AmbientOcclusion,
			EyeAdaptation,
			FocusPlane,
			PreGradingLog,
			LogLut,
			UserLut
		}

		[Serializable]
		public struct Settings
		{
			public Mode mode;

			public DepthSettings depth;

			public MotionVectorsSettings motionVectors;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.mode = Mode.None;
					result.depth = DepthSettings.defaultSettings;
					result.motionVectors = MotionVectorsSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public bool willInterrupt
		{
			get
			{
				if (!IsModeActive(Mode.None) && !IsModeActive(Mode.EyeAdaptation) && !IsModeActive(Mode.PreGradingLog) && !IsModeActive(Mode.LogLut))
				{
					return !IsModeActive(Mode.UserLut);
				}
				return false;
			}
		}

		public override void Reset()
		{
			settings = Settings.defaultSettings;
		}

		public bool IsModeActive(Mode mode)
		{
			return m_Settings.mode == mode;
		}
	}
	[Serializable]
	public class ChromaticAberrationModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Shift the hue of chromatic aberrations.")]
			public Texture2D spectralTexture;

			[Range(0f, 1f)]
			[Tooltip("Amount of tangential distortion.")]
			public float intensity;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.spectralTexture = null;
					result.intensity = 0.1f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class ColorGradingModel : PostProcessingModel
	{
		public enum Tonemapper
		{
			None,
			ACES,
			Neutral
		}

		[Serializable]
		public struct TonemappingSettings
		{
			[Tooltip("Tonemapping algorithm to use at the end of the color grading process. Use \"Neutral\" if you need a customizable tonemapper or \"Filmic\" to give a standard filmic look to your scenes.")]
			public Tonemapper tonemapper;

			[Range(-0.1f, 0.1f)]
			public float neutralBlackIn;

			[Range(1f, 20f)]
			public float neutralWhiteIn;

			[Range(-0.09f, 0.1f)]
			public float neutralBlackOut;

			[Range(1f, 19f)]
			public float neutralWhiteOut;

			[Range(0.1f, 20f)]
			public float neutralWhiteLevel;

			[Range(1f, 10f)]
			public float neutralWhiteClip;

			public static TonemappingSettings defaultSettings
			{
				get
				{
					TonemappingSettings result = default(TonemappingSettings);
					result.tonemapper = Tonemapper.Neutral;
					result.neutralBlackIn = 0.02f;
					result.neutralWhiteIn = 10f;
					result.neutralBlackOut = 0f;
					result.neutralWhiteOut = 10f;
					result.neutralWhiteLevel = 5.3f;
					result.neutralWhiteClip = 10f;
					return result;
				}
			}
		}

		[Serializable]
		public struct BasicSettings
		{
			[Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
			public float postExposure;

			[Range(-100f, 100f)]
			[Tooltip("Sets the white balance to a custom color temperature.")]
			public float temperature;

			[Range(-100f, 100f)]
			[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
			public float tint;

			[Range(-180f, 180f)]
			[Tooltip("Shift the hue of all colors.")]
			public float hueShift;

			[Range(0f, 2f)]
			[Tooltip("Pushes the intensity of all colors.")]
			public float saturation;

			[Range(0f, 2f)]
			[Tooltip("Expands or shrinks the overall range of tonal values.")]
			public float contrast;

			public static BasicSettings defaultSettings
			{
				get
				{
					BasicSettings result = default(BasicSettings);
					result.postExposure = 0f;
					result.temperature = 0f;
					result.tint = 0f;
					result.hueShift = 0f;
					result.saturation = 1f;
					result.contrast = 1f;
					return result;
				}
			}
		}

		[Serializable]
		public struct ChannelMixerSettings
		{
			public Vector3 red;

			public Vector3 green;

			public Vector3 blue;

			[HideInInspector]
			public int currentEditingChannel;

			public static ChannelMixerSettings defaultSettings
			{
				get
				{
					ChannelMixerSettings result = default(ChannelMixerSettings);
					result.red = new Vector3(1f, 0f, 0f);
					result.green = new Vector3(0f, 1f, 0f);
					result.blue = new Vector3(0f, 0f, 1f);
					result.currentEditingChannel = 0;
					return result;
				}
			}
		}

		[Serializable]
		public struct LogWheelsSettings
		{
			[Trackball("GetSlopeValue")]
			public Color slope;

			[Trackball("GetPowerValue")]
			public Color power;

			[Trackball("GetOffsetValue")]
			public Color offset;

			public static LogWheelsSettings defaultSettings
			{
				get
				{
					LogWheelsSettings result = default(LogWheelsSettings);
					result.slope = Color.clear;
					result.power = Color.clear;
					result.offset = Color.clear;
					return result;
				}
			}
		}

		[Serializable]
		public struct LinearWheelsSettings
		{
			[Trackball("GetLiftValue")]
			public Color lift;

			[Trackball("GetGammaValue")]
			public Color gamma;

			[Trackball("GetGainValue")]
			public Color gain;

			public static LinearWheelsSettings defaultSettings
			{
				get
				{
					LinearWheelsSettings result = default(LinearWheelsSettings);
					result.lift = Color.clear;
					result.gamma = Color.clear;
					result.gain = Color.clear;
					return result;
				}
			}
		}

		public enum ColorWheelMode
		{
			Linear,
			Log
		}

		[Serializable]
		public struct ColorWheelsSettings
		{
			public ColorWheelMode mode;

			[TrackballGroup]
			public LogWheelsSettings log;

			[TrackballGroup]
			public LinearWheelsSettings linear;

			public static ColorWheelsSettings defaultSettings
			{
				get
				{
					ColorWheelsSettings result = default(ColorWheelsSettings);
					result.mode = ColorWheelMode.Log;
					result.log = LogWheelsSettings.defaultSettings;
					result.linear = LinearWheelsSettings.defaultSettings;
					return result;
				}
			}
		}

		[Serializable]
		public struct CurvesSettings
		{
			public ColorGradingCurve master;

			public ColorGradingCurve red;

			public ColorGradingCurve green;

			public ColorGradingCurve blue;

			public ColorGradingCurve hueVShue;

			public ColorGradingCurve hueVSsat;

			public ColorGradingCurve satVSsat;

			public ColorGradingCurve lumVSsat;

			[HideInInspector]
			public int e_CurrentEditingCurve;

			[HideInInspector]
			public bool e_CurveY;

			[HideInInspector]
			public bool e_CurveR;

			[HideInInspector]
			public bool e_CurveG;

			[HideInInspector]
			public bool e_CurveB;

			public static CurvesSettings defaultSettings
			{
				get
				{
					CurvesSettings result = default(CurvesSettings);
					result.master = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.red = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.green = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.blue = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
					result.hueVShue = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
					result.hueVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
					result.satVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
					result.lumVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
					result.e_CurrentEditingCurve = 0;
					result.e_CurveY = true;
					result.e_CurveR = false;
					result.e_CurveG = false;
					result.e_CurveB = false;
					return result;
				}
			}
		}

		[Serializable]
		public struct Settings
		{
			public TonemappingSettings tonemapping;

			public BasicSettings basic;

			public ChannelMixerSettings channelMixer;

			public ColorWheelsSettings colorWheels;

			public CurvesSettings curves;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.tonemapping = TonemappingSettings.defaultSettings;
					result.basic = BasicSettings.defaultSettings;
					result.channelMixer = ChannelMixerSettings.defaultSettings;
					result.colorWheels = ColorWheelsSettings.defaultSettings;
					result.curves = CurvesSettings.defaultSettings;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
				OnValidate();
			}
		}

		public bool isDirty { get; internal set; }

		public RenderTexture bakedLut { get; internal set; }

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
			OnValidate();
		}

		public override void OnValidate()
		{
			isDirty = true;
		}
	}
	[Serializable]
	public class DepthOfFieldModel : PostProcessingModel
	{
		public enum KernelSize
		{
			Small,
			Medium,
			Large,
			VeryLarge
		}

		[Serializable]
		public struct Settings
		{
			[Min(0.1f)]
			[Tooltip("Distance to the point of focus.")]
			public float focusDistance;

			[Range(0.05f, 32f)]
			[Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
			public float aperture;

			[Range(1f, 300f)]
			[Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
			public float focalLength;

			[Tooltip("Calculate the focal length automatically from the field-of-view value set on the camera. Using this setting isn't recommended.")]
			public bool useCameraFov;

			[Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects the performance (the larger the kernel is, the longer the GPU time is required).")]
			public KernelSize kernelSize;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.focusDistance = 10f;
					result.aperture = 5.6f;
					result.focalLength = 50f;
					result.useCameraFov = false;
					result.kernelSize = KernelSize.Medium;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class DitheringModel : PostProcessingModel
	{
		[Serializable]
		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct Settings
		{
			public static Settings defaultSettings => default(Settings);
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class EyeAdaptationModel : PostProcessingModel
	{
		public enum EyeAdaptationType
		{
			Progressive,
			Fixed
		}

		[Serializable]
		public struct Settings
		{
			[Range(1f, 99f)]
			[Tooltip("Filters the dark part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
			public float lowPercent;

			[Range(1f, 99f)]
			[Tooltip("Filters the bright part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
			public float highPercent;

			[Tooltip("Minimum average luminance to consider for auto exposure (in EV).")]
			public float minLuminance;

			[Tooltip("Maximum average luminance to consider for auto exposure (in EV).")]
			public float maxLuminance;

			[Min(0f)]
			[Tooltip("Exposure bias. Use this to offset the global exposure of the scene.")]
			public float keyValue;

			[Tooltip("Set this to true to let Unity handle the key value automatically based on average luminance.")]
			public bool dynamicKeyValue;

			[Tooltip("Use \"Progressive\" if you want the auto exposure to be animated. Use \"Fixed\" otherwise.")]
			public EyeAdaptationType adaptationType;

			[Min(0f)]
			[Tooltip("Adaptation speed from a dark to a light environment.")]
			public float speedUp;

			[Min(0f)]
			[Tooltip("Adaptation speed from a light to a dark environment.")]
			public float speedDown;

			[Range(-16f, -1f)]
			[Tooltip("Lower bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
			public int logMin;

			[Range(1f, 16f)]
			[Tooltip("Upper bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
			public int logMax;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.lowPercent = 45f;
					result.highPercent = 95f;
					result.minLuminance = -5f;
					result.maxLuminance = 1f;
					result.keyValue = 0.25f;
					result.dynamicKeyValue = true;
					result.adaptationType = EyeAdaptationType.Progressive;
					result.speedUp = 2f;
					result.speedDown = 1f;
					result.logMin = -8;
					result.logMax = 4;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class FogModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Should the fog affect the skybox?")]
			public bool excludeSkybox;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.excludeSkybox = true;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class GrainModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Enable the use of colored grain.")]
			public bool colored;

			[Range(0f, 1f)]
			[Tooltip("Grain strength. Higher means more visible grain.")]
			public float intensity;

			[Range(0.3f, 3f)]
			[Tooltip("Grain particle size.")]
			public float size;

			[Range(0f, 1f)]
			[Tooltip("Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas.")]
			public float luminanceContribution;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.colored = true;
					result.intensity = 0.5f;
					result.size = 1f;
					result.luminanceContribution = 0.8f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class MotionBlurModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Range(0f, 360f)]
			[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
			public float shutterAngle;

			[Range(4f, 32f)]
			[Tooltip("The amount of sample points, which affects quality and performances.")]
			public int sampleCount;

			[Range(0f, 1f)]
			[Tooltip("The strength of multiple frame blending. The opacity of preceding frames are determined from this coefficient and time differences.")]
			public float frameBlending;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.shutterAngle = 270f;
					result.sampleCount = 10;
					result.frameBlending = 0f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class ScreenSpaceReflectionModel : PostProcessingModel
	{
		public enum SSRResolution
		{
			High = 0,
			Low = 2
		}

		public enum SSRReflectionBlendType
		{
			PhysicallyBased,
			Additive
		}

		[Serializable]
		public struct IntensitySettings
		{
			[Tooltip("Nonphysical multiplier for the SSR reflections. 1.0 is physically based.")]
			[Range(0f, 2f)]
			public float reflectionMultiplier;

			[Tooltip("How far away from the maxDistance to begin fading SSR.")]
			[Range(0f, 1000f)]
			public float fadeDistance;

			[Tooltip("Amplify Fresnel fade out. Increase if floor reflections look good close to the surface and bad farther 'under' the floor.")]
			[Range(0f, 1f)]
			public float fresnelFade;

			[Tooltip("Higher values correspond to a faster Fresnel fade as the reflection changes from the grazing angle.")]
			[Range(0.1f, 10f)]
			public float fresnelFadePower;
		}

		[Serializable]
		public struct ReflectionSettings
		{
			[Tooltip("How the reflections are blended into the render.")]
			public SSRReflectionBlendType blendType;

			[Tooltip("Half resolution SSRR is much faster, but less accurate.")]
			public SSRResolution reflectionQuality;

			[Tooltip("Maximum reflection distance in world units.")]
			[Range(0.1f, 300f)]
			public float maxDistance;

			[Tooltip("Max raytracing length.")]
			[Range(16f, 1024f)]
			public int iterationCount;

			[Tooltip("Log base 2 of ray tracing coarse step size. Higher traces farther, lower gives better quality silhouettes.")]
			[Range(1f, 16f)]
			public int stepSize;

			[Tooltip("Typical thickness of columns, walls, furniture, and other objects that reflection rays might pass behind.")]
			[Range(0.01f, 10f)]
			public float widthModifier;

			[Tooltip("Blurriness of reflections.")]
			[Range(0.1f, 8f)]
			public float reflectionBlur;

			[Tooltip("Disable for a performance gain in scenes where most glossy objects are horizontal, like floors, water, and tables. Leave on for scenes with glossy vertical objects.")]
			public bool reflectBackfaces;
		}

		[Serializable]
		public struct ScreenEdgeMask
		{
			[Tooltip("Higher = fade out SSRR near the edge of the screen so that reflections don't pop under camera motion.")]
			[Range(0f, 1f)]
			public float intensity;
		}

		[Serializable]
		public struct Settings
		{
			public ReflectionSettings reflection;

			public IntensitySettings intensity;

			public ScreenEdgeMask screenEdgeMask;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.reflection = new ReflectionSettings
					{
						blendType = SSRReflectionBlendType.PhysicallyBased,
						reflectionQuality = SSRResolution.Low,
						maxDistance = 100f,
						iterationCount = 256,
						stepSize = 3,
						widthModifier = 0.5f,
						reflectionBlur = 1f,
						reflectBackfaces = false
					};
					result.intensity = new IntensitySettings
					{
						reflectionMultiplier = 1f,
						fadeDistance = 100f,
						fresnelFade = 1f,
						fresnelFadePower = 1f
					};
					result.screenEdgeMask = new ScreenEdgeMask
					{
						intensity = 0.03f
					};
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class UserLutModel : PostProcessingModel
	{
		[Serializable]
		public struct Settings
		{
			[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
			public Texture2D lut;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float contribution;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.lut = null;
					result.contribution = 1f;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[Serializable]
	public class VignetteModel : PostProcessingModel
	{
		public enum Mode
		{
			Classic,
			Masked
		}

		[Serializable]
		public struct Settings
		{
			[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
			public Mode mode;

			[ColorUsage(false)]
			[Tooltip("Vignette color. Use the alpha channel for transparency.")]
			public Color color;

			[Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
			public Vector2 center;

			[Range(0f, 1f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float intensity;

			[Range(0.01f, 1f)]
			[Tooltip("Smoothness of the vignette borders.")]
			public float smoothness;

			[Range(0f, 1f)]
			[Tooltip("Lower values will make a square-ish vignette.")]
			public float roundness;

			[Tooltip("A black and white mask to use as a vignette.")]
			public Texture mask;

			[Range(0f, 1f)]
			[Tooltip("Mask opacity.")]
			public float opacity;

			[Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
			public bool rounded;

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.mode = Mode.Classic;
					result.color = new Color(0f, 0f, 0f, 1f);
					result.center = new Vector2(0.5f, 0.5f);
					result.intensity = 0.45f;
					result.smoothness = 0.2f;
					result.roundness = 1f;
					result.mask = null;
					result.opacity = 1f;
					result.rounded = false;
					return result;
				}
			}
		}

		[SerializeField]
		private Settings m_Settings = Settings.defaultSettings;

		public Settings settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				m_Settings = value;
			}
		}

		public override void Reset()
		{
			m_Settings = Settings.defaultSettings;
		}
	}
	[ImageEffectAllowedInSceneView]
	[RequireComponent(typeof(Camera))]
	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	[AddComponentMenu("Effects/Post-Processing Behaviour", -1)]
	public class PostProcessingBehaviour : MonoBehaviour
	{
		public PostProcessingProfile profile;

		public Func<Vector2, Matrix4x4> jitteredMatrixFunc;

		private Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>> m_CommandBuffers;

		private List<PostProcessingComponentBase> m_Components;

		private Dictionary<PostProcessingComponentBase, bool> m_ComponentStates;

		private MaterialFactory m_MaterialFactory;

		private RenderTextureFactory m_RenderTextureFactory;

		private PostProcessingContext m_Context;

		private Camera m_Camera;

		private PostProcessingProfile m_PreviousProfile;

		private bool m_RenderingInSceneView;

		private BuiltinDebugViewsComponent m_DebugViews;

		private AmbientOcclusionComponent m_AmbientOcclusion;

		private ScreenSpaceReflectionComponent m_ScreenSpaceReflection;

		private FogComponent m_FogComponent;

		private MotionBlurComponent m_MotionBlur;

		private TaaComponent m_Taa;

		private EyeAdaptationComponent m_EyeAdaptation;

		private DepthOfFieldComponent m_DepthOfField;

		private BloomComponent m_Bloom;

		private ChromaticAberrationComponent m_ChromaticAberration;

		private ColorGradingComponent m_ColorGrading;

		private UserLutComponent m_UserLut;

		private GrainComponent m_Grain;

		private VignetteComponent m_Vignette;

		private DitheringComponent m_Dithering;

		private FxaaComponent m_Fxaa;

		private List<PostProcessingComponentBase> m_ComponentsToEnable = new List<PostProcessingComponentBase>();

		private List<PostProcessingComponentBase> m_ComponentsToDisable = new List<PostProcessingComponentBase>();

		private void OnEnable()
		{
			m_CommandBuffers = new Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>>();
			m_MaterialFactory = new MaterialFactory();
			m_RenderTextureFactory = new RenderTextureFactory();
			m_Context = new PostProcessingContext();
			m_Components = new List<PostProcessingComponentBase>();
			m_DebugViews = AddComponent(new BuiltinDebugViewsComponent());
			m_AmbientOcclusion = AddComponent(new AmbientOcclusionComponent());
			m_ScreenSpaceReflection = AddComponent(new ScreenSpaceReflectionComponent());
			m_FogComponent = AddComponent(new FogComponent());
			m_MotionBlur = AddComponent(new MotionBlurComponent());
			m_Taa = AddComponent(new TaaComponent());
			m_EyeAdaptation = AddComponent(new EyeAdaptationComponent());
			m_DepthOfField = AddComponent(new DepthOfFieldComponent());
			m_Bloom = AddComponent(new BloomComponent());
			m_ChromaticAberration = AddComponent(new ChromaticAberrationComponent());
			m_ColorGrading = AddComponent(new ColorGradingComponent());
			m_UserLut = AddComponent(new UserLutComponent());
			m_Grain = AddComponent(new GrainComponent());
			m_Vignette = AddComponent(new VignetteComponent());
			m_Dithering = AddComponent(new DitheringComponent());
			m_Fxaa = AddComponent(new FxaaComponent());
			m_ComponentStates = new Dictionary<PostProcessingComponentBase, bool>();
			foreach (PostProcessingComponentBase component in m_Components)
			{
				m_ComponentStates.Add(component, value: false);
			}
			base.useGUILayout = false;
		}

		private void OnPreCull()
		{
			m_Camera = GetComponent<Camera>();
			if (profile == null || m_Camera == null)
			{
				return;
			}
			PostProcessingContext postProcessingContext = m_Context.Reset();
			postProcessingContext.profile = profile;
			postProcessingContext.renderTextureFactory = m_RenderTextureFactory;
			postProcessingContext.materialFactory = m_MaterialFactory;
			postProcessingContext.camera = m_Camera;
			m_DebugViews.Init(postProcessingContext, profile.debugViews);
			m_AmbientOcclusion.Init(postProcessingContext, profile.ambientOcclusion);
			m_ScreenSpaceReflection.Init(postProcessingContext, profile.screenSpaceReflection);
			m_FogComponent.Init(postProcessingContext, profile.fog);
			m_MotionBlur.Init(postProcessingContext, profile.motionBlur);
			m_Taa.Init(postProcessingContext, profile.antialiasing);
			m_EyeAdaptation.Init(postProcessingContext, profile.eyeAdaptation);
			m_DepthOfField.Init(postProcessingContext, profile.depthOfField);
			m_Bloom.Init(postProcessingContext, profile.bloom);
			m_ChromaticAberration.Init(postProcessingContext, profile.chromaticAberration);
			m_ColorGrading.Init(postProcessingContext, profile.colorGrading);
			m_UserLut.Init(postProcessingContext, profile.userLut);
			m_Grain.Init(postProcessingContext, profile.grain);
			m_Vignette.Init(postProcessingContext, profile.vignette);
			m_Dithering.Init(postProcessingContext, profile.dithering);
			m_Fxaa.Init(postProcessingContext, profile.antialiasing);
			if (m_PreviousProfile != profile)
			{
				DisableComponents();
				m_PreviousProfile = profile;
			}
			CheckObservers();
			DepthTextureMode depthTextureMode = postProcessingContext.camera.depthTextureMode;
			foreach (PostProcessingComponentBase component in m_Components)
			{
				if (component.active)
				{
					depthTextureMode |= component.GetCameraFlags();
				}
			}
			postProcessingContext.camera.depthTextureMode = depthTextureMode;
			if (!m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
			{
				m_Taa.SetProjectionMatrix(jitteredMatrixFunc);
			}
		}

		private void OnPreRender()
		{
			if (!(profile == null))
			{
				TryExecuteCommandBuffer(m_DebugViews);
				TryExecuteCommandBuffer(m_AmbientOcclusion);
				TryExecuteCommandBuffer(m_ScreenSpaceReflection);
				TryExecuteCommandBuffer(m_FogComponent);
				if (!m_RenderingInSceneView)
				{
					TryExecuteCommandBuffer(m_MotionBlur);
				}
			}
		}

		private void OnPostRender()
		{
			if (!(profile == null) && !(m_Camera == null) && !m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
			{
				m_Context.camera.ResetProjectionMatrix();
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (profile == null || m_Camera == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			bool flag = false;
			bool active = m_Fxaa.active;
			bool flag2 = m_Taa.active && !m_RenderingInSceneView;
			bool num = m_DepthOfField.active && !m_RenderingInSceneView;
			Material material = m_MaterialFactory.Get("Hidden/Post FX/Uber Shader");
			material.shaderKeywords = null;
			RenderTexture renderTexture = source;
			if (flag2)
			{
				RenderTexture renderTexture2 = m_RenderTextureFactory.Get(renderTexture);
				m_Taa.Render(renderTexture, renderTexture2);
				renderTexture = renderTexture2;
			}
			Texture texture = GraphicsUtils.whiteTexture;
			if (m_EyeAdaptation.active)
			{
				flag = true;
				texture = m_EyeAdaptation.Prepare(renderTexture, material);
			}
			material.SetTexture("_AutoExposure", texture);
			if (num)
			{
				flag = true;
				m_DepthOfField.Prepare(renderTexture, material, flag2, m_Taa.jitterVector, m_Taa.model.settings.taaSettings.motionBlending);
			}
			if (m_Bloom.active)
			{
				flag = true;
				m_Bloom.Prepare(renderTexture, material, texture);
			}
			flag |= TryPrepareUberImageEffect(m_ChromaticAberration, material);
			flag |= TryPrepareUberImageEffect(m_ColorGrading, material);
			flag |= TryPrepareUberImageEffect(m_Vignette, material);
			flag |= TryPrepareUberImageEffect(m_UserLut, material);
			Material material2 = (active ? m_MaterialFactory.Get("Hidden/Post FX/FXAA") : null);
			if (active)
			{
				material2.shaderKeywords = null;
				TryPrepareUberImageEffect(m_Grain, material2);
				TryPrepareUberImageEffect(m_Dithering, material2);
				if (flag)
				{
					RenderTexture renderTexture3 = m_RenderTextureFactory.Get(renderTexture);
					Graphics.Blit(renderTexture, renderTexture3, material, 0);
					renderTexture = renderTexture3;
				}
				m_Fxaa.Render(renderTexture, destination);
			}
			else
			{
				flag |= TryPrepareUberImageEffect(m_Grain, material);
				flag |= TryPrepareUberImageEffect(m_Dithering, material);
				if (flag)
				{
					if (!GraphicsUtils.isLinearColorSpace)
					{
						material.EnableKeyword("UNITY_COLORSPACE_GAMMA");
					}
					Graphics.Blit(renderTexture, destination, material, 0);
				}
			}
			if (!flag && !active)
			{
				Graphics.Blit(renderTexture, destination);
			}
			m_RenderTextureFactory.ReleaseAll();
		}

		private void OnGUI()
		{
			if (Event.current.type == EventType.Repaint && !(profile == null) && !(m_Camera == null))
			{
				if (m_EyeAdaptation.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
				{
					m_EyeAdaptation.OnGUI();
				}
				else if (m_ColorGrading.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.LogLut))
				{
					m_ColorGrading.OnGUI();
				}
				else if (m_UserLut.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.UserLut))
				{
					m_UserLut.OnGUI();
				}
			}
		}

		private void OnDisable()
		{
			foreach (KeyValuePair<CameraEvent, CommandBuffer> value in m_CommandBuffers.Values)
			{
				m_Camera.RemoveCommandBuffer(value.Key, value.Value);
				value.Value.Dispose();
			}
			m_CommandBuffers.Clear();
			if (profile != null)
			{
				DisableComponents();
			}
			m_Components.Clear();
			m_MaterialFactory.Dispose();
			m_RenderTextureFactory.Dispose();
			GraphicsUtils.Dispose();
		}

		public void ResetTemporalEffects()
		{
			m_Taa.ResetHistory();
			m_MotionBlur.ResetHistory();
			m_EyeAdaptation.ResetHistory();
		}

		private void CheckObservers()
		{
			foreach (KeyValuePair<PostProcessingComponentBase, bool> componentState in m_ComponentStates)
			{
				PostProcessingComponentBase key = componentState.Key;
				bool flag = key.GetModel().enabled;
				if (flag != componentState.Value)
				{
					if (flag)
					{
						m_ComponentsToEnable.Add(key);
					}
					else
					{
						m_ComponentsToDisable.Add(key);
					}
				}
			}
			for (int i = 0; i < m_ComponentsToDisable.Count; i++)
			{
				PostProcessingComponentBase postProcessingComponentBase = m_ComponentsToDisable[i];
				m_ComponentStates[postProcessingComponentBase] = false;
				postProcessingComponentBase.OnDisable();
			}
			for (int j = 0; j < m_ComponentsToEnable.Count; j++)
			{
				PostProcessingComponentBase postProcessingComponentBase2 = m_ComponentsToEnable[j];
				m_ComponentStates[postProcessingComponentBase2] = true;
				postProcessingComponentBase2.OnEnable();
			}
			m_ComponentsToDisable.Clear();
			m_ComponentsToEnable.Clear();
		}

		private void DisableComponents()
		{
			foreach (PostProcessingComponentBase component in m_Components)
			{
				PostProcessingModel model = component.GetModel();
				if (model != null && model.enabled)
				{
					component.OnDisable();
				}
			}
		}

		private CommandBuffer AddCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
		{
			CommandBuffer value = new CommandBuffer
			{
				name = name
			};
			KeyValuePair<CameraEvent, CommandBuffer> value2 = new KeyValuePair<CameraEvent, CommandBuffer>(evt, value);
			m_CommandBuffers.Add(typeof(T), value2);
			m_Camera.AddCommandBuffer(evt, value2.Value);
			return value2.Value;
		}

		private void RemoveCommandBuffer<T>() where T : PostProcessingModel
		{
			Type typeFromHandle = typeof(T);
			if (m_CommandBuffers.TryGetValue(typeFromHandle, out var value))
			{
				m_Camera.RemoveCommandBuffer(value.Key, value.Value);
				m_CommandBuffers.Remove(typeFromHandle);
				value.Value.Dispose();
			}
		}

		private CommandBuffer GetCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
		{
			if (!m_CommandBuffers.TryGetValue(typeof(T), out var value))
			{
				return AddCommandBuffer<T>(evt, name);
			}
			if (value.Key != evt)
			{
				RemoveCommandBuffer<T>();
				return AddCommandBuffer<T>(evt, name);
			}
			return value.Value;
		}

		private void TryExecuteCommandBuffer<T>(PostProcessingComponentCommandBuffer<T> component) where T : PostProcessingModel
		{
			if (component.active)
			{
				CommandBuffer commandBuffer = GetCommandBuffer<T>(component.GetCameraEvent(), component.GetName());
				commandBuffer.Clear();
				component.PopulateCommandBuffer(commandBuffer);
			}
			else
			{
				RemoveCommandBuffer<T>();
			}
		}

		private bool TryPrepareUberImageEffect<T>(PostProcessingComponentRenderTexture<T> component, Material material) where T : PostProcessingModel
		{
			if (!component.active)
			{
				return false;
			}
			component.Prepare(material);
			return true;
		}

		private T AddComponent<T>(T component) where T : PostProcessingComponentBase
		{
			m_Components.Add(component);
			return component;
		}
	}
	public abstract class PostProcessingComponentBase
	{
		public PostProcessingContext context;

		public abstract bool active { get; }

		public virtual DepthTextureMode GetCameraFlags()
		{
			return DepthTextureMode.None;
		}

		public virtual void OnEnable()
		{
		}

		public virtual void OnDisable()
		{
		}

		public abstract PostProcessingModel GetModel();
	}
	public abstract class PostProcessingComponent<T> : PostProcessingComponentBase where T : PostProcessingModel
	{
		public T model { get; internal set; }

		public virtual void Init(PostProcessingContext pcontext, T pmodel)
		{
			context = pcontext;
			model = pmodel;
		}

		public override PostProcessingModel GetModel()
		{
			return model;
		}
	}
	public abstract class PostProcessingComponentCommandBuffer<T> : PostProcessingComponent<T> where T : PostProcessingModel
	{
		public abstract CameraEvent GetCameraEvent();

		public abstract string GetName();

		public abstract void PopulateCommandBuffer(CommandBuffer cb);
	}
	public abstract class PostProcessingComponentRenderTexture<T> : PostProcessingComponent<T> where T : PostProcessingModel
	{
		public virtual void Prepare(Material material)
		{
		}
	}
	public class PostProcessingContext
	{
		public PostProcessingProfile profile;

		public Camera camera;

		public MaterialFactory materialFactory;

		public RenderTextureFactory renderTextureFactory;

		public bool interrupted { get; private set; }

		public bool isGBufferAvailable => camera.actualRenderingPath == RenderingPath.DeferredShading;

		public bool isHdr => camera.allowHDR;

		public int width => camera.pixelWidth;

		public int height => camera.pixelHeight;

		public Rect viewport => camera.rect;

		public void Interrupt()
		{
			interrupted = true;
		}

		public PostProcessingContext Reset()
		{
			profile = null;
			camera = null;
			materialFactory = null;
			renderTextureFactory = null;
			interrupted = false;
			return this;
		}
	}
	[Serializable]
	public abstract class PostProcessingModel
	{
		[SerializeField]
		[GetSet("enabled")]
		private bool m_Enabled;

		public bool enabled
		{
			get
			{
				return m_Enabled;
			}
			set
			{
				m_Enabled = value;
				if (value)
				{
					OnValidate();
				}
			}
		}

		public abstract void Reset();

		public virtual void OnValidate()
		{
		}
	}
	public class PostProcessingProfile : ScriptableObject
	{
		public BuiltinDebugViewsModel debugViews = new BuiltinDebugViewsModel();

		public FogModel fog = new FogModel();

		public AntialiasingModel antialiasing = new AntialiasingModel();

		public AmbientOcclusionModel ambientOcclusion = new AmbientOcclusionModel();

		public ScreenSpaceReflectionModel screenSpaceReflection = new ScreenSpaceReflectionModel();

		public DepthOfFieldModel depthOfField = new DepthOfFieldModel();

		public MotionBlurModel motionBlur = new MotionBlurModel();

		public EyeAdaptationModel eyeAdaptation = new EyeAdaptationModel();

		public BloomModel bloom = new BloomModel();

		public ColorGradingModel colorGrading = new ColorGradingModel();

		public UserLutModel userLut = new UserLutModel();

		public ChromaticAberrationModel chromaticAberration = new ChromaticAberrationModel();

		public GrainModel grain = new GrainModel();

		public VignetteModel vignette = new VignetteModel();

		public DitheringModel dithering = new DitheringModel();
	}
	[Serializable]
	public sealed class ColorGradingCurve
	{
		public AnimationCurve curve;

		[SerializeField]
		private bool m_Loop;

		[SerializeField]
		private float m_ZeroValue;

		[SerializeField]
		private float m_Range;

		private AnimationCurve m_InternalLoopingCurve;

		public ColorGradingCurve(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
		{
			this.curve = curve;
			m_ZeroValue = zeroValue;
			m_Loop = loop;
			m_Range = bounds.magnitude;
		}

		public void Cache()
		{
			if (!m_Loop)
			{
				return;
			}
			int length = curve.length;
			if (length >= 2)
			{
				if (m_InternalLoopingCurve == null)
				{
					m_InternalLoopingCurve = new AnimationCurve();
				}
				Keyframe key = curve[length - 1];
				key.time -= m_Range;
				Keyframe key2 = curve[0];
				key2.time += m_Range;
				m_InternalLoopingCurve.keys = curve.keys;
				m_InternalLoopingCurve.AddKey(key);
				m_InternalLoopingCurve.AddKey(key2);
			}
		}

		public float Evaluate(float t)
		{
			if (curve.length == 0)
			{
				return m_ZeroValue;
			}
			if (!m_Loop || curve.length == 1)
			{
				return curve.Evaluate(t);
			}
			return m_InternalLoopingCurve.Evaluate(t);
		}
	}
	public static class GraphicsUtils
	{
		private static Texture2D s_WhiteTexture;

		private static Mesh s_Quad;

		public static bool isLinearColorSpace => QualitySettings.activeColorSpace == ColorSpace.Linear;

		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static Texture2D whiteTexture
		{
			get
			{
				if (s_WhiteTexture != null)
				{
					return s_WhiteTexture;
				}
				s_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: false);
				s_WhiteTexture.SetPixel(0, 0, new Color(1f, 1f, 1f, 1f));
				s_WhiteTexture.Apply();
				return s_WhiteTexture;
			}
		}

		public static Mesh quad
		{
			get
			{
				if (s_Quad != null)
				{
					return s_Quad;
				}
				Vector3[] vertices = new Vector3[4]
				{
					new Vector3(-1f, -1f, 0f),
					new Vector3(1f, 1f, 0f),
					new Vector3(1f, -1f, 0f),
					new Vector3(-1f, 1f, 0f)
				};
				Vector2[] uv = new Vector2[4]
				{
					new Vector2(0f, 0f),
					new Vector2(1f, 1f),
					new Vector2(1f, 0f),
					new Vector2(0f, 1f)
				};
				int[] triangles = new int[6] { 0, 1, 2, 1, 0, 3 };
				s_Quad = new Mesh
				{
					vertices = vertices,
					uv = uv,
					triangles = triangles
				};
				s_Quad.RecalculateNormals();
				s_Quad.RecalculateBounds();
				return s_Quad;
			}
		}

		public static void Blit(Material material, int pass)
		{
			GL.PushMatrix();
			GL.LoadOrtho();
			material.SetPass(pass);
			GL.Begin(5);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, 0.1f);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, 0.1f);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, 0.1f);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, 0.1f);
			GL.End();
			GL.PopMatrix();
		}

		public static void ClearAndBlit(Texture source, RenderTexture destination, Material material, int pass, bool clearColor = true, bool clearDepth = false)
		{
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = destination;
			GL.Clear(clearDepth: false, clearColor, Color.clear);
			GL.PushMatrix();
			GL.LoadOrtho();
			material.SetTexture("_MainTex", source);
			material.SetPass(pass);
			GL.Begin(5);
			GL.TexCoord2(0f, 0f);
			GL.Vertex3(0f, 0f, 0.1f);
			GL.TexCoord2(1f, 0f);
			GL.Vertex3(1f, 0f, 0.1f);
			GL.TexCoord2(0f, 1f);
			GL.Vertex3(0f, 1f, 0.1f);
			GL.TexCoord2(1f, 1f);
			GL.Vertex3(1f, 1f, 0.1f);
			GL.End();
			GL.PopMatrix();
			RenderTexture.active = active;
		}

		public static void Destroy(Object obj)
		{
			if (obj != null)
			{
				Object.Destroy(obj);
			}
		}

		public static void Dispose()
		{
			Destroy(s_Quad);
		}
	}
	public sealed class MaterialFactory : IDisposable
	{
		private Dictionary<string, Material> m_Materials;

		public MaterialFactory()
		{
			m_Materials = new Dictionary<string, Material>();
		}

		public Material Get(string shaderName)
		{
			if (!m_Materials.TryGetValue(shaderName, out var value))
			{
				Shader shader = Shader.Find(shaderName);
				if (shader == null)
				{
					throw new ArgumentException($"Shader not found ({shaderName})");
				}
				value = new Material(shader)
				{
					name = string.Format("PostFX - {0}", shaderName.Substring(shaderName.LastIndexOf("/") + 1)),
					hideFlags = HideFlags.DontSave
				};
				m_Materials.Add(shaderName, value);
			}
			return value;
		}

		public void Dispose()
		{
			Dictionary<string, Material>.Enumerator enumerator = m_Materials.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GraphicsUtils.Destroy(enumerator.Current.Value);
			}
			m_Materials.Clear();
		}
	}
	public sealed class RenderTextureFactory : IDisposable
	{
		private HashSet<RenderTexture> m_TemporaryRTs;

		public RenderTextureFactory()
		{
			m_TemporaryRTs = new HashSet<RenderTexture>();
		}

		public RenderTexture Get(RenderTexture baseRenderTexture)
		{
			return Get(baseRenderTexture.width, baseRenderTexture.height, baseRenderTexture.depth, baseRenderTexture.format, (!baseRenderTexture.sRGB) ? RenderTextureReadWrite.Linear : RenderTextureReadWrite.sRGB, baseRenderTexture.filterMode, baseRenderTexture.wrapMode);
		}

		public RenderTexture Get(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, RenderTextureReadWrite rw = RenderTextureReadWrite.Default, FilterMode filterMode = FilterMode.Bilinear, TextureWrapMode wrapMode = TextureWrapMode.Clamp, string name = "FactoryTempTexture")
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format, rw);
			temporary.filterMode = filterMode;
			temporary.wrapMode = wrapMode;
			temporary.name = name;
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void Release(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					throw new ArgumentException($"Attempting to remove a RenderTexture that was not allocated: {rt}");
				}
				m_TemporaryRTs.Remove(rt);
				RenderTexture.ReleaseTemporary(rt);
			}
		}

		public void ReleaseAll()
		{
			HashSet<RenderTexture>.Enumerator enumerator = m_TemporaryRTs.GetEnumerator();
			while (enumerator.MoveNext())
			{
				RenderTexture.ReleaseTemporary(enumerator.Current);
			}
			m_TemporaryRTs.Clear();
		}

		public void Dispose()
		{
			ReleaseAll();
		}
	}
}
namespace BoundarySystem_Ext
{
	internal static class Pvr_BoundaryAPI
	{
		private const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_StartSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ShutdownSDKBoundary();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetCameraData_Ext();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_ResetVrModebyForce();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_ResumeBoundaryForSTS();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_PauseBoundaryForSTS();

		public static int UPvr_GetMainSensorStateExt(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorStateExt(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static IntPtr UPvr_GetCameraData_Ext()
		{
			_ = IntPtr.Zero;
			return Pvr_GetCameraData_Ext();
		}

		public static bool UPvr_ResumeBoundaryForSTS()
		{
			return Pvr_ResumeBoundaryForSTS();
		}

		public static void UPvr_PauseBoundaryForSTS()
		{
			Pvr_PauseBoundaryForSTS();
		}

		public static IntPtr StructToIntPtr<T>(T info)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(info));
			Marshal.StructureToPtr(info, intPtr, fDeleteOld: true);
			return intPtr;
		}

		public static T IntPtrToStruct<T>(IntPtr info)
		{
			return (T)Marshal.PtrToStructure(info, typeof(T));
		}
	}
	internal static class Pvr_SafeAreaAlgoAPI
	{
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr);

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		public delegate void SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr);

		public struct GSAPoint3i
		{
			public int x;

			public int y;

			public int z;
		}

		public struct GSALine
		{
			public IntPtr pointArray;

			public int pointCount;
		}

		public struct GSALineCollection
		{
			public IntPtr lineArray;

			public int lineCount;
		}

		public struct GSALegalData
		{
			public int overMaxRange;

			public int includeBigGrap;

			public int bigGapNum;

			public int centerOut;

			public int removeNarrow;

			public int overMaxRange_more;

			public int validShrinkArea;
		}

		public struct GSARect
		{
			public GSAPoint3i leftup;

			public GSAPoint3i leftdown;

			public GSAPoint3i rightup;

			public GSAPoint3i rightdown;

			public GSAPoint3i center;

			public uint width;

			public uint height;

			public int isLegal;

			public GSALegalData legalData;
		}

		private const string LibFileName = "SafetyArea";

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAInit(int width, int height);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAShutDown();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallback(SafeAreaCallback cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetCallbackShrink(SafeAreaCallbackShrink cb);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSAUpDateData(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSASetConfigFilePath(IntPtr configPath);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool GSAGetClosedAreaUpdateFlag();

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea(IntPtr lineCollectionPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector(ref GSAPoint3i pointPtr);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern int GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea);

		[DllImport("SafetyArea", CallingConvention = CallingConvention.Cdecl)]
		private static extern double GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir);

		public static int Pvr_GSAInit(int width, int height)
		{
			return GSAInit(width, height);
		}

		public static int Pvr_GSASetCallback(SafeAreaCallback cb)
		{
			return GSASetCallback(cb);
		}

		public static int Pvr_GSASetCallbackShrink(SafeAreaCallbackShrink cb)
		{
			return GSASetCallbackShrink(cb);
		}

		public static int Pvr_GSAUpDateData(IntPtr lineCollectionPtr)
		{
			return GSAUpDateData(lineCollectionPtr);
		}

		public static bool Pvr_GSAGetClosedAreaUpdateFlag()
		{
			return GSAGetClosedAreaUpdateFlag();
		}

		public static int Pvr_GSASetConfigFilePath(string configPath)
		{
			int num = -1;
			IntPtr intPtr = Marshal.StringToHGlobalAnsi(configPath);
			num = GSASetConfigFilePath(intPtr);
			Marshal.FreeHGlobal(intPtr);
			return num;
		}

		public static int Pvr_GSALoadSafetyArea(IntPtr lineCollectionPtr)
		{
			return GSALoadSafetyArea(lineCollectionPtr);
		}

		public static double Pvr_GSABoundaryDetector(ref GSAPoint3i point)
		{
			return GSABoundaryDetector(ref point);
		}

		public static int Pvr_GSAShutDown()
		{
			return GSAShutDown();
		}

		public static int Pvr_GSALoadSafetyArea2(IntPtr lineCollectionPtr, bool isPlayArea)
		{
			return GSALoadSafetyArea2(lineCollectionPtr, isPlayArea);
		}

		public static double Pvr_GSABoundaryDetector2(ref GSAPoint3i point, bool isPlayArea, ref GSAPoint3i closestPoint, ref GSAPoint3i normalDir)
		{
			return GSABoundaryDetector2(ref point, isPlayArea, ref closestPoint, ref normalDir);
		}
	}
	public class Pvr_BoundarySystem
	{
		private static Pvr_BoundarySystem instance;

		public const int CameraImageWidth = 1280;

		public const int CameraImageHeight = 400;

		public IntPtr CameraFramePtr = IntPtr.Zero;

		public static Pvr_BoundarySystem Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_BoundarySystem();
				}
				return instance;
			}
		}

		public void OpenBoundary()
		{
			Pvr_BoundaryAPI.Pvr_StartSDKBoundary();
		}

		public void CloseBoundary()
		{
			Pvr_BoundaryAPI.Pvr_ShutdownSDKBoundary();
		}

		public void Reset6Dof()
		{
			Pvr_BoundaryAPI.Pvr_ResetVrModebyForce();
		}

		public float[] GetControllerFixedPoseData(int hand)
		{
			float[] result = new float[7] { 0f, 0f, 0f, 1f, 0f, 0f, 0f };
			if (Pvr_ControllerManager.controllerlink != null)
			{
				Pvr_UnitySDKAPI.System.UPvr_CallStaticMethod(ref result, Pvr_ControllerManager.controllerlink.javaCVClass, "getControllerFixedSensorState", hand);
			}
			result[2] = 0f - result[2];
			result[3] = 0f - result[3];
			return result;
		}
	}
	public class Pvr_SafeAreaAlgoModule
	{
		public struct ExtraInfo
		{
			public bool overMaxRange;

			public bool includeBigGap;

			public int bigGapNum;

			public bool centerOut;

			public bool removeNarrow;

			public bool overMaxRange_more;

			public int validShrinkArea;
		}

		public struct BoundaryPlayerArea
		{
			public Vector3 lowerleft;

			public Vector3 upperleft;

			public Vector3 upperRight;

			public Vector3 lowerRight;

			public Vector3 center;

			public uint width;

			public uint height;

			public bool isLegal;

			public ExtraInfo extraInfo;
		}

		public delegate void BoundarySystemCallback(BoundaryPlayerArea playAreaInfo, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		public delegate void BoundarySystemCallbackShrink(List<Vector3> rectPoints, List<Vector3> boundaryPoints, List<List<Vector3>> unusedLines);

		private static Pvr_SafeAreaAlgoModule instance;

		private BoundarySystemCallback boundarySystemCallback;

		private BoundarySystemCallbackShrink boundarySystemCallbackShrink;

		public static Pvr_SafeAreaAlgoModule Instance
		{
			get
			{
				if (instance == null)
				{
					instance = new Pvr_SafeAreaAlgoModule();
				}
				return instance;
			}
		}

		public void RegisterCallBack(BoundarySystemCallback callback)
		{
			boundarySystemCallback = callback;
		}

		public void RegisterCallBackShrink(BoundarySystemCallbackShrink callback)
		{
			boundarySystemCallbackShrink = callback;
		}

		public bool Start()
		{
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallback(_SafeAreaCallback);
			int num2 = Pvr_SafeAreaAlgoAPI.Pvr_GSASetCallbackShrink(_SafeAreaCallbackShrink);
			if (num != 0 || num2 != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem register callback failed!");
				return false;
			}
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAInit(300, 300) != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem init failed!");
				return false;
			}
			return true;
		}

		public bool CommitNewLineData(bool isFistLine, Vector3[] points)
		{
			Pvr_SafeAreaAlgoAPI.GSALineCollection info = default(Pvr_SafeAreaAlgoAPI.GSALineCollection);
			info.lineCount = 2;
			Pvr_SafeAreaAlgoAPI.GSALine[] array = new Pvr_SafeAreaAlgoAPI.GSALine[2];
			if (isFistLine)
			{
				array[0].pointArray = IntPtr.Zero;
				array[0].pointCount = 0;
			}
			else
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i[] arr = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[1]
				{
					new Pvr_SafeAreaAlgoAPI.GSAPoint3i
					{
						x = 0,
						y = 0,
						z = 0
					}
				};
				array[0].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(arr, 0);
				array[0].pointCount = 1;
			}
			Pvr_SafeAreaAlgoAPI.GSAPoint3i[] array2 = new Pvr_SafeAreaAlgoAPI.GSAPoint3i[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
				gSAPoint3i.x = (int)(points[i].x * 1000f);
				gSAPoint3i.y = (int)(points[i].y * 1000f);
				gSAPoint3i.z = (int)(points[i].z * 1000f);
				array2[i] = gSAPoint3i;
			}
			array[1].pointArray = Marshal.UnsafeAddrOfPinnedArrayElement(array2, 0);
			array[1].pointCount = array2.Length;
			info.lineArray = Marshal.UnsafeAddrOfPinnedArrayElement(array, 0);
			IntPtr intPtr = Pvr_BoundaryAPI.StructToIntPtr(info);
			int num = Pvr_SafeAreaAlgoAPI.Pvr_GSAUpDateData(intPtr);
			Marshal.FreeHGlobal(intPtr);
			if (num != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem commit new line data failed!");
				return false;
			}
			return true;
		}

		public bool Shutdown()
		{
			if (Pvr_SafeAreaAlgoAPI.Pvr_GSAShutDown() != 0)
			{
				UnityEngine.Debug.LogError("BoundarySystem shutdown failed!");
				return false;
			}
			return true;
		}

		public double QueryDistanceOfPoint(Vector3 point)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			return Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector(ref point2) / 1000.0;
		}

		public double QueryDistanceOfPoint(Vector3 point, bool isPlayArea, ref Vector3 closestPoint, ref Vector3 normalDir)
		{
			Pvr_SafeAreaAlgoAPI.GSAPoint3i point2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			point2.x = (int)(point.x * 1000f);
			point2.y = (int)(point.y * 1000f);
			point2.z = (int)(point.z * 1000f);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i closestPoint2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			Pvr_SafeAreaAlgoAPI.GSAPoint3i normalDir2 = default(Pvr_SafeAreaAlgoAPI.GSAPoint3i);
			double num = Pvr_SafeAreaAlgoAPI.Pvr_GSABoundaryDetector2(ref point2, isPlayArea, ref closestPoint2, ref normalDir2);
			closestPoint.x = (float)closestPoint2.x / 1000f;
			closestPoint.y = (float)closestPoint2.y / 1000f;
			closestPoint.z = (float)closestPoint2.z / 1000f;
			normalDir.x = (float)normalDir2.x / 1000f;
			normalDir.y = (float)normalDir2.y / 1000f;
			normalDir.z = (float)normalDir2.z / 1000f;
			return num / 1000.0;
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallback))]
		private static void _SafeAreaCallback(IntPtr lineCollectionPtr, IntPtr safeAreaRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallback == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				Pvr_SafeAreaAlgoAPI.GSARect gSARect = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSARect>(safeAreaRectPtr);
				BoundaryPlayerArea playAreaInfo = default(BoundaryPlayerArea);
				playAreaInfo.lowerleft = new Vector3((float)gSARect.leftup.x / 1000f, (float)gSARect.leftup.y / 1000f, (float)gSARect.leftup.z / 1000f);
				playAreaInfo.upperleft = new Vector3((float)gSARect.leftdown.x / 1000f, (float)gSARect.leftdown.y / 1000f, (float)gSARect.leftdown.z / 1000f);
				playAreaInfo.upperRight = new Vector3((float)gSARect.rightdown.x / 1000f, (float)gSARect.rightdown.y / 1000f, (float)gSARect.rightdown.z / 1000f);
				playAreaInfo.lowerRight = new Vector3((float)gSARect.rightup.x / 1000f, (float)gSARect.rightup.y / 1000f, (float)gSARect.rightup.z / 1000f);
				playAreaInfo.center = new Vector3((float)gSARect.center.x / 1000f, (float)gSARect.center.y / 1000f, (float)gSARect.center.z / 1000f);
				playAreaInfo.width = gSARect.width;
				playAreaInfo.height = gSARect.height;
				playAreaInfo.isLegal = ((gSARect.isLegal != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange = ((gSARect.legalData.overMaxRange != 0) ? true : false);
				playAreaInfo.extraInfo.includeBigGap = ((gSARect.legalData.includeBigGrap != 0) ? true : false);
				playAreaInfo.extraInfo.bigGapNum = gSARect.legalData.bigGapNum;
				playAreaInfo.extraInfo.centerOut = ((gSARect.legalData.centerOut != 0) ? true : false);
				playAreaInfo.extraInfo.removeNarrow = ((gSARect.legalData.removeNarrow != 0) ? true : false);
				playAreaInfo.extraInfo.overMaxRange_more = ((gSARect.legalData.overMaxRange_more != 0) ? true : false);
				playAreaInfo.extraInfo.validShrinkArea = gSARect.legalData.validShrinkArea;
				instance.boundarySystemCallback(playAreaInfo, boundaryPoints, list);
			}
		}

		[MonoPInvokeCallback(typeof(Pvr_SafeAreaAlgoAPI.SafeAreaCallbackShrink))]
		private static void _SafeAreaCallbackShrink(IntPtr lineCollectionPtr, IntPtr safeAreaDetailRectPtr)
		{
			if (lineCollectionPtr == IntPtr.Zero || safeAreaDetailRectPtr == IntPtr.Zero)
			{
				UnityEngine.Debug.LogError("BoundarySystem callback is inValid!");
			}
			else
			{
				if (instance.boundarySystemCallbackShrink == null)
				{
					return;
				}
				List<Vector3> boundaryPoints = new List<Vector3>();
				List<List<Vector3>> list = new List<List<Vector3>>();
				int num = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSALine));
				int num2 = Marshal.SizeOf(typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(lineCollectionPtr);
				for (int i = 0; i < gSALineCollection.lineCount; i++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection.lineArray.ToInt64() + num * i), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					List<Vector3> list2 = new List<Vector3>();
					for (int j = 0; j < gSALine.pointCount; j++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine.pointArray.ToInt64() + num2 * j), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list2.Add(new Vector3((float)gSAPoint3i.x / 1000f, (float)gSAPoint3i.y / 1000f, (float)gSAPoint3i.z / 1000f));
					}
					if (i == 0)
					{
						boundaryPoints = list2;
					}
					else
					{
						list.Add(list2);
					}
				}
				List<Vector3> list3 = new List<Vector3>();
				Pvr_SafeAreaAlgoAPI.GSALineCollection gSALineCollection2 = Pvr_BoundaryAPI.IntPtrToStruct<Pvr_SafeAreaAlgoAPI.GSALineCollection>(safeAreaDetailRectPtr);
				for (int k = 0; k < gSALineCollection2.lineCount; k++)
				{
					Pvr_SafeAreaAlgoAPI.GSALine gSALine2 = (Pvr_SafeAreaAlgoAPI.GSALine)Marshal.PtrToStructure(new IntPtr(gSALineCollection2.lineArray.ToInt64() + num * k), typeof(Pvr_SafeAreaAlgoAPI.GSALine));
					for (int l = 0; l < gSALine2.pointCount; l++)
					{
						Pvr_SafeAreaAlgoAPI.GSAPoint3i gSAPoint3i2 = (Pvr_SafeAreaAlgoAPI.GSAPoint3i)Marshal.PtrToStructure(new IntPtr(gSALine2.pointArray.ToInt64() + num2 * l), typeof(Pvr_SafeAreaAlgoAPI.GSAPoint3i));
						list3.Add(new Vector3((float)gSAPoint3i2.x / 1000f, (float)gSAPoint3i2.y / 1000f, (float)gSAPoint3i2.z / 1000f));
					}
				}
				instance.boundarySystemCallbackShrink(list3, boundaryPoints, list);
			}
		}
	}
}
namespace Pvr_UnitySDKAPI
{
	public class PvrControllerKey
	{
		public bool State;

		public bool PressedDown;

		public bool PressedUp;

		public bool LongPressed;

		public bool Click;

		public bool Touch;

		public bool TouchDown;

		public bool TouchUp;

		public PvrControllerKey()
		{
			State = false;
			PressedDown = false;
			PressedUp = false;
			LongPressed = false;
			Click = false;
			Touch = false;
			TouchDown = false;
			TouchUp = false;
		}
	}
	public class ControllerHand
	{
		public PvrControllerKey App;

		public PvrControllerKey Touch;

		public PvrControllerKey Home;

		public PvrControllerKey VolumeDown;

		public PvrControllerKey VolumeUp;

		public PvrControllerKey Trigger;

		public PvrControllerKey X;

		public PvrControllerKey Y;

		public PvrControllerKey A;

		public PvrControllerKey B;

		public PvrControllerKey Left;

		public PvrControllerKey Right;

		public PvrControllerKey Thumbrest;

		public Vector2 TouchPadPosition;

		public int TriggerNum;

		public int GripValue;

		public Quaternion Rotation;

		public Vector3 Position;

		public int Battery;

		public ControllerState ConnectState;

		public SwipeDirection SwipeDirection;

		public TouchPadClick TouchPadClick;

		public bool isShowBoundary;

		public ControllerHand()
		{
			App = new PvrControllerKey();
			Touch = new PvrControllerKey();
			Home = new PvrControllerKey();
			VolumeDown = new PvrControllerKey();
			VolumeUp = new PvrControllerKey();
			Trigger = new PvrControllerKey();
			A = new PvrControllerKey();
			B = new PvrControllerKey();
			X = new PvrControllerKey();
			Y = new PvrControllerKey();
			Left = new PvrControllerKey();
			Right = new PvrControllerKey();
			Thumbrest = new PvrControllerKey();
			TouchPadPosition = default(Vector2);
			Rotation = default(Quaternion);
			Position = default(Vector3);
			Battery = 0;
			TriggerNum = 0;
			GripValue = 0;
			ConnectState = ControllerState.Error;
			SwipeDirection = SwipeDirection.No;
			TouchPadClick = TouchPadClick.No;
			isShowBoundary = false;
		}
	}
	public enum ControllerState
	{
		Error = -1,
		DisConnected,
		Connected
	}
	public enum Pvr_KeyCode
	{
		APP = 1,
		TOUCHPAD,
		HOME,
		VOLUMEUP,
		VOLUMEDOWN,
		TRIGGER,
		A,
		B,
		X,
		Y,
		Left,
		Right,
		Thumbrest
	}
	public enum SwipeDirection
	{
		No,
		SwipeUp,
		SwipeDown,
		SwipeLeft,
		SwipeRight
	}
	public enum TouchPadClick
	{
		No,
		ClickUp,
		ClickDown,
		ClickLeft,
		ClickRight
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Controller
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public static Vector2 UPvr_GetTouchPadPosition(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition, 
				_ => new Vector2(0f, 0f), 
			};
		}

		public static float UPvr_GetAxis1D(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller0.TriggerNum / 255f, 
					Pvr_KeyCode.Left => (float)Pvr_ControllerManager.controllerlink.Controller0.GripValue / 255f, 
					_ => 0f, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TRIGGER => (float)Pvr_ControllerManager.controllerlink.Controller1.TriggerNum / 255f, 
					Pvr_KeyCode.Right => (float)Pvr_ControllerManager.controllerlink.Controller1.GripValue / 255f, 
					_ => 0f, 
				}, 
				_ => 0f, 
			};
		}

		public static Vector2 UPvr_GetAxis2D(int hand)
		{
			switch (hand)
			{
			case 0:
				if (Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			case 1:
				if (Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition != Vector2.zero)
				{
					return new Vector2(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x / 128f - 1f, Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y / 128f - 1f);
				}
				return Vector2.zero;
			default:
				return Vector2.zero;
			}
		}

		public static ControllerState UPvr_GetControllerState(int hand)
		{
			return hand switch
			{
				0 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller0Connected), 
				1 => (ControllerState)Convert.ToInt16(Pvr_ControllerManager.controllerlink.controller1Connected), 
				_ => ControllerState.Error, 
			};
		}

		public static Quaternion UPvr_GetControllerQUA(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Rotation, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Rotation, 
				_ => new Quaternion(0f, 0f, 0f, 1f), 
			};
		}

		public static Vector3 UPvr_GetControllerPOS(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Position, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Position, 
				_ => new Vector3(0f, 0f, 0f), 
			};
		}

		public static int UPvr_GetControllerTriggerValue(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TriggerNum, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TriggerNum, 
				_ => 0, 
			};
		}

		public static int UPvr_GetControllerPower(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.Battery, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.Battery, 
				_ => 0, 
			};
		}

		public static SwipeDirection UPvr_GetSwipeDirection(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.SwipeDirection, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.SwipeDirection, 
				_ => SwipeDirection.No, 
			};
		}

		public static TouchPadClick UPvr_GetTouchPadClick(int hand)
		{
			return hand switch
			{
				0 => Pvr_ControllerManager.controllerlink.Controller0.TouchPadClick, 
				1 => Pvr_ControllerManager.controllerlink.Controller1.TouchPadClick, 
				_ => TouchPadClick.No, 
			};
		}

		public static bool UPvr_GetKey(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.State, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.State, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.State, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.State, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.State, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.State, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.State, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.State, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.State, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.State, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.State, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.State, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.State, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedDown, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedDown, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedDown, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedDown, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedDown, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedDown, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.PressedUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.PressedUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.PressedUp, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.PressedUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.PressedUp, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.PressedUp, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.PressedUp, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.PressedUp, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.PressedUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.PressedUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.PressedUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.PressedUp, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.PressedUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouch(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Touch, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Touch, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.Touch, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Touch, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Touch, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Touch, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Touch, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.Touch, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchDown(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchDown, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchDown, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchDown, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchDown, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchDown, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchDown, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchDown, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetTouchUp(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.TouchUp, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.TouchUp, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller0.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.TouchUp, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.TouchUp, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.TouchUp, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.TouchUp, 
					Pvr_KeyCode.Thumbrest => Pvr_ControllerManager.controllerlink.Controller1.Thumbrest.TouchUp, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyClick(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.Click, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.Click, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.Click, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.Click, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.Click, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.Click, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.Click, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.Click, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.Click, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.Click, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.Click, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.Click, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.Click, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_GetKeyLongPressed(int hand, Pvr_KeyCode key)
		{
			return hand switch
			{
				0 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller0.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller0.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller0.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller0.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller0.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller0.Trigger.LongPressed, 
					Pvr_KeyCode.X => Pvr_ControllerManager.controllerlink.Controller0.X.LongPressed, 
					Pvr_KeyCode.Y => Pvr_ControllerManager.controllerlink.Controller0.Y.LongPressed, 
					Pvr_KeyCode.Left => Pvr_ControllerManager.controllerlink.Controller0.Left.LongPressed, 
					_ => false, 
				}, 
				1 => key switch
				{
					Pvr_KeyCode.APP => Pvr_ControllerManager.controllerlink.Controller1.App.LongPressed, 
					Pvr_KeyCode.HOME => Pvr_ControllerManager.controllerlink.Controller1.Home.LongPressed, 
					Pvr_KeyCode.TOUCHPAD => Pvr_ControllerManager.controllerlink.Controller1.Touch.LongPressed, 
					Pvr_KeyCode.VOLUMEUP => Pvr_ControllerManager.controllerlink.Controller1.VolumeUp.LongPressed, 
					Pvr_KeyCode.VOLUMEDOWN => Pvr_ControllerManager.controllerlink.Controller1.VolumeDown.LongPressed, 
					Pvr_KeyCode.TRIGGER => Pvr_ControllerManager.controllerlink.Controller1.Trigger.LongPressed, 
					Pvr_KeyCode.A => Pvr_ControllerManager.controllerlink.Controller1.A.LongPressed, 
					Pvr_KeyCode.B => Pvr_ControllerManager.controllerlink.Controller1.B.LongPressed, 
					Pvr_KeyCode.Right => Pvr_ControllerManager.controllerlink.Controller1.Right.LongPressed, 
					_ => false, 
				}, 
				_ => false, 
			};
		}

		public static bool UPvr_IsTouching(int hand)
		{
			switch (hand)
			{
			case 0:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller0.TouchPadPosition.y) > 0f;
				}
				return true;
			case 1:
				if (!(Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.x) > 0f))
				{
					return Math.Abs(Pvr_ControllerManager.controllerlink.Controller1.TouchPadPosition.y) > 0f;
				}
				return true;
			default:
				return false;
			}
		}

		public static void UPvr_SetHandNess(Pvr_Controller.UserHandNess hand)
		{
			if (Pvr_ControllerManager.controllerlink.getHandness() != (int)hand)
			{
				Pvr_ControllerManager.controllerlink.setHandness((int)hand);
			}
		}

		public static Pvr_Controller.UserHandNess UPvr_GetHandNess()
		{
			return Pvr_ControllerManager.controllerlink.handness;
		}

		public static int UPvr_GetPreferenceDevice()
		{
			int trackingmode = Pvr_ControllerManager.controllerlink.trackingmode;
			int systemProp = Pvr_ControllerManager.controllerlink.systemProp;
			if (trackingmode == 0 || trackingmode == 1 || ((trackingmode == 3 || trackingmode == 5 || trackingmode == 6) && (systemProp == 1 || systemProp == 3)))
			{
				return 1;
			}
			return 2;
		}

		public static bool UPvr_IsEnbleTrigger()
		{
			return Pvr_ControllerManager.controllerlink.IsEnbleTrigger();
		}

		public static int UPvr_GetDeviceType()
		{
			return Pvr_ControllerManager.controllerlink.controllerType;
		}

		public static int UPvr_GetMainHandNess()
		{
			return Pvr_ControllerManager.controllerlink.mainHandID;
		}

		public static void UPvr_SetMainHandNess(int hand)
		{
			Pvr_ControllerManager.controllerlink.SetMainController(hand);
		}

		public static int UPvr_GetControllerAbility(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerAbility(hand);
		}

		public static void UPvr_VibrateNeo2Controller(float strength, int time, int hand)
		{
			Pvr_ControllerManager.controllerlink.VibrateNeo2Controller(strength, time, hand);
		}

		public static int UPvr_GetControllerBindingState(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetControllerBindingState(hand);
		}

		public static Vector3 UPvr_GetVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetVelocity(hand);
		}

		public static Vector3 UPvr_GetAngularVelocity(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAngularVelocity(hand);
		}

		public static Vector3 UPvr_GetAcceleration(int hand)
		{
			return Pvr_ControllerManager.controllerlink.GetAcceleration(hand);
		}

		public static void UPvr_ScanController()
		{
			Pvr_ControllerManager.controllerlink.StartScan();
		}

		public static void UPvr_StopScanController()
		{
			Pvr_ControllerManager.controllerlink.StopScan();
		}

		public static void UPvr_ConnectController(string mac)
		{
			if (mac != "")
			{
				Pvr_ControllerManager.controllerlink.hummingBirdMac = mac;
			}
			Pvr_ControllerManager.controllerlink.ConnectBLE();
		}

		public static void UPvr_DisConnectController()
		{
			Pvr_ControllerManager.controllerlink.DisConnectBLE();
		}

		public static void UPvr_ResetController(int hand)
		{
			Pvr_ControllerManager.controllerlink.ResetController(hand);
		}

		public static string UPvr_GetControllerVersion()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerVersion();
		}

		public static void UPvr_GetDeviceVersion(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.GetDeviceVersion(deviceType);
		}

		public static void UPvr_GetControllerSnCode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerSnCode(controllerSerialNum);
		}

		public static void UPvr_SetControllerUnbind(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerUnbind(controllerSerialNum);
		}

		public static void UPvr_SetStationRestart()
		{
			Pvr_ControllerManager.controllerlink.SetStationRestart();
		}

		public static void UPvr_StartStationOtaUpdate()
		{
			Pvr_ControllerManager.controllerlink.StartStationOtaUpdate();
		}

		public static void UPvr_StartControllerOtaUpdate(int mode, int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.StartControllerOtaUpdate(mode, controllerSerialNum);
		}

		public static void UPvr_EnterPairMode(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.EnterPairMode(controllerSerialNum);
		}

		public static void UPvr_SetControllerShutdown(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.SetControllerShutdown(controllerSerialNum);
		}

		public static int UPvr_GetStationPairState()
		{
			return Pvr_ControllerManager.controllerlink.GetStationPairState();
		}

		public static int UPvr_GetStationOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetStationOtaUpdateProgress();
		}

		public static int UPvr_GetControllerOtaUpdateProgress()
		{
			return Pvr_ControllerManager.controllerlink.GetControllerOtaUpdateProgress();
		}

		public static void UPvr_GetControllerVersionAndSN(int controllerSerialNum)
		{
			Pvr_ControllerManager.controllerlink.GetControllerVersionAndSN(controllerSerialNum);
		}

		public static void UPvr_GetControllerUniqueID()
		{
			Pvr_ControllerManager.controllerlink.GetControllerUniqueID();
		}

		public void UPvr_InterruptStationPairMode()
		{
			Pvr_ControllerManager.controllerlink.InterruptStationPairMode();
		}

		public void UPvr_StartCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StartCV2PairingMode(deviceType);
		}

		public void UPvr_StopCV2PairingMode(int deviceType)
		{
			Pvr_ControllerManager.controllerlink.StopCV2PairingMode(deviceType);
		}

		public static void UPvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle)
		{
			Pvr_SetArmModelParameters(hand, gazeType, elbowHeight, elbowDepth, pointerTiltAngle);
		}

		public static void UPvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] controllerPrimary)
		{
			Pvr_CalcArmModelParameters(headOrientation, controllerOrientation, controllerPrimary);
		}

		public static void UPvr_GetPointerPose(float[] rotation, float[] position)
		{
			Pvr_GetPointerPose(rotation, position);
		}

		public static void UPvr_GetElbowPose(float[] rotation, float[] position)
		{
			Pvr_GetElbowPose(rotation, position);
		}

		public static void UPvr_GetWristPose(float[] rotation, float[] position)
		{
			Pvr_GetWristPose(rotation, position);
		}

		public static void UPvr_GetShoulderPose(float[] rotation, float[] position)
		{
			Pvr_GetShoulderPose(rotation, position);
		}

		public static void UPvr_IsEnbleHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.setIsEnbleHomeKey(state);
		}

		public static void UPvr_SwitchHomeKey(bool state)
		{
			Pvr_ControllerManager.controllerlink.SwitchHomeKey(state);
		}

		public static int UPvr_GetControllerSensorStatus(int id)
		{
			return Pvr_ControllerManager.controllerlink.getControllerSensorStatus(id);
		}

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_CalcArmModelParameters(float[] headOrientation, float[] controllerOrientation, float[] gyro);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetPointerPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetElbowPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetWristPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetShoulderPose(float[] rotation, float[] position);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetArmModelParameters(int hand, int gazeType, float elbowHeight, float elbowDepth, float pointerTiltAngle);
	}
	public enum ControllerVariety
	{
		Controller0,
		Controller1
	}
	public enum ControllerDevice
	{
		Goblin,
		Neo,
		G2,
		Neo2,
		Neo3,
		NewController
	}
	public enum PBS_SystemInfoEnum
	{
		ELECTRIC_QUANTITY,
		PUI_VERSION,
		EQUIPMENT_MODEL,
		EQUIPMENT_SN,
		CUSTOMER_SN,
		INTERNAL_STORAGE_SPACE_OF_THE_DEVICE,
		DEVICE_BLUETOOTH_STATUS,
		BLUETOOTH_NAME_CONNECTED,
		BLUETOOTH_MAC_ADDRESS,
		DEVICE_WIFI_STATUS,
		WIFI_NAME_CONNECTED,
		WLAN_MAC_ADDRESS,
		DEVICE_IP
	}
	public enum PBS_DeviceControlEnum
	{
		DEVICE_CONTROL_REBOOT,
		DEVICE_CONTROL_SHUTDOWN
	}
	public enum PBS_PackageControlEnum
	{
		PACKAGE_SILENCE_INSTALL,
		PACKAGE_SILENCE_UNINSTALL
	}
	public enum PBS_SwitchEnum
	{
		S_ON,
		S_OFF
	}
	public enum PBS_HomeEventEnum
	{
		SINGLE_CLICK,
		DOUBLE_CLICK,
		LONG_PRESS
	}
	public enum PBS_HomeFunctionEnum
	{
		VALUE_HOME_GO_TO_SETTING,
		VALUE_HOME_BACK,
		VALUE_HOME_RECENTER,
		VALUE_HOME_OPEN_APP,
		VALUE_HOME_DISABLE,
		VALUE_HOME_GO_TO_HOME,
		VALUE_HOME_SEND_BROADCAST,
		VALUE_HOME_CLEAN_MEMORY
	}
	public enum PBS_ScreenOffDelayTimeEnum
	{
		THREE = 3,
		TEN = 10,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		NEVER = -1
	}
	public enum PBS_SleepDelayTimeEnum
	{
		FIFTEEN = 15,
		THIRTY = 30,
		SIXTY = 60,
		THREE_HUNDRED = 300,
		SIX_HUNDRED = 600,
		ONE_THOUSAND_AND_EIGHT_HUNDRED = 1800,
		NEVER = -1
	}
	public enum PBS_SystemFunctionSwitchEnum
	{
		SFS_USB,
		SFS_AUTOSLEEP,
		SFS_SCREENON_CHARGING,
		SFS_OTG_CHARGING,
		SFS_RETURN_MENU_IN_2DMODE,
		SFS_COMBINATION_KEY,
		SFS_CALIBRATION_WITH_POWER_ON,
		SFS_SYSTEM_UPDATE,
		SFS_CAST_SERVICE,
		SFS_EYE_PROTECTION,
		SFS_SECURITY_ZONE_PERMANENTLY,
		SFS_GLOBAL_CALIBRATION,
		SFS_Auto_Calibration,
		SFS_USB_BOOT
	}
	public enum PBS_USBConfigModeEnum
	{
		MTP,
		CHARGE
	}
	public struct ToBService
	{
		public static Action<bool> BoolCallback;

		public static Action<int> IntCallback;

		public static Action<long> LongCallback;

		private static AndroidJavaClass unityPlayer;

		private static AndroidJavaObject currentActivity;

		private static AndroidJavaObject tobHelper;

		private static AndroidJavaClass tobHelperClass;

		public static void UPvr_InitToBService()
		{
			tobHelperClass = new AndroidJavaClass("com.pvr.tobservice.ToBServiceHelper");
			tobHelper = tobHelperClass.CallStatic<AndroidJavaObject>("getInstance", Array.Empty<object>());
			unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
			currentActivity = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static void UPvr_SetUnityObjectName(string obj)
		{
			System.UPvr_CallMethod(tobHelper, "setUnityObjectName", obj);
		}

		public static void UPvr_BindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "bindTobService", currentActivity);
		}

		public static void UPvr_UnBindToBService()
		{
			System.UPvr_CallMethod(tobHelper, "unBindTobService", currentActivity);
		}

		private static AndroidJavaObject GetEnumType(Enum enumType)
		{
			return new AndroidJavaClass("com.pvr.tobservice.enums" + enumType.GetType().ToString().Replace("Pvr_UnitySDKAPI", "")).GetStatic<AndroidJavaObject>(enumType.ToString());
		}

		public static string UPvr_StateGetDeviceInfo(PBS_SystemInfoEnum type)
		{
			string result = "";
			System.UPvr_CallMethod(ref result, tobHelper, "pbsStateGetDeviceInfo", GetEnumType(type), 0);
			return result;
		}

		public static void UPvr_ControlSetDeviceAction(PBS_DeviceControlEnum deviceControl, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetDeviceAction", GetEnumType(deviceControl), null);
		}

		public static void UPvr_ControlAPPManger(PBS_PackageControlEnum packageControl, string path, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlAPPManger", GetEnumType(packageControl), path, 0, null);
		}

		public static void UPvr_ControlSetAutoConnectWIFI(string ssid, string pwd, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlSetAutoConnectWIFI", ssid, pwd, 0, null);
		}

		public static void UPvr_ControlClearAutoConnectWIFI(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsControlClearAutoConnectWIFI", null);
		}

		public static void UPvr_PropertySetHomeKey(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKey", GetEnumType(eventEnum), GetEnumType(function), null);
		}

		public static void UPvr_PropertySetHomeKeyAll(PBS_HomeEventEnum eventEnum, PBS_HomeFunctionEnum function, int timesetup, string pkg, string className, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetHomeKeyAll", GetEnumType(eventEnum), GetEnumType(function), timesetup, pkg, className, null);
		}

		public static void UPvr_PropertyDisablePowerKey(bool isSingleTap, bool enable, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertyDisablePowerKey", isSingleTap, enable, null);
		}

		public static void UPvr_PropertySetScreenOffDelay(PBS_ScreenOffDelayTimeEnum timeEnum, Action<int> callback)
		{
			if (callback != null)
			{
				IntCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetScreenOffDelay", GetEnumType(timeEnum), null);
		}

		public static void UPvr_PropertySetSleepDelay(PBS_SleepDelayTimeEnum timeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsPropertySetSleepDelay", GetEnumType(timeEnum));
		}

		public static void UPvr_SwitchSystemFunction(PBS_SystemFunctionSwitchEnum systemFunction, PBS_SwitchEnum switchEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSystemFunction", GetEnumType(systemFunction), GetEnumType(switchEnum), 0);
		}

		public static void UPvr_SwitchSetUsbConfigurationOption(PBS_USBConfigModeEnum uSBConfigModeEnum)
		{
			System.UPvr_CallMethod(tobHelper, "pbsSwitchSetUsbConfigurationOption", GetEnumType(uSBConfigModeEnum), 0);
		}

		public static void UPvr_ScreenOn()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOn");
		}

		public static void UPvr_ScreenOff()
		{
			System.UPvr_CallMethod(tobHelper, "pbsScreenOff");
		}

		public static void UPvr_AcquireWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsAcquireWakeLock");
		}

		public static void UPvr_ReleaseWakeLock()
		{
			System.UPvr_CallMethod(tobHelper, "pbsReleaseWakeLock");
		}

		public static void UPvr_EnableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableEnterKey");
		}

		public static void UPvr_DisableEnterKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableEnterKey");
		}

		public static void UPvr_EnableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableVolumeKey");
		}

		public static void UPvr_DisableVolumeKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableVolumeKey");
		}

		public static void UPvr_EnableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsEnableBackKey");
		}

		public static void UPvr_DisableBackKey()
		{
			System.UPvr_CallMethod(tobHelper, "pbsDisableBackKey");
		}

		public static void UPvr_WriteConfigFileToDataLocal(string path, string content, Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsWriteConfigFileToDataLocal", path, content, null);
		}

		public static void UPvr_ResetAllKeyToDefault(Action<bool> callback)
		{
			if (callback != null)
			{
				BoolCallback = callback;
			}
			System.UPvr_CallMethod(tobHelper, "pbsResetAllKeyToDefault", null);
		}
	}
	public enum GlobalIntConfigs
	{
		EYE_TEXTURE_RESOLUTION0,
		EYE_TEXTURE_RESOLUTION1,
		SEENSOR_COUNT,
		ABILITY6DOF,
		PLATFORM_TYPE,
		TRACKING_MODE,
		LOG_LEVEL,
		ENBLE_HAND6DOF_BY_HEAD,
		ENBLE_6DOF_GLOBAL_TRACKING,
		TARGET_FRAME_RATE,
		iShowFPS,
		SensorMode,
		LOGICFLOW,
		EYE_TEXTURE_RES_HIGH,
		EYE_TEXTURE_RES_NORMAL,
		iCtrlModelLoadingPri,
		iPhoneHMDModeEnabled,
		isEnableBoundary,
		Enable_Activity_Rotation,
		GetDisplay_Orientation,
		GetWaitFrameNum,
		GetResetFrameNum,
		EnableFFRBYSYS,
		RotControllerMode
	}
	public enum GlobalFloatConfigs
	{
		IPD,
		VFOV,
		HFOV,
		NECK_MODEL_X,
		NECK_MODEL_Y,
		NECK_MODEL_Z,
		DISPLAY_REFRESH_RATE
	}
	public enum RenderTextureAntiAliasing
	{
		X_1 = 1,
		X_2 = 2,
		X_4 = 4,
		X_8 = 8
	}
	public enum PlatForm
	{
		Android = 1,
		IOS,
		Win,
		Notsupport
	}
	public enum RenderTextureDepth
	{
		BD_0 = 0,
		BD_16 = 16,
		BD_24 = 24
	}
	public enum RenderTextureLevel
	{
		Normal,
		High
	}
	public enum Sensorindex
	{
		Default,
		FirstSensor,
		SecondSensor
	}
	public enum Eye
	{
		LeftEye,
		RightEye,
		BothEye
	}
	public enum ResUtilsType
	{
		TYPE_TEXTSIZE,
		TYPE_COLOR,
		TYPE_TEXT,
		TYPE_FONT,
		TYPE_VALUE,
		TYPE_DRAWABLE,
		TYPE_OBJECT,
		TYPR_OBJECTARRAY
	}
	public enum TrackingOrigin
	{
		EyeLevel,
		FloorLevel,
		StageLevel
	}
	public enum EFoveationLevel
	{
		Low,
		Med,
		High,
		Top_High
	}
	public enum StereoRenderingPathPico
	{
		MultiPass,
		SinglePass
	}
	public enum pvrEyePoseStatus
	{
		kGazePointValid = 1,
		kGazeVectorValid = 2,
		kEyeOpennessValid = 4,
		kEyePupilDilationValid = 8,
		kEyePositionGuideValid = 0x10
	}
	public enum TrackingMode
	{
		PVR_TRACKING_MODE_ROTATION = 1,
		PVR_TRACKING_MODE_POSITION = 2,
		PVR_TRACKING_MODE_EYE = 4
	}
	public struct EyeTrackingData
	{
		public int leftEyePoseStatus;

		public int rightEyePoseStatus;

		public int combinedEyePoseStatus;

		public Vector3 leftEyeGazePoint;

		public Vector3 rightEyeGazePoint;

		public Vector3 combinedEyeGazePoint;

		public Vector3 leftEyeGazeVector;

		public Vector3 rightEyeGazeVector;

		public Vector3 combinedEyeGazeVector;

		public float leftEyeOpenness;

		public float rightEyeOpenness;

		public float leftEyePupilDilation;

		public float rightEyePupilDilation;

		public Vector3 leftEyePositionGuide;

		public Vector3 rightEyePositionGuide;

		public Vector3 foveatedGazeDirection;

		public int foveatedGazeTrackingState;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
		public byte[] reserved;
	}
	public struct EyeTrackingGazeRay
	{
		public Vector3 Direction;

		public bool IsValid;

		public Vector3 Origin;
	}
	public struct EyeDeviceInfo
	{
		public ViewFrustum targetFrustumLeft;

		public ViewFrustum targetFrustumRight;
	}
	public struct ViewFrustum
	{
		public float left;

		public float right;

		public float top;

		public float bottom;

		public float near;

		public float far;
	}
	public struct EyeSetting
	{
		public Transform eyelocalPosition;

		public Rect eyeRect;

		public float eyeFov;

		public float eyeAspect;

		public Matrix4x4 eyeProjectionMatrix;

		public Shader eyeShader;
	}
	public struct Sensor
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Enable6DofModule(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_OptionalResetSensor(int index, int resetRot, int resetPos);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Init(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StartSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_StopSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensor(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_ResetSensorAll(int index);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetPsensorState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdPSensorStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_Get6DofSensorQualityStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_Get6DofSafePanelFlag();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetTrackingOriginType(TrackingOrigin trackingOriginType);

		public static bool UPvr_Pvr_Get6DofSafePanelFlag()
		{
			return Pvr_Get6DofSafePanelFlag();
		}

		public static int UPvr_Init(int index)
		{
			return Pvr_Init(index);
		}

		public static void UPvr_InitPsensor()
		{
			Pvr_InitPsensor();
		}

		public static int UPvr_GetPsensorState()
		{
			int res = -1;
			Render.UPvr_GetIntConfig(4, ref res);
			if (res == 1)
			{
				return Pvr_GetPsensorState();
			}
			int num = Pvr_GetAndroidPsensorState();
			if (num != 0 && num != -1)
			{
				num = 1;
			}
			return num;
		}

		public static int UPvr_GetPSensorStatus()
		{
			return Pvr_GetHmdPSensorStatus();
		}

		public static void UPvr_UnregisterPsensor()
		{
			Pvr_UnregisterPsensor();
		}

		public static int UPvr_StartSensor(int index)
		{
			return Pvr_StartSensor(index);
		}

		public static int UPvr_StopSensor(int index)
		{
			return Pvr_StopSensor(index);
		}

		public static int UPvr_ResetSensor(int index)
		{
			Pvr_UnitySDKManager.SDK.resetBasePos = default(Vector3);
			return Pvr_ResetSensor(index);
		}

		public static int UPvr_OptionalResetSensor(int index, int resetRot, int resetPos)
		{
			return Pvr_OptionalResetSensor(index, resetRot, resetPos);
		}

		public static int UPvr_GetSensorState(int index, ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz)
		{
			return Pvr_GetSensorState(index, ref x, ref y, ref z, ref w, ref px, ref py, ref pz);
		}

		public static int UPvr_GetMainSensorState(ref float x, ref float y, ref float z, ref float w, ref float px, ref float py, ref float pz, ref float vfov, ref float hfov, ref int viewNumber)
		{
			return Pvr_GetMainSensorState(ref x, ref y, ref z, ref w, ref px, ref py, ref pz, ref vfov, ref hfov, ref viewNumber);
		}

		public static int UPvr_GetSensorGyroscope(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorGyroscope(index, ref x, ref y, ref z);
		}

		public static int UPvr_GetSensorMagnet(int index, ref float x, ref float y, ref float z)
		{
			return Pvr_GetSensorMagnet(index, ref x, ref y, ref z);
		}

		public static int UPvr_Get6DofSensorQualityStatus()
		{
			return Pvr_Get6DofSensorQualityStatus();
		}

		public static int UPvr_Enable6DofModule(bool enable)
		{
			return Pvr_Enable6DofModule(enable);
		}

		public static void Pvr_InitPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "initPsensor", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static bool Pvr_IsHead6dofReset()
		{
			int res = 0;
			Render.UPvr_GetIntConfig(17, ref res);
			if (res > 0)
			{
				return false;
			}
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "isHead6dofReset", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static int Pvr_GetAndroidPsensorState()
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getPsensorState");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_UnregisterPsensor()
		{
			try
			{
				System.UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "unregisterListener");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
		}

		public static int UPvr_ResetSensorAll(int index)
		{
			return Pvr_ResetSensorAll(index);
		}

		public static void UPvr_SetReinPosition(float x, float y, float z, float w, float px, float py, float pz, int hand, bool valid, int key)
		{
			if (PLOG.logLevel > 2)
			{
				PLOG.D("PvrLog UPvr_SetReinPosition" + x + y + z + w + px + py + pz + hand + valid + key);
			}
			Pvr_SetReinPosition(x, y, z, w, px, py, pz, hand, valid, key);
		}

		public static bool UPvr_SetTrackingOriginType(TrackingOrigin trackingOriginType)
		{
			return Pvr_SetTrackingOriginType(trackingOriginType);
		}
	}
	public struct Render
	{
		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetRatio(float midH, float midV);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_SetPupillaryPoint(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSupportHMDTypes();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCurrentHMDType([MarshalAs(UnmanagedType.LPStr)] string type);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetIntConfig(int configsenum, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetFloatConfig(int configsenum, ref float res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, float[] mvMatrix, float[] modelS, float[] modelR, float[] modelT, float[] cameraR, float[] cameraT, float[] colorScaleAndOffset);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableFoveation(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationParameters2(float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetFoveationLevel(EFoveationLevel level);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern EFoveationLevel Pvr_GetFoveationLevel();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetIntSysProc(string property, ref int res);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetCastingColorspaceType(int colorspaceType);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_CreateLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetLayerAndroidSurface(int layerType, int layerIndex);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetMonoMode(bool openMono);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexData, ref IntPtr indexData);

		public static void UPvr_ChangeScreenParameters(string model, int width, int height, double xppi, double yppi, double densityDpi)
		{
			Pvr_ChangeScreenParameters(model, width, height, xppi, yppi, densityDpi);
		}

		public static int UPvr_SetRatio(float midH, float midV)
		{
			return Pvr_SetRatio(midH, midV);
		}

		public static void UPvr_EnableFoveation(bool enable)
		{
			if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1 || Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				enable = true;
			}
			Pvr_EnableFoveation(enable);
		}

		[Obsolete("This API will be removed in later versions")]
		public static void UPvr_SetFoveationParameters(int textureId, int previousId, float focalPointX, float focalPointY, float foveationGainX, float foveationGainY, float foveationArea, float foveationMinimum)
		{
			Pvr_SetFoveationParameters(textureId, previousId, focalPointX, focalPointY, foveationGainX, foveationGainY, foveationArea, foveationMinimum);
		}

		public static void UPvr_SetFoveationResource(int textureId, int previousId, float focalPointX, float focalPointY)
		{
			Pvr_SetFoveationResource(textureId, previousId, focalPointX, focalPointY);
		}

		public static void SetFoveatedRenderingLevel(EFoveationLevel level)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationLevel(level);
			}
		}

		public static EFoveationLevel GetFoveatedRenderingLevel()
		{
			return Pvr_GetFoveationLevel();
		}

		public static void SetFoveatedRenderingParameters(Vector2 ffrGainValue, float ffrAreaValue, float ffrMinimumValue)
		{
			if (Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemDebugFFRLevel);
			}
			else if (Pvr_UnitySDKManager.SDK.SystemFFRLevel != -1)
			{
				Pvr_SetFoveationLevel((EFoveationLevel)Pvr_UnitySDKManager.SDK.SystemFFRLevel);
			}
			else
			{
				Pvr_SetFoveationParameters2(ffrGainValue.x, ffrGainValue.y, ffrAreaValue, ffrMinimumValue);
			}
		}

		public static bool UPvr_GetIntSysProc(string property, ref int res)
		{
			return Pvr_GetIntSysProc(property, ref res);
		}

		public static int UPvr_GetIntConfig(int configsenum, ref int res)
		{
			return Pvr_GetIntConfig(configsenum, ref res);
		}

		public static int UPvr_GetFloatConfig(int configsenum, ref float res)
		{
			return Pvr_GetFloatConfig(configsenum, ref res);
		}

		public static string UPvr_GetSupportHMDTypes()
		{
			IntPtr intPtr = Pvr_GetSupportHMDTypes();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return null;
		}

		public static void UPvr_SetCurrentHMDType(string type)
		{
			Pvr_SetCurrentHMDType(type);
		}

		public static void UPvr_SetupLayerData(int layerIndex, int sideMask, int textureId, int textureType, int layerFlags, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetupLayerData(layerIndex, sideMask, textureId, textureType, layerFlags, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetupLayerCoords(int layerIndex, int sideMask, float[] lowerLeft, float[] lowerRight, float[] upperLeft, float[] upperRight)
		{
			Pvr_SetupLayerCoords(layerIndex, sideMask, lowerLeft, lowerRight, upperLeft, upperRight);
		}

		public static void UPvr_SetOverlayModelViewMatrix(int overlayType, int overlayShape, int texId, int eyeSide, int layerIndex, bool isHeadLocked, int layerFlags, Matrix4x4 mvMatrix, Vector3 modelS, Quaternion modelR, Vector3 modelT, Quaternion cameraR, Vector3 cameraT, Vector4 colorScale, Vector4 colorOffset)
		{
			Pvr_SetOverlayModelViewMatrix(overlayType, overlayShape, texId, eyeSide, layerIndex, isHeadLocked, layerFlags, new float[16]
			{
				mvMatrix.m00, mvMatrix.m01, mvMatrix.m02, mvMatrix.m03, mvMatrix.m10, mvMatrix.m11, mvMatrix.m12, mvMatrix.m13, mvMatrix.m20, mvMatrix.m21,
				mvMatrix.m22, mvMatrix.m23, mvMatrix.m30, mvMatrix.m31, mvMatrix.m32, mvMatrix.m33
			}, new float[3] { modelS.x, modelS.y, modelS.z }, new float[4] { modelR.x, modelR.y, modelR.z, modelR.w }, new float[3] { modelT.x, modelT.y, modelT.z }, new float[4] { cameraR.x, cameraR.y, cameraR.z, cameraR.w }, new float[3] { cameraT.x, cameraT.y, cameraT.z }, new float[8] { colorScale.x, colorScale.y, colorScale.z, colorScale.w, colorOffset.x, colorOffset.y, colorOffset.z, colorOffset.w });
		}

		public static void UPvr_SetColorspaceType(int colorspaceType)
		{
			Pvr_SetColorspaceType(colorspaceType);
		}

		public static void UPvr_SetCastingColorspaceType(int colorspaceType)
		{
			Pvr_SetCastingColorspaceType(colorspaceType);
		}

		public static IntPtr UPvr_CreateLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_CreateLayerAndroidSurface(layerType, layerIndex);
		}

		public static IntPtr UPvr_GetLayerAndroidSurface(int layerType, int layerIndex)
		{
			return Pvr_GetLayerAndroidSurface(layerType, layerIndex);
		}

		public static void UPvr_SetMonoMode(bool openMono)
		{
			Pvr_SetMonoMode(openMono);
		}

		public static void UPvr_GetStencilMesh(int eye, ref int vertexCount, ref int triangleCount, ref IntPtr vertexDataPtr, ref IntPtr indexDataPtr)
		{
			Pvr_GetStencilMesh(eye, ref vertexCount, ref triangleCount, ref vertexDataPtr, ref indexDataPtr);
		}
	}
	public struct System
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public const string UnitySDKVersion = "2.8.9.12";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern IntPtr Pvr_GetSDKVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetHmdHardwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdFirmwareVersion();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr Pvr_GetHmdSerialNumber();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdBatteryStatus();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float PVR_GetHmdBatteryTemperature();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_SetHmdAudioStatus(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingData(ref int leftEyePoseStatus, ref int rightEyePoseStatus, ref int combinedEyePoseStatus, ref float leftEyeGazePointX, ref float leftEyeGazePointY, ref float leftEyeGazePointZ, ref float rightEyeGazePointX, ref float rightEyeGazePointY, ref float rightEyeGazePointZ, ref float combinedEyeGazePointX, ref float combinedEyeGazePointY, ref float combinedEyeGazePointZ, ref float leftEyeGazeVectorX, ref float leftEyeGazeVectorY, ref float leftEyeGazeVectorZ, ref float rightEyeGazeVectorX, ref float rightEyeGazeVectorY, ref float rightEyeGazeVectorZ, ref float combinedEyeGazeVectorX, ref float combinedEyeGazeVectorY, ref float combinedEyeGazeVectorZ, ref float leftEyeOpenness, ref float rightEyeOpenness, ref float leftEyePupilDilation, ref float rightEyePupilDilation, ref float leftEyePositionGuideX, ref float leftEyePositionGuideY, ref float leftEyePositionGuideZ, ref float rightEyePositionGuideX, ref float rightEyePositionGuideY, ref float rightEyePositionGuideZ, ref float foveatedGazeDirectionX, ref float foveatedGazeDirectionY, ref float foveatedGazeDirectionZ, ref int foveatedGazeTrackingState);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingMode(int trackingMode);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int Pvr_GetTrackingMode();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr GetRenderEventFunc();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void UnityEventData(long data);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_EnableSinglePass(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetAntiAliasing(int antiAliasing);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SinglePassBeforeForwardOpaque();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetCurrentRenderTexture(uint textureId);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetSinglePassDepthBufferWidthHeight(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_setPerformanceLevels(int cpuLevel, int gpuLevel);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetIPD(float distance);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern float Pvr_GetIPD();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_SetTrackingIPDEnabled(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetTrackingIPDEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool Pvr_GetEyeTrackingAutoIPD(ref float autoIPD);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern int PVR_GetHmdAudioStatus();

		public static bool UPvr_CallStaticMethod<T>(ref T result, AndroidJavaClass jclass, string name, params object[] args)
		{
			try
			{
				result = jclass.CallStatic<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling static method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallStaticMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.CallStatic(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("CallStaticMethod  Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod<T>(ref T result, AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				result = jobj.Call<T>(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E("Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static bool UPvr_CallMethod(AndroidJavaObject jobj, string name, params object[] args)
		{
			try
			{
				jobj.Call(name, args);
				return true;
			}
			catch (AndroidJavaException ex)
			{
				PLOG.E(" Exception calling activity method " + name + ": " + ex);
				return false;
			}
		}

		public static string UPvr_GetSDKVersion()
		{
			IntPtr intPtr = Pvr_GetSDKVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetUnitySDKVersion()
		{
			return "2.8.9.12";
		}

		public static string UPvr_GetDeviceMode()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceModel()
		{
			return SystemInfo.deviceModel;
		}

		public static string UPvr_GetDeviceSN()
		{
			string result = "UNKONWN";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaSysActivityClass, "getDeviceSN");
			return result;
		}

		public static AndroidJavaObject UPvr_GetCurrentActivity()
		{
			return new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
		}

		public static bool UPvr_SetMonoPresentation()
		{
			return UPvr_CallMethod(UPvr_GetCurrentActivity(), "Pvr_setMonoPresentation");
		}

		public static bool UPvr_IsPresentationExisted()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_isPresentationExisted") && result;
		}

		public static bool UPvr_GetMainActivityPauseStatus()
		{
			bool result = false;
			return UPvr_CallMethod(ref result, UPvr_GetCurrentActivity(), "Pvr_getMainActivityPauseStatus") && result;
		}

		public static void UPvr_Sleep()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaSysActivityClass, "Pvr_Sleep");
		}

		public static bool UPvr_StartHomeKeyReceiver(string startreceivre)
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
					PLOG.I("Start home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Start home key  Receiver  Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static bool UPvr_StopHomeKeyReceiver()
		{
			try
			{
				if (Pvr_UnitySDKRender.Instance != null)
				{
					UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityLongReceiver, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
					PLOG.I("Stop home key Receiver");
					return true;
				}
			}
			catch (Exception ex)
			{
				PLOG.E("Stop home key Receiver Error :" + ex.ToString());
				return false;
			}
			return true;
		}

		public static void UPvr_StartVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "startVRModel");
		}

		public static void UPvr_RemovePlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "removePlatformLogo");
		}

		public static void UPvr_ShowPlatformLogo()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "showPlatformLogo");
		}

		public static bool UPvr_IsPicoActivity()
		{
			bool result = false;
			return UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "isPicoActivity", UPvr_GetCurrentActivity()) && result;
		}

		public static void UPvr_StopVRModel()
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClass, "stopVRModel");
		}

		public static string UPvr_GetCountryCode()
		{
			string result = "";
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCountryCode", UPvr_GetCurrentActivity());
			return result;
		}

		public static bool UPvr_SetIPD(float distance)
		{
			bool flag = false;
			flag = Pvr_SetIPD(distance);
			if (flag)
			{
				for (int i = 0; i < Pvr_UnitySDKEyeManager.Instance.Eyes.Length; i++)
				{
					Pvr_UnitySDKEyeManager.Instance.Eyes[i].RefreshCameraPosition(distance);
				}
			}
			return flag;
		}

		public static float UPvr_GetIPD()
		{
			float result = Pvr_GetIPD();
			UnityEngine.Debug.Log("DISFT IPD:" + result);
			return result;
		}

		public static bool UPvr_SetTrackingIPDEnabled(bool enable)
		{
			return Pvr_SetTrackingIPDEnabled(enable);
		}

		public static bool UPvr_GetTrackingIPDEnabled()
		{
			return Pvr_GetTrackingIPDEnabled();
		}

		public static bool UPvr_GetEyeTrackingAutoIPD(ref float autoipd)
		{
			return Pvr_GetEyeTrackingAutoIPD(ref autoipd);
		}

		public static void UPvr_UnityEventData(long data)
		{
			UnityEventData(data);
		}

		public static long UPvr_GetEyeBufferData(int id)
		{
			return ((long)Pvr_UnitySDKRender.Instance.RenderviewNumber << 32) | id;
		}

		public static bool UPvr_checkDevice(string packagename)
		{
			bool result = false;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "checkDevice", packagename, UPvr_GetCurrentActivity());
			return result;
		}

		public static int UPvr_GetHmdHardwareVersion()
		{
			return Pvr_GetHmdHardwareVersion();
		}

		public static string UPvr_GetHmdFirmwareVersion()
		{
			IntPtr intPtr = Pvr_GetHmdFirmwareVersion();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static string UPvr_GetHmdSerialNumber()
		{
			IntPtr intPtr = Pvr_GetHmdSerialNumber();
			if (intPtr != IntPtr.Zero)
			{
				return Marshal.PtrToStringAnsi(intPtr);
			}
			return "";
		}

		public static int UPvr_GetHmdBatteryStatus()
		{
			return PVR_GetHmdBatteryStatus();
		}

		public static float UPvr_GetHmdBatteryTemperature()
		{
			return PVR_GetHmdBatteryTemperature();
		}

		public static int UPvr_SetHmdAudioStatus(bool enable)
		{
			return PVR_SetHmdAudioStatus(enable);
		}

		public static int UPvr_GetTrackingMode()
		{
			return Pvr_GetTrackingMode();
		}

		public static bool UPvr_setTrackingMode(int trackingMode)
		{
			return Pvr_SetTrackingMode(trackingMode);
		}

		public static bool UPvr_getEyeTrackingData(ref EyeTrackingData trackingData)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			bool result = Pvr_GetEyeTrackingData(ref trackingData.leftEyePoseStatus, ref trackingData.rightEyePoseStatus, ref trackingData.combinedEyePoseStatus, ref trackingData.leftEyeGazePoint.x, ref trackingData.leftEyeGazePoint.y, ref trackingData.leftEyeGazePoint.z, ref trackingData.rightEyeGazePoint.x, ref trackingData.rightEyeGazePoint.y, ref trackingData.rightEyeGazePoint.z, ref trackingData.combinedEyeGazePoint.x, ref trackingData.combinedEyeGazePoint.y, ref trackingData.combinedEyeGazePoint.z, ref trackingData.leftEyeGazeVector.x, ref trackingData.leftEyeGazeVector.y, ref trackingData.leftEyeGazeVector.z, ref trackingData.rightEyeGazeVector.x, ref trackingData.rightEyeGazeVector.y, ref trackingData.rightEyeGazeVector.z, ref trackingData.combinedEyeGazeVector.x, ref trackingData.combinedEyeGazeVector.y, ref trackingData.combinedEyeGazeVector.z, ref trackingData.leftEyeOpenness, ref trackingData.rightEyeOpenness, ref trackingData.leftEyePupilDilation, ref trackingData.rightEyePupilDilation, ref trackingData.leftEyePositionGuide.x, ref trackingData.leftEyePositionGuide.y, ref trackingData.leftEyePositionGuide.z, ref trackingData.rightEyePositionGuide.x, ref trackingData.rightEyePositionGuide.y, ref trackingData.rightEyePositionGuide.z, ref trackingData.foveatedGazeDirection.x, ref trackingData.foveatedGazeDirection.y, ref trackingData.foveatedGazeDirection.z, ref trackingData.foveatedGazeTrackingState);
			trackingData.leftEyeGazeVector.z = 0f - trackingData.leftEyeGazeVector.z;
			trackingData.rightEyeGazeVector.z = 0f - trackingData.rightEyeGazeVector.z;
			trackingData.combinedEyeGazeVector.z = 0f - trackingData.combinedEyeGazeVector.z;
			trackingData.leftEyeGazePoint.z = 0f - trackingData.leftEyeGazePoint.z;
			trackingData.rightEyeGazePoint.z = 0f - trackingData.rightEyeGazePoint.z;
			trackingData.combinedEyeGazePoint.z = 0f - trackingData.combinedEyeGazePoint.z;
			trackingData.foveatedGazeDirection.z = 0f - trackingData.foveatedGazeDirection.z;
			return result;
		}

		public static bool UPvr_getEyeTrackingGazeRay(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = Pvr_UnitySDKSensor.Instance.HeadPose.Matrix.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static bool UPvr_getEyeTrackingGazeRayWorld(ref EyeTrackingGazeRay gazeRay)
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return false;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return false;
			}
			Transform transform = Pvr_UnitySDKEyeManager.Instance.transform;
			Matrix4x4 matrix4x = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);
			EyeTrackingData trackingData = default(EyeTrackingData);
			UPvr_getEyeTrackingData(ref trackingData);
			gazeRay.IsValid = ((uint)trackingData.combinedEyePoseStatus & (true ? 1u : 0u)) != 0 && (trackingData.combinedEyePoseStatus & 2) != 0;
			if (gazeRay.IsValid)
			{
				gazeRay.Direction = trackingData.combinedEyeGazeVector;
				gazeRay.Origin = trackingData.combinedEyeGazePoint;
				gazeRay.Origin = matrix4x.MultiplyPoint(gazeRay.Origin);
				gazeRay.Direction = matrix4x.MultiplyVector(gazeRay.Direction);
				return true;
			}
			return false;
		}

		public static Vector3 UPvr_getEyeTrackingPos()
		{
			if (!Pvr_UnitySDKEyeManager.supportEyeTracking)
			{
				PLOG.E("The device is not supported");
				return Vector3.zero;
			}
			if (!Pvr_UnitySDKEyeManager.Instance.EyeTracking)
			{
				PLOG.E("Please Enable \"Pvr_UnitySDK/Head/Pvr_UnitySDKEyeManager.cs/EyeTracking\"option first.");
				return Vector3.zero;
			}
			return Pvr_UnitySDKEyeManager.Instance.GetEyeTrackingPos();
		}

		public static int UPvr_GetPhoneScreenBrightness()
		{
			int result = 0;
			UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_GetScreen_Brightness", UPvr_GetCurrentActivity());
			return result;
		}

		public static void UPvr_SetPhoneScreenBrightness(int level)
		{
			UPvr_CallStaticMethod(Pvr_UnitySDKRender.javaVrActivityClientClass, "Pvr_setAPPScreen_Brightness", UPvr_GetCurrentActivity(), level);
		}

		public static bool UPvr_IsPicoDefaultActivity()
		{
			using (AndroidJavaClass androidJavaClass = new AndroidJavaClass("com.unity3d.player.UnityPlayer"))
			{
				using AndroidJavaObject androidJavaObject = androidJavaClass.GetStatic<AndroidJavaObject>("currentActivity");
				if (androidJavaObject.Call<string>("getLocalClassName", Array.Empty<object>()) == "com.unity3d.player.UnityPlayerNativeActivityPico")
				{
					return true;
				}
			}
			return false;
		}

		public static bool UPvr_EnableSinglePass(bool enable)
		{
			return Pvr_EnableSinglePass(enable);
		}

		public static void UPvr_SetAntiAliasing(int antiAliasing)
		{
			Pvr_SetAntiAliasing(antiAliasing);
		}

		public static void UPvr_SinglePassBeforeForwardOpaque()
		{
			Pvr_SinglePassBeforeForwardOpaque();
		}

		public static void UPvr_SetCurrentRenderTexture(uint textureId)
		{
			Pvr_SetCurrentRenderTexture(textureId);
		}

		public static bool UPvr_SetSinglePassDepthBufferWidthHeight(int width, int height)
		{
			return Pvr_SetSinglePassDepthBufferWidthHeight(width, height);
		}

		public static int UPVR_setPerformanceLevels(int cpuLevel, int gpuLevel)
		{
			return PVR_setPerformanceLevels(cpuLevel, gpuLevel);
		}

		public static int UPvr_GetColorRes(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getColorRes", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetColorResError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetConfigInt(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigInt", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigIntError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetConfigString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getConfigString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetConfigStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetDrawableLocation(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDrawableLocation", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetDrawableLocationError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetTextSize(string name)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getTextSize", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetTextSizeError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetLangString(string name)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getLangString", name);
			}
			catch (Exception ex)
			{
				PLOG.E("GetLangStringError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetStringValue(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getStringValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetStringValueError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetIntValue(string id, int type)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getIntValue", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetIntValueError :" + ex.ToString());
			}
			return result;
		}

		public static float UPvr_GetFloatValue(string id)
		{
			float result = -1f;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getFloatValue", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetFloatValueError :" + ex.ToString());
			}
			return result;
		}

		public static string UPvr_GetObjectOrArray(string id, int type)
		{
			string result = "";
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getObjectOrArray", id, type);
			}
			catch (Exception ex)
			{
				PLOG.E("GetObjectOrArrayError :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCharSpace(string id)
		{
			int result = -1;
			try
			{
				UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getCharSpace", id);
			}
			catch (Exception ex)
			{
				PLOG.E("GetCharSpaceError :" + ex.ToString());
			}
			return result;
		}
	}
	public struct BoundarySystem
	{
		public enum BoundaryType
		{
			OuterBoundary,
			PlayArea
		}

		public struct BoundaryTestResult
		{
			public bool IsTriggering;

			public float ClosestDistance;

			public Vector3 ClosestPoint;

			public Vector3 ClosestPointNormal;
		}

		public enum BoundaryTrackingNode
		{
			HandLeft,
			HandRight,
			Head
		}

		public enum BoundaryTrackingState
		{
			PVR_NOREASON,
			PVRRELOCATION_IN_PROGRESS,
			PVRLOW_FEATURE_COUNT_ERROR,
			PVRLOW_LIGHT_ERROR,
			PVRBRIGHT_LIGHT_ERROR,
			PVRSTEREO_CAMERA_CALIBRATION_ERROR
		}

		public const string LibFileName = "Pvr_UnitySDK";

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern float Pvr_GetFloorHeight();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetSeeThroughState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSTBackground(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetTrackingState();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_GetFrameRateLimit();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsBoundaryEnable();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetConfigured();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestNode(int node, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryTestPoint(float x, float y, float z, bool isPlayArea, ref bool isTriggering, ref float closestDistance, ref float px, ref float py, ref float pz, ref float nx, ref float ny, ref float nz);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetGeometry(out IntPtr handle, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_BoundaryGetDimensions(ref float x, ref float y, ref float z, bool isPlayArea);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetEnabled();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_BoundaryGetVisible();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_EnableLWRP(bool enable);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetViewportSize(int w, int h);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_BoundarySetSeeThroughVisible(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void PVR_SetCameraImageRect(int width, int height);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern void Pvr_SetGuardianSystemDisable(bool value);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetDialogState();

		public static float UPvr_GetFloorHeight()
		{
			return Pvr_GetFloorHeight();
		}

		public static int UPvr_GetSeeThroughState()
		{
			return Pvr_GetSeeThroughState();
		}

		public static void UPvr_EnableSeeThroughManual(bool enable)
		{
			Pvr_BoundarySetSTBackground(enable);
		}

		public static BoundaryTrackingState UPvr_GetTrackingState()
		{
			return (BoundaryTrackingState)Pvr_GetTrackingState();
		}

		public static bool UPvr_GetFrameRateLimit()
		{
			return Pvr_GetFrameRateLimit();
		}

		public static bool UPvr_IsBoundaryEnable()
		{
			return Pvr_IsBoundaryEnable();
		}

		public static bool UPvr_BoundaryGetConfigured()
		{
			return Pvr_BoundaryGetConfigured();
		}

		public static BoundaryTestResult UPvr_BoundaryTestNode(BoundaryTrackingNode node, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			bool num = Pvr_BoundaryTestNode((int)node, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z);
			result.ClosestPoint.z = 0f - result.ClosestPoint.z;
			result.ClosestPointNormal.z = 0f - result.ClosestPointNormal.z;
			if (!num)
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestNode({node}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static BoundaryTestResult UPvr_BoundaryTestPoint(Vector3 point, BoundaryType boundaryType)
		{
			BoundaryTestResult result = default(BoundaryTestResult);
			if (!Pvr_BoundaryTestPoint(point.x, point.y, 0f - point.z, boundaryType == BoundaryType.PlayArea, ref result.IsTriggering, ref result.ClosestDistance, ref result.ClosestPoint.x, ref result.ClosestPoint.y, ref result.ClosestPoint.z, ref result.ClosestPointNormal.x, ref result.ClosestPointNormal.y, ref result.ClosestPointNormal.z))
			{
				UnityEngine.Debug.LogError($"UPvr_BoundaryTestPoint({point}, {boundaryType}) API call failed!");
			}
			return result;
		}

		public static Vector3[] UPvr_BoundaryGetGeometry(BoundaryType boundaryType)
		{
			IntPtr handle = IntPtr.Zero;
			int num = Pvr_BoundaryGetGeometry(out handle, boundaryType == BoundaryType.PlayArea);
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("Boundary geometry point count is " + num);
				return null;
			}
			int num2 = num * 3;
			float[] array = new float[num2];
			Marshal.Copy(handle, array, 0, num2);
			Vector3[] array2 = new Vector3[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = new Vector3
				{
					x = array[3 * i],
					y = array[3 * i + 1],
					z = 0f - array[3 * i + 2]
				};
			}
			return array2;
		}

		public static Vector3 UPvr_BoundaryGetDimensions(BoundaryType boundaryType)
		{
			float x = 0f;
			float y = 0f;
			float z = 0f;
			Pvr_BoundaryGetDimensions(ref x, ref y, ref z, boundaryType == BoundaryType.PlayArea);
			return new Vector3(x, y, z);
		}

		public static bool UPvr_BoundaryGetEnabled()
		{
			return Pvr_BoundaryGetEnabled();
		}

		public static void UPvr_BoundarySetVisible(bool value)
		{
			Pvr_BoundarySetVisible(value);
		}

		public static bool UPvr_BoundaryGetVisible()
		{
			return Pvr_BoundaryGetVisible();
		}

		public static bool UPvr_EnableLWRP(bool enable)
		{
			return Pvr_EnableLWRP(enable);
		}

		public static bool UPvr_SetViewportSize(int width, int height)
		{
			return Pvr_SetViewportSize(width, height);
		}

		public static void UPvr_StartCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StartCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StartCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_StopCameraFrame()
		{
			try
			{
				Pvr_UnitySDKPluginEvent.Issue(RenderEventType.StopCameraFrame);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_StopCameraFrame :" + ex.ToString());
			}
		}

		public static void UPvr_BoundaryGetSeeThroughData(int cameraIndex, RenderTexture renderTexture)
		{
			try
			{
				if (renderTexture.IsCreated())
				{
					System.UPvr_UnityEventData(renderTexture.GetNativeTexturePtr().ToInt32());
					switch (cameraIndex)
					{
					case 0:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameLeft);
						break;
					case 1:
						Pvr_UnitySDKPluginEvent.Issue(RenderEventType.CameraFrameRight);
						break;
					}
				}
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundaryGetSeeThroughDataError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetCameraImageRect(int width, int height)
		{
			try
			{
				PVR_SetCameraImageRect(width, height);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetCameraImageRectError :" + ex.ToString());
			}
		}

		public static void UPvr_BoundarySetSeeThroughVisible(bool value)
		{
			try
			{
				Pvr_BoundarySetSeeThroughVisible(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_BoundarySetSeeThroughVisibleError :" + ex.ToString());
			}
		}

		public static void UPvr_SetGuardianSystemDisable(bool value)
		{
			try
			{
				Pvr_SetGuardianSystemDisable(value);
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_SetGuardianSystemDisableError :" + ex.ToString());
			}
		}

		public static int UPvr_GetDialogState()
		{
			int result = 0;
			try
			{
				result = Pvr_GetDialogState();
			}
			catch (Exception ex)
			{
				PLOG.E("UPvr_GetDialogStateError :" + ex.ToString());
			}
			return result;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct PlatformSettings
	{
		public static Pvr_UnitySDKPlatformSetting.simulationType UPvr_IsCurrentDeviceValid()
		{
			if (Pvr_UnitySDKPlatformSetting.Entitlementchecksimulation)
			{
				if (Pvr_UnitySDKPlatformSetting.Instance.deviceSN.Count <= 0)
				{
					UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Null");
					return Pvr_UnitySDKPlatformSetting.simulationType.Null;
				}
				foreach (string item in Pvr_UnitySDKPlatformSetting.Instance.deviceSN)
				{
					if (System.UPvr_GetDeviceSN() == item)
					{
						return Pvr_UnitySDKPlatformSetting.simulationType.Valid;
					}
				}
				UnityEngine.Debug.Log("DISFT Entitlement Check Simulation deviceSN is Invalid");
				return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
			}
			UnityEngine.Debug.Log("DISFT Entitlement Check Simulation DO NOT Enable");
			return Pvr_UnitySDKPlatformSetting.simulationType.Invalid;
		}

		public static bool UPvr_AppEntitlementCheck(string appid)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), appid, "");
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_AppEntitlementCheck" + result);
			return result;
		}

		[Obsolete("This API will be removed in later versions")]
		public static bool UPvr_KeyEntitlementCheck(string publicKey)
		{
			bool result = false;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPP", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_AppEntitlementCheckExtra(string appid)
		{
			return 0;
		}

		public static int UPvr_KeyEntitlementCheckExtra(string publicKey)
		{
			int result = -1;
			try
			{
				System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "verifyAPPExt", System.UPvr_GetCurrentActivity(), "", publicKey);
			}
			catch (Exception ex)
			{
				PLOG.E("Error :" + ex.ToString());
			}
			UnityEngine.Debug.Log("PvrLog UPvr_KeyEntitlementCheck" + result);
			return result;
		}

		public static int UPvr_GetHmdAudioStatus()
		{
			return System.PVR_GetHmdAudioStatus();
		}
	}
	public enum DeviceCommand
	{
		SET_PICO_NEO_HMD_BRIGHTNESS = 12,
		SET_PICO_NEO_HMD_SLEEPDELAY
	}
	public enum BrightnessLevel
	{
		VR_BRIGHTNESS_LEVEL_MIN = 1,
		VR_BRIGHTNESS_LEVEL_MAX = 100,
		VR_BRIGHTNESS_LEVEL_DOWN = 1000,
		VR_BRIGHTNESS_LEVEL_UP = 1001,
		VR_BRIGHTNESS_LEVEL_SCREEN_OFF = -100
	}
	public struct VolumePowerBrightness
	{
		public const string LibFileName = "Pvr_UnitySDK";

		public AndroidJavaObject activity;

		public static AndroidJavaClass javaSysActivityClass;

		private static AndroidJavaClass batteryjavaVrActivityClass;

		private static AndroidJavaClass volumejavaVrActivityClass;

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		public static extern void Pvr_SetInitActivity(IntPtr activity, IntPtr vrActivityClass);

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_IsHmdExist();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern int Pvr_GetHmdScreenBrightness();

		[DllImport("Pvr_UnitySDK", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool Pvr_SetHmdScreenBrightness(int brightness);

		public static bool UPvr_IsHmdExist()
		{
			return Pvr_IsHmdExist();
		}

		public static int UPvr_GetHmdScreenBrightness()
		{
			return Pvr_GetHmdScreenBrightness();
		}

		public static bool UPvr_SetHmdScreenBrightness(int brightness)
		{
			return Pvr_SetHmdScreenBrightness(brightness);
		}

		public static bool UPvr_SetCommonBrightness(int brightness)
		{
			bool flag = false;
			if (UPvr_IsHmdExist())
			{
				return UPvr_SetHmdScreenBrightness(brightness);
			}
			return UPvr_SetBrightness(brightness);
		}

		public static int UPvr_GetCommonBrightness()
		{
			int num = 0;
			if (UPvr_IsHmdExist())
			{
				return UPvr_GetHmdScreenBrightness();
			}
			return UPvr_GetCurrentBrightness();
		}

		public static int[] UPvr_GetScreenBrightnessLevel()
		{
			return Pvr_GetScreenBrightnessLevel();
		}

		public static void UPvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			Pvr_SetScreenBrightnessLevel(vrBrightness, level);
		}

		public static bool UPvr_SetDevicePropForUser(DeviceCommand deviceid, string number)
		{
			return setDevicePropForUser(deviceid, number);
		}

		public static string UPvr_GetDevicePropForUser(DeviceCommand deviceid)
		{
			return getDevicePropForUser(deviceid);
		}

		public static bool UPvr_InitBatteryClass()
		{
			try
			{
				if (javaSysActivityClass == null)
				{
					javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				}
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					if (batteryjavaVrActivityClass == null)
					{
						batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					}
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_InitBatteryVolClass()
		{
			try
			{
				javaSysActivityClass = new AndroidJavaClass("com.psmart.aosoperation.SysActivity");
				if (javaSysActivityClass != null && Pvr_UnitySDKRender.Instance.activity != null)
				{
					batteryjavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.BatteryReceiver");
					volumejavaVrActivityClass = new AndroidJavaClass("com.psmart.aosoperation.AudioReceiver");
					System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_InitAudioDevice", Pvr_UnitySDKRender.Instance.activity);
					return true;
				}
				return false;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StartBatteryReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopBatteryReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(batteryjavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetBrightness(int brightness)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_SetScreen_Brightness", brightness, Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetCurrentBrightness()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetScreen_Brightness", Pvr_UnitySDKRender.Instance.activity);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int[] Pvr_GetScreenBrightnessLevel()
		{
			int[] result = new int[1];
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "getScreenBrightnessLevel");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static void Pvr_SetScreenBrightnessLevel(int vrBrightness, int level)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "setScreenBrightnessLevel", vrBrightness, level);
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
		}

		public static bool UPvr_StartAudioReceiver(string startreceivre)
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StartReceiver", Pvr_UnitySDKRender.Instance.activity, startreceivre);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_StopAudioReceiver()
		{
			try
			{
				System.UPvr_CallStaticMethod(volumejavaVrActivityClass, "Pvr_StopReceiver", Pvr_UnitySDKRender.Instance.activity);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E("startReceiver Error :" + ex.ToString());
				return false;
			}
		}

		public static int UPvr_GetMaxVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetMaxAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static int UPvr_GetCurrentVolumeNumber()
		{
			int result = 0;
			try
			{
				System.UPvr_CallStaticMethod(ref result, javaSysActivityClass, "Pvr_GetAudionumber");
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
			}
			return result;
		}

		public static bool UPvr_VolumeUp()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_UpAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_VolumeDown()
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_DownAudio");
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetVolumeNum(int volume)
		{
			try
			{
				System.UPvr_CallStaticMethod(javaSysActivityClass, "Pvr_ChangeAudio", volume);
				return true;
			}
			catch (Exception ex)
			{
				PLOG.E(" Error :" + ex.ToString());
				return false;
			}
		}

		public static bool UPvr_SetAudio(string s)
		{
			return false;
		}

		public static bool UPvr_SetBattery(string s)
		{
			return false;
		}

		private static string getDevicePropForUser(DeviceCommand deviceid)
		{
			string result = "0";
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "getDevicePropForUser", (int)deviceid);
			return result;
		}

		private static bool setDevicePropForUser(DeviceCommand deviceid, string number)
		{
			bool result = false;
			System.UPvr_CallStaticMethod(ref result, Pvr_UnitySDKRender.javaVrActivityClass, "setDevicePropForUser", (int)deviceid, number);
			return result;
		}
	}
}
namespace Pvr_UnitySDKAPI.Achievement
{
	public sealed class AchievementCore
	{
		private static bool IsPlatformInitialized = true;

		public static bool LogMessages = false;

		public static bool IsInitialized()
		{
			return IsPlatformInitialized;
		}

		public static void Initialize()
		{
		}

		public static void RegisterNetwork()
		{
			Pvr_AchievementAPI.RegisterNetwork();
		}

		public static void UnRegisterNetwork()
		{
			Pvr_AchievementAPI.UnRegisterNetwork();
		}
	}
	public static class Achievements
	{
		public static Pvr_Request<Pvr_AchievementUpdate> Init()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.Init());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddCount(string name, long count)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddCount(name, count));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> AddFields(string name, string fields)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_AddFields(name, fields));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetAllDefinitions()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetAllDefinitions());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetAllProgress()
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetAllProgress());
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetDefinitionsByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_Achievements_GetDefinitionsByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetProgressByName(string[] names)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_Achievements_GetProgressByName(names, (names != null) ? names.Length : 0));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementUpdate> Unlock(string name)
		{
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementUpdate>(Pvr_AchievementAPI.pvr_Achievements_Unlock(name));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementDefinitionList> GetNextAchievementDefinitionListPage(Pvr_AchievementDefinitionList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementDefinitionListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementDefinitionList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage));
			}
			return null;
		}

		public static Pvr_Request<Pvr_AchievementProgressList> GetNextAchievementProgressListPage(Pvr_AchievementProgressList list)
		{
			if (!list.HasNextPage)
			{
				UnityEngine.Debug.LogWarning("Platform.GetNextAchievementProgressListPage: List has no next page");
				return null;
			}
			if (AchievementCore.IsInitialized())
			{
				return new Pvr_Request<Pvr_AchievementProgressList>(Pvr_AchievementAPI.pvr_HTTP_GetWithMessageType(list.NextUrl, Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage));
			}
			return null;
		}
	}
	public enum AchievementType
	{
		[Description("UNKNOWN")]
		Unknown,
		[Description("SIMPLE")]
		Simple,
		[Description("BITFIELD")]
		Bitfield,
		[Description("COUNT")]
		Count
	}
	public class Pvr_AchievementAPI
	{
		private static AndroidJavaClass achievementAPI = new AndroidJavaClass("com.pico.achievenment.AchievementAPI");

		private static AndroidJavaClass definitionArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionArrayHandle");

		private static AndroidJavaClass definitionHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementDefinitionHandle");

		private static AndroidJavaClass progressArrayHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressArrayHandle");

		private static AndroidJavaClass progressHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementProgressHandle");

		private static AndroidJavaClass updateHandle = new AndroidJavaClass("com.picovr.achievement.utils.pvrAchievementUpdateHandle");

		private static AndroidJavaObject errorHandle = new AndroidJavaObject("com.picovr.achievement.utils.pvrAchievementErrorHandle");

		private static AndroidJavaObject unityInterface = new AndroidJavaObject("com.pico.loginpaysdk.UnityInterface");

		private static string openId;

		private static string accessToken;

		private static string appId = Pvr_UnitySDKPlatformSetting.Instance.appID;

		internal static long Init()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			unityInterface.Call("init", @static);
			unityInterface.Call("authSSO");
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.pico.loginpaysdk.utils.PicoAccessTokenKeeper").CallStatic<AndroidJavaObject>("readAccessToken", new object[1] { @static });
			accessToken = androidJavaObject.Call<string>("getAccessToken", Array.Empty<object>());
			openId = androidJavaObject.Call<string>("getOpenId", Array.Empty<object>());
			return achievementAPI.CallStatic<long>("init", new object[3] { accessToken, openId, @static });
		}

		internal static void RegisterNetwork()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			achievementAPI.CallStatic("registerNetwork", @static);
		}

		internal static void UnRegisterNetwork()
		{
			achievementAPI.CallStatic("unregisterNetwork");
		}

		internal static AndroidJavaObject PopMessage()
		{
			return achievementAPI.CallStatic<AndroidJavaObject>("pvr_PopMessage", Array.Empty<object>());
		}

		internal static string pvr_Error_GetMessage(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<string>("pvr_Error_GetMessage", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetHttpCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetHttpCode", new object[1] { popMessage });
		}

		internal static int pvr_Error_GetCode(AndroidJavaObject popMessage)
		{
			return errorHandle.CallStatic<int>("pvr_Error_GetCode", new object[1] { popMessage });
		}

		internal static long pvr_Achievements_AddCount(string name, long count)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddCount", new object[3] { name, count, accessToken });
		}

		internal static long pvr_Achievements_AddFields(string name, string fields)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_AddFields", new object[3] { name, fields, accessToken });
		}

		internal static long pvr_Achievements_GetAllDefinitions()
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitions", new object[2] { appId, @static });
		}

		internal static long pvr_Achievements_GetAllProgress()
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgress", new object[1] { accessToken });
		}

		internal static long pvr_Achievements_GetDefinitionsByName(string[] names, int v)
		{
			AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetDefinitionsByName", new object[2] { names, @static });
		}

		internal static long pvr_Achievements_GetProgressByName(string[] names, int v)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_GetProgressByName", new object[2] { names, accessToken });
		}

		internal static long pvr_Achievements_Unlock(string name)
		{
			return achievementAPI.CallStatic<long>("pvr_Achievements_Unlock", new object[2] { name, accessToken });
		}

		internal static long pvr_HTTP_GetWithMessageType(string nextUrl, Pvr_Message.MessageType messageType)
		{
			long result = 0L;
			switch (messageType)
			{
			case Pvr_Message.MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			{
				AndroidJavaObject @static = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity");
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllDefinitionsByUrl", new object[2] { nextUrl, @static });
				break;
			}
			case Pvr_Message.MessageType.Achievements_GetNextAchievementProgressArrayPage:
				result = achievementAPI.CallStatic<long>("pvr_Achievements_GetAllProgressByUrl", new object[1] { nextUrl });
				break;
			}
			return result;
		}

		internal static long pvr_Message_GetType(AndroidJavaObject popMessage)
		{
			return popMessage.Call<AndroidJavaObject>("getHandleType", Array.Empty<object>()).Call<long>("getIndex", Array.Empty<object>());
		}

		internal static bool pvr_Message_IsError(AndroidJavaObject popMessage)
		{
			return popMessage.Call<bool>("isMessage_IsError", Array.Empty<object>());
		}

		internal static long pvr_Message_GetRequestID(AndroidJavaObject popMessage)
		{
			return popMessage.Call<long>("getId", Array.Empty<object>());
		}

		internal static string pvr_Message_GetString(AndroidJavaObject popMessage)
		{
			return popMessage.Call<string>("getContent", Array.Empty<object>());
		}

		internal static bool pvr_AchievementUpdate_GetJustUnlocked(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<bool>("pvr_AchievementUpdate_GetJustUnlocked", new object[1] { popMessage });
		}

		internal static string pvr_AchievementUpdate_GetName(AndroidJavaObject popMessage)
		{
			return updateHandle.CallStatic<string>("pvr_AchievementUpdate_GetName", new object[1] { popMessage });
		}

		internal static int pvr_AchievementProgressArray_GetSize(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<int>("pvr_AchievementProgressArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementProgressArray_GetElement(AndroidJavaObject msg, int index)
		{
			return progressArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementProgressArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementProgressArray_GetNextUrl(AndroidJavaObject msg)
		{
			return progressArrayHandle.CallStatic<string>("pvr_AchievementProgressArray_GetNextUrl", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetBitfield(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetBitfield", new object[1] { msg });
		}

		internal static long pvr_AchievementProgress_GetCount(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<long>("pvr_AchievementProgress_GetCount", new object[1] { msg });
		}

		internal static bool pvr_AchievementProgress_GetIsUnlocked(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<bool>("pvr_AchievementProgress_GetIsUnlocked", new object[1] { msg });
		}

		internal static string pvr_AchievementProgress_GetName(AndroidJavaObject msg)
		{
			return progressHandle.CallStatic<string>("pvr_AchievementProgress_GetName", new object[1] { msg });
		}

		internal static DateTime pvr_AchievementProgress_GetUnlockTime(AndroidJavaObject msg)
		{
			new DateTime(1970, 1, 1, 0, 0, 0, 0);
			return DateTimeFromNative(progressHandle.CallStatic<long>("pvr_AchievementProgress_GetUnlockTime", new object[1] { msg }));
		}

		internal static DateTime DateTimeFromNative(long seconds_since_the_one_true_epoch)
		{
			return new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(seconds_since_the_one_true_epoch).ToLocalTime();
		}

		internal static int pvr_AchievementDefinitionArray_GetSize(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<int>("pvr_AchievementDefinitionArray_GetSize", new object[1] { msg });
		}

		internal static AndroidJavaObject pvr_AchievementDefinitionArray_GetElement(AndroidJavaObject msg, int index)
		{
			return definitionArrayHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinitionArray_GetElement", new object[2] { msg, index });
		}

		internal static string pvr_AchievementDefinitionArray_GetNextUrl(AndroidJavaObject msg)
		{
			return definitionArrayHandle.CallStatic<string>("pvr_AchievementDefinitionArray_GetNextUrl", new object[1] { msg });
		}

		internal static AchievementType pvr_AchievementDefinition_GetType(AndroidJavaObject msg)
		{
			return (AchievementType)definitionHandle.CallStatic<AndroidJavaObject>("pvr_AchievementDefinition_GetType", new object[1] { msg }).Call<int>("getIndex", Array.Empty<object>());
		}

		internal static string pvr_AchievementDefinition_GetName(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetName", new object[1] { msg });
		}

		internal static int pvr_AchievementDefinition_GetBitfieldLength(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<int>("pvr_AchievementDefinition_GetBitfieldLength", new object[1] { msg });
		}

		internal static long pvr_AchievementDefinition_GetTarget(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<long>("pvr_AchievementDefinition_GetTarget", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetTitle(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetTitle", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_description", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetLockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetLocked_image", new object[1] { msg });
		}

		internal static bool pvr_AchievementDefinition_GetIsSecrect(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<bool>("pvr_AchievementDefinition_GetIs_secret", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetUnlockedIcon(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetUnlocked_image", new object[1] { msg });
		}

		internal static string pvr_AchievementDefinition_GetDescription(AndroidJavaObject msg)
		{
			return definitionHandle.CallStatic<string>("pvr_AchievementDefinition_GetDescription", new object[1] { msg });
		}
	}
	public class Pvr_AchievementDefinition
	{
		public readonly AchievementType Type;

		public readonly string Name;

		public readonly int BitfieldLength;

		public readonly long Target;

		public readonly string Title;

		public readonly string Description;

		public readonly string UnlockedDescription;

		public readonly string UnlockedIcon;

		public readonly string LockedIcon;

		public readonly bool IsSecrect;

		public Pvr_AchievementDefinition(AndroidJavaObject msg)
		{
			Type = Pvr_AchievementAPI.pvr_AchievementDefinition_GetType(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementDefinition_GetName(msg);
			BitfieldLength = Pvr_AchievementAPI.pvr_AchievementDefinition_GetBitfieldLength(msg);
			Target = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTarget(msg);
			Title = Pvr_AchievementAPI.pvr_AchievementDefinition_GetTitle(msg);
			Description = Pvr_AchievementAPI.pvr_AchievementDefinition_GetDescription(msg);
			UnlockedDescription = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedDescription(msg);
			UnlockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetUnlockedIcon(msg);
			LockedIcon = Pvr_AchievementAPI.pvr_AchievementDefinition_GetLockedIcon(msg);
			IsSecrect = Pvr_AchievementAPI.pvr_AchievementDefinition_GetIsSecrect(msg);
		}
	}
	public class Pvr_AchievementDefinitionList : Pvr_DeserializableList<Pvr_AchievementDefinition>
	{
		public Pvr_AchievementDefinitionList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetSize(msg);
			data = new List<Pvr_AchievementDefinition>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementDefinition(Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementDefinitionArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementProgress
	{
		public readonly string Bitfield;

		public readonly long Count;

		public readonly bool IsUnlocked;

		public readonly string Name;

		public readonly DateTime UnlockTime;

		public Pvr_AchievementProgress(AndroidJavaObject msg)
		{
			Bitfield = Pvr_AchievementAPI.pvr_AchievementProgress_GetBitfield(msg);
			Count = Pvr_AchievementAPI.pvr_AchievementProgress_GetCount(msg);
			IsUnlocked = Pvr_AchievementAPI.pvr_AchievementProgress_GetIsUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementProgress_GetName(msg);
			UnlockTime = Pvr_AchievementAPI.pvr_AchievementProgress_GetUnlockTime(msg);
		}
	}
	public class Pvr_AchievementProgressList : Pvr_DeserializableList<Pvr_AchievementProgress>
	{
		public Pvr_AchievementProgressList(AndroidJavaObject msg)
		{
			int num = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetSize(msg);
			data = new List<Pvr_AchievementProgress>(num);
			for (int i = 0; i < num; i++)
			{
				data.Add(new Pvr_AchievementProgress(Pvr_AchievementAPI.pvr_AchievementProgressArray_GetElement(msg, i)));
			}
			nextUrl = Pvr_AchievementAPI.pvr_AchievementProgressArray_GetNextUrl(msg);
		}
	}
	public class Pvr_AchievementUpdate
	{
		public readonly bool JustUnlocked;

		public readonly string Name;

		public Pvr_AchievementUpdate(AndroidJavaObject msg)
		{
			JustUnlocked = Pvr_AchievementAPI.pvr_AchievementUpdate_GetJustUnlocked(msg);
			Name = Pvr_AchievementAPI.pvr_AchievementUpdate_GetName(msg);
		}
	}
	public class Pvr_DeserializableList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		protected List<T> data;

		protected string nextUrl;

		protected string previousUrl;

		public int Count => data.Count;

		bool ICollection<T>.IsReadOnly => ((ICollection<T>)data).IsReadOnly;

		public T this[int index]
		{
			get
			{
				return data[index];
			}
			set
			{
				data[index] = value;
			}
		}

		public bool HasNextPage => !string.IsNullOrEmpty(NextUrl);

		public bool HasPreviousPage => !string.IsNullOrEmpty(PreviousUrl);

		public string NextUrl => nextUrl;

		public string PreviousUrl => previousUrl;

		public int IndexOf(T obj)
		{
			return data.IndexOf(obj);
		}

		public void Add(T item)
		{
			data.Add(item);
		}

		public void Clear()
		{
			data.Clear();
		}

		public bool Contains(T item)
		{
			return data.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			data.CopyTo(array, arrayIndex);
		}

		public IEnumerator<T> GetEnumerator()
		{
			return data.GetEnumerator();
		}

		public void Insert(int index, T item)
		{
			data.Insert(index, item);
		}

		public bool Remove(T item)
		{
			return data.Remove(item);
		}

		public void RemoveAt(int index)
		{
			data.RemoveAt(index);
		}

		private IEnumerator GetEnumerator1()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator1();
		}
	}
	public static class Pvr_Callback
	{
		private class RequestCallback
		{
			private Pvr_Message.Callback messageCallback;

			public RequestCallback()
			{
			}

			public RequestCallback(Pvr_Message.Callback callback)
			{
				messageCallback = callback;
			}

			public virtual void HandleMessage(Pvr_Message msg)
			{
				if (messageCallback != null)
				{
					messageCallback(msg);
				}
			}
		}

		private sealed class RequestCallback<T> : RequestCallback
		{
			private Pvr_Message<T>.Callback callback;

			public RequestCallback(Pvr_Message<T>.Callback callback)
			{
				this.callback = callback;
			}

			public override void HandleMessage(Pvr_Message msg)
			{
				if (callback != null)
				{
					if (msg is Pvr_Message<T>)
					{
						callback((Pvr_Message<T>)msg);
					}
					else
					{
						UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
					}
				}
			}
		}

		private static Dictionary<long, Request> requestIDsToRequests = new Dictionary<long, Request>();

		private static Dictionary<Pvr_Message.MessageType, RequestCallback> notificationCallbacks = new Dictionary<Pvr_Message.MessageType, RequestCallback>();

		internal static void AddRequest(Request request)
		{
			if (request.RequestID <= 2)
			{
				long requestID = request.RequestID;
				if ((ulong)requestID <= 2uL)
				{
					switch (requestID)
					{
					case 0L:
						UnityEngine.Debug.LogError("An PARAM_INVALIDE error occurred. Request failed.");
						return;
					case 1L:
						UnityEngine.Debug.LogError("An NETWORK_INVALIDE error occurred. Request failed.");
						return;
					case 2L:
						UnityEngine.Debug.LogError("An NOT_INTIALIZE error occurred. Request failed.");
						return;
					}
				}
				UnityEngine.Debug.LogError("An unknown error occurred. Request failed.");
			}
			else
			{
				requestIDsToRequests[request.RequestID] = request;
			}
		}

		internal static void RunCallbacks()
		{
			while (true)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void RunLimitedCallbacks(uint limit)
		{
			for (int i = 0; i < limit; i++)
			{
				Pvr_Message pvr_Message = Pvr_Message.PopMessage();
				if (pvr_Message != null)
				{
					HandleMessage(pvr_Message);
					continue;
				}
				break;
			}
		}

		internal static void OnApplicationQuit()
		{
			requestIDsToRequests.Clear();
			notificationCallbacks.Clear();
		}

		internal static void HandleMessage(Pvr_Message msg)
		{
			if (msg.RequestID != 0L && requestIDsToRequests.TryGetValue(msg.RequestID, out var value))
			{
				try
				{
					value.HandleMessage(msg);
					return;
				}
				finally
				{
					requestIDsToRequests.Remove(msg.RequestID);
				}
			}
			if (notificationCallbacks.TryGetValue(msg.Type, out var value2))
			{
				value2.HandleMessage(msg);
			}
		}
	}
	public class Pvr_CallbackRunner : MonoBehaviour
	{
		public bool IsPersistantBetweenSceneLoads = true;

		private void Awake()
		{
			if (UnityEngine.Object.FindObjectOfType<Pvr_CallbackRunner>() != this)
			{
				UnityEngine.Debug.LogWarning("You only need one instance of CallbackRunner");
			}
			if (IsPersistantBetweenSceneLoads)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		private void Update()
		{
			Request.RunCallbacks();
		}

		private void OnApplicationQuit()
		{
			Pvr_Callback.OnApplicationQuit();
		}
	}
	public abstract class Pvr_Message<T> : Pvr_Message
	{
		public new delegate void Callback(Pvr_Message<T> message);

		private T data;

		public T Data => data;

		public Pvr_Message(AndroidJavaObject msg)
			: base(msg)
		{
			if (!base.IsError)
			{
				data = GetDataFromMessage(msg);
			}
		}

		protected abstract T GetDataFromMessage(AndroidJavaObject msg);
	}
	public class Pvr_Message
	{
		public delegate void Callback(Pvr_Message message);

		public enum MessageType : uint
		{
			Unknown = 0u,
			Achievements_AddCount = 65495601u,
			Achievements_AddFields = 346693929u,
			Achievements_GetAllDefinitions = 64177549u,
			Achievements_GetAllProgress = 1335877149u,
			Achievements_GetDefinitionsByName = 1653670332u,
			Achievements_GetNextAchievementDefinitionArrayPage = 712888917u,
			Achievements_GetNextAchievementProgressArrayPage = 792913703u,
			Achievements_GetProgressByName = 354837425u,
			Achievements_Unlock = 1497156573u,
			Achievements_WriteAchievementProgress = 121027549u,
			Achievements_VerifyAccessToken = 53284924u
		}

		internal delegate Pvr_Message ExtraMessageTypesHandler(AndroidJavaObject messageHandle, MessageType message_type);

		private MessageType type;

		private long requestID;

		private Error error;

		public MessageType Type => type;

		public bool IsError => error != null;

		public long RequestID => requestID;

		internal static ExtraMessageTypesHandler HandleExtraMessageTypes { private get; set; }

		public Pvr_Message(AndroidJavaObject msg)
		{
			type = (MessageType)Pvr_AchievementAPI.pvr_Message_GetType(msg);
			bool num = Pvr_AchievementAPI.pvr_Message_IsError(msg);
			requestID = Pvr_AchievementAPI.pvr_Message_GetRequestID(msg);
			if (num)
			{
				error = new Error(Pvr_AchievementAPI.pvr_Error_GetCode(msg), Pvr_AchievementAPI.pvr_Error_GetMessage(msg), Pvr_AchievementAPI.pvr_Error_GetHttpCode(msg));
			}
			else if (AchievementCore.LogMessages)
			{
				string text = Pvr_AchievementAPI.pvr_Message_GetString(msg);
				if (text != null)
				{
					UnityEngine.Debug.Log(text);
				}
				else
				{
					UnityEngine.Debug.Log($"null message string {msg}");
				}
			}
		}

		public virtual Error GetError()
		{
			return error;
		}

		public virtual Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return null;
		}

		public virtual Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return null;
		}

		public virtual Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return null;
		}

		public virtual string GetString()
		{
			return null;
		}

		internal static Pvr_Message ParseMessageHandle(AndroidJavaObject messageHandle)
		{
			if (messageHandle == null)
			{
				return null;
			}
			Pvr_Message result = null;
			switch ((MessageType)Pvr_AchievementAPI.pvr_Message_GetType(messageHandle))
			{
			case MessageType.Achievements_GetAllDefinitions:
			case MessageType.Achievements_GetNextAchievementDefinitionArrayPage:
			case MessageType.Achievements_GetDefinitionsByName:
				result = new MessageWithAchievementDefinitions(messageHandle);
				break;
			case MessageType.Achievements_GetProgressByName:
			case MessageType.Achievements_GetNextAchievementProgressArrayPage:
			case MessageType.Achievements_GetAllProgress:
				result = new MessageWithAchievementProgressList(messageHandle);
				break;
			case MessageType.Achievements_VerifyAccessToken:
			case MessageType.Achievements_AddCount:
			case MessageType.Achievements_AddFields:
			case MessageType.Achievements_Unlock:
				result = new MessageWithAchievementUpdate(messageHandle);
				break;
			}
			return result;
		}

		public static Pvr_Message PopMessage()
		{
			return ParseMessageHandle(Pvr_AchievementAPI.PopMessage());
		}
	}
	public class MessageWithAchievementDefinitions : Pvr_Message<Pvr_AchievementDefinitionList>
	{
		public MessageWithAchievementDefinitions(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementDefinitionList GetAchievementDefinitions()
		{
			return base.Data;
		}

		protected override Pvr_AchievementDefinitionList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementDefinitionList(msg);
		}
	}
	public class MessageWithAchievementProgressList : Pvr_Message<Pvr_AchievementProgressList>
	{
		public MessageWithAchievementProgressList(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementProgressList GetAchievementProgressList()
		{
			return base.Data;
		}

		protected override Pvr_AchievementProgressList GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementProgressList(msg);
		}
	}
	public class MessageWithAchievementUpdate : Pvr_Message<Pvr_AchievementUpdate>
	{
		public MessageWithAchievementUpdate(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override Pvr_AchievementUpdate GetAchievementUpdate()
		{
			return base.Data;
		}

		protected override Pvr_AchievementUpdate GetDataFromMessage(AndroidJavaObject msg)
		{
			return new Pvr_AchievementUpdate(msg);
		}
	}
	public class MessageWithString : Pvr_Message<string>
	{
		public MessageWithString(AndroidJavaObject msg)
			: base(msg)
		{
		}

		public override string GetString()
		{
			return base.Data;
		}

		protected override string GetDataFromMessage(AndroidJavaObject msg)
		{
			return Pvr_AchievementAPI.pvr_Message_GetString(msg);
		}
	}
	public class Error
	{
		public readonly int Code;

		public readonly int HttpCode;

		public readonly string Message;

		public Error(int code, string message, int httpCode)
		{
			Message = message;
			Code = code;
			HttpCode = httpCode;
		}
	}
	public sealed class Pvr_Request<T> : Request
	{
		private Pvr_Message<T>.Callback callback_;

		public Pvr_Request(long requestID)
			: base(requestID)
		{
		}

		public Pvr_Request<T> OnComplete(Pvr_Message<T>.Callback callback)
		{
			if (callback_ != null)
			{
				throw new UnityException("Attempted to attach multiple handlers to a Request.  This is not allowed.");
			}
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public override void HandleMessage(Pvr_Message msg)
		{
			if (!(msg is Pvr_Message<T>))
			{
				UnityEngine.Debug.LogError("Unable to handle message: " + msg.GetType());
				return;
			}
			if (callback_ != null)
			{
				callback_((Pvr_Message<T>)msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}
	}
	public class Request
	{
		private Pvr_Message.Callback callback_;

		public long RequestID { get; set; }

		public Request(long requestID)
		{
			RequestID = requestID;
		}

		public Request OnComplete(Pvr_Message.Callback callback)
		{
			callback_ = callback;
			Pvr_Callback.AddRequest(this);
			return this;
		}

		public virtual void HandleMessage(Pvr_Message msg)
		{
			if (callback_ != null)
			{
				callback_(msg);
				return;
			}
			throw new UnityException("Request with no handler.  This should never happen.");
		}

		public static void RunCallbacks(uint limit = 0u)
		{
			if (limit == 0)
			{
				Pvr_Callback.RunCallbacks();
			}
			else
			{
				Pvr_Callback.RunLimitedCallbacks(limit);
			}
		}
	}
}
namespace I2.Loc
{
	public class CallbackNotification : MonoBehaviour
	{
		public void OnModifyLocalization()
		{
			if (!string.IsNullOrEmpty(Localize.MainTranslation))
			{
				string translation = LocalizationManager.GetTranslation("Color/Red");
				Localize.MainTranslation = Localize.MainTranslation.Replace("{PLAYER_COLOR}", translation);
			}
		}
	}
	public class Example_ChangeLanguage : MonoBehaviour
	{
		public void SetLanguage_English()
		{
			SetLanguage("English");
		}

		public void SetLanguage_French()
		{
			SetLanguage("French");
		}

		public void SetLanguage_Spanish()
		{
			SetLanguage("Spanish");
		}

		public void SetLanguage(string LangName)
		{
			if (LocalizationManager.HasLanguage(LangName))
			{
				LocalizationManager.CurrentLanguage = LangName;
			}
		}
	}
	public class Example_LocalizedString : MonoBehaviour
	{
		public LocalizedString _MyLocalizedString;

		public string _NormalString;

		[TermsPopup("")]
		public string _StringWithTermPopup;

		public void Start()
		{
			UnityEngine.Debug.Log(_MyLocalizedString);
			UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_NormalString));
			UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_StringWithTermPopup));
			UnityEngine.Debug.Log((string)(LocalizedString)"Term2");
			UnityEngine.Debug.Log(_MyLocalizedString);
			UnityEngine.Debug.Log((LocalizedString)"Term3");
			LocalizedString localizedString = "Term3";
			localizedString.mRTL_IgnoreArabicFix = true;
			UnityEngine.Debug.Log(localizedString);
			LocalizedString localizedString2 = "Term3";
			localizedString2.mRTL_ConvertNumbers = true;
			localizedString2.mRTL_MaxLineLength = 20;
			UnityEngine.Debug.Log(localizedString2);
			UnityEngine.Debug.Log(localizedString2);
		}
	}
	public class GlobalParametersExample : RegisterGlobalParameters
	{
		public override string GetParameterValue(string ParamName)
		{
			if (ParamName == "WINNER")
			{
				return "Javier";
			}
			if (ParamName == "NUM PLAYERS")
			{
				return 5.ToString();
			}
			return null;
		}
	}
	public class RealTimeTranslation : MonoBehaviour
	{
		private string OriginalText = "This is an example showing how to use the google translator to translate chat messages within the game.\nIt also supports multiline translations.";

		private string TranslatedText = string.Empty;

		private bool IsTranslating;

		public void OnGUI()
		{
			GUILayout.Label("Translate:");
			OriginalText = GUILayout.TextArea(OriginalText, GUILayout.Width(Screen.width));
			GUILayout.Space(10f);
			GUILayout.BeginHorizontal();
			if (GUILayout.Button("English -> Espaol", GUILayout.Height(100f)))
			{
				StartTranslating("en", "es");
			}
			if (GUILayout.Button("Espaol -> English", GUILayout.Height(100f)))
			{
				StartTranslating("es", "en");
			}
			GUILayout.EndHorizontal();
			GUILayout.Space(10f);
			GUILayout.BeginHorizontal();
			GUILayout.TextArea("Multiple Translation with 1 call:\n'This is an example' -> en,zh\n'Hola' -> en");
			if (GUILayout.Button("Multi Translate", GUILayout.ExpandHeight(expand: true)))
			{
				ExampleMultiTranslations_Async();
			}
			GUILayout.EndHorizontal();
			GUILayout.TextArea(TranslatedText, GUILayout.Width(Screen.width));
			GUILayout.Space(10f);
			if (IsTranslating)
			{
				GUILayout.Label("Contacting Google....");
			}
		}

		public void StartTranslating(string fromCode, string toCode)
		{
			IsTranslating = true;
			GoogleTranslation.Translate(OriginalText, fromCode, toCode, OnTranslationReady);
		}

		private void OnTranslationReady(string Translation, string errorMsg)
		{
			IsTranslating = false;
			if (errorMsg != null)
			{
				UnityEngine.Debug.LogError(errorMsg);
			}
			else
			{
				TranslatedText = Translation;
			}
		}

		public void ExampleMultiTranslations_Blocking()
		{
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
			GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
			GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
			if (GoogleTranslation.ForceTranslate(dictionary))
			{
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "en", dictionary));
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "zh", dictionary));
				UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "", dictionary));
				UnityEngine.Debug.Log(dictionary["Hola"].Results[0]);
			}
		}

		public void ExampleMultiTranslations_Async()
		{
			IsTranslating = true;
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
			GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
			GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
			GoogleTranslation.Translate(dictionary, OnMultitranslationReady);
		}

		private void OnMultitranslationReady(Dictionary<string, TranslationQuery> dict, string errorMsg)
		{
			if (!string.IsNullOrEmpty(errorMsg))
			{
				UnityEngine.Debug.LogError(errorMsg);
				return;
			}
			IsTranslating = false;
			TranslatedText = "";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "es", dict) + "\n";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "zh", dict) + "\n";
			TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "", dict) + "\n";
			TranslatedText += dict["Hola"].Results[0];
		}

		public bool IsWaitingForTranslation()
		{
			return IsTranslating;
		}

		public string GetTranslatedText()
		{
			return TranslatedText;
		}

		public void SetOriginalText(string text)
		{
			OriginalText = text;
		}
	}
	public class RegisterBundlesManager : MonoBehaviour, IResourceManager_Bundles
	{
		public void OnEnable()
		{
			if (!ResourceManager.pInstance.mBundleManagers.Contains(this))
			{
				ResourceManager.pInstance.mBundleManagers.Add(this);
			}
		}

		public void OnDisable()
		{
			ResourceManager.pInstance.mBundleManagers.Remove(this);
		}

		public virtual UnityEngine.Object LoadFromBundle(string path, Type assetType)
		{
			return null;
		}
	}
	public class ToggleLanguage : MonoBehaviour
	{
		private void Start()
		{
			Invoke("test", 3f);
		}

		private void test()
		{
			List<string> allLanguages = LocalizationManager.GetAllLanguages();
			int num = allLanguages.IndexOf(LocalizationManager.CurrentLanguage);
			if (num < 0)
			{
				num = 0;
			}
			else
			{
				num = (num + 1) % allLanguages.Count;
			}
			Invoke("test", 3f);
		}
	}
	public static class PersistentStorage
	{
		public enum eFileType
		{
			Raw,
			Persistent,
			Temporal,
			Streaming
		}

		private static I2CustomPersistentStorage mStorage;

		public static void SetSetting_String(string key, string value)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.SetSetting_String(key, value);
		}

		public static string GetSetting_String(string key, string defaultValue)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.GetSetting_String(key, defaultValue);
		}

		public static void DeleteSetting(string key)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.DeleteSetting(key);
		}

		public static bool HasSetting(string key)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.HasSetting(key);
		}

		public static void ForceSaveSettings()
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			mStorage.ForceSaveSettings();
		}

		public static bool CanAccessFiles()
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.CanAccessFiles();
		}

		public static bool SaveFile(eFileType fileType, string fileName, string data, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.SaveFile(fileType, fileName, data, logExceptions);
		}

		public static string LoadFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.LoadFile(fileType, fileName, logExceptions);
		}

		public static bool DeleteFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.DeleteFile(fileType, fileName, logExceptions);
		}

		public static bool HasFile(eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (mStorage == null)
			{
				mStorage = new I2CustomPersistentStorage();
			}
			return mStorage.HasFile(fileType, fileName, logExceptions);
		}
	}
	public abstract class I2BasePersistentStorage
	{
		public virtual void SetSetting_String(string key, string value)
		{
			try
			{
				int length = value.Length;
				int num = 8000;
				if (length <= num)
				{
					PlayerPrefs.SetString(key, value);
					return;
				}
				int num2 = Mathf.CeilToInt((float)length / (float)num);
				for (int i = 0; i < num2; i++)
				{
					int num3 = num * i;
					PlayerPrefs.SetString($"[I2split]{i}{key}", value.Substring(num3, Mathf.Min(num, length - num3)));
				}
				PlayerPrefs.SetString(key, "[$I2#@div$]" + num2);
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error saving PlayerPrefs " + key);
			}
		}

		public virtual string GetSetting_String(string key, string defaultValue)
		{
			try
			{
				string text = PlayerPrefs.GetString(key, defaultValue);
				if (!string.IsNullOrEmpty(text) && text.StartsWith("[I2split]"))
				{
					int num = int.Parse(text.Substring("[I2split]".Length));
					text = "";
					for (int i = 0; i < num; i++)
					{
						text += PlayerPrefs.GetString($"[I2split]{i}{key}", "");
					}
				}
				return text;
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error loading PlayerPrefs " + key);
				return defaultValue;
			}
		}

		public virtual void DeleteSetting(string key)
		{
			try
			{
				string @string = PlayerPrefs.GetString(key, null);
				if (!string.IsNullOrEmpty(@string) && @string.StartsWith("[I2split]"))
				{
					int num = int.Parse(@string.Substring("[I2split]".Length));
					for (int i = 0; i < num; i++)
					{
						PlayerPrefs.DeleteKey($"[I2split]{i}{key}");
					}
				}
				PlayerPrefs.DeleteKey(key);
			}
			catch (Exception)
			{
				UnityEngine.Debug.LogError("Error deleting PlayerPrefs " + key);
			}
		}

		public virtual void ForceSaveSettings()
		{
			PlayerPrefs.Save();
		}

		public virtual bool HasSetting(string key)
		{
			return PlayerPrefs.HasKey(key);
		}

		public virtual bool CanAccessFiles()
		{
			return true;
		}

		private string UpdateFilename(PersistentStorage.eFileType fileType, string fileName)
		{
			switch (fileType)
			{
			case PersistentStorage.eFileType.Persistent:
				fileName = Application.persistentDataPath + "/" + fileName;
				break;
			case PersistentStorage.eFileType.Temporal:
				fileName = Application.temporaryCachePath + "/" + fileName;
				break;
			case PersistentStorage.eFileType.Streaming:
				fileName = Application.streamingAssetsPath + "/" + fileName;
				break;
			}
			return fileName;
		}

		public virtual bool SaveFile(PersistentStorage.eFileType fileType, string fileName, string data, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				File.WriteAllText(fileName, data, Encoding.UTF8);
				return true;
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error saving file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}

		public virtual string LoadFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return null;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				return File.ReadAllText(fileName, Encoding.UTF8);
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error loading file '" + fileName + "'\n" + ex);
				}
				return null;
			}
		}

		public virtual bool DeleteFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				File.Delete(fileName);
				return true;
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error deleting file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}

		public virtual bool HasFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
		{
			if (!CanAccessFiles())
			{
				return false;
			}
			try
			{
				fileName = UpdateFilename(fileType, fileName);
				return File.Exists(fileName);
			}
			catch (Exception ex)
			{
				if (logExceptions)
				{
					UnityEngine.Debug.LogError("Error requesting file '" + fileName + "'\n" + ex);
				}
				return false;
			}
		}
	}
	public class I2CustomPersistentStorage : I2BasePersistentStorage
	{
	}
	public class BaseSpecializationManager
	{
		public string[] mSpecializations;

		public Dictionary<string, string> mSpecializationsFallbacks;

		public virtual void InitializeSpecializations()
		{
			mSpecializations = new string[12]
			{
				"Any", "PC", "Touch", "Controller", "VR", "XBox", "PS4", "OculusVR", "ViveVR", "GearVR",
				"Android", "IOS"
			};
			mSpecializationsFallbacks = new Dictionary<string, string>
			{
				{ "XBox", "Controller" },
				{ "PS4", "Controller" },
				{ "OculusVR", "VR" },
				{ "ViveVR", "VR" },
				{ "GearVR", "VR" },
				{ "Android", "Touch" },
				{ "IOS", "Touch" }
			};
		}

		public virtual string GetCurrentSpecialization()
		{
			if (mSpecializations == null)
			{
				InitializeSpecializations();
			}
			return "Android";
		}

		public virtual string GetFallbackSpecialization(string specialization)
		{
			if (mSpecializationsFallbacks == null)
			{
				InitializeSpecializations();
			}
			if (mSpecializationsFallbacks.TryGetValue(specialization, out var value))
			{
				return value;
			}
			return "Any";
		}
	}
	public class SpecializationManager : BaseSpecializationManager
	{
		public static SpecializationManager Singleton = new SpecializationManager();

		private SpecializationManager()
		{
			InitializeSpecializations();
		}

		public static string GetSpecializedText(string text, string specialization = null)
		{
			int num = text.IndexOf("[i2s_");
			if (num < 0)
			{
				return text;
			}
			if (string.IsNullOrEmpty(specialization))
			{
				specialization = Singleton.GetCurrentSpecialization();
			}
			while (!string.IsNullOrEmpty(specialization) && specialization != "Any")
			{
				string text2 = "[i2s_" + specialization + "]";
				int num2 = text.IndexOf(text2);
				if (num2 < 0)
				{
					specialization = Singleton.GetFallbackSpecialization(specialization);
					continue;
				}
				num2 += text2.Length;
				int num3 = text.IndexOf("[i2s_", num2);
				if (num3 < 0)
				{
					num3 = text.Length;
				}
				return text.Substring(num2, num3 - num2);
			}
			return text.Substring(0, num);
		}

		public static string SetSpecializedText(string text, string newText, string specialization)
		{
			if (string.IsNullOrEmpty(specialization))
			{
				specialization = "Any";
			}
			if ((text == null || !text.Contains("[i2s_")) && specialization == "Any")
			{
				return newText;
			}
			Dictionary<string, string> specializations = GetSpecializations(text);
			specializations[specialization] = newText;
			return SetSpecializedText(specializations);
		}

		public static string SetSpecializedText(Dictionary<string, string> specializations)
		{
			if (!specializations.TryGetValue("Any", out var value))
			{
				value = string.Empty;
			}
			foreach (KeyValuePair<string, string> specialization in specializations)
			{
				if (specialization.Key != "Any" && !string.IsNullOrEmpty(specialization.Value))
				{
					value = value + "[i2s_" + specialization.Key + "]" + specialization.Value;
				}
			}
			return value;
		}

		public static Dictionary<string, string> GetSpecializations(string text, Dictionary<string, string> buffer = null)
		{
			if (buffer == null)
			{
				buffer = new Dictionary<string, string>();
			}
			else
			{
				buffer.Clear();
			}
			if (text == null)
			{
				buffer["Any"] = "";
				return buffer;
			}
			int num = 0;
			int num2 = text.IndexOf("[i2s_");
			if (num2 < 0)
			{
				num2 = text.Length;
			}
			buffer["Any"] = text.Substring(0, num2);
			for (num = num2; num < text.Length; num = num2)
			{
				num += "[i2s_".Length;
				int num3 = text.IndexOf(']', num);
				if (num3 < 0)
				{
					break;
				}
				string key = text.Substring(num, num3 - num);
				num = num3 + 1;
				num2 = text.IndexOf("[i2s_", num);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				string value = text.Substring(num, num2 - num);
				buffer[key] = value;
			}
			return buffer;
		}

		public static void AppendSpecializations(string text, List<string> list = null)
		{
			if (text == null)
			{
				return;
			}
			if (list == null)
			{
				list = new List<string>();
			}
			if (!list.Contains("Any"))
			{
				list.Add("Any");
			}
			int num = 0;
			while (num < text.Length)
			{
				num = text.IndexOf("[i2s_", num);
				if (num >= 0)
				{
					num += "[i2s_".Length;
					int num2 = text.IndexOf(']', num);
					if (num2 >= 0)
					{
						string item = text.Substring(num, num2 - num);
						if (!list.Contains(item))
						{
							list.Add(item);
						}
						continue;
					}
					break;
				}
				break;
			}
		}
	}
	[Serializable]
	public class EventCallback
	{
		public MonoBehaviour Target;

		public string MethodName = string.Empty;

		public void Execute(UnityEngine.Object Sender = null)
		{
			if (HasCallback() && Application.isPlaying)
			{
				Target.gameObject.SendMessage(MethodName, Sender, SendMessageOptions.DontRequireReceiver);
			}
		}

		public bool HasCallback()
		{
			if (Target != null)
			{
				return !string.IsNullOrEmpty(MethodName);
			}
			return false;
		}
	}
	public enum ePluralType
	{
		Zero,
		One,
		Two,
		Few,
		Many,
		Plural
	}
	public static class GoogleLanguages
	{
		public struct LanguageCodeDef
		{
			public string Code;

			public string GoogleCode;

			public bool HasJoinedWords;

			public int PluralRule;
		}

		public static Dictionary<string, LanguageCodeDef> mLanguageDef = new Dictionary<string, LanguageCodeDef>(StringComparer.Ordinal)
		{
			{
				"Abkhazian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ab",
					GoogleCode = "-"
				}
			},
			{
				"Afar",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "aa",
					GoogleCode = "-"
				}
			},
			{
				"Afrikaans",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "af"
				}
			},
			{
				"Akan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ak",
					GoogleCode = "-"
				}
			},
			{
				"Albanian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sq"
				}
			},
			{
				"Amharic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "am"
				}
			},
			{
				"Arabic",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar"
				}
			},
			{
				"Arabic/Algeria",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-DZ",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Bahrain",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-BH",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Egypt",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-EG",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Iraq",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-IQ",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Jordan",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-JO",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Kuwait",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-KW",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Lebanon",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-LB",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Libya",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-LY",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Morocco",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-MA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Oman",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-OM",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Qatar",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-QA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Saudi Arabia",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-SA",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Syria",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-SY",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Tunisia",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-TN",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/U.A.E.",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-AE",
					GoogleCode = "ar"
				}
			},
			{
				"Arabic/Yemen",
				new LanguageCodeDef
				{
					PluralRule = 11,
					Code = "ar-YE",
					GoogleCode = "ar"
				}
			},
			{
				"Aragonese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "an",
					GoogleCode = "-"
				}
			},
			{
				"Armenian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hy"
				}
			},
			{
				"Assamese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "as",
					GoogleCode = "-"
				}
			},
			{
				"Avaric",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "av",
					GoogleCode = "-"
				}
			},
			{
				"Avestan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ae",
					GoogleCode = "-"
				}
			},
			{
				"Aymara",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ay",
					GoogleCode = "-"
				}
			},
			{
				"Azerbaijani",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "az"
				}
			},
			{
				"Bambara",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bm",
					GoogleCode = "-"
				}
			},
			{
				"Bashkir",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ba",
					GoogleCode = "-"
				}
			},
			{
				"Basque",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eu"
				}
			},
			{
				"Basque/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eu-ES",
					GoogleCode = "eu"
				}
			},
			{
				"Belarusian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "be"
				}
			},
			{
				"Bengali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bn"
				}
			},
			{
				"Bihari",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bh",
					GoogleCode = "-"
				}
			},
			{
				"Bislama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bi",
					GoogleCode = "-"
				}
			},
			{
				"Bosnian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "bs"
				}
			},
			{
				"Breton",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "br",
					GoogleCode = "-"
				}
			},
			{
				"Bulgariaa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bg"
				}
			},
			{
				"Burmese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "my"
				}
			},
			{
				"Catalan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ca"
				}
			},
			{
				"Chamorro",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ch",
					GoogleCode = "-"
				}
			},
			{
				"Chechen",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ce",
					GoogleCode = "-"
				}
			},
			{
				"Chichewa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ny"
				}
			},
			{
				"Chinese",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Hong Kong",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-HK",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Macau",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-MO",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/PRC",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-CN",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Simplified",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-CN",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Singapore",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-SG",
					GoogleCode = "zh-CN",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Taiwan",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-TW",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chinese/Traditional",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "zh-TW",
					GoogleCode = "zh-TW",
					HasJoinedWords = true
				}
			},
			{
				"Chuvash",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cv",
					GoogleCode = "-"
				}
			},
			{
				"Cornish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kw",
					GoogleCode = "-"
				}
			},
			{
				"Corsican",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "co"
				}
			},
			{
				"Cree",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cr",
					GoogleCode = "-"
				}
			},
			{
				"Croatian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "hr"
				}
			},
			{
				"Croatian/Bosnia and Herzegovina",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "hr-BA",
					GoogleCode = "hr"
				}
			},
			{
				"Czech",
				new LanguageCodeDef
				{
					PluralRule = 7,
					Code = "cs"
				}
			},
			{
				"Danish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "da"
				}
			},
			{
				"Divehi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "dv",
					GoogleCode = "-"
				}
			},
			{
				"Dutch",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl"
				}
			},
			{
				"Dutch/Belgium",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl-BE",
					GoogleCode = "nl"
				}
			},
			{
				"Dutch/Netherlands",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nl-NL",
					GoogleCode = "nl"
				}
			},
			{
				"Dzongkha",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "dz",
					GoogleCode = "-"
				}
			},
			{
				"English",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en"
				}
			},
			{
				"English/Australia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-AU",
					GoogleCode = "en"
				}
			},
			{
				"English/Belize",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-BZ",
					GoogleCode = "en"
				}
			},
			{
				"English/Canada",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-CA",
					GoogleCode = "en"
				}
			},
			{
				"English/Caribbean",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-CB",
					GoogleCode = "en"
				}
			},
			{
				"English/Ireland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-IE",
					GoogleCode = "en"
				}
			},
			{
				"English/Jamaica",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-JM",
					GoogleCode = "en"
				}
			},
			{
				"English/New Zealand",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-NZ",
					GoogleCode = "en"
				}
			},
			{
				"English/Republic of the Philippines",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-PH",
					GoogleCode = "en"
				}
			},
			{
				"English/South Africa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-ZA",
					GoogleCode = "en"
				}
			},
			{
				"English/Trinidad",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-TT",
					GoogleCode = "en"
				}
			},
			{
				"English/United Kingdom",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-GB",
					GoogleCode = "en"
				}
			},
			{
				"English/United States",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-US",
					GoogleCode = "en"
				}
			},
			{
				"English/Zimbabwe",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "en-ZW",
					GoogleCode = "en"
				}
			},
			{
				"Esperanto",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "eo"
				}
			},
			{
				"Estonian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "et"
				}
			},
			{
				"Ewe",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ee",
					GoogleCode = "-"
				}
			},
			{
				"Faeroese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fo",
					GoogleCode = "-"
				}
			},
			{
				"Fijian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fj",
					GoogleCode = "-"
				}
			},
			{
				"Finnish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fi"
				}
			},
			{
				"French",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr"
				}
			},
			{
				"French/Belgium",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-BE",
					GoogleCode = "fr"
				}
			},
			{
				"French/Canada",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-CA",
					GoogleCode = "fr"
				}
			},
			{
				"French/France",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-FR",
					GoogleCode = "fr"
				}
			},
			{
				"French/Luxembourg",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-LU",
					GoogleCode = "fr"
				}
			},
			{
				"French/Principality of Monaco",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-MC",
					GoogleCode = "fr"
				}
			},
			{
				"French/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "fr-CH",
					GoogleCode = "fr"
				}
			},
			{
				"Fulah",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ff",
					GoogleCode = "-"
				}
			},
			{
				"Galician",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gl"
				}
			},
			{
				"Galician/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gl-ES",
					GoogleCode = "gl"
				}
			},
			{
				"Georgian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ka"
				}
			},
			{
				"German",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de"
				}
			},
			{
				"German/Austria",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-AT",
					GoogleCode = "de"
				}
			},
			{
				"German/Germany",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-DE",
					GoogleCode = "de"
				}
			},
			{
				"German/Liechtenstein",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-LI",
					GoogleCode = "de"
				}
			},
			{
				"German/Luxembourg",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-LU",
					GoogleCode = "de"
				}
			},
			{
				"German/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "de-CH",
					GoogleCode = "de"
				}
			},
			{
				"Greek",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "el"
				}
			},
			{
				"Guaran",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gn",
					GoogleCode = "-"
				}
			},
			{
				"Gujarati",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gu"
				}
			},
			{
				"Haitian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ht"
				}
			},
			{
				"Hausa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ha"
				}
			},
			{
				"Hebrew",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "he",
					GoogleCode = "iw"
				}
			},
			{
				"Herero",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hz",
					GoogleCode = "-"
				}
			},
			{
				"Hindi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hi"
				}
			},
			{
				"Hiri Motu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ho",
					GoogleCode = "-"
				}
			},
			{
				"Hungarian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "hu"
				}
			},
			{
				"Interlingua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ia",
					GoogleCode = "-"
				}
			},
			{
				"Indonesian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "id"
				}
			},
			{
				"Interlingue",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ie",
					GoogleCode = "-"
				}
			},
			{
				"Irish",
				new LanguageCodeDef
				{
					PluralRule = 10,
					Code = "ga"
				}
			},
			{
				"Igbo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ig"
				}
			},
			{
				"Inupiaq",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ik",
					GoogleCode = "-"
				}
			},
			{
				"Ido",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "io",
					GoogleCode = "-"
				}
			},
			{
				"Icelandic",
				new LanguageCodeDef
				{
					PluralRule = 14,
					Code = "is"
				}
			},
			{
				"Italian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it"
				}
			},
			{
				"Italian/Italy",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it-IT",
					GoogleCode = "it"
				}
			},
			{
				"Italian/Switzerland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "it-CH",
					GoogleCode = "it"
				}
			},
			{
				"Inuktitut",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "iu",
					GoogleCode = "-"
				}
			},
			{
				"Japanese",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ja",
					HasJoinedWords = true
				}
			},
			{
				"Javanese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "jv"
				}
			},
			{
				"Kalaallisut",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kl",
					GoogleCode = "-"
				}
			},
			{
				"Kannada",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kn"
				}
			},
			{
				"Kanuri",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kr",
					GoogleCode = "-"
				}
			},
			{
				"Kashmiri",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ks",
					GoogleCode = "-"
				}
			},
			{
				"Kazakh",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kk"
				}
			},
			{
				"Central Khmer",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "km"
				}
			},
			{
				"Kikuyu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ki",
					GoogleCode = "-"
				}
			},
			{
				"Kinyarwanda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rw",
					GoogleCode = "-"
				}
			},
			{
				"Kirghiz",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ky"
				}
			},
			{
				"Komi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kv",
					GoogleCode = "-"
				}
			},
			{
				"Kongo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kg",
					GoogleCode = "-"
				}
			},
			{
				"Korean",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ko"
				}
			},
			{
				"Kurdish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ku"
				}
			},
			{
				"Kuanyama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "kj",
					GoogleCode = "-"
				}
			},
			{
				"Latin",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "la"
				}
			},
			{
				"Luxembourgish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lb"
				}
			},
			{
				"Ganda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lg",
					GoogleCode = "-"
				}
			},
			{
				"Limburgan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "li",
					GoogleCode = "-"
				}
			},
			{
				"Lingala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ln",
					GoogleCode = "-"
				}
			},
			{
				"Lao",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lo"
				}
			},
			{
				"Latvian",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "lv"
				}
			},
			{
				"Luba-Katanga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "lu",
					GoogleCode = "-"
				}
			},
			{
				"Lithuanian",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "lt"
				}
			},
			{
				"Manx",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gv",
					GoogleCode = "-"
				}
			},
			{
				"Macedonian",
				new LanguageCodeDef
				{
					PluralRule = 13,
					Code = "mk"
				}
			},
			{
				"Malagasy",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mg"
				}
			},
			{
				"Malay",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms"
				}
			},
			{
				"Malay/Brunei Darussalam",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms-BN",
					GoogleCode = "ms"
				}
			},
			{
				"Malay/Malaysia",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "ms-MY",
					GoogleCode = "ms"
				}
			},
			{
				"Malayalam",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ml"
				}
			},
			{
				"Maltese",
				new LanguageCodeDef
				{
					PluralRule = 12,
					Code = "mt"
				}
			},
			{
				"Maori",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "mi"
				}
			},
			{
				"Marathi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mr"
				}
			},
			{
				"Marshallese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mh",
					GoogleCode = "-"
				}
			},
			{
				"Mongolian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "mn"
				}
			},
			{
				"Nauru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "na",
					GoogleCode = "-"
				}
			},
			{
				"Navajo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nv",
					GoogleCode = "-"
				}
			},
			{
				"North Ndebele",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nd",
					GoogleCode = "-"
				}
			},
			{
				"Nepali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ne"
				}
			},
			{
				"Ndonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ng",
					GoogleCode = "-"
				}
			},
			{
				"Northern Sotho",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ns",
					GoogleCode = "st"
				}
			},
			{
				"Norwegian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nb",
					GoogleCode = "no"
				}
			},
			{
				"Norwegian/Nynorsk",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nn",
					GoogleCode = "no"
				}
			},
			{
				"Sichuan Yi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ii",
					GoogleCode = "-"
				}
			},
			{
				"South Ndebele",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "nr",
					GoogleCode = "-"
				}
			},
			{
				"Occitan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "oc",
					GoogleCode = "-"
				}
			},
			{
				"Ojibwa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "oj",
					GoogleCode = "-"
				}
			},
			{
				"Church\u00a0Slavic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "cu",
					GoogleCode = "-"
				}
			},
			{
				"Oromo",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "om",
					GoogleCode = "-"
				}
			},
			{
				"Oriya",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "or",
					GoogleCode = "-"
				}
			},
			{
				"Ossetian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "os",
					GoogleCode = "-"
				}
			},
			{
				"Pali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pi",
					GoogleCode = "-"
				}
			},
			{
				"Pashto",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ps"
				}
			},
			{
				"Persian",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "fa"
				}
			},
			{
				"Polish",
				new LanguageCodeDef
				{
					PluralRule = 8,
					Code = "pl"
				}
			},
			{
				"Portuguese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pt"
				}
			},
			{
				"Portuguese/Brazil",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "pt-BR",
					GoogleCode = "pt"
				}
			},
			{
				"Portuguese/Portugal",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pt-PT",
					GoogleCode = "pt"
				}
			},
			{
				"Punjabi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "pa"
				}
			},
			{
				"Quechua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Bolivia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-BO",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Ecuador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-EC",
					GoogleCode = "-"
				}
			},
			{
				"Quechua/Peru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "qu-PE",
					GoogleCode = "-"
				}
			},
			{
				"Rhaeto-Romanic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rm",
					GoogleCode = "ro"
				}
			},
			{
				"Romanian",
				new LanguageCodeDef
				{
					PluralRule = 4,
					Code = "ro"
				}
			},
			{
				"Rundi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "rn",
					GoogleCode = "-"
				}
			},
			{
				"Russian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "ru"
				}
			},
			{
				"Russian/Republic of Moldova",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "ru-MO",
					GoogleCode = "ru"
				}
			},
			{
				"Sanskrit",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sa",
					GoogleCode = "-"
				}
			},
			{
				"Sardinian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sc",
					GoogleCode = "-"
				}
			},
			{
				"Sindhi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sd"
				}
			},
			{
				"Northern Sami",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "se",
					GoogleCode = "-"
				}
			},
			{
				"Samoan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sm"
				}
			},
			{
				"Sango",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sg",
					GoogleCode = "-"
				}
			},
			{
				"Serbian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "sr"
				}
			},
			{
				"Serbian/Bosnia and Herzegovina",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "sr-BA",
					GoogleCode = "sr"
				}
			},
			{
				"Serbian/Serbia and Montenegro",
				new LanguageCodeDef
				{
					PluralRule = 5,
					Code = "sr-SP",
					GoogleCode = "sr"
				}
			},
			{
				"Scottish Gaelic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "gd"
				}
			},
			{
				"Shona",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sn"
				}
			},
			{
				"Sinhala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "si"
				}
			},
			{
				"Slovak",
				new LanguageCodeDef
				{
					PluralRule = 7,
					Code = "sk"
				}
			},
			{
				"Slovenian",
				new LanguageCodeDef
				{
					PluralRule = 9,
					Code = "sl"
				}
			},
			{
				"Somali",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "so"
				}
			},
			{
				"Southern Sotho",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "st"
				}
			},
			{
				"Spanish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es"
				}
			},
			{
				"Spanish/Argentina",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-AR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Bolivia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-BO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Castilian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-ES",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Chile",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CL",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Colombia",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Costa Rica",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-CR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Dominican Republic",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-DO",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Ecuador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-EC",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/El Salvador",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-SV",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Guatemala",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-GT",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Honduras",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-HN",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Mexico",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-MX",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Nicaragua",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-NI",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Panama",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PA",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Paraguay",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PY",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Peru",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PE",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Puerto Rico",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-PR",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Spain",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-ES",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Uruguay",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-UY",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Venezuela",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-VE",
					GoogleCode = "es"
				}
			},
			{
				"Spanish/Latin Americas",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "es-US",
					GoogleCode = "es"
				}
			},
			{
				"Sundanese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "su"
				}
			},
			{
				"Swahili",
				new LanguageCodeDef
				{
					Code = "sw"
				}
			},
			{
				"Swati",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ss",
					GoogleCode = "-"
				}
			},
			{
				"Swedish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv"
				}
			},
			{
				"Swedish/Finland",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv-FI",
					GoogleCode = "sv"
				}
			},
			{
				"Swedish/Sweden",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "sv-SE",
					GoogleCode = "sv"
				}
			},
			{
				"Tamil",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ta"
				}
			},
			{
				"Tatar",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "tt",
					GoogleCode = "-"
				}
			},
			{
				"Telugu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "te"
				}
			},
			{
				"Tajik",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tg"
				}
			},
			{
				"Thai",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "th",
					HasJoinedWords = true
				}
			},
			{
				"Tigrinya",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ti",
					GoogleCode = "-"
				}
			},
			{
				"Tibetan",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "bo",
					GoogleCode = "-"
				}
			},
			{
				"Turkmen",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tk",
					GoogleCode = "-"
				}
			},
			{
				"Tagalog",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tl"
				}
			},
			{
				"Tswana",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tn",
					GoogleCode = "-"
				}
			},
			{
				"Tonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "to",
					GoogleCode = "-"
				}
			},
			{
				"Turkish",
				new LanguageCodeDef
				{
					PluralRule = 0,
					Code = "tr"
				}
			},
			{
				"Tsonga",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ts",
					GoogleCode = "-"
				}
			},
			{
				"Twi",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "tw",
					GoogleCode = "-"
				}
			},
			{
				"Tahitian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ty",
					GoogleCode = "-"
				}
			},
			{
				"Uighur",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ug",
					GoogleCode = "-"
				}
			},
			{
				"Ukrainian",
				new LanguageCodeDef
				{
					PluralRule = 6,
					Code = "uk"
				}
			},
			{
				"Urdu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ur"
				}
			},
			{
				"Uzbek",
				new LanguageCodeDef
				{
					PluralRule = 2,
					Code = "uz"
				}
			},
			{
				"Venda",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "ve",
					GoogleCode = "-"
				}
			},
			{
				"Vietnamese",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "vi"
				}
			},
			{
				"Volapk",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "vo",
					GoogleCode = "-"
				}
			},
			{
				"Walloon",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "wa",
					GoogleCode = "-"
				}
			},
			{
				"Welsh",
				new LanguageCodeDef
				{
					PluralRule = 16,
					Code = "cy"
				}
			},
			{
				"Wolof",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "wo",
					GoogleCode = "-"
				}
			},
			{
				"Frisian",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "fy"
				}
			},
			{
				"Xhosa",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "xh"
				}
			},
			{
				"Yiddish",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "yi"
				}
			},
			{
				"Yoruba",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "yo"
				}
			},
			{
				"Zhuang",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "za",
					GoogleCode = "-"
				}
			},
			{
				"Zulu",
				new LanguageCodeDef
				{
					PluralRule = 1,
					Code = "zu"
				}
			}
		};

		public static string GetLanguageCode(string Filter, bool ShowWarnings = false)
		{
			if (string.IsNullOrEmpty(Filter))
			{
				return string.Empty;
			}
			string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (LanguageMatchesFilter(item.Key, filters))
				{
					return item.Value.Code;
				}
			}
			if (ShowWarnings)
			{
				UnityEngine.Debug.Log($"Language '{Filter}' not recognized. Please, add the language code to GoogleTranslation.cs");
			}
			return string.Empty;
		}

		public static List<string> GetLanguagesForDropdown(string Filter, string CodesToExclude)
		{
			string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
			List<string> list = new List<string>();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (string.IsNullOrEmpty(Filter) || LanguageMatchesFilter(item.Key, filters))
				{
					string text = string.Concat("[" + item.Value.Code + "]");
					if (!CodesToExclude.Contains(text))
					{
						list.Add(item.Key + " " + text);
					}
				}
			}
			for (int num = list.Count - 2; num >= 0; num--)
			{
				string text2 = list[num].Substring(0, list[num].IndexOf(" ["));
				if (list[num + 1].StartsWith(text2))
				{
					list[num] = text2 + "/" + list[num];
					list.Insert(num + 1, text2 + "/");
				}
			}
			return list;
		}

		private static bool LanguageMatchesFilter(string Language, string[] Filters)
		{
			Language = Language.ToLowerInvariant();
			int i = 0;
			for (int num = Filters.Length; i < num; i++)
			{
				if (Filters[i] != "")
				{
					if (!Language.Contains(Filters[i].ToLower()))
					{
						return false;
					}
					Language = Language.Remove(Language.IndexOf(Filters[i]), Filters[i].Length);
				}
			}
			return true;
		}

		public static string GetFormatedLanguageName(string Language)
		{
			string empty = string.Empty;
			int num = Language.IndexOf(" [");
			if (num > 0)
			{
				Language = Language.Substring(0, num);
			}
			num = Language.IndexOf('/');
			if (num > 0)
			{
				empty = Language.Substring(0, num);
				if (Language == empty + "/" + empty)
				{
					return empty;
				}
				Language = Language.Replace("/", " (") + ")";
			}
			return Language;
		}

		public static string GetCodedLanguage(string Language, string code)
		{
			string languageCode = GetLanguageCode(Language);
			if (string.Compare(code, languageCode, StringComparison.OrdinalIgnoreCase) == 0)
			{
				return Language;
			}
			return Language + " [" + code + "]";
		}

		public static void UnPackCodeFromLanguageName(string CodedLanguage, out string Language, out string code)
		{
			if (string.IsNullOrEmpty(CodedLanguage))
			{
				Language = string.Empty;
				code = string.Empty;
				return;
			}
			int num = CodedLanguage.IndexOf("[");
			if (num < 0)
			{
				Language = CodedLanguage;
				code = GetLanguageCode(Language);
			}
			else
			{
				Language = CodedLanguage.Substring(0, num).Trim();
				code = CodedLanguage.Substring(num + 1, CodedLanguage.IndexOf("]", num) - num - 1);
			}
		}

		public static string GetGoogleLanguageCode(string InternationalCode)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (InternationalCode == item.Value.Code)
				{
					if (item.Value.GoogleCode == "-")
					{
						return null;
					}
					return (!string.IsNullOrEmpty(item.Value.GoogleCode)) ? item.Value.GoogleCode : InternationalCode;
				}
			}
			return InternationalCode;
		}

		public static string GetLanguageName(string code, bool useParenthesesForRegion = false, bool allowDiscardRegion = true)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (!(code == item.Value.Code))
				{
					continue;
				}
				string text = item.Key;
				if (useParenthesesForRegion)
				{
					int num = text.IndexOf('/');
					if (num > 0)
					{
						text = text.Substring(0, num) + " (" + text.Substring(num + 1) + ")";
					}
				}
				return text;
			}
			if (allowDiscardRegion)
			{
				int num2 = code.IndexOf("-");
				if (num2 > 0)
				{
					return GetLanguageName(code.Substring(0, num2), useParenthesesForRegion, allowDiscardRegion: false);
				}
			}
			return null;
		}

		public static List<string> GetAllInternationalCodes()
		{
			HashSet<string> hashSet = new HashSet<string>();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				hashSet.Add(item.Value.Code);
			}
			return new List<string>(hashSet);
		}

		public static bool LanguageCode_HasJoinedWord(string languageCode)
		{
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (languageCode == item.Value.GoogleCode || languageCode == item.Value.Code)
				{
					return item.Value.HasJoinedWords;
				}
			}
			return false;
		}

		private static int GetPluralRule(string langCode)
		{
			if (langCode.Length > 2)
			{
				langCode = langCode.Substring(0, 2);
			}
			langCode = langCode.ToLower();
			foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
			{
				if (item.Value.Code == langCode)
				{
					return item.Value.PluralRule;
				}
			}
			return 0;
		}

		public static bool LanguageHasPluralType(string langCode, string pluralType)
		{
			switch (pluralType)
			{
			case "Plural":
			case "Zero":
			case "One":
				return true;
			default:
				switch (GetPluralRule(langCode))
				{
				case 3:
					if (!(pluralType == "Two"))
					{
						return pluralType == "Few";
					}
					return true;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
					return pluralType == "Few";
				case 9:
					if (!(pluralType == "Two"))
					{
						return pluralType == "Few";
					}
					return true;
				case 10:
				case 11:
				case 15:
				case 16:
					if (!(pluralType == "Two") && !(pluralType == "Few"))
					{
						return pluralType == "Many";
					}
					return true;
				case 12:
					if (!(pluralType == "Few"))
					{
						return pluralType == "Many";
					}
					return true;
				case 13:
					return pluralType == "Two";
				default:
					return false;
				}
			}
		}

		public static ePluralType GetPluralType(string langCode, int n)
		{
			switch (n)
			{
			case 0:
				return ePluralType.Zero;
			case 1:
				return ePluralType.One;
			default:
				switch (GetPluralRule(langCode))
				{
				case 0:
					return ePluralType.Plural;
				case 1:
					if (n != 1)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 2:
					if (n > 1)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 3:
					switch (n)
					{
					default:
						if (!inRange(n, 3, 10) && !inRange(n, 13, 19))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					case 2:
					case 12:
						return ePluralType.Two;
					case 1:
					case 11:
						return ePluralType.One;
					}
				case 4:
					if (n != 1)
					{
						if (!inRange(n % 100, 1, 19))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 5:
					if (n % 10 != 1 || n % 100 == 11)
					{
						if (n % 10 < 2 || (n % 100 >= 10 && n % 100 < 20))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 6:
					if (n % 10 != 1 || n % 100 == 11)
					{
						if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 7:
					if (n != 1)
					{
						if (!inRange(n, 2, 4))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 8:
					if (n != 1)
					{
						if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
						{
							return ePluralType.Plural;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 9:
					if (n % 100 != 1)
					{
						if (n % 100 != 2)
						{
							if (!inRange(n % 100, 3, 4))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 10:
					switch (n)
					{
					default:
						if (!inRange(n, 3, 6))
						{
							if (!inRange(n, 7, 10))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					case 2:
						return ePluralType.Two;
					case 1:
						return ePluralType.One;
					}
				case 11:
					switch (n)
					{
					default:
						if (!inRange(n % 100, 3, 10))
						{
							if (n % 100 < 11)
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					case 2:
						return ePluralType.Two;
					case 1:
						return ePluralType.One;
					case 0:
						return ePluralType.Zero;
					}
				case 12:
					if (n != 1)
					{
						if (!inRange(n % 100, 1, 10))
						{
							if (!inRange(n % 100, 11, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Many;
						}
						return ePluralType.Few;
					}
					return ePluralType.One;
				case 13:
					if (n % 10 != 1)
					{
						if (n % 10 != 2)
						{
							return ePluralType.Plural;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 14:
					if (n % 10 != 1 || n % 100 == 11)
					{
						return ePluralType.Plural;
					}
					return ePluralType.One;
				case 15:
					if (n % 10 != 1 || n % 100 == 11 || n % 100 == 71 || n % 100 == 91)
					{
						if (n % 10 != 2 || n % 100 == 12 || n % 100 == 72 || n % 100 == 92)
						{
							if ((n % 10 != 3 && n % 10 != 4 && n % 10 != 9) || n % 100 == 13 || n % 100 == 14 || n % 100 == 19 || n % 100 == 73 || n % 100 == 74 || n % 100 == 79 || n % 100 == 93 || n % 100 == 94 || n % 100 == 99)
							{
								if (n % 1000000 != 0)
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						}
						return ePluralType.Two;
					}
					return ePluralType.One;
				case 16:
					return n switch
					{
						6 => ePluralType.Many, 
						3 => ePluralType.Few, 
						2 => ePluralType.Two, 
						1 => ePluralType.One, 
						0 => ePluralType.Zero, 
						_ => ePluralType.Plural, 
					};
				default:
					return ePluralType.Plural;
				}
			}
		}

		public static int GetPluralTestNumber(string langCode, ePluralType pluralType)
		{
			switch (pluralType)
			{
			case ePluralType.Zero:
				return 0;
			case ePluralType.One:
				return 1;
			case ePluralType.Few:
				return 3;
			case ePluralType.Many:
				switch (GetPluralRule(langCode))
				{
				case 10:
					return 8;
				case 11:
				case 12:
					return 13;
				case 15:
					return 1000000;
				default:
					return 6;
				}
			default:
				return 936;
			}
		}

		private static bool inRange(int amount, int min, int max)
		{
			if (amount >= min)
			{
				return amount <= max;
			}
			return false;
		}
	}
	public static class GoogleTranslation
	{
		public delegate void fnOnTranslated(string Translation, string Error);

		public delegate void fnOnTranslationReady(Dictionary<string, TranslationQuery> dict, string error);

		private static List<UnityWebRequest> mCurrentTranslations = new List<UnityWebRequest>();

		private static List<TranslationJob> mTranslationJobs = new List<TranslationJob>();

		public static bool CanTranslate()
		{
			if (LocalizationManager.Sources.Count > 0)
			{
				return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL());
			}
			return false;
		}

		public static void Translate(string text, string LanguageCodeFrom, string LanguageCodeTo, fnOnTranslated OnTranslationReady)
		{
			LocalizationManager.InitializeIfNeeded();
			if (!CanTranslate())
			{
				OnTranslationReady(null, "WebService is not set correctly or needs to be reinstalled");
				return;
			}
			if (LanguageCodeTo == LanguageCodeFrom)
			{
				OnTranslationReady(text, null);
				return;
			}
			Dictionary<string, TranslationQuery> queries = new Dictionary<string, TranslationQuery>();
			if (string.IsNullOrEmpty(LanguageCodeTo))
			{
				OnTranslationReady(string.Empty, null);
				return;
			}
			CreateQueries(text, LanguageCodeFrom, LanguageCodeTo, queries);
			Translate(queries, delegate(Dictionary<string, TranslationQuery> results, string error)
			{
				if (!string.IsNullOrEmpty(error) || results.Count == 0)
				{
					OnTranslationReady(null, error);
				}
				else
				{
					string translation = RebuildTranslation(text, queries, LanguageCodeTo);
					OnTranslationReady(translation, null);
				}
			});
		}

		public static string ForceTranslate(string text, string LanguageCodeFrom, string LanguageCodeTo)
		{
			Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
			AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dictionary);
			TranslationJob_Main translationJob_Main = new TranslationJob_Main(dictionary, null);
			while (true)
			{
				switch (translationJob_Main.GetState())
				{
				case TranslationJob.eJobState.Running:
					break;
				case TranslationJob.eJobState.Failed:
					return null;
				default:
					return GetQueryResult(text, "", dictionary);
				}
			}
		}

		public static void Translate(Dictionary<string, TranslationQuery> requests, fnOnTranslationReady OnTranslationReady, bool usePOST = true)
		{
			AddTranslationJob(new TranslationJob_Main(requests, OnTranslationReady));
		}

		public static bool ForceTranslate(Dictionary<string, TranslationQuery> requests, bool usePOST = true)
		{
			TranslationJob_Main translationJob_Main = new TranslationJob_Main(requests, null);
			while (true)
			{
				switch (translationJob_Main.GetState())
				{
				case TranslationJob.eJobState.Running:
					break;
				case TranslationJob.eJobState.Failed:
					return false;
				default:
					return true;
				}
			}
		}

		public static List<string> ConvertTranslationRequest(Dictionary<string, TranslationQuery> requests, bool encodeGET)
		{
			List<string> list = new List<string>();
			StringBuilder stringBuilder = new StringBuilder();
			foreach (KeyValuePair<string, TranslationQuery> request in requests)
			{
				TranslationQuery value = request.Value;
				if (stringBuilder.Length > 0)
				{
					stringBuilder.Append("<I2Loc>");
				}
				stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.LanguageCode));
				stringBuilder.Append(":");
				for (int i = 0; i < value.TargetLanguagesCode.Length; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append(",");
					}
					stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.TargetLanguagesCode[i]));
				}
				stringBuilder.Append("=");
				string text = ((TitleCase(value.Text) == value.Text) ? value.Text.ToLowerInvariant() : value.Text);
				if (!encodeGET)
				{
					stringBuilder.Append(text);
					continue;
				}
				stringBuilder.Append(Uri.EscapeDataString(text));
				if (stringBuilder.Length > 4000)
				{
					list.Add(stringBuilder.ToString());
					stringBuilder.Length = 0;
				}
			}
			list.Add(stringBuilder.ToString());
			return list;
		}

		private static void AddTranslationJob(TranslationJob job)
		{
			mTranslationJobs.Add(job);
			if (mTranslationJobs.Count == 1)
			{
				CoroutineManager.Start(WaitForTranslations());
			}
		}

		private static IEnumerator WaitForTranslations()
		{
			while (mTranslationJobs.Count > 0)
			{
				TranslationJob[] array = mTranslationJobs.ToArray();
				foreach (TranslationJob translationJob in array)
				{
					if (translationJob.GetState() != 0)
					{
						mTranslationJobs.Remove(translationJob);
					}
				}
				yield return null;
			}
		}

		public static string ParseTranslationResult(string html, Dictionary<string, TranslationQuery> requests)
		{
			if (html.StartsWith("<!DOCTYPE html>") || html.StartsWith("<HTML>"))
			{
				if (html.Contains("The script completed but did not return anything"))
				{
					return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
				}
				if (html.Contains("Service invoked too many times in a short time"))
				{
					return "";
				}
				return "There was a problem contacting the WebService. Please try again later\n" + html;
			}
			string[] array = html.Split(new string[1] { "<I2Loc>" }, StringSplitOptions.None);
			string[] separator = new string[1] { "<i2>" };
			int num = 0;
			string[] array2 = requests.Keys.ToArray();
			foreach (string text in array2)
			{
				TranslationQuery value = FindQueryFromOrigText(text, requests);
				string text2 = array[num++];
				if (value.Tags != null)
				{
					for (int num2 = value.Tags.Length - 1; num2 >= 0; num2--)
					{
						text2 = text2.Replace(GetGoogleNoTranslateTag(num2), value.Tags[num2]);
					}
				}
				value.Results = text2.Split(separator, StringSplitOptions.None);
				if (TitleCase(text) == text)
				{
					for (int j = 0; j < value.Results.Length; j++)
					{
						value.Results[j] = TitleCase(value.Results[j]);
					}
				}
				requests[value.OrigText] = value;
			}
			return null;
		}

		public static bool IsTranslating()
		{
			if (mCurrentTranslations.Count <= 0)
			{
				return mTranslationJobs.Count > 0;
			}
			return true;
		}

		public static void CancelCurrentGoogleTranslations()
		{
			mCurrentTranslations.Clear();
			foreach (TranslationJob mTranslationJob in mTranslationJobs)
			{
				mTranslationJob.Dispose();
			}
			mTranslationJobs.Clear();
		}

		public static void CreateQueries(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!text.Contains("[i2s_"))
			{
				CreateQueries_Plurals(text, LanguageCodeFrom, LanguageCodeTo, dict);
				return;
			}
			foreach (KeyValuePair<string, string> specialization in SpecializationManager.GetSpecializations(text))
			{
				CreateQueries_Plurals(specialization.Value, LanguageCodeFrom, LanguageCodeTo, dict);
			}
		}

		private static void CreateQueries_Plurals(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			bool flag = text.Contains("{[#");
			bool flag2 = text.Contains("[i2p_");
			if (!HasParameters(text) || (!flag && !flag2))
			{
				AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dict);
				return;
			}
			bool forceTag = flag;
			for (ePluralType ePluralType2 = ePluralType.Zero; ePluralType2 <= ePluralType.Plural; ePluralType2++)
			{
				string pluralType = ePluralType2.ToString();
				if (GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, pluralType))
				{
					string text2 = GetPluralText(text, pluralType);
					int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
					string pluralParameter = GetPluralParameter(text2, forceTag);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text2 = text2.Replace(pluralParameter, pluralTestNumber.ToString());
					}
					AddQuery(text2, LanguageCodeFrom, LanguageCodeTo, dict);
				}
			}
		}

		public static void AddQuery(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			if (!dict.ContainsKey(text))
			{
				TranslationQuery translationQuery = default(TranslationQuery);
				translationQuery.OrigText = text;
				translationQuery.LanguageCode = LanguageCodeFrom;
				translationQuery.TargetLanguagesCode = new string[1] { LanguageCodeTo };
				TranslationQuery query = translationQuery;
				query.Text = text;
				ParseNonTranslatableElements(ref query);
				dict[text] = query;
			}
			else
			{
				TranslationQuery value = dict[text];
				if (Array.IndexOf(value.TargetLanguagesCode, LanguageCodeTo) < 0)
				{
					value.TargetLanguagesCode = value.TargetLanguagesCode.Concat(new string[1] { LanguageCodeTo }).Distinct().ToArray();
				}
				dict[text] = value;
			}
		}

		private static string GetTranslation(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!dict.ContainsKey(text))
			{
				return null;
			}
			TranslationQuery translationQuery = dict[text];
			int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
			if (num < 0)
			{
				return "";
			}
			if (translationQuery.Results == null)
			{
				return "";
			}
			return translationQuery.Results[num];
		}

		private static TranslationQuery FindQueryFromOrigText(string origText, Dictionary<string, TranslationQuery> dict)
		{
			foreach (KeyValuePair<string, TranslationQuery> item in dict)
			{
				if (item.Value.OrigText == origText)
				{
					return item.Value;
				}
			}
			return default(TranslationQuery);
		}

		public static bool HasParameters(string text)
		{
			int num = text.IndexOf("{[");
			if (num < 0)
			{
				return false;
			}
			return text.IndexOf("]}", num) > 0;
		}

		public static string GetPluralParameter(string text, bool forceTag)
		{
			int num = text.IndexOf("{[#");
			if (num < 0)
			{
				if (forceTag)
				{
					return null;
				}
				num = text.IndexOf("{[");
			}
			if (num < 0)
			{
				return null;
			}
			int num2 = text.IndexOf("]}", num + 2);
			if (num2 < 0)
			{
				return null;
			}
			return text.Substring(num, num2 - num + 2);
		}

		public static string GetPluralText(string text, string pluralType)
		{
			pluralType = "[i2p_" + pluralType + "]";
			int num = text.IndexOf(pluralType);
			if (num >= 0)
			{
				num += pluralType.Length;
				int num2 = text.IndexOf("[i2p_", num);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				return text.Substring(num, num2 - num);
			}
			num = text.IndexOf("[i2p_");
			if (num < 0)
			{
				return text;
			}
			if (num > 0)
			{
				return text.Substring(0, num);
			}
			num = text.IndexOf("]");
			if (num < 0)
			{
				return text;
			}
			num++;
			int num3 = text.IndexOf("[i2p_", num);
			if (num3 < 0)
			{
				num3 = text.Length;
			}
			return text.Substring(num, num3 - num);
		}

		private static int FindClosingTag(string tag, MatchCollection matches, int startIndex)
		{
			int i = startIndex;
			for (int count = matches.Count; i < count; i++)
			{
				string captureMatch = I2Utils.GetCaptureMatch(matches[i]);
				if (captureMatch[0] == '/' && tag.StartsWith(captureMatch.Substring(1)))
				{
					return i;
				}
			}
			return -1;
		}

		private static string GetGoogleNoTranslateTag(int tagNumber)
		{
			if (tagNumber < 70)
			{
				return "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++".Substring(0, tagNumber + 1);
			}
			string text = "";
			for (int i = -1; i < tagNumber; i++)
			{
				text += "+";
			}
			return text;
		}

		private static void ParseNonTranslatableElements(ref TranslationQuery query)
		{
			MatchCollection matchCollection = Regex.Matches(query.Text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>");
			if (matchCollection == null || matchCollection.Count == 0)
			{
				return;
			}
			string text = query.Text;
			List<string> list = new List<string>();
			int i = 0;
			for (int count = matchCollection.Count; i < count; i++)
			{
				string captureMatch = I2Utils.GetCaptureMatch(matchCollection[i]);
				int num = FindClosingTag(captureMatch, matchCollection, i);
				if (num < 0)
				{
					string text2 = matchCollection[i].ToString();
					if (text2.StartsWith("{[") && text2.EndsWith("]}"))
					{
						text = text.Replace(text2, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text2);
					}
				}
				else if (captureMatch == "i2nt")
				{
					string text3 = query.Text.Substring(matchCollection[i].Index, matchCollection[num].Index - matchCollection[i].Index + matchCollection[num].Length);
					text = text.Replace(text3, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text3);
				}
				else
				{
					string text4 = matchCollection[i].ToString();
					text = text.Replace(text4, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text4);
					string text5 = matchCollection[num].ToString();
					text = text.Replace(text5, GetGoogleNoTranslateTag(list.Count) + " ");
					list.Add(text5);
				}
			}
			query.Text = text;
			query.Tags = list.ToArray();
		}

		public static string GetQueryResult(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
		{
			if (!dict.ContainsKey(text))
			{
				return null;
			}
			TranslationQuery translationQuery = dict[text];
			if (translationQuery.Results == null || translationQuery.Results.Length < 0)
			{
				return null;
			}
			if (string.IsNullOrEmpty(LanguageCodeTo))
			{
				return translationQuery.Results[0];
			}
			int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
			if (num < 0)
			{
				return null;
			}
			return translationQuery.Results[num];
		}

		public static string RebuildTranslation(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
		{
			if (!text.Contains("[i2s_"))
			{
				return RebuildTranslation_Plural(text, dict, LanguageCodeTo);
			}
			Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (KeyValuePair<string, string> item in specializations)
			{
				dictionary[item.Key] = RebuildTranslation_Plural(item.Value, dict, LanguageCodeTo);
			}
			return SpecializationManager.SetSpecializedText(dictionary);
		}

		private static string RebuildTranslation_Plural(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
		{
			bool flag = text.Contains("{[#");
			bool flag2 = text.Contains("[i2p_");
			if (!HasParameters(text) || (!flag && !flag2))
			{
				return GetTranslation(text, LanguageCodeTo, dict);
			}
			StringBuilder stringBuilder = new StringBuilder();
			string text2 = null;
			bool forceTag = flag;
			for (ePluralType ePluralType2 = ePluralType.Plural; ePluralType2 >= ePluralType.Zero; ePluralType2--)
			{
				string text3 = ePluralType2.ToString();
				if (!GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, text3))
				{
					continue;
				}
				string text4 = GetPluralText(text, text3);
				int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
				string pluralParameter = GetPluralParameter(text4, forceTag);
				if (!string.IsNullOrEmpty(pluralParameter))
				{
					text4 = text4.Replace(pluralParameter, pluralTestNumber.ToString());
				}
				string text5 = GetTranslation(text4, LanguageCodeTo, dict);
				if (!string.IsNullOrEmpty(pluralParameter))
				{
					text5 = text5.Replace(pluralTestNumber.ToString(), pluralParameter);
				}
				if (ePluralType2 == ePluralType.Plural)
				{
					text2 = text5;
				}
				else
				{
					if (text5 == text2)
					{
						continue;
					}
					stringBuilder.AppendFormat("[i2p_{0}]", text3);
				}
				stringBuilder.Append(text5);
			}
			return stringBuilder.ToString();
		}

		public static string UppercaseFirst(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return string.Empty;
			}
			char[] array = s.ToLower().ToCharArray();
			array[0] = char.ToUpper(array[0]);
			return new string(array);
		}

		public static string TitleCase(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				return string.Empty;
			}
			return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s);
		}
	}
	public struct TranslationQuery
	{
		public string OrigText;

		public string Text;

		public string LanguageCode;

		public string[] TargetLanguagesCode;

		public string[] Results;

		public string[] Tags;
	}
	public class TranslationJob : IDisposable
	{
		public enum eJobState
		{
			Running,
			Succeeded,
			Failed
		}

		public eJobState mJobState;

		public virtual eJobState GetState()
		{
			return mJobState;
		}

		public virtual void Dispose()
		{
		}
	}
	public class TranslationJob_WWW : TranslationJob
	{
		public UnityWebRequest www;

		public override void Dispose()
		{
			if (www != null)
			{
				www.Dispose();
			}
			www = null;
		}
	}
	public class TranslationJob_GET : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		private List<string> mQueries;

		public string mErrorMessage;

		public TranslationJob_GET(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			mQueries = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: true);
			GetState();
		}

		private void ExecuteNextQuery()
		{
			if (mQueries.Count == 0)
			{
				mJobState = eJobState.Succeeded;
				return;
			}
			int index = mQueries.Count - 1;
			string arg = mQueries[index];
			mQueries.RemoveAt(index);
			string uri = $"{LocalizationManager.GetWebServiceURL()}?action=Translate&list={arg}";
			www = UnityWebRequest.Get(uri);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			if (www == null)
			{
				ExecuteNextQuery();
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (string.IsNullOrEmpty(errorMsg))
			{
				errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
				if (string.IsNullOrEmpty(errorMsg))
				{
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, null);
					}
					return;
				}
			}
			mJobState = eJobState.Failed;
			mErrorMessage = errorMsg;
		}
	}
	public class TranslationJob_Main : TranslationJob
	{
		private TranslationJob_WEB mWeb;

		private TranslationJob_POST mPost;

		private TranslationJob_GET mGet;

		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public string mErrorMessage;

		public TranslationJob_Main(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			mPost = new TranslationJob_POST(requests, OnTranslationReady);
		}

		public override eJobState GetState()
		{
			if (mWeb != null)
			{
				switch (mWeb.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mWeb.Dispose();
					mWeb = null;
					mPost = new TranslationJob_POST(_requests, _OnTranslationReady);
					break;
				}
			}
			if (mPost != null)
			{
				switch (mPost.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mPost.Dispose();
					mPost = null;
					mGet = new TranslationJob_GET(_requests, _OnTranslationReady);
					break;
				}
			}
			if (mGet != null)
			{
				switch (mGet.GetState())
				{
				case eJobState.Running:
					return eJobState.Running;
				case eJobState.Succeeded:
					mJobState = eJobState.Succeeded;
					break;
				case eJobState.Failed:
					mErrorMessage = mGet.mErrorMessage;
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, mErrorMessage);
					}
					mGet.Dispose();
					mGet = null;
					break;
				}
			}
			return mJobState;
		}

		public override void Dispose()
		{
			if (mPost != null)
			{
				mPost.Dispose();
			}
			if (mGet != null)
			{
				mGet.Dispose();
			}
			mPost = null;
			mGet = null;
		}
	}
	public class TranslationJob_POST : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public TranslationJob_POST(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			List<string> list = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: false);
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("action", "Translate");
			wWWForm.AddField("list", list[0]);
			www = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(), wWWForm);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (!string.IsNullOrEmpty(errorMsg))
			{
				mJobState = eJobState.Failed;
				return;
			}
			errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
			if (_OnTranslationReady != null)
			{
				_OnTranslationReady(_requests, errorMsg);
			}
			mJobState = eJobState.Succeeded;
		}
	}
	public class TranslationJob_WEB : TranslationJob_WWW
	{
		private Dictionary<string, TranslationQuery> _requests;

		private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

		public string mErrorMessage;

		private string mCurrentBatch_ToLanguageCode;

		private string mCurrentBatch_FromLanguageCode;

		private List<string> mCurrentBatch_Text;

		private List<KeyValuePair<string, string>> mQueries;

		public TranslationJob_WEB(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
		{
			_requests = requests;
			_OnTranslationReady = OnTranslationReady;
			FindAllQueries();
			ExecuteNextBatch();
		}

		private void FindAllQueries()
		{
			mQueries = new List<KeyValuePair<string, string>>();
			foreach (KeyValuePair<string, TranslationQuery> request in _requests)
			{
				string[] targetLanguagesCode = request.Value.TargetLanguagesCode;
				foreach (string text in targetLanguagesCode)
				{
					mQueries.Add(new KeyValuePair<string, string>(request.Value.OrigText, request.Value.LanguageCode + ":" + text));
				}
			}
			mQueries.Sort((KeyValuePair<string, string> a, KeyValuePair<string, string> b) => a.Value.CompareTo(b.Value));
		}

		private void ExecuteNextBatch()
		{
			if (mQueries.Count == 0)
			{
				mJobState = eJobState.Succeeded;
				return;
			}
			mCurrentBatch_Text = new List<string>();
			string text = null;
			int num = 200;
			StringBuilder stringBuilder = new StringBuilder();
			int i;
			for (i = 0; i < mQueries.Count; i++)
			{
				string key = mQueries[i].Key;
				string value = mQueries[i].Value;
				if (text == null || value == text)
				{
					if (i != 0)
					{
						stringBuilder.Append("|||");
					}
					stringBuilder.Append(key);
					mCurrentBatch_Text.Add(key);
					text = value;
				}
				if (stringBuilder.Length > num)
				{
					break;
				}
			}
			mQueries.RemoveRange(0, i);
			string[] array = text.Split(':');
			mCurrentBatch_FromLanguageCode = array[0];
			mCurrentBatch_ToLanguageCode = array[1];
			string text2 = $"http://www.google.com/translate_t?hl=en&vi=c&ie=UTF8&oe=UTF8&submit=Translate&langpair={mCurrentBatch_FromLanguageCode}|{mCurrentBatch_ToLanguageCode}&text={Uri.EscapeUriString(stringBuilder.ToString())}";
			UnityEngine.Debug.Log(text2);
			www = UnityWebRequest.Get(text2);
			I2Utils.SendWebRequest(www);
		}

		public override eJobState GetState()
		{
			if (www != null && www.isDone)
			{
				ProcessResult(www.downloadHandler.data, www.error);
				www.Dispose();
				www = null;
			}
			if (www == null)
			{
				ExecuteNextBatch();
			}
			return mJobState;
		}

		public void ProcessResult(byte[] bytes, string errorMsg)
		{
			if (string.IsNullOrEmpty(errorMsg))
			{
				string @string = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
				UnityEngine.Debug.Log(ParseTranslationResult(@string, "aab"));
				if (string.IsNullOrEmpty(errorMsg))
				{
					if (_OnTranslationReady != null)
					{
						_OnTranslationReady(_requests, null);
					}
					return;
				}
			}
			mJobState = eJobState.Failed;
			mErrorMessage = errorMsg;
		}

		private string ParseTranslationResult(string html, string OriginalText)
		{
			try
			{
				int num = html.IndexOf("TRANSLATED_TEXT='") + "TRANSLATED_TEXT='".Length;
				int num2 = html.IndexOf("';var", num);
				string input = html.Substring(num, num2 - num);
				input = Regex.Replace(input, "\\\\x([a-fA-F0-9]{2})", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value, NumberStyles.HexNumber)));
				input = Regex.Replace(input, "&#(\\d+);", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value)));
				input = input.Replace("<br>", "\n");
				if (OriginalText.ToUpper() == OriginalText)
				{
					input = input.ToUpper();
				}
				else if (GoogleTranslation.UppercaseFirst(OriginalText) == OriginalText)
				{
					input = GoogleTranslation.UppercaseFirst(input);
				}
				else if (GoogleTranslation.TitleCase(OriginalText) == OriginalText)
				{
					input = GoogleTranslation.TitleCase(input);
				}
				return input;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
				return string.Empty;
			}
		}
	}
	public enum eLanguageDataFlags
	{
		DISABLED = 1,
		KEEP_LOADED = 2,
		NOT_LOADED = 4
	}
	[Serializable]
	public class LanguageData
	{
		public string Name;

		public string Code;

		public byte Flags;

		[NonSerialized]
		public bool Compressed;

		public bool IsEnabled()
		{
			return (Flags & 1) == 0;
		}

		public void SetEnabled(bool bEnabled)
		{
			if (bEnabled)
			{
				Flags = (byte)(Flags & 0xFFFFFFFEu);
			}
			else
			{
				Flags |= 1;
			}
		}

		public bool IsLoaded()
		{
			return (Flags & 4) == 0;
		}

		public bool CanBeUnloaded()
		{
			return (Flags & 2) == 0;
		}

		public void SetLoaded(bool loaded)
		{
			if (loaded)
			{
				Flags = (byte)(Flags & 0xFFFFFFFBu);
			}
			else
			{
				Flags |= 4;
			}
		}

		public void SetCanBeUnLoaded(bool allowUnloading)
		{
			if (allowUnloading)
			{
				Flags = (byte)(Flags & 0xFFFFFFFDu);
			}
			else
			{
				Flags |= 2;
			}
		}
	}
	[AddComponentMenu("I2/Localization/Source")]
	[ExecuteInEditMode]
	public class LanguageSource : MonoBehaviour, ISerializationCallbackReceiver, ILanguageSource
	{
		public delegate void fnOnSourceUpdated(LanguageSourceData source, bool ReceivedNewData, string errorMsg);

		public LanguageSourceData mSource = new LanguageSourceData();

		public int version;

		public bool NeverDestroy;

		public bool UserAgreesToHaveItOnTheScene;

		public bool UserAgreesToHaveItInsideThePluginsFolder;

		public bool GoogleLiveSyncIsUptoDate = true;

		public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

		public string Google_WebServiceURL;

		public string Google_SpreadsheetKey;

		public string Google_SpreadsheetName;

		public string Google_LastUpdatedVersion;

		public LanguageSourceData.eGoogleUpdateFrequency GoogleUpdateFrequency = LanguageSourceData.eGoogleUpdateFrequency.Weekly;

		public float GoogleUpdateDelay = 5f;

		public List<LanguageData> mLanguages = new List<LanguageData>();

		public bool IgnoreDeviceLanguage;

		public LanguageSourceData.eAllowUnloadLanguages _AllowUnloadingLanguages;

		public List<TermData> mTerms = new List<TermData>();

		public bool CaseInsensitiveTerms;

		public LanguageSourceData.MissingTranslationAction OnMissingTranslation = LanguageSourceData.MissingTranslationAction.Fallback;

		public string mTerm_AppName;

		public LanguageSourceData SourceData
		{
			get
			{
				return mSource;
			}
			set
			{
				mSource = value;
			}
		}

		public event fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

		private void Awake()
		{
			mSource.owner = this;
			mSource.Awake();
		}

		private void OnDestroy()
		{
			NeverDestroy = false;
			if (!NeverDestroy)
			{
				mSource.OnDestroy();
			}
		}

		public string GetSourceName()
		{
			string text = base.gameObject.name;
			Transform parent = base.transform.parent;
			while ((bool)parent)
			{
				text = parent.name + "_" + text;
				parent = parent.parent;
			}
			return text;
		}

		public void OnBeforeSerialize()
		{
			version = 1;
		}

		public void OnAfterDeserialize()
		{
			if (version != 0 && mSource != null)
			{
				return;
			}
			mSource = new LanguageSourceData();
			mSource.owner = this;
			mSource.UserAgreesToHaveItOnTheScene = UserAgreesToHaveItOnTheScene;
			mSource.UserAgreesToHaveItInsideThePluginsFolder = UserAgreesToHaveItInsideThePluginsFolder;
			mSource.IgnoreDeviceLanguage = IgnoreDeviceLanguage;
			mSource._AllowUnloadingLanguages = _AllowUnloadingLanguages;
			mSource.CaseInsensitiveTerms = CaseInsensitiveTerms;
			mSource.OnMissingTranslation = OnMissingTranslation;
			mSource.mTerm_AppName = mTerm_AppName;
			mSource.GoogleLiveSyncIsUptoDate = GoogleLiveSyncIsUptoDate;
			mSource.Google_WebServiceURL = Google_WebServiceURL;
			mSource.Google_SpreadsheetKey = Google_SpreadsheetKey;
			mSource.Google_SpreadsheetName = Google_SpreadsheetName;
			mSource.Google_LastUpdatedVersion = Google_LastUpdatedVersion;
			mSource.GoogleUpdateFrequency = GoogleUpdateFrequency;
			mSource.GoogleUpdateDelay = GoogleUpdateDelay;
			mSource.Event_OnSourceUpdateFromGoogle += this.Event_OnSourceUpdateFromGoogle;
			if (mLanguages != null && mLanguages.Count > 0)
			{
				mSource.mLanguages.Clear();
				mSource.mLanguages.AddRange(mLanguages);
				mLanguages.Clear();
			}
			if (Assets != null && Assets.Count > 0)
			{
				mSource.Assets.Clear();
				mSource.Assets.AddRange(Assets);
				Assets.Clear();
			}
			if (mTerms != null && mTerms.Count > 0)
			{
				mSource.mTerms.Clear();
				for (int i = 0; i < mTerms.Count; i++)
				{
					mSource.mTerms.Add(mTerms[i]);
				}
				mTerms.Clear();
			}
			version = 1;
			this.Event_OnSourceUpdateFromGoogle = null;
		}
	}
	[CreateAssetMenu(fileName = "I2Languages", menuName = "I2 Localization/LanguageSource", order = 1)]
	public class LanguageSourceAsset : ScriptableObject, ILanguageSource
	{
		public LanguageSourceData mSource = new LanguageSourceData();

		public LanguageSourceData SourceData
		{
			get
			{
				return mSource;
			}
			set
			{
				mSource = value;
			}
		}
	}
	public interface ILanguageSource
	{
		LanguageSourceData SourceData { get; set; }
	}
	[Serializable]
	[ExecuteInEditMode]
	public class LanguageSourceData
	{
		public enum MissingTranslationAction
		{
			Empty,
			Fallback,
			ShowWarning,
			ShowTerm
		}

		public enum eAllowUnloadLanguages
		{
			Never,
			OnlyInDevice,
			EditorAndDevice
		}

		public enum eGoogleUpdateFrequency
		{
			Always,
			Never,
			Daily,
			Weekly,
			Monthly,
			OnlyOnce,
			EveryOtherDay
		}

		public enum eGoogleUpdateSynchronization
		{
			Manual,
			OnSceneLoaded,
			AsSoonAsDownloaded
		}

		[NonSerialized]
		public ILanguageSource owner;

		public bool UserAgreesToHaveItOnTheScene;

		public bool UserAgreesToHaveItInsideThePluginsFolder;

		public bool GoogleLiveSyncIsUptoDate = true;

		[NonSerialized]
		public bool mIsGlobalSource;

		public List<TermData> mTerms = new List<TermData>();

		public bool CaseInsensitiveTerms;

		[NonSerialized]
		public Dictionary<string, TermData> mDictionary = new Dictionary<string, TermData>(StringComparer.Ordinal);

		public MissingTranslationAction OnMissingTranslation = MissingTranslationAction.Fallback;

		public string mTerm_AppName;

		public List<LanguageData> mLanguages = new List<LanguageData>();

		public bool IgnoreDeviceLanguage;

		public eAllowUnloadLanguages _AllowUnloadingLanguages;

		public string Google_WebServiceURL;

		public string Google_SpreadsheetKey;

		public string Google_SpreadsheetName;

		public string Google_LastUpdatedVersion;

		public eGoogleUpdateFrequency GoogleUpdateFrequency = eGoogleUpdateFrequency.Weekly;

		public eGoogleUpdateFrequency GoogleInEditorCheckFrequency = eGoogleUpdateFrequency.Daily;

		public eGoogleUpdateSynchronization GoogleUpdateSynchronization = eGoogleUpdateSynchronization.OnSceneLoaded;

		public float GoogleUpdateDelay;

		public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

		[NonSerialized]
		public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		private string mDelayedGoogleData;

		public static string EmptyCategory = "Default";

		public static char[] CategorySeparators = "/\\".ToCharArray();

		public UnityEngine.Object ownerObject => owner as UnityEngine.Object;

		public event LanguageSource.fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

		public void Awake()
		{
			LocalizationManager.AddSource(this);
			UpdateDictionary();
			UpdateAssetDictionary();
			LocalizationManager.LocalizeAll(Force: true);
		}

		public void OnDestroy()
		{
			LocalizationManager.RemoveSource(this);
		}

		public bool IsEqualTo(LanguageSourceData Source)
		{
			if (Source.mLanguages.Count != mLanguages.Count)
			{
				return false;
			}
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (Source.GetLanguageIndex(mLanguages[i].Name) < 0)
				{
					return false;
				}
			}
			if (Source.mTerms.Count != mTerms.Count)
			{
				return false;
			}
			for (int j = 0; j < mTerms.Count; j++)
			{
				if (Source.GetTermData(mTerms[j].Term) == null)
				{
					return false;
				}
			}
			return true;
		}

		internal bool ManagerHasASimilarSource()
		{
			int i = 0;
			for (int count = LocalizationManager.Sources.Count; i < count; i++)
			{
				LanguageSourceData languageSourceData = LocalizationManager.Sources[i];
				if (languageSourceData != null && languageSourceData.IsEqualTo(this) && languageSourceData != this)
				{
					return true;
				}
			}
			return false;
		}

		public void ClearAllData()
		{
			mTerms.Clear();
			mLanguages.Clear();
			mDictionary.Clear();
			mAssetDictionary.Clear();
		}

		public bool IsGlobalSource()
		{
			return mIsGlobalSource;
		}

		public void Editor_SetDirty()
		{
		}

		public void UpdateAssetDictionary()
		{
			Assets.RemoveAll((UnityEngine.Object x) => x == null);
			mAssetDictionary = (from o in Assets.Distinct()
				group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
		}

		public UnityEngine.Object FindAsset(string Name)
		{
			if (Assets != null)
			{
				if (mAssetDictionary == null || mAssetDictionary.Count != Assets.Count)
				{
					UpdateAssetDictionary();
				}
				if (mAssetDictionary.TryGetValue(Name, out var value))
				{
					return value;
				}
			}
			return null;
		}

		public bool HasAsset(UnityEngine.Object Obj)
		{
			return Assets.Contains(Obj);
		}

		public void AddAsset(UnityEngine.Object Obj)
		{
			if (!Assets.Contains(Obj))
			{
				Assets.Add(Obj);
				UpdateAssetDictionary();
			}
		}

		public string Export_I2CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("Key[*]Type[*]Desc");
			foreach (LanguageData mLanguage in mLanguages)
			{
				stringBuilder.Append("[*]");
				if (!mLanguage.IsEnabled())
				{
					stringBuilder.Append('$');
				}
				stringBuilder.Append(GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code));
			}
			stringBuilder.Append("[ln]");
			mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
			int count = mLanguages.Count;
			bool flag = true;
			foreach (TermData mTerm in mTerms)
			{
				string term;
				if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
				{
					term = mTerm.Term;
				}
				else
				{
					if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
					{
						continue;
					}
					term = mTerm.Term.Substring(Category.Length + 1);
				}
				if (!flag)
				{
					stringBuilder.Append("[ln]");
				}
				flag = false;
				if (!specializationsAsRows)
				{
					AppendI2Term(stringBuilder, count, term, mTerm, Separator, null);
					continue;
				}
				List<string> allSpecializations = mTerm.GetAllSpecializations();
				for (int i = 0; i < allSpecializations.Count; i++)
				{
					if (i != 0)
					{
						stringBuilder.Append("[ln]");
					}
					string forceSpecialization = allSpecializations[i];
					AppendI2Term(stringBuilder, count, term, mTerm, Separator, forceSpecialization);
				}
			}
			return stringBuilder.ToString();
		}

		private static void AppendI2Term(StringBuilder Builder, int nLanguages, string Term, TermData termData, char Separator, string forceSpecialization)
		{
			AppendI2Text(Builder, Term);
			if (!string.IsNullOrEmpty(forceSpecialization) && forceSpecialization != "Any")
			{
				Builder.Append("[");
				Builder.Append(forceSpecialization);
				Builder.Append("]");
			}
			Builder.Append("[*]");
			Builder.Append(termData.TermType.ToString());
			Builder.Append("[*]");
			Builder.Append(termData.Description);
			for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
			{
				Builder.Append("[*]");
				string text = termData.Languages[i];
				if (!string.IsNullOrEmpty(forceSpecialization))
				{
					text = termData.GetTranslation(i, forceSpecialization);
				}
				AppendI2Text(Builder, text);
			}
		}

		private static void AppendI2Text(StringBuilder Builder, string text)
		{
			if (!string.IsNullOrEmpty(text))
			{
				if (text.StartsWith("'") || text.StartsWith("="))
				{
					Builder.Append('\'');
				}
				Builder.Append(text);
			}
		}

		private string Export_Language_to_Cache(int langIndex, bool fillTermWithFallback)
		{
			if (!mLanguages[langIndex].IsLoaded())
			{
				return null;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < mTerms.Count; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append("[i2t]");
				}
				TermData termData = mTerms[i];
				stringBuilder.Append(termData.Term);
				stringBuilder.Append("=");
				string Translation = termData.Languages[langIndex];
				if (OnMissingTranslation == MissingTranslationAction.Fallback && string.IsNullOrEmpty(Translation) && TryGetFallbackTranslation(termData, out Translation, langIndex, null, skipDisabled: true))
				{
					stringBuilder.Append("[i2fb]");
					if (fillTermWithFallback)
					{
						termData.Languages[langIndex] = Translation;
					}
				}
				if (!string.IsNullOrEmpty(Translation))
				{
					stringBuilder.Append(Translation);
				}
			}
			return stringBuilder.ToString();
		}

		public string Export_CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
		{
			StringBuilder stringBuilder = new StringBuilder();
			int count = mLanguages.Count;
			stringBuilder.AppendFormat("Key{0}Type{0}Desc", Separator);
			foreach (LanguageData mLanguage in mLanguages)
			{
				stringBuilder.Append(Separator);
				if (!mLanguage.IsEnabled())
				{
					stringBuilder.Append('$');
				}
				AppendString(stringBuilder, GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code), Separator);
			}
			stringBuilder.Append("\n");
			mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
			foreach (TermData mTerm in mTerms)
			{
				string term;
				if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
				{
					term = mTerm.Term;
				}
				else
				{
					if (!mTerm.Term.StartsWith(Category + "/") || !(Category != mTerm.Term))
					{
						continue;
					}
					term = mTerm.Term.Substring(Category.Length + 1);
				}
				if (specializationsAsRows)
				{
					foreach (string allSpecialization in mTerm.GetAllSpecializations())
					{
						AppendTerm(stringBuilder, count, term, mTerm, allSpecialization, Separator);
					}
				}
				else
				{
					AppendTerm(stringBuilder, count, term, mTerm, null, Separator);
				}
			}
			return stringBuilder.ToString();
		}

		private static void AppendTerm(StringBuilder Builder, int nLanguages, string Term, TermData termData, string specialization, char Separator)
		{
			AppendString(Builder, Term, Separator);
			if (!string.IsNullOrEmpty(specialization) && specialization != "Any")
			{
				Builder.AppendFormat("[{0}]", specialization);
			}
			Builder.Append(Separator);
			Builder.Append(termData.TermType.ToString());
			Builder.Append(Separator);
			AppendString(Builder, termData.Description, Separator);
			for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
			{
				Builder.Append(Separator);
				string text = termData.Languages[i];
				if (!string.IsNullOrEmpty(specialization))
				{
					text = termData.GetTranslation(i, specialization);
				}
				AppendTranslation(Builder, text, Separator, null);
			}
			Builder.Append("\n");
		}

		private static void AppendString(StringBuilder Builder, string Text, char Separator)
		{
			if (!string.IsNullOrEmpty(Text))
			{
				Text = Text.Replace("\\n", "\n");
				if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
				{
					Text = Text.Replace("\"", "\"\"");
					Builder.AppendFormat("\"{0}\"", Text);
				}
				else
				{
					Builder.Append(Text);
				}
			}
		}

		private static void AppendTranslation(StringBuilder Builder, string Text, char Separator, string tags)
		{
			if (!string.IsNullOrEmpty(Text))
			{
				Text = Text.Replace("\\n", "\n");
				if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
				{
					Text = Text.Replace("\"", "\"\"");
					Builder.AppendFormat("\"{0}{1}\"", tags, Text);
				}
				else
				{
					Builder.Append(tags);
					Builder.Append(Text);
				}
			}
		}

		public UnityWebRequest Export_Google_CreateWWWcall(eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			string value = Export_Google_CreateData();
			WWWForm wWWForm = new WWWForm();
			wWWForm.AddField("key", Google_SpreadsheetKey);
			wWWForm.AddField("action", "SetLanguageSource");
			wWWForm.AddField("data", value);
			wWWForm.AddField("updateMode", UpdateMode.ToString());
			UnityWebRequest unityWebRequest = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(this), wWWForm);
			I2Utils.SendWebRequest(unityWebRequest);
			return unityWebRequest;
		}

		private string Export_Google_CreateData()
		{
			List<string> categories = GetCategories(OnlyMainCategory: true);
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = true;
			foreach (string item in categories)
			{
				if (flag)
				{
					flag = false;
				}
				else
				{
					stringBuilder.Append("<I2Loc>");
				}
				bool specializationsAsRows = true;
				string value = Export_I2CSV(item, ',', specializationsAsRows);
				stringBuilder.Append(item);
				stringBuilder.Append("<I2Loc>");
				stringBuilder.Append(value);
			}
			return stringBuilder.ToString();
		}

		public string Import_CSV(string Category, string CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace, char Separator = ',')
		{
			List<string[]> cSV = LocalizationReader.ReadCSV(CSVstring, Separator);
			return Import_CSV(Category, cSV, UpdateMode);
		}

		public string Import_I2CSV(string Category, string I2CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			List<string[]> cSV = LocalizationReader.ReadI2CSV(I2CSVstring);
			return Import_CSV(Category, cSV, UpdateMode);
		}

		public string Import_CSV(string Category, List<string[]> CSV, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
		{
			string[] array = CSV[0];
			int num = 1;
			int num2 = -1;
			int num3 = -1;
			string[] texts = new string[1] { "Key" };
			string[] texts2 = new string[1] { "Type" };
			string[] texts3 = new string[2] { "Desc", "Description" };
			if (array.Length > 1 && ArrayContains(array[0], texts))
			{
				if (UpdateMode == eSpreadsheetUpdateMode.Replace)
				{
					ClearAllData();
				}
				if (array.Length > 2)
				{
					if (ArrayContains(array[1], texts2))
					{
						num2 = 1;
						num = 2;
					}
					if (ArrayContains(array[1], texts3))
					{
						num3 = 1;
						num = 2;
					}
				}
				if (array.Length > 3)
				{
					if (ArrayContains(array[2], texts2))
					{
						num2 = 2;
						num = 3;
					}
					if (ArrayContains(array[2], texts3))
					{
						num3 = 2;
						num = 3;
					}
				}
				int num4 = Mathf.Max(array.Length - num, 0);
				int[] array2 = new int[num4];
				for (int i = 0; i < num4; i++)
				{
					if (string.IsNullOrEmpty(array[i + num]))
					{
						array2[i] = -1;
						continue;
					}
					string text = array[i + num];
					bool flag = true;
					if (text.StartsWith("$"))
					{
						flag = false;
						text = text.Substring(1);
					}
					GoogleLanguages.UnPackCodeFromLanguageName(text, out var Language, out var code);
					int num5 = -1;
					num5 = (string.IsNullOrEmpty(code) ? GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled: false) : GetLanguageIndexFromCode(code));
					if (num5 < 0)
					{
						LanguageData languageData = new LanguageData();
						languageData.Name = Language;
						languageData.Code = code;
						languageData.Flags = (byte)(0u | ((!flag) ? 1u : 0u));
						mLanguages.Add(languageData);
						num5 = mLanguages.Count - 1;
					}
					array2[i] = num5;
				}
				num4 = mLanguages.Count;
				int j = 0;
				for (int count = mTerms.Count; j < count; j++)
				{
					TermData termData = mTerms[j];
					if (termData.Languages.Length < num4)
					{
						Array.Resize(ref termData.Languages, num4);
						Array.Resize(ref termData.Flags, num4);
					}
				}
				int k = 1;
				for (int count2 = CSV.Count; k < count2; k++)
				{
					array = CSV[k];
					string Term = (string.IsNullOrEmpty(Category) ? array[0] : (Category + "/" + array[0]));
					string text2 = null;
					if (Term.EndsWith("]"))
					{
						int num6 = Term.LastIndexOf('[');
						if (num6 > 0)
						{
							text2 = Term.Substring(num6 + 1, Term.Length - num6 - 2);
							if (text2 == "touch")
							{
								text2 = "Touch";
							}
							Term = Term.Remove(num6);
						}
					}
					ValidateFullTerm(ref Term);
					if (string.IsNullOrEmpty(Term))
					{
						continue;
					}
					TermData termData2 = GetTermData(Term);
					if (termData2 == null)
					{
						termData2 = new TermData();
						termData2.Term = Term;
						termData2.Languages = new string[mLanguages.Count];
						termData2.Flags = new byte[mLanguages.Count];
						for (int l = 0; l < mLanguages.Count; l++)
						{
							termData2.Languages[l] = string.Empty;
						}
						mTerms.Add(termData2);
						mDictionary.Add(Term, termData2);
					}
					else if (UpdateMode == eSpreadsheetUpdateMode.AddNewTerms)
					{
						continue;
					}
					if (num2 > 0)
					{
						termData2.TermType = GetTermType(array[num2]);
					}
					if (num3 > 0)
					{
						termData2.Description = array[num3];
					}
					for (int m = 0; m < array2.Length && m < array.Length - num; m++)
					{
						if (string.IsNullOrEmpty(array[m + num]))
						{
							continue;
						}
						int num7 = array2[m];
						if (num7 >= 0)
						{
							string text3 = array[m + num];
							if (text3 == "-")
							{
								text3 = string.Empty;
							}
							else if (text3 == "")
							{
								text3 = null;
							}
							termData2.SetTranslation(num7, text3, text2);
						}
					}
				}
				if (Application.isPlaying)
				{
					SaveLanguages(HasUnloadedLanguages());
				}
				return string.Empty;
			}
			return "Bad Spreadsheet Format.\nFirst columns should be 'Key', 'Type' and 'Desc'";
		}

		private bool ArrayContains(string MainText, params string[] texts)
		{
			int i = 0;
			for (int num = texts.Length; i < num; i++)
			{
				if (MainText.IndexOf(texts[i], StringComparison.OrdinalIgnoreCase) >= 0)
				{
					return true;
				}
			}
			return false;
		}

		public static eTermType GetTermType(string type)
		{
			int i = 0;
			for (int num = 10; i <= num; i++)
			{
				eTermType eTermType2 = (eTermType)i;
				if (string.Equals(eTermType2.ToString(), type, StringComparison.OrdinalIgnoreCase))
				{
					return (eTermType)i;
				}
			}
			return eTermType.Text;
		}

		private void Import_Language_from_Cache(int langIndex, string langData, bool useFallback, bool onlyCurrentSpecialization)
		{
			int num = 0;
			while (num < langData.Length)
			{
				int num2 = langData.IndexOf("[i2t]", num);
				if (num2 < 0)
				{
					num2 = langData.Length;
				}
				int num3 = langData.IndexOf("=", num);
				if (num3 >= num2)
				{
					break;
				}
				string term = langData.Substring(num, num3 - num);
				num = num3 + 1;
				TermData termData = GetTermData(term);
				if (termData != null)
				{
					string text = null;
					if (num != num2)
					{
						text = langData.Substring(num, num2 - num);
						if (text.StartsWith("[i2fb]"))
						{
							text = (useFallback ? text.Substring(6) : null);
						}
						if (onlyCurrentSpecialization && text != null)
						{
							text = SpecializationManager.GetSpecializedText(text);
						}
					}
					termData.Languages[langIndex] = text;
				}
				num = num2 + 5;
			}
		}

		public static void FreeUnusedLanguages()
		{
			LanguageSourceData languageSourceData = LocalizationManager.Sources[0];
			int languageIndex = languageSourceData.GetLanguageIndex(LocalizationManager.CurrentLanguage);
			for (int i = 0; i < languageSourceData.mTerms.Count; i++)
			{
				TermData termData = languageSourceData.mTerms[i];
				for (int j = 0; j < termData.Languages.Length; j++)
				{
					if (j != languageIndex)
					{
						termData.Languages[j] = null;
					}
				}
			}
		}

		public void Import_Google_FromCache()
		{
			if (GoogleUpdateFrequency == eGoogleUpdateFrequency.Never || !I2Utils.IsPlaying())
			{
				return;
			}
			string sourcePlayerPrefName = GetSourcePlayerPrefName();
			string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
			if (string.IsNullOrEmpty(text))
			{
				return;
			}
			if (text.StartsWith("[i2e]", StringComparison.Ordinal))
			{
				text = StringObfucator.Decode(text.Substring(5, text.Length - 5));
			}
			bool flag = false;
			string text2 = Google_LastUpdatedVersion;
			if (PersistentStorage.HasSetting("I2SourceVersion_" + sourcePlayerPrefName))
			{
				text2 = PersistentStorage.GetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, Google_LastUpdatedVersion);
				flag = IsNewerVersion(Google_LastUpdatedVersion, text2);
			}
			if (!flag)
			{
				PersistentStorage.DeleteFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
				PersistentStorage.DeleteSetting("I2SourceVersion_" + sourcePlayerPrefName);
				return;
			}
			if (text2.Length > 19)
			{
				text2 = string.Empty;
			}
			Google_LastUpdatedVersion = text2;
			Import_Google_Result(text, eSpreadsheetUpdateMode.Replace);
		}

		private bool IsNewerVersion(string currentVersion, string newVersion)
		{
			if (string.IsNullOrEmpty(newVersion))
			{
				return false;
			}
			if (string.IsNullOrEmpty(currentVersion))
			{
				return true;
			}
			if (!long.TryParse(newVersion, out var result) || !long.TryParse(currentVersion, out var result2))
			{
				return true;
			}
			return result > result2;
		}

		public void Import_Google(bool ForceUpdate, bool justCheck)
		{
			if ((!ForceUpdate && GoogleUpdateFrequency == eGoogleUpdateFrequency.Never) || !I2Utils.IsPlaying())
			{
				return;
			}
			eGoogleUpdateFrequency googleUpdateFrequency = GoogleUpdateFrequency;
			string sourcePlayerPrefName = GetSourcePlayerPrefName();
			if (!ForceUpdate && googleUpdateFrequency != 0)
			{
				string setting_String = PersistentStorage.GetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, "");
				try
				{
					if (DateTime.TryParse(setting_String, out var result))
					{
						double totalDays = (DateTime.Now - result).TotalDays;
						switch (googleUpdateFrequency)
						{
						case eGoogleUpdateFrequency.Daily:
							if (totalDays < 1.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.Weekly:
							if (totalDays < 8.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.Monthly:
							if (totalDays < 31.0)
							{
								return;
							}
							break;
						case eGoogleUpdateFrequency.OnlyOnce:
							return;
						case eGoogleUpdateFrequency.EveryOtherDay:
							if (totalDays < 2.0)
							{
								return;
							}
							break;
						}
					}
				}
				catch (Exception)
				{
				}
			}
			PersistentStorage.SetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, DateTime.Now.ToString());
			CoroutineManager.Start(Import_Google_Coroutine(justCheck));
		}

		private string GetSourcePlayerPrefName()
		{
			if (owner == null)
			{
				return null;
			}
			string text = (owner as UnityEngine.Object).name;
			if (!string.IsNullOrEmpty(Google_SpreadsheetKey))
			{
				text += Google_SpreadsheetKey;
			}
			if (Array.IndexOf(LocalizationManager.GlobalSources, (owner as UnityEngine.Object).name) >= 0)
			{
				return text;
			}
			return SceneManager.GetActiveScene().name + "_" + text;
		}

		private IEnumerator Import_Google_Coroutine(bool JustCheck)
		{
			UnityWebRequest www = Import_Google_CreateWWWcall(ForceUpdate: false, JustCheck);
			if (www == null)
			{
				yield break;
			}
			while (!www.isDone)
			{
				yield return null;
			}
			if (string.IsNullOrEmpty(www.error))
			{
				byte[] data = www.downloadHandler.data;
				string @string = Encoding.UTF8.GetString(data, 0, data.Length);
				bool flag = string.IsNullOrEmpty(@string) || @string == "\"\"";
				if (JustCheck)
				{
					if (!flag)
					{
						UnityEngine.Debug.LogWarning("Spreadsheet is not up-to-date and Google Live Synchronization is enabled\nWhen playing in the device the Spreadsheet will be downloaded and translations may not behave as what you see in the editor.\nTo fix this, Import or Export replace to Google");
						GoogleLiveSyncIsUptoDate = false;
					}
					yield break;
				}
				if (!flag)
				{
					mDelayedGoogleData = @string;
					switch (GoogleUpdateSynchronization)
					{
					case eGoogleUpdateSynchronization.AsSoonAsDownloaded:
						ApplyDownloadedDataFromGoogle();
						break;
					case eGoogleUpdateSynchronization.OnSceneLoaded:
						SceneManager.sceneLoaded += ApplyDownloadedDataOnSceneLoaded;
						break;
					}
					yield break;
				}
			}
			if (this.Event_OnSourceUpdateFromGoogle != null)
			{
				this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, www.error);
			}
			UnityEngine.Debug.Log("Language Source was up-to-date with Google Spreadsheet");
		}

		private void ApplyDownloadedDataOnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			SceneManager.sceneLoaded -= ApplyDownloadedDataOnSceneLoaded;
			ApplyDownloadedDataFromGoogle();
		}

		public void ApplyDownloadedDataFromGoogle()
		{
			if (string.IsNullOrEmpty(mDelayedGoogleData))
			{
				return;
			}
			if (string.IsNullOrEmpty(Import_Google_Result(mDelayedGoogleData, eSpreadsheetUpdateMode.Replace, saveInPlayerPrefs: true)))
			{
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: true, "");
				}
				LocalizationManager.LocalizeAll(Force: true);
				UnityEngine.Debug.Log("Done Google Sync");
			}
			else
			{
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, "");
				}
				UnityEngine.Debug.Log("Done Google Sync: source was up-to-date");
			}
		}

		public UnityWebRequest Import_Google_CreateWWWcall(bool ForceUpdate, bool justCheck)
		{
			if (!HasGoogleSpreadsheet())
			{
				return null;
			}
			string text = PersistentStorage.GetSetting_String("I2SourceVersion_" + GetSourcePlayerPrefName(), Google_LastUpdatedVersion);
			if (text.Length > 19)
			{
				text = string.Empty;
			}
			if (IsNewerVersion(text, Google_LastUpdatedVersion))
			{
				Google_LastUpdatedVersion = text;
			}
			UnityWebRequest unityWebRequest = UnityWebRequest.Get(string.Format("{0}?key={1}&action=GetLanguageSource&version={2}", LocalizationManager.GetWebServiceURL(this), Google_SpreadsheetKey, ForceUpdate ? "0" : Google_LastUpdatedVersion));
			I2Utils.SendWebRequest(unityWebRequest);
			return unityWebRequest;
		}

		public bool HasGoogleSpreadsheet()
		{
			if (!string.IsNullOrEmpty(Google_WebServiceURL) && !string.IsNullOrEmpty(Google_SpreadsheetKey))
			{
				return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL(this));
			}
			return false;
		}

		public string Import_Google_Result(string JsonString, eSpreadsheetUpdateMode UpdateMode, bool saveInPlayerPrefs = false)
		{
			try
			{
				string empty = string.Empty;
				if (string.IsNullOrEmpty(JsonString) || JsonString == "\"\"")
				{
					return empty;
				}
				int num = JsonString.IndexOf("version=", StringComparison.Ordinal);
				int num2 = JsonString.IndexOf("script_version=", StringComparison.Ordinal);
				if (num < 0 || num2 < 0)
				{
					return "Invalid Response from Google, Most likely the WebService needs to be updated";
				}
				num += "version=".Length;
				num2 += "script_version=".Length;
				string text = JsonString.Substring(num, JsonString.IndexOf(",", num, StringComparison.Ordinal) - num);
				int num3 = int.Parse(JsonString.Substring(num2, JsonString.IndexOf(",", num2, StringComparison.Ordinal) - num2));
				if (text.Length > 19)
				{
					text = string.Empty;
				}
				if (num3 != LocalizationManager.GetRequiredWebServiceVersion())
				{
					return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
				}
				if (saveInPlayerPrefs && !IsNewerVersion(Google_LastUpdatedVersion, text))
				{
					return "LanguageSource is up-to-date";
				}
				if (saveInPlayerPrefs)
				{
					string sourcePlayerPrefName = GetSourcePlayerPrefName();
					PersistentStorage.SaveFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", "[i2e]" + StringObfucator.Encode(JsonString));
					PersistentStorage.SetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, text);
					PersistentStorage.ForceSaveSettings();
				}
				Google_LastUpdatedVersion = text;
				if (UpdateMode == eSpreadsheetUpdateMode.Replace)
				{
					ClearAllData();
				}
				int num4 = JsonString.IndexOf("[i2category]", StringComparison.Ordinal);
				while (num4 > 0)
				{
					num4 += "[i2category]".Length;
					int num5 = JsonString.IndexOf("[/i2category]", num4, StringComparison.Ordinal);
					string category = JsonString.Substring(num4, num5 - num4);
					num5 += "[/i2category]".Length;
					int num6 = JsonString.IndexOf("[/i2csv]", num5, StringComparison.Ordinal);
					string i2CSVstring = JsonString.Substring(num5, num6 - num5);
					num4 = JsonString.IndexOf("[i2category]", num6, StringComparison.Ordinal);
					Import_I2CSV(category, i2CSVstring, UpdateMode);
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						UpdateMode = eSpreadsheetUpdateMode.Merge;
					}
				}
				GoogleLiveSyncIsUptoDate = true;
				if (I2Utils.IsPlaying())
				{
					SaveLanguages(unloadAll: true);
				}
				if (!string.IsNullOrEmpty(empty))
				{
					Editor_SetDirty();
				}
				return empty;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogWarning(ex);
				return ex.ToString();
			}
		}

		public int GetLanguageIndex(string language, bool AllowDiscartingRegion = true, bool SkipDisabled = true)
		{
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if ((!SkipDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Name, language, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return i;
				}
			}
			if (AllowDiscartingRegion)
			{
				int num = -1;
				int num2 = 0;
				int j = 0;
				for (int count2 = mLanguages.Count; j < count2; j++)
				{
					if (!SkipDisabled || mLanguages[j].IsEnabled())
					{
						int commonWordInLanguageNames = GetCommonWordInLanguageNames(mLanguages[j].Name, language);
						if (commonWordInLanguageNames > num2)
						{
							num2 = commonWordInLanguageNames;
							num = j;
						}
					}
				}
				if (num >= 0)
				{
					return num;
				}
			}
			return -1;
		}

		public LanguageData GetLanguageData(string language, bool AllowDiscartingRegion = true)
		{
			int languageIndex = GetLanguageIndex(language, AllowDiscartingRegion, SkipDisabled: false);
			if (languageIndex >= 0)
			{
				return mLanguages[languageIndex];
			}
			return null;
		}

		public bool IsCurrentLanguage(int languageIndex)
		{
			return LocalizationManager.CurrentLanguage == mLanguages[languageIndex].Name;
		}

		public int GetLanguageIndexFromCode(string Code, bool exactMatch = true, bool ignoreDisabled = false)
		{
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if ((!ignoreDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Code, Code, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return i;
				}
			}
			if (!exactMatch)
			{
				int j = 0;
				for (int count2 = mLanguages.Count; j < count2; j++)
				{
					if ((!ignoreDisabled || mLanguages[j].IsEnabled()) && string.Compare(mLanguages[j].Code, 0, Code, 0, 2, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return j;
					}
				}
			}
			return -1;
		}

		public static int GetCommonWordInLanguageNames(string Language1, string Language2)
		{
			if (string.IsNullOrEmpty(Language1) || string.IsNullOrEmpty(Language2))
			{
				return 0;
			}
			char[] separator = "( )-/\\".ToCharArray();
			string[] array = Language1.ToLower().Split(separator);
			string[] array2 = Language2.ToLower().Split(separator);
			int num = 0;
			string[] array3 = array;
			foreach (string value in array3)
			{
				if (!string.IsNullOrEmpty(value) && array2.Contains(value))
				{
					num++;
				}
			}
			array3 = array2;
			foreach (string value2 in array3)
			{
				if (!string.IsNullOrEmpty(value2) && array.Contains(value2))
				{
					num++;
				}
			}
			return num;
		}

		public static bool AreTheSameLanguage(string Language1, string Language2)
		{
			Language1 = GetLanguageWithoutRegion(Language1);
			Language2 = GetLanguageWithoutRegion(Language2);
			return string.Compare(Language1, Language2, StringComparison.OrdinalIgnoreCase) == 0;
		}

		public static string GetLanguageWithoutRegion(string Language)
		{
			int num = Language.IndexOfAny("(/\\[,{".ToCharArray());
			if (num < 0)
			{
				return Language;
			}
			return Language.Substring(0, num).Trim();
		}

		public void AddLanguage(string LanguageName)
		{
			AddLanguage(LanguageName, GoogleLanguages.GetLanguageCode(LanguageName));
		}

		public void AddLanguage(string LanguageName, string LanguageCode)
		{
			if (GetLanguageIndex(LanguageName, AllowDiscartingRegion: false) < 0)
			{
				LanguageData languageData = new LanguageData();
				languageData.Name = LanguageName;
				languageData.Code = LanguageCode;
				mLanguages.Add(languageData);
				int count = mLanguages.Count;
				int i = 0;
				for (int count2 = mTerms.Count; i < count2; i++)
				{
					Array.Resize(ref mTerms[i].Languages, count);
					Array.Resize(ref mTerms[i].Flags, count);
				}
				Editor_SetDirty();
			}
		}

		public void RemoveLanguage(string LanguageName)
		{
			int languageIndex = GetLanguageIndex(LanguageName, AllowDiscartingRegion: false, SkipDisabled: false);
			if (languageIndex < 0)
			{
				return;
			}
			int count = mLanguages.Count;
			int i = 0;
			for (int count2 = mTerms.Count; i < count2; i++)
			{
				for (int j = languageIndex + 1; j < count; j++)
				{
					mTerms[i].Languages[j - 1] = mTerms[i].Languages[j];
					mTerms[i].Flags[j - 1] = mTerms[i].Flags[j];
				}
				Array.Resize(ref mTerms[i].Languages, count - 1);
				Array.Resize(ref mTerms[i].Flags, count - 1);
			}
			mLanguages.RemoveAt(languageIndex);
			Editor_SetDirty();
		}

		public List<string> GetLanguages(bool skipDisabled = true)
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (!skipDisabled || mLanguages[i].IsEnabled())
				{
					list.Add(mLanguages[i].Name);
				}
			}
			return list;
		}

		public List<string> GetLanguagesCode(bool allowRegions = true, bool skipDisabled = true)
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = mLanguages.Count; i < count; i++)
			{
				if (!skipDisabled || mLanguages[i].IsEnabled())
				{
					string text = mLanguages[i].Code;
					if (!allowRegions && text != null && text.Length > 2)
					{
						text = text.Substring(0, 2);
					}
					if (!string.IsNullOrEmpty(text) && !list.Contains(text))
					{
						list.Add(text);
					}
				}
			}
			return list;
		}

		public bool IsLanguageEnabled(string Language)
		{
			int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false);
			if (languageIndex >= 0)
			{
				return mLanguages[languageIndex].IsEnabled();
			}
			return false;
		}

		public void EnableLanguage(string Language, bool bEnabled)
		{
			int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled: false);
			if (languageIndex >= 0)
			{
				mLanguages[languageIndex].SetEnabled(bEnabled);
			}
		}

		public bool AllowUnloadingLanguages()
		{
			return _AllowUnloadingLanguages != eAllowUnloadLanguages.Never;
		}

		private string GetSavedLanguageFileName(int languageIndex)
		{
			if (languageIndex < 0)
			{
				return null;
			}
			return "LangSource_" + GetSourcePlayerPrefName() + "_" + mLanguages[languageIndex].Name + ".loc";
		}

		public void LoadLanguage(int languageIndex, bool UnloadOtherLanguages, bool useFallback, bool onlyCurrentSpecialization, bool forceLoad)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
			{
				return;
			}
			if (languageIndex >= 0 && (forceLoad || !mLanguages[languageIndex].IsLoaded()))
			{
				string savedLanguageFileName = GetSavedLanguageFileName(languageIndex);
				string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Temporal, savedLanguageFileName, logExceptions: false);
				if (!string.IsNullOrEmpty(text))
				{
					Import_Language_from_Cache(languageIndex, text, useFallback, onlyCurrentSpecialization);
					mLanguages[languageIndex].SetLoaded(loaded: true);
				}
			}
			if (!UnloadOtherLanguages || !I2Utils.IsPlaying())
			{
				return;
			}
			for (int i = 0; i < mLanguages.Count; i++)
			{
				if (i != languageIndex)
				{
					UnloadLanguage(i);
				}
			}
		}

		public void LoadAllLanguages(bool forceLoad = false)
		{
			for (int i = 0; i < mLanguages.Count; i++)
			{
				LoadLanguage(i, UnloadOtherLanguages: false, useFallback: false, onlyCurrentSpecialization: false, forceLoad);
			}
		}

		public void UnloadLanguage(int languageIndex)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles() || !I2Utils.IsPlaying() || !mLanguages[languageIndex].IsLoaded() || !mLanguages[languageIndex].CanBeUnloaded() || IsCurrentLanguage(languageIndex) || !PersistentStorage.HasFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(languageIndex)))
			{
				return;
			}
			foreach (TermData mTerm in mTerms)
			{
				mTerm.Languages[languageIndex] = null;
			}
			mLanguages[languageIndex].SetLoaded(loaded: false);
		}

		public void SaveLanguages(bool unloadAll, PersistentStorage.eFileType fileLocation = PersistentStorage.eFileType.Temporal)
		{
			if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
			{
				return;
			}
			for (int i = 0; i < mLanguages.Count; i++)
			{
				string text = Export_Language_to_Cache(i, IsCurrentLanguage(i));
				if (!string.IsNullOrEmpty(text))
				{
					PersistentStorage.SaveFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(i), text);
				}
			}
			if (!unloadAll)
			{
				return;
			}
			for (int j = 0; j < mLanguages.Count; j++)
			{
				if (unloadAll && !IsCurrentLanguage(j))
				{
					UnloadLanguage(j);
				}
			}
		}

		public bool HasUnloadedLanguages()
		{
			for (int i = 0; i < mLanguages.Count; i++)
			{
				if (!mLanguages[i].IsLoaded())
				{
					return true;
				}
			}
			return false;
		}

		public List<string> GetCategories(bool OnlyMainCategory = false, List<string> Categories = null)
		{
			if (Categories == null)
			{
				Categories = new List<string>();
			}
			foreach (TermData mTerm in mTerms)
			{
				string categoryFromFullTerm = GetCategoryFromFullTerm(mTerm.Term, OnlyMainCategory);
				if (!Categories.Contains(categoryFromFullTerm))
				{
					Categories.Add(categoryFromFullTerm);
				}
			}
			Categories.Sort();
			return Categories;
		}

		public static string GetKeyFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num >= 0)
			{
				return FullTerm.Substring(num + 1);
			}
			return FullTerm;
		}

		public static string GetCategoryFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num >= 0)
			{
				return FullTerm.Substring(0, num);
			}
			return EmptyCategory;
		}

		public static void DeserializeFullTerm(string FullTerm, out string Key, out string Category, bool OnlyMainCategory = false)
		{
			int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
			if (num < 0)
			{
				Category = EmptyCategory;
				Key = FullTerm;
			}
			else
			{
				Category = FullTerm.Substring(0, num);
				Key = FullTerm.Substring(num + 1);
			}
		}

		public void UpdateDictionary(bool force = false)
		{
			if (force || mDictionary == null || mDictionary.Count != mTerms.Count)
			{
				StringComparer stringComparer = (CaseInsensitiveTerms ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
				if (mDictionary.Comparer != stringComparer)
				{
					mDictionary = new Dictionary<string, TermData>(stringComparer);
				}
				else
				{
					mDictionary.Clear();
				}
				int i = 0;
				for (int count = mTerms.Count; i < count; i++)
				{
					TermData termData = mTerms[i];
					ValidateFullTerm(ref termData.Term);
					mDictionary[termData.Term] = mTerms[i];
					mTerms[i].Validate();
				}
				if (I2Utils.IsPlaying())
				{
					SaveLanguages(unloadAll: true);
				}
			}
		}

		public string GetTranslation(string term, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
		{
			if (TryGetTranslation(term, out var Translation, overrideLanguage, overrideSpecialization, skipDisabled, allowCategoryMistmatch))
			{
				return Translation;
			}
			return string.Empty;
		}

		public bool TryGetTranslation(string term, out string Translation, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
		{
			int languageIndex = GetLanguageIndex((overrideLanguage == null) ? LocalizationManager.CurrentLanguage : overrideLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
			if (languageIndex >= 0 && (!skipDisabled || mLanguages[languageIndex].IsEnabled()))
			{
				TermData termData = GetTermData(term, allowCategoryMistmatch);
				if (termData != null)
				{
					Translation = termData.GetTranslation(languageIndex, overrideSpecialization, editMode: true);
					if (Translation == "---")
					{
						Translation = string.Empty;
						return true;
					}
					if (!string.IsNullOrEmpty(Translation))
					{
						return true;
					}
					Translation = null;
				}
				if (OnMissingTranslation == MissingTranslationAction.ShowWarning)
				{
					Translation = $"<!-Missing Translation [{term}]-!>";
					return true;
				}
				if (OnMissingTranslation == MissingTranslationAction.Fallback && termData != null)
				{
					return TryGetFallbackTranslation(termData, out Translation, languageIndex, overrideSpecialization, skipDisabled);
				}
				if (OnMissingTranslation == MissingTranslationAction.Empty)
				{
					Translation = string.Empty;
					return true;
				}
				if (OnMissingTranslation == MissingTranslationAction.ShowTerm)
				{
					Translation = term;
					return true;
				}
			}
			Translation = null;
			return false;
		}

		private bool TryGetFallbackTranslation(TermData termData, out string Translation, int langIndex, string overrideSpecialization = null, bool skipDisabled = false)
		{
			string text = mLanguages[langIndex].Code;
			if (!string.IsNullOrEmpty(text))
			{
				if (text.Contains('-'))
				{
					text = text.Substring(0, text.IndexOf('-'));
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (i != langIndex && mLanguages[i].Code.StartsWith(text) && (!skipDisabled || mLanguages[i].IsEnabled()))
					{
						Translation = termData.GetTranslation(i, overrideSpecialization, editMode: true);
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
					}
				}
			}
			for (int j = 0; j < mLanguages.Count; j++)
			{
				if (j != langIndex && (!skipDisabled || mLanguages[j].IsEnabled()) && (text == null || !mLanguages[j].Code.StartsWith(text)))
				{
					Translation = termData.GetTranslation(j, overrideSpecialization, editMode: true);
					if (!string.IsNullOrEmpty(Translation))
					{
						return true;
					}
				}
			}
			Translation = null;
			return false;
		}

		public TermData AddTerm(string term)
		{
			return AddTerm(term, eTermType.Text);
		}

		public TermData GetTermData(string term, bool allowCategoryMistmatch = false)
		{
			if (string.IsNullOrEmpty(term))
			{
				return null;
			}
			if (mDictionary.Count == 0)
			{
				UpdateDictionary();
			}
			if (mDictionary.TryGetValue(term, out var value))
			{
				return value;
			}
			TermData termData = null;
			if (allowCategoryMistmatch)
			{
				string keyFromFullTerm = GetKeyFromFullTerm(term);
				foreach (KeyValuePair<string, TermData> item in mDictionary)
				{
					if (item.Value.IsTerm(keyFromFullTerm, allowCategoryMistmatch: true))
					{
						if (termData != null)
						{
							return null;
						}
						termData = item.Value;
					}
				}
			}
			return termData;
		}

		public bool ContainsTerm(string term)
		{
			return GetTermData(term) != null;
		}

		public List<string> GetTermsList(string Category = null)
		{
			if (mDictionary.Count != mTerms.Count)
			{
				UpdateDictionary();
			}
			if (string.IsNullOrEmpty(Category))
			{
				return new List<string>(mDictionary.Keys);
			}
			List<string> list = new List<string>();
			for (int i = 0; i < mTerms.Count; i++)
			{
				TermData termData = mTerms[i];
				if (GetCategoryFromFullTerm(termData.Term) == Category)
				{
					list.Add(termData.Term);
				}
			}
			return list;
		}

		public TermData AddTerm(string NewTerm, eTermType termType, bool SaveSource = true)
		{
			ValidateFullTerm(ref NewTerm);
			NewTerm = NewTerm.Trim();
			if (mLanguages.Count == 0)
			{
				AddLanguage("English", "en");
			}
			TermData termData = GetTermData(NewTerm);
			if (termData == null)
			{
				termData = new TermData();
				termData.Term = NewTerm;
				termData.TermType = termType;
				termData.Languages = new string[mLanguages.Count];
				termData.Flags = new byte[mLanguages.Count];
				mTerms.Add(termData);
				mDictionary.Add(NewTerm, termData);
			}
			return termData;
		}

		public void RemoveTerm(string term)
		{
			int i = 0;
			for (int count = mTerms.Count; i < count; i++)
			{
				if (mTerms[i].Term == term)
				{
					mTerms.RemoveAt(i);
					mDictionary.Remove(term);
					break;
				}
			}
		}

		public static void ValidateFullTerm(ref string Term)
		{
			Term = Term.Replace('\\', '/');
			Term = Term.Trim();
			if (Term.StartsWith(EmptyCategory, StringComparison.Ordinal) && Term.Length > EmptyCategory.Length && Term[EmptyCategory.Length] == '/')
			{
				Term = Term.Substring(EmptyCategory.Length + 1);
			}
			Term = I2Utils.GetValidTermName(Term, allowCategory: true);
		}
	}
	public enum eSpreadsheetUpdateMode
	{
		None,
		Replace,
		Merge,
		AddNewTerms
	}
	public class LocalizationReader
	{
		public static Dictionary<string, string> ReadTextAsset(TextAsset asset)
		{
			StringReader stringReader = new StringReader(Encoding.UTF8.GetString(asset.bytes, 0, asset.bytes.Length).Replace("\r\n", "\n").Replace("\r", "\n"));
			Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.Ordinal);
			string line;
			while ((line = stringReader.ReadLine()) != null)
			{
				if (TextAsset_ReadLine(line, out var key, out var value, out var _, out var _, out var _) && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
				{
					dictionary[key] = value;
				}
			}
			return dictionary;
		}

		public static bool TextAsset_ReadLine(string line, out string key, out string value, out string category, out string comment, out string termType)
		{
			key = string.Empty;
			category = string.Empty;
			comment = string.Empty;
			termType = string.Empty;
			value = string.Empty;
			int num = line.LastIndexOf("//");
			if (num >= 0)
			{
				comment = line.Substring(num + 2).Trim();
				comment = DecodeString(comment);
				line = line.Substring(0, num);
			}
			int num2 = line.IndexOf("=");
			if (num2 < 0)
			{
				return false;
			}
			key = line.Substring(0, num2).Trim();
			value = line.Substring(num2 + 1).Trim();
			value = value.Replace("\r\n", "\n").Replace("\n", "\\n");
			value = DecodeString(value);
			if (key.Length > 2 && key[0] == '[')
			{
				int num3 = key.IndexOf(']');
				if (num3 >= 0)
				{
					termType = key.Substring(1, num3 - 1);
					key = key.Substring(num3 + 1);
				}
			}
			ValidateFullTerm(ref key);
			return true;
		}

		public static string ReadCSVfile(string Path, Encoding encoding)
		{
			string text = string.Empty;
			using (StreamReader streamReader = new StreamReader(Path, encoding))
			{
				text = streamReader.ReadToEnd();
			}
			text = text.Replace("\r\n", "\n");
			return text.Replace("\r", "\n");
		}

		public static List<string[]> ReadCSV(string Text, char Separator = ',')
		{
			int iStart = 0;
			List<string[]> list = new List<string[]>();
			while (iStart < Text.Length)
			{
				string[] array = ParseCSVline(Text, ref iStart, Separator);
				if (array == null)
				{
					break;
				}
				list.Add(array);
			}
			return list;
		}

		private static string[] ParseCSVline(string Line, ref int iStart, char Separator)
		{
			List<string> list = new List<string>();
			int length = Line.Length;
			int iWordStart = iStart;
			bool flag = false;
			while (iStart < length)
			{
				char c = Line[iStart];
				if (flag)
				{
					if (c == '"')
					{
						if (iStart + 1 >= length || Line[iStart + 1] != '"')
						{
							flag = false;
						}
						else if (iStart + 2 < length && Line[iStart + 2] == '"')
						{
							flag = false;
							iStart += 2;
						}
						else
						{
							iStart++;
						}
					}
				}
				else if (c == '\n' || c == Separator)
				{
					AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
					if (c == '\n')
					{
						iStart++;
						break;
					}
				}
				else if (c == '"')
				{
					flag = true;
				}
				iStart++;
			}
			if (iStart > iWordStart)
			{
				AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
			}
			return list.ToArray();
		}

		private static void AddCSVtoken(ref List<string> list, ref string Line, int iEnd, ref int iWordStart)
		{
			string text = Line.Substring(iWordStart, iEnd - iWordStart);
			iWordStart = iEnd + 1;
			text = text.Replace("\"\"", "\"");
			if (text.Length > 1 && text[0] == '"' && text[text.Length - 1] == '"')
			{
				text = text.Substring(1, text.Length - 2);
			}
			list.Add(text);
		}

		public static List<string[]> ReadI2CSV(string Text)
		{
			string[] separator = new string[1] { "[*]" };
			string[] separator2 = new string[1] { "[ln]" };
			List<string[]> list = new List<string[]>();
			string[] array = Text.Split(separator2, StringSplitOptions.None);
			foreach (string text in array)
			{
				list.Add(text.Split(separator, StringSplitOptions.None));
			}
			return list;
		}

		public static void ValidateFullTerm(ref string Term)
		{
			Term = Term.Replace('\\', '/');
			int num = Term.IndexOf('/');
			if (num >= 0)
			{
				int startIndex;
				while ((startIndex = Term.LastIndexOf('/')) != num)
				{
					Term = Term.Remove(startIndex, 1);
				}
			}
		}

		public static string EncodeString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}
			return str.Replace("\r\n", "<\\n>").Replace("\r", "<\\n>").Replace("\n", "<\\n>");
		}

		public static string DecodeString(string str)
		{
			if (string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}
			return str.Replace("<\\n>", "\r\n");
		}
	}
	[AddComponentMenu("I2/Localization/I2 Localize")]
	public class Localize : MonoBehaviour
	{
		public enum TermModification
		{
			DontModify,
			ToUpper,
			ToLower,
			ToUpperFirst,
			ToTitle
		}

		public string mTerm = string.Empty;

		public string mTermSecondary = string.Empty;

		[NonSerialized]
		public string FinalTerm;

		[NonSerialized]
		public string FinalSecondaryTerm;

		public TermModification PrimaryTermModifier;

		public TermModification SecondaryTermModifier;

		public string TermPrefix;

		public string TermSuffix;

		public bool LocalizeOnAwake = true;

		private string LastLocalizedLanguage;

		public bool IgnoreRTL;

		public int MaxCharactersInRTL;

		public bool IgnoreNumbersInRTL = true;

		public bool CorrectAlignmentForRTL = true;

		public bool AddSpacesToJoinedLanguages;

		public bool AllowLocalizedParameters = true;

		public List<UnityEngine.Object> TranslatedObjects = new List<UnityEngine.Object>();

		[NonSerialized]
		public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		public UnityEvent LocalizeEvent = new UnityEvent();

		public static string MainTranslation;

		public static string SecondaryTranslation;

		public static string CallBackTerm;

		public static string CallBackSecondaryTerm;

		public static Localize CurrentLocalizeComponent;

		public bool AlwaysForceLocalize;

		[SerializeField]
		public EventCallback LocalizeCallBack = new EventCallback();

		public bool mGUI_ShowReferences;

		public bool mGUI_ShowTems = true;

		public bool mGUI_ShowCallback;

		public ILocalizeTarget mLocalizeTarget;

		public string mLocalizeTargetName;

		public string Term
		{
			get
			{
				return mTerm;
			}
			set
			{
				SetTerm(value);
			}
		}

		public string SecondaryTerm
		{
			get
			{
				return mTermSecondary;
			}
			set
			{
				SetTerm(null, value);
			}
		}

		private void Awake()
		{
			UpdateAssetDictionary();
			FindTarget();
			if (LocalizeOnAwake)
			{
				OnLocalize();
			}
		}

		private void OnEnable()
		{
			OnLocalize();
		}

		public bool HasCallback()
		{
			if (LocalizeCallBack.HasCallback())
			{
				return true;
			}
			return LocalizeEvent.GetPersistentEventCount() > 0;
		}

		public void OnLocalize(bool Force = false)
		{
			if ((!Force && (!base.enabled || base.gameObject == null || !base.gameObject.activeInHierarchy)) || string.IsNullOrEmpty(LocalizationManager.CurrentLanguage) || (!AlwaysForceLocalize && !Force && !HasCallback() && LastLocalizedLanguage == LocalizationManager.CurrentLanguage))
			{
				return;
			}
			LastLocalizedLanguage = LocalizationManager.CurrentLanguage;
			if (string.IsNullOrEmpty(FinalTerm) || string.IsNullOrEmpty(FinalSecondaryTerm))
			{
				GetFinalTerms(out FinalTerm, out FinalSecondaryTerm);
			}
			bool flag = I2Utils.IsPlaying() && HasCallback();
			if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(FinalSecondaryTerm))
			{
				return;
			}
			CallBackTerm = FinalTerm;
			CallBackSecondaryTerm = FinalSecondaryTerm;
			MainTranslation = ((string.IsNullOrEmpty(FinalTerm) || FinalTerm == "-") ? null : LocalizationManager.GetTranslation(FinalTerm, FixForRTL: false));
			SecondaryTranslation = ((string.IsNullOrEmpty(FinalSecondaryTerm) || FinalSecondaryTerm == "-") ? null : LocalizationManager.GetTranslation(FinalSecondaryTerm, FixForRTL: false));
			if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(SecondaryTranslation))
			{
				return;
			}
			CurrentLocalizeComponent = this;
			LocalizeCallBack.Execute(this);
			LocalizeEvent.Invoke();
			LocalizationManager.ApplyLocalizationParams(ref MainTranslation, base.gameObject, AllowLocalizedParameters);
			if (!FindTarget())
			{
				return;
			}
			bool flag2 = LocalizationManager.IsRight2Left && !IgnoreRTL;
			if (MainTranslation != null)
			{
				switch (PrimaryTermModifier)
				{
				case TermModification.ToUpper:
					MainTranslation = MainTranslation.ToUpper();
					break;
				case TermModification.ToLower:
					MainTranslation = MainTranslation.ToLower();
					break;
				case TermModification.ToUpperFirst:
					MainTranslation = GoogleTranslation.UppercaseFirst(MainTranslation);
					break;
				case TermModification.ToTitle:
					MainTranslation = GoogleTranslation.TitleCase(MainTranslation);
					break;
				}
				if (!string.IsNullOrEmpty(TermPrefix))
				{
					MainTranslation = (flag2 ? (MainTranslation + TermPrefix) : (TermPrefix + MainTranslation));
				}
				if (!string.IsNullOrEmpty(TermSuffix))
				{
					MainTranslation = (flag2 ? (TermSuffix + MainTranslation) : (MainTranslation + TermSuffix));
				}
				if (AddSpacesToJoinedLanguages && LocalizationManager.HasJoinedWords && !string.IsNullOrEmpty(MainTranslation))
				{
					StringBuilder stringBuilder = new StringBuilder();
					stringBuilder.Append(MainTranslation[0]);
					int i = 1;
					for (int length = MainTranslation.Length; i < length; i++)
					{
						stringBuilder.Append(' ');
						stringBuilder.Append(MainTranslation[i]);
					}
					MainTranslation = stringBuilder.ToString();
				}
				if (flag2 && mLocalizeTarget.AllowMainTermToBeRTL() && !string.IsNullOrEmpty(MainTranslation))
				{
					MainTranslation = LocalizationManager.ApplyRTLfix(MainTranslation, MaxCharactersInRTL, IgnoreNumbersInRTL);
				}
			}
			if (SecondaryTranslation != null)
			{
				switch (SecondaryTermModifier)
				{
				case TermModification.ToUpper:
					SecondaryTranslation = SecondaryTranslation.ToUpper();
					break;
				case TermModification.ToLower:
					SecondaryTranslation = SecondaryTranslation.ToLower();
					break;
				case TermModification.ToUpperFirst:
					SecondaryTranslation = GoogleTranslation.UppercaseFirst(SecondaryTranslation);
					break;
				case TermModification.ToTitle:
					SecondaryTranslation = GoogleTranslation.TitleCase(SecondaryTranslation);
					break;
				}
				if (flag2 && mLocalizeTarget.AllowSecondTermToBeRTL() && !string.IsNullOrEmpty(SecondaryTranslation))
				{
					SecondaryTranslation = LocalizationManager.ApplyRTLfix(SecondaryTranslation);
				}
			}
			if (LocalizationManager.HighlightLocalizedTargets)
			{
				MainTranslation = "LOC:" + FinalTerm;
			}
			mLocalizeTarget.DoLocalize(this, MainTranslation, SecondaryTranslation);
			CurrentLocalizeComponent = null;
		}

		public bool FindTarget()
		{
			if (mLocalizeTarget != null && mLocalizeTarget.IsValid(this))
			{
				return true;
			}
			if (mLocalizeTarget != null)
			{
				UnityEngine.Object.DestroyImmediate(mLocalizeTarget);
				mLocalizeTarget = null;
				mLocalizeTargetName = null;
			}
			if (!string.IsNullOrEmpty(mLocalizeTargetName))
			{
				foreach (ILocalizeTargetDescriptor mLocalizeTarget in LocalizationManager.mLocalizeTargets)
				{
					if (mLocalizeTargetName == mLocalizeTarget.GetTargetType().ToString())
					{
						if (mLocalizeTarget.CanLocalize(this))
						{
							this.mLocalizeTarget = mLocalizeTarget.CreateTarget(this);
						}
						if (this.mLocalizeTarget != null)
						{
							return true;
						}
					}
				}
			}
			foreach (ILocalizeTargetDescriptor mLocalizeTarget2 in LocalizationManager.mLocalizeTargets)
			{
				if (mLocalizeTarget2.CanLocalize(this))
				{
					this.mLocalizeTarget = mLocalizeTarget2.CreateTarget(this);
					mLocalizeTargetName = mLocalizeTarget2.GetTargetType().ToString();
					if (this.mLocalizeTarget != null)
					{
						return true;
					}
				}
			}
			return false;
		}

		public void GetFinalTerms(out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = string.Empty;
			secondaryTerm = string.Empty;
			if (FindTarget())
			{
				if (mLocalizeTarget != null)
				{
					mLocalizeTarget.GetFinalTerms(this, mTerm, mTermSecondary, out primaryTerm, out secondaryTerm);
					primaryTerm = I2Utils.GetValidTermName(primaryTerm);
				}
				if (!string.IsNullOrEmpty(mTerm))
				{
					primaryTerm = mTerm;
				}
				if (!string.IsNullOrEmpty(mTermSecondary))
				{
					secondaryTerm = mTermSecondary;
				}
				if (primaryTerm != null)
				{
					primaryTerm = primaryTerm.Trim();
				}
				if (secondaryTerm != null)
				{
					secondaryTerm = secondaryTerm.Trim();
				}
			}
		}

		public string GetMainTargetsText()
		{
			string primaryTerm = null;
			string secondaryTerm = null;
			if (mLocalizeTarget != null)
			{
				mLocalizeTarget.GetFinalTerms(this, null, null, out primaryTerm, out secondaryTerm);
			}
			if (!string.IsNullOrEmpty(primaryTerm))
			{
				return primaryTerm;
			}
			return mTerm;
		}

		public void SetFinalTerms(string Main, string Secondary, out string primaryTerm, out string secondaryTerm, bool RemoveNonASCII)
		{
			primaryTerm = (RemoveNonASCII ? I2Utils.GetValidTermName(Main) : Main);
			secondaryTerm = Secondary;
		}

		public void SetTerm(string primary)
		{
			if (!string.IsNullOrEmpty(primary))
			{
				FinalTerm = (mTerm = primary);
			}
			OnLocalize(Force: true);
		}

		public void SetTerm(string primary, string secondary)
		{
			if (!string.IsNullOrEmpty(primary))
			{
				FinalTerm = (mTerm = primary);
			}
			FinalSecondaryTerm = (mTermSecondary = secondary);
			OnLocalize(Force: true);
		}

		internal T GetSecondaryTranslatedObj<T>(ref string mainTranslation, ref string secondaryTranslation) where T : UnityEngine.Object
		{
			DeserializeTranslation(mainTranslation, out var value, out var secondary);
			T val = null;
			if (!string.IsNullOrEmpty(secondary))
			{
				val = GetObject<T>(secondary);
				if (val != null)
				{
					mainTranslation = value;
					secondaryTranslation = secondary;
				}
			}
			if (val == null)
			{
				val = GetObject<T>(secondaryTranslation);
			}
			return val;
		}

		public void UpdateAssetDictionary()
		{
			TranslatedObjects.RemoveAll((UnityEngine.Object x) => x == null);
			mAssetDictionary = (from o in TranslatedObjects.Distinct()
				group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
		}

		internal T GetObject<T>(string Translation) where T : UnityEngine.Object
		{
			if (string.IsNullOrEmpty(Translation))
			{
				return null;
			}
			return GetTranslatedObject<T>(Translation);
		}

		private T GetTranslatedObject<T>(string Translation) where T : UnityEngine.Object
		{
			return FindTranslatedObject<T>(Translation);
		}

		private void DeserializeTranslation(string translation, out string value, out string secondary)
		{
			if (!string.IsNullOrEmpty(translation) && translation.Length > 1 && translation[0] == '[')
			{
				int num = translation.IndexOf(']');
				if (num > 0)
				{
					secondary = translation.Substring(1, num - 1);
					value = translation.Substring(num + 1);
					return;
				}
			}
			value = translation;
			secondary = string.Empty;
		}

		public T FindTranslatedObject<T>(string value) where T : UnityEngine.Object
		{
			if (string.IsNullOrEmpty(value))
			{
				return null;
			}
			if (mAssetDictionary == null || mAssetDictionary.Count != TranslatedObjects.Count)
			{
				UpdateAssetDictionary();
			}
			foreach (KeyValuePair<string, UnityEngine.Object> item in mAssetDictionary)
			{
				if (item.Value is T && value.EndsWith(item.Key, StringComparison.OrdinalIgnoreCase) && string.Compare(value, item.Key, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return (T)item.Value;
				}
			}
			T val = LocalizationManager.FindAsset(value) as T;
			if ((bool)val)
			{
				return val;
			}
			return ResourceManager.pInstance.GetAsset<T>(value);
		}

		public bool HasTranslatedObject(UnityEngine.Object Obj)
		{
			if (TranslatedObjects.Contains(Obj))
			{
				return true;
			}
			return ResourceManager.pInstance.HasAsset(Obj);
		}

		public void AddTranslatedObject(UnityEngine.Object Obj)
		{
			if (!TranslatedObjects.Contains(Obj))
			{
				TranslatedObjects.Add(Obj);
				UpdateAssetDictionary();
			}
		}

		public void SetGlobalLanguage(string Language)
		{
			LocalizationManager.CurrentLanguage = Language;
		}
	}
	[AddComponentMenu("I2/Localization/Localize Dropdown")]
	public class LocalizeDropdown : MonoBehaviour
	{
		public List<string> _Terms = new List<string>();

		public void Start()
		{
			LocalizationManager.OnLocalizeEvent += OnLocalize;
			OnLocalize();
		}

		public void OnDestroy()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
		}

		private void OnEnable()
		{
			if (_Terms.Count == 0)
			{
				FillValues();
			}
			OnLocalize();
		}

		public void OnLocalize()
		{
			if (base.enabled && !(base.gameObject == null) && base.gameObject.activeInHierarchy && !string.IsNullOrEmpty(LocalizationManager.CurrentLanguage))
			{
				UpdateLocalization();
			}
		}

		private void FillValues()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (component == null && I2Utils.IsPlaying())
			{
				FillValuesTMPro();
				return;
			}
			foreach (Dropdown.OptionData option in component.options)
			{
				_Terms.Add(option.text);
			}
		}

		public void UpdateLocalization()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (component == null)
			{
				UpdateLocalizationTMPro();
				return;
			}
			component.options.Clear();
			foreach (string term in _Terms)
			{
				string translation = LocalizationManager.GetTranslation(term);
				component.options.Add(new Dropdown.OptionData(translation));
			}
			component.RefreshShownValue();
		}

		public void UpdateLocalizationTMPro()
		{
			TMP_Dropdown component = GetComponent<TMP_Dropdown>();
			if (component == null)
			{
				return;
			}
			component.options.Clear();
			foreach (string term in _Terms)
			{
				string translation = LocalizationManager.GetTranslation(term);
				component.options.Add(new TMP_Dropdown.OptionData(translation));
			}
			component.RefreshShownValue();
		}

		private void FillValuesTMPro()
		{
			TMP_Dropdown component = GetComponent<TMP_Dropdown>();
			if (component == null)
			{
				return;
			}
			foreach (TMP_Dropdown.OptionData option in component.options)
			{
				_Terms.Add(option.text);
			}
		}
	}
	public static class LocalizationManager
	{
		public delegate object _GetParam(string param);

		public delegate void OnLocalizeCallback();

		private static string mCurrentLanguage;

		private static string mLanguageCode;

		private static CultureInfo mCurrentCulture;

		private static bool mChangeCultureInfo = false;

		public static bool IsRight2Left = false;

		public static bool HasJoinedWords = false;

		public static List<ILocalizationParamsManager> ParamManagers = new List<ILocalizationParamsManager>();

		private static string[] LanguagesRTL = new string[21]
		{
			"ar-DZ", "ar", "ar-BH", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA",
			"ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-AE", "ar-YE", "fa", "he", "ur",
			"ji"
		};

		public static List<LanguageSourceData> Sources = new List<LanguageSourceData>();

		public static string[] GlobalSources = new string[1] { "I2Languages" };

		private static string mCurrentDeviceLanguage;

		public static List<ILocalizeTargetDescriptor> mLocalizeTargets = new List<ILocalizeTargetDescriptor>();

		private static bool mLocalizeIsScheduled = false;

		private static bool mLocalizeIsScheduledWithForcedValue = false;

		public static bool HighlightLocalizedTargets = false;

		public static string CurrentLanguage
		{
			get
			{
				InitializeIfNeeded();
				return mCurrentLanguage;
			}
			set
			{
				InitializeIfNeeded();
				string supportedLanguage = GetSupportedLanguage(value);
				if (!string.IsNullOrEmpty(supportedLanguage) && mCurrentLanguage != supportedLanguage)
				{
					SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage));
				}
			}
		}

		public static string CurrentLanguageCode
		{
			get
			{
				InitializeIfNeeded();
				return mLanguageCode;
			}
			set
			{
				InitializeIfNeeded();
				if (mLanguageCode != value)
				{
					string languageFromCode = GetLanguageFromCode(value);
					if (!string.IsNullOrEmpty(languageFromCode))
					{
						SetLanguageAndCode(languageFromCode, value);
					}
				}
			}
		}

		public static string CurrentRegion
		{
			get
			{
				string currentLanguage = CurrentLanguage;
				int num = currentLanguage.IndexOfAny("/\\".ToCharArray());
				if (num > 0)
				{
					return currentLanguage.Substring(num + 1);
				}
				num = currentLanguage.IndexOfAny("[(".ToCharArray());
				int num2 = currentLanguage.LastIndexOfAny("])".ToCharArray());
				if (num > 0 && num != num2)
				{
					return currentLanguage.Substring(num + 1, num2 - num - 1);
				}
				return string.Empty;
			}
			set
			{
				string text = CurrentLanguage;
				int num = text.IndexOfAny("/\\".ToCharArray());
				if (num > 0)
				{
					CurrentLanguage = text.Substring(num + 1) + value;
					return;
				}
				num = text.IndexOfAny("[(".ToCharArray());
				int num2 = text.LastIndexOfAny("])".ToCharArray());
				if (num > 0 && num != num2)
				{
					text = text.Substring(num);
				}
				CurrentLanguage = text + "(" + value + ")";
			}
		}

		public static string CurrentRegionCode
		{
			get
			{
				string currentLanguageCode = CurrentLanguageCode;
				int num = currentLanguageCode.IndexOfAny(" -_/\\".ToCharArray());
				if (num >= 0)
				{
					return currentLanguageCode.Substring(num + 1);
				}
				return string.Empty;
			}
			set
			{
				string text = CurrentLanguageCode;
				int num = text.IndexOfAny(" -_/\\".ToCharArray());
				if (num > 0)
				{
					text = text.Substring(0, num);
				}
				CurrentLanguageCode = text + "-" + value;
			}
		}

		public static CultureInfo CurrentCulture => mCurrentCulture;

		public static event OnLocalizeCallback OnLocalizeEvent;

		public static void InitializeIfNeeded()
		{
			if (string.IsNullOrEmpty(mCurrentLanguage) || Sources.Count == 0)
			{
				AutoLoadGlobalParamManagers();
				UpdateSources();
				SelectStartupLanguage();
			}
		}

		public static string GetVersion()
		{
			return "2.8.13 f2";
		}

		public static int GetRequiredWebServiceVersion()
		{
			return 5;
		}

		public static string GetWebServiceURL(LanguageSourceData source = null)
		{
			if (source != null && !string.IsNullOrEmpty(source.Google_WebServiceURL))
			{
				return source.Google_WebServiceURL;
			}
			InitializeIfNeeded();
			for (int i = 0; i < Sources.Count; i++)
			{
				if (Sources[i] != null && !string.IsNullOrEmpty(Sources[i].Google_WebServiceURL))
				{
					return Sources[i].Google_WebServiceURL;
				}
			}
			return string.Empty;
		}

		public static void SetLanguageAndCode(string LanguageName, string LanguageCode, bool RememberLanguage = true, bool Force = false)
		{
			if (mCurrentLanguage != LanguageName || mLanguageCode != LanguageCode || Force)
			{
				if (RememberLanguage)
				{
					PersistentStorage.SetSetting_String("I2 Language", LanguageName);
				}
				mCurrentLanguage = LanguageName;
				mLanguageCode = LanguageCode;
				mCurrentCulture = CreateCultureForCode(LanguageCode);
				if (mChangeCultureInfo)
				{
					SetCurrentCultureInfo();
				}
				IsRight2Left = IsRTL(mLanguageCode);
				HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
				LocalizeAll(Force);
			}
		}

		private static CultureInfo CreateCultureForCode(string code)
		{
			try
			{
				return CultureInfo.CreateSpecificCulture(code);
			}
			catch (Exception)
			{
				return CultureInfo.InvariantCulture;
			}
		}

		public static void EnableChangingCultureInfo(bool bEnable)
		{
			if (!mChangeCultureInfo && bEnable)
			{
				SetCurrentCultureInfo();
			}
			mChangeCultureInfo = bEnable;
		}

		private static void SetCurrentCultureInfo()
		{
			Thread.CurrentThread.CurrentCulture = mCurrentCulture;
		}

		private static void SelectStartupLanguage()
		{
			if (Sources.Count == 0)
			{
				return;
			}
			string setting_String = PersistentStorage.GetSetting_String("I2 Language", string.Empty);
			string currentDeviceLanguage = GetCurrentDeviceLanguage();
			if (!string.IsNullOrEmpty(setting_String) && HasLanguage(setting_String, AllowDiscartingRegion: true, Initialize: false))
			{
				SetLanguageAndCode(setting_String, GetLanguageCode(setting_String));
				return;
			}
			if (!Sources[0].IgnoreDeviceLanguage)
			{
				string supportedLanguage = GetSupportedLanguage(currentDeviceLanguage, ignoreDisabled: true);
				if (!string.IsNullOrEmpty(supportedLanguage))
				{
					SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage), RememberLanguage: false);
					return;
				}
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].mLanguages.Count <= 0)
				{
					continue;
				}
				for (int j = 0; j < Sources[i].mLanguages.Count; j++)
				{
					if (Sources[i].mLanguages[j].IsEnabled())
					{
						SetLanguageAndCode(Sources[i].mLanguages[j].Name, Sources[i].mLanguages[j].Code, RememberLanguage: false);
						return;
					}
				}
			}
		}

		public static bool HasLanguage(string Language, bool AllowDiscartingRegion = true, bool Initialize = true, bool SkipDisabled = true)
		{
			if (Initialize)
			{
				InitializeIfNeeded();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled) >= 0)
				{
					return true;
				}
			}
			if (AllowDiscartingRegion)
			{
				int j = 0;
				for (int count2 = Sources.Count; j < count2; j++)
				{
					if (Sources[j].GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled) >= 0)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static string GetSupportedLanguage(string Language, bool ignoreDisabled = false)
		{
			string languageCode = GoogleLanguages.GetLanguageCode(Language);
			if (!string.IsNullOrEmpty(languageCode))
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: true, ignoreDisabled);
					if (languageIndexFromCode >= 0)
					{
						return Sources[i].mLanguages[languageIndexFromCode].Name;
					}
				}
				int j = 0;
				for (int count2 = Sources.Count; j < count2; j++)
				{
					int languageIndexFromCode2 = Sources[j].GetLanguageIndexFromCode(languageCode, exactMatch: false, ignoreDisabled);
					if (languageIndexFromCode2 >= 0)
					{
						return Sources[j].mLanguages[languageIndexFromCode2].Name;
					}
				}
			}
			int k = 0;
			for (int count3 = Sources.Count; k < count3; k++)
			{
				int languageIndex = Sources[k].GetLanguageIndex(Language, AllowDiscartingRegion: false, ignoreDisabled);
				if (languageIndex >= 0)
				{
					return Sources[k].mLanguages[languageIndex].Name;
				}
			}
			int l = 0;
			for (int count4 = Sources.Count; l < count4; l++)
			{
				int languageIndex2 = Sources[l].GetLanguageIndex(Language, AllowDiscartingRegion: true, ignoreDisabled);
				if (languageIndex2 >= 0)
				{
					return Sources[l].mLanguages[languageIndex2].Name;
				}
			}
			return string.Empty;
		}

		public static string GetLanguageCode(string Language)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				int languageIndex = Sources[i].GetLanguageIndex(Language);
				if (languageIndex >= 0)
				{
					return Sources[i].mLanguages[languageIndex].Code;
				}
			}
			return string.Empty;
		}

		public static string GetLanguageFromCode(string Code, bool exactMatch = true)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(Code, exactMatch);
				if (languageIndexFromCode >= 0)
				{
					return Sources[i].mLanguages[languageIndexFromCode].Name;
				}
			}
			return string.Empty;
		}

		public static List<string> GetAllLanguages(bool SkipDisabled = true)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			List<string> Languages = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Languages.AddRange(from x in Sources[i].GetLanguages(SkipDisabled)
					where !Languages.Contains(x)
					select x);
			}
			return Languages;
		}

		public static List<string> GetAllLanguagesCode(bool allowRegions = true, bool SkipDisabled = true)
		{
			List<string> Languages = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Languages.AddRange(from x in Sources[i].GetLanguagesCode(allowRegions, SkipDisabled)
					where !Languages.Contains(x)
					select x);
			}
			return Languages;
		}

		public static bool IsLanguageEnabled(string Language)
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (!Sources[i].IsLanguageEnabled(Language))
				{
					return false;
				}
			}
			return true;
		}

		private static void LoadCurrentLanguage()
		{
			for (int i = 0; i < Sources.Count; i++)
			{
				int languageIndex = Sources[i].GetLanguageIndex(mCurrentLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
				Sources[i].LoadLanguage(languageIndex, UnloadOtherLanguages: true, useFallback: true, onlyCurrentSpecialization: true, forceLoad: false);
			}
		}

		public static void PreviewLanguage(string NewLanguage)
		{
			mCurrentLanguage = NewLanguage;
			mLanguageCode = GetLanguageCode(mCurrentLanguage);
			IsRight2Left = IsRTL(mLanguageCode);
			HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
		}

		public static void AutoLoadGlobalParamManagers()
		{
			LocalizationParamsManager[] array = UnityEngine.Object.FindObjectsOfType<LocalizationParamsManager>();
			foreach (LocalizationParamsManager localizationParamsManager in array)
			{
				if (localizationParamsManager._IsGlobalManager && !ParamManagers.Contains(localizationParamsManager))
				{
					UnityEngine.Debug.Log(localizationParamsManager);
					ParamManagers.Add(localizationParamsManager);
				}
			}
		}

		public static void ApplyLocalizationParams(ref string translation, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, null), allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, GameObject root, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, root), allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, Dictionary<string, object> parameters, bool allowLocalizedParameters = true)
		{
			ApplyLocalizationParams(ref translation, delegate(string p)
			{
				object value = null;
				return parameters.TryGetValue(p, out value) ? value : null;
			}, allowLocalizedParameters);
		}

		public static void ApplyLocalizationParams(ref string translation, _GetParam getParam, bool allowLocalizedParameters = true)
		{
			if (translation == null)
			{
				return;
			}
			string text = null;
			int num = 0;
			int length = translation.Length;
			int num2 = 0;
			while (num2 >= 0 && num2 < translation.Length)
			{
				int num3 = translation.IndexOf("{[", num2);
				if (num3 < 0)
				{
					break;
				}
				int num4 = translation.IndexOf("]}", num3);
				if (num4 < 0)
				{
					break;
				}
				int num5 = translation.IndexOf("{[", num3 + 1);
				if (num5 > 0 && num5 < num4)
				{
					num2 = num5;
					continue;
				}
				int num6 = ((translation[num3 + 2] == '#') ? 3 : 2);
				string param = translation.Substring(num3 + num6, num4 - num3 - num6);
				string text2 = (string)getParam(param);
				if (text2 != null && allowLocalizedParameters)
				{
					LanguageSourceData source;
					TermData termData = GetTermData(text2, out source);
					if (termData != null)
					{
						int languageIndex = source.GetLanguageIndex(CurrentLanguage);
						if (languageIndex >= 0)
						{
							text2 = termData.GetTranslation(languageIndex);
						}
					}
					string oldValue = translation.Substring(num3, num4 - num3 + 2);
					translation = translation.Replace(oldValue, text2);
					int result = 0;
					if (int.TryParse(text2, out result))
					{
						text = GoogleLanguages.GetPluralType(CurrentLanguageCode, result).ToString();
					}
					num2 = num3 + text2.Length;
				}
				else
				{
					num2 = num4 + 2;
				}
			}
			if (text != null)
			{
				string text3 = "[i2p_" + text + "]";
				num = translation.IndexOf(text3, StringComparison.OrdinalIgnoreCase);
				num = ((num >= 0) ? (num + text3.Length) : 0);
				length = translation.IndexOf("[i2p_", num + 1, StringComparison.OrdinalIgnoreCase);
				if (length < 0)
				{
					length = translation.Length;
				}
				translation = translation.Substring(num, length - num);
			}
		}

		internal static string GetLocalizationParam(string ParamName, GameObject root)
		{
			string text = null;
			if ((bool)root)
			{
				MonoBehaviour[] components = root.GetComponents<MonoBehaviour>();
				int i = 0;
				for (int num = components.Length; i < num; i++)
				{
					if (components[i] is ILocalizationParamsManager localizationParamsManager && components[i].enabled)
					{
						text = localizationParamsManager.GetParameterValue(ParamName);
						if (text != null)
						{
							return text;
						}
					}
				}
			}
			int j = 0;
			for (int count = ParamManagers.Count; j < count; j++)
			{
				text = ParamManagers[j].GetParameterValue(ParamName);
				if (text != null)
				{
					return text;
				}
			}
			return null;
		}

		private static string GetPluralType(MatchCollection matches, string langCode, _GetParam getParam)
		{
			int i = 0;
			for (int count = matches.Count; i < count; i++)
			{
				Match match = matches[i];
				string value = match.Groups[match.Groups.Count - 1].Value;
				string text = (string)getParam(value);
				if (text != null)
				{
					int result = 0;
					if (int.TryParse(text, out result))
					{
						return GoogleLanguages.GetPluralType(langCode, result).ToString();
					}
				}
			}
			return null;
		}

		public static string ApplyRTLfix(string line)
		{
			return ApplyRTLfix(line, 0, ignoreNumbers: true);
		}

		public static string ApplyRTLfix(string line, int maxCharacters, bool ignoreNumbers)
		{
			if (string.IsNullOrEmpty(line))
			{
				return line;
			}
			char c = line[0];
			if (c == '!' || c == '.' || c == '?')
			{
				line = line.Substring(1) + c;
			}
			int tagStart = -1;
			int num = 0;
			int num2 = 40000;
			num = 0;
			List<string> list = new List<string>();
			while (I2Utils.FindNextTag(line, num, out tagStart, out num))
			{
				string text = "@@" + (char)(num2 + list.Count) + "@@";
				list.Add(line.Substring(tagStart, num - tagStart + 1));
				line = line.Substring(0, tagStart) + text + line.Substring(num + 1);
				num = tagStart + 5;
			}
			line = line.Replace("\r\n", "\n");
			line = I2Utils.SplitLine(line, maxCharacters);
			line = RTLFixer.Fix(line, showTashkeel: true, !ignoreNumbers);
			for (int i = 0; i < list.Count; i++)
			{
				int length = line.Length;
				for (int j = 0; j < length; j++)
				{
					if (line[j] == '@' && line[j + 1] == '@' && line[j + 2] >= num2 && line[j + 3] == '@' && line[j + 4] == '@')
					{
						int num3 = line[j + 2] - num2;
						num3 = ((num3 % 2 != 0) ? (num3 - 1) : (num3 + 1));
						if (num3 >= list.Count)
						{
							num3 = list.Count - 1;
						}
						line = line.Substring(0, j) + list[num3] + line.Substring(j + 5);
						break;
					}
				}
			}
			return line;
		}

		public static string FixRTL_IfNeeded(string text, int maxCharacters = 0, bool ignoreNumber = false)
		{
			if (IsRight2Left)
			{
				return ApplyRTLfix(text, maxCharacters, ignoreNumber);
			}
			return text;
		}

		public static bool IsRTL(string Code)
		{
			return Array.IndexOf(LanguagesRTL, Code) >= 0;
		}

		public static bool UpdateSources()
		{
			UnregisterDeletededSources();
			RegisterSourceInResources();
			RegisterSceneSources();
			return Sources.Count > 0;
		}

		private static void UnregisterDeletededSources()
		{
			for (int num = Sources.Count - 1; num >= 0; num--)
			{
				if (Sources[num] == null)
				{
					RemoveSource(Sources[num]);
				}
			}
		}

		private static void RegisterSceneSources()
		{
			LanguageSource[] array = (LanguageSource[])Resources.FindObjectsOfTypeAll(typeof(LanguageSource));
			foreach (LanguageSource languageSource in array)
			{
				if (!Sources.Contains(languageSource.mSource))
				{
					if (languageSource.mSource.owner == null)
					{
						languageSource.mSource.owner = languageSource;
					}
					AddSource(languageSource.mSource);
				}
			}
		}

		private static void RegisterSourceInResources()
		{
			string[] globalSources = GlobalSources;
			foreach (string name in globalSources)
			{
				LanguageSourceAsset asset = ResourceManager.pInstance.GetAsset<LanguageSourceAsset>(name);
				if ((bool)asset && !Sources.Contains(asset.mSource))
				{
					if (!asset.mSource.mIsGlobalSource)
					{
						asset.mSource.mIsGlobalSource = true;
					}
					asset.mSource.owner = asset;
					AddSource(asset.mSource);
				}
			}
		}

		internal static void AddSource(LanguageSourceData Source)
		{
			if (Sources.Contains(Source))
			{
				return;
			}
			Sources.Add(Source);
			if (Source.HasGoogleSpreadsheet() && Source.GoogleUpdateFrequency != LanguageSourceData.eGoogleUpdateFrequency.Never)
			{
				Source.Import_Google_FromCache();
				bool justCheck = false;
				if (Source.GoogleUpdateDelay > 0f)
				{
					CoroutineManager.Start(Delayed_Import_Google(Source, Source.GoogleUpdateDelay, justCheck));
				}
				else
				{
					Source.Import_Google(ForceUpdate: false, justCheck);
				}
			}
			for (int i = 0; i < Source.mLanguages.Count(); i++)
			{
				Source.mLanguages[i].SetLoaded(loaded: true);
			}
			if (Source.mDictionary.Count == 0)
			{
				Source.UpdateDictionary(force: true);
			}
		}

		private static IEnumerator Delayed_Import_Google(LanguageSourceData source, float delay, bool justCheck)
		{
			yield return new WaitForSeconds(delay);
			source?.Import_Google(ForceUpdate: false, justCheck);
		}

		internal static void RemoveSource(LanguageSourceData Source)
		{
			Sources.Remove(Source);
		}

		public static bool IsGlobalSource(string SourceName)
		{
			return Array.IndexOf(GlobalSources, SourceName) >= 0;
		}

		public static LanguageSourceData GetSourceContaining(string term, bool fallbackToFirst = true)
		{
			if (!string.IsNullOrEmpty(term))
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].GetTermData(term) != null)
					{
						return Sources[i];
					}
				}
			}
			if (!fallbackToFirst || Sources.Count <= 0)
			{
				return null;
			}
			return Sources[0];
		}

		public static UnityEngine.Object FindAsset(string value)
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				UnityEngine.Object @object = Sources[i].FindAsset(value);
				if ((bool)@object)
				{
					return @object;
				}
			}
			return null;
		}

		public static void ApplyDownloadedDataFromGoogle()
		{
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Sources[i].ApplyDownloadedDataFromGoogle();
			}
		}

		public static string GetCurrentDeviceLanguage(bool force = false)
		{
			if (force || string.IsNullOrEmpty(mCurrentDeviceLanguage))
			{
				DetectDeviceLanguage();
			}
			return mCurrentDeviceLanguage;
		}

		private static void DetectDeviceLanguage()
		{
			try
			{
				mCurrentDeviceLanguage = new AndroidJavaClass("java/util/Locale").CallStatic<AndroidJavaObject>("getDefault", Array.Empty<object>()).Call<string>("toString", Array.Empty<object>());
				if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
				{
					mCurrentDeviceLanguage = mCurrentDeviceLanguage.Replace('_', '-');
					mCurrentDeviceLanguage = GoogleLanguages.GetLanguageName(mCurrentDeviceLanguage, useParenthesesForRegion: true);
					if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
					{
						return;
					}
				}
			}
			catch (Exception)
			{
			}
			mCurrentDeviceLanguage = Application.systemLanguage.ToString();
			if (mCurrentDeviceLanguage == "ChineseSimplified")
			{
				mCurrentDeviceLanguage = "Chinese (Simplified)";
			}
			if (mCurrentDeviceLanguage == "ChineseTraditional")
			{
				mCurrentDeviceLanguage = "Chinese (Traditional)";
			}
		}

		public static void RegisterTarget(ILocalizeTargetDescriptor desc)
		{
			if (mLocalizeTargets.FindIndex((ILocalizeTargetDescriptor x) => x.Name == desc.Name) != -1)
			{
				return;
			}
			for (int i = 0; i < mLocalizeTargets.Count; i++)
			{
				if (mLocalizeTargets[i].Priority > desc.Priority)
				{
					mLocalizeTargets.Insert(i, desc);
					return;
				}
			}
			mLocalizeTargets.Add(desc);
		}

		public static string GetTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			string Translation = null;
			TryGetTranslation(Term, out Translation, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage);
			return Translation;
		}

		public static string GetTermTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			return GetTranslation(Term, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage);
		}

		public static bool TryGetTranslation(string Term, out string Translation, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null)
		{
			Translation = null;
			if (string.IsNullOrEmpty(Term))
			{
				return false;
			}
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				if (Sources[i].TryGetTranslation(Term, out Translation, overrideLanguage))
				{
					if (applyParameters)
					{
						ApplyLocalizationParams(ref Translation, localParametersRoot);
					}
					if (IsRight2Left && FixForRTL)
					{
						Translation = ApplyRTLfix(Translation, maxLineLengthForRTL, ignoreRTLnumbers);
					}
					return true;
				}
			}
			return false;
		}

		public static T GetTranslatedObject<T>(string AssetName, Localize optionalLocComp = null) where T : UnityEngine.Object
		{
			if (optionalLocComp != null)
			{
				return optionalLocComp.FindTranslatedObject<T>(AssetName);
			}
			T val = FindAsset(AssetName) as T;
			if ((bool)val)
			{
				return val;
			}
			return ResourceManager.pInstance.GetAsset<T>(AssetName);
		}

		public static T GetTranslatedObjectByTermName<T>(string Term, Localize optionalLocComp = null) where T : UnityEngine.Object
		{
			return GetTranslatedObject<T>(GetTranslation(Term, FixForRTL: false));
		}

		public static string GetAppName(string languageCode)
		{
			if (!string.IsNullOrEmpty(languageCode))
			{
				for (int i = 0; i < Sources.Count; i++)
				{
					if (string.IsNullOrEmpty(Sources[i].mTerm_AppName))
					{
						continue;
					}
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: false);
					if (languageIndexFromCode < 0)
					{
						continue;
					}
					TermData termData = Sources[i].GetTermData(Sources[i].mTerm_AppName);
					if (termData != null)
					{
						string translation = termData.GetTranslation(languageIndexFromCode);
						if (!string.IsNullOrEmpty(translation))
						{
							return translation;
						}
					}
				}
			}
			return Application.productName;
		}

		public static void LocalizeAll(bool Force = false)
		{
			LoadCurrentLanguage();
			if (!Application.isPlaying)
			{
				DoLocalizeAll(Force);
				return;
			}
			mLocalizeIsScheduledWithForcedValue |= Force;
			if (!mLocalizeIsScheduled)
			{
				CoroutineManager.Start(Coroutine_LocalizeAll());
			}
		}

		private static IEnumerator Coroutine_LocalizeAll()
		{
			mLocalizeIsScheduled = true;
			yield return null;
			mLocalizeIsScheduled = false;
			bool force = mLocalizeIsScheduledWithForcedValue;
			mLocalizeIsScheduledWithForcedValue = false;
			DoLocalizeAll(force);
		}

		private static void DoLocalizeAll(bool Force = false)
		{
			Localize[] array = (Localize[])Resources.FindObjectsOfTypeAll(typeof(Localize));
			int i = 0;
			for (int num = array.Length; i < num; i++)
			{
				array[i].OnLocalize(Force);
			}
			if (LocalizationManager.OnLocalizeEvent != null)
			{
				LocalizationManager.OnLocalizeEvent();
			}
		}

		public static List<string> GetCategories()
		{
			List<string> list = new List<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				Sources[i].GetCategories(OnlyMainCategory: false, list);
			}
			return list;
		}

		public static List<string> GetTermsList(string Category = null)
		{
			if (Sources.Count == 0)
			{
				UpdateSources();
			}
			if (Sources.Count == 1)
			{
				return Sources[0].GetTermsList(Category);
			}
			HashSet<string> hashSet = new HashSet<string>();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				hashSet.UnionWith(Sources[i].GetTermsList(Category));
			}
			return new List<string>(hashSet);
		}

		public static TermData GetTermData(string term)
		{
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				TermData termData = Sources[i].GetTermData(term);
				if (termData != null)
				{
					return termData;
				}
			}
			return null;
		}

		public static TermData GetTermData(string term, out LanguageSourceData source)
		{
			InitializeIfNeeded();
			int i = 0;
			for (int count = Sources.Count; i < count; i++)
			{
				TermData termData = Sources[i].GetTermData(term);
				if (termData != null)
				{
					source = Sources[i];
					return termData;
				}
			}
			source = null;
			return null;
		}
	}
	public abstract class ILocalizeTarget : ScriptableObject
	{
		public abstract bool IsValid(Localize cmp);

		public abstract void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm);

		public abstract void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation);

		public abstract bool CanUseSecondaryTerm();

		public abstract bool AllowMainTermToBeRTL();

		public abstract bool AllowSecondTermToBeRTL();

		public abstract eTermType GetPrimaryTermType(Localize cmp);

		public abstract eTermType GetSecondaryTermType(Localize cmp);
	}
	public abstract class LocalizeTarget<T> : ILocalizeTarget where T : UnityEngine.Object
	{
		public T mTarget;

		public override bool IsValid(Localize cmp)
		{
			if (mTarget != null)
			{
				UnityEngine.Component component = mTarget as UnityEngine.Component;
				if (component != null && component.gameObject != cmp.gameObject)
				{
					mTarget = null;
				}
			}
			if (mTarget == null)
			{
				mTarget = cmp.GetComponent<T>();
			}
			return mTarget != null;
		}
	}
	public abstract class ILocalizeTargetDescriptor
	{
		public string Name;

		public int Priority;

		public abstract bool CanLocalize(Localize cmp);

		public abstract ILocalizeTarget CreateTarget(Localize cmp);

		public abstract Type GetTargetType();
	}
	public abstract class LocalizeTargetDesc<T> : ILocalizeTargetDescriptor where T : ILocalizeTarget
	{
		public override ILocalizeTarget CreateTarget(Localize cmp)
		{
			return ScriptableObject.CreateInstance<T>();
		}

		public override Type GetTargetType()
		{
			return typeof(T);
		}
	}
	public class LocalizeTargetDesc_Type<T, G> : LocalizeTargetDesc<G> where T : UnityEngine.Object where G : LocalizeTarget<T>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return cmp.GetComponent<T>() != null;
		}

		public override ILocalizeTarget CreateTarget(Localize cmp)
		{
			T component = cmp.GetComponent<T>();
			if (component == null)
			{
				return null;
			}
			G val = ScriptableObject.CreateInstance<G>();
			val.mTarget = component;
			return val;
		}
	}
	public class LocalizeTarget_TextMeshPro_Label : LocalizeTarget<TextMeshPro>
	{
		private TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

		private TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_TextMeshPro_Label()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshPro, LocalizeTarget_TextMeshPro_Label>
			{
				Name = "TextMeshPro Label",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null)
			{
				SetFont(mTarget, secondaryTranslatedObj);
			}
			else
			{
				Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
				{
					if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
					{
						secondaryTranslatedObj = GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
						if (secondaryTranslatedObj != null)
						{
							SetFont(mTarget, secondaryTranslatedObj);
						}
					}
					SetMaterial(mTarget, secondaryTranslatedObj2);
				}
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation == null || !(mTarget.text != mainTranslation))
			{
				return;
			}
			if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
			{
				mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
				if (LocalizationManager.IsRight2Left)
				{
					mainTranslation = I2Utils.ReverseText(mainTranslation);
				}
			}
			mTarget.text = mainTranslation;
		}

		internal static TMP_FontAsset GetTMPFontFromMaterial(Localize cmp, string matName)
		{
			string text = " .\\/-[]()";
			int num = matName.Length - 1;
			while (num > 0)
			{
				while (num > 0 && text.IndexOf(matName[num]) >= 0)
				{
					num--;
				}
				if (num <= 0)
				{
					break;
				}
				string translation = matName.Substring(0, num + 1);
				TMP_FontAsset @object = cmp.GetObject<TMP_FontAsset>(translation);
				if (@object != null)
				{
					return @object;
				}
				while (num > 0 && text.IndexOf(matName[num]) < 0)
				{
					num--;
				}
			}
			return null;
		}

		internal static void InitAlignment_TMPro(bool isRTL, TextAlignmentOptions alignment, out TextAlignmentOptions alignLTR, out TextAlignmentOptions alignRTL)
		{
			alignLTR = (alignRTL = alignment);
			if (isRTL)
			{
				switch (alignment)
				{
				case TextAlignmentOptions.TopRight:
					alignLTR = TextAlignmentOptions.TopLeft;
					break;
				case TextAlignmentOptions.Right:
					alignLTR = TextAlignmentOptions.Left;
					break;
				case TextAlignmentOptions.BottomRight:
					alignLTR = TextAlignmentOptions.BottomLeft;
					break;
				case TextAlignmentOptions.BaselineRight:
					alignLTR = TextAlignmentOptions.BaselineLeft;
					break;
				case TextAlignmentOptions.MidlineRight:
					alignLTR = TextAlignmentOptions.MidlineLeft;
					break;
				case TextAlignmentOptions.CaplineRight:
					alignLTR = TextAlignmentOptions.CaplineLeft;
					break;
				case TextAlignmentOptions.TopLeft:
					alignLTR = TextAlignmentOptions.TopRight;
					break;
				case TextAlignmentOptions.Left:
					alignLTR = TextAlignmentOptions.Right;
					break;
				case TextAlignmentOptions.BottomLeft:
					alignLTR = TextAlignmentOptions.BottomRight;
					break;
				case TextAlignmentOptions.BaselineLeft:
					alignLTR = TextAlignmentOptions.BaselineRight;
					break;
				case TextAlignmentOptions.MidlineLeft:
					alignLTR = TextAlignmentOptions.MidlineRight;
					break;
				case TextAlignmentOptions.CaplineLeft:
					alignLTR = TextAlignmentOptions.CaplineRight;
					break;
				}
			}
			else
			{
				switch (alignment)
				{
				case TextAlignmentOptions.TopRight:
					alignRTL = TextAlignmentOptions.TopLeft;
					break;
				case TextAlignmentOptions.Right:
					alignRTL = TextAlignmentOptions.Left;
					break;
				case TextAlignmentOptions.BottomRight:
					alignRTL = TextAlignmentOptions.BottomLeft;
					break;
				case TextAlignmentOptions.BaselineRight:
					alignRTL = TextAlignmentOptions.BaselineLeft;
					break;
				case TextAlignmentOptions.MidlineRight:
					alignRTL = TextAlignmentOptions.MidlineLeft;
					break;
				case TextAlignmentOptions.CaplineRight:
					alignRTL = TextAlignmentOptions.CaplineLeft;
					break;
				case TextAlignmentOptions.TopLeft:
					alignRTL = TextAlignmentOptions.TopRight;
					break;
				case TextAlignmentOptions.Left:
					alignRTL = TextAlignmentOptions.Right;
					break;
				case TextAlignmentOptions.BottomLeft:
					alignRTL = TextAlignmentOptions.BottomRight;
					break;
				case TextAlignmentOptions.BaselineLeft:
					alignRTL = TextAlignmentOptions.BaselineRight;
					break;
				case TextAlignmentOptions.MidlineLeft:
					alignRTL = TextAlignmentOptions.MidlineRight;
					break;
				case TextAlignmentOptions.CaplineLeft:
					alignRTL = TextAlignmentOptions.CaplineRight;
					break;
				}
			}
		}

		internal static void SetFont(TMP_Text label, TMP_FontAsset newFont)
		{
			if (label.font != newFont)
			{
				label.font = newFont;
			}
			if (label.linkedTextComponent != null)
			{
				SetFont(label.linkedTextComponent, newFont);
			}
		}

		internal static void SetMaterial(TMP_Text label, Material newMat)
		{
			if (label.fontSharedMaterial != newMat)
			{
				label.fontSharedMaterial = newMat;
			}
			if (label.linkedTextComponent != null)
			{
				SetMaterial(label.linkedTextComponent, newMat);
			}
		}
	}
	public class LocalizeTarget_TextMeshPro_UGUI : LocalizeTarget<TextMeshProUGUI>
	{
		public TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

		public TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

		public bool mAlignmentWasRTL;

		public bool mInitializeAlignment = true;

		static LocalizeTarget_TextMeshPro_UGUI()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshProUGUI, LocalizeTarget_TextMeshPro_UGUI>
			{
				Name = "TextMeshPro UGUI",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.TextMeshPFont;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null)
			{
				LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
			}
			else
			{
				Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
				{
					if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
					{
						secondaryTranslatedObj = LocalizeTarget_TextMeshPro_Label.GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
						if (secondaryTranslatedObj != null)
						{
							LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
						}
					}
					LocalizeTarget_TextMeshPro_Label.SetMaterial(mTarget, secondaryTranslatedObj2);
				}
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation == null || !(mTarget.text != mainTranslation))
			{
				return;
			}
			if (mainTranslation != null && cmp.CorrectAlignmentForRTL)
			{
				mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
				if (LocalizationManager.IsRight2Left)
				{
					mainTranslation = I2Utils.ReverseText(mainTranslation);
				}
			}
			mTarget.text = mainTranslation;
		}
	}
	public class LocalizeTarget_UnityStandard_AudioSource : LocalizeTarget<AudioSource>
	{
		static LocalizeTarget_UnityStandard_AudioSource()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<AudioSource, LocalizeTarget_UnityStandard_AudioSource>
			{
				Name = "AudioSource",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.AudioClip;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.clip ? mTarget.clip.name : string.Empty);
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			bool num = (mTarget.isPlaying || mTarget.loop) && Application.isPlaying;
			AudioClip clip = mTarget.clip;
			AudioClip audioClip = cmp.FindTranslatedObject<AudioClip>(mainTranslation);
			if (clip != audioClip)
			{
				mTarget.clip = audioClip;
			}
			if (num && (bool)mTarget.clip)
			{
				mTarget.Play();
			}
		}
	}
	public class LocalizeTargetDesc_Child : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Child>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return cmp.transform.childCount > 1;
		}
	}
	public class LocalizeTarget_UnityStandard_Child : LocalizeTarget<GameObject>
	{
		static LocalizeTarget_UnityStandard_Child()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Child
			{
				Name = "Child",
				Priority = 200
			});
		}

		public override bool IsValid(Localize cmp)
		{
			return cmp.transform.childCount > 1;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.GameObject;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = cmp.name;
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			if (!string.IsNullOrEmpty(mainTranslation))
			{
				Transform transform = cmp.transform;
				string text = mainTranslation;
				int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num >= 0)
				{
					text = text.Substring(num + 1);
				}
				for (int i = 0; i < transform.childCount; i++)
				{
					Transform child = transform.GetChild(i);
					child.gameObject.SetActive(child.name == text);
				}
			}
		}
	}
	public class LocalizeTarget_UnityStandard_MeshRenderer : LocalizeTarget<MeshRenderer>
	{
		static LocalizeTarget_UnityStandard_MeshRenderer()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<MeshRenderer, LocalizeTarget_UnityStandard_MeshRenderer>
			{
				Name = "MeshRenderer",
				Priority = 800
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Mesh;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Material;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			if (mTarget == null)
			{
				primaryTerm = (secondaryTerm = null);
			}
			else
			{
				MeshFilter component = mTarget.GetComponent<MeshFilter>();
				if (component == null || component.sharedMesh == null)
				{
					primaryTerm = null;
				}
				else
				{
					primaryTerm = component.sharedMesh.name;
				}
			}
			if (mTarget == null || mTarget.sharedMaterial == null)
			{
				secondaryTerm = null;
			}
			else
			{
				secondaryTerm = mTarget.sharedMaterial.name;
			}
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Material secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && mTarget.sharedMaterial != secondaryTranslatedObj)
			{
				mTarget.material = secondaryTranslatedObj;
			}
			Mesh mesh = cmp.FindTranslatedObject<Mesh>(mainTranslation);
			MeshFilter component = mTarget.GetComponent<MeshFilter>();
			if (mesh != null && component.sharedMesh != mesh)
			{
				component.mesh = mesh;
			}
		}
	}
	public class LocalizeTargetDesc_Prefab : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Prefab>
	{
		public override bool CanLocalize(Localize cmp)
		{
			return true;
		}
	}
	public class LocalizeTarget_UnityStandard_Prefab : LocalizeTarget<GameObject>
	{
		static LocalizeTarget_UnityStandard_Prefab()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Prefab
			{
				Name = "Prefab",
				Priority = 250
			});
		}

		public override bool IsValid(Localize cmp)
		{
			return true;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.GameObject;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = cmp.name;
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			if (string.IsNullOrEmpty(mainTranslation) || ((bool)mTarget && mTarget.name == mainTranslation))
			{
				return;
			}
			Transform transform = cmp.transform;
			string text = mainTranslation;
			int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
			if (num >= 0)
			{
				text = text.Substring(num + 1);
			}
			Transform transform2 = InstantiateNewPrefab(cmp, mainTranslation);
			if (transform2 == null)
			{
				return;
			}
			transform2.name = text;
			for (int num2 = transform.childCount - 1; num2 >= 0; num2--)
			{
				Transform child = transform.GetChild(num2);
				if (child != transform2)
				{
					UnityEngine.Object.Destroy(child.gameObject);
				}
			}
		}

		private Transform InstantiateNewPrefab(Localize cmp, string mainTranslation)
		{
			GameObject gameObject = cmp.FindTranslatedObject<GameObject>(mainTranslation);
			if (gameObject == null)
			{
				return null;
			}
			GameObject gameObject2 = mTarget;
			mTarget = UnityEngine.Object.Instantiate(gameObject);
			if (mTarget == null)
			{
				return null;
			}
			Transform transform = cmp.transform;
			Transform transform2 = mTarget.transform;
			transform2.SetParent(transform);
			Transform transform3 = (gameObject2 ? gameObject2.transform : transform);
			transform2.rotation = transform3.rotation;
			transform2.position = transform3.position;
			return transform2;
		}
	}
	public class LocalizeTarget_UnityStandard_SpriteRenderer : LocalizeTarget<SpriteRenderer>
	{
		static LocalizeTarget_UnityStandard_SpriteRenderer()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<SpriteRenderer, LocalizeTarget_UnityStandard_SpriteRenderer>
			{
				Name = "SpriteRenderer",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Sprite;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = ((mTarget.sprite != null) ? mTarget.sprite.name : string.Empty);
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Sprite sprite = mTarget.sprite;
			if (sprite == null || sprite.name != mainTranslation)
			{
				mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityStandard_TextMesh : LocalizeTarget<TextMesh>
	{
		private TextAlignment mAlignment_RTL = TextAlignment.Right;

		private TextAlignment mAlignment_LTR;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_UnityStandard_TextMesh()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMesh, LocalizeTarget_UnityStandard_TextMesh>
			{
				Name = "TextMesh",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((string.IsNullOrEmpty(Secondary) && mTarget.font != null) ? mTarget.font.name : null);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && mTarget.font != secondaryTranslatedObj)
			{
				mTarget.font = secondaryTranslatedObj;
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignment_LTR = (mAlignment_RTL = mTarget.alignment);
				if (LocalizationManager.IsRight2Left && mAlignment_RTL == TextAlignment.Right)
				{
					mAlignment_LTR = TextAlignment.Left;
				}
				if (!LocalizationManager.IsRight2Left && mAlignment_LTR == TextAlignment.Left)
				{
					mAlignment_RTL = TextAlignment.Right;
				}
			}
			if (mainTranslation != null && mTarget.text != mainTranslation)
			{
				if (cmp.CorrectAlignmentForRTL && mTarget.alignment != TextAlignment.Center)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				}
				mTarget.font.RequestCharactersInTexture(mainTranslation);
				mTarget.text = mainTranslation;
			}
		}
	}
	public class LocalizeTarget_UnityUI_Image : LocalizeTarget<Image>
	{
		static LocalizeTarget_UnityUI_Image()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Image, LocalizeTarget_UnityUI_Image>
			{
				Name = "Image",
				Priority = 100
			});
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			if (!(mTarget.sprite == null))
			{
				return eTermType.Sprite;
			}
			return eTermType.Texture;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
			if (mTarget.sprite != null && mTarget.sprite.name != primaryTerm)
			{
				primaryTerm = primaryTerm + "." + mTarget.sprite.name;
			}
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Sprite sprite = mTarget.sprite;
			if (sprite == null || sprite.name != mainTranslation)
			{
				mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityUI_RawImage : LocalizeTarget<RawImage>
	{
		static LocalizeTarget_UnityUI_RawImage()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<RawImage, LocalizeTarget_UnityUI_RawImage>
			{
				Name = "RawImage",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Texture;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override bool CanUseSecondaryTerm()
		{
			return false;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return false;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
			secondaryTerm = null;
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Texture texture = mTarget.texture;
			if (texture == null || texture.name != mainTranslation)
			{
				mTarget.texture = cmp.FindTranslatedObject<Texture>(mainTranslation);
			}
		}
	}
	public class LocalizeTarget_UnityUI_Text : LocalizeTarget<Text>
	{
		private TextAnchor mAlignment_RTL = TextAnchor.UpperRight;

		private TextAnchor mAlignment_LTR;

		private bool mAlignmentWasRTL;

		private bool mInitializeAlignment = true;

		static LocalizeTarget_UnityUI_Text()
		{
			AutoRegister();
		}

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void AutoRegister()
		{
			LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Text, LocalizeTarget_UnityUI_Text>
			{
				Name = "Text",
				Priority = 100
			});
		}

		public override eTermType GetPrimaryTermType(Localize cmp)
		{
			return eTermType.Text;
		}

		public override eTermType GetSecondaryTermType(Localize cmp)
		{
			return eTermType.Font;
		}

		public override bool CanUseSecondaryTerm()
		{
			return true;
		}

		public override bool AllowMainTermToBeRTL()
		{
			return true;
		}

		public override bool AllowSecondTermToBeRTL()
		{
			return false;
		}

		public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
		{
			primaryTerm = (mTarget ? mTarget.text : null);
			secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
		}

		public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
		{
			Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
			if (secondaryTranslatedObj != null && secondaryTranslatedObj != mTarget.font)
			{
				mTarget.font = secondaryTranslatedObj;
			}
			if (mInitializeAlignment)
			{
				mInitializeAlignment = false;
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				InitAlignment(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
			}
			else
			{
				InitAlignment(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
				if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
				{
					mAlignment_LTR = alignLTR;
					mAlignment_RTL = alignRTL;
				}
				mAlignmentWasRTL = LocalizationManager.IsRight2Left;
			}
			if (mainTranslation != null && mTarget.text != mainTranslation)
			{
				if (cmp.CorrectAlignmentForRTL)
				{
					mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
				}
				mTarget.text = mainTranslation;
				mTarget.SetVerticesDirty();
			}
		}

		private void InitAlignment(bool isRTL, TextAnchor alignment, out TextAnchor alignLTR, out TextAnchor alignRTL)
		{
			alignLTR = (alignRTL = alignment);
			if (isRTL)
			{
				switch (alignment)
				{
				case TextAnchor.UpperRight:
					alignLTR = TextAnchor.UpperLeft;
					break;
				case TextAnchor.MiddleRight:
					alignLTR = TextAnchor.MiddleLeft;
					break;
				case TextAnchor.LowerRight:
					alignLTR = TextAnchor.LowerLeft;
					break;
				case TextAnchor.UpperLeft:
					alignLTR = TextAnchor.UpperRight;
					break;
				case TextAnchor.MiddleLeft:
					alignLTR = TextAnchor.MiddleRight;
					break;
				case TextAnchor.LowerLeft:
					alignLTR = TextAnchor.LowerRight;
					break;
				case TextAnchor.UpperCenter:
				case TextAnchor.MiddleCenter:
				case TextAnchor.LowerCenter:
					break;
				}
			}
			else
			{
				switch (alignment)
				{
				case TextAnchor.UpperRight:
					alignRTL = TextAnchor.UpperLeft;
					break;
				case TextAnchor.MiddleRight:
					alignRTL = TextAnchor.MiddleLeft;
					break;
				case TextAnchor.LowerRight:
					alignRTL = TextAnchor.LowerLeft;
					break;
				case TextAnchor.UpperLeft:
					alignRTL = TextAnchor.UpperRight;
					break;
				case TextAnchor.MiddleLeft:
					alignRTL = TextAnchor.MiddleRight;
					break;
				case TextAnchor.LowerLeft:
					alignRTL = TextAnchor.LowerRight;
					break;
				case TextAnchor.UpperCenter:
				case TextAnchor.MiddleCenter:
				case TextAnchor.LowerCenter:
					break;
				}
			}
		}
	}
	public enum eTermType
	{
		Text,
		Font,
		Texture,
		AudioClip,
		GameObject,
		Sprite,
		Material,
		Child,
		Mesh,
		TextMeshPFont,
		Object
	}
	public enum TranslationFlag : byte
	{
		Normal = 1,
		AutoTranslated
	}
	[Serializable]
	public class TermData
	{
		public string Term = string.Empty;

		public eTermType TermType;

		[NonSerialized]
		public string Description;

		public string[] Languages = new string[0];

		public byte[] Flags = new byte[0];

		[SerializeField]
		private string[] Languages_Touch;

		public string GetTranslation(int idx, string specialization = null, bool editMode = false)
		{
			string text = Languages[idx];
			if (text != null)
			{
				text = SpecializationManager.GetSpecializedText(text, specialization);
				if (!editMode)
				{
					text = text.Replace("[i2nt]", "").Replace("[/i2nt]", "");
				}
			}
			return text;
		}

		public void SetTranslation(int idx, string translation, string specialization = null)
		{
			Languages[idx] = SpecializationManager.SetSpecializedText(Languages[idx], translation, specialization);
		}

		public void RemoveSpecialization(string specialization)
		{
			for (int i = 0; i < Languages.Length; i++)
			{
				RemoveSpecialization(i, specialization);
			}
		}

		public void RemoveSpecialization(int idx, string specialization)
		{
			string text = Languages[idx];
			if (!(specialization == "Any") && text.Contains("[i2s_" + specialization + "]"))
			{
				Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
				specializations.Remove(specialization);
				Languages[idx] = SpecializationManager.SetSpecializedText(specializations);
			}
		}

		public bool IsAutoTranslated(int idx, bool IsTouch)
		{
			return (Flags[idx] & 2) > 0;
		}

		public void Validate()
		{
			int num = Mathf.Max(Languages.Length, Flags.Length);
			if (Languages.Length != num)
			{
				Array.Resize(ref Languages, num);
			}
			if (Flags.Length != num)
			{
				Array.Resize(ref Flags, num);
			}
			if (Languages_Touch == null)
			{
				return;
			}
			for (int i = 0; i < Mathf.Min(Languages_Touch.Length, num); i++)
			{
				if (string.IsNullOrEmpty(Languages[i]) && !string.IsNullOrEmpty(Languages_Touch[i]))
				{
					Languages[i] = Languages_Touch[i];
					Languages_Touch[i] = null;
				}
			}
			Languages_Touch = null;
		}

		public bool IsTerm(string name, bool allowCategoryMistmatch)
		{
			if (!allowCategoryMistmatch)
			{
				return name == Term;
			}
			return name == LanguageSourceData.GetKeyFromFullTerm(Term);
		}

		public bool HasSpecializations()
		{
			for (int i = 0; i < Languages.Length; i++)
			{
				if (!string.IsNullOrEmpty(Languages[i]) && Languages[i].Contains("[i2s_"))
				{
					return true;
				}
			}
			return false;
		}

		public List<string> GetAllSpecializations()
		{
			List<string> list = new List<string>();
			for (int i = 0; i < Languages.Length; i++)
			{
				SpecializationManager.AppendSpecializations(Languages[i], list);
			}
			return list;
		}
	}
	public class TermsPopup : PropertyAttribute
	{
		public string Filter { get; private set; }

		public TermsPopup(string filter = "")
		{
			Filter = filter;
		}
	}
	public class AutoChangeCultureInfo : MonoBehaviour
	{
		public void Start()
		{
			LocalizationManager.EnableChangingCultureInfo(bEnable: true);
		}
	}
	public class CoroutineManager : MonoBehaviour
	{
		private static CoroutineManager mInstance;

		private static CoroutineManager pInstance
		{
			get
			{
				if (mInstance == null)
				{
					GameObject gameObject = new GameObject("_Coroutiner");
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					mInstance = gameObject.AddComponent<CoroutineManager>();
					if (Application.isPlaying)
					{
						UnityEngine.Object.DontDestroyOnLoad(gameObject);
					}
				}
				return mInstance;
			}
		}

		private void Awake()
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
		}

		public static Coroutine Start(IEnumerator coroutine)
		{
			return pInstance.StartCoroutine(coroutine);
		}
	}
	[AddComponentMenu("I2/Localization/I2 Localize Callback")]
	public class CustomLocalizeCallback : MonoBehaviour
	{
		public UnityEvent _OnLocalize = new UnityEvent();

		public void OnEnable()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
			LocalizationManager.OnLocalizeEvent += OnLocalize;
		}

		public void OnDisable()
		{
			LocalizationManager.OnLocalizeEvent -= OnLocalize;
		}

		public void OnLocalize()
		{
			_OnLocalize.Invoke();
		}
	}
	public class HindiFixer
	{
		internal static string Fix(string text)
		{
			char[] array = text.ToCharArray();
			bool flag = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '\u093f' && !char.IsWhiteSpace(array[i - 1]) && array[i - 1] != 0)
				{
					array[i] = array[i - 1];
					array[i - 1] = '\u093f';
					flag = true;
				}
				if (i != array.Length - 1)
				{
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0943' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0944';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0901' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u093f' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0962';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '\u0940' && array[i + 1] == '\u093c')
					{
						array[i] = '\u0963';
						array[i + 1] = '\0';
						flag = true;
					}
					if (array[i] == '' && array[i + 1] == '\u093c')
					{
						array[i] = '';
						array[i + 1] = '\0';
						flag = true;
					}
				}
			}
			if (!flag)
			{
				return text;
			}
			string text2 = new string(array.Where((char x) => x != '\0').ToArray());
			if (text2 == text)
			{
				return text2;
			}
			text = text2;
			return text;
		}
	}
	public static class I2Utils
	{
		public const string ValidChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

		public const string NumberChars = "0123456789";

		public const string ValidNameSymbols = ".-_$#@*()[]{}+:?!&',^=<>~`";

		public static string ReverseText(string source)
		{
			int length = source.Length;
			char[] array = new char[length];
			for (int i = 0; i < length; i++)
			{
				array[length - 1 - i] = source[i];
			}
			return new string(array);
		}

		public static string RemoveNonASCII(string text, bool allowCategory = false)
		{
			if (string.IsNullOrEmpty(text))
			{
				return text;
			}
			int num = 0;
			char[] array = new char[text.Length];
			bool flag = false;
			char[] array2 = text.Trim().ToCharArray();
			foreach (char c in array2)
			{
				char c2 = ' ';
				if ((allowCategory && (c == '\\' || c == '"' || c == '/')) || char.IsLetterOrDigit(c) || ".-_$#@*()[]{}+:?!&',^=<>~`".IndexOf(c) >= 0)
				{
					c2 = c;
				}
				if (char.IsWhiteSpace(c2))
				{
					if (!flag)
					{
						if (num > 0)
						{
							array[num++] = ' ';
						}
						flag = true;
					}
				}
				else
				{
					flag = false;
					array[num++] = c2;
				}
			}
			return new string(array, 0, num);
		}

		public static string GetValidTermName(string text, bool allowCategory = false)
		{
			if (text == null)
			{
				return null;
			}
			text = RemoveTags(text);
			return RemoveNonASCII(text, allowCategory);
		}

		public static string SplitLine(string line, int maxCharacters)
		{
			if (maxCharacters <= 0 || line.Length < maxCharacters)
			{
				return line;
			}
			char[] array = line.ToCharArray();
			bool flag = true;
			bool flag2 = false;
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				if (flag)
				{
					num++;
					if (array[i] == '\n')
					{
						num = 0;
					}
					if (num >= maxCharacters && char.IsWhiteSpace(array[i]))
					{
						array[i] = '\n';
						flag = false;
						flag2 = false;
					}
				}
				else if (!char.IsWhiteSpace(array[i]))
				{
					flag = true;
					num = 0;
				}
				else if (array[i] != '\n')
				{
					array[i] = '\0';
				}
				else
				{
					if (!flag2)
					{
						array[i] = '\0';
					}
					flag2 = true;
				}
			}
			return new string(array.Where((char c) => c != '\0').ToArray());
		}

		public static bool FindNextTag(string line, int iStart, out int tagStart, out int tagEnd)
		{
			tagStart = -1;
			tagEnd = -1;
			int length = line.Length;
			tagStart = iStart;
			while (tagStart < length && line[tagStart] != '[' && line[tagStart] != '(' && line[tagStart] != '{' && line[tagStart] != '<')
			{
				tagStart++;
			}
			if (tagStart == length)
			{
				return false;
			}
			bool flag = false;
			for (tagEnd = tagStart + 1; tagEnd < length; tagEnd++)
			{
				char c = line[tagEnd];
				if (c == ']' || c == ')' || c == '}' || c == '>')
				{
					if (flag)
					{
						return FindNextTag(line, tagEnd + 1, out tagStart, out tagEnd);
					}
					return true;
				}
				if (c > '')
				{
					flag = true;
				}
			}
			return false;
		}

		public static string RemoveTags(string text)
		{
			return Regex.Replace(text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>", "");
		}

		public static bool RemoveResourcesPath(ref string sPath)
		{
			int num = sPath.IndexOf("\\Resources\\");
			int num2 = sPath.IndexOf("\\Resources/");
			int num3 = sPath.IndexOf("/Resources\\");
			int num4 = sPath.IndexOf("/Resources/");
			int num5 = Mathf.Max(num, num2, num3, num4);
			bool result = false;
			if (num5 >= 0)
			{
				sPath = sPath.Substring(num5 + 11);
				result = true;
			}
			else
			{
				num5 = sPath.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num5 > 0)
				{
					sPath = sPath.Substring(num5 + 1);
				}
			}
			string extension = Path.GetExtension(sPath);
			if (!string.IsNullOrEmpty(extension))
			{
				sPath = sPath.Substring(0, sPath.Length - extension.Length);
			}
			return result;
		}

		public static bool IsPlaying()
		{
			if (Application.isPlaying)
			{
				return true;
			}
			return false;
		}

		public static string GetPath(this Transform tr)
		{
			Transform parent = tr.parent;
			if (tr == null)
			{
				return tr.name;
			}
			return parent.GetPath() + "/" + tr.name;
		}

		public static Transform FindObject(string objectPath)
		{
			return FindObject(SceneManager.GetActiveScene(), objectPath);
		}

		public static Transform FindObject(Scene scene, string objectPath)
		{
			GameObject[] rootGameObjects = scene.GetRootGameObjects();
			for (int i = 0; i < rootGameObjects.Length; i++)
			{
				Transform transform = rootGameObjects[i].transform;
				if (transform.name == objectPath)
				{
					return transform;
				}
				if (objectPath.StartsWith(transform.name + "/"))
				{
					return FindObject(transform, objectPath.Substring(transform.name.Length + 1));
				}
			}
			return null;
		}

		public static Transform FindObject(Transform root, string objectPath)
		{
			for (int i = 0; i < root.childCount; i++)
			{
				Transform child = root.GetChild(i);
				if (child.name == objectPath)
				{
					return child;
				}
				if (objectPath.StartsWith(child.name + "/"))
				{
					return FindObject(child, objectPath.Substring(child.name.Length + 1));
				}
			}
			return null;
		}

		public static H FindInParents<H>(Transform tr) where H : UnityEngine.Component
		{
			if (!tr)
			{
				return null;
			}
			H component = tr.GetComponent<H>();
			while (!component && (bool)tr)
			{
				component = tr.GetComponent<H>();
				tr = tr.parent;
			}
			return component;
		}

		public static string GetCaptureMatch(Match match)
		{
			for (int num = match.Groups.Count - 1; num >= 0; num--)
			{
				if (match.Groups[num].Success)
				{
					return match.Groups[num].ToString();
				}
			}
			return match.ToString();
		}

		public static void SendWebRequest(UnityWebRequest www)
		{
			www.SendWebRequest();
		}
	}
	public interface ILocalizationParamsManager
	{
		string GetParameterValue(string Param);
	}
	public class LocalizationParamsManager : MonoBehaviour, ILocalizationParamsManager
	{
		[Serializable]
		public struct ParamValue
		{
			public string Name;

			public string Value;
		}

		[SerializeField]
		public List<ParamValue> _Params = new List<ParamValue>();

		public bool _IsGlobalManager;

		public string GetParameterValue(string ParamName)
		{
			if (_Params != null)
			{
				int i = 0;
				for (int count = _Params.Count; i < count; i++)
				{
					if (_Params[i].Name == ParamName)
					{
						return _Params[i].Value;
					}
				}
			}
			return null;
		}

		public void SetParameterValue(string ParamName, string ParamValue, bool localize = true)
		{
			bool flag = false;
			int i = 0;
			for (int count = _Params.Count; i < count; i++)
			{
				if (_Params[i].Name == ParamName)
				{
					ParamValue value = _Params[i];
					value.Value = ParamValue;
					_Params[i] = value;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				_Params.Add(new ParamValue
				{
					Name = ParamName,
					Value = ParamValue
				});
			}
			if (localize)
			{
				OnLocalize();
			}
		}

		public void OnLocalize()
		{
			Localize component = GetComponent<Localize>();
			if (component != null)
			{
				component.OnLocalize(Force: true);
			}
		}

		public virtual void OnEnable()
		{
			if (_IsGlobalManager)
			{
				DoAutoRegister();
			}
		}

		public void DoAutoRegister()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
				LocalizationManager.LocalizeAll(Force: true);
			}
		}

		public void OnDisable()
		{
			LocalizationManager.ParamManagers.Remove(this);
		}
	}
	[Serializable]
	public struct LocalizedString
	{
		public string mTerm;

		public bool mRTL_IgnoreArabicFix;

		public int mRTL_MaxLineLength;

		public bool mRTL_ConvertNumbers;

		public bool m_DontLocalizeParameters;

		public static implicit operator string(LocalizedString s)
		{
			return s.ToString();
		}

		public static implicit operator LocalizedString(string term)
		{
			LocalizedString result = default(LocalizedString);
			result.mTerm = term;
			return result;
		}

		public LocalizedString(LocalizedString str)
		{
			mTerm = str.mTerm;
			mRTL_IgnoreArabicFix = str.mRTL_IgnoreArabicFix;
			mRTL_MaxLineLength = str.mRTL_MaxLineLength;
			mRTL_ConvertNumbers = str.mRTL_ConvertNumbers;
			m_DontLocalizeParameters = str.m_DontLocalizeParameters;
		}

		public override string ToString()
		{
			string translation = LocalizationManager.GetTranslation(mTerm, !mRTL_IgnoreArabicFix, mRTL_MaxLineLength, !mRTL_ConvertNumbers, applyParameters: true);
			LocalizationManager.ApplyLocalizationParams(ref translation, !m_DontLocalizeParameters);
			return translation;
		}
	}
	public class RTLFixer
	{
		public static string Fix(string str)
		{
			return Fix(str, showTashkeel: false, useHinduNumbers: true);
		}

		public static string Fix(string str, bool rtl)
		{
			if (rtl)
			{
				return Fix(str);
			}
			string[] array = str.Split(' ');
			string text = "";
			string text2 = "";
			string[] array2 = array;
			foreach (string text3 in array2)
			{
				if (char.IsLower(text3.ToLower()[text3.Length / 2]))
				{
					text = text + Fix(text2) + text3 + " ";
					text2 = "";
				}
				else
				{
					text2 = text2 + text3 + " ";
				}
			}
			if (text2 != "")
			{
				text += Fix(text2);
			}
			return text;
		}

		public static string Fix(string str, bool showTashkeel, bool useHinduNumbers)
		{
			string text = HindiFixer.Fix(str);
			if (text != str)
			{
				return text;
			}
			RTLFixerTool.showTashkeel = showTashkeel;
			RTLFixerTool.useHinduNumbers = useHinduNumbers;
			if (str.Contains("\n"))
			{
				str = str.Replace("\n", Environment.NewLine);
			}
			if (str.Contains(Environment.NewLine))
			{
				string[] separator = new string[1] { Environment.NewLine };
				string[] array = str.Split(separator, StringSplitOptions.None);
				if (array.Length == 0)
				{
					return RTLFixerTool.FixLine(str);
				}
				if (array.Length == 1)
				{
					return RTLFixerTool.FixLine(str);
				}
				string text2 = RTLFixerTool.FixLine(array[0]);
				int i = 1;
				if (array.Length > 1)
				{
					for (; i < array.Length; i++)
					{
						text2 = text2 + Environment.NewLine + RTLFixerTool.FixLine(array[i]);
					}
				}
				return text2;
			}
			return RTLFixerTool.FixLine(str);
		}
	}
	internal enum IsolatedArabicLetters
	{
		Hamza = 65152,
		Alef = 65165,
		AlefHamza = 65155,
		WawHamza = 65157,
		AlefMaksoor = 65159,
		AlefMaksora = 64508,
		HamzaNabera = 65161,
		Ba = 65167,
		Ta = 65173,
		Tha2 = 65177,
		Jeem = 65181,
		H7aa = 65185,
		Khaa2 = 65189,
		Dal = 65193,
		Thal = 65195,
		Ra2 = 65197,
		Zeen = 65199,
		Seen = 65201,
		Sheen = 65205,
		S9a = 65209,
		Dha = 65213,
		T6a = 65217,
		T6ha = 65221,
		Ain = 65225,
		Gain = 65229,
		Fa = 65233,
		Gaf = 65237,
		Kaf = 65241,
		Lam = 65245,
		Meem = 65249,
		Noon = 65253,
		Ha = 65257,
		Waw = 65261,
		Ya = 65265,
		AlefMad = 65153,
		TaMarboota = 65171,
		PersianPe = 64342,
		PersianChe = 64378,
		PersianZe = 64394,
		PersianGaf = 64402,
		PersianGaf2 = 64398
	}
	internal enum GeneralArabicLetters
	{
		Hamza = 1569,
		Alef = 1575,
		AlefHamza = 1571,
		WawHamza = 1572,
		AlefMaksoor = 1573,
		AlefMagsora = 1609,
		HamzaNabera = 1574,
		Ba = 1576,
		Ta = 1578,
		Tha2 = 1579,
		Jeem = 1580,
		H7aa = 1581,
		Khaa2 = 1582,
		Dal = 1583,
		Thal = 1584,
		Ra2 = 1585,
		Zeen = 1586,
		Seen = 1587,
		Sheen = 1588,
		S9a = 1589,
		Dha = 1590,
		T6a = 1591,
		T6ha = 1592,
		Ain = 1593,
		Gain = 1594,
		Fa = 1601,
		Gaf = 1602,
		Kaf = 1603,
		Lam = 1604,
		Meem = 1605,
		Noon = 1606,
		Ha = 1607,
		Waw = 1608,
		Ya = 1610,
		AlefMad = 1570,
		TaMarboota = 1577,
		PersianPe = 1662,
		PersianChe = 1670,
		PersianZe = 1688,
		PersianGaf = 1711,
		PersianGaf2 = 1705
	}
	internal class ArabicMapping
	{
		public int from;

		public int to;

		public ArabicMapping(int from, int to)
		{
			this.from = from;
			this.to = to;
		}
	}
	internal class ArabicTable
	{
		private static List<ArabicMapping> mapList;

		private static ArabicTable arabicMapper;

		internal static ArabicTable ArabicMapper
		{
			get
			{
				if (arabicMapper == null)
				{
					arabicMapper = new ArabicTable();
				}
				return arabicMapper;
			}
		}

		private ArabicTable()
		{
			mapList = new List<ArabicMapping>();
			mapList.Add(new ArabicMapping(1569, 65152));
			mapList.Add(new ArabicMapping(1575, 65165));
			mapList.Add(new ArabicMapping(1571, 65155));
			mapList.Add(new ArabicMapping(1572, 65157));
			mapList.Add(new ArabicMapping(1573, 65159));
			mapList.Add(new ArabicMapping(1609, 64508));
			mapList.Add(new ArabicMapping(1574, 65161));
			mapList.Add(new ArabicMapping(1576, 65167));
			mapList.Add(new ArabicMapping(1578, 65173));
			mapList.Add(new ArabicMapping(1579, 65177));
			mapList.Add(new ArabicMapping(1580, 65181));
			mapList.Add(new ArabicMapping(1581, 65185));
			mapList.Add(new ArabicMapping(1582, 65189));
			mapList.Add(new ArabicMapping(1583, 65193));
			mapList.Add(new ArabicMapping(1584, 65195));
			mapList.Add(new ArabicMapping(1585, 65197));
			mapList.Add(new ArabicMapping(1586, 65199));
			mapList.Add(new ArabicMapping(1587, 65201));
			mapList.Add(new ArabicMapping(1588, 65205));
			mapList.Add(new ArabicMapping(1589, 65209));
			mapList.Add(new ArabicMapping(1590, 65213));
			mapList.Add(new ArabicMapping(1591, 65217));
			mapList.Add(new ArabicMapping(1592, 65221));
			mapList.Add(new ArabicMapping(1593, 65225));
			mapList.Add(new ArabicMapping(1594, 65229));
			mapList.Add(new ArabicMapping(1601, 65233));
			mapList.Add(new ArabicMapping(1602, 65237));
			mapList.Add(new ArabicMapping(1603, 65241));
			mapList.Add(new ArabicMapping(1604, 65245));
			mapList.Add(new ArabicMapping(1605, 65249));
			mapList.Add(new ArabicMapping(1606, 65253));
			mapList.Add(new ArabicMapping(1607, 65257));
			mapList.Add(new ArabicMapping(1608, 65261));
			mapList.Add(new ArabicMapping(1610, 65265));
			mapList.Add(new ArabicMapping(1570, 65153));
			mapList.Add(new ArabicMapping(1577, 65171));
			mapList.Add(new ArabicMapping(1662, 64342));
			mapList.Add(new ArabicMapping(1670, 64378));
			mapList.Add(new ArabicMapping(1688, 64394));
			mapList.Add(new ArabicMapping(1711, 64402));
			mapList.Add(new ArabicMapping(1705, 64398));
		}

		internal int Convert(int toBeConverted)
		{
			foreach (ArabicMapping map in mapList)
			{
				if (map.from == toBeConverted)
				{
					return map.to;
				}
			}
			return toBeConverted;
		}
	}
	internal class TashkeelLocation
	{
		public char tashkeel;

		public int position;

		public TashkeelLocation(char tashkeel, int position)
		{
			this.tashkeel = tashkeel;
			this.position = position;
		}
	}
	internal class RTLFixerTool
	{
		internal static bool showTashkeel = true;

		internal static bool useHinduNumbers = false;

		internal static string RemoveTashkeel(string str, out List<TashkeelLocation> tashkeelLocation)
		{
			tashkeelLocation = new List<TashkeelLocation>();
			char[] array = str.ToCharArray();
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '\u064b')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064b', i));
					num++;
				}
				else if (array[i] == '\u064c')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064c', i));
					num++;
				}
				else if (array[i] == '\u064d')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u064d', i));
					num++;
				}
				else if (array[i] == '\u064e')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = '';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u064e', i));
					num++;
				}
				else if (array[i] == '\u064f')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = '';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u064f', i));
					num++;
				}
				else if (array[i] == '\u0650')
				{
					if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
					{
						tashkeelLocation[num - 1].tashkeel = '';
						continue;
					}
					tashkeelLocation.Add(new TashkeelLocation('\u0650', i));
					num++;
				}
				else if (array[i] == '\u0651')
				{
					if (num > 0)
					{
						if (tashkeelLocation[num - 1].tashkeel == '\u064e')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						if (tashkeelLocation[num - 1].tashkeel == '\u064f')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						if (tashkeelLocation[num - 1].tashkeel == '\u0650')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
					}
					tashkeelLocation.Add(new TashkeelLocation('\u0651', i));
					num++;
				}
				else if (array[i] == '\u0652')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u0652', i));
					num++;
				}
				else if (array[i] == '\u0653')
				{
					tashkeelLocation.Add(new TashkeelLocation('\u0653', i));
					num++;
				}
			}
			string[] array2 = str.Split('\u064b', '\u064c', '\u064d', '\u064e', '\u064f', '\u0650', '\u0651', '\u0652', '\u0653', '', '', '');
			str = "";
			string[] array3 = array2;
			foreach (string text in array3)
			{
				str += text;
			}
			return str;
		}

		internal static char[] ReturnTashkeel(char[] letters, List<TashkeelLocation> tashkeelLocation)
		{
			char[] array = new char[letters.Length + tashkeelLocation.Count];
			int num = 0;
			for (int i = 0; i < letters.Length; i++)
			{
				array[num] = letters[i];
				num++;
				foreach (TashkeelLocation item in tashkeelLocation)
				{
					if (item.position == num)
					{
						array[num] = item.tashkeel;
						num++;
					}
				}
			}
			return array;
		}

		internal static string FixLine(string str)
		{
			string text = "";
			List<TashkeelLocation> tashkeelLocation;
			string text2 = RemoveTashkeel(str, out tashkeelLocation);
			char[] array = text2.ToCharArray();
			char[] array2 = text2.ToCharArray();
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = (char)ArabicTable.ArabicMapper.Convert(array[i]);
			}
			for (int j = 0; j < array.Length; j++)
			{
				bool flag = false;
				if (array[j] == '' && j < array.Length - 1)
				{
					if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
					else if (array[j + 1] == '')
					{
						array[j] = '';
						array2[j + 1] = '\uffff';
						flag = true;
					}
				}
				if (!IsIgnoredCharacter(array[j]))
				{
					if (IsMiddleLetter(array, j))
					{
						array2[j] = (char)(array[j] + 3);
					}
					else if (IsFinishingLetter(array, j))
					{
						array2[j] = (char)(array[j] + 1);
					}
					else if (IsLeadingLetter(array, j))
					{
						array2[j] = (char)(array[j] + 2);
					}
				}
				text = text + Convert.ToString(array[j], 16) + " ";
				if (flag)
				{
					j++;
				}
				if (useHinduNumbers)
				{
					if (array[j] == '0')
					{
						array2[j] = '';
					}
					else if (array[j] == '1')
					{
						array2[j] = '';
					}
					else if (array[j] == '2')
					{
						array2[j] = '';
					}
					else if (array[j] == '3')
					{
						array2[j] = '';
					}
					else if (array[j] == '4')
					{
						array2[j] = '';
					}
					else if (array[j] == '5')
					{
						array2[j] = '';
					}
					else if (array[j] == '6')
					{
						array2[j] = '';
					}
					else if (array[j] == '7')
					{
						array2[j] = '';
					}
					else if (array[j] == '8')
					{
						array2[j] = '';
					}
					else if (array[j] == '9')
					{
						array2[j] = '';
					}
				}
			}
			if (showTashkeel)
			{
				array2 = ReturnTashkeel(array2, tashkeelLocation);
			}
			List<char> list = new List<char>();
			List<char> list2 = new List<char>();
			for (int num = array2.Length - 1; num >= 0; num--)
			{
				if (char.IsPunctuation(array2[num]) && num > 0 && num < array2.Length - 1 && (char.IsPunctuation(array2[num - 1]) || char.IsPunctuation(array2[num + 1])))
				{
					if (array2[num] == '(')
					{
						list.Add(')');
					}
					else if (array2[num] == ')')
					{
						list.Add('(');
					}
					else if (array2[num] == '<')
					{
						list.Add('>');
					}
					else if (array2[num] == '>')
					{
						list.Add('<');
					}
					else if (array2[num] == '[')
					{
						list.Add(']');
					}
					else if (array2[num] == ']')
					{
						list.Add('[');
					}
					else if (array2[num] != '\uffff')
					{
						list.Add(array2[num]);
					}
				}
				else if (array2[num] == ' ' && num > 0 && num < array2.Length - 1 && (char.IsLower(array2[num - 1]) || char.IsUpper(array2[num - 1]) || char.IsNumber(array2[num - 1])) && (char.IsLower(array2[num + 1]) || char.IsUpper(array2[num + 1]) || char.IsNumber(array2[num + 1])))
				{
					list2.Add(array2[num]);
				}
				else if (char.IsNumber(array2[num]) || char.IsLower(array2[num]) || char.IsUpper(array2[num]) || char.IsSymbol(array2[num]) || char.IsPunctuation(array2[num]))
				{
					if (array2[num] == '(')
					{
						list2.Add(')');
					}
					else if (array2[num] == ')')
					{
						list2.Add('(');
					}
					else if (array2[num] == '<')
					{
						list2.Add('>');
					}
					else if (array2[num] == '>')
					{
						list2.Add('<');
					}
					else if (array2[num] == '[')
					{
						list.Add(']');
					}
					else if (array2[num] == ']')
					{
						list.Add('[');
					}
					else
					{
						list2.Add(array2[num]);
					}
				}
				else if ((array2[num] >= '\ud800' && array2[num] <= '\udbff') || (array2[num] >= '\udc00' && array2[num] <= '\udfff'))
				{
					list2.Add(array2[num]);
				}
				else
				{
					if (list2.Count > 0)
					{
						for (int k = 0; k < list2.Count; k++)
						{
							list.Add(list2[list2.Count - 1 - k]);
						}
						list2.Clear();
					}
					if (array2[num] != '\uffff')
					{
						list.Add(array2[num]);
					}
				}
			}
			if (list2.Count > 0)
			{
				for (int l = 0; l < list2.Count; l++)
				{
					list.Add(list2[list2.Count - 1 - l]);
				}
				list2.Clear();
			}
			array2 = new char[list.Count];
			for (int m = 0; m < array2.Length; m++)
			{
				array2[m] = list[m];
			}
			str = new string(array2);
			return str;
		}

		internal static bool IsIgnoredCharacter(char ch)
		{
			bool num = char.IsPunctuation(ch);
			bool flag = char.IsNumber(ch);
			bool flag2 = char.IsLower(ch);
			bool flag3 = char.IsUpper(ch);
			bool flag4 = char.IsSymbol(ch);
			bool flag5 = ch == '' || ch == '' || ch == '' || ch == '' || ch == '';
			bool flag6 = (ch <= '\ufeff' && ch >= '') || flag5 || ch == '';
			if (!(num || flag || flag2 || flag3 || flag4) && flag6 && ch != 'a' && ch != '>' && ch != '<')
			{
				return ch == '';
			}
			return true;
		}

		internal static bool IsLeadingLetter(char[] letters, int index)
		{
			bool num = index == 0 || letters[index - 1] == ' ' || letters[index - 1] == '*' || letters[index - 1] == 'A' || char.IsPunctuation(letters[index - 1]) || letters[index - 1] == '>' || letters[index - 1] == '<' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '';
			bool flag = letters[index] != ' ' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '';
			bool flag2 = index < letters.Length - 1 && letters[index + 1] != ' ' && !char.IsPunctuation(letters[index + 1]) && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsLower(letters[index + 1]) && !char.IsUpper(letters[index + 1]) && letters[index + 1] != '';
			if (num && flag && flag2)
			{
				return true;
			}
			return false;
		}

		internal static bool IsFinishingLetter(char[] letters, int index)
		{
			bool num = index != 0 && letters[index - 1] != ' ' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<';
			bool flag = letters[index] != ' ' && letters[index] != '';
			if (num && flag)
			{
				return true;
			}
			return false;
		}

		internal static bool IsMiddleLetter(char[] letters, int index)
		{
			bool flag = index != 0 && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '';
			bool flag2 = index != 0 && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<' && letters[index - 1] != ' ' && letters[index - 1] != '*';
			if (index < letters.Length - 1 && letters[index + 1] != ' ' && letters[index + 1] != '\r' && letters[index + 1] != '' && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsPunctuation(letters[index + 1]) && flag2 && flag)
			{
				try
				{
					if (char.IsPunctuation(letters[index + 1]))
					{
						return false;
					}
					return true;
				}
				catch
				{
					return false;
				}
			}
			return false;
		}
	}
	public class RegisterGlobalParameters : MonoBehaviour, ILocalizationParamsManager
	{
		public virtual void OnEnable()
		{
			if (!LocalizationManager.ParamManagers.Contains(this))
			{
				LocalizationManager.ParamManagers.Add(this);
				LocalizationManager.LocalizeAll(Force: true);
			}
		}

		public virtual void OnDisable()
		{
			LocalizationManager.ParamManagers.Remove(this);
		}

		public virtual string GetParameterValue(string ParamName)
		{
			return null;
		}
	}
	public interface IResourceManager_Bundles
	{
		UnityEngine.Object LoadFromBundle(string path, Type assetType);
	}
	public class ResourceManager : MonoBehaviour
	{
		private static ResourceManager mInstance;

		public List<IResourceManager_Bundles> mBundleManagers = new List<IResourceManager_Bundles>();

		public UnityEngine.Object[] Assets;

		private readonly Dictionary<string, UnityEngine.Object> mResourcesCache = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

		public static ResourceManager pInstance
		{
			get
			{
				bool flag = mInstance == null;
				if (mInstance == null)
				{
					mInstance = (ResourceManager)UnityEngine.Object.FindObjectOfType(typeof(ResourceManager));
				}
				if (mInstance == null)
				{
					GameObject obj = new GameObject("I2ResourceManager", typeof(ResourceManager));
					obj.hideFlags |= HideFlags.HideAndDontSave;
					mInstance = obj.GetComponent<ResourceManager>();
					SceneManager.sceneLoaded += MyOnLevelWasLoaded;
				}
				if (flag && Application.isPlaying)
				{
					UnityEngine.Object.DontDestroyOnLoad(mInstance.gameObject);
				}
				return mInstance;
			}
		}

		public static void MyOnLevelWasLoaded(Scene scene, LoadSceneMode mode)
		{
			pInstance.CleanResourceCache();
			LocalizationManager.UpdateSources();
		}

		public T GetAsset<T>(string Name) where T : UnityEngine.Object
		{
			T val = FindAsset(Name) as T;
			if (val != null)
			{
				return val;
			}
			return LoadFromResources<T>(Name);
		}

		private UnityEngine.Object FindAsset(string Name)
		{
			if (Assets != null)
			{
				int i = 0;
				for (int num = Assets.Length; i < num; i++)
				{
					if (Assets[i] != null && Assets[i].name == Name)
					{
						return Assets[i];
					}
				}
			}
			return null;
		}

		public bool HasAsset(UnityEngine.Object Obj)
		{
			if (Assets == null)
			{
				return false;
			}
			return Array.IndexOf(Assets, Obj) >= 0;
		}

		public T LoadFromResources<T>(string Path) where T : UnityEngine.Object
		{
			try
			{
				if (string.IsNullOrEmpty(Path))
				{
					return null;
				}
				if (mResourcesCache.TryGetValue(Path, out var value) && value != null)
				{
					return value as T;
				}
				T val = null;
				if (Path.EndsWith("]", StringComparison.OrdinalIgnoreCase))
				{
					int num = Path.LastIndexOf("[", StringComparison.OrdinalIgnoreCase);
					int length = Path.Length - num - 2;
					string value2 = Path.Substring(num + 1, length);
					Path = Path.Substring(0, num);
					T[] array = Resources.LoadAll<T>(Path);
					int i = 0;
					for (int num2 = array.Length; i < num2; i++)
					{
						if (array[i].name.Equals(value2))
						{
							val = array[i];
							break;
						}
					}
				}
				else
				{
					val = Resources.Load(Path, typeof(T)) as T;
				}
				if (val == null)
				{
					val = LoadFromBundle<T>(Path);
				}
				if (val != null)
				{
					mResourcesCache[Path] = val;
				}
				return val;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogErrorFormat("Unable to load {0} '{1}'\nERROR: {2}", typeof(T), Path, ex.ToString());
				return null;
			}
		}

		public T LoadFromBundle<T>(string path) where T : UnityEngine.Object
		{
			int i = 0;
			for (int count = mBundleManagers.Count; i < count; i++)
			{
				if (mBundleManagers[i] != null)
				{
					T val = mBundleManagers[i].LoadFromBundle(path, typeof(T)) as T;
					if (val != null)
					{
						return val;
					}
				}
			}
			return null;
		}

		public void CleanResourceCache()
		{
			mResourcesCache.Clear();
			Resources.UnloadUnusedAssets();
			CancelInvoke();
		}
	}
	[AddComponentMenu("I2/Localization/SetLanguage Button")]
	public class SetLanguage : MonoBehaviour
	{
		public string _Language;

		private void OnClick()
		{
			ApplyLanguage();
		}

		public void ApplyLanguage()
		{
			if (LocalizationManager.HasLanguage(_Language))
			{
				LocalizationManager.CurrentLanguage = _Language;
			}
		}
	}
	[AddComponentMenu("I2/Localization/SetLanguage Dropdown")]
	public class SetLanguageDropdown : MonoBehaviour
	{
		private void OnEnable()
		{
			Dropdown component = GetComponent<Dropdown>();
			if (!(component == null))
			{
				string currentLanguage = LocalizationManager.CurrentLanguage;
				if (LocalizationManager.Sources.Count == 0)
				{
					LocalizationManager.UpdateSources();
				}
				List<string> allLanguages = LocalizationManager.GetAllLanguages();
				component.ClearOptions();
				component.AddOptions(allLanguages);
				component.value = allLanguages.IndexOf(currentLanguage);
				component.onValueChanged.RemoveListener(OnValueChanged);
				component.onValueChanged.AddListener(OnValueChanged);
			}
		}

		private void OnValueChanged(int index)
		{
			Dropdown component = GetComponent<Dropdown>();
			if (index < 0)
			{
				index = 0;
				component.value = index;
			}
			LocalizationManager.CurrentLanguage = component.options[index].text;
		}
	}
	public class StringObfucator
	{
		public static char[] StringObfuscatorPassword = "bUu\u00b8C*4P-@T6DlWuzm4G$=g,QiKEr60t4~^y:d1<QbUu\u00b8C*4P-@T6DlWuzm4G$=g,QiKEr60t4~^y:d".ToCharArray();

		public static string Encode(string NormalString)
		{
			try
			{
				return ToBase64(XoREncode(NormalString));
			}
			catch (Exception)
			{
				return null;
			}
		}

		public static string Decode(string ObfucatedString)
		{
			try
			{
				return XoREncode(FromBase64(ObfucatedString));
			}
			catch (Exception)
			{
				return null;
			}
		}

		private static string ToBase64(string regularString)
		{
			return Convert.ToBase64String(Encoding.UTF8.GetBytes(regularString));
		}

		private static string FromBase64(string base64string)
		{
			byte[] array = Convert.FromBase64String(base64string);
			return Encoding.UTF8.GetString(array, 0, array.Length);
		}

		private static string XoREncode(string NormalString)
		{
			try
			{
				char[] stringObfuscatorPassword = StringObfuscatorPassword;
				char[] array = NormalString.ToCharArray();
				int num = stringObfuscatorPassword.Length;
				int i = 0;
				for (int num2 = array.Length; i < num2; i++)
				{
					array[i] = (char)(array[i] ^ stringObfuscatorPassword[i % num] ^ (byte)((i % 2 == 0) ? (i * 23) : (-i * 51)));
				}
				return new string(array);
			}
			catch (Exception)
			{
				return null;
			}
		}
	}
}
namespace I2.Loc.SimpleJSON
{
	public enum JSONBinaryTag
	{
		Array = 1,
		Class,
		Value,
		IntValue,
		DoubleValue,
		BoolValue,
		FloatValue
	}
	public class JSONNode
	{
		public virtual JSONNode this[int aIndex]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual JSONNode this[string aKey]
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public virtual string Value
		{
			get
			{
				return "";
			}
			set
			{
			}
		}

		public virtual int Count => 0;

		public virtual IEnumerable<JSONNode> Childs
		{
			get
			{
				yield break;
			}
		}

		public IEnumerable<JSONNode> DeepChilds
		{
			get
			{
				foreach (JSONNode child in Childs)
				{
					foreach (JSONNode deepChild in child.DeepChilds)
					{
						yield return deepChild;
					}
				}
			}
		}

		public virtual int AsInt
		{
			get
			{
				int result = 0;
				if (int.TryParse(Value, out result))
				{
					return result;
				}
				return 0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual float AsFloat
		{
			get
			{
				float result = 0f;
				if (float.TryParse(Value, out result))
				{
					return result;
				}
				return 0f;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual double AsDouble
		{
			get
			{
				double result = 0.0;
				if (double.TryParse(Value, out result))
				{
					return result;
				}
				return 0.0;
			}
			set
			{
				Value = value.ToString();
			}
		}

		public virtual bool AsBool
		{
			get
			{
				bool result = false;
				if (bool.TryParse(Value, out result))
				{
					return result;
				}
				return !string.IsNullOrEmpty(Value);
			}
			set
			{
				Value = (value ? "true" : "false");
			}
		}

		public virtual JSONArray AsArray => this as JSONArray;

		public virtual JSONClass AsObject => this as JSONClass;

		public virtual void Add(string aKey, JSONNode aItem)
		{
		}

		public virtual void Add(JSONNode aItem)
		{
			Add("", aItem);
		}

		public virtual JSONNode Remove(string aKey)
		{
			return null;
		}

		public virtual JSONNode Remove(int aIndex)
		{
			return null;
		}

		public virtual JSONNode Remove(JSONNode aNode)
		{
			return aNode;
		}

		public override string ToString()
		{
			return "JSONNode";
		}

		public virtual string ToString(string aPrefix)
		{
			return "JSONNode";
		}

		public static implicit operator JSONNode(string s)
		{
			return new JSONData(s);
		}

		public static implicit operator string(JSONNode d)
		{
			if (!(d == null))
			{
				return d.Value;
			}
			return null;
		}

		public static bool operator ==(JSONNode a, object b)
		{
			if (b == null && a is JSONLazyCreator)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONNode a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal static string Escape(string aText)
		{
			string text = "";
			for (int i = 0; i < aText.Length; i++)
			{
				char c = aText[i];
				text = c switch
				{
					'\\' => text + "\\\\", 
					'"' => text + "\\\"", 
					'\n' => text + "\\n", 
					'\r' => text + "\\r", 
					'\t' => text + "\\t", 
					'\b' => text + "\\b", 
					'\f' => text + "\\f", 
					_ => text + c, 
				};
			}
			return text;
		}

		public static JSONNode Parse(string aJSON)
		{
			Stack<JSONNode> stack = new Stack<JSONNode>();
			JSONNode jSONNode = null;
			int i = 0;
			string text = "";
			string text2 = "";
			bool flag = false;
			for (; i < aJSON.Length; i++)
			{
				switch (aJSON[i])
				{
				case '{':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					stack.Push(new JSONClass());
					if (jSONNode != null)
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(stack.Peek());
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, stack.Peek());
						}
					}
					text2 = "";
					text = "";
					jSONNode = stack.Peek();
					break;
				case '[':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					stack.Push(new JSONArray());
					if (jSONNode != null)
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(stack.Peek());
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, stack.Peek());
						}
					}
					text2 = "";
					text = "";
					jSONNode = stack.Peek();
					break;
				case ']':
				case '}':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					if (stack.Count == 0)
					{
						throw new Exception("JSON Parse: Too many closing brackets");
					}
					stack.Pop();
					if (text != "")
					{
						text2 = text2.Trim();
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(text);
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, text);
						}
					}
					text2 = "";
					text = "";
					if (stack.Count > 0)
					{
						jSONNode = stack.Peek();
					}
					break;
				case ':':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					text2 = text;
					text = "";
					break;
				case '"':
					flag = !flag;
					break;
				case ',':
					if (flag)
					{
						text += aJSON[i];
						break;
					}
					if (text != "")
					{
						if (jSONNode is JSONArray)
						{
							jSONNode.Add(text);
						}
						else if (text2 != "")
						{
							jSONNode.Add(text2, text);
						}
					}
					text2 = "";
					text = "";
					break;
				case '\t':
				case ' ':
					if (flag)
					{
						text += aJSON[i];
					}
					break;
				case '\\':
					i++;
					if (flag)
					{
						char c = aJSON[i];
						switch (c)
						{
						case 't':
							text += "\t";
							break;
						case 'r':
							text += "\r";
							break;
						case 'n':
							text += "\n";
							break;
						case 'b':
							text += "\b";
							break;
						case 'f':
							text += "\f";
							break;
						case 'u':
						{
							string s = aJSON.Substring(i + 1, 4);
							text += (char)int.Parse(s, NumberStyles.AllowHexSpecifier);
							i += 4;
							break;
						}
						default:
							text += c;
							break;
						}
					}
					break;
				default:
					text += aJSON[i];
					break;
				case '\n':
				case '\r':
					break;
				}
			}
			if (flag)
			{
				throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
			}
			return jSONNode;
		}

		public virtual void Serialize(BinaryWriter aWriter)
		{
		}

		public void SaveToStream(Stream aData)
		{
			BinaryWriter aWriter = new BinaryWriter(aData);
			Serialize(aWriter);
		}

		public void SaveToCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public string SaveToCompressedBase64()
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public void SaveToFile(string aFileName)
		{
			Directory.CreateDirectory(new FileInfo(aFileName).Directory.FullName);
			using FileStream aData = File.OpenWrite(aFileName);
			SaveToStream(aData);
		}

		public string SaveToBase64()
		{
			using MemoryStream memoryStream = new MemoryStream();
			SaveToStream(memoryStream);
			memoryStream.Position = 0L;
			return Convert.ToBase64String(memoryStream.ToArray());
		}

		public static JSONNode Deserialize(BinaryReader aReader)
		{
			JSONBinaryTag jSONBinaryTag = (JSONBinaryTag)aReader.ReadByte();
			switch (jSONBinaryTag)
			{
			case JSONBinaryTag.Array:
			{
				int num2 = aReader.ReadInt32();
				JSONArray jSONArray = new JSONArray();
				for (int j = 0; j < num2; j++)
				{
					jSONArray.Add(Deserialize(aReader));
				}
				return jSONArray;
			}
			case JSONBinaryTag.Class:
			{
				int num = aReader.ReadInt32();
				JSONClass jSONClass = new JSONClass();
				for (int i = 0; i < num; i++)
				{
					string aKey = aReader.ReadString();
					JSONNode aItem = Deserialize(aReader);
					jSONClass.Add(aKey, aItem);
				}
				return jSONClass;
			}
			case JSONBinaryTag.Value:
				return new JSONData(aReader.ReadString());
			case JSONBinaryTag.IntValue:
				return new JSONData(aReader.ReadInt32());
			case JSONBinaryTag.DoubleValue:
				return new JSONData(aReader.ReadDouble());
			case JSONBinaryTag.BoolValue:
				return new JSONData(aReader.ReadBoolean());
			case JSONBinaryTag.FloatValue:
				return new JSONData(aReader.ReadSingle());
			default:
				throw new Exception("Error deserializing JSON. Unknown tag: " + jSONBinaryTag);
			}
		}

		public static JSONNode LoadFromCompressedFile(string aFileName)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedStream(Stream aData)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromCompressedBase64(string aBase64)
		{
			throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
		}

		public static JSONNode LoadFromStream(Stream aData)
		{
			using BinaryReader aReader = new BinaryReader(aData);
			return Deserialize(aReader);
		}

		public static JSONNode LoadFromFile(string aFileName)
		{
			using FileStream aData = File.OpenRead(aFileName);
			return LoadFromStream(aData);
		}

		public static JSONNode LoadFromBase64(string aBase64)
		{
			return LoadFromStream(new MemoryStream(Convert.FromBase64String(aBase64))
			{
				Position = 0L
			});
		}
	}
	public class JSONArray : JSONNode, IEnumerable
	{
		private List<JSONNode> m_List = new List<JSONNode>();

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return new JSONLazyCreator(this);
				}
				return m_List[aIndex];
			}
			set
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					m_List.Add(value);
				}
				else
				{
					m_List[aIndex] = value;
				}
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				m_List.Add(value);
			}
		}

		public override int Count => m_List.Count;

		public override IEnumerable<JSONNode> Childs
		{
			get
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			m_List.Add(aItem);
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_List.Count)
			{
				return null;
			}
			JSONNode result = m_List[aIndex];
			m_List.RemoveAt(aIndex);
			return result;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			m_List.Remove(aNode);
			return aNode;
		}

		public IEnumerator GetEnumerator()
		{
			foreach (JSONNode item in m_List)
			{
				yield return item;
			}
		}

		public override string ToString()
		{
			string text = "[ ";
			foreach (JSONNode item in m_List)
			{
				if (text.Length > 2)
				{
					text += ", ";
				}
				text += item.ToString();
			}
			return text + " ]";
		}

		public override string ToString(string aPrefix)
		{
			string text = "[ ";
			foreach (JSONNode item in m_List)
			{
				if (text.Length > 3)
				{
					text += ", ";
				}
				text = text + "\n" + aPrefix + "   ";
				text += item.ToString(aPrefix + "   ");
			}
			return text + "\n" + aPrefix + "]";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)1);
			aWriter.Write(m_List.Count);
			for (int i = 0; i < m_List.Count; i++)
			{
				m_List[i].Serialize(aWriter);
			}
		}
	}
	public class JSONClass : JSONNode, IEnumerable
	{
		private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>(StringComparer.Ordinal);

		public override JSONNode this[string aKey]
		{
			get
			{
				if (m_Dict.ContainsKey(aKey))
				{
					return m_Dict[aKey];
				}
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = value;
				}
				else
				{
					m_Dict.Add(aKey, value);
				}
			}
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				return m_Dict.ElementAt(aIndex).Value;
			}
			set
			{
				if (aIndex >= 0 && aIndex < m_Dict.Count)
				{
					string key = m_Dict.ElementAt(aIndex).Key;
					m_Dict[key] = value;
				}
			}
		}

		public override int Count => m_Dict.Count;

		public override IEnumerable<JSONNode> Childs
		{
			get
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item.Value;
				}
			}
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			if (!string.IsNullOrEmpty(aKey))
			{
				if (m_Dict.ContainsKey(aKey))
				{
					m_Dict[aKey] = aItem;
				}
				else
				{
					m_Dict.Add(aKey, aItem);
				}
			}
			else
			{
				m_Dict.Add(Guid.NewGuid().ToString(), aItem);
			}
		}

		public override JSONNode Remove(string aKey)
		{
			if (!m_Dict.ContainsKey(aKey))
			{
				return null;
			}
			JSONNode result = m_Dict[aKey];
			m_Dict.Remove(aKey);
			return result;
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex < 0 || aIndex >= m_Dict.Count)
			{
				return null;
			}
			KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
			m_Dict.Remove(keyValuePair.Key);
			return keyValuePair.Value;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			try
			{
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
				m_Dict.Remove(keyValuePair.Key);
				return aNode;
			}
			catch
			{
				return null;
			}
		}

		public IEnumerator GetEnumerator()
		{
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				yield return item;
			}
		}

		public override string ToString()
		{
			string text = "{";
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (text.Length > 2)
				{
					text += ", ";
				}
				text = text + "\"" + JSONNode.Escape(item.Key) + "\":" + item.Value.ToString();
			}
			return text + "}";
		}

		public override string ToString(string aPrefix)
		{
			string text = "{ ";
			foreach (KeyValuePair<string, JSONNode> item in m_Dict)
			{
				if (text.Length > 3)
				{
					text += ", ";
				}
				text = text + "\n" + aPrefix + "   ";
				text = text + "\"" + JSONNode.Escape(item.Key) + "\" : " + item.Value.ToString(aPrefix + "   ");
			}
			return text + "\n" + aPrefix + "}";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			aWriter.Write((byte)2);
			aWriter.Write(m_Dict.Count);
			foreach (string key in m_Dict.Keys)
			{
				aWriter.Write(key);
				m_Dict[key].Serialize(aWriter);
			}
		}
	}
	public class JSONData : JSONNode
	{
		private string m_Data;

		public override string Value
		{
			get
			{
				return m_Data;
			}
			set
			{
				m_Data = value;
			}
		}

		public JSONData(string aData)
		{
			m_Data = aData;
		}

		public JSONData(float aData)
		{
			AsFloat = aData;
		}

		public JSONData(double aData)
		{
			AsDouble = aData;
		}

		public JSONData(bool aData)
		{
			AsBool = aData;
		}

		public JSONData(int aData)
		{
			AsInt = aData;
		}

		public override string ToString()
		{
			return "\"" + JSONNode.Escape(m_Data) + "\"";
		}

		public override string ToString(string aPrefix)
		{
			return "\"" + JSONNode.Escape(m_Data) + "\"";
		}

		public override void Serialize(BinaryWriter aWriter)
		{
			JSONData jSONData = new JSONData("");
			jSONData.AsInt = AsInt;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)4);
				aWriter.Write(AsInt);
				return;
			}
			jSONData.AsFloat = AsFloat;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)7);
				aWriter.Write(AsFloat);
				return;
			}
			jSONData.AsDouble = AsDouble;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)5);
				aWriter.Write(AsDouble);
				return;
			}
			jSONData.AsBool = AsBool;
			if (jSONData.m_Data == m_Data)
			{
				aWriter.Write((byte)6);
				aWriter.Write(AsBool);
			}
			else
			{
				aWriter.Write((byte)3);
				aWriter.Write(m_Data);
			}
		}
	}
	internal class JSONLazyCreator : JSONNode
	{
		private JSONNode m_Node;

		private string m_Key;

		public override JSONNode this[int aIndex]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(value);
				Set(jSONArray);
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				JSONClass jSONClass = new JSONClass();
				jSONClass.Add(aKey, value);
				Set(jSONClass);
			}
		}

		public override int AsInt
		{
			get
			{
				JSONData aVal = new JSONData(0);
				Set(aVal);
				return 0;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override float AsFloat
		{
			get
			{
				JSONData aVal = new JSONData(0f);
				Set(aVal);
				return 0f;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override double AsDouble
		{
			get
			{
				JSONData aVal = new JSONData(0.0);
				Set(aVal);
				return 0.0;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override bool AsBool
		{
			get
			{
				JSONData aVal = new JSONData(aData: false);
				Set(aVal);
				return false;
			}
			set
			{
				JSONData aVal = new JSONData(value);
				Set(aVal);
			}
		}

		public override JSONArray AsArray
		{
			get
			{
				JSONArray jSONArray = new JSONArray();
				Set(jSONArray);
				return jSONArray;
			}
		}

		public override JSONClass AsObject
		{
			get
			{
				JSONClass jSONClass = new JSONClass();
				Set(jSONClass);
				return jSONClass;
			}
		}

		public JSONLazyCreator(JSONNode aNode)
		{
			m_Node = aNode;
			m_Key = null;
		}

		public JSONLazyCreator(JSONNode aNode, string aKey)
		{
			m_Node = aNode;
			m_Key = aKey;
		}

		private void Set(JSONNode aVal)
		{
			if (m_Key == null)
			{
				m_Node.Add(aVal);
			}
			else
			{
				m_Node.Add(m_Key, aVal);
			}
			m_Node = null;
		}

		public override void Add(JSONNode aItem)
		{
			JSONArray jSONArray = new JSONArray();
			jSONArray.Add(aItem);
			Set(jSONArray);
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			JSONClass jSONClass = new JSONClass();
			jSONClass.Add(aKey, aItem);
			Set(jSONClass);
		}

		public static bool operator ==(JSONLazyCreator a, object b)
		{
			if (b == null)
			{
				return true;
			}
			return (object)a == b;
		}

		public static bool operator !=(JSONLazyCreator a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return true;
			}
			return (object)this == obj;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public override string ToString()
		{
			return "";
		}

		public override string ToString(string aPrefix)
		{
			return "";
		}
	}
	public static class JSON
	{
		public static JSONNode Parse(string aJSON)
		{
			return JSONNode.Parse(aJSON);
		}
	}
}
namespace UnityStandardAssets.Vehicles.Car
{
	public class BrakeLight : MonoBehaviour
	{
		public CarController car;

		private Renderer m_Renderer;

		private void Start()
		{
			m_Renderer = GetComponent<Renderer>();
		}

		private void Update()
		{
			m_Renderer.enabled = car.BrakeInput > 0f;
		}
	}
	[RequireComponent(typeof(CarController))]
	public class CarAudio : MonoBehaviour
	{
		public enum EngineAudioOptions
		{
			Simple,
			FourChannel
		}

		public EngineAudioOptions engineSoundStyle = EngineAudioOptions.FourChannel;

		public AudioClip lowAccelClip;

		public AudioClip lowDecelClip;

		public AudioClip highAccelClip;

		public AudioClip highDecelClip;

		public float pitchMultiplier = 1f;

		public float lowPitchMin = 1f;

		public float lowPitchMax = 6f;

		public float highPitchMultiplier = 0.25f;

		public float maxRolloffDistance = 500f;

		public float dopplerLevel = 1f;

		public bool useDoppler = true;

		private AudioSource m_LowAccel;

		private AudioSource m_LowDecel;

		private AudioSource m_HighAccel;

		private AudioSource m_HighDecel;

		private bool m_StartedSound;

		private CarController m_CarController;

		private void StartSound()
		{
			m_CarController = GetComponent<CarController>();
			m_HighAccel = SetUpEngineAudioSource(highAccelClip);
			if (engineSoundStyle == EngineAudioOptions.FourChannel)
			{
				m_LowAccel = SetUpEngineAudioSource(lowAccelClip);
				m_LowDecel = SetUpEngineAudioSource(lowDecelClip);
				m_HighDecel = SetUpEngineAudioSource(highDecelClip);
			}
			m_StartedSound = true;
		}

		private void StopSound()
		{
			AudioSource[] components = GetComponents<AudioSource>();
			for (int i = 0; i < components.Length; i++)
			{
				UnityEngine.Object.Destroy(components[i]);
			}
			m_StartedSound = false;
		}

		private void Update()
		{
			float sqrMagnitude = (Camera.main.transform.position - base.transform.position).sqrMagnitude;
			if (m_StartedSound && sqrMagnitude > maxRolloffDistance * maxRolloffDistance)
			{
				StopSound();
			}
			if (!m_StartedSound && sqrMagnitude < maxRolloffDistance * maxRolloffDistance)
			{
				StartSound();
			}
			if (m_StartedSound)
			{
				float b = ULerp(lowPitchMin, lowPitchMax, m_CarController.Revs);
				b = Mathf.Min(lowPitchMax, b);
				if (engineSoundStyle == EngineAudioOptions.Simple)
				{
					m_HighAccel.pitch = b * pitchMultiplier * highPitchMultiplier;
					m_HighAccel.dopplerLevel = (useDoppler ? dopplerLevel : 0f);
					m_HighAccel.volume = 1f;
					return;
				}
				m_LowAccel.pitch = b * pitchMultiplier;
				m_LowDecel.pitch = b * pitchMultiplier;
				m_HighAccel.pitch = b * highPitchMultiplier * pitchMultiplier;
				m_HighDecel.pitch = b * highPitchMultiplier * pitchMultiplier;
				float num = Mathf.Abs(m_CarController.AccelInput);
				float num2 = 1f - num;
				float num3 = Mathf.InverseLerp(0.2f, 0.8f, m_CarController.Revs);
				float num4 = 1f - num3;
				num3 = 1f - (1f - num3) * (1f - num3);
				num4 = 1f - (1f - num4) * (1f - num4);
				num = 1f - (1f - num) * (1f - num);
				num2 = 1f - (1f - num2) * (1f - num2);
				m_LowAccel.volume = num4 * num;
				m_LowDecel.volume = num4 * num2;
				m_HighAccel.volume = num3 * num;
				m_HighDecel.volume = num3 * num2;
				m_HighAccel.dopplerLevel = (useDoppler ? dopplerLevel : 0f);
				m_LowAccel.dopplerLevel = (useDoppler ? dopplerLevel : 0f);
				m_HighDecel.dopplerLevel = (useDoppler ? dopplerLevel : 0f);
				m_LowDecel.dopplerLevel = (useDoppler ? dopplerLevel : 0f);
			}
		}

		private AudioSource SetUpEngineAudioSource(AudioClip clip)
		{
			AudioSource audioSource = base.gameObject.AddComponent<AudioSource>();
			audioSource.clip = clip;
			audioSource.volume = 0f;
			audioSource.loop = true;
			audioSource.time = UnityEngine.Random.Range(0f, clip.length);
			audioSource.Play();
			audioSource.minDistance = 5f;
			audioSource.maxDistance = maxRolloffDistance;
			audioSource.dopplerLevel = 0f;
			return audioSource;
		}

		private static float ULerp(float from, float to, float value)
		{
			return (1f - value) * from + value * to;
		}
	}
	internal enum CarDriveType
	{
		FrontWheelDrive,
		RearWheelDrive,
		FourWheelDrive
	}
	internal enum SpeedType
	{
		MPH,
		KPH
	}
	public class CarController : MonoBehaviour
	{
		[SerializeField]
		private CarDriveType m_CarDriveType = CarDriveType.FourWheelDrive;

		[SerializeField]
		private WheelCollider[] m_WheelColliders = new WheelCollider[4];

		[SerializeField]
		private GameObject[] m_WheelMeshes = new GameObject[4];

		[SerializeField]
		private WheelEffects[] m_WheelEffects = new WheelEffects[4];

		[SerializeField]
		private Vector3 m_CentreOfMassOffset;

		[SerializeField]
		private float m_MaximumSteerAngle;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_SteerHelper;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_TractionControl;

		[SerializeField]
		private float m_FullTorqueOverAllWheels;

		[SerializeField]
		private float m_ReverseTorque;

		[SerializeField]
		private float m_MaxHandbrakeTorque;

		[SerializeField]
		private float m_Downforce = 100f;

		[SerializeField]
		private SpeedType m_SpeedType;

		[SerializeField]
		private float m_Topspeed = 200f;

		[SerializeField]
		private static int NoOfGears = 5;

		[SerializeField]
		private float m_RevRangeBoundary = 1f;

		[SerializeField]
		private float m_SlipLimit;

		[SerializeField]
		private float m_BrakeTorque;

		private Quaternion[] m_WheelMeshLocalRotations;

		private Vector3 m_Prevpos;

		private Vector3 m_Pos;

		private float m_SteerAngle;

		private int m_GearNum;

		private float m_GearFactor;

		private float m_OldRotation;

		private float m_CurrentTorque;

		private Rigidbody m_Rigidbody;

		private const float k_ReversingThreshold = 0.01f;

		public bool Skidding { get; private set; }

		public float BrakeInput { get; private set; }

		public float CurrentSteerAngle => m_SteerAngle;

		public float CurrentSpeed => m_Rigidbody.velocity.magnitude * 2.2369363f;

		public float MaxSpeed => m_Topspeed;

		public float Revs { get; private set; }

		public float AccelInput { get; private set; }

		private void Start()
		{
			m_WheelMeshLocalRotations = new Quaternion[4];
			for (int i = 0; i < 4; i++)
			{
				m_WheelMeshLocalRotations[i] = m_WheelMeshes[i].transform.localRotation;
			}
			m_WheelColliders[0].attachedRigidbody.centerOfMass = m_CentreOfMassOffset;
			m_MaxHandbrakeTorque = float.MaxValue;
			m_Rigidbody = GetComponent<Rigidbody>();
			m_CurrentTorque = m_FullTorqueOverAllWheels - m_TractionControl * m_FullTorqueOverAllWheels;
		}

		private void GearChanging()
		{
			float num = Mathf.Abs(CurrentSpeed / MaxSpeed);
			float num2 = 1f / (float)NoOfGears * (float)(m_GearNum + 1);
			float num3 = 1f / (float)NoOfGears * (float)m_GearNum;
			if (m_GearNum > 0 && num < num3)
			{
				m_GearNum--;
			}
			if (num > num2 && m_GearNum < NoOfGears - 1)
			{
				m_GearNum++;
			}
		}

		private static float CurveFactor(float factor)
		{
			return 1f - (1f - factor) * (1f - factor);
		}

		private static float ULerp(float from, float to, float value)
		{
			return (1f - value) * from + value * to;
		}

		private void CalculateGearFactor()
		{
			float num = 1f / (float)NoOfGears;
			float b = Mathf.InverseLerp(num * (float)m_GearNum, num * (float)(m_GearNum + 1), Mathf.Abs(CurrentSpeed / MaxSpeed));
			m_GearFactor = Mathf.Lerp(m_GearFactor, b, Time.deltaTime * 5f);
		}

		private void CalculateRevs()
		{
			CalculateGearFactor();
			float num = (float)m_GearNum / (float)NoOfGears;
			float from = ULerp(0f, m_RevRangeBoundary, CurveFactor(num));
			float to = ULerp(m_RevRangeBoundary, 1f, num);
			Revs = ULerp(from, to, m_GearFactor);
		}

		public void Move(float steering, float accel, float footbrake, float handbrake)
		{
			for (int i = 0; i < 4; i++)
			{
				m_WheelColliders[i].GetWorldPose(out var pos, out var quat);
				m_WheelMeshes[i].transform.position = pos;
				m_WheelMeshes[i].transform.rotation = quat;
			}
			steering = Mathf.Clamp(steering, -1f, 1f);
			AccelInput = (accel = Mathf.Clamp(accel, 0f, 1f));
			BrakeInput = (footbrake = -1f * Mathf.Clamp(footbrake, -1f, 0f));
			handbrake = Mathf.Clamp(handbrake, 0f, 1f);
			m_SteerAngle = steering * m_MaximumSteerAngle;
			m_WheelColliders[0].steerAngle = m_SteerAngle;
			m_WheelColliders[1].steerAngle = m_SteerAngle;
			SteerHelper();
			ApplyDrive(accel, footbrake);
			CapSpeed();
			if (handbrake > 0f)
			{
				float brakeTorque = handbrake * m_MaxHandbrakeTorque;
				m_WheelColliders[2].brakeTorque = brakeTorque;
				m_WheelColliders[3].brakeTorque = brakeTorque;
			}
			CalculateRevs();
			GearChanging();
			AddDownForce();
			CheckForWheelSpin();
			TractionControl();
		}

		private void CapSpeed()
		{
			float magnitude = m_Rigidbody.velocity.magnitude;
			switch (m_SpeedType)
			{
			case SpeedType.MPH:
				magnitude *= 2.2369363f;
				if (magnitude > m_Topspeed)
				{
					m_Rigidbody.velocity = m_Topspeed / 2.2369363f * m_Rigidbody.velocity.normalized;
				}
				break;
			case SpeedType.KPH:
				magnitude *= 3.6f;
				if (magnitude > m_Topspeed)
				{
					m_Rigidbody.velocity = m_Topspeed / 3.6f * m_Rigidbody.velocity.normalized;
				}
				break;
			}
		}

		private void ApplyDrive(float accel, float footbrake)
		{
			switch (m_CarDriveType)
			{
			case CarDriveType.FourWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 4f);
				for (int i = 0; i < 4; i++)
				{
					m_WheelColliders[i].motorTorque = num;
				}
				break;
			}
			case CarDriveType.FrontWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 2f);
				WheelCollider obj2 = m_WheelColliders[0];
				float motorTorque = (m_WheelColliders[1].motorTorque = num);
				obj2.motorTorque = motorTorque;
				break;
			}
			case CarDriveType.RearWheelDrive:
			{
				float num = accel * (m_CurrentTorque / 2f);
				WheelCollider obj = m_WheelColliders[2];
				float motorTorque = (m_WheelColliders[3].motorTorque = num);
				obj.motorTorque = motorTorque;
				break;
			}
			}
			for (int j = 0; j < 4; j++)
			{
				if (CurrentSpeed > 5f && Vector3.Angle(base.transform.forward, m_Rigidbody.velocity) < 50f)
				{
					m_WheelColliders[j].brakeTorque = m_BrakeTorque * footbrake;
				}
				else if (footbrake > 0f)
				{
					m_WheelColliders[j].brakeTorque = 0f;
					m_WheelColliders[j].motorTorque = (0f - m_ReverseTorque) * footbrake;
				}
			}
		}

		private void SteerHelper()
		{
			for (int i = 0; i < 4; i++)
			{
				m_WheelColliders[i].GetGroundHit(out var hit);
				if (hit.normal == Vector3.zero)
				{
					return;
				}
			}
			if (Mathf.Abs(m_OldRotation - base.transform.eulerAngles.y) < 10f)
			{
				Quaternion quaternion = Quaternion.AngleAxis((base.transform.eulerAngles.y - m_OldRotation) * m_SteerHelper, Vector3.up);
				m_Rigidbody.velocity = quaternion * m_Rigidbody.velocity;
			}
			m_OldRotation = base.transform.eulerAngles.y;
		}

		private void AddDownForce()
		{
			m_WheelColliders[0].attachedRigidbody.AddForce(-base.transform.up * m_Downforce * m_WheelColliders[0].attachedRigidbody.velocity.magnitude);
		}

		private void CheckForWheelSpin()
		{
			for (int i = 0; i < 4; i++)
			{
				m_WheelColliders[i].GetGroundHit(out var hit);
				if (Mathf.Abs(hit.forwardSlip) >= m_SlipLimit || Mathf.Abs(hit.sidewaysSlip) >= m_SlipLimit)
				{
					m_WheelEffects[i].EmitTyreSmoke();
					if (!AnySkidSoundPlaying())
					{
						m_WheelEffects[i].PlayAudio();
					}
				}
				else
				{
					if (m_WheelEffects[i].PlayingAudio)
					{
						m_WheelEffects[i].StopAudio();
					}
					m_WheelEffects[i].EndSkidTrail();
				}
			}
		}

		private void TractionControl()
		{
			WheelHit hit;
			switch (m_CarDriveType)
			{
			case CarDriveType.FourWheelDrive:
			{
				for (int i = 0; i < 4; i++)
				{
					m_WheelColliders[i].GetGroundHit(out hit);
					AdjustTorque(hit.forwardSlip);
				}
				break;
			}
			case CarDriveType.RearWheelDrive:
				m_WheelColliders[2].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				m_WheelColliders[3].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				break;
			case CarDriveType.FrontWheelDrive:
				m_WheelColliders[0].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				m_WheelColliders[1].GetGroundHit(out hit);
				AdjustTorque(hit.forwardSlip);
				break;
			}
		}

		private void AdjustTorque(float forwardSlip)
		{
			if (forwardSlip >= m_SlipLimit && m_CurrentTorque >= 0f)
			{
				m_CurrentTorque -= 10f * m_TractionControl;
				return;
			}
			m_CurrentTorque += 10f * m_TractionControl;
			if (m_CurrentTorque > m_FullTorqueOverAllWheels)
			{
				m_CurrentTorque = m_FullTorqueOverAllWheels;
			}
		}

		private bool AnySkidSoundPlaying()
		{
			for (int i = 0; i < 4; i++)
			{
				if (m_WheelEffects[i].PlayingAudio)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class Mudguard : MonoBehaviour
	{
		public CarController carController;

		private Quaternion m_OriginalRotation;

		private void Start()
		{
			m_OriginalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f, carController.CurrentSteerAngle, 0f);
		}
	}
	public class SkidTrail : MonoBehaviour
	{
		[SerializeField]
		private float m_PersistTime;

		private IEnumerator Start()
		{
			while (true)
			{
				yield return null;
				if (base.transform.parent.parent == null)
				{
					UnityEngine.Object.Destroy(base.gameObject, m_PersistTime);
				}
			}
		}
	}
	public class Suspension : MonoBehaviour
	{
		public GameObject wheel;

		private Vector3 m_TargetOriginalPosition;

		private Vector3 m_Origin;

		private void Start()
		{
			m_TargetOriginalPosition = wheel.transform.localPosition;
			m_Origin = base.transform.localPosition;
		}

		private void Update()
		{
			base.transform.localPosition = m_Origin + (wheel.transform.localPosition - m_TargetOriginalPosition);
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class WheelEffects : MonoBehaviour
	{
		public Transform SkidTrailPrefab;

		public static Transform skidTrailsDetachedParent;

		public ParticleSystem skidParticles;

		private AudioSource m_AudioSource;

		private Transform m_SkidTrail;

		private WheelCollider m_WheelCollider;

		public bool skidding { get; private set; }

		public bool PlayingAudio { get; private set; }

		private void Start()
		{
			skidParticles = base.transform.root.GetComponentInChildren<ParticleSystem>();
			if (skidParticles == null)
			{
				UnityEngine.Debug.LogWarning(" no particle system found on car to generate smoke particles", base.gameObject);
			}
			else
			{
				skidParticles.Stop();
			}
			m_WheelCollider = GetComponent<WheelCollider>();
			m_AudioSource = GetComponent<AudioSource>();
			PlayingAudio = false;
			if (skidTrailsDetachedParent == null)
			{
				skidTrailsDetachedParent = new GameObject("Skid Trails - Detached").transform;
			}
		}

		public void EmitTyreSmoke()
		{
			skidParticles.transform.position = base.transform.position - base.transform.up * m_WheelCollider.radius;
			skidParticles.Emit(1);
			if (!skidding)
			{
				StartCoroutine(StartSkidTrail());
			}
		}

		public void PlayAudio()
		{
			m_AudioSource.Play();
			PlayingAudio = true;
		}

		public void StopAudio()
		{
			m_AudioSource.Stop();
			PlayingAudio = false;
		}

		public IEnumerator StartSkidTrail()
		{
			skidding = true;
			m_SkidTrail = UnityEngine.Object.Instantiate(SkidTrailPrefab);
			while (m_SkidTrail == null)
			{
				yield return null;
			}
			m_SkidTrail.parent = base.transform;
			m_SkidTrail.localPosition = -Vector3.up * m_WheelCollider.radius;
		}

		public void EndSkidTrail()
		{
			if (skidding)
			{
				skidding = false;
				m_SkidTrail.parent = skidTrailsDetachedParent;
				UnityEngine.Object.Destroy(m_SkidTrail.gameObject, 10f);
			}
		}
	}
}
namespace UnityStandardAssets.Cameras
{
	public class ProtectCameraFromWallClip : MonoBehaviour
	{
		public class RayHitComparer : IComparer
		{
			public int Compare(object x, object y)
			{
				return ((RaycastHit)x).distance.CompareTo(((RaycastHit)y).distance);
			}
		}

		public float clipMoveTime = 0.05f;

		public float returnTime = 0.4f;

		public float sphereCastRadius = 0.1f;

		public bool visualiseInEditor;

		public float closestDistance = 0.5f;

		public string dontClipTag = "Player";

		private Transform m_Cam;

		private Transform m_Pivot;

		private float m_OriginalDist;

		private float m_MoveVelocity;

		private float m_CurrentDist;

		private Ray m_Ray;

		private RaycastHit[] m_Hits;

		private RayHitComparer m_RayHitComparer;

		public bool protecting { get; private set; }

		private void Start()
		{
			m_Cam = GetComponentInChildren<Camera>().transform;
			m_Pivot = m_Cam.parent;
			m_OriginalDist = m_Cam.localPosition.magnitude;
			m_CurrentDist = m_OriginalDist;
			m_RayHitComparer = new RayHitComparer();
		}

		private void LateUpdate()
		{
			float num = m_OriginalDist;
			m_Ray.origin = m_Pivot.position + m_Pivot.forward * sphereCastRadius;
			m_Ray.direction = -m_Pivot.forward;
			Collider[] array = Physics.OverlapSphere(m_Ray.origin, sphereCastRadius);
			bool flag = false;
			bool flag2 = false;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].isTrigger && (!(array[i].attachedRigidbody != null) || !array[i].attachedRigidbody.CompareTag(dontClipTag)))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				m_Ray.origin += m_Pivot.forward * sphereCastRadius;
				m_Hits = Physics.RaycastAll(m_Ray, m_OriginalDist - sphereCastRadius);
			}
			else
			{
				m_Hits = Physics.SphereCastAll(m_Ray, sphereCastRadius, m_OriginalDist + sphereCastRadius);
			}
			Array.Sort(m_Hits, m_RayHitComparer);
			float num2 = float.PositiveInfinity;
			for (int j = 0; j < m_Hits.Length; j++)
			{
				if (m_Hits[j].distance < num2 && !m_Hits[j].collider.isTrigger && (!(m_Hits[j].collider.attachedRigidbody != null) || !m_Hits[j].collider.attachedRigidbody.CompareTag(dontClipTag)))
				{
					num2 = m_Hits[j].distance;
					num = 0f - m_Pivot.InverseTransformPoint(m_Hits[j].point).z;
					flag2 = true;
				}
			}
			if (flag2)
			{
				UnityEngine.Debug.DrawRay(m_Ray.origin, -m_Pivot.forward * (num + sphereCastRadius), Color.red);
			}
			protecting = flag2;
			m_CurrentDist = Mathf.SmoothDamp(m_CurrentDist, num, ref m_MoveVelocity, (m_CurrentDist > num) ? clipMoveTime : returnTime);
			m_CurrentDist = Mathf.Clamp(m_CurrentDist, closestDistance, m_OriginalDist);
			m_Cam.localPosition = -Vector3.forward * m_CurrentDist;
		}
	}
}
namespace UnityStandardAssets.Water
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class Displace : MonoBehaviour
	{
		public void Awake()
		{
			if (base.enabled)
			{
				OnEnable();
			}
			else
			{
				OnDisable();
			}
		}

		public void OnEnable()
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
		}

		public void OnDisable()
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class GerstnerDisplace : Displace
	{
	}
	public class MeshContainer
	{
		public Mesh mesh;

		public Vector3[] vertices;

		public Vector3[] normals;

		public MeshContainer(Mesh m)
		{
			mesh = m;
			vertices = m.vertices;
			normals = m.normals;
		}

		public void Update()
		{
			mesh.vertices = vertices;
			mesh.normals = normals;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(WaterBase))]
	public class PlanarReflection : MonoBehaviour
	{
		public LayerMask reflectionMask;

		public bool reflectSkybox;

		public Color clearColor = Color.grey;

		public string reflectionSampler = "_ReflectionTex";

		public float clipPlaneOffset = 0.07f;

		private Vector3 m_Oldpos;

		private Camera m_ReflectionCamera;

		private Material m_SharedMaterial;

		private Dictionary<Camera, bool> m_HelperCameras;

		public void Start()
		{
			m_SharedMaterial = ((WaterBase)base.gameObject.GetComponent(typeof(WaterBase))).sharedMaterial;
		}

		private Camera CreateReflectionCameraFor(Camera cam)
		{
			string text = base.gameObject.name + "Reflection" + cam.name;
			GameObject gameObject = GameObject.Find(text);
			if (!gameObject)
			{
				gameObject = new GameObject(text, typeof(Camera));
			}
			if (!gameObject.GetComponent(typeof(Camera)))
			{
				gameObject.AddComponent(typeof(Camera));
			}
			Camera component = gameObject.GetComponent<Camera>();
			component.backgroundColor = clearColor;
			component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			SetStandardCameraParameter(component, reflectionMask);
			if (!component.targetTexture)
			{
				component.targetTexture = CreateTextureFor(cam);
			}
			return component;
		}

		private void SetStandardCameraParameter(Camera cam, LayerMask mask)
		{
			cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
			cam.backgroundColor = Color.black;
			cam.enabled = false;
		}

		private RenderTexture CreateTextureFor(Camera cam)
		{
			return new RenderTexture(Mathf.FloorToInt((float)cam.pixelWidth * 0.5f), Mathf.FloorToInt((float)cam.pixelHeight * 0.5f), 24)
			{
				hideFlags = HideFlags.DontSave
			};
		}

		public void RenderHelpCameras(Camera currentCam)
		{
			if (m_HelperCameras == null)
			{
				m_HelperCameras = new Dictionary<Camera, bool>();
			}
			if (!m_HelperCameras.ContainsKey(currentCam))
			{
				m_HelperCameras.Add(currentCam, value: false);
			}
			if (!m_HelperCameras[currentCam])
			{
				if (!m_ReflectionCamera)
				{
					m_ReflectionCamera = CreateReflectionCameraFor(currentCam);
				}
				RenderReflectionFor(currentCam, m_ReflectionCamera);
				m_HelperCameras[currentCam] = true;
			}
		}

		public void LateUpdate()
		{
			if (m_HelperCameras != null)
			{
				m_HelperCameras.Clear();
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			RenderHelpCameras(currentCam);
			if ((bool)m_ReflectionCamera && (bool)m_SharedMaterial)
			{
				m_SharedMaterial.SetTexture(reflectionSampler, m_ReflectionCamera.targetTexture);
			}
		}

		public void OnEnable()
		{
			Shader.EnableKeyword("WATER_REFLECTIVE");
			Shader.DisableKeyword("WATER_SIMPLE");
		}

		public void OnDisable()
		{
			Shader.EnableKeyword("WATER_SIMPLE");
			Shader.DisableKeyword("WATER_REFLECTIVE");
		}

		private void RenderReflectionFor(Camera cam, Camera reflectCamera)
		{
			if (!reflectCamera || ((bool)m_SharedMaterial && !m_SharedMaterial.HasProperty(reflectionSampler)))
			{
				return;
			}
			reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
			SaneCameraSettings(reflectCamera);
			reflectCamera.backgroundColor = clearColor;
			reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
			if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
			{
				Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
				if (!skybox)
				{
					skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
				}
				skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
			}
			GL.invertCulling = true;
			Transform transform = base.transform;
			Vector3 eulerAngles = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
			reflectCamera.transform.position = cam.transform.position;
			Vector3 position = transform.transform.position;
			position.y = transform.position.y;
			Vector3 up = transform.transform.up;
			float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
			Vector4 plane = new Vector4(up.x, up.y, up.z, w);
			Matrix4x4 zero = Matrix4x4.zero;
			zero = CalculateReflectionMatrix(zero, plane);
			m_Oldpos = cam.transform.position;
			Vector3 position2 = zero.MultiplyPoint(m_Oldpos);
			reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
			Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
			Matrix4x4 projectionMatrix = cam.projectionMatrix;
			projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
			reflectCamera.projectionMatrix = projectionMatrix;
			reflectCamera.transform.position = position2;
			Vector3 eulerAngles2 = cam.transform.eulerAngles;
			reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
			reflectCamera.Render();
			GL.invertCulling = false;
		}

		private void SaneCameraSettings(Camera helperCam)
		{
			helperCam.depthTextureMode = DepthTextureMode.None;
			helperCam.backgroundColor = Color.black;
			helperCam.clearFlags = CameraClearFlags.Color;
			helperCam.renderingPath = RenderingPath.Forward;
		}

		private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
		{
			Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
			Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
			projection[2] = vector.x - projection[3];
			projection[6] = vector.y - projection[7];
			projection[10] = vector.z - projection[11];
			projection[14] = vector.w - projection[15];
			return projection;
		}

		private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
			return reflectionMat;
		}

		private static float Sgn(float a)
		{
			if (a > 0f)
			{
				return 1f;
			}
			if (a < 0f)
			{
				return -1f;
			}
			return 0f;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}
	}
	[RequireComponent(typeof(WaterBase))]
	[ExecuteInEditMode]
	public class SpecularLighting : MonoBehaviour
	{
		public Transform specularLight;

		private WaterBase m_WaterBase;

		public void Start()
		{
			m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
		}

		public void Update()
		{
			if (!m_WaterBase)
			{
				m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
			}
			if ((bool)specularLight && (bool)m_WaterBase.sharedMaterial)
			{
				m_WaterBase.sharedMaterial.SetVector("_WorldLightDir", specularLight.transform.forward);
			}
		}
	}
	public enum WaterQuality
	{
		High = 2,
		Medium = 1,
		Low = 0
	}
	[ExecuteInEditMode]
	public class WaterBase : MonoBehaviour
	{
		public Material sharedMaterial;

		public WaterQuality waterQuality = WaterQuality.High;

		public bool edgeBlend = true;

		public void UpdateShader()
		{
			if (waterQuality > WaterQuality.Medium)
			{
				sharedMaterial.shader.maximumLOD = 501;
			}
			else if (waterQuality > WaterQuality.Low)
			{
				sharedMaterial.shader.maximumLOD = 301;
			}
			else
			{
				sharedMaterial.shader.maximumLOD = 201;
			}
			if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				edgeBlend = false;
			}
			if (edgeBlend)
			{
				Shader.EnableKeyword("WATER_EDGEBLEND_ON");
				Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
				if ((bool)Camera.main)
				{
					Camera.main.depthTextureMode |= DepthTextureMode.Depth;
				}
			}
			else
			{
				Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
				Shader.DisableKeyword("WATER_EDGEBLEND_ON");
			}
		}

		public void WaterTileBeingRendered(Transform tr, Camera currentCam)
		{
			if ((bool)currentCam && edgeBlend)
			{
				currentCam.depthTextureMode |= DepthTextureMode.Depth;
			}
		}

		public void Update()
		{
			if ((bool)sharedMaterial)
			{
				UpdateShader();
			}
		}
	}
	[ExecuteInEditMode]
	public class WaterTile : MonoBehaviour
	{
		public PlanarReflection reflection;

		public WaterBase waterBase;

		public void Start()
		{
			AcquireComponents();
		}

		private void AcquireComponents()
		{
			if (!reflection)
			{
				if ((bool)base.transform.parent)
				{
					reflection = base.transform.parent.GetComponent<PlanarReflection>();
				}
				else
				{
					reflection = base.transform.GetComponent<PlanarReflection>();
				}
			}
			if (!waterBase)
			{
				if ((bool)base.transform.parent)
				{
					waterBase = base.transform.parent.GetComponent<WaterBase>();
				}
				else
				{
					waterBase = base.transform.GetComponent<WaterBase>();
				}
			}
		}

		public void OnWillRenderObject()
		{
			if ((bool)reflection)
			{
				reflection.WaterTileBeingRendered(base.transform, Camera.current);
			}
			if ((bool)waterBase)
			{
				waterBase.WaterTileBeingRendered(base.transform, Camera.current);
			}
		}
	}
	[ExecuteInEditMode]
	public class Water : MonoBehaviour
	{
		public enum WaterMode
		{
			Simple,
			Reflective,
			Refractive
		}

		public WaterMode waterMode = WaterMode.Refractive;

		public bool disablePixelLights = true;

		public int textureSize = 256;

		public float clipPlaneOffset = 0.07f;

		public LayerMask reflectLayers = -1;

		public LayerMask refractLayers = -1;

		private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

		private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

		private RenderTexture m_ReflectionTexture;

		private RenderTexture m_RefractionTexture;

		private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

		private int m_OldReflectionTextureSize;

		private int m_OldRefractionTextureSize;

		private static bool s_InsideWater;

		public void OnWillRenderObject()
		{
			if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
			{
				return;
			}
			Camera current = Camera.current;
			if ((bool)current && !s_InsideWater)
			{
				s_InsideWater = true;
				m_HardwareWaterSupport = FindHardwareWaterSupport();
				WaterMode waterMode = GetWaterMode();
				CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
				Vector3 position = base.transform.position;
				Vector3 up = base.transform.up;
				int pixelLightCount = QualitySettings.pixelLightCount;
				if (disablePixelLights)
				{
					QualitySettings.pixelLightCount = 0;
				}
				UpdateCameraModes(current, reflectionCamera);
				UpdateCameraModes(current, refractionCamera);
				if (waterMode >= WaterMode.Reflective)
				{
					float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
					Vector4 plane = new Vector4(up.x, up.y, up.z, w);
					Matrix4x4 reflectionMat = Matrix4x4.zero;
					CalculateReflectionMatrix(ref reflectionMat, plane);
					Vector3 position2 = current.transform.position;
					Vector3 position3 = reflectionMat.MultiplyPoint(position2);
					reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
					Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
					reflectionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
					reflectionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
					reflectionCamera.cullingMask = -17 & reflectLayers.value;
					reflectionCamera.targetTexture = m_ReflectionTexture;
					bool invertCulling = GL.invertCulling;
					GL.invertCulling = !invertCulling;
					reflectionCamera.transform.position = position3;
					Vector3 eulerAngles = current.transform.eulerAngles;
					reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
					reflectionCamera.Render();
					reflectionCamera.transform.position = position2;
					GL.invertCulling = invertCulling;
					GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
				}
				if (waterMode >= WaterMode.Refractive)
				{
					refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
					Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
					refractionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane2);
					refractionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
					refractionCamera.cullingMask = -17 & refractLayers.value;
					refractionCamera.targetTexture = m_RefractionTexture;
					refractionCamera.transform.position = current.transform.position;
					refractionCamera.transform.rotation = current.transform.rotation;
					refractionCamera.Render();
					GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
				}
				if (disablePixelLights)
				{
					QualitySettings.pixelLightCount = pixelLightCount;
				}
				switch (waterMode)
				{
				case WaterMode.Simple:
					Shader.EnableKeyword("WATER_SIMPLE");
					Shader.DisableKeyword("WATER_REFLECTIVE");
					Shader.DisableKeyword("WATER_REFRACTIVE");
					break;
				case WaterMode.Reflective:
					Shader.DisableKeyword("WATER_SIMPLE");
					Shader.EnableKeyword("WATER_REFLECTIVE");
					Shader.DisableKeyword("WATER_REFRACTIVE");
					break;
				case WaterMode.Refractive:
					Shader.DisableKeyword("WATER_SIMPLE");
					Shader.DisableKeyword("WATER_REFLECTIVE");
					Shader.EnableKeyword("WATER_REFRACTIVE");
					break;
				}
				s_InsideWater = false;
			}
		}

		private void OnDisable()
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
				m_ReflectionTexture = null;
			}
			if ((bool)m_RefractionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				m_RefractionTexture = null;
			}
			foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
			{
				UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
			}
			m_ReflectionCameras.Clear();
			foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
			{
				UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
			}
			m_RefractionCameras.Clear();
		}

		private void Update()
		{
			if ((bool)GetComponent<Renderer>())
			{
				Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
				if ((bool)sharedMaterial)
				{
					Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
					float @float = sharedMaterial.GetFloat("_WaveScale");
					Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
					double num = (double)Time.timeSinceLevelLoad / 20.0;
					Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
					sharedMaterial.SetVector("_WaveOffset", value2);
					sharedMaterial.SetVector("_WaveScale4", value);
				}
			}
		}

		private void UpdateCameraModes(Camera src, Camera dest)
		{
			if (dest == null)
			{
				return;
			}
			dest.clearFlags = src.clearFlags;
			dest.backgroundColor = src.backgroundColor;
			if (src.clearFlags == CameraClearFlags.Skybox)
			{
				Skybox component = src.GetComponent<Skybox>();
				Skybox component2 = dest.GetComponent<Skybox>();
				if (!component || !component.material)
				{
					component2.enabled = false;
				}
				else
				{
					component2.enabled = true;
					component2.material = component.material;
				}
			}
			dest.farClipPlane = src.farClipPlane;
			dest.nearClipPlane = src.nearClipPlane;
			dest.orthographic = src.orthographic;
			dest.fieldOfView = src.fieldOfView;
			dest.aspect = src.aspect;
			dest.orthographicSize = src.orthographicSize;
		}

		private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
		{
			WaterMode waterMode = GetWaterMode();
			reflectionCamera = null;
			refractionCamera = null;
			if (waterMode >= WaterMode.Reflective)
			{
				if (!m_ReflectionTexture || m_OldReflectionTextureSize != textureSize)
				{
					if ((bool)m_ReflectionTexture)
					{
						UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
					}
					m_ReflectionTexture = new RenderTexture(textureSize, textureSize, 16);
					m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
					m_ReflectionTexture.isPowerOfTwo = true;
					m_ReflectionTexture.hideFlags = HideFlags.DontSave;
					m_OldReflectionTextureSize = textureSize;
				}
				m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
				if (!reflectionCamera)
				{
					GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
					reflectionCamera = gameObject.GetComponent<Camera>();
					reflectionCamera.enabled = false;
					reflectionCamera.transform.position = base.transform.position;
					reflectionCamera.transform.rotation = base.transform.rotation;
					reflectionCamera.gameObject.AddComponent<FlareLayer>();
					gameObject.hideFlags = HideFlags.HideAndDontSave;
					m_ReflectionCameras[currentCamera] = reflectionCamera;
				}
			}
			if (waterMode < WaterMode.Refractive)
			{
				return;
			}
			if (!m_RefractionTexture || m_OldRefractionTextureSize != textureSize)
			{
				if ((bool)m_RefractionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
				}
				m_RefractionTexture = new RenderTexture(textureSize, textureSize, 16);
				m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
				m_RefractionTexture.isPowerOfTwo = true;
				m_RefractionTexture.hideFlags = HideFlags.DontSave;
				m_OldRefractionTextureSize = textureSize;
			}
			m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
			if (!refractionCamera)
			{
				GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
				refractionCamera = gameObject2.GetComponent<Camera>();
				refractionCamera.enabled = false;
				refractionCamera.transform.position = base.transform.position;
				refractionCamera.transform.rotation = base.transform.rotation;
				refractionCamera.gameObject.AddComponent<FlareLayer>();
				gameObject2.hideFlags = HideFlags.HideAndDontSave;
				m_RefractionCameras[currentCamera] = refractionCamera;
			}
		}

		private WaterMode GetWaterMode()
		{
			if (m_HardwareWaterSupport < waterMode)
			{
				return m_HardwareWaterSupport;
			}
			return waterMode;
		}

		private WaterMode FindHardwareWaterSupport()
		{
			if (!SystemInfo.supportsRenderTextures || !GetComponent<Renderer>())
			{
				return WaterMode.Simple;
			}
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			if (!sharedMaterial)
			{
				return WaterMode.Simple;
			}
			string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
			if (text == "Refractive")
			{
				return WaterMode.Refractive;
			}
			if (text == "Reflective")
			{
				return WaterMode.Reflective;
			}
			return WaterMode.Simple;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * clipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}

		private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
		}
	}
}
namespace CurvedUI
{
	public class CUI_AnimateCurvedFillOnStart : MonoBehaviour
	{
		private void Update()
		{
			CurvedUISettings component = GetComponent<CurvedUISettings>();
			Text componentInChildren = GetComponentInChildren<Text>();
			if (Time.time < 1.5f)
			{
				component.RingFill = Mathf.PerlinNoise(Time.time * 30.23234f, Time.time * 30.2313f) * 0.15f;
				componentInChildren.text = "Accesing Mainframe...";
			}
			else if (Time.time < 2.5f)
			{
				component.RingFill = Mathf.Clamp(component.RingFill + Time.deltaTime * 3f, 0f, 1f);
				componentInChildren.text = "Mainframe Active";
			}
		}
	}
	public class CUI_CameraController : MonoBehaviour
	{
		public static CUI_CameraController instance;

		[SerializeField]
		private Transform CameraObject;

		[SerializeField]
		private float rotationMargin = 25f;

		[SerializeField]
		private bool runInEditorOnly = true;

		private void Awake()
		{
			instance = this;
		}
	}
	public class CUI_ChangeValueOnHold : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private bool pressed;

		private bool selected;

		[SerializeField]
		private Image bg;

		[SerializeField]
		private Color SelectedColor;

		[SerializeField]
		private Color NormalColor;

		[SerializeField]
		private CanvasGroup IntroCG;

		[SerializeField]
		private CanvasGroup MenuCG;

		private void Update()
		{
			pressed = Input.GetKey(KeyCode.Space) || Input.GetButton("Fire1");
			ChangeVal();
		}

		private void ChangeVal()
		{
			if (GetComponent<Slider>().normalizedValue == 1f)
			{
				IntroCG.alpha -= Time.deltaTime;
				MenuCG.alpha += Time.deltaTime;
			}
			else
			{
				GetComponent<Slider>().normalizedValue += ((pressed && selected) ? Time.deltaTime : (0f - Time.deltaTime));
			}
			IntroCG.blocksRaycasts = IntroCG.alpha > 0f;
		}

		public void OnPointerEnter(PointerEventData data)
		{
			bg.color = SelectedColor;
			bg.GetComponent<CurvedUIVertexEffect>().TesselationRequired = true;
			selected = true;
		}

		public void OnPointerExit(PointerEventData data)
		{
			bg.color = NormalColor;
			bg.GetComponent<CurvedUIVertexEffect>().TesselationRequired = true;
			selected = false;
		}
	}
	public class CUI_DragBetweenCanvases : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IEndDragHandler, IDragHandler
	{
		private Vector2 dragPoint;

		public void OnBeginDrag(PointerEventData data)
		{
			UnityEngine.Debug.Log("OnBeginDrag");
			Vector2 newPos = Vector2.zero;
			RaycastPosition(out newPos);
			dragPoint = new Vector2((base.transform as RectTransform).localPosition.x, (base.transform as RectTransform).localPosition.y) - newPos;
		}

		public void OnDrag(PointerEventData data)
		{
			CurvedUISettings componentInParent = GetComponentInParent<CurvedUISettings>();
			Ray ray = Camera.main.ScreenPointToRay(new Vector2((float)Screen.width / 2f, (float)Screen.height / 2f));
			if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.MOUSE)
			{
				ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			}
			else if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.GAZE)
			{
				ray = Camera.main.ScreenPointToRay(new Vector2((float)Screen.width / 2f, (float)Screen.height / 2f));
			}
			if (!Physics.Raycast(ray, out var hitInfo))
			{
				return;
			}
			CurvedUISettings componentInParent2 = hitInfo.collider.GetComponentInParent<CurvedUISettings>();
			Vector2 o_positionOnCanvas = Vector2.zero;
			if (!(componentInParent2 != null))
			{
				return;
			}
			if (componentInParent2 != componentInParent)
			{
				base.transform.SetParent(componentInParent2.transform);
				base.transform.ResetTransform();
				CurvedUIVertexEffect[] componentsInChildren = GetComponentsInChildren<CurvedUIVertexEffect>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].FindParentSettings(forceNew: true);
				}
			}
			componentInParent2.RaycastToCanvasSpace(ray, out o_positionOnCanvas);
			(base.transform as RectTransform).localPosition = o_positionOnCanvas + dragPoint;
		}

		public void OnEndDrag(PointerEventData data)
		{
			UnityEngine.Debug.Log("OnEndDrag");
		}

		private void RaycastPosition(out Vector2 newPos)
		{
			if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.MOUSE)
			{
				GetComponentInParent<CurvedUISettings>().RaycastToCanvasSpace(Camera.main.ScreenPointToRay(Input.mousePosition), out newPos);
			}
			else if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.GAZE)
			{
				GetComponentInParent<CurvedUISettings>().RaycastToCanvasSpace(Camera.main.ScreenPointToRay(new Vector2((float)Screen.width / 2f, (float)Screen.height / 2f)), out newPos);
			}
			else
			{
				newPos = Vector2.zero;
			}
		}
	}
	public class CUI_GunController : MonoBehaviour
	{
		[SerializeField]
		private CurvedUISettings ControlledCanvas;

		[SerializeField]
		private Transform LaserBeamTransform;

		private void Update()
		{
			Ray ray = new Ray(base.transform.position, base.transform.forward);
			if ((bool)ControlledCanvas)
			{
				CurvedUIInputModule.CustomControllerRay = ray;
			}
			float num = 10000f;
			if (Physics.Raycast(ray, out var hitInfo, num))
			{
				int num2 = 0;
				if (hitInfo.transform.GetComponent<CurvedUIRaycaster>() != null)
				{
					num2 = hitInfo.transform.GetComponent<CurvedUIRaycaster>().GetObjectsUnderPointer().FindAll((GameObject x) => x.GetComponent<Graphic>() != null && x.GetComponent<Graphic>().depth != -1)
						.Count;
				}
				num = ((num2 == 0) ? 10000f : Vector3.Distance(hitInfo.point, base.transform.position));
			}
			LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyZ(num);
			if (Input.GetMouseButton(0))
			{
				LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyX(0.75f).ModifyY(0.75f);
			}
			else
			{
				LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyX(0.2f).ModifyY(0.2f);
			}
		}
	}
	public class CUI_GunMovement : MonoBehaviour
	{
		[SerializeField]
		private CurvedUISettings mySettings;

		[SerializeField]
		private Transform pivot;

		[SerializeField]
		private float sensitivity = 0.1f;

		private Vector3 lastMouse;

		private void Start()
		{
			lastMouse = Input.mousePosition;
		}

		private void Update()
		{
			Vector3 vector = Input.mousePosition - lastMouse;
			lastMouse = Input.mousePosition;
			pivot.localEulerAngles += new Vector3(0f - vector.y, vector.x, 0f) * sensitivity;
			CurvedUIInputModule.CustomControllerRay = new Ray(base.transform.position, base.transform.forward);
			CurvedUIInputModule.CustomControllerButtonState = Input.GetButton("Fire1");
		}
	}
	public class CUI_OrientOnCurvedSpace : MonoBehaviour
	{
		public CurvedUISettings mySettings;

		private void Awake()
		{
			mySettings = GetComponentInParent<CurvedUISettings>();
		}

		private void Update()
		{
			Vector3 pos = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(base.transform.parent.position);
			base.transform.position = mySettings.CanvasToCurvedCanvas(pos);
			base.transform.rotation = Quaternion.LookRotation(mySettings.CanvasToCurvedCanvasNormal(base.transform.parent.localPosition), base.transform.parent.up);
		}
	}
	public class CUI_PerlinNoisePosition : MonoBehaviour
	{
		public float samplingSpeed = 1f;

		public Vector2 Range;

		private RectTransform rectie;

		private void Start()
		{
			rectie = base.transform as RectTransform;
		}

		private void Update()
		{
			rectie.anchoredPosition = new Vector2(Mathf.PerlinNoise(Time.time * samplingSpeed, Time.time * samplingSpeed).Remap(0f, 1f, 0f - Range.x, Range.x), Mathf.PerlinNoise(Time.time * samplingSpeed * 1.333f, Time.time * samplingSpeed * 0.888f).Remap(0f, 1f, 0f - Range.y, Range.y));
		}
	}
	public class CUI_PerlinNoiseRotation : MonoBehaviour
	{
		public float samplingSpeed = 1f;

		public float maxrotation = 60f;

		private RectTransform rectie;

		private void Start()
		{
			rectie = base.transform as RectTransform;
		}

		private void Update()
		{
			rectie.localEulerAngles = new Vector3(0f, 0f, Mathf.PerlinNoise(Time.time * samplingSpeed, Time.time * samplingSpeed).Remap(0f, 1f, 0f - maxrotation, maxrotation));
		}
	}
	public class CUI_PickImageFromSet : MonoBehaviour
	{
		private static CUI_PickImageFromSet picked;

		public void PickThis()
		{
			if (picked != null)
			{
				picked.GetComponent<Button>().targetGraphic.color = Color.white;
			}
			UnityEngine.Debug.Log("Clicked this!", base.gameObject);
			picked = this;
			picked.GetComponent<Button>().targetGraphic.color = Color.red;
		}
	}
	public class CUI_RaycastToCanvas : MonoBehaviour
	{
		private CurvedUISettings mySettings;

		private void Start()
		{
			mySettings = GetComponentInParent<CurvedUISettings>();
		}

		private void Update()
		{
			Vector2 o_positionOnCanvas = Vector2.zero;
			mySettings.RaycastToCanvasSpace(Camera.main.ScreenPointToRay(Input.mousePosition), out o_positionOnCanvas);
			base.transform.localPosition = o_positionOnCanvas;
		}
	}
	public class CUI_RiseChildrenOverTime : MonoBehaviour
	{
		private float current;

		public float Speed = 10f;

		public float RiseBy = 50f;

		private void Start()
		{
		}

		private void Update()
		{
			current += Speed * Time.deltaTime;
			if (Mathf.RoundToInt(current) >= base.transform.childCount)
			{
				current = 0f;
			}
			if (Mathf.RoundToInt(current) < 0)
			{
				current = base.transform.childCount - 1;
			}
			for (int i = 0; i < base.transform.childCount; i++)
			{
				if (Mathf.RoundToInt(current) == i)
				{
					base.transform.GetChild(i).localPosition = base.transform.GetChild(i).localPosition.ModifyZ(0f - RiseBy);
				}
				else
				{
					base.transform.GetChild(i).localPosition = base.transform.GetChild(i).localPosition.ModifyZ(0f);
				}
			}
		}
	}
	public class CUI_TMPChecker : MonoBehaviour
	{
		[SerializeField]
		private GameObject testMsg;

		[SerializeField]
		private GameObject enabledMsg;

		[SerializeField]
		private GameObject disabledMsg;

		private void Start()
		{
			testMsg.gameObject.SetActive(value: false);
			enabledMsg.gameObject.SetActive(value: true);
			disabledMsg.gameObject.SetActive(value: false);
		}
	}
	public class CUI_ViveButtonState : MonoBehaviour
	{
		private enum ViveButton
		{
			Trigger,
			TouchpadTouch,
			TouchpadPress,
			Grip,
			Menu
		}

		[SerializeField]
		private Color ActiveColor = Color.green;

		[SerializeField]
		private Color InActiveColor = Color.gray;

		[SerializeField]
		private ViveButton ShowStateFor;
	}
	public class CUI_ViveHapticPulse : MonoBehaviour
	{
		private float PulseStrength;

		private void Start()
		{
			PulseStrength = 1f;
		}

		public void SetPulseStrength(float newStr)
		{
			PulseStrength = Mathf.Clamp(newStr, 0f, 1f);
		}

		public void TriggerPulse()
		{
		}
	}
	public class CUI_WorldSpaceCursorFollow : MonoBehaviour
	{
		private CurvedUISettings mySettings;

		private void Start()
		{
			mySettings = GetComponentInParent<CurvedUISettings>();
			CurvedUIInputModule.Instance.WorldSpaceMouseInCanvasSpace -= (mySettings.transform as RectTransform).rect.size / 2f;
		}

		private void Update()
		{
			base.transform.localPosition = CurvedUIInputModule.Instance.WorldSpaceMouseInCanvasSpace;
		}
	}
	public class CUI_WorldSpaceMouseMultipleCanvases : MonoBehaviour
	{
		[SerializeField]
		private List<CurvedUISettings> ControlledCanvases;

		[SerializeField]
		private Transform WorldSpaceMouse;

		[SerializeField]
		private CurvedUISettings MouseCanvas;

		private void Update()
		{
			Vector3 vector = MouseCanvas.CanvasToCurvedCanvas(WorldSpaceMouse.localPosition);
			Ray ray2 = (CurvedUIInputModule.CustomControllerRay = new Ray(Camera.main.transform.position, vector - Camera.main.transform.position));
			if (Input.GetButton("Fire2"))
			{
				Vector2 o_positionOnCanvas = Vector2.zero;
				MouseCanvas.RaycastToCanvasSpace(new Ray(Camera.main.transform.position, Camera.main.transform.forward), out o_positionOnCanvas);
				CurvedUIInputModule.Instance.WorldSpaceMouseInCanvasSpace = o_positionOnCanvas;
			}
			UnityEngine.Debug.DrawRay(ray2.GetPoint(0f), ray2.direction * 1000f, Color.cyan);
		}
	}
	public class CUI_draggable : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IEndDragHandler, IDragHandler
	{
		private Vector2 savedVector;

		private bool isDragged;

		public void OnBeginDrag(PointerEventData data)
		{
			UnityEngine.Debug.Log("OnBeginDrag");
			Vector2 newPos = Vector2.zero;
			RaycastPosition(out newPos);
			savedVector = new Vector2((base.transform as RectTransform).localPosition.x, (base.transform as RectTransform).localPosition.y) - newPos;
			isDragged = true;
		}

		public void OnDrag(PointerEventData data)
		{
		}

		public void OnEndDrag(PointerEventData data)
		{
			UnityEngine.Debug.Log("OnEndDrag");
			isDragged = false;
		}

		private void LateUpdate()
		{
			if (isDragged)
			{
				UnityEngine.Debug.Log("OnDrag");
				Vector2 newPos = Vector2.zero;
				RaycastPosition(out newPos);
				(base.transform as RectTransform).localPosition = newPos + savedVector;
			}
		}

		private void RaycastPosition(out Vector2 newPos)
		{
			if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.MOUSE)
			{
				GetComponentInParent<CurvedUISettings>().RaycastToCanvasSpace(Camera.main.ScreenPointToRay(Input.mousePosition), out newPos);
			}
			else if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.GAZE)
			{
				GetComponentInParent<CurvedUISettings>().RaycastToCanvasSpace(Camera.main.ScreenPointToRay(new Vector2((float)Screen.width / 2f, (float)Screen.height / 2f)), out newPos);
			}
			else
			{
				newPos = Vector2.zero;
			}
		}
	}
	public class CUI_inventory_paralax : MonoBehaviour
	{
		[SerializeField]
		private Transform front;

		[SerializeField]
		private Transform back;

		private Vector3 initFG;

		private Vector3 initBG;

		public float change = 50f;

		private void Start()
		{
			initFG = front.position;
			initBG = back.position;
		}

		private void Update()
		{
			front.position = front.position.ModifyX(initFG.x + Input.mousePosition.x.Remap(0f, Screen.width, 0f - change, change));
			back.position = back.position.ModifyX(initBG.x - Input.mousePosition.x.Remap(0f, Screen.width, 0f - change, change));
			front.position = front.position.ModifyY(initFG.y + Input.mousePosition.y.Remap(0f, Screen.height, 0f - change, change) * (float)(Screen.height / Screen.width));
			back.position = back.position.ModifyY(initBG.y - Input.mousePosition.y.Remap(0f, Screen.height, 0f - change, change) * (float)(Screen.height / Screen.width));
		}
	}
	public class CurvedUIEventSystem : EventSystem
	{
		public static CurvedUIEventSystem instance;

		protected override void Awake()
		{
			base.Awake();
			instance = this;
		}

		protected override void OnApplicationFocus(bool hasFocus)
		{
			base.OnApplicationFocus(hasFocus: true);
		}
	}
	public static class CurvedUIExtensionMethods
	{
		public static bool AlmostEqual(this Vector3 a, Vector3 b, double accuracy = 0.01)
		{
			return (double)Vector3.SqrMagnitude(a - b) < accuracy;
		}

		public static float Remap(this float value, float from1, float to1, float from2, float to2)
		{
			return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static float RemapAndClamp(this float value, float from1, float to1, float from2, float to2)
		{
			return value.Remap(from1, to1, from2, to2).Clamp(from2, to2);
		}

		public static float Remap(this int value, float from1, float to1, float from2, float to2)
		{
			return ((float)value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static double Remap(this double value, double from1, double to1, double from2, double to2)
		{
			return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
		}

		public static float Clamp(this float value, float min, float max)
		{
			return Mathf.Clamp(value, min, max);
		}

		public static float Clamp(this int value, int min, int max)
		{
			return Mathf.Clamp(value, min, max);
		}

		public static int Abs(this int value)
		{
			return Mathf.Abs(value);
		}

		public static float Abs(this float value)
		{
			return Mathf.Abs(value);
		}

		public static int ToInt(this float value)
		{
			return Mathf.RoundToInt(value);
		}

		public static int FloorToInt(this float value)
		{
			return Mathf.FloorToInt(value);
		}

		public static int CeilToInt(this float value)
		{
			return Mathf.FloorToInt(value);
		}

		public static Vector3 ModifyX(this Vector3 trans, float newVal)
		{
			trans = new Vector3(newVal, trans.y, trans.z);
			return trans;
		}

		public static Vector3 ModifyY(this Vector3 trans, float newVal)
		{
			trans = new Vector3(trans.x, newVal, trans.z);
			return trans;
		}

		public static Vector3 ModifyZ(this Vector3 trans, float newVal)
		{
			trans = new Vector3(trans.x, trans.y, newVal);
			return trans;
		}

		public static Vector2 ModifyVectorX(this Vector2 trans, float newVal)
		{
			trans = new Vector3(newVal, trans.y);
			return trans;
		}

		public static Vector2 ModifyVectorY(this Vector2 trans, float newVal)
		{
			trans = new Vector3(trans.x, newVal);
			return trans;
		}

		public static void ResetTransform(this Transform trans)
		{
			trans.localPosition = Vector3.zero;
			trans.localRotation = Quaternion.identity;
			trans.localScale = Vector3.one;
		}

		public static T AddComponentIfMissing<T>(this GameObject go) where T : UnityEngine.Component
		{
			if (go.GetComponent<T>() == null)
			{
				return go.AddComponent<T>();
			}
			return go.GetComponent<T>();
		}

		public static T AddComponentIfMissing<T>(this UnityEngine.Component go) where T : UnityEngine.Component
		{
			return go.gameObject.AddComponentIfMissing<T>();
		}
	}
	public class CurvedUIHandSwitcher : MonoBehaviour
	{
		[SerializeField]
		private GameObject LaserBeam;

		[SerializeField]
		[Tooltip("If true, when player clicks the trigger on the other hand, we'll instantly set it as UI controlling hand and move the pointer to it.")]
		private bool autoSwitchHands = true;

		private void SwitchHandTo(CurvedUIInputModule.Hand newHand)
		{
			CurvedUIInputModule.Instance.UsedHand = newHand;
			if ((bool)CurvedUIInputModule.Instance.ControllerTransform)
			{
				LaserBeam.transform.SetParent(CurvedUIInputModule.Instance.ControllerTransform);
				LaserBeam.transform.ResetTransform();
				LaserBeam.transform.LookAt(LaserBeam.transform.position + CurvedUIInputModule.Instance.ControllerPointingDirection);
			}
			else
			{
				UnityEngine.Debug.LogError("CURVEDUI: No Active controller that can be used as a parent of the pointer. Is the controller gameobject present on the scene and active?");
			}
		}
	}
	public class CurvedUIInputFieldCaret : MonoBehaviour, ISelectHandler, IEventSystemHandler, IDeselectHandler
	{
		private InputField myField;

		private RectTransform myCaret;

		private Color origCaretColor;

		private Color origSelectionColor;

		private bool selected;

		private bool selectingText;

		private int lastCharDist = 2;

		public Color CaretColor
		{
			get
			{
				return origCaretColor;
			}
			set
			{
				origCaretColor = value;
			}
		}

		public Color SelectionColor
		{
			get
			{
				return origSelectionColor;
			}
			set
			{
				origSelectionColor = value;
			}
		}

		public float CaretBlinkRate
		{
			get
			{
				return myField.caretBlinkRate;
			}
			set
			{
				myField.caretBlinkRate = value;
			}
		}

		private void Awake()
		{
			myField = GetComponent<InputField>();
		}

		private void Update()
		{
			if (selected)
			{
				UpdateCaret();
			}
		}

		public void OnSelect(BaseEventData eventData)
		{
			if (myCaret == null)
			{
				CreateCaret();
			}
			selected = true;
			myCaret.gameObject.SetActive(value: true);
			StartCoroutine(CaretBlinker());
		}

		public void OnDeselect(BaseEventData eventData)
		{
			selected = false;
			myCaret.gameObject.SetActive(value: false);
		}

		private IEnumerator CaretBlinker()
		{
			while (selected)
			{
				myCaret.gameObject.SetActive(selectingText || !myCaret.gameObject.activeSelf);
				yield return new WaitForSeconds(0.5f / myField.caretBlinkRate);
			}
		}

		private void CreateCaret()
		{
			GameObject gameObject = new GameObject("CurvedUICaret");
			gameObject.AddComponent<RectTransform>();
			gameObject.AddComponent<Image>();
			gameObject.AddComponent<CurvedUIVertexEffect>();
			gameObject.transform.SetParent(base.transform);
			gameObject.transform.localScale = Vector3.one;
			(gameObject.transform as RectTransform).anchoredPosition3D = Vector3.zero;
			(gameObject.transform as RectTransform).pivot = new Vector2(0f, 1f);
			gameObject.GetComponent<Image>().color = myField.caretColor;
			myCaret = gameObject.transform as RectTransform;
			gameObject.transform.SetAsFirstSibling();
			myField.customCaretColor = true;
			origCaretColor = myField.caretColor;
			myField.caretColor = new Color(0f, 0f, 0f, 0f);
			origSelectionColor = myField.selectionColor;
			myField.selectionColor = new Color(0f, 0f, 0f, 0f);
			gameObject.gameObject.SetActive(value: false);
		}

		private void UpdateCaret()
		{
			if (myCaret == null)
			{
				CreateCaret();
			}
			Vector2 localPositionInText = GetLocalPositionInText(myField.caretPosition);
			if (myField.selectionFocusPosition != myField.selectionAnchorPosition)
			{
				selectingText = true;
				Vector2 vector = new Vector2(GetLocalPositionInText(myField.selectionAnchorPosition).x - GetLocalPositionInText(myField.selectionFocusPosition).x, GetLocalPositionInText(myField.selectionAnchorPosition).y - GetLocalPositionInText(myField.selectionFocusPosition).y);
				localPositionInText = ((vector.x < 0f) ? GetLocalPositionInText(myField.selectionAnchorPosition) : GetLocalPositionInText(myField.selectionFocusPosition));
				vector = new Vector2(Mathf.Abs(vector.x), Mathf.Abs(vector.y) + (float)myField.textComponent.fontSize);
				myCaret.sizeDelta = new Vector2(vector.x, vector.y);
				myCaret.anchoredPosition = localPositionInText;
				myCaret.GetComponent<Image>().color = origSelectionColor;
			}
			else
			{
				selectingText = false;
				myCaret.sizeDelta = new Vector2(myField.caretWidth, myField.textComponent.fontSize);
				myCaret.anchoredPosition = localPositionInText;
				myCaret.GetComponent<Image>().color = origCaretColor;
			}
		}

		private Vector2 GetLocalPositionInText(int charNo)
		{
			if (myField.isFocused)
			{
				TextGenerator cachedTextGenerator = myField.textComponent.cachedTextGenerator;
				if (charNo > cachedTextGenerator.characterCount - 1)
				{
					charNo = cachedTextGenerator.characterCount - 1;
				}
				if (charNo > 0)
				{
					UICharInfo uICharInfo = cachedTextGenerator.characters[charNo - 1];
					float x = (uICharInfo.cursorPos.x + uICharInfo.charWidth) / myField.textComponent.pixelsPerUnit + (float)lastCharDist;
					float y = uICharInfo.cursorPos.y / myField.textComponent.pixelsPerUnit;
					return new Vector2(x, y);
				}
				UICharInfo uICharInfo2 = cachedTextGenerator.characters[charNo];
				float x2 = uICharInfo2.cursorPos.x / myField.textComponent.pixelsPerUnit;
				float y2 = uICharInfo2.cursorPos.y / myField.textComponent.pixelsPerUnit;
				return new Vector2(x2, y2);
			}
			return Vector2.zero;
		}
	}
	public class CurvedUILaserBeam : MonoBehaviour
	{
		[SerializeField]
		private Transform LaserBeamTransform;

		[SerializeField]
		private Transform LaserBeamDot;

		[SerializeField]
		private bool CollideWithMyLayerOnly;

		[SerializeField]
		private bool hideWhenNotAimingAtCanvas;

		protected void Update()
		{
			Ray ray = new Ray(base.transform.position, base.transform.forward);
			if (!LaserBeamTransform || !LaserBeamDot)
			{
				return;
			}
			float num = 10000f;
			int layerMask = -1;
			if (CollideWithMyLayerOnly)
			{
				layerMask = 1 << base.gameObject.layer;
			}
			if (Physics.Raycast(ray, out var hitInfo, num, layerMask))
			{
				num = Vector3.Distance(hitInfo.point, base.transform.position);
				CurvedUISettings componentInParent = hitInfo.collider.GetComponentInParent<CurvedUISettings>();
				if (componentInParent != null)
				{
					num = ((componentInParent.GetObjectsUnderPointer().FindAll((GameObject x) => x != null && x.GetComponent<Graphic>() != null && x.GetComponent<Graphic>().depth != -1).Count == 0) ? 10000f : Vector3.Distance(hitInfo.point, base.transform.position));
				}
				else if (hideWhenNotAimingAtCanvas)
				{
					num = 0f;
				}
			}
			else if (hideWhenNotAimingAtCanvas)
			{
				num = 0f;
			}
			LaserBeamTransform.localScale = LaserBeamTransform.localScale.ModifyZ(num);
		}
	}
	public class CurvedUIPointerEventData : PointerEventData
	{
		public enum ControllerType
		{
			NONE = -1,
			VIVE
		}

		public GameObject Controller;

		public Vector2 TouchPadAxis = Vector2.zero;

		public CurvedUIPointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
		}
	}
	public class CurvedUIRaycaster : GraphicRaycaster
	{
		[SerializeField]
		private bool showDebug;

		private bool overrideEventData = true;

		private Canvas myCanvas;

		private CurvedUISettings mySettings;

		private Vector3 cyllinderMidPoint;

		private List<GameObject> objectsUnderPointer = new List<GameObject>();

		private Vector2 lastCanvasPos = Vector2.zero;

		private GameObject colliderContainer;

		private PointerEventData lastFrameEventData;

		private PointerEventData curEventData;

		private PointerEventData eventDataToUse;

		private Camera cachedWorldCamera;

		private Ray cachedRay;

		private Graphic gph;

		private List<GameObject> selectablesUnderGaze = new List<GameObject>();

		private List<GameObject> selectablesUnderGazeLastFrame = new List<GameObject>();

		private float objectsUnderGazeLastChangeTime;

		private bool gazeClickExecuted;

		private bool pointingAtCanvas;

		private bool pointingAtCanvasLastFrame;

		[NonSerialized]
		private List<Graphic> m_RaycastResults = new List<Graphic>();

		[NonSerialized]
		private static readonly List<Graphic> s_SortedGraphics = new List<Graphic>();

		private Image GazeProgressImage => CurvedUIInputModule.Instance.GazeTimedClickProgressImage;

		public bool PointingAtCanvas => pointingAtCanvas;

		protected override void Awake()
		{
			base.Awake();
			mySettings = GetComponentInParent<CurvedUISettings>();
			if (!(mySettings == null))
			{
				myCanvas = mySettings.GetComponent<Canvas>();
				cyllinderMidPoint = new Vector3(0f, 0f, 0f - mySettings.GetCyllinderRadiusInCanvasSpace());
				if (myCanvas.worldCamera == null && Camera.main != null)
				{
					myCanvas.worldCamera = Camera.main;
				}
				base.ignoreReversedGraphics = false;
			}
		}

		protected override void Start()
		{
			if (!(mySettings == null))
			{
				CreateCollider();
			}
		}

		protected virtual void Update()
		{
			if (mySettings == null)
			{
				return;
			}
			if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.GAZE && CurvedUIInputModule.Instance.GazeUseTimedClick)
			{
				if (pointingAtCanvas)
				{
					if (!pointingAtCanvasLastFrame)
					{
						ResetGazeTimedClick();
					}
					ProcessGazeTimedClick();
					selectablesUnderGazeLastFrame.Clear();
					selectablesUnderGazeLastFrame.AddRange(selectablesUnderGaze);
					selectablesUnderGaze.Clear();
					selectablesUnderGaze.AddRange(objectsUnderPointer);
					selectablesUnderGaze.RemoveAll((GameObject obj) => obj.GetComponent<Selectable>() == null || !obj.GetComponent<Selectable>().interactable);
					if ((bool)GazeProgressImage)
					{
						if (GazeProgressImage.type != Image.Type.Filled)
						{
							GazeProgressImage.type = Image.Type.Filled;
						}
						GazeProgressImage.fillAmount = (Time.time - objectsUnderGazeLastChangeTime).RemapAndClamp(CurvedUIInputModule.Instance.GazeClickTimerDelay, CurvedUIInputModule.Instance.GazeClickTimer + CurvedUIInputModule.Instance.GazeClickTimerDelay, 0f, 1f);
					}
				}
				else if (!pointingAtCanvas && pointingAtCanvasLastFrame)
				{
					ResetGazeTimedClick();
					if ((bool)GazeProgressImage)
					{
						GazeProgressImage.fillAmount = 0f;
					}
				}
			}
			pointingAtCanvasLastFrame = pointingAtCanvas;
			pointingAtCanvas = false;
		}

		private void ProcessGazeTimedClick()
		{
			if (selectablesUnderGazeLastFrame.Count == 0 || selectablesUnderGazeLastFrame.Count != selectablesUnderGaze.Count)
			{
				ResetGazeTimedClick();
				return;
			}
			for (int i = 0; i < selectablesUnderGazeLastFrame.Count && i < selectablesUnderGaze.Count; i++)
			{
				if (selectablesUnderGazeLastFrame[i].GetInstanceID() != selectablesUnderGaze[i].GetInstanceID())
				{
					ResetGazeTimedClick();
					return;
				}
			}
			if (!gazeClickExecuted && Time.time > objectsUnderGazeLastChangeTime + CurvedUIInputModule.Instance.GazeClickTimer + CurvedUIInputModule.Instance.GazeClickTimerDelay)
			{
				Click();
				gazeClickExecuted = true;
			}
		}

		private void ResetGazeTimedClick()
		{
			objectsUnderGazeLastChangeTime = Time.time;
			gazeClickExecuted = false;
		}

		public override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (mySettings == null)
			{
				base.Raycast(eventData, resultAppendList);
			}
			else
			{
				if (!mySettings.Interactable)
				{
					return;
				}
				if (myCanvas.worldCamera == null)
				{
					if ((bool)Camera.main)
					{
						myCanvas.worldCamera = Camera.main;
					}
					if (myCanvas.worldCamera == null)
					{
						UnityEngine.Debug.LogWarning("CurvedUI: No WORLD CAMERA assigned to Canvas " + base.gameObject.name + " to use for event processing!", myCanvas.gameObject);
						return;
					}
				}
				cachedWorldCamera = myCanvas.worldCamera;
				switch (CurvedUIInputModule.ControlMethod)
				{
				case CurvedUIInputModule.CUIControlMethod.MOUSE:
					cachedRay = cachedWorldCamera.ScreenPointToRay(eventData.position);
					break;
				case CurvedUIInputModule.CUIControlMethod.GAZE:
					cachedRay = new Ray(cachedWorldCamera.transform.position, cachedWorldCamera.transform.forward);
					UpdateSelectedObjects(eventData);
					break;
				case CurvedUIInputModule.CUIControlMethod.WORLD_MOUSE:
					cachedRay = new Ray(cachedWorldCamera.transform.position, mySettings.CanvasToCurvedCanvas(CurvedUIInputModule.Instance.WorldSpaceMouseInCanvasSpace) - myCanvas.worldCamera.transform.position);
					break;
				case CurvedUIInputModule.CUIControlMethod.STEAMVR_LEGACY:
					cachedRay = new Ray(CurvedUIInputModule.Instance.ControllerPointingOrigin, CurvedUIInputModule.Instance.ControllerPointingDirection);
					break;
				case CurvedUIInputModule.CUIControlMethod.GOOGLEVR:
					cachedRay = new Ray(CurvedUIInputModule.Instance.ControllerPointingOrigin, CurvedUIInputModule.Instance.ControllerPointingDirection);
					break;
				case CurvedUIInputModule.CUIControlMethod.CUSTOM_RAY:
				case CurvedUIInputModule.CUIControlMethod.OCULUSVR:
				case CurvedUIInputModule.CUIControlMethod.STEAMVR_2:
					cachedRay = CurvedUIInputModule.CustomControllerRay;
					break;
				default:
					cachedRay = default(Ray);
					break;
				}
				if (curEventData == null)
				{
					curEventData = new PointerEventData(EventSystem.current);
				}
				if (!overrideEventData)
				{
					curEventData.pointerEnter = eventData.pointerEnter;
					curEventData.rawPointerPress = eventData.rawPointerPress;
					curEventData.pointerDrag = eventData.pointerDrag;
					curEventData.pointerCurrentRaycast = eventData.pointerCurrentRaycast;
					curEventData.pointerPressRaycast = eventData.pointerPressRaycast;
					curEventData.hovered.Clear();
					curEventData.hovered.AddRange(eventData.hovered);
					curEventData.eligibleForClick = eventData.eligibleForClick;
					curEventData.pointerId = eventData.pointerId;
					curEventData.position = eventData.position;
					curEventData.delta = eventData.delta;
					curEventData.pressPosition = eventData.pressPosition;
					curEventData.clickTime = eventData.clickTime;
					curEventData.clickCount = eventData.clickCount;
					curEventData.scrollDelta = eventData.scrollDelta;
					curEventData.useDragThreshold = eventData.useDragThreshold;
					curEventData.dragging = eventData.dragging;
					curEventData.button = eventData.button;
				}
				if (mySettings.Angle != 0 && mySettings.enabled)
				{
					Vector2 o_canvasPos = eventData.position;
					switch (mySettings.Shape)
					{
					case CurvedUISettings.CurvedUIShape.CYLINDER:
						if (!RaycastToCyllinderCanvas(cachedRay, out o_canvasPos))
						{
							return;
						}
						break;
					case CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL:
						if (!RaycastToCyllinderVerticalCanvas(cachedRay, out o_canvasPos))
						{
							return;
						}
						break;
					case CurvedUISettings.CurvedUIShape.RING:
						if (!RaycastToRingCanvas(cachedRay, out o_canvasPos))
						{
							return;
						}
						break;
					case CurvedUISettings.CurvedUIShape.SPHERE:
						if (!RaycastToSphereCanvas(cachedRay, out o_canvasPos))
						{
							return;
						}
						break;
					}
					pointingAtCanvas = true;
					eventDataToUse = (overrideEventData ? eventData : curEventData);
					if (eventDataToUse.pressPosition == eventDataToUse.position)
					{
						eventDataToUse.pressPosition = o_canvasPos;
					}
					eventDataToUse.position = o_canvasPos;
					if (CurvedUIInputModule.ControlMethod == CurvedUIInputModule.CUIControlMethod.STEAMVR_LEGACY)
					{
						eventDataToUse.delta = o_canvasPos - lastCanvasPos;
						lastCanvasPos = o_canvasPos;
					}
				}
				objectsUnderPointer = eventData.hovered;
				lastFrameEventData = eventData;
				FlatRaycast(overrideEventData ? eventData : curEventData, resultAppendList);
			}
		}

		public virtual bool RaycastToCyllinderCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false)
		{
			if (showDebug)
			{
				UnityEngine.Debug.DrawLine(ray3D.origin, ray3D.GetPoint(1000f), Color.red);
			}
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, GetLayerMaskForMyLayer()))
			{
				if (overrideEventData && hitInfo.collider.gameObject != base.gameObject && (colliderContainer == null || hitInfo.collider.transform.parent != colliderContainer.transform))
				{
					o_canvasPos = Vector2.zero;
					return false;
				}
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 normalized = (vector - cyllinderMidPoint).normalized;
				float value = 0f - AngleSigned(normalized.ModifyY(0f), (mySettings.Angle < 0) ? Vector3.back : Vector3.forward, Vector3.up);
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				Vector2 vector2 = new Vector3(0f, 0f, 0f);
				vector2.x = value.Remap((float)(-mySettings.Angle) / 2f, (float)mySettings.Angle / 2f, (0f - size.x) / 2f, size.x / 2f);
				vector2.y = vector.y;
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector2;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2));
				}
				if (showDebug)
				{
					UnityEngine.Debug.DrawLine(hitInfo.point, hitInfo.point.ModifyY(hitInfo.point.y + 10f), Color.green);
					UnityEngine.Debug.DrawLine(hitInfo.point, myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(cyllinderMidPoint), Color.yellow);
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		public virtual bool RaycastToCyllinderVerticalCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false)
		{
			if (showDebug)
			{
				UnityEngine.Debug.DrawLine(ray3D.origin, ray3D.GetPoint(1000f), Color.red);
			}
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, GetLayerMaskForMyLayer()))
			{
				if (overrideEventData && hitInfo.collider.gameObject != base.gameObject && (colliderContainer == null || hitInfo.collider.transform.parent != colliderContainer.transform))
				{
					o_canvasPos = Vector2.zero;
					return false;
				}
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 normalized = (vector - cyllinderMidPoint).normalized;
				float value = 0f - AngleSigned(normalized.ModifyX(0f), (mySettings.Angle < 0) ? Vector3.back : Vector3.forward, Vector3.left);
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				Vector2 vector2 = new Vector3(0f, 0f, 0f);
				vector2.y = value.Remap((float)(-mySettings.Angle) / 2f, (float)mySettings.Angle / 2f, (0f - size.y) / 2f, size.y / 2f);
				vector2.x = vector.x;
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector2;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2));
				}
				if (showDebug)
				{
					UnityEngine.Debug.DrawLine(hitInfo.point, hitInfo.point.ModifyY(hitInfo.point.y + 10f), Color.green);
					UnityEngine.Debug.DrawLine(hitInfo.point, myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(cyllinderMidPoint), Color.yellow);
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		public virtual bool RaycastToRingCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false)
		{
			LayerMask layerMaskForMyLayer = GetLayerMaskForMyLayer();
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, layerMaskForMyLayer))
			{
				if (overrideEventData && hitInfo.collider.gameObject != base.gameObject && (colliderContainer == null || hitInfo.collider.transform.parent != colliderContainer.transform))
				{
					o_canvasPos = Vector2.zero;
					return false;
				}
				Vector3 trans = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 normalized = trans.ModifyZ(0f).normalized;
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				float num = 0f - AngleSigned(normalized.ModifyZ(0f), Vector3.up, Vector3.back);
				Vector2 vector = new Vector2(0f, 0f);
				if (showDebug)
				{
					UnityEngine.Debug.Log("angle: " + num);
				}
				if (num < 0f)
				{
					vector.x = num.Remap(0f, -mySettings.Angle, (0f - size.x) / 2f, size.x / 2f);
				}
				else
				{
					vector.x = num.Remap(360f, 360 - mySettings.Angle, (0f - size.x) / 2f, size.x / 2f);
				}
				vector.y = trans.magnitude.Remap((float)mySettings.RingExternalDiameter * 0.5f * (1f - mySettings.RingFill), (float)mySettings.RingExternalDiameter * 0.5f, (0f - size.y) * 0.5f * (float)((!mySettings.RingFlipVertical) ? 1 : (-1)), size.y * 0.5f * (float)((!mySettings.RingFlipVertical) ? 1 : (-1)));
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector));
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		public virtual bool RaycastToSphereCanvas(Ray ray3D, out Vector2 o_canvasPos, bool OutputInCanvasSpace = false)
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray3D, out hitInfo, float.PositiveInfinity, GetLayerMaskForMyLayer()))
			{
				if (overrideEventData && hitInfo.collider.gameObject != base.gameObject && (colliderContainer == null || hitInfo.collider.transform.parent != colliderContainer.transform))
				{
					o_canvasPos = Vector2.zero;
					return false;
				}
				Vector2 size = myCanvas.GetComponent<RectTransform>().rect.size;
				float num = (mySettings.PreserveAspect ? mySettings.GetCyllinderRadiusInCanvasSpace() : (size.x / 2f));
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(hitInfo.point);
				Vector3 vector2 = new Vector3(0f, 0f, mySettings.PreserveAspect ? (0f - num) : 0f);
				Vector3 normalized = (vector - vector2).normalized;
				Vector3 vector3 = Vector3.Cross(normalized, normalized.ModifyY(0f)).normalized * ((normalized.y < 0f) ? 1 : (-1));
				float value = 0f - AngleSigned(normalized.ModifyY(0f), (mySettings.Angle > 0) ? Vector3.forward : Vector3.back, (mySettings.Angle > 0) ? Vector3.up : Vector3.down);
				float value2 = 0f - AngleSigned(normalized, normalized.ModifyY(0f), vector3);
				float num2 = (float)Mathf.Abs(mySettings.Angle) * 0.5f;
				float num3 = Mathf.Abs(mySettings.PreserveAspect ? (num2 * size.y / size.x) : ((float)mySettings.VerticalAngle * 0.5f));
				Vector2 vector4 = new Vector2(value.Remap(0f - num2, num2, (0f - size.x) * 0.5f, size.x * 0.5f), value2.Remap(0f - num3, num3, (0f - size.y) * 0.5f, size.y * 0.5f));
				if (showDebug)
				{
					string[] obj = new string[6]
					{
						"h: ",
						value.ToString(),
						" / v: ",
						value2.ToString(),
						" poc: ",
						null
					};
					Vector2 vector5 = vector4;
					obj[5] = vector5.ToString();
					UnityEngine.Debug.Log(string.Concat(obj));
					UnityEngine.Debug.DrawRay(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2), myCanvas.transform.localToWorldMatrix.MultiplyVector(normalized) * Mathf.Abs(num), Color.red);
					UnityEngine.Debug.DrawRay(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector2), myCanvas.transform.localToWorldMatrix.MultiplyVector(vector3) * 300f, Color.magenta);
				}
				if (OutputInCanvasSpace)
				{
					o_canvasPos = vector4;
				}
				else
				{
					o_canvasPos = myCanvas.worldCamera.WorldToScreenPoint(myCanvas.transform.localToWorldMatrix.MultiplyPoint3x4(vector4));
				}
				return true;
			}
			o_canvasPos = Vector2.zero;
			return false;
		}

		private void FlatRaycast(PointerEventData eventData, List<RaycastResult> resultAppendList)
		{
			if (myCanvas == null)
			{
				return;
			}
			IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(myCanvas);
			if (graphicsForCanvas == null || graphicsForCanvas.Count == 0)
			{
				return;
			}
			Camera camera = eventCamera;
			int num = ((myCanvas.renderMode != 0 && !(camera == null)) ? camera.targetDisplay : myCanvas.targetDisplay);
			Vector3 vector = Display.RelativeMouseAt(eventData.position);
			if (vector != Vector3.zero)
			{
				if ((int)vector.z != num)
				{
					return;
				}
			}
			else
			{
				vector = eventData.position;
			}
			m_RaycastResults.Clear();
			FlatRaycastAndSort(myCanvas, camera, vector, graphicsForCanvas, m_RaycastResults);
			Ray ray = default(Ray);
			if (camera != null)
			{
				ray = camera.ScreenPointToRay(vector);
			}
			float num2 = float.MaxValue;
			int count = m_RaycastResults.Count;
			for (int i = 0; i < count; i++)
			{
				GameObject gameObject = m_RaycastResults[i].gameObject;
				Transform transform = gameObject.transform;
				Vector3 forward = transform.forward;
				float num3 = Vector3.Dot(forward, transform.position - ray.origin) / Vector3.Dot(forward, ray.direction);
				if (!(num3 < 0f) && !(num3 >= num2))
				{
					RaycastResult raycastResult = default(RaycastResult);
					raycastResult.gameObject = gameObject;
					raycastResult.module = this;
					raycastResult.distance = num3;
					raycastResult.screenPosition = vector;
					raycastResult.index = resultAppendList.Count;
					raycastResult.depth = m_RaycastResults[i].depth;
					raycastResult.sortingLayer = myCanvas.sortingLayerID;
					raycastResult.sortingOrder = myCanvas.sortingOrder;
					RaycastResult item = raycastResult;
					resultAppendList.Add(item);
				}
			}
		}

		private static void FlatRaycastAndSort(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)
		{
			int count = foundGraphics.Count;
			for (int i = 0; i < count; i++)
			{
				Graphic graphic = foundGraphics[i];
				if (graphic.depth != -1 && graphic.raycastTarget && !graphic.canvasRenderer.cull && RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera) && (!(eventCamera != null) || !(eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z > eventCamera.farClipPlane)) && graphic.Raycast(pointerPosition, eventCamera))
				{
					s_SortedGraphics.Add(graphic);
				}
			}
			s_SortedGraphics.Sort((Graphic g1, Graphic g2) => g2.depth.CompareTo(g1.depth));
			count = s_SortedGraphics.Count;
			for (int j = 0; j < count; j++)
			{
				results.Add(s_SortedGraphics[j]);
			}
			s_SortedGraphics.Clear();
		}

		protected void CreateCollider()
		{
			List<Collider> list = new List<Collider>();
			list.AddRange(GetComponents<Collider>());
			for (int i = 0; i < list.Count; i++)
			{
				UnityEngine.Object.Destroy(list[i]);
			}
			if (!mySettings.BlocksRaycasts || (mySettings.Shape == CurvedUISettings.CurvedUIShape.SPHERE && !mySettings.PreserveAspect && mySettings.VerticalAngle == 0))
			{
				return;
			}
			switch (mySettings.Shape)
			{
			case CurvedUISettings.CurvedUIShape.CYLINDER:
				if (mySettings.ForceUseBoxCollider || GetComponent<Rigidbody>() != null || GetComponentInParent<Rigidbody>() != null)
				{
					if (colliderContainer != null)
					{
						UnityEngine.Object.Destroy(colliderContainer);
					}
					colliderContainer = CreateConvexCyllinderCollider();
				}
				else
				{
					SetupMeshColliderUsingMesh(CreateCyllinderColliderMesh());
				}
				break;
			case CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL:
				if (mySettings.ForceUseBoxCollider || GetComponent<Rigidbody>() != null || GetComponentInParent<Rigidbody>() != null)
				{
					if (colliderContainer != null)
					{
						UnityEngine.Object.Destroy(colliderContainer);
					}
					colliderContainer = CreateConvexCyllinderCollider(vertical: true);
				}
				else
				{
					SetupMeshColliderUsingMesh(CreateCyllinderColliderMesh(vertical: true));
				}
				break;
			case CurvedUISettings.CurvedUIShape.RING:
				base.gameObject.AddComponent<BoxCollider>().size = new Vector3(mySettings.RingExternalDiameter, mySettings.RingExternalDiameter, 1f);
				break;
			case CurvedUISettings.CurvedUIShape.SPHERE:
				if (GetComponent<Rigidbody>() != null || GetComponentInParent<Rigidbody>() != null)
				{
					UnityEngine.Debug.LogWarning("CurvedUI: Sphere shape canvases as children of rigidbodies do not support user input. Switch to Cyllinder shape or remove the rigidbody from parent.", base.gameObject);
				}
				SetupMeshColliderUsingMesh(CreateSphereColliderMesh());
				break;
			}
		}

		private void SetupMeshColliderUsingMesh(Mesh meshie)
		{
			MeshFilter meshFilter = this.AddComponentIfMissing<MeshFilter>();
			MeshCollider meshCollider = base.gameObject.AddComponent<MeshCollider>();
			meshFilter.mesh = meshie;
			meshCollider.sharedMesh = meshie;
		}

		private GameObject CreateConvexCyllinderCollider(bool vertical = false)
		{
			GameObject gameObject = new GameObject("_CurvedUIColliders");
			gameObject.layer = base.gameObject.layer;
			gameObject.transform.SetParent(base.transform);
			gameObject.transform.ResetTransform();
			Mesh mesh = new Mesh();
			Vector3[] array = new Vector3[4];
			(myCanvas.transform as RectTransform).GetWorldCorners(array);
			mesh.vertices = array;
			if (vertical)
			{
				array[0] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[1]);
				array[1] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[2]);
				array[2] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[0]);
				array[3] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[3]);
			}
			else
			{
				array[0] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[1]);
				array[1] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[0]);
				array[2] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[2]);
				array[3] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[3]);
			}
			mesh.vertices = array;
			List<Vector3> list = new List<Vector3>();
			int num = Mathf.Max(8, Mathf.RoundToInt((float)(mySettings.BaseCircleSegments * Mathf.Abs(mySettings.Angle)) / 360f));
			for (int i = 0; i < num; i++)
			{
				list.Add(Vector3.Lerp(mesh.vertices[0], mesh.vertices[2], (float)i * 1f / (float)(num - 1)));
			}
			if (mySettings.Angle != 0)
			{
				Rect rect = myCanvas.GetComponent<RectTransform>().rect;
				float cyllinderRadiusInCanvasSpace = mySettings.GetCyllinderRadiusInCanvasSpace();
				for (int j = 0; j < list.Count; j++)
				{
					Vector3 value = list[j];
					if (vertical)
					{
						float f = list[j].y / rect.size.y * (float)mySettings.Angle * ((float)Math.PI / 180f);
						value.y = Mathf.Sin(f) * cyllinderRadiusInCanvasSpace;
						value.z += Mathf.Cos(f) * cyllinderRadiusInCanvasSpace - cyllinderRadiusInCanvasSpace;
						list[j] = value;
					}
					else
					{
						float f2 = list[j].x / rect.size.x * (float)mySettings.Angle * ((float)Math.PI / 180f);
						value.x = Mathf.Sin(f2) * cyllinderRadiusInCanvasSpace;
						value.z += Mathf.Cos(f2) * cyllinderRadiusInCanvasSpace - cyllinderRadiusInCanvasSpace;
						list[j] = value;
					}
				}
			}
			float x = mySettings.GetTesslationSize(modifiedByQuality: false).x / 10f;
			for (int k = 0; k < list.Count - 1; k++)
			{
				GameObject gameObject2 = new GameObject("Box collider");
				gameObject2.layer = base.gameObject.layer;
				gameObject2.transform.SetParent(gameObject.transform);
				gameObject2.transform.ResetTransform();
				gameObject2.AddComponent<BoxCollider>();
				if (vertical)
				{
					gameObject2.transform.localPosition = new Vector3(0f, (list[k + 1].y + list[k].y) * 0.5f, (list[k + 1].z + list[k].z) * 0.5f);
					gameObject2.transform.localScale = new Vector3(x, Vector3.Distance(array[0], array[1]), Vector3.Distance(list[k + 1], list[k]));
					gameObject2.transform.localRotation = Quaternion.LookRotation(list[k + 1] - list[k], array[0] - array[1]);
				}
				else
				{
					gameObject2.transform.localPosition = new Vector3((list[k + 1].x + list[k].x) * 0.5f, 0f, (list[k + 1].z + list[k].z) * 0.5f);
					gameObject2.transform.localScale = new Vector3(x, Vector3.Distance(array[0], array[1]), Vector3.Distance(list[k + 1], list[k]));
					gameObject2.transform.localRotation = Quaternion.LookRotation(list[k + 1] - list[k], array[0] - array[1]);
				}
			}
			return gameObject;
		}

		private Mesh CreateCyllinderColliderMesh(bool vertical = false)
		{
			Mesh mesh = new Mesh();
			Vector3[] array = new Vector3[4];
			(myCanvas.transform as RectTransform).GetWorldCorners(array);
			mesh.vertices = array;
			if (vertical)
			{
				array[0] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[1]);
				array[1] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[2]);
				array[2] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[0]);
				array[3] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[3]);
			}
			else
			{
				array[0] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[1]);
				array[1] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[0]);
				array[2] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[2]);
				array[3] = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(mesh.vertices[3]);
			}
			mesh.vertices = array;
			List<Vector3> list = new List<Vector3>();
			int num = Mathf.Max(8, Mathf.RoundToInt((float)(mySettings.BaseCircleSegments * Mathf.Abs(mySettings.Angle)) / 360f));
			for (int i = 0; i < num; i++)
			{
				list.Add(Vector3.Lerp(mesh.vertices[0], mesh.vertices[2], (float)i * 1f / (float)(num - 1)));
				list.Add(Vector3.Lerp(mesh.vertices[1], mesh.vertices[3], (float)i * 1f / (float)(num - 1)));
			}
			if (mySettings.Angle != 0)
			{
				Rect rect = myCanvas.GetComponent<RectTransform>().rect;
				float cyllinderRadiusInCanvasSpace = mySettings.GetCyllinderRadiusInCanvasSpace();
				for (int j = 0; j < list.Count; j++)
				{
					Vector3 value = list[j];
					if (vertical)
					{
						float f = list[j].y / rect.size.y * (float)mySettings.Angle * ((float)Math.PI / 180f);
						value.y = Mathf.Sin(f) * cyllinderRadiusInCanvasSpace;
						value.z += Mathf.Cos(f) * cyllinderRadiusInCanvasSpace - cyllinderRadiusInCanvasSpace;
						list[j] = value;
					}
					else
					{
						float f2 = list[j].x / rect.size.x * (float)mySettings.Angle * ((float)Math.PI / 180f);
						value.x = Mathf.Sin(f2) * cyllinderRadiusInCanvasSpace;
						value.z += Mathf.Cos(f2) * cyllinderRadiusInCanvasSpace - cyllinderRadiusInCanvasSpace;
						list[j] = value;
					}
				}
			}
			mesh.vertices = list.ToArray();
			List<int> list2 = new List<int>();
			for (int k = 0; k < list.Count / 2 - 1; k++)
			{
				if (vertical)
				{
					list2.Add(k * 2);
					list2.Add(k * 2 + 1);
					list2.Add(k * 2 + 2);
					list2.Add(k * 2 + 1);
					list2.Add(k * 2 + 3);
					list2.Add(k * 2 + 2);
				}
				else
				{
					list2.Add(k * 2 + 2);
					list2.Add(k * 2 + 1);
					list2.Add(k * 2);
					list2.Add(k * 2 + 2);
					list2.Add(k * 2 + 3);
					list2.Add(k * 2 + 1);
				}
			}
			mesh.triangles = list2.ToArray();
			return mesh;
		}

		private Mesh CreateSphereColliderMesh()
		{
			Mesh mesh = new Mesh();
			Vector3[] array = new Vector3[4];
			(myCanvas.transform as RectTransform).GetWorldCorners(array);
			List<Vector3> list = new List<Vector3>(array);
			for (int i = 0; i < list.Count; i++)
			{
				list[i] = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(list[i]);
			}
			if (mySettings.Angle != 0)
			{
				int count = list.Count;
				for (int j = 0; j < count; j += 4)
				{
					ModifyQuad(list, j, mySettings.GetTesslationSize(modifiedByQuality: false));
				}
				list.RemoveRange(0, count);
				float num = mySettings.VerticalAngle;
				float num2 = mySettings.Angle;
				Vector2 size = (myCanvas.transform as RectTransform).rect.size;
				float num3 = mySettings.GetCyllinderRadiusInCanvasSpace();
				if (mySettings.PreserveAspect)
				{
					num = (float)mySettings.Angle * (size.y / size.x);
				}
				else
				{
					num3 = size.x / 2f;
				}
				for (int k = 0; k < list.Count; k++)
				{
					float num4 = (list[k].x / size.x).Remap(-0.5f, 0.5f, (180f - num2) / 2f - 90f, 180f - (180f - num2) / 2f - 90f);
					num4 *= (float)Math.PI / 180f;
					float num5 = (list[k].y / size.y).Remap(-0.5f, 0.5f, (180f - num) / 2f, 180f - (180f - num) / 2f);
					num5 *= (float)Math.PI / 180f;
					list[k] = new Vector3(Mathf.Sin(num5) * Mathf.Sin(num4) * num3, (0f - num3) * Mathf.Cos(num5), Mathf.Sin(num5) * Mathf.Cos(num4) * num3 + (mySettings.PreserveAspect ? (0f - num3) : 0f));
				}
			}
			mesh.vertices = list.ToArray();
			List<int> list2 = new List<int>();
			for (int l = 0; l < list.Count; l += 4)
			{
				list2.Add(l);
				list2.Add(l + 1);
				list2.Add(l + 2);
				list2.Add(l + 3);
				list2.Add(l);
				list2.Add(l + 2);
			}
			mesh.triangles = list2.ToArray();
			return mesh;
		}

		private bool IsInLayerMask(int layer, LayerMask layermask)
		{
			return (int)layermask == ((int)layermask | (1 << layer));
		}

		private LayerMask GetLayerMaskForMyLayer()
		{
			int num = -1;
			if (mySettings.RaycastMyLayerOnly)
			{
				num = 1 << base.gameObject.layer;
			}
			return num;
		}

		private float AngleSigned(Vector3 v1, Vector3 v2, Vector3 n)
		{
			return Mathf.Atan2(Vector3.Dot(n, Vector3.Cross(v1, v2)), Vector3.Dot(v1, v2)) * 57.29578f;
		}

		private bool ShouldStartDrag(Vector2 pressPos, Vector2 currentPos, float threshold, bool useDragThreshold)
		{
			if (!useDragThreshold)
			{
				return true;
			}
			return (pressPos - currentPos).sqrMagnitude >= threshold * threshold;
		}

		protected virtual void ProcessMove(PointerEventData pointerEvent)
		{
			GameObject newEnterTarget = pointerEvent.pointerCurrentRaycast.gameObject;
			HandlePointerExitAndEnter(pointerEvent, newEnterTarget);
		}

		protected void UpdateSelectedObjects(PointerEventData eventData)
		{
			bool flag = false;
			foreach (GameObject item in eventData.hovered)
			{
				if (item == eventData.selectedObject)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				eventData.selectedObject = null;
			}
			foreach (GameObject item2 in eventData.hovered)
			{
				if (item2 == null)
				{
					continue;
				}
				gph = item2.GetComponent<Graphic>();
				if (item2.GetComponent<Selectable>() != null && gph != null && gph.depth != -1 && gph.raycastTarget)
				{
					if (eventData.selectedObject != item2)
					{
						eventData.selectedObject = item2;
					}
					break;
				}
			}
			if (mySettings.ControlMethod == CurvedUIInputModule.CUIControlMethod.GAZE && eventData.IsPointerMoving() && eventData.pointerDrag != null && !eventData.dragging && ShouldStartDrag(eventData.pressPosition, eventData.position, EventSystem.current.pixelDragThreshold, eventData.useDragThreshold))
			{
				ExecuteEvents.Execute(eventData.pointerDrag, eventData, ExecuteEvents.beginDragHandler);
				eventData.dragging = true;
			}
		}

		protected void HandlePointerExitAndEnter(PointerEventData currentPointerData, GameObject newEnterTarget)
		{
			if (newEnterTarget == null || currentPointerData.pointerEnter == null)
			{
				for (int i = 0; i < currentPointerData.hovered.Count; i++)
				{
					ExecuteEvents.Execute(currentPointerData.hovered[i], currentPointerData, ExecuteEvents.pointerExitHandler);
				}
				currentPointerData.hovered.Clear();
				if (newEnterTarget == null)
				{
					currentPointerData.pointerEnter = newEnterTarget;
					return;
				}
			}
			if (currentPointerData.pointerEnter == newEnterTarget && (bool)newEnterTarget)
			{
				return;
			}
			GameObject gameObject = FindCommonRoot(currentPointerData.pointerEnter, newEnterTarget);
			if (currentPointerData.pointerEnter != null)
			{
				Transform parent = currentPointerData.pointerEnter.transform;
				while (parent != null && (!(gameObject != null) || !(gameObject.transform == parent)))
				{
					ExecuteEvents.Execute(parent.gameObject, currentPointerData, ExecuteEvents.pointerExitHandler);
					currentPointerData.hovered.Remove(parent.gameObject);
					parent = parent.parent;
				}
			}
			currentPointerData.pointerEnter = newEnterTarget;
			if (newEnterTarget != null)
			{
				Transform parent2 = newEnterTarget.transform;
				while (parent2 != null && parent2.gameObject != gameObject)
				{
					ExecuteEvents.Execute(parent2.gameObject, currentPointerData, ExecuteEvents.pointerEnterHandler);
					currentPointerData.hovered.Add(parent2.gameObject);
					parent2 = parent2.parent;
				}
			}
		}

		protected static GameObject FindCommonRoot(GameObject g1, GameObject g2)
		{
			if (g1 == null || g2 == null)
			{
				return null;
			}
			Transform parent = g1.transform;
			while (parent != null)
			{
				Transform parent2 = g2.transform;
				while (parent2 != null)
				{
					if (parent == parent2)
					{
						return parent.gameObject;
					}
					parent2 = parent2.parent;
				}
				parent = parent.parent;
			}
			return null;
		}

		private bool GetScreenSpacePointByRay(Ray ray, out Vector2 o_positionOnCanvas)
		{
			switch (mySettings.Shape)
			{
			case CurvedUISettings.CurvedUIShape.CYLINDER:
				return RaycastToCyllinderCanvas(ray, out o_positionOnCanvas);
			case CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL:
				return RaycastToCyllinderVerticalCanvas(ray, out o_positionOnCanvas);
			case CurvedUISettings.CurvedUIShape.RING:
				return RaycastToRingCanvas(ray, out o_positionOnCanvas);
			case CurvedUISettings.CurvedUIShape.SPHERE:
				return RaycastToSphereCanvas(ray, out o_positionOnCanvas);
			default:
				o_positionOnCanvas = Vector2.zero;
				return false;
			}
		}

		public void RebuildCollider()
		{
			cyllinderMidPoint = new Vector3(0f, 0f, 0f - mySettings.GetCyllinderRadiusInCanvasSpace());
			CreateCollider();
		}

		public List<GameObject> GetObjectsUnderPointer()
		{
			if (objectsUnderPointer == null)
			{
				objectsUnderPointer = new List<GameObject>();
			}
			return objectsUnderPointer;
		}

		public List<GameObject> GetObjectsUnderScreenPos(Vector2 screenPos, Camera eventCamera = null)
		{
			if (eventCamera == null)
			{
				eventCamera = myCanvas.worldCamera;
			}
			return GetObjectsHitByRay(eventCamera.ScreenPointToRay(screenPos));
		}

		public List<GameObject> GetObjectsHitByRay(Ray ray)
		{
			List<GameObject> list = new List<GameObject>();
			if (!GetScreenSpacePointByRay(ray, out var o_positionOnCanvas))
			{
				return list;
			}
			List<Graphic> list2 = new List<Graphic>();
			IList<Graphic> graphicsForCanvas = GraphicRegistry.GetGraphicsForCanvas(myCanvas);
			for (int i = 0; i < graphicsForCanvas.Count; i++)
			{
				Graphic graphic = graphicsForCanvas[i];
				if (graphic.depth != -1 && graphic.raycastTarget && RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, o_positionOnCanvas, eventCamera) && graphic.Raycast(o_positionOnCanvas, eventCamera))
				{
					list2.Add(graphic);
				}
			}
			list2.Sort((Graphic g1, Graphic g2) => g2.depth.CompareTo(g1.depth));
			for (int j = 0; j < list2.Count; j++)
			{
				list.Add(list2[j].gameObject);
			}
			list2.Clear();
			return list;
		}

		public void Click()
		{
			for (int i = 0; i < GetObjectsUnderPointer().Count; i++)
			{
				if ((bool)GetObjectsUnderPointer()[i].GetComponent<Slider>())
				{
					Slider component = GetObjectsUnderPointer()[i].GetComponent<Slider>();
					RectTransformUtility.ScreenPointToLocalPointInRectangle(component.handleRect.parent as RectTransform, lastFrameEventData.position, myCanvas.worldCamera, out var localPoint);
					localPoint -= component.handleRect.parent.GetComponent<RectTransform>().rect.position;
					if (component.direction == Slider.Direction.LeftToRight || component.direction == Slider.Direction.RightToLeft)
					{
						component.normalizedValue = localPoint.x / (component.handleRect.parent as RectTransform).rect.width;
					}
					else
					{
						component.normalizedValue = localPoint.y / (component.handleRect.parent as RectTransform).rect.height;
					}
					GetObjectsUnderPointer()[i].GetComponent<Slider>().fillRect.GetComponent<Graphic>().SetAllDirty();
				}
				else
				{
					ExecuteEvents.Execute(GetObjectsUnderPointer()[i], lastFrameEventData, ExecuteEvents.pointerDownHandler);
					ExecuteEvents.Execute(GetObjectsUnderPointer()[i], lastFrameEventData, ExecuteEvents.pointerClickHandler);
					ExecuteEvents.Execute(GetObjectsUnderPointer()[i], lastFrameEventData, ExecuteEvents.pointerUpHandler);
				}
			}
		}

		private void ModifyQuad(List<Vector3> verts, int vertexIndex, Vector2 requiredSize)
		{
			List<Vector3> list = new List<Vector3>();
			for (int i = 0; i < 4; i++)
			{
				list.Add(verts[vertexIndex + i]);
			}
			Vector3 vector = list[2] - list[1];
			Vector3 vector2 = list[1] - list[0];
			int num = Mathf.CeilToInt(vector.magnitude * (1f / Mathf.Max(1f, requiredSize.x)));
			int num2 = Mathf.CeilToInt(vector2.magnitude * (1f / Mathf.Max(1f, requiredSize.y)));
			float y = 0f;
			for (int j = 0; j < num2; j++)
			{
				float num3 = ((float)j + 1f) / (float)num2;
				float x = 0f;
				for (int k = 0; k < num; k++)
				{
					float num4 = ((float)k + 1f) / (float)num;
					verts.Add(TesselateQuad(list, x, y));
					verts.Add(TesselateQuad(list, x, num3));
					verts.Add(TesselateQuad(list, num4, num3));
					verts.Add(TesselateQuad(list, num4, y));
					x = num4;
				}
				y = num3;
			}
		}

		private Vector3 TesselateQuad(List<Vector3> quad, float x, float y)
		{
			Vector3 zero = Vector3.zero;
			List<float> list = new List<float>
			{
				(1f - x) * (1f - y),
				(1f - x) * y,
				x * y,
				x * (1f - y)
			};
			for (int i = 0; i < 4; i++)
			{
				zero += quad[i] * list[i];
			}
			return zero;
		}
	}
	[AddComponentMenu("CurvedUI/CurvedUISettings")]
	[RequireComponent(typeof(Canvas))]
	public class CurvedUISettings : MonoBehaviour
	{
		public enum CurvedUIShape
		{
			CYLINDER,
			RING,
			SPHERE,
			CYLINDER_VERTICAL
		}

		public const string Version = "2.8p2";

		[SerializeField]
		private CurvedUIShape shape;

		[SerializeField]
		private float quality = 1f;

		[SerializeField]
		private bool interactable = true;

		[SerializeField]
		private bool blocksRaycasts = true;

		[SerializeField]
		private bool raycastMyLayerOnly = true;

		[SerializeField]
		private bool forceUseBoxCollider;

		[SerializeField]
		private int angle = 90;

		[SerializeField]
		private bool preserveAspect = true;

		[SerializeField]
		private int vertAngle = 90;

		[SerializeField]
		private float ringFill = 0.5f;

		[SerializeField]
		private int ringExternalDiamater = 1000;

		[SerializeField]
		private bool ringFlipVertical;

		private int baseCircleSegments = 16;

		private Vector2 savedRectSize;

		private float savedRadius;

		private Canvas myCanvas;

		private RectTransform m_rectTransform;

		private RectTransform RectTransform
		{
			get
			{
				if (m_rectTransform == null)
				{
					m_rectTransform = base.transform as RectTransform;
				}
				return m_rectTransform;
			}
		}

		public int BaseCircleSegments => baseCircleSegments;

		public int Angle
		{
			get
			{
				return angle;
			}
			set
			{
				if (angle != value)
				{
					SetUIAngle(value);
				}
			}
		}

		public float Quality
		{
			get
			{
				return quality;
			}
			set
			{
				if (quality != value)
				{
					quality = value;
					SetUIAngle(angle);
				}
			}
		}

		public CurvedUIShape Shape
		{
			get
			{
				return shape;
			}
			set
			{
				if (shape != value)
				{
					shape = value;
					SetUIAngle(angle);
				}
			}
		}

		public int VerticalAngle
		{
			get
			{
				return vertAngle;
			}
			set
			{
				if (vertAngle != value)
				{
					vertAngle = value;
					SetUIAngle(angle);
				}
			}
		}

		public float RingFill
		{
			get
			{
				return ringFill;
			}
			set
			{
				if (ringFill != value)
				{
					ringFill = value;
					SetUIAngle(angle);
				}
			}
		}

		public float SavedRadius
		{
			get
			{
				if (savedRadius == 0f)
				{
					savedRadius = GetCyllinderRadiusInCanvasSpace();
				}
				return savedRadius;
			}
		}

		public int RingExternalDiameter
		{
			get
			{
				return ringExternalDiamater;
			}
			set
			{
				if (ringExternalDiamater != value)
				{
					ringExternalDiamater = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool RingFlipVertical
		{
			get
			{
				return ringFlipVertical;
			}
			set
			{
				if (ringFlipVertical != value)
				{
					ringFlipVertical = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool PreserveAspect
		{
			get
			{
				return preserveAspect;
			}
			set
			{
				if (preserveAspect != value)
				{
					preserveAspect = value;
					SetUIAngle(angle);
				}
			}
		}

		public bool Interactable
		{
			get
			{
				return interactable;
			}
			set
			{
				interactable = value;
			}
		}

		public bool ForceUseBoxCollider
		{
			get
			{
				return forceUseBoxCollider;
			}
			set
			{
				forceUseBoxCollider = value;
			}
		}

		public bool BlocksRaycasts
		{
			get
			{
				return blocksRaycasts;
			}
			set
			{
				if (blocksRaycasts != value)
				{
					blocksRaycasts = value;
					if (Application.isPlaying && GetComponent<CurvedUIRaycaster>() != null)
					{
						GetComponent<CurvedUIRaycaster>().RebuildCollider();
					}
				}
			}
		}

		public bool RaycastMyLayerOnly
		{
			get
			{
				return raycastMyLayerOnly;
			}
			set
			{
				raycastMyLayerOnly = value;
			}
		}

		public bool PointingAtCanvas
		{
			get
			{
				if (GetComponent<CurvedUIRaycaster>() != null)
				{
					return GetComponent<CurvedUIRaycaster>().PointingAtCanvas;
				}
				UnityEngine.Debug.LogWarning("CURVEDUI: Can't check if user is pointing at this canvas - No CurvedUIRaycaster is added to this canvas.");
				return false;
			}
		}

		public CurvedUIInputModule.CUIControlMethod ControlMethod
		{
			get
			{
				return CurvedUIInputModule.ControlMethod;
			}
			set
			{
				CurvedUIInputModule.ControlMethod = value;
			}
		}

		public bool GazeUseTimedClick
		{
			get
			{
				return CurvedUIInputModule.Instance.GazeUseTimedClick;
			}
			set
			{
				CurvedUIInputModule.Instance.GazeUseTimedClick = value;
			}
		}

		public float GazeClickTimer
		{
			get
			{
				return CurvedUIInputModule.Instance.GazeClickTimer;
			}
			set
			{
				CurvedUIInputModule.Instance.GazeClickTimer = value;
			}
		}

		public float GazeClickTimerDelay
		{
			get
			{
				return CurvedUIInputModule.Instance.GazeClickTimerDelay;
			}
			set
			{
				CurvedUIInputModule.Instance.GazeClickTimerDelay = value;
			}
		}

		public float GazeTimerProgress => CurvedUIInputModule.Instance.GazeTimerProgress;

		private void Awake()
		{
			if (RaycastMyLayerOnly && base.gameObject.layer == 0)
			{
				base.gameObject.layer = 5;
			}
			savedRectSize = RectTransform.rect.size;
		}

		private void Start()
		{
			if (Application.isPlaying)
			{
				BaseRaycaster[] components = GetComponents<BaseRaycaster>();
				foreach (BaseRaycaster baseRaycaster in components)
				{
					if (!(baseRaycaster is CurvedUIRaycaster))
					{
						baseRaycaster.enabled = false;
					}
				}
				base.gameObject.AddComponentIfMissing<CurvedUIRaycaster>();
				Canvas[] componentsInChildren = GetComponentsInChildren<Canvas>();
				foreach (Canvas canvas in componentsInChildren)
				{
					if (canvas.gameObject != base.gameObject)
					{
						Transform parent = canvas.transform;
						string text = parent.name;
						while (parent.parent != null)
						{
							text = parent.parent.name + "/" + text;
							parent = parent.parent;
						}
						UnityEngine.Debug.LogWarning("CURVEDUI: Interactions on nested canvases are not supported. You won't be able to interact with any child object of [" + text + "]", canvas.gameObject);
					}
				}
			}
			if (myCanvas == null)
			{
				myCanvas = GetComponent<Canvas>();
			}
			savedRadius = GetCyllinderRadiusInCanvasSpace();
		}

		private void OnEnable()
		{
			Graphic[] componentsInChildren = GetComponentsInChildren<Graphic>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].SetAllDirty();
			}
		}

		private void OnDisable()
		{
			Graphic[] componentsInChildren = GetComponentsInChildren<Graphic>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].SetAllDirty();
			}
		}

		private void Update()
		{
			if (RectTransform.rect.size != savedRectSize)
			{
				savedRectSize = RectTransform.rect.size;
				SetUIAngle(angle);
			}
			if (savedRectSize.x == 0f || savedRectSize.y == 0f)
			{
				UnityEngine.Debug.LogError("CurvedUI: Your Canvas size must be bigger than 0!");
			}
		}

		private void SetUIAngle(int newAngle)
		{
			if (myCanvas == null)
			{
				myCanvas = GetComponent<Canvas>();
			}
			if (newAngle == 0)
			{
				newAngle = 1;
			}
			angle = newAngle;
			savedRadius = GetCyllinderRadiusInCanvasSpace();
			CurvedUIVertexEffect[] componentsInChildren = GetComponentsInChildren<CurvedUIVertexEffect>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].SetDirty();
			}
			Graphic[] componentsInChildren2 = GetComponentsInChildren<Graphic>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				componentsInChildren2[i].SetAllDirty();
			}
			if (Application.isPlaying && GetComponent<CurvedUIRaycaster>() != null)
			{
				GetComponent<CurvedUIRaycaster>().RebuildCollider();
			}
		}

		private Vector3 CanvasToCyllinder(Vector3 pos)
		{
			float f = pos.x / savedRectSize.x * (float)Angle * ((float)Math.PI / 180f);
			pos.x = Mathf.Sin(f) * (SavedRadius + pos.z);
			pos.z += Mathf.Cos(f) * (SavedRadius + pos.z) - (SavedRadius + pos.z);
			return pos;
		}

		private Vector3 CanvasToCyllinderVertical(Vector3 pos)
		{
			float f = pos.y / savedRectSize.y * (float)Angle * ((float)Math.PI / 180f);
			pos.y = Mathf.Sin(f) * (SavedRadius + pos.z);
			pos.z += Mathf.Cos(f) * (SavedRadius + pos.z) - (SavedRadius + pos.z);
			return pos;
		}

		private Vector3 CanvasToRing(Vector3 pos)
		{
			float num = pos.y.Remap(savedRectSize.y * 0.5f * (float)(RingFlipVertical ? 1 : (-1)), (0f - savedRectSize.y) * 0.5f * (float)(RingFlipVertical ? 1 : (-1)), (float)RingExternalDiameter * (1f - RingFill) * 0.5f, (float)RingExternalDiameter * 0.5f);
			float f = (pos.x / savedRectSize.x).Remap(-0.5f, 0.5f, (float)Math.PI / 2f, (float)angle * ((float)Math.PI / 180f) + (float)Math.PI / 2f);
			pos.x = num * Mathf.Cos(f);
			pos.y = num * Mathf.Sin(f);
			return pos;
		}

		private Vector3 CanvasToSphere(Vector3 pos)
		{
			float num = SavedRadius;
			float num2 = VerticalAngle;
			if (PreserveAspect)
			{
				num2 = (float)angle * (savedRectSize.y / savedRectSize.x);
				num += ((Angle > 0) ? (0f - pos.z) : pos.z);
			}
			else
			{
				num = savedRectSize.x / 2f + pos.z;
				if (num2 == 0f)
				{
					return Vector3.zero;
				}
			}
			float num3 = (pos.x / savedRectSize.x).Remap(-0.5f, 0.5f, (float)(180 - angle) / 2f - 90f, 180f - (float)(180 - angle) / 2f - 90f);
			num3 *= (float)Math.PI / 180f;
			float num4 = (pos.y / savedRectSize.y).Remap(-0.5f, 0.5f, (180f - num2) / 2f, 180f - (180f - num2) / 2f);
			num4 *= (float)Math.PI / 180f;
			pos.z = Mathf.Sin(num4) * Mathf.Cos(num3) * num;
			pos.y = (0f - num) * Mathf.Cos(num4);
			pos.x = Mathf.Sin(num4) * Mathf.Sin(num3) * num;
			if (PreserveAspect)
			{
				pos.z -= num;
			}
			return pos;
		}

		public void AddEffectToChildren()
		{
			Graphic[] componentsInChildren = GetComponentsInChildren<Graphic>(includeInactive: true);
			foreach (Graphic graphic in componentsInChildren)
			{
				if (graphic.GetComponent<CurvedUIVertexEffect>() == null)
				{
					graphic.gameObject.AddComponent<CurvedUIVertexEffect>();
					graphic.SetAllDirty();
				}
			}
			InputField[] componentsInChildren2 = GetComponentsInChildren<InputField>(includeInactive: true);
			foreach (InputField inputField in componentsInChildren2)
			{
				if (inputField.GetComponent<CurvedUIInputFieldCaret>() == null)
				{
					inputField.gameObject.AddComponent<CurvedUIInputFieldCaret>();
				}
			}
			TextMeshProUGUI[] componentsInChildren3 = GetComponentsInChildren<TextMeshProUGUI>(includeInactive: true);
			foreach (TextMeshProUGUI textMeshProUGUI in componentsInChildren3)
			{
				if (textMeshProUGUI.GetComponent<CurvedUITMP>() == null)
				{
					textMeshProUGUI.gameObject.AddComponent<CurvedUITMP>();
					textMeshProUGUI.SetAllDirty();
				}
			}
			TMP_InputField[] componentsInChildren4 = GetComponentsInChildren<TMP_InputField>(includeInactive: true);
			for (int i = 0; i < componentsInChildren4.Length; i++)
			{
				componentsInChildren4[i].AddComponentIfMissing<CurvedUITMPInputFieldCaret>();
			}
		}

		public Vector3 VertexPositionToCurvedCanvas(Vector3 pos)
		{
			return Shape switch
			{
				CurvedUIShape.CYLINDER => CanvasToCyllinder(pos), 
				CurvedUIShape.CYLINDER_VERTICAL => CanvasToCyllinderVertical(pos), 
				CurvedUIShape.RING => CanvasToRing(pos), 
				CurvedUIShape.SPHERE => CanvasToSphere(pos), 
				_ => Vector3.zero, 
			};
		}

		public Vector3 CanvasToCurvedCanvas(Vector3 pos)
		{
			pos = VertexPositionToCurvedCanvas(pos);
			if (float.IsNaN(pos.x) || float.IsInfinity(pos.x))
			{
				return Vector3.zero;
			}
			return base.transform.localToWorldMatrix.MultiplyPoint3x4(pos);
		}

		public Vector3 CanvasToCurvedCanvasNormal(Vector3 pos)
		{
			pos = VertexPositionToCurvedCanvas(pos);
			switch (Shape)
			{
			case CurvedUIShape.CYLINDER:
				return base.transform.localToWorldMatrix.MultiplyVector((pos - new Vector3(0f, 0f, 0f - GetCyllinderRadiusInCanvasSpace())).ModifyY(0f)).normalized;
			case CurvedUIShape.CYLINDER_VERTICAL:
				return base.transform.localToWorldMatrix.MultiplyVector((pos - new Vector3(0f, 0f, 0f - GetCyllinderRadiusInCanvasSpace())).ModifyX(0f)).normalized;
			case CurvedUIShape.RING:
				return -base.transform.forward;
			case CurvedUIShape.SPHERE:
			{
				Vector3 vector = (PreserveAspect ? new Vector3(0f, 0f, 0f - GetCyllinderRadiusInCanvasSpace()) : Vector3.zero);
				return base.transform.localToWorldMatrix.MultiplyVector(pos - vector).normalized;
			}
			default:
				return Vector3.zero;
			}
		}

		public bool RaycastToCanvasSpace(Ray ray, out Vector2 o_positionOnCanvas)
		{
			CurvedUIRaycaster component = GetComponent<CurvedUIRaycaster>();
			o_positionOnCanvas = Vector2.zero;
			return Shape switch
			{
				CurvedUIShape.CYLINDER => component.RaycastToCyllinderCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				CurvedUIShape.CYLINDER_VERTICAL => component.RaycastToCyllinderVerticalCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				CurvedUIShape.RING => component.RaycastToRingCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				CurvedUIShape.SPHERE => component.RaycastToSphereCanvas(ray, out o_positionOnCanvas, OutputInCanvasSpace: true), 
				_ => false, 
			};
		}

		public float GetCyllinderRadiusInCanvasSpace()
		{
			float result = ((!PreserveAspect) ? (RectTransform.rect.size.x * 0.5f / Mathf.Sin(Mathf.Clamp(angle, -180f, 180f) * 0.5f * ((float)Math.PI / 180f))) : ((shape != CurvedUIShape.CYLINDER_VERTICAL) ? (RectTransform.rect.size.x / ((float)Math.PI * 2f * ((float)angle / 360f))) : (RectTransform.rect.size.y / ((float)Math.PI * 2f * ((float)angle / 360f)))));
			if (angle != 0)
			{
				return result;
			}
			return 0f;
		}

		public Vector2 GetTesslationSize(bool modifiedByQuality = true)
		{
			Vector2 size = RectTransform.rect.size;
			if (Angle != 0 || (!PreserveAspect && vertAngle != 0))
			{
				switch (shape)
				{
				case CurvedUIShape.CYLINDER:
				case CurvedUIShape.RING:
				case CurvedUIShape.CYLINDER_VERTICAL:
					size /= GetSegmentsByAngle(angle);
					break;
				case CurvedUIShape.SPHERE:
					size.x /= GetSegmentsByAngle(angle);
					if (PreserveAspect)
					{
						size.y = size.x * RectTransform.rect.size.y / RectTransform.rect.size.x;
					}
					else
					{
						size.y /= GetSegmentsByAngle(VerticalAngle);
					}
					break;
				}
			}
			return size / (modifiedByQuality ? Mathf.Clamp(Quality, 0.01f, 10f) : 1f);
		}

		private float GetSegmentsByAngle(float angle)
		{
			if (angle.Abs() <= 1f)
			{
				return 1f;
			}
			if (angle.Abs() < 90f)
			{
				return (float)baseCircleSegments * Mathf.Abs(angle).Remap(0f, 90f, 0.01f, 0.5f);
			}
			return (float)baseCircleSegments * Mathf.Abs(angle).Remap(90f, 360f, 0.5f, 1f);
		}

		public void SetAllChildrenDirty(bool recalculateCurveOnly = false)
		{
			CurvedUIVertexEffect[] componentsInChildren = GetComponentsInChildren<CurvedUIVertexEffect>();
			foreach (CurvedUIVertexEffect curvedUIVertexEffect in componentsInChildren)
			{
				if (recalculateCurveOnly)
				{
					curvedUIVertexEffect.SetDirty();
				}
				else
				{
					curvedUIVertexEffect.CurvingRequired = true;
				}
			}
		}

		public void Click()
		{
			if (GetComponent<CurvedUIRaycaster>() != null)
			{
				GetComponent<CurvedUIRaycaster>().Click();
			}
		}

		public List<GameObject> GetObjectsUnderPointer()
		{
			if (GetComponent<CurvedUIRaycaster>() != null)
			{
				return GetComponent<CurvedUIRaycaster>().GetObjectsUnderPointer();
			}
			return new List<GameObject>();
		}

		public List<GameObject> GetObjectsUnderScreenPos(Vector2 pos, Camera eventCamera = null)
		{
			if (eventCamera == null)
			{
				eventCamera = myCanvas.worldCamera;
			}
			if (GetComponent<CurvedUIRaycaster>() != null)
			{
				return GetComponent<CurvedUIRaycaster>().GetObjectsUnderScreenPos(pos, eventCamera);
			}
			return new List<GameObject>();
		}

		public List<GameObject> GetObjectsHitByRay(Ray ray)
		{
			if (GetComponent<CurvedUIRaycaster>() != null)
			{
				return GetComponent<CurvedUIRaycaster>().GetObjectsHitByRay(ray);
			}
			return new List<GameObject>();
		}
	}
	public class CurvedUIVertexEffect : BaseMeshEffect
	{
		[Tooltip("Check to skip tesselation pass on this object. CurvedUI will not create additional vertices to make this object have a smoother curve. Checking this can solve some issues if you create your own procedural mesh for this object. Default false.")]
		public bool DoNotTesselate;

		private Canvas myCanvas;

		private CurvedUISettings mySettings;

		private Graphic myGraphic;

		private Text myText;

		private TextMeshProUGUI myTMP;

		private CurvedUITMPSubmesh myTMPSubMesh;

		private bool m_tesselationRequired = true;

		private bool curvingRequired = true;

		private bool TransformMisaligned;

		private Matrix4x4 CanvasToWorld;

		private Matrix4x4 CanvasToLocal;

		private Matrix4x4 MyToWorld;

		private Matrix4x4 MyToLocal;

		private List<UIVertex> m_tesselatedVerts = new List<UIVertex>();

		private List<UIVertex> m_curvedVerts = new List<UIVertex>();

		private List<UIVertex> m_vertsInQuads = new List<UIVertex>();

		private UIVertex m_ret;

		private UIVertex[] m_quad = new UIVertex[4];

		private float[] m_weights = new float[4];

		[SerializeField]
		[HideInInspector]
		private Vector3 savedPos;

		[SerializeField]
		[HideInInspector]
		private Vector3 savedUp;

		[SerializeField]
		[HideInInspector]
		private Vector2 savedRectSize;

		[SerializeField]
		[HideInInspector]
		private Color savedColor;

		[SerializeField]
		[HideInInspector]
		private Vector2 savedTextUV0;

		[SerializeField]
		[HideInInspector]
		private float savedFill;

		private Vector2 _uv0;

		private Vector2 _uv1;

		private Vector3 _pos;

		private bool tesselationRequired
		{
			get
			{
				return m_tesselationRequired;
			}
			set
			{
				m_tesselationRequired = value;
			}
		}

		public bool TesselationRequired
		{
			get
			{
				return tesselationRequired;
			}
			set
			{
				tesselationRequired = value;
			}
		}

		public bool CurvingRequired
		{
			get
			{
				return curvingRequired;
			}
			set
			{
				curvingRequired = value;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			myGraphic = GetComponent<Graphic>();
			myText = GetComponent<Text>();
			myTMP = GetComponent<TextMeshProUGUI>();
			myTMPSubMesh = GetComponent<CurvedUITMPSubmesh>();
		}

		protected override void OnEnable()
		{
			FindParentSettings();
			if ((bool)myGraphic)
			{
				myGraphic.RegisterDirtyMaterialCallback(TesselationRequiredCallback);
				myGraphic.SetVerticesDirty();
			}
			if ((bool)myText)
			{
				myText.RegisterDirtyVerticesCallback(TesselationRequiredCallback);
				Font.textureRebuilt += FontTextureRebuiltCallback;
			}
		}

		protected override void Start()
		{
			base.Start();
			if ((bool)myCanvas && (bool)GetComponent<Selectable>())
			{
				Vector3 vector = myCanvas.transform.worldToLocalMatrix.MultiplyPoint3x4(base.transform.position);
				RectTransform rectTransform = myCanvas.transform as RectTransform;
				if (vector.x.Abs() > rectTransform.rect.width / 2f || vector.y.Abs() > rectTransform.rect.height / 2f)
				{
					UnityEngine.Debug.LogWarning("CurvedUI: " + GetComponent<Selectable>().GetType().Name + " \"" + base.gameObject.name + "\" is outside of the canvas. It will not be interactable. Move it inside the canvas rectangle (white border in scene view) for it to work.", base.gameObject);
				}
				if (vector.z.Abs() > 0.1f)
				{
					UnityEngine.Debug.LogWarning("CurvedUI: The Z position of \"" + base.gameObject.name + "\" " + GetComponent<Selectable>().GetType().Name + ", or one of its parents is not 0 in relation to the canvas. The interactions may not be accurate.", base.gameObject);
				}
			}
		}

		protected override void OnDisable()
		{
			if ((bool)myGraphic)
			{
				myGraphic.UnregisterDirtyMaterialCallback(TesselationRequiredCallback);
			}
			if ((bool)myText)
			{
				myText.UnregisterDirtyVerticesCallback(TesselationRequiredCallback);
				Font.textureRebuilt -= FontTextureRebuiltCallback;
			}
		}

		private void TesselationRequiredCallback()
		{
			tesselationRequired = true;
		}

		private void FontTextureRebuiltCallback(Font fontie)
		{
			if (myText.font == fontie)
			{
				tesselationRequired = true;
			}
		}

		private void LateUpdate()
		{
			if ((bool)myTMP || (bool)myTMPSubMesh)
			{
				return;
			}
			if (!tesselationRequired)
			{
				if ((base.transform as RectTransform).rect.size != savedRectSize)
				{
					tesselationRequired = true;
				}
				else if (myGraphic != null)
				{
					if (myGraphic.color != savedColor)
					{
						tesselationRequired = true;
						savedColor = myGraphic.color;
					}
					else if (myGraphic is Image && (myGraphic as Image).fillAmount != savedFill)
					{
						tesselationRequired = true;
						savedFill = (myGraphic as Image).fillAmount;
					}
				}
			}
			if (!tesselationRequired && !curvingRequired)
			{
				Vector3 a = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(base.transform.position);
				if (!a.AlmostEqual(savedPos) && (mySettings.Shape != 0 || (double)Mathf.Pow(a.x - savedPos.x, 2f) > 1E-05 || (double)Mathf.Pow(a.z - savedPos.z, 2f) > 1E-05))
				{
					savedPos = a;
					curvingRequired = true;
				}
				Vector3 normalized = mySettings.transform.worldToLocalMatrix.MultiplyVector(base.transform.up).normalized;
				if (!savedUp.AlmostEqual(normalized, 0.0001))
				{
					bool flag = normalized.AlmostEqual(Vector3.up.normalized);
					bool flag2 = savedUp.AlmostEqual(Vector3.up.normalized);
					if ((!flag && flag2) || (flag && !flag2))
					{
						tesselationRequired = true;
					}
					savedUp = normalized;
					curvingRequired = true;
				}
			}
			if ((bool)myGraphic && (tesselationRequired || curvingRequired))
			{
				myGraphic.SetVerticesDirty();
			}
		}

		public override void ModifyMesh(VertexHelper vh)
		{
			if (!ShouldModify())
			{
				return;
			}
			CheckTextFontMaterial();
			if (tesselationRequired || !Application.isPlaying)
			{
				if (m_tesselatedVerts == null)
				{
					m_tesselatedVerts = new List<UIVertex>();
				}
				else
				{
					m_tesselatedVerts.Clear();
				}
				vh.GetUIVertexStream(m_tesselatedVerts);
				TesselateGeometry(m_tesselatedVerts);
				savedRectSize = (base.transform as RectTransform).rect.size;
				tesselationRequired = false;
				curvingRequired = true;
			}
			if (curvingRequired)
			{
				CanvasToWorld = myCanvas.transform.localToWorldMatrix;
				CanvasToLocal = myCanvas.transform.worldToLocalMatrix;
				MyToWorld = base.transform.localToWorldMatrix;
				MyToLocal = base.transform.worldToLocalMatrix;
				if (m_curvedVerts == null)
				{
					m_curvedVerts = new List<UIVertex>();
				}
				if (m_curvedVerts.Count == m_tesselatedVerts.Count)
				{
					for (int i = 0; i < m_curvedVerts.Count; i++)
					{
						m_curvedVerts[i] = CurveVertex(m_tesselatedVerts[i], mySettings.Angle, mySettings.GetCyllinderRadiusInCanvasSpace(), (myCanvas.transform as RectTransform).rect.size);
					}
				}
				else
				{
					m_curvedVerts.Clear();
					for (int j = 0; j < m_tesselatedVerts.Count; j++)
					{
						m_curvedVerts.Add(CurveVertex(m_tesselatedVerts[j], mySettings.Angle, mySettings.GetCyllinderRadiusInCanvasSpace(), (myCanvas.transform as RectTransform).rect.size));
					}
				}
				curvingRequired = false;
			}
			vh.Clear();
			if (m_curvedVerts.Count % 4 == 0)
			{
				for (int k = 0; k < m_curvedVerts.Count; k += 4)
				{
					for (int l = 0; l < 4; l++)
					{
						m_quad[l] = m_curvedVerts[k + l];
					}
					vh.AddUIVertexQuad(m_quad);
				}
			}
			else
			{
				vh.AddUIVertexTriangleStream(m_curvedVerts);
			}
		}

		public void ModifyTMPMesh(ref List<UIVertex> vertexList)
		{
			if (!ShouldModify())
			{
				return;
			}
			CheckTextFontMaterial();
			tesselationRequired = false;
			curvingRequired = true;
			if (curvingRequired)
			{
				CanvasToWorld = myCanvas.transform.localToWorldMatrix;
				CanvasToLocal = myCanvas.transform.worldToLocalMatrix;
				MyToWorld = base.transform.localToWorldMatrix;
				MyToLocal = base.transform.worldToLocalMatrix;
				for (int i = 0; i < vertexList.Count; i++)
				{
					vertexList[i] = CurveVertex(vertexList[i], mySettings.Angle, mySettings.GetCyllinderRadiusInCanvasSpace(), (myCanvas.transform as RectTransform).rect.size);
				}
				curvingRequired = false;
			}
		}

		private bool ShouldModify()
		{
			if (!IsActive())
			{
				return false;
			}
			if (mySettings == null)
			{
				FindParentSettings();
			}
			if (mySettings == null || !mySettings.enabled || mySettings.Angle == 1)
			{
				return false;
			}
			return true;
		}

		private void CheckTextFontMaterial()
		{
			if ((bool)myText && myText.cachedTextGenerator.verts.Count > 0 && !myText.cachedTextGenerator.verts[0].uv0.Equals(savedTextUV0))
			{
				savedTextUV0 = myText.cachedTextGenerator.verts[0].uv0;
				tesselationRequired = true;
			}
		}

		public CurvedUISettings FindParentSettings(bool forceNew = false)
		{
			if (mySettings == null || forceNew)
			{
				mySettings = GetComponentInParent<CurvedUISettings>();
				if (mySettings == null)
				{
					return null;
				}
				myCanvas = mySettings.GetComponent<Canvas>();
			}
			return mySettings;
		}

		private UIVertex CurveVertex(UIVertex input, float cylinder_angle, float radius, Vector2 canvasSize)
		{
			Vector3 position = input.position;
			position = CanvasToLocal.MultiplyPoint3x4(MyToWorld.MultiplyPoint3x4(position));
			if (mySettings.Shape == CurvedUISettings.CurvedUIShape.CYLINDER && mySettings.Angle != 0)
			{
				float f = position.x / canvasSize.x * cylinder_angle * ((float)Math.PI / 180f);
				radius += position.z;
				position.x = Mathf.Sin(f) * radius;
				position.z += Mathf.Cos(f) * radius - radius;
			}
			else if (mySettings.Shape == CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL && mySettings.Angle != 0)
			{
				float f2 = position.y / canvasSize.y * cylinder_angle * ((float)Math.PI / 180f);
				radius += position.z;
				position.y = Mathf.Sin(f2) * radius;
				position.z += Mathf.Cos(f2) * radius - radius;
			}
			else if (mySettings.Shape == CurvedUISettings.CurvedUIShape.RING)
			{
				float num = 0f;
				float num2 = position.y.Remap(canvasSize.y * 0.5f * (float)(mySettings.RingFlipVertical ? 1 : (-1)), (0f - canvasSize.y) * 0.5f * (float)(mySettings.RingFlipVertical ? 1 : (-1)), (float)mySettings.RingExternalDiameter * (1f - mySettings.RingFill) * 0.5f, (float)mySettings.RingExternalDiameter * 0.5f);
				float f3 = (position.x / canvasSize.x).Remap(-0.5f, 0.5f, (float)Math.PI / 2f, cylinder_angle * ((float)Math.PI / 180f) + (float)Math.PI / 2f) - num;
				position.x = num2 * Mathf.Cos(f3);
				position.y = num2 * Mathf.Sin(f3);
			}
			else if (mySettings.Shape == CurvedUISettings.CurvedUIShape.SPHERE && mySettings.Angle != 0)
			{
				float num3 = mySettings.VerticalAngle;
				float num4 = 0f - position.z;
				if (mySettings.PreserveAspect)
				{
					num3 = cylinder_angle * (canvasSize.y / canvasSize.x);
				}
				else
				{
					radius = canvasSize.x / 2f;
					if (num3 == 0f)
					{
						return input;
					}
				}
				float num5 = (position.x / canvasSize.x).Remap(-0.5f, 0.5f, (180f - cylinder_angle) / 2f - 90f, 180f - (180f - cylinder_angle) / 2f - 90f);
				num5 *= (float)Math.PI / 180f;
				float num6 = (position.y / canvasSize.y).Remap(-0.5f, 0.5f, (180f - num3) / 2f, 180f - (180f - num3) / 2f);
				num6 *= (float)Math.PI / 180f;
				position.z = Mathf.Sin(num6) * Mathf.Cos(num5) * (radius + num4);
				position.y = (0f - (radius + num4)) * Mathf.Cos(num6);
				position.x = Mathf.Sin(num6) * Mathf.Sin(num5) * (radius + num4);
				if (mySettings.PreserveAspect)
				{
					position.z -= radius;
				}
			}
			input.position = MyToLocal.MultiplyPoint3x4(CanvasToWorld.MultiplyPoint3x4(position));
			return input;
		}

		private void TesselateGeometry(List<UIVertex> verts)
		{
			Vector2 tesslationSize = mySettings.GetTesslationSize();
			TransformMisaligned = !savedUp.AlmostEqual(Vector3.up.normalized);
			TrisToQuads(verts);
			if (myText == null && myTMP == null && !DoNotTesselate)
			{
				int count = verts.Count;
				for (int i = 0; i < count; i += 4)
				{
					ModifyQuad(verts, i, tesslationSize);
				}
				verts.RemoveRange(0, count);
			}
		}

		private void ModifyQuad(List<UIVertex> verts, int vertexIndex, Vector2 requiredSize)
		{
			for (int i = 0; i < 4; i++)
			{
				m_quad[i] = verts[vertexIndex + i];
			}
			Vector3 vector = m_quad[2].position - m_quad[1].position;
			Vector3 vector2 = m_quad[1].position - m_quad[0].position;
			if (myGraphic != null && myGraphic is Image && (myGraphic as Image).type == Image.Type.Filled)
			{
				vector = ((vector.x > (m_quad[3].position - m_quad[0].position).x) ? vector : (m_quad[3].position - m_quad[0].position));
				vector2 = ((vector2.y > (m_quad[2].position - m_quad[3].position).y) ? vector2 : (m_quad[2].position - m_quad[3].position));
			}
			int num = 1;
			int num2 = 1;
			if (TransformMisaligned || mySettings.Shape == CurvedUISettings.CurvedUIShape.SPHERE || mySettings.Shape == CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL)
			{
				num2 = Mathf.CeilToInt(vector2.magnitude * (1f / Mathf.Max(0.0001f, requiredSize.y)));
			}
			if (TransformMisaligned || mySettings.Shape != CurvedUISettings.CurvedUIShape.CYLINDER_VERTICAL)
			{
				num = Mathf.CeilToInt(vector.magnitude * (1f / Mathf.Max(0.0001f, requiredSize.x)));
			}
			bool flag = false;
			bool flag2 = false;
			float y = 0f;
			for (int j = 0; j < num2 || !flag; j++)
			{
				flag = true;
				float num3 = ((float)j + 1f) / (float)num2;
				float x = 0f;
				for (int k = 0; k < num || !flag2; k++)
				{
					flag2 = true;
					float num4 = ((float)k + 1f) / (float)num;
					verts.Add(TesselateQuad(x, y));
					verts.Add(TesselateQuad(x, num3));
					verts.Add(TesselateQuad(num4, num3));
					verts.Add(TesselateQuad(num4, y));
					x = num4;
				}
				y = num3;
			}
		}

		private void TrisToQuads(List<UIVertex> verts)
		{
			int count = verts.Count;
			m_vertsInQuads.Clear();
			for (int i = 0; i < count; i += 6)
			{
				m_vertsInQuads.Add(verts[i]);
				m_vertsInQuads.Add(verts[i + 1]);
				m_vertsInQuads.Add(verts[i + 2]);
				m_vertsInQuads.Add(verts[i + 4]);
			}
			verts.AddRange(m_vertsInQuads);
			verts.RemoveRange(0, count);
		}

		private UIVertex TesselateQuad(float x, float y)
		{
			m_weights[0] = (1f - x) * (1f - y);
			m_weights[1] = (1f - x) * y;
			m_weights[2] = x * y;
			m_weights[3] = x * (1f - y);
			_uv0 = (_uv1 = Vector2.zero);
			_pos = Vector3.zero;
			for (int i = 0; i < 4; i++)
			{
				_uv0 += (Vector2)m_quad[i].uv0 * m_weights[i];
				_uv1 += (Vector2)m_quad[i].uv1 * m_weights[i];
				_pos += m_quad[i].position * m_weights[i];
			}
			m_ret.position = _pos;
			m_ret.color = m_quad[0].color;
			m_ret.uv0 = _uv0;
			m_ret.uv1 = _uv1;
			m_ret.normal = m_quad[0].normal;
			m_ret.tangent = m_quad[0].tangent;
			return m_ret;
		}

		public void SetDirty()
		{
			TesselationRequired = true;
		}
	}
	public class CurvedUIViveController : MonoBehaviour
	{
	}
	public struct ViveInputArgs
	{
		public uint controllerIndex;

		public float buttonPressure;

		public Vector2 touchpadAxis;
	}
	public delegate void ViveInputEvent(object sender, ViveInputArgs e);
	public delegate void ViveEvent(object sender);
	[ExecuteInEditMode]
	public class CurvedUITMP : MonoBehaviour
	{
		private CurvedUIVertexEffect crvdVE;

		private TextMeshProUGUI tmpText;

		private CurvedUISettings mySettings;

		private List<UIVertex> m_UIVerts = new List<UIVertex>();

		private UIVertex m_tempVertex;

		private CurvedUITMPSubmesh m_tempSubMsh;

		private Vector2 savedSize;

		private Vector3 savedUp;

		private Vector3 savedPos;

		private Vector3 savedLocalScale;

		private Vector3 savedGlobalScale;

		private List<CurvedUITMPSubmesh> subMeshes = new List<CurvedUITMPSubmesh>();

		public bool Dirty;

		private bool curvingRequired;

		private bool tesselationRequired;

		private bool quitting;

		private Vector3[] vertices;

		private void Start()
		{
			if (mySettings == null)
			{
				mySettings = GetComponentInParent<CurvedUISettings>();
			}
		}

		private void OnEnable()
		{
			FindTMP();
			if ((bool)tmpText)
			{
				tmpText.RegisterDirtyMaterialCallback(TesselationRequiredCallback);
				TMPro_EventManager.TEXT_CHANGED_EVENT.Add(TMPTextChangedCallback);
				tmpText.SetText(tmpText.text);
			}
		}

		private void OnDisable()
		{
			if ((bool)tmpText)
			{
				tmpText.UnregisterDirtyMaterialCallback(TesselationRequiredCallback);
				TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(TMPTextChangedCallback);
			}
		}

		private void OnDestroy()
		{
			quitting = true;
		}

		private void LateUpdate()
		{
			if (!tmpText)
			{
				FindTMP();
			}
			if (mySettings == null || !tmpText || quitting)
			{
				return;
			}
			if (ShouldTesselate())
			{
				tesselationRequired = true;
			}
			if (Dirty || tesselationRequired || (curvingRequired && !Application.isPlaying))
			{
				if (mySettings == null)
				{
					base.enabled = false;
					return;
				}
				tmpText.renderMode = TextRenderFlags.Render;
				tmpText.ForceMeshUpdate(ignoreActiveState: true);
				CreateUIVertexList(tmpText.mesh);
				crvdVE.ModifyTMPMesh(ref m_UIVerts);
				FillMeshWithUIVertexList(tmpText.mesh, m_UIVerts);
				tmpText.renderMode = TextRenderFlags.DontRender;
				savedLocalScale = mySettings.transform.localScale;
				savedGlobalScale = mySettings.transform.lossyScale;
				savedSize = (base.transform as RectTransform).rect.size;
				savedUp = mySettings.transform.worldToLocalMatrix.MultiplyVector(base.transform.up);
				savedPos = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(base.transform.position);
				tesselationRequired = false;
				curvingRequired = false;
				Dirty = false;
				FindSubmeshes();
				foreach (CurvedUITMPSubmesh subMesh in subMeshes)
				{
					subMesh.UpdateSubmesh(tesselate: true, curve: false);
				}
			}
			tmpText.canvasRenderer.SetMesh(tmpText.mesh);
		}

		private void CreateUIVertexList(Mesh mesh)
		{
			if (mesh.vertexCount < m_UIVerts.Count)
			{
				m_UIVerts.RemoveRange(mesh.vertexCount, m_UIVerts.Count - mesh.vertexCount);
			}
			vertices = mesh.vertices;
			for (int i = 0; i < mesh.vertexCount; i++)
			{
				if (m_UIVerts.Count <= i)
				{
					m_tempVertex = default(UIVertex);
					GetUIVertexFromMesh(ref m_tempVertex, i);
					m_UIVerts.Add(m_tempVertex);
				}
				else
				{
					m_tempVertex = m_UIVerts[i];
					GetUIVertexFromMesh(ref m_tempVertex, i);
					m_UIVerts[i] = m_tempVertex;
				}
			}
		}

		private void GetUIVertexFromMesh(ref UIVertex vert, int i)
		{
			vert.position = vertices[i];
		}

		private void FillMeshWithUIVertexList(Mesh mesh, List<UIVertex> list)
		{
			if (list.Count >= 65536)
			{
				UnityEngine.Debug.LogError("CURVEDUI: Unity UI Mesh can not have more than 65536 vertices. Remove some UI elements or lower quality.");
				return;
			}
			for (int i = 0; i < list.Count; i++)
			{
				vertices[i] = list[i].position;
			}
			mesh.vertices = vertices;
			mesh.RecalculateBounds();
		}

		private void FindTMP()
		{
			if (GetComponent<TextMeshProUGUI>() != null)
			{
				tmpText = base.gameObject.GetComponent<TextMeshProUGUI>();
				crvdVE = base.gameObject.GetComponent<CurvedUIVertexEffect>();
				mySettings = GetComponentInParent<CurvedUISettings>();
				base.transform.hasChanged = false;
				FindSubmeshes();
			}
		}

		private void FindSubmeshes()
		{
			TMP_SubMeshUI[] componentsInChildren = GetComponentsInChildren<TMP_SubMeshUI>();
			foreach (TMP_SubMeshUI tMP_SubMeshUI in componentsInChildren)
			{
				m_tempSubMsh = tMP_SubMeshUI.gameObject.AddComponentIfMissing<CurvedUITMPSubmesh>();
				if (!subMeshes.Contains(m_tempSubMsh))
				{
					subMeshes.Add(m_tempSubMsh);
				}
			}
		}

		private bool ShouldTesselate()
		{
			if (savedSize != (base.transform as RectTransform).rect.size)
			{
				return true;
			}
			if (savedLocalScale != mySettings.transform.localScale)
			{
				return true;
			}
			if (savedGlobalScale != mySettings.transform.lossyScale)
			{
				return true;
			}
			if (!savedUp.AlmostEqual(mySettings.transform.worldToLocalMatrix.MultiplyVector(base.transform.up)))
			{
				return true;
			}
			Vector3 b = mySettings.transform.worldToLocalMatrix.MultiplyPoint3x4(base.transform.position);
			if (!savedPos.AlmostEqual(b) && (mySettings.Shape != 0 || (double)Mathf.Pow(b.x - savedPos.x, 2f) > 1E-05 || (double)Mathf.Pow(b.z - savedPos.z, 2f) > 1E-05))
			{
				return true;
			}
			return false;
		}

		private void TMPTextChangedCallback(object obj)
		{
			if (obj == tmpText)
			{
				tesselationRequired = true;
			}
		}

		private void TesselationRequiredCallback()
		{
			tesselationRequired = true;
			curvingRequired = true;
		}
	}
	[ExecuteInEditMode]
	public class CurvedUITMPInputFieldCaret : MonoBehaviour, ISelectHandler, IEventSystemHandler, IDeselectHandler
	{
		private TMP_InputField myField;

		private RectTransform myCaret;

		private Color origCaretColor;

		private Color origSelectionColor;

		private bool selected;

		private bool selectingText;

		public Color CaretColor
		{
			get
			{
				return origCaretColor;
			}
			set
			{
				origCaretColor = value;
			}
		}

		public Color SelectionColor
		{
			get
			{
				return origSelectionColor;
			}
			set
			{
				origSelectionColor = value;
			}
		}

		public float CaretBlinkRate
		{
			get
			{
				return myField.caretBlinkRate;
			}
			set
			{
				myField.caretBlinkRate = value;
			}
		}

		private void Awake()
		{
			myField = GetComponent<TMP_InputField>();
			if ((bool)myField)
			{
				CheckAndConvertMask();
			}
		}

		private void Update()
		{
			if (selected)
			{
				UpdateCaret();
			}
		}

		public void OnSelect(BaseEventData eventData)
		{
			if (myCaret == null)
			{
				CreateCaret();
			}
			selected = true;
			myCaret.gameObject.SetActive(value: true);
			StartCoroutine(CaretBlinker());
		}

		public void OnDeselect(BaseEventData eventData)
		{
			selected = false;
			myCaret.gameObject.SetActive(value: false);
		}

		private IEnumerator CaretBlinker()
		{
			while (selected)
			{
				myCaret.gameObject.SetActive(selectingText || !myCaret.gameObject.activeSelf);
				yield return new WaitForSeconds(0.5f / myField.caretBlinkRate);
			}
		}

		private void CreateCaret()
		{
			GameObject gameObject = new GameObject("CurvedUI_TMPCaret");
			gameObject.AddComponent<RectTransform>();
			gameObject.AddComponent<Image>();
			gameObject.AddComponent<CurvedUIVertexEffect>();
			gameObject.transform.SetParent(base.transform.GetChild(0).GetChild(0));
			gameObject.transform.localScale = Vector3.one;
			(gameObject.transform as RectTransform).anchoredPosition3D = Vector3.zero;
			(gameObject.transform as RectTransform).pivot = new Vector2(0f, 1f);
			gameObject.GetComponent<Image>().color = myField.caretColor;
			myCaret = gameObject.transform as RectTransform;
			gameObject.transform.SetAsFirstSibling();
			myField.customCaretColor = true;
			origCaretColor = myField.caretColor;
			myField.caretColor = new Color(0f, 0f, 0f, 0f);
			origSelectionColor = myField.selectionColor;
			myField.selectionColor = new Color(0f, 0f, 0f, 0f);
			gameObject.gameObject.SetActive(value: false);
		}

		private void UpdateCaret()
		{
			if (myCaret == null)
			{
				CreateCaret();
			}
			Vector2 localPositionInText = GetLocalPositionInText(myField.caretPosition);
			if (myField.selectionFocusPosition != myField.selectionAnchorPosition)
			{
				selectingText = true;
				Vector2 vector = new Vector2(GetLocalPositionInText(myField.selectionAnchorPosition).x - GetLocalPositionInText(myField.selectionFocusPosition).x, GetLocalPositionInText(myField.selectionAnchorPosition).y - GetLocalPositionInText(myField.selectionFocusPosition).y);
				localPositionInText = ((vector.x < 0f) ? GetLocalPositionInText(myField.selectionAnchorPosition) : GetLocalPositionInText(myField.selectionFocusPosition));
				vector = new Vector2(Mathf.Abs(vector.x), Mathf.Abs(vector.y) + myField.textComponent.fontSize);
				myCaret.sizeDelta = new Vector2(vector.x, vector.y);
				myCaret.anchoredPosition = localPositionInText;
				myCaret.GetComponent<Image>().color = origSelectionColor;
			}
			else
			{
				selectingText = false;
				myCaret.sizeDelta = new Vector2(myField.caretWidth, myField.textComponent.fontSize);
				myCaret.anchoredPosition = localPositionInText;
				myCaret.GetComponent<Image>().color = origCaretColor;
			}
		}

		private Vector2 GetLocalPositionInText(int charNo)
		{
			if (myField.isFocused)
			{
				TMP_TextInfo textInfo = myField.textComponent.textInfo;
				if (charNo > textInfo.characterCount - 1)
				{
					charNo = textInfo.characterCount - 1;
				}
				TMP_CharacterInfo tMP_CharacterInfo = textInfo.characterInfo[charNo];
				return new Vector2(tMP_CharacterInfo.topLeft.x, tMP_CharacterInfo.ascender);
			}
			return Vector2.zero;
		}

		private void CheckAndConvertMask()
		{
			foreach (Transform item in base.transform)
			{
				if (item.GetComponent<RectMask2D>() != null)
				{
					UnityEngine.Object.DestroyImmediate(item.GetComponent<RectMask2D>());
					item.AddComponentIfMissing<Image>();
					item.AddComponentIfMissing<Mask>();
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class CurvedUITMPSubmesh : MonoBehaviour
	{
		private VertexHelper vh;

		private Mesh straightMesh;

		private Mesh curvedMesh;

		private CurvedUIVertexEffect crvdVE;

		private TMP_SubMeshUI TMPsub;

		public void UpdateSubmesh(bool tesselate, bool curve)
		{
			if (TMPsub == null)
			{
				TMPsub = base.gameObject.GetComponent<TMP_SubMeshUI>();
			}
			if (!(TMPsub == null))
			{
				if (crvdVE == null)
				{
					crvdVE = base.gameObject.AddComponentIfMissing<CurvedUIVertexEffect>();
				}
				if (tesselate || straightMesh == null || vh == null || !Application.isPlaying)
				{
					vh = new VertexHelper(TMPsub.mesh);
					straightMesh = new Mesh();
					vh.FillMesh(straightMesh);
					curve = true;
				}
				if (curve)
				{
					vh = new VertexHelper(straightMesh);
					crvdVE.ModifyMesh(vh);
					curvedMesh = new Mesh();
					vh.FillMesh(curvedMesh);
					crvdVE.CurvingRequired = true;
				}
				TMPsub.canvasRenderer.SetMesh(curvedMesh);
			}
		}
	}
	[Conditional("UNITY_CCU")]
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
	public class OptionalDependencyAttribute : Attribute
	{
		public string dependentClass;

		public string define;

		public OptionalDependencyAttribute(string dependentClass, string define)
		{
			this.dependentClass = dependentClass;
			this.define = define;
		}
	}
}
namespace Suriyun
{
	public class AnimatorController : MonoBehaviour
	{
		public Animator[] animators;

		public void SwapVisibility(GameObject obj)
		{
			obj.SetActive(!obj.activeSelf);
		}

		public void SetFloat(string parameter = "key,value")
		{
			char[] separator = new char[2] { ',', ';' };
			string[] array = parameter.Split(separator);
			string text = array[0];
			float value = (float)Convert.ToDouble(array[1]);
			UnityEngine.Debug.Log(text + " " + value);
			Animator[] array2 = animators;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].SetFloat(text, value);
			}
		}

		public void SetInt(string parameter = "key,value")
		{
			char[] separator = new char[2] { ',', ';' };
			string[] array = parameter.Split(separator);
			string text = array[0];
			int value = Convert.ToInt32(array[1]);
			UnityEngine.Debug.Log(text + " " + value);
			Animator[] array2 = animators;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].SetInteger(text, value);
			}
		}

		public void SetBool(string parameter = "key,value")
		{
			char[] separator = new char[2] { ',', ';' };
			string[] array = parameter.Split(separator);
			string text = array[0];
			bool value = Convert.ToBoolean(array[1]);
			UnityEngine.Debug.Log(text + " " + value);
			Animator[] array2 = animators;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].SetBool(text, value);
			}
		}

		public void SetTrigger(string parameter = "key,value")
		{
			char[] separator = new char[2] { ',', ';' };
			string text = parameter.Split(separator)[0];
			UnityEngine.Debug.Log(text);
			Animator[] array = animators;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetTrigger(text);
			}
		}
	}
}
namespace MalbersAnimations
{
	public class Readme : ScriptableObject
	{
		[Serializable]
		public class Section
		{
			public string heading;

			public string text;

			public string linkText;

			public string url;
		}

		public Texture2D icon;

		public string title;

		public Section[] sections;
	}
	public class UseTransform : MonoBehaviour
	{
		public enum UpdateMode
		{
			Update = 1,
			FixedUpdate = 2,
			LateUpdate = 4
		}

		public Transform Reference;

		public bool rotation = true;

		public UpdateMode updateMode = UpdateMode.LateUpdate;

		private void Update()
		{
			if (updateMode == UpdateMode.Update)
			{
				SetTransformReference();
			}
		}

		private void LateUpdate()
		{
			if (updateMode == UpdateMode.LateUpdate)
			{
				SetTransformReference();
			}
		}

		private void FixedUpdate()
		{
			if (updateMode == UpdateMode.FixedUpdate)
			{
				SetTransformReference();
			}
		}

		private void SetTransformReference()
		{
			if ((bool)Reference)
			{
				base.transform.position = Reference.position;
				if (rotation)
				{
					base.transform.rotation = Reference.rotation;
				}
			}
		}
	}
}
namespace MalbersAnimations.Events
{
	public class UnityEventRaiser : MonoBehaviour
	{
		public float Delayed;

		public UnityEvent OnEnableEvent;

		public void OnEnable()
		{
			if (Delayed > 0f)
			{
				Invoke("StartEvent", Delayed);
			}
			else
			{
				OnEnableEvent.Invoke();
			}
		}

		private void StartEvent()
		{
			OnEnableEvent.Invoke();
		}

		public void DestroyMe(float time)
		{
			UnityEngine.Object.Destroy(base.gameObject, time);
		}
	}
}
