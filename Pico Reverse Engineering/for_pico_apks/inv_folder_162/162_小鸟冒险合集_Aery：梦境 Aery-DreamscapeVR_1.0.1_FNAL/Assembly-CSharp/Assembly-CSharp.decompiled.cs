using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using DarkTonic.MasterAudio;
using FlightKit;
using FogVolumePlaydeadTAA;
using FogVolumeUtilities;
using HighlightPlus;
using I2.Loc;
using Ibuprogames.SketchAsset;
using NaughtyAttributes;
using Sony.PS4.SaveData;
using TMPro;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Controls;
using UnityEngine.InputSystem.EnhancedTouch;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityStandardAssets.Cameras;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.CrossPlatformInput.PlatformSpecific;
using UnityStandardAssets.ImageEffects;
using UnityStandardAssets.Utility;
using UnityStandardAssets.Vehicles.Aeroplane;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class Animate : MonoBehaviour
{
	private Animator anim;

	private string AnimatorName;

	private int Move;

	private int Pose;

	private int CurrentPose;

	private bool ChangePose;

	public bool StateChangeComplete = true;

	private string CurrentButtonPressed = "Stand";

	private GameObject AggressiveButton;

	private GameObject LayButton;

	private GameObject StandButton;

	private GameObject SitButton;

	private GameObject ConsumeButton;

	private float CrossfadeVal = 0.25f;

	private bool BackWards;

	private void Start()
	{
		AggressiveButton = GameObject.Find("Aggressive");
		LayButton = GameObject.Find("Lay");
		StandButton = GameObject.Find("Stand");
		SitButton = GameObject.Find("Sit");
		ConsumeButton = GameObject.Find("Consume");
		anim = GetComponent<Animator>();
		AnimatorName = anim.name;
		MonoBehaviour.print("name " + AnimatorName);
	}

	private void Update()
	{
		if (!ChangePose)
		{
			return;
		}
		MonoBehaviour.print("Change Pose");
		ChangePose = false;
		if (CurrentPose == 0)
		{
			if (Pose == 1)
			{
				anim.CrossFade(AnimatorName + "IdleToAggressive", CrossfadeVal);
			}
			else if (Pose == 2)
			{
				anim.CrossFade(AnimatorName + "IdleToSit", CrossfadeVal);
			}
			else if (Pose == 3)
			{
				anim.CrossFade(AnimatorName + "IdleToLay", CrossfadeVal);
			}
			else if (Pose == 5)
			{
				anim.CrossFade(AnimatorName + "IdleToConsume", CrossfadeVal);
			}
			CurrentPose = Pose;
		}
		else if (CurrentPose == 1)
		{
			if (Pose == 0)
			{
				anim.CrossFade(AnimatorName + "AggressiveToIdle", CrossfadeVal);
			}
			else if (Pose == 2)
			{
				anim.CrossFade(AnimatorName + "AggressiveToSitTrans", CrossfadeVal);
			}
			else if (Pose == 3)
			{
				anim.CrossFade(AnimatorName + "AggressiveToLayTrans", CrossfadeVal);
			}
			else if (Pose == 4)
			{
				anim.CrossFade(AnimatorName + "AggressiveToIdle", CrossfadeVal);
			}
			else if (Pose == 5)
			{
				anim.CrossFade(AnimatorName + "AggressiveToEat", CrossfadeVal);
			}
			CurrentPose = Pose;
		}
		else if (CurrentPose == 2)
		{
			if (Pose == 0)
			{
				anim.CrossFade(AnimatorName + "SitToIdle", CrossfadeVal);
			}
			else if (Pose == 1)
			{
				anim.CrossFade(AnimatorName + "SitToAggressiveTrans", CrossfadeVal);
			}
			else if (Pose == 3)
			{
				anim.CrossFade(AnimatorName + "SitToLay", CrossfadeVal);
			}
			else if (Pose == 4)
			{
				anim.CrossFade(AnimatorName + "SitToIdle", CrossfadeVal);
			}
			else if (Pose == 5)
			{
				anim.CrossFade(AnimatorName + "SitToEat", CrossfadeVal);
			}
			CurrentPose = Pose;
		}
		else if (CurrentPose == 3)
		{
			if (Pose == 0)
			{
				anim.CrossFade(AnimatorName + "LayToIdle", CrossfadeVal);
			}
			else if (Pose == 1)
			{
				anim.CrossFade(AnimatorName + "LayToAggressiveTrans", CrossfadeVal);
			}
			else if (Pose == 2)
			{
				anim.CrossFade(AnimatorName + "LayToSit", CrossfadeVal);
			}
			else if (Pose == 4)
			{
				anim.CrossFade(AnimatorName + "LayToIdle", CrossfadeVal);
			}
			else if (Pose == 5)
			{
				anim.CrossFade(AnimatorName + "LayToEat", CrossfadeVal);
			}
			CurrentPose = Pose;
		}
		else if (CurrentPose == 4 || CurrentPose == 5)
		{
			if (Pose == 0)
			{
				anim.CrossFade(AnimatorName + "Idle", CrossfadeVal);
			}
			else if (Pose == 1)
			{
				anim.CrossFade(AnimatorName + "IdleToAggressive", CrossfadeVal);
			}
			else if (Pose == 2)
			{
				anim.CrossFade(AnimatorName + "IdleToSit", CrossfadeVal);
			}
			else if (Pose == 3)
			{
				anim.CrossFade(AnimatorName + "IdleToLay", CrossfadeVal);
			}
			else if (Pose == 5)
			{
				anim.CrossFade(AnimatorName + "IdleToConsume", CrossfadeVal);
			}
			CurrentPose = Pose;
		}
	}

	public void StandButtonClicked()
	{
		if (CurrentButtonPressed != "Stand")
		{
			Pose = 0;
			ChangePose = true;
			ResetButtonNames();
		}
		else
		{
			anim.CrossFade(AnimatorName + StandButton.GetComponentInChildren<Text>().text, 0.5f);
		}
		Move = 0;
		anim.SetFloat("Move", Move);
		CurrentButtonPressed = "Stand";
	}

	public void SitButtonClicked()
	{
		if (CurrentButtonPressed != "Sit")
		{
			Pose = 2;
			ChangePose = true;
			ResetButtonNames();
		}
		else
		{
			anim.CrossFade(AnimatorName + SitButton.GetComponentInChildren<Text>().text, 0.5f);
		}
		Move = 0;
		CurrentButtonPressed = "Sit";
		anim.SetFloat("Move", Move);
	}

	public void LayButtonClicked()
	{
		if (CurrentButtonPressed != "Lay")
		{
			Pose = 3;
			ChangePose = true;
			ResetButtonNames();
		}
		else
		{
			anim.CrossFade(AnimatorName + LayButton.GetComponentInChildren<Text>().text, 0.5f);
		}
		Move = 0;
		anim.SetFloat("Move", Move);
		CurrentButtonPressed = "Lay";
	}

	public void ConsumeButtonClicked()
	{
		if (CurrentButtonPressed != "Consume")
		{
			Pose = 5;
			ChangePose = true;
			ResetButtonNames();
		}
		else
		{
			anim.CrossFade(AnimatorName + ConsumeButton.GetComponentInChildren<Text>().text, 0.5f);
		}
		Move = 0;
		anim.SetFloat("Move", Move);
		CurrentButtonPressed = "Consume";
	}

	public void AggressiveButtonClicked()
	{
		if (CurrentButtonPressed != "Aggressive")
		{
			Pose = 1;
			ChangePose = true;
			ResetButtonNames();
		}
		else
		{
			anim.CrossFade(AnimatorName + AggressiveButton.GetComponentInChildren<Text>().text, 0.5f);
		}
		Move = 0;
		anim.SetFloat("Move", Move);
		CurrentButtonPressed = "Aggressive";
	}

	public void WalkButtonClicked()
	{
		if (Move < 5 && !BackWards)
		{
			Move++;
		}
		else
		{
			BackWards = true;
			Move--;
			if (Move == 1)
			{
				BackWards = false;
			}
		}
		anim.SetFloat("Move", Move);
		if (Pose != 4)
		{
			ChangePose = true;
			ResetButtonNames();
		}
		Pose = 4;
		CurrentButtonPressed = "Walk";
	}

	private void ResetButtonNames()
	{
		GameObject gameObject = GameObject.Find(CurrentButtonPressed);
		gameObject.GetComponentInChildren<Text>().text = CurrentButtonPressed;
		MonoBehaviour.print("change button name and it is now " + gameObject.GetComponentInChildren<Text>().text);
		gameObject.GetComponentInChildren<ChangeButtonText>().ValuetoGet = 0;
	}
}
public class ButtonResponder : MonoBehaviour
{
	public GameObject[] GameObjects;

	private int CurrentModel;

	private Animate CurrentModelSelected;

	private GameObject Camera;

	private void Start()
	{
		Camera = GameObject.Find("Camera");
		CurrentModelSelected = GameObjects[CurrentModel].GetComponent<Animate>();
	}

	private void Update()
	{
	}

	public void ButtonResponderClicked()
	{
		if (CurrentModel < GameObjects.Length - 1)
		{
			CurrentModel++;
		}
		else
		{
			CurrentModel = 0;
		}
		CurrentModelSelected = GameObjects[CurrentModel].GetComponent<Animate>();
		Camera.GetComponentInChildren<MouseOrbitImprovedMod>().target = GameObjects[CurrentModel].transform;
		GetComponentInChildren<Text>().text = CurrentModelSelected.name;
	}

	public void StandButtonClicked()
	{
		CurrentModelSelected.StandButtonClicked();
		MonoBehaviour.print("Stand Button CLicked");
	}

	public void SitButtonClicked()
	{
		CurrentModelSelected.SitButtonClicked();
	}

	public void LayButtonClicked()
	{
		CurrentModelSelected.LayButtonClicked();
	}

	public void ConsumeButtonClicked()
	{
		CurrentModelSelected.ConsumeButtonClicked();
	}

	public void AggressiveButtonClicked()
	{
		CurrentModelSelected.AggressiveButtonClicked();
	}

	public void WalkButtonClicked()
	{
		CurrentModelSelected.WalkButtonClicked();
	}

	public void ChangeMatButtonClicked()
	{
		CurrentModelSelected.GetComponentInChildren<ChangeShader>().ChangeShaderButtonClicked();
	}

	public void ChangeBlendButtonClicked()
	{
		CurrentModelSelected.GetComponentInChildren<ChangeBlendShape>().ChangeBlend();
	}
}
public class ChangeBlendShape : MonoBehaviour
{
	private int blendShapeCount;

	private SkinnedMeshRenderer skinnedMeshRenderer;

	private Mesh skinnedMesh;

	private float blendCounter;

	public float blendSpeed = 10f;

	private bool blendFinished = true;

	private int CurrentBlend;

	private float PreviosBlendCounter;

	private void Awake()
	{
		skinnedMeshRenderer = GetComponent<SkinnedMeshRenderer>();
		skinnedMesh = GetComponent<SkinnedMeshRenderer>().sharedMesh;
	}

	private void Start()
	{
		blendShapeCount = skinnedMesh.blendShapeCount;
	}

	public void ChangeBlend()
	{
		blendCounter = 0f;
		blendFinished = false;
		PreviosBlendCounter = skinnedMeshRenderer.GetBlendShapeWeight(CurrentBlend);
		skinnedMeshRenderer.SetBlendShapeWeight(CurrentBlend, 0f);
		if (CurrentBlend < blendShapeCount)
		{
			CurrentBlend++;
		}
		else
		{
			CurrentBlend = 0;
		}
	}

	private void Update()
	{
		if (!blendFinished)
		{
			if (PreviosBlendCounter > 0f)
			{
				PreviosBlendCounter -= blendSpeed;
				skinnedMeshRenderer.SetBlendShapeWeight(CurrentBlend - 1, PreviosBlendCounter);
			}
			if (blendCounter < 100f)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(CurrentBlend, blendCounter);
				blendCounter += blendSpeed;
			}
			else
			{
				blendFinished = true;
			}
		}
	}
}
public class ChangeButtonText : MonoBehaviour
{
	public int ValuetoGet;

	public string[] AnimationNames;

	public string AnimationSelected;

	private void Start()
	{
		AnimationSelected = AnimationNames[0];
	}

	public void ChangeText()
	{
		GetComponentInChildren<Text>().text = AnimationNames[ValuetoGet];
		if (ValuetoGet < AnimationNames.Length - 1)
		{
			ValuetoGet++;
		}
		else
		{
			ValuetoGet = 0;
		}
	}
}
public class ChangeShader : MonoBehaviour
{
	public Material[] material;

	private Renderer rend;

	private int MatValue;

	private void Start()
	{
		rend = GetComponent<Renderer>();
		rend.enabled = true;
		rend.sharedMaterial = material[0];
	}

	public void ChangeShaderButtonClicked()
	{
		MonoBehaviour.print("Change mat");
		if (MatValue < material.Length - 1)
		{
			MatValue++;
		}
		else
		{
			MatValue = 0;
		}
		rend.sharedMaterial = material[MatValue];
	}
}
[AddComponentMenu("Camera-Control/Mouse Orbit with zoom")]
public class MouseOrbitImprovedMod : MonoBehaviour
{
	public Transform target;

	public float distance = 5f;

	public float xSpeed = 120f;

	public float ySpeed = 120f;

	public float Yoffset;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float distanceMin = 0.5f;

	public float distanceMax = 15f;

	private Rigidbody rigidbody;

	private float x;

	private float y;

	private bool Rotate;

	private Vector3 ModPosition;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		rigidbody = GetComponent<Rigidbody>();
		if (rigidbody != null)
		{
			rigidbody.freezeRotation = true;
		}
	}

	private void LateUpdate()
	{
		if (Input.GetMouseButtonDown(0))
		{
			Rotate = true;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			Rotate = false;
		}
		if ((bool)target)
		{
			if (Rotate)
			{
				x += Input.GetAxis("Mouse X") * xSpeed * distance * 0.02f;
				y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				y = ClampAngle(y, yMinLimit, yMaxLimit);
			}
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			distance = Mathf.Clamp(distance - Input.GetAxis("Mouse ScrollWheel") * 5f, distanceMin, distanceMax);
			if (Physics.Linecast(target.position, base.transform.position, out var hitInfo))
			{
				distance -= hitInfo.distance;
			}
			Vector3 vector = new Vector3(0f, 0f, 0f - distance);
			ModPosition = target.position;
			ModPosition.y += Yoffset;
			Vector3 position = quaternion * vector + ModPosition;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
	}

	public static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class MegaLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Right_Front_Hip;

	public Transform Left_Front_Hip;

	public Transform Right_Mid_Hip;

	public Transform Left_Mid_Hip;

	public Transform Right_Back_Hip;

	public Transform Left_Back_Hip;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Bite;

	public AudioClip Ammo2;

	public AudioClip Ammo3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 2);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Ammo2;
			break;
		case 1:
			pain = Ammo3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(1.25f, 1.5f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.1f, 0.25f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.1f, 0.25f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.1f, 0.25f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1.25f, 1.5f);
			source[1].PlayOneShot(Bite, 1f);
			lastframe = currframe;
			break;
		case "Fly":
			source[1].pitch = UnityEngine.Random.Range(0.4f, 0.6f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.1f, 0.25f));
			}
			else
			{
				source[1].PlayOneShot(Bite, UnityEngine.Random.Range(0.1f, 0.25f));
			}
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.6f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Atk":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.75f);
			source[0].PlayOneShot(Ammo2, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.75f);
			source[0].PlayOneShot(Ammo3, 0.25f);
			lastframe = currframe;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		_ = -Root.right;
		anm.SetBool("OnGround", IsOnGround);
		OnReset = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnJump = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
			anm.SetInteger("Move", 1);
		}
		else if (IsOnGround)
		{
			roll = Mathf.Lerp(roll, 0f, 0.1f);
			pitch = Mathf.Lerp(pitch, 0f, 0.1f);
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
		}
		else if (Health == 0f)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyGravity(0.4f);
		}
		else
		{
			body.drag = 1f;
			body.angularDrag = 1f;
		}
		if (OnAnm.IsName("Mega|IdleA") | OnAnm.IsName("Mega|Die1") | OnAnm.IsName("Mega|Die2") | OnAnm.IsName("Mega|Fall"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Mega|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 1);
					PlaySound("Die", 11);
				}
			}
			else if (OnAnm.IsName("Mega|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Die", 0);
				}
			}
			else if (OnAnm.IsName("Mega|Fall"))
			{
				OnReset = true;
				IsOnLevitation = true;
				if (IsInWater)
				{
					anm.SetBool("OnGround", value: true);
				}
				if (OnAnm.normalizedTime < 0.05f)
				{
					source[0].PlayOneShot(Ammo3, 0.5f);
				}
			}
		}
		else if (OnAnm.IsName("Mega|Walk"))
		{
			Move(base.transform.forward, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Mega|Run"))
		{
			IsOnLevitation = true;
			Move(base.transform.forward, 10f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Mega|Walk-"))
		{
			Move(-base.transform.forward, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Mega|Strafe+"))
		{
			Move(base.transform.right, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Mega|Strafe-"))
		{
			Move(-base.transform.right, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Mega|Takeoff"))
		{
			IsOnLevitation = true;
			OnJump = true;
			if ((double)OnAnm.normalizedTime > 0.6)
			{
				Move(Vector3.up, 50f);
			}
			PlaySound("Fly", 3);
			PlaySound("Fly", 6);
			PlaySound("Fly", 9);
			PlaySound("Fly", 12);
			PlaySound("Fly", 15);
		}
		else if (OnAnm.IsName("Mega|Flight") | OnAnm.IsName("Mega|FlightForw") | OnAnm.IsName("Mega|FlightBack") | OnAnm.IsName("Mega|FlyAtk") | OnAnm.IsName("Mega|FlyIdleA") | OnAnm.IsName("Mega|FlyIdleB"))
		{
			IsOnLevitation = true;
			if (IsOnGround && OnAnm.IsName("Mega|FlyAtk"))
			{
				Move(Vector3.up, 50f);
			}
			Move(Vector3.up, 50f * (0f - anm.GetFloat("Pitch")));
			if (anm.GetInteger("Move") == 0)
			{
				roll = Mathf.Lerp(roll, 0f, Ang_T);
				pitch = Mathf.Lerp(pitch, 0f, Ang_T);
			}
			else if (anm.GetInteger("Move") > 0 && anm.GetInteger("Move") < 4)
			{
				if (anm.GetInteger("Move") == 1)
				{
					Move(-Root.up, 50f);
				}
				else
				{
					Move(-Root.up, 100f);
				}
				pitch = Mathf.Lerp(pitch, Mathf.Clamp(anm.GetFloat("Pitch"), -0.75f, 1f) * 90f, Ang_T);
				roll = Mathf.Lerp(roll, (0f - spineX) * 16f, Ang_T);
			}
			else if (anm.GetInteger("Move") == -1)
			{
				Move(-base.transform.forward, 75f);
				pitch = Mathf.Lerp(pitch, 0f, Ang_T);
				roll = Mathf.Lerp(roll, 0f, Ang_T);
			}
			else if (anm.GetInteger("Move") == -10)
			{
				Move(base.transform.right, 75f);
				pitch = Mathf.Lerp(pitch, 0f, Ang_T);
				roll = Mathf.Lerp(roll, 45f, Ang_T);
			}
			else if (anm.GetInteger("Move") == 10)
			{
				Move(-base.transform.right, 75f);
				pitch = Mathf.Lerp(pitch, 0f, Ang_T);
				roll = Mathf.Lerp(roll, -45f, Ang_T);
			}
			if (OnAnm.IsName("Mega|FlyAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 5);
				PlaySound("Bite", 10);
			}
			if (OnAnm.IsName("Mega|FlyIdleA") | OnAnm.IsName("Mega|FlyIdleB"))
			{
				PlaySound("Fly", 2);
				PlaySound("Fly", 4);
				PlaySound("Fly", 6);
				PlaySound("Fly", 8);
				PlaySound("Fly", 10);
			}
			else
			{
				PlaySound("Fly", 4);
				PlaySound("Fly", 7);
				PlaySound("Fly", 10);
				PlaySound("Fly", 13);
				PlaySound("Fly", 1);
			}
		}
		else if (OnAnm.IsName("Mega|Landing"))
		{
			IsOnLevitation = true;
			PlaySound("Step", 9);
			PlaySound("Step", 10);
		}
		else if (OnAnm.IsName("Mega|IdleB"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Mega|IdleC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Mega|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Mega|Drink"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Mega|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Mega|Die-"))
		{
			IsConstrained = true;
			PlaySound("Atk", 10);
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).position;
			Root.rotation *= Quaternion.Euler(0f - pitch, roll, 0f);
			Right_Front_Hip.rotation *= Quaternion.Euler(roll, 0f, 0f);
			Left_Front_Hip.rotation *= Quaternion.Euler(0f, roll, 0f);
			Right_Mid_Hip.rotation *= Quaternion.Euler(roll, 0f, 0f);
			Left_Mid_Hip.rotation *= Quaternion.Euler(0f, roll, 0f);
			Right_Back_Hip.rotation *= Quaternion.Euler(0f, roll, 0f);
			Left_Back_Hip.rotation *= Quaternion.Euler(roll, 0f, 0f);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.None);
			anm.SetBool("OnGround", IsOnGround);
		}
	}
}
public class TriloLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip MedSplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(MedSplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Flush":
			source[1].pitch = UnityEngine.Random.Range(1.25f, 1.5f);
			source[1].PlayOneShot(Waterflush, 0.25f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.25f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Neck0.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 30f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 30f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 30f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 30f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 60f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 1f;
			body.angularDrag = 1f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Trilo|Die") | OnAnm.IsName("Trilo|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Trilo|Swim"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|SwimStrafe-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|SwimStrafe+"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|SwimInpulse"))
		{
			if (IsInWater && (double)OnAnm.normalizedTime < 0.4)
			{
				PlaySound("Flush", 2);
				Move(base.transform.forward, 80f);
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|Atk") | OnAnm.IsName("Trilo|SwimAtk"))
		{
			if (OnAnm.IsName("Trilo|SwimAtk"))
			{
				PlaySound("Flush", 2);
				PlaySound("Bite", 7);
				OnAttack = true;
			}
			else
			{
				PlaySound("Flush", 1);
				PlaySound("Bite", 10);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Trilo|OnGround"))
		{
			Move(base.transform.forward, 25f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Trilo|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Trilo|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), roll * 6f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public enum WaterQuality
{
	High = 2,
	Medium = 1,
	Low = 0
}
[ExecuteInEditMode]
public class JPWater : MonoBehaviour
{
	private Camera cam;

	public Material WaterMaterial;

	[SerializeField]
	private WaterQuality WaterQuality = WaterQuality.High;

	[SerializeField]
	private bool EdgeBlend = true;

	[SerializeField]
	private bool GerstnerDisplace = true;

	[SerializeField]
	private bool DisablePixelLights = true;

	[SerializeField]
	private int ReflectionSize = 256;

	[SerializeField]
	private float ClipPlaneOffset = 0.07f;

	[SerializeField]
	private LayerMask ReflectLayers = -1;

	public Light DirectionalLight;

	private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

	private RenderTexture m_ReflectionTexture;

	private int m_OldReflectionTextureSize;

	private static bool s_InsideWater;

	[Header("UNDERWATER EFFECT")]
	[SerializeField]
	private bool UnderwaterEffect = true;

	public AudioSource Underwater;

	public Texture[] LightCookie;

	public Color32 defaultFogColor;

	public float defaultFogDensity;

	private Vector3 defaultLightDir = Vector3.zero;

	[SerializeField]
	private float UnderwaterDensity;

	private float screenWaterY;

	[Header("WATER PARTICLES FX")]
	[SerializeField]
	private bool ParticlesEffect = true;

	public ParticleSystem ripples;

	public ParticleSystem splash;

	public AudioClip Largesplash;

	private float count;

	private FlareLayer sunflare;

	private void Start()
	{
		cam = Camera.main;
		defaultLightDir = DirectionalLight.transform.forward;
		sunflare = cam.GetComponent<FlareLayer>();
	}

	private void Update()
	{
		if (!GetComponent<MeshRenderer>().isVisible | !WaterMaterial | !cam | s_InsideWater)
		{
			return;
		}
		if (WaterQuality > WaterQuality.Medium)
		{
			WaterMaterial.shader.maximumLOD = 501;
		}
		else if (WaterQuality > WaterQuality.Low)
		{
			WaterMaterial.shader.maximumLOD = 301;
		}
		else
		{
			WaterMaterial.shader.maximumLOD = 201;
		}
		if ((bool)DirectionalLight)
		{
			WaterMaterial.SetVector("_DirectionalLightDir", DirectionalLight.transform.forward);
		}
		if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth) | !EdgeBlend)
		{
			Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
			Shader.DisableKeyword("WATER_EDGEBLEND_ON");
		}
		else
		{
			Shader.EnableKeyword("WATER_EDGEBLEND_ON");
			Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
			cam.depthTextureMode |= DepthTextureMode.Depth;
		}
		if (GerstnerDisplace)
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
		}
		else
		{
			Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
			Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
		}
		s_InsideWater = true;
		CreateWaterObjects(cam, out var reflectionCamera);
		Vector3 position = base.transform.position;
		Vector3 up = base.transform.up;
		int pixelLightCount = QualitySettings.pixelLightCount;
		if (DisablePixelLights)
		{
			QualitySettings.pixelLightCount = 0;
		}
		if (UpdateCameraModes(cam, reflectionCamera))
		{
			float w = 0f - Vector3.Dot(up, position) - ClipPlaneOffset;
			Vector4 plane = new Vector4(up.x, up.y, up.z, w);
			Matrix4x4 reflectionMat = Matrix4x4.zero;
			CalculateReflectionMatrix(ref reflectionMat, plane);
			Vector3 position2 = reflectionMat.MultiplyPoint(cam.transform.position);
			reflectionCamera.worldToCameraMatrix = cam.worldToCameraMatrix * reflectionMat;
			Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
			reflectionCamera.projectionMatrix = cam.CalculateObliqueMatrix(clipPlane);
			reflectionCamera.cullingMask = -17 & ReflectLayers.value;
			reflectionCamera.targetTexture = m_ReflectionTexture;
			GL.invertCulling = true;
			Vector3 eulerAngles = cam.transform.eulerAngles;
			reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
			reflectionCamera.transform.position = position2;
			reflectionCamera.Render();
			GL.invertCulling = false;
			GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
			if (DisablePixelLights)
			{
				QualitySettings.pixelLightCount = pixelLightCount;
			}
			s_InsideWater = false;
		}
	}

	private void OnDisable()
	{
		if ((bool)m_ReflectionTexture)
		{
			UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			m_ReflectionTexture = null;
		}
		foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
		{
			UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
		}
		m_ReflectionCameras.Clear();
	}

	private bool UpdateCameraModes(Camera src, Camera dest)
	{
		if (dest == null)
		{
			return false;
		}
		dest.clearFlags = src.clearFlags;
		dest.backgroundColor = src.backgroundColor;
		dest.farClipPlane = src.farClipPlane;
		dest.nearClipPlane = src.nearClipPlane;
		dest.orthographic = src.orthographic;
		dest.fieldOfView = src.fieldOfView;
		dest.aspect = src.aspect;
		dest.orthographicSize = src.orthographicSize;
		return true;
	}

	private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera)
	{
		reflectionCamera = null;
		if (!m_ReflectionTexture | (m_OldReflectionTextureSize != ReflectionSize))
		{
			if ((bool)m_ReflectionTexture)
			{
				UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
			}
			m_ReflectionTexture = new RenderTexture(ReflectionSize, ReflectionSize, 16)
			{
				name = "__WaterReflection" + GetInstanceID(),
				isPowerOfTwo = true,
				hideFlags = HideFlags.DontSave
			};
			m_OldReflectionTextureSize = ReflectionSize;
		}
		m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
		if (!reflectionCamera)
		{
			GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
			reflectionCamera = gameObject.GetComponent<Camera>();
			reflectionCamera.enabled = false;
			reflectionCamera.transform.position = base.transform.position;
			reflectionCamera.transform.rotation = base.transform.rotation;
			reflectionCamera.gameObject.AddComponent<FlareLayer>();
			gameObject.hideFlags = HideFlags.HideAndDontSave;
			m_ReflectionCameras[currentCamera] = reflectionCamera;
		}
	}

	private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
	{
		Vector3 point = pos + normal * ClipPlaneOffset;
		Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
		Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
		Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
		return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
	}

	private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
	{
		reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
		reflectionMat.m01 = -2f * plane[0] * plane[1];
		reflectionMat.m02 = -2f * plane[0] * plane[2];
		reflectionMat.m03 = -2f * plane[3] * plane[0];
		reflectionMat.m10 = -2f * plane[1] * plane[0];
		reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
		reflectionMat.m12 = -2f * plane[1] * plane[2];
		reflectionMat.m13 = -2f * plane[3] * plane[1];
		reflectionMat.m20 = -2f * plane[2] * plane[0];
		reflectionMat.m21 = -2f * plane[2] * plane[1];
		reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
		reflectionMat.m23 = -2f * plane[3] * plane[2];
		reflectionMat.m30 = 0f;
		reflectionMat.m31 = 0f;
		reflectionMat.m32 = 0f;
		reflectionMat.m33 = 1f;
	}

	private void OnGUI()
	{
		if (!Application.isPlaying | !UnderwaterEffect | !cam)
		{
			return;
		}
		float y = cam.ScreenToWorldPoint(new Vector3(0f, 0f, cam.nearClipPlane)).y;
		float y2 = cam.ScreenToWorldPoint(new Vector3(0f, Screen.height, cam.nearClipPlane)).y;
		float y3 = cam.ScreenToWorldPoint(new Vector3(Screen.width, 0f, cam.nearClipPlane)).y;
		float y4 = cam.ScreenToWorldPoint(new Vector3(Screen.width, Screen.height, cam.nearClipPlane)).y;
		screenWaterY = Mathf.Clamp((Mathf.Min(y, y3) - base.transform.position.y) / (Mathf.Min(y, y3) - Mathf.Min(y2, y4)), -16f, 16f);
		Color32 b = Color32.Lerp(WaterMaterial.GetColor("_ReflectionColor"), WaterMaterial.GetColor("_BaseColor"), screenWaterY / 16f);
		RenderSettings.fogColor = Color32.Lerp(defaultFogColor, b, Mathf.Clamp01(screenWaterY));
		RenderSettings.fogDensity = Mathf.Lerp(defaultFogDensity, UnderwaterDensity, Mathf.Clamp01(screenWaterY));
		cam.backgroundColor = RenderSettings.fogColor;
		Color color = WaterMaterial.GetColor("_ReflectionColor");
		WaterMaterial.SetColor("_ReflectionColor", new Color(color.r, color.g, color.b, Mathf.Clamp(screenWaterY / 16f, 0.5f, 1f)));
		if (screenWaterY > 0.5f)
		{
			if (!Underwater.isPlaying)
			{
				Underwater.Play();
				sunflare.enabled = false;
				cam.clearFlags = CameraClearFlags.Color;
				DirectionalLight.transform.forward = -Vector3.up;
			}
			if (LightCookie.Length != 0)
			{
				DirectionalLight.cookie = LightCookie[Mathf.FloorToInt(Time.fixedTime * 16f % (float)LightCookie.Length)];
			}
		}
		else if (Underwater.isPlaying)
		{
			Underwater.Stop();
			sunflare.enabled = true;
			cam.clearFlags = CameraClearFlags.Skybox;
			DirectionalLight.transform.forward = defaultLightDir;
			DirectionalLight.cookie = null;
		}
	}

	private void OnTriggerStay(Collider col)
	{
		if (ParticlesEffect)
		{
			WaterParticleFX(col, ripples);
		}
	}

	private void OnTriggerExit(Collider col)
	{
		if (ParticlesEffect)
		{
			WaterParticleFX(col, splash);
		}
	}

	private void OnTriggerEnter(Collider col)
	{
		if (ParticlesEffect)
		{
			WaterParticleFX(col, splash);
		}
	}

	private void WaterParticleFX(Collider col, ParticleSystem particleFx)
	{
		count += Time.fixedDeltaTime;
		Creature creature = null;
		if (!col.transform.root.GetComponent<Rigidbody>() || !(col.transform.root.tag == "Creature"))
		{
			return;
		}
		creature = col.transform.root.GetComponent<Creature>();
		creature.waterY = base.transform.position.y;
		if (!creature.IsVisible || (particleFx == ripples && count < (float)(creature.loop % 10)))
		{
			return;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = creature.rend[0];
		if (skinnedMeshRenderer.bounds.Contains(new Vector3(col.transform.position.x, base.transform.position.y, col.transform.position.z)) && (!creature.anm.GetInteger("Move").Equals(0) | (creature.CanFly && creature.IsOnLevitation) | creature.OnJump | creature.OnAttack))
		{
			if (particleFx == splash && (!creature.IsOnGround | creature.OnJump))
			{
				col.transform.root.GetComponents<AudioSource>()[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
				col.transform.root.GetComponents<AudioSource>()[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.5f, 0.75f));
			}
			else
			{
				particleFx = ripples;
			}
			Vector2 vector = new Vector2(skinnedMeshRenderer.bounds.center.x, skinnedMeshRenderer.bounds.center.z);
			ParticleSystem particleSystem = UnityEngine.Object.Instantiate(particleFx, new Vector3(vector.x, base.transform.position.y + 0.01f, vector.y), Quaternion.Euler(-90f, 0f, 0f));
			float num = skinnedMeshRenderer.bounds.size.magnitude / 10f;
			particleSystem.transform.localScale = new Vector3(num, num, num);
			UnityEngine.Object.Destroy(particleSystem.gameObject, 3f);
			count = 0f;
		}
	}
}
public class Creature : MonoBehaviour
{
	[HideInInspector]
	public enum PathType
	{
		Walk,
		Run
	}

	[HideInInspector]
	public enum TargetAction
	{
		None,
		Sleep,
		Eat,
		Drink
	}

	[Serializable]
	public struct _PathEditor
	{
		[Tooltip("Place your waypoint gameobject in a reacheable position.\nDon't put a waypoint in air if the creature are not able to fly")]
		public GameObject _Waypoint;

		public PathType _PathType;

		public TargetAction _TargetAction;

		[Tooltip("Using a priority of 100% will disable all autonomous AI for this waypoint\nObstacle avoid AI and custom targets search still enabled")]
		[Range(1f, 100f)]
		public int _Priority;

		public _PathEditor(GameObject Waypoint, PathType PathType, TargetAction TargetAction, int Priority)
		{
			_Waypoint = Waypoint;
			_PathType = PathType;
			_TargetAction = TargetAction;
			_Priority = Priority;
		}
	}

	[HideInInspector]
	public enum TargetType
	{
		Enemy,
		Friend
	}

	[Serializable]
	public struct _TargetEditor
	{
		public GameObject _GameObject;

		public TargetType _TargetType;

		[Tooltip("If MaxRange is zero, range is infinite. \nCreature will start his attack/tracking once in range.")]
		public int MaxRange;
	}

	public enum Skin
	{
		SkinA,
		SkinB,
		SkinC
	}

	public enum Eyes
	{
		Type0,
		Type1,
		Type2,
		Type3,
		Type4,
		Type5,
		Type6,
		Type7,
		Type8,
		Type9,
		Type10,
		Type11,
		Type12,
		Type13,
		Type14,
		Type15
	}

	public enum IkType
	{
		None,
		Convex,
		Quad,
		Flying,
		SmBiped,
		LgBiped
	}

	private enum Vect
	{
		forward,
		strafe,
		backward,
		zero
	}

	[Space(10f)]
	[Header("ARTIFICIAL INTELLIGENCE")]
	public bool UseAI;

	private const string PathHelp = "Use gameobjects as waypoints to define a path for this creature by \ntaking into account the priority between autonomous AI and its path.";

	private const string WaypointHelp = "Place your waypoint gameobject in a reacheable position.\nDon't put a waypoint in air if the creature are not able to fly";

	private const string PriorityPathHelp = "Using a priority of 100% will disable all autonomous AI for this waypoint\nObstacle avoid AI and custom targets search still enabled";

	private const string TargetHelp = "Use gameobjects to assign a custom enemy/friend for this creature\nCan be any kind of gameobject e.g : player, other creature.\nThe creature will include friend/enemy goals in its search. \nEnemy: triggered if the target is in range. \nFriend: triggered when the target moves away.";

	private const string MaxRangeHelp = "If MaxRange is zero, range is infinite. \nCreature will start his attack/tracking once in range.";

	[Space(10f)]
	[Tooltip("Use gameobjects as waypoints to define a path for this creature by \ntaking into account the priority between autonomous AI and its path.")]
	public List<_PathEditor> PathEditor;

	[HideInInspector]
	public int nextPath;

	[Space(10f)]
	[Tooltip("Use gameobjects to assign a custom enemy/friend for this creature\nCan be any kind of gameobject e.g : player, other creature.\nThe creature will include friend/enemy goals in its search. \nEnemy: triggered if the target is in range. \nFriend: triggered when the target moves away.")]
	public List<_TargetEditor> TargetEditor;

	[Space(10f)]
	[Header("CREATURE SETTINGS")]
	public Skin bodyTexture;

	public Eyes eyesTexture;

	[Space(5f)]
	[Range(0f, 100f)]
	public float Health = 100f;

	[Range(0f, 100f)]
	public float Water = 100f;

	[Range(0f, 100f)]
	public float Food = 100f;

	[Range(0f, 100f)]
	public float Stamina = 100f;

	[Space(5f)]
	[Range(1f, 10f)]
	public float DamageMultiplier = 1f;

	[Range(1f, 10f)]
	public float ArmorMultiplier = 1f;

	[Range(0f, 2f)]
	public float AnimSpeed = 1f;

	public bool Herbivorous;

	public bool CanAttack;

	public bool CanHeadAttack;

	public bool CanTailAttack;

	public bool CanWalk;

	public bool CanJump;

	public bool CanFly;

	public bool CanSwim;

	public bool LowAltitude;

	public bool CanInvertBody;

	public float BaseMass = 1f;

	public float Ang_T = 0.025f;

	public float Crouch_Max;

	public float Yaw_Max;

	public float Pitch_Max;

	[Space(20f)]
	[Header("COMPONENTS AND TEXTURES")]
	public Rigidbody body;

	public LODGroup lod;

	public Animator anm;

	public AudioSource[] source;

	public SkinnedMeshRenderer[] rend;

	public Texture[] skin;

	public Texture[] eyes;

	[Space(20f)]
	[Header("TRANSFORMS AND SOUNDS")]
	public Transform Head;

	[HideInInspector]
	public Manager main;

	[HideInInspector]
	public AnimatorStateInfo OnAnm;

	[HideInInspector]
	public bool IsActive;

	[HideInInspector]
	public bool IsVisible;

	[HideInInspector]
	public bool IsDead;

	[HideInInspector]
	public bool IsOnGround;

	[HideInInspector]
	public bool IsOnWater;

	[HideInInspector]
	public bool IsInWater;

	[HideInInspector]
	public bool IsConstrained;

	[HideInInspector]
	public bool IsOnLevitation;

	[HideInInspector]
	public bool OnAttack;

	[HideInInspector]
	public bool OnJump;

	[HideInInspector]
	public bool OnCrouch;

	[HideInInspector]
	public bool OnReset;

	[HideInInspector]
	public bool OnInvert;

	[HideInInspector]
	public bool OnHeadMove;

	[HideInInspector]
	public bool OnAutoLook;

	[HideInInspector]
	public bool OnTailAttack;

	[HideInInspector]
	public int rndX;

	[HideInInspector]
	public int rndY;

	[HideInInspector]
	public int rndMove;

	[HideInInspector]
	public int rndIdle;

	[HideInInspector]
	public int loop;

	[HideInInspector]
	public string behavior;

	[HideInInspector]
	public string specie;

	[HideInInspector]
	public GameObject objTGT;

	[HideInInspector]
	public GameObject objCOL;

	[HideInInspector]
	public Vector3 HeadPos;

	[HideInInspector]
	public Vector3 posCOL = Vector3.zero;

	[HideInInspector]
	public Vector3 posTGT = Vector3.zero;

	[HideInInspector]
	public Vector3 lookTGT = Vector3.zero;

	[HideInInspector]
	public Vector3 boxscale = Vector3.zero;

	[HideInInspector]
	public Vector3 normal = Vector3.zero;

	[HideInInspector]
	public Quaternion angTGT = Quaternion.identity;

	[HideInInspector]
	public Quaternion normAng = Quaternion.identity;

	[HideInInspector]
	public float currframe;

	[HideInInspector]
	public float lastframe;

	[HideInInspector]
	public float lastHit;

	[HideInInspector]
	public float crouch;

	[HideInInspector]
	public float spineX;

	[HideInInspector]
	public float spineY;

	[HideInInspector]
	public float headX;

	[HideInInspector]
	public float headY;

	[HideInInspector]
	public float pitch;

	[HideInInspector]
	public float roll;

	[HideInInspector]
	public float reverse;

	[HideInInspector]
	public float posY;

	[HideInInspector]
	public float waterY;

	[HideInInspector]
	public float withersSize;

	[HideInInspector]
	public float size;

	[HideInInspector]
	public float speed;

	[HideInInspector]
	public float behaviorCount;

	[HideInInspector]
	public float distTGT;

	[HideInInspector]
	public float delta;

	[HideInInspector]
	public float actionDist;

	[HideInInspector]
	public float angleAdd;

	[HideInInspector]
	public float avoidDelta;

	[HideInInspector]
	public float avoidAdd;

	private const int enemyMaxRange = 50;

	private const int waterMaxRange = 200;

	private const int foodMaxRange = 200;

	private const int friendMaxRange = 200;

	private const int preyMaxRange = 200;

	private const int MoveX = 0;

	private const int MoveY = 1;

	private const int Attack = 2;

	private const int Interact = 3;

	private const int Sleep = 4;

	private const int MoveZ = 5;

	private const int Run = 6;

	private const int CamX = 7;

	private const int CamY = 8;

	private const int CamZ = 9;

	private const int Focus = 10;

	private const int Target = 11;

	private const int Map = 12;

	private const int YesNo = 13;

	private const int Menu = 14;

	private Vector3 FR_HIT;

	private Vector3 FL_HIT;

	private Vector3 BR_HIT;

	private Vector3 BL_HIT;

	private Vector3 FR_Norm = Vector3.up;

	private Vector3 FL_Norm = Vector3.up;

	private Vector3 BR_Norm = Vector3.up;

	private Vector3 BL_Norm = Vector3.up;

	private float BR1;

	private float BR2;

	private float BR3;

	private float BR_Add;

	private float BL1;

	private float BL2;

	private float BL3;

	private float BL_Add;

	private float alt1;

	private float alt2;

	private float a1;

	private float a2;

	private float b1;

	private float b2;

	private float c1;

	private float c2;

	private float FR1;

	private float FR2;

	private float FR3;

	private float FR_Add;

	private float FL1;

	private float FL2;

	private float FL3;

	private float FL_Add;

	private float alt3;

	private float alt4;

	private float a3;

	private float a4;

	private float b3;

	private float b4;

	private float c3;

	private float c4;

	private void Start()
	{
		main = Camera.main.transform.GetComponent<Manager>();
		SetScale(base.transform.localScale.x);
		SetMaterials(bodyTexture.GetHashCode(), eyesTexture.GetHashCode());
		loop = UnityEngine.Random.Range(0, 100);
		specie = base.transform.GetChild(0).name;
	}

	public void SetAI(bool UseAI)
	{
		this.UseAI = UseAI;
		if (!this.UseAI)
		{
			posTGT = Vector3.zero;
			objTGT = null;
			objCOL = null;
			behaviorCount = 0f;
		}
	}

	public void SetMaterials(int bodyindex, int eyesindex)
	{
		bodyTexture = (Skin)bodyindex;
		eyesTexture = (Eyes)eyesindex;
		SkinnedMeshRenderer[] array = rend;
		foreach (SkinnedMeshRenderer obj in array)
		{
			obj.materials[0].mainTexture = skin[bodyindex];
			obj.materials[1].mainTexture = eyes[eyesindex];
		}
	}

	public void SetScale(float resize)
	{
		size = resize;
		base.transform.localScale = new Vector3(resize, resize, resize);
		body.mass = BaseMass * size;
		withersSize = (base.transform.GetChild(0).GetChild(0).position - base.transform.position).magnitude;
		boxscale = rend[0].bounds.extents;
		source[0].maxDistance = Mathf.Lerp(50f, 300f, size);
		source[1].maxDistance = Mathf.Lerp(50f, 150f, size);
	}

	public void StatusUpdate()
	{
		IsVisible = false;
		SkinnedMeshRenderer[] array = rend;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].isVisible)
			{
				IsVisible = true;
			}
		}
		if (!main.RealtimeGame)
		{
			float magnitude = (main.transform.position - base.transform.position).magnitude;
			if (!IsVisible && magnitude > 100f)
			{
				IsActive = false;
				anm.cullingMode = AnimatorCullingMode.CullCompletely;
				return;
			}
			IsActive = true;
			anm.cullingMode = AnimatorCullingMode.AlwaysAnimate;
		}
		else
		{
			IsActive = true;
			anm.cullingMode = AnimatorCullingMode.AlwaysAnimate;
		}
		anm.speed = AnimSpeed;
		if (anm.GetNextAnimatorClipInfo(0).Length != 0)
		{
			OnAnm = anm.GetNextAnimatorStateInfo(0);
		}
		else if (anm.GetCurrentAnimatorClipInfo(0).Length != 0)
		{
			OnAnm = anm.GetCurrentAnimatorStateInfo(0);
		}
		if ((currframe == 15f) | ((double)anm.GetAnimatorTransitionInfo(0).normalizedTime > 0.5))
		{
			currframe = 0f;
			lastframe = -1f;
		}
		else
		{
			currframe = Mathf.Round(OnAnm.normalizedTime % 1f * 15f);
		}
		if (Health > 0f)
		{
			if (loop > 100)
			{
				if (CanSwim)
				{
					if (anm.GetInteger("Move") != 0)
					{
						Food = Mathf.Clamp(Food - 0.01f, 0f, 100f);
					}
					if (IsInWater | IsOnWater)
					{
						Stamina = Mathf.Clamp(Stamina + 1f, 0f, 100f);
						Water = Mathf.Clamp(Water + 1f, 0f, 100f);
					}
					else if (CanWalk)
					{
						Stamina = Mathf.Clamp(Stamina - 0.01f, 0f, 100f);
						Water = Mathf.Clamp(Water - 0.01f, 0f, 100f);
					}
					else
					{
						Stamina = Mathf.Clamp(Stamina - 1f, 0f, 100f);
						Water = Mathf.Clamp(Water - 1f, 0f, 100f);
						Health = Mathf.Clamp(Health - 1f, 0f, 100f);
					}
				}
				else
				{
					if (anm.GetInteger("Move") != 0)
					{
						Stamina = Mathf.Clamp(Stamina - 0.01f, 0f, 100f);
						Water = Mathf.Clamp(Water - 0.01f, 0f, 100f);
						Food = Mathf.Clamp(Herbivorous ? (Food - 0.1f) : (Food - 0.01f), 0f, 100f);
					}
					if (IsInWater)
					{
						Stamina = Mathf.Clamp(Stamina - 1f, 0f, 100f);
						Health = Mathf.Clamp(Health - 1f, 0f, 100f);
					}
				}
				if ((Food == 0f) | (Stamina == 0f) | (Water == 0f))
				{
					Health = Mathf.Clamp(Health - 0.1f, 0f, 100f);
				}
				else
				{
					Health = Mathf.Clamp(Health + 0.1f, 0f, 100f);
				}
				loop = 0;
			}
			else
			{
				loop++;
			}
			return;
		}
		Water = 0f;
		Food = 0f;
		Stamina = 0f;
		behavior = "Dead";
		if (main.TimeAfterDead == 0)
		{
			return;
		}
		if (behaviorCount > 0f)
		{
			behaviorCount = 0f;
		}
		else if (behaviorCount == (float)(-main.TimeAfterDead))
		{
			if (main.selected >= main.creaturesList.IndexOf(base.transform.gameObject) && main.selected > 0)
			{
				main.selected--;
			}
			main.creaturesList.Remove(base.transform.gameObject);
			UnityEngine.Object.Destroy(base.transform.gameObject);
		}
		else
		{
			behaviorCount -= 1f;
		}
	}

	private void SpawnBlood(Vector3 position)
	{
		ParticleSystem particleSystem = UnityEngine.Object.Instantiate(main.blood, position, Quaternion.Euler(-90f, 0f, 0f));
		particleSystem.transform.localScale = new Vector3(boxscale.z / 10f, boxscale.z / 10f, boxscale.z / 10f);
		UnityEngine.Object.Destroy(particleSystem.gameObject, 1f);
	}

	private void OnCollisionExit()
	{
		objCOL = null;
	}

	public void ManageCollision(Collision col, float pitch_max, float crouch_max, AudioSource[] source, AudioClip pain, AudioClip Hit_jaw, AudioClip Hit_head, AudioClip Hit_tail)
	{
		if (col.transform.root.tag.Equals("Creature"))
		{
			Creature component = col.gameObject.GetComponent<Creature>();
			objCOL = component.gameObject;
			if (!UseAI && OnAttack)
			{
				objTGT = component.gameObject;
				component.objTGT = base.transform.gameObject;
				behaviorCount = 500f;
				component.behaviorCount = 500f;
				if (component.specie == specie)
				{
					behavior = "Contest";
					component.behavior = "Contest";
				}
				else if (component.CanAttack)
				{
					behavior = "Battle";
					component.behavior = "Battle";
				}
				else
				{
					behavior = "Battle";
					component.behavior = "ToFlee";
				}
			}
			if (IsDead && lastHit == 0f && component.IsConstrained)
			{
				SpawnBlood(col.GetContact(0).point);
				body.AddForce(-component.transform.forward, ForceMode.Acceleration);
				lastHit = 25f;
				return;
			}
			if (lastHit == 0f && component.OnAttack)
			{
				float num = Mathf.Clamp(component.BaseMass * component.DamageMultiplier / (BaseMass * ArmorMultiplier), 10f, 100f);
				if (col.collider.gameObject.name.StartsWith("jaw"))
				{
					SpawnBlood(col.GetContact(0).point);
					if (!IsInWater)
					{
						body.AddForce(-col.GetContact(0).normal * component.body.mass / 4f, ForceMode.Acceleration);
					}
					lastHit = 50f;
					if (IsDead)
					{
						return;
					}
					source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
					source[0].PlayOneShot(pain, 1f);
					source[1].PlayOneShot(Hit_jaw, UnityEngine.Random.Range(0.1f, 0.4f));
					Health = Mathf.Clamp(Health - num, 0f, 100f);
				}
				else if (col.collider.gameObject.name.Equals("head"))
				{
					SpawnBlood(col.GetContact(0).point);
					if (!IsInWater)
					{
						body.AddForce(col.GetContact(0).normal * component.body.mass / 4f, ForceMode.Acceleration);
					}
					lastHit = 50f;
					if (IsDead)
					{
						return;
					}
					source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
					source[0].PlayOneShot(pain, 1f);
					source[1].PlayOneShot(Hit_head, UnityEngine.Random.Range(0.1f, 0.4f));
					if (!Herbivorous)
					{
						Health = Mathf.Clamp(Health - num, 0f, 100f);
					}
					else
					{
						Health = Mathf.Clamp(Health - num / 10f, 0f, 100f);
					}
				}
				else if (!col.collider.gameObject.name.Equals("root"))
				{
					SpawnBlood(col.GetContact(0).point);
					if (!IsInWater)
					{
						body.AddForce(col.GetContact(0).normal * component.body.mass / 4f, ForceMode.Acceleration);
					}
					lastHit = 50f;
					if (IsDead)
					{
						return;
					}
					source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
					source[0].PlayOneShot(pain, 1f);
					source[1].PlayOneShot(Hit_tail, UnityEngine.Random.Range(0.1f, 0.4f));
					if (!Herbivorous)
					{
						Health = Mathf.Clamp(Health - num, 0f, 100f);
					}
					else
					{
						Health -= (Health = Mathf.Clamp(Health - num / 10f, 0f, 100f));
					}
				}
			}
			if (objTGT != objCOL)
			{
				lookTGT = component.Head.position;
				posCOL = col.GetContact(0).point;
			}
		}
		else if (col.gameObject != objTGT)
		{
			objCOL = col.gameObject;
			posCOL = col.GetContact(0).point;
		}
	}

	public void GetGroundPos(IkType ikType, Transform RLeg1 = null, Transform RLeg2 = null, Transform RLeg3 = null, Transform LLeg1 = null, Transform LLeg2 = null, Transform LLeg3 = null, Transform RArm1 = null, Transform RArm2 = null, Transform RArm3 = null, Transform LArm1 = null, Transform LArm2 = null, Transform LArm3 = null, float FeetOffset = 0f)
	{
		posY = 0f - base.transform.position.y;
		if (main.UseRaycast)
		{
			if ((ikType == IkType.None) | IsDead | IsInWater | !IsOnGround)
			{
				if (Physics.Raycast(base.transform.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo, withersSize * 1.5f, 1))
				{
					posY = hitInfo.point.y;
					normal = hitInfo.normal;
					IsOnGround = true;
				}
				else
				{
					IsOnGround = false;
				}
			}
			else if (ikType >= IkType.SmBiped)
			{
				if (Physics.Raycast(base.transform.position + base.transform.forward * 2f + Vector3.up, -Vector3.up, out var hitInfo2, withersSize * 2f, 1))
				{
					posY = hitInfo2.point.y;
					normal = hitInfo2.normal;
				}
				if (Physics.Raycast(RLeg3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo3, withersSize * 2f, 1))
				{
					IsOnGround = true;
					BR_HIT = hitInfo3.point;
					BR_Norm = hitInfo3.normal;
				}
				else
				{
					BR_HIT.y = 0f - base.transform.position.y;
				}
				if (Physics.Raycast(LLeg3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo4, withersSize * 2f, 1))
				{
					IsOnGround = true;
					BL_HIT = hitInfo4.point;
					BL_Norm = hitInfo4.normal;
				}
				else
				{
					BL_HIT.y = 0f - base.transform.position.y;
				}
				if (posY > BL_HIT.y && posY > BR_HIT.y)
				{
					posY = Mathf.Max(BL_HIT.y, BR_HIT.y);
				}
				else
				{
					posY = Mathf.Min(BL_HIT.y, BR_HIT.y);
				}
				normal = (BL_Norm + BR_Norm + normal) / 3f;
			}
			else if (ikType == IkType.Flying)
			{
				IsOnGround = false;
				if (Physics.Raycast(base.transform.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo5, withersSize * 4f, 1))
				{
					normal = hitInfo5.normal;
					IsOnGround = true;
					if (Physics.Raycast(RArm3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo6, withersSize * 4f, 1))
					{
						FR_HIT = hitInfo6.point;
						FR_Norm = hitInfo6.normal;
					}
					else
					{
						FR_Norm = hitInfo5.normal;
						FR_HIT.y = 0f - base.transform.position.y;
					}
					if (Physics.Raycast(LArm3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo7, withersSize * 4f, 1))
					{
						FL_HIT = hitInfo7.point;
						FL_Norm = hitInfo7.normal;
					}
					else
					{
						FL_Norm = hitInfo5.normal;
						FL_HIT.y = 0f - base.transform.position.y;
					}
					if (Physics.Raycast(RLeg3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo8, withersSize * 4f, 1))
					{
						BR_HIT = hitInfo8.point;
						BR_Norm = hitInfo8.normal;
					}
					else
					{
						BR_Norm = hitInfo5.normal;
						BR_HIT.y = 0f - base.transform.position.y;
					}
					if (Physics.Raycast(LLeg3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo9, withersSize * 4f, 1))
					{
						BL_HIT = hitInfo9.point;
						BL_Norm = hitInfo9.normal;
					}
					else
					{
						BL_Norm = hitInfo5.normal;
						BL_HIT.y = 0f - base.transform.position.y;
					}
					posY = hitInfo5.point.y;
				}
			}
			else
			{
				IsOnGround = false;
				if (Physics.Raycast(RArm3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo10, withersSize * 2f, 1))
				{
					FR_HIT = hitInfo10.point;
					FR_Norm = hitInfo10.normal;
					IsOnGround = true;
				}
				else
				{
					FR_HIT.y = 0f - base.transform.position.y;
				}
				if (Physics.Raycast(LArm3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo11, withersSize * 2f, 1))
				{
					FL_HIT = hitInfo11.point;
					FL_Norm = hitInfo11.normal;
					IsOnGround = true;
				}
				else
				{
					FL_HIT.y = 0f - base.transform.position.y;
				}
				if (Physics.Raycast(RLeg3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo12, withersSize * 2f, 1))
				{
					BR_HIT = hitInfo12.point;
					BR_Norm = hitInfo12.normal;
					IsOnGround = true;
				}
				else
				{
					BR_HIT.y = 0f - base.transform.position.y;
				}
				if (Physics.Raycast(LLeg3.position + Vector3.up * withersSize, -Vector3.up, out var hitInfo13, withersSize * 2f, 1))
				{
					BL_HIT = hitInfo13.point;
					BL_Norm = hitInfo13.normal;
					IsOnGround = true;
				}
				else
				{
					BL_HIT.y = 0f - base.transform.position.y;
				}
				if (ikType == IkType.Convex)
				{
					if (IsConstrained)
					{
						posY = Mathf.Min(BR_HIT.y, BL_HIT.y, FR_HIT.y, FL_HIT.y);
					}
					else
					{
						posY = (BR_HIT.y + BL_HIT.y + FR_HIT.y + FL_HIT.y) / 4f;
					}
				}
				else if (IsConstrained | !main.UseIK)
				{
					posY = Mathf.Min(BR_HIT.y, BL_HIT.y, FR_HIT.y, FL_HIT.y);
				}
				else
				{
					posY = (BR_HIT.y + BL_HIT.y + FR_HIT.y + FL_HIT.y - size) / 4f;
				}
				normal = Vector3.Cross(FR_HIT - BL_HIT, BR_HIT - FL_HIT).normalized;
			}
		}
		else if ((ikType == IkType.None) | IsDead | IsInWater | !IsOnGround)
		{
			float num = (base.transform.position.x - main.T.transform.position.x) / main.T.terrainData.size.x * main.tres;
			float num2 = (base.transform.position.z - main.T.transform.position.z) / main.T.terrainData.size.z * main.tres;
			normal = main.T.terrainData.GetInterpolatedNormal(num / main.tres, num2 / main.tres);
			posY = main.T.SampleHeight(base.transform.position) + main.T.GetPosition().y;
		}
		else if (ikType >= IkType.SmBiped)
		{
			BR_HIT = new Vector3(RLeg3.position.x, main.T.SampleHeight(RLeg3.position) + main.tpos.y, RLeg3.position.z);
			float num3 = (RLeg3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			float num4 = (RLeg3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			BR_Norm = main.tdata.GetInterpolatedNormal(num3 / main.tres, num4 / main.tres);
			BL_HIT = new Vector3(LLeg3.position.x, main.T.SampleHeight(LLeg3.position) + main.tpos.y, LLeg3.position.z);
			num3 = (LLeg3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num4 = (LLeg3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			BL_Norm = main.tdata.GetInterpolatedNormal(num3 / main.tres, num4 / main.tres);
			if (posY > BL_HIT.y && posY > BR_HIT.y)
			{
				posY = Mathf.Max(BL_HIT.y, BR_HIT.y);
			}
			else
			{
				posY = Mathf.Min(BL_HIT.y, BR_HIT.y);
			}
			normal = (BL_Norm + BR_Norm + normal) / 3f;
		}
		else if (ikType == IkType.Flying)
		{
			float num5 = (base.transform.position.x - main.T.transform.position.x) / main.T.terrainData.size.x * main.tres;
			float num6 = (base.transform.position.z - main.T.transform.position.z) / main.T.terrainData.size.z * main.tres;
			normal = main.T.terrainData.GetInterpolatedNormal(num5 / main.tres, num6 / main.tres);
			posY = main.T.SampleHeight(base.transform.position) + main.T.GetPosition().y;
			BR_HIT = new Vector3(RLeg3.position.x, main.T.SampleHeight(RLeg3.position) + main.tpos.y, RLeg3.position.z);
			num5 = (RLeg3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num6 = (RLeg3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			BR_Norm = main.tdata.GetInterpolatedNormal(num5 / main.tres, num6 / main.tres);
			BL_HIT = new Vector3(LLeg3.position.x, main.T.SampleHeight(LLeg3.position) + main.tpos.y, LLeg3.position.z);
			num5 = (LLeg3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num6 = (LLeg3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			BL_Norm = main.tdata.GetInterpolatedNormal(num5 / main.tres, num6 / main.tres);
			FR_HIT = new Vector3(RArm3.position.x, main.T.SampleHeight(RArm3.position) + main.tpos.y, RArm3.position.z);
			num5 = (RArm3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num6 = (RArm3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			FR_Norm = main.tdata.GetInterpolatedNormal(num5 / main.tres, num6 / main.tres);
			FL_HIT = new Vector3(LArm3.position.x, main.T.SampleHeight(LArm3.position) + main.tpos.y, LArm3.position.z);
			num5 = (LArm3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num6 = (LArm3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			FL_Norm = main.tdata.GetInterpolatedNormal(num5 / main.tres, num6 / main.tres);
		}
		else
		{
			BR_HIT = new Vector3(RLeg3.position.x, main.T.SampleHeight(RLeg3.position) + main.tpos.y, RLeg3.position.z);
			float num7 = (RLeg3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			float num8 = (RLeg3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			BR_Norm = main.tdata.GetInterpolatedNormal(num7 / main.tres, num8 / main.tres);
			BL_HIT = new Vector3(LLeg3.position.x, main.T.SampleHeight(LLeg3.position) + main.tpos.y, LLeg3.position.z);
			num7 = (LLeg3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num8 = (LLeg3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			BL_Norm = main.tdata.GetInterpolatedNormal(num7 / main.tres, num8 / main.tres);
			FR_HIT = new Vector3(RArm3.position.x, main.T.SampleHeight(RArm3.position) + main.tpos.y, RArm3.position.z);
			num7 = (RArm3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num8 = (RArm3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			FR_Norm = main.tdata.GetInterpolatedNormal(num7 / main.tres, num8 / main.tres);
			FL_HIT = new Vector3(LArm3.position.x, main.T.SampleHeight(LArm3.position) + main.tpos.y, LArm3.position.z);
			num7 = (LArm3.position.x - main.tpos.x) / main.tdata.size.x * main.tres;
			num8 = (LArm3.position.z - main.tpos.z) / main.tdata.size.z * main.tres;
			FL_Norm = main.tdata.GetInterpolatedNormal(num7 / main.tres, num8 / main.tres);
			if (ikType == IkType.Convex)
			{
				if (IsConstrained)
				{
					posY = Mathf.Min(BR_HIT.y, BL_HIT.y, FR_HIT.y, FL_HIT.y);
				}
				else
				{
					posY = (BR_HIT.y + BL_HIT.y + FR_HIT.y + FL_HIT.y) / 4f;
				}
			}
			else if (IsConstrained | !main.UseIK)
			{
				posY = Mathf.Min(BR_HIT.y, BL_HIT.y, FR_HIT.y, FL_HIT.y);
			}
			else
			{
				posY = (BR_HIT.y + BL_HIT.y + FR_HIT.y + FL_HIT.y - size) / 4f;
			}
			normal = Vector3.Cross(FR_HIT - BL_HIT, BR_HIT - FL_HIT).normalized;
		}
		if (base.transform.position.y - size <= posY)
		{
			IsOnGround = true;
		}
		else
		{
			IsOnGround = false;
		}
		waterY = main.WaterAlt - crouch;
		if (base.transform.position.y < waterY && body.worldCenterOfMass.y > waterY)
		{
			IsOnWater = true;
		}
		else
		{
			IsOnWater = false;
		}
		if (body.worldCenterOfMass.y < waterY)
		{
			IsInWater = true;
		}
		else
		{
			IsInWater = false;
		}
		if (IsDead)
		{
			body.maxDepenetrationVelocity = 0.25f;
			body.constraints = RigidbodyConstraints.None;
		}
		else if (IsConstrained)
		{
			body.maxDepenetrationVelocity = 0f;
			crouch = 0f;
			body.constraints = (RigidbodyConstraints)122;
		}
		else
		{
			body.maxDepenetrationVelocity = 5f;
			if (lastHit == 0f)
			{
				body.constraints = RigidbodyConstraints.FreezeRotationZ;
			}
			else
			{
				body.constraints = RigidbodyConstraints.None;
			}
		}
		if (IsOnGround && !IsInWater)
		{
			Quaternion quaternion = Quaternion.LookRotation(Vector3.Cross(base.transform.right, normal), normal);
			if (!CanFly)
			{
				float value = Mathf.DeltaAngle(quaternion.eulerAngles.x, 0f);
				float value2 = Mathf.DeltaAngle(quaternion.eulerAngles.z, 0f);
				float num9 = Mathf.Clamp(value, -45f, 45f);
				float num10 = Mathf.Clamp(value2, -10f, 10f);
				normAng = Quaternion.Euler(0f - num9, anm.GetFloat("Turn"), 0f - num10);
			}
			else
			{
				normAng = Quaternion.Euler(quaternion.eulerAngles.x, anm.GetFloat("Turn"), quaternion.eulerAngles.z);
			}
			posY -= crouch;
		}
		else if (IsInWater | IsOnWater)
		{
			normAng = Quaternion.Euler(0f, anm.GetFloat("Turn"), 0f);
			posY = waterY - body.centerOfMass.y;
		}
		else
		{
			normAng = Quaternion.Euler(0f, anm.GetFloat("Turn"), 0f);
			posY = 0f - base.transform.position.y;
		}
		if (!(!IsVisible | !main.UseIK))
		{
			switch (ikType)
			{
			case IkType.Convex:
				Convex(RLeg1, RLeg2, RLeg3, LLeg1, LLeg2, LLeg3, RArm1, RArm2, RArm3, LArm1, LArm2, LArm3);
				break;
			case IkType.Quad:
				Quad(RLeg1, RLeg2, RLeg3, LLeg1, LLeg2, LLeg3, RArm1, RArm2, RArm3, LArm1, LArm2, LArm3, FeetOffset);
				break;
			case IkType.Flying:
				Flying(RLeg1, RLeg2, RLeg3, LLeg1, LLeg2, LLeg3, RArm1, RArm2, RArm3, LArm1, LArm2, LArm3);
				break;
			case IkType.SmBiped:
				SmBiped(RLeg1, RLeg2, RLeg3, LLeg1, LLeg2, LLeg3);
				break;
			case IkType.LgBiped:
				LgBiped(RLeg1, RLeg2, RLeg3, LLeg1, LLeg2, LLeg3);
				break;
			case IkType.None:
				break;
			}
		}
	}

	public void ApplyGravity(float multiplier = 1f)
	{
		body.AddForce(Vector3.up * size * ((body.velocity.y > 0f) ? (-20f * body.drag) : (-50f * body.drag)) * multiplier, ForceMode.Acceleration);
	}

	public void ApplyYPos()
	{
		if (IsOnGround && ((Mathf.Abs(normal.x) > main.MaxSlope) | (Mathf.Abs(normal.z) > main.MaxSlope)))
		{
			body.AddForce(new Vector3(normal.x, 0f - normal.y, normal.z) * 64f, ForceMode.Acceleration);
			behaviorCount = 0f;
		}
		body.AddForce(Vector3.up * Mathf.Clamp(posY - base.transform.position.y, 0f - size, size), ForceMode.VelocityChange);
	}

	public void Move(Vector3 dir, float force = 0f, bool jump = false)
	{
		if (CanAttack && anm.GetBool("Attack").Equals(obj: true))
		{
			force *= 1.5f;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, normAng, Ang_T * 2f);
		}
		else
		{
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, normAng, Ang_T);
		}
		if (dir != Vector3.zero)
		{
			force = ((CanSwim || IsOnGround) ? (force / (4f / body.drag)) : ((IsInWater | IsOnWater) ? (force / 8f) : ((CanFly || OnJump) ? (force / (4f / body.drag)) : (force / 8f))));
			body.AddForce(dir * force * speed, jump ? ForceMode.VelocityChange : ForceMode.Acceleration);
		}
	}

	public void RotateBone(IkType ikType, float maxX, float maxY = 0f, bool CanMoveHead = true, float t = 0.5f)
	{
		if (AnimSpeed == 0f)
		{
			return;
		}
		if (!OnAttack && !OnJump)
		{
			speed = size * anm.speed * (1f - Mathf.Abs(Mathf.DeltaAngle(base.transform.eulerAngles.y, anm.GetFloat("Turn"))) / 135f);
		}
		if (main.UseIK)
		{
			switch (ikType)
			{
			case IkType.Convex:
			{
				float t2 = 0.1f;
				if (!IsConstrained && !IsDead && IsOnGround && !IsInWater)
				{
					FR1 = Mathf.Lerp(FR1, Mathf.Clamp(0f - alt1, -55f, 0f), t2);
					FR2 = Mathf.Lerp(FR2, b1, t2);
					FR3 = Mathf.Lerp(FR3, c1, t2);
					FL1 = Mathf.Lerp(FL1, Mathf.Clamp(0f - alt2, -55f, 0f), t2);
					FL2 = Mathf.Lerp(FL2, b2, t2);
					FL3 = Mathf.Lerp(FL3, c2, t2);
					BR1 = Mathf.Lerp(BR1, Mathf.Clamp(0f - alt3, -55f, 0f), t2);
					BR2 = Mathf.Lerp(BR2, b3, t2);
					BR3 = Mathf.Lerp(BR3, c3, t2);
					BL1 = Mathf.Lerp(BL1, Mathf.Clamp(0f - alt4, -55f, 0f), t2);
					BL2 = Mathf.Lerp(BL2, b4, t2);
					BL3 = Mathf.Lerp(BL3, c4, t2);
				}
				else
				{
					FR_Add = Mathf.Lerp(FR_Add, 0f, t2);
					FR1 = Mathf.Lerp(FR1, 0f, t2);
					FR2 = Mathf.Lerp(FR2, 0f, t2);
					FR3 = Mathf.Lerp(FR3, 0f, t2);
					FL_Add = Mathf.Lerp(FL_Add, 0f, t2);
					FL1 = Mathf.Lerp(FL1, 0f, t2);
					FL2 = Mathf.Lerp(FL2, 0f, t2);
					FL3 = Mathf.Lerp(FL3, 0f, t2);
					BR_Add = Mathf.Lerp(BR_Add, 0f, t2);
					BR1 = Mathf.Lerp(BR1, 0f, t2);
					BR2 = Mathf.Lerp(BR2, 0f, t2);
					BR3 = Mathf.Lerp(BR3, 0f, t2);
					BL_Add = Mathf.Lerp(BL_Add, 0f, t2);
					BL1 = Mathf.Lerp(BL1, 0f, t2);
					BL2 = Mathf.Lerp(BL2, 0f, t2);
					BL3 = Mathf.Lerp(BL3, 0f, t2);
				}
				break;
			}
			case IkType.Quad:
			{
				float t2 = 0.1f;
				if (!IsConstrained && !IsDead && IsOnGround)
				{
					FR1 = Mathf.Lerp(FR1, Mathf.Clamp(0f - alt1, -50f, 0f), t2);
					FR2 = Mathf.Lerp(FR2, b1, t2);
					FR3 = Mathf.Lerp(FR3, c1, t2);
					FL1 = Mathf.Lerp(FL1, Mathf.Clamp(0f - alt2, -50f, 0f), t2);
					FL2 = Mathf.Lerp(FL2, b2, t2);
					FL3 = Mathf.Lerp(FL3, c2, t2);
					BR1 = Mathf.Lerp(BR1, Mathf.Clamp(0f - alt3, -50f, 0f), t2);
					BR2 = Mathf.Lerp(BR2, b3, t2);
					BR3 = Mathf.Lerp(BR3, c3, t2);
					BL1 = Mathf.Lerp(BL1, Mathf.Clamp(0f - alt4, -50f, 0f), t2);
					BL2 = Mathf.Lerp(BL2, b4, t2);
					BL3 = Mathf.Lerp(BL3, c4, t2);
				}
				else
				{
					FR_Add = Mathf.Lerp(FR_Add, 0f, t2);
					FR1 = Mathf.Lerp(FR1, 0f, t2);
					FR2 = Mathf.Lerp(FR2, 0f, t2);
					FR3 = Mathf.Lerp(FR3, 0f, t2);
					FL_Add = Mathf.Lerp(FL_Add, 0f, t2);
					FL1 = Mathf.Lerp(FL1, 0f, t2);
					FL2 = Mathf.Lerp(FL2, 0f, t2);
					FL3 = Mathf.Lerp(FL3, 0f, t2);
					BR_Add = Mathf.Lerp(BR_Add, 0f, t2);
					BR1 = Mathf.Lerp(BR1, 0f, t2);
					BR2 = Mathf.Lerp(BR2, 0f, t2);
					BR3 = Mathf.Lerp(BR3, 0f, t2);
					BL_Add = Mathf.Lerp(BL_Add, 0f, t2);
					BL1 = Mathf.Lerp(BL1, 0f, t2);
					BL2 = Mathf.Lerp(BL2, 0f, t2);
					BL3 = Mathf.Lerp(BL3, 0f, t2);
				}
				break;
			}
			case IkType.Flying:
			{
				float t2 = 0.25f;
				if (!IsConstrained && !IsDead && IsOnGround && !IsOnLevitation)
				{
					FR1 = Mathf.Lerp(FR1, Mathf.Clamp(0f - alt1, -100f, 0f), t2);
					FR2 = Mathf.Lerp(FR2, b1, t2);
					FR3 = Mathf.Lerp(FR3, c1, t2);
					FL1 = Mathf.Lerp(FL1, Mathf.Clamp(0f - alt2, -100f, 0f), t2);
					FL2 = Mathf.Lerp(FL2, b2, t2);
					FL3 = Mathf.Lerp(FL3, c2, t2);
					BR1 = Mathf.Lerp(BR1, Mathf.Clamp(0f - alt3, -60f, 0f), t2);
					BR2 = Mathf.Lerp(BR2, b3, t2);
					BR3 = Mathf.Lerp(BR3, c3, t2);
					BL1 = Mathf.Lerp(BL1, Mathf.Clamp(0f - alt4, -60f, 0f), t2);
					BL2 = Mathf.Lerp(BL2, b4, t2);
					BL3 = Mathf.Lerp(BL3, c4, t2);
				}
				else
				{
					FR_Add = Mathf.Lerp(FR_Add, 0f, t2);
					FR1 = Mathf.Lerp(FR1, 0f, t2);
					FR2 = Mathf.Lerp(FR2, 0f, t2);
					FR3 = Mathf.Lerp(FR3, 0f, t2);
					FL_Add = Mathf.Lerp(FL_Add, 0f, t2);
					FL1 = Mathf.Lerp(FL1, 0f, t2);
					FL2 = Mathf.Lerp(FL2, 0f, t2);
					FL3 = Mathf.Lerp(FL3, 0f, t2);
					BR_Add = Mathf.Lerp(BR_Add, 0f, t2);
					BR1 = Mathf.Lerp(BR1, 0f, t2);
					BR2 = Mathf.Lerp(BR2, 0f, t2);
					BR3 = Mathf.Lerp(BR3, 0f, t2);
					BL_Add = Mathf.Lerp(BL_Add, 0f, t2);
					BL1 = Mathf.Lerp(BL1, 0f, t2);
					BL2 = Mathf.Lerp(BL2, 0f, t2);
					BL3 = Mathf.Lerp(BL3, 0f, t2);
				}
				break;
			}
			case IkType.SmBiped:
			{
				float t2 = 0.25f;
				if (!IsConstrained && !IsDead && IsOnGround)
				{
					BR1 = Mathf.Lerp(BR1, Mathf.Clamp(0f - alt1, -60f, 0f), t2);
					BR2 = Mathf.Lerp(BR2, b1, t2);
					BR3 = Mathf.Lerp(BR3, c1, t2);
					BL1 = Mathf.Lerp(BL1, Mathf.Clamp(0f - alt2, -60f, 0f), t2);
					BL2 = Mathf.Lerp(BL2, b2, t2);
					BL3 = Mathf.Lerp(BL3, c2, t2);
				}
				else
				{
					BR_Add = Mathf.Lerp(BR_Add, 0f, t2);
					BR1 = Mathf.Lerp(BR1, 0f, t2);
					BR2 = Mathf.Lerp(BR2, 0f, t2);
					BR3 = Mathf.Lerp(BR3, 0f, t2);
					BL_Add = Mathf.Lerp(BL_Add, 0f, t2);
					BL1 = Mathf.Lerp(BL1, 0f, t2);
					BL2 = Mathf.Lerp(BL2, 0f, t2);
					BL3 = Mathf.Lerp(BL3, 0f, t2);
				}
				break;
			}
			case IkType.LgBiped:
			{
				float t2 = 0.25f;
				if (!IsDead && IsOnGround)
				{
					BR1 = Mathf.Lerp(BR1, Mathf.Clamp(0f - alt1, -55f, 0f), t2);
					BR2 = Mathf.Lerp(BR2, b1, t2);
					BR3 = Mathf.Lerp(BR3, c1, t2);
					BL1 = Mathf.Lerp(BL1, Mathf.Clamp(0f - alt2, -55f, 0f), t2);
					BL2 = Mathf.Lerp(BL2, b2, t2);
					BL3 = Mathf.Lerp(BL3, c2, t2);
				}
				else
				{
					BR_Add = Mathf.Lerp(BR_Add, 0f, t2);
					BR1 = Mathf.Lerp(BR1, 0f, t2);
					BR2 = Mathf.Lerp(BR2, 0f, t2);
					BR3 = Mathf.Lerp(BR3, 0f, t2);
					BL_Add = Mathf.Lerp(BL_Add, 0f, t2);
					BL1 = Mathf.Lerp(BL1, 0f, t2);
					BL2 = Mathf.Lerp(BL2, 0f, t2);
					BL3 = Mathf.Lerp(BL3, 0f, t2);
				}
				break;
			}
			}
		}
		if (lastHit != 0f)
		{
			if (!IsDead && CanWalk)
			{
				crouch = Mathf.Lerp(crouch, Crouch_Max * size / 2f, 1f);
			}
			lastHit -= 1f;
		}
		if (OnReset)
		{
			pitch = Mathf.Lerp(pitch, 0f, t / 10f);
			roll = Mathf.Lerp(roll, 0f, t / 10f);
			headX = Mathf.LerpAngle(headX, 0f, t / 10f);
			headY = Mathf.LerpAngle(headY, 0f, t / 10f);
			crouch = Mathf.Lerp(crouch, 0f, t / 10f);
			spineX = Mathf.LerpAngle(spineX, 0f, t / 10f);
			spineY = Mathf.LerpAngle(spineY, 0f, t / 10f);
			return;
		}
		if (avoidDelta != 0f)
		{
			if (Mathf.Abs(avoidAdd) > 90f)
			{
				avoidDelta = 0f;
			}
			avoidAdd = Mathf.MoveTowardsAngle(avoidAdd, (avoidDelta > 0f) ? 135f : (-135f), t);
		}
		else
		{
			avoidAdd = Mathf.MoveTowardsAngle(avoidAdd, 0f, t);
		}
		if ((bool)objTGT)
		{
			if (behavior.EndsWith("Hunt") | behavior.Equals("Battle") | behavior.EndsWith("Contest"))
			{
				lookTGT = objTGT.transform.position;
			}
			else if (Herbivorous && behavior.Equals("Food"))
			{
				lookTGT = posTGT;
			}
			else if (loop == 0)
			{
				lookTGT = Vector3.zero;
			}
		}
		else if (loop == 0)
		{
			lookTGT = Vector3.zero;
		}
		if (CanMoveHead)
		{
			if (!OnTailAttack && !anm.GetInteger("Move").Equals(0))
			{
				spineX = Mathf.MoveTowardsAngle(spineX, Mathf.DeltaAngle(anm.GetFloat("Turn"), base.transform.eulerAngles.y) / 360f * maxX, t);
				spineY = Mathf.LerpAngle(spineY, 0f, t / 10f);
			}
			else
			{
				spineX = Mathf.MoveTowardsAngle(spineX, 0f, t / 10f);
				spineY = Mathf.LerpAngle(spineY, 0f, t / 10f);
			}
			if ((!CanFly && !CanSwim && anm.GetInteger("Move") != 2) | !IsOnGround)
			{
				roll = Mathf.Lerp(roll, 0f, Ang_T);
			}
			crouch = Mathf.Lerp(crouch, 0f, t / 10f);
			if (OnHeadMove)
			{
				return;
			}
			if (lookTGT != Vector3.zero && (lookTGT - base.transform.position).magnitude > boxscale.z)
			{
				Quaternion quaternion = ((!objTGT || !objTGT.tag.Equals("Creature")) ? Quaternion.LookRotation(lookTGT - HeadPos) : Quaternion.LookRotation(objTGT.GetComponent<Rigidbody>().worldCenterOfMass - HeadPos));
				headX = Mathf.MoveTowardsAngle(headX, Mathf.DeltaAngle(quaternion.eulerAngles.y, base.transform.eulerAngles.y) / (180f - Yaw_Max) * Yaw_Max, t);
				headY = Mathf.MoveTowardsAngle(headY, Mathf.DeltaAngle(quaternion.eulerAngles.x, base.transform.eulerAngles.x) / (90f - Pitch_Max) * Pitch_Max, t);
			}
			else if (Mathf.RoundToInt(anm.GetFloat("Turn")) == Mathf.RoundToInt(base.transform.eulerAngles.y))
			{
				if (loop == 0 && Mathf.RoundToInt(headX * 100f) == Mathf.RoundToInt(rndX * 100) && Mathf.RoundToInt(headY * 100f) == Mathf.RoundToInt(rndY * 100))
				{
					rndX = UnityEngine.Random.Range((int)(0f - Yaw_Max) / 2, (int)Yaw_Max / 2);
					rndY = UnityEngine.Random.Range((int)(0f - Pitch_Max) / 2, (int)Pitch_Max / 2);
				}
				headX = Mathf.LerpAngle(headX, rndX, t / 10f);
				headY = Mathf.LerpAngle(headY, rndY, t / 10f);
			}
			else
			{
				headX = Mathf.LerpAngle(headX, spineX, t / 10f);
				headY = Mathf.LerpAngle(headY, 0f, t / 10f);
			}
			return;
		}
		spineX = Mathf.LerpAngle(spineX, Mathf.DeltaAngle(anm.GetFloat("Turn"), base.transform.eulerAngles.y) / 360f * maxX, Ang_T);
		if (IsOnGround && !IsInWater)
		{
			spineY = Mathf.LerpAngle(spineY, 0f, t / 10f);
			roll = Mathf.LerpAngle(roll, 0f, t / 10f);
			pitch = Mathf.Lerp(pitch, 0f, t / 10f);
		}
		else if (CanFly)
		{
			if (anm.GetInteger("Move") >= 2 && anm.GetInteger("Move") < 3)
			{
				spineY = Mathf.LerpAngle(spineY, Mathf.DeltaAngle(anm.GetFloat("Pitch") * 90f, pitch) / 180f * maxY, Ang_T);
			}
			roll = Mathf.LerpAngle(roll, 0f - spineX, t / 10f);
		}
		else
		{
			spineY = Mathf.LerpAngle(spineY, Mathf.DeltaAngle(anm.GetFloat("Pitch") * 90f, pitch) / 180f * maxY, Ang_T);
			roll = Mathf.LerpAngle(roll, 0f - spineX, t / 10f);
		}
		headX = Mathf.LerpAngle(headX, spineX, t);
		headY = Mathf.LerpAngle(headY, spineY, t);
	}

	private void Quad(Transform RLeg1, Transform RLeg2, Transform RLeg3, Transform LLeg1, Transform LLeg2, Transform LLeg3, Transform RArm1, Transform RArm2, Transform RArm3, Transform LArm1, Transform LArm2, Transform LArm3, float FeetOffset)
	{
		float num = (RArm3.position - RArm3.GetChild(0).GetChild(0).position).magnitude + FeetOffset;
		Vector3 vector = RArm3.position - base.transform.up * num;
		RArm1.rotation *= Quaternion.Euler(0f, 0f - FR1 + (FR1 + FR_Add), 0f);
		a1 = Vector3.Angle(RArm1.position - RArm2.position, RArm1.position - RArm3.position);
		RArm2.rotation *= Quaternion.Euler(0f, FR1 * 2f - FR_Add, 0f);
		b1 = Vector3.Angle(FR_Norm, RArm3.right) - 100f;
		c1 = Vector3.Angle(-FR_Norm, RArm3.up) - 90f;
		RArm3.rotation *= Quaternion.Euler(FR3, FR2, 0f);
		Vector3 vector2 = FR_HIT + (FR_HIT - RArm3.position) + base.transform.up * num;
		Vector3 vector3 = new Vector3(vector.x, vector.y - (vector.y - RArm1.position.y) - (vector.y - FR_HIT.y), vector.z);
		alt1 = ((vector - vector3).magnitude - (vector2 - vector3).magnitude) * (100f / (vector - vector3).magnitude);
		num = (LArm3.position - LArm3.GetChild(0).GetChild(0).position).magnitude + FeetOffset;
		Vector3 vector4 = LArm3.position - base.transform.up * num;
		LArm1.rotation *= Quaternion.Euler(0f - FL1 + (FL1 + FL_Add), 0f, 0f);
		a2 = Vector3.Angle(LArm1.position - LArm2.position, LArm1.position - LArm3.position);
		LArm2.rotation *= Quaternion.Euler(FL1 * 2f - FL_Add, 0f, 0f);
		b2 = Vector3.Angle(FL_Norm, LArm3.right) - 90f;
		c2 = Vector3.Angle(-FL_Norm, LArm3.up) - 100f;
		LArm3.rotation *= Quaternion.Euler(FL3, FL2, 0f);
		Vector3 vector5 = FL_HIT + (FL_HIT - LArm3.position) + base.transform.up * num;
		Vector3 vector6 = new Vector3(vector4.x, vector4.y - (vector4.y - LArm1.position.y) - (vector4.y - FL_HIT.y), vector4.z);
		alt2 = ((vector4 - vector6).magnitude - (vector5 - vector6).magnitude) * (100f / (vector4 - vector6).magnitude);
		num = (RLeg3.position - RLeg3.GetChild(0).GetChild(0).position).magnitude + FeetOffset;
		Vector3 vector7 = RLeg3.position - base.transform.up * num;
		RLeg1.rotation *= Quaternion.Euler(0f, BR1 - (BR1 + BR_Add), 0f);
		a3 = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position);
		RLeg2.rotation *= Quaternion.Euler(0f, (0f - BR1) * 2f + BR_Add, 0f);
		b3 = Vector3.Angle(BR_Norm, RLeg3.right) - 90f;
		c3 = Vector3.Angle(-BR_Norm, RLeg3.up) - 90f;
		RLeg3.rotation *= Quaternion.Euler(BR3, BR2, 0f);
		Vector3 vector8 = BR_HIT + (BR_HIT - RLeg3.position) + base.transform.up * num;
		Vector3 vector9 = new Vector3(vector7.x, vector7.y - (vector7.y - RLeg1.position.y) - (vector7.y - BR_HIT.y), vector7.z);
		alt3 = ((vector7 - vector9).magnitude - (vector8 - vector9).magnitude) * (100f / (vector7 - vector9).magnitude);
		num = (LLeg3.position - LLeg3.GetChild(0).GetChild(0).position).magnitude + FeetOffset;
		Vector3 vector10 = LLeg3.position - base.transform.up * num;
		LLeg1.rotation *= Quaternion.Euler(0f, BL1 - (BL1 + BL_Add), 0f);
		a4 = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position);
		LLeg2.rotation *= Quaternion.Euler(0f, (0f - BL1) * 2f + BL_Add, 0f);
		b4 = Vector3.Angle(BL_Norm, LLeg3.right) - 90f;
		c4 = Vector3.Angle(-BL_Norm, LLeg3.up) - 90f;
		LLeg3.rotation *= Quaternion.Euler(BL3, BL2, 0f);
		Vector3 vector11 = BL_HIT + (BL_HIT - LLeg3.position) + base.transform.up * num;
		Vector3 vector12 = new Vector3(vector10.x, vector10.y - (vector10.y - LLeg1.position.y) - (vector10.y - BL_HIT.y), vector10.z);
		alt4 = ((vector10 - vector12).magnitude - (vector11 - vector12).magnitude) * (100f / (vector10 - vector12).magnitude);
		if (!IsConstrained && !IsDead && IsOnGround)
		{
			FR_Add = Vector3.Angle(RArm1.position - RArm2.position, RArm1.position - RArm3.position) - a1;
			FL_Add = Vector3.Angle(LArm1.position - LArm2.position, LArm1.position - LArm3.position) - a2;
			BR_Add = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position) - a3;
			BL_Add = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position) - a4;
		}
	}

	private void SmBiped(Transform RLeg1, Transform RLeg2, Transform RLeg3, Transform LLeg1, Transform LLeg2, Transform LLeg3)
	{
		Transform child = RLeg3.GetChild(0);
		float magnitude = (child.position - child.GetChild(0).position).magnitude;
		Vector3 vector = child.position - base.transform.up * magnitude;
		float num = Mathf.Clamp(Vector3.Cross(child.position - base.transform.position, RLeg1.position - base.transform.position).y, -1f, 1f);
		RLeg1.rotation *= Quaternion.Euler(0f, BR1 - (BR1 + BR_Add), 0f);
		a1 = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position);
		RLeg2.rotation *= Quaternion.Euler(0f, (0f - BR1) * 2f, 0f);
		RLeg3.rotation *= Quaternion.Euler(0f, BR1 - BR_Add * num, 0f);
		b1 = Vector3.Angle(-BR_Norm, child.GetChild(0).right) - 90f;
		c1 = Vector3.Angle(-BR_Norm, child.up) - 90f;
		child.rotation *= Quaternion.Euler(BR3, 0f, 0f);
		child.GetChild(0).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		Vector3 vector2 = BR_HIT + (BR_HIT - child.GetChild(0).position) + base.transform.up * magnitude;
		Vector3 vector3 = vector + base.transform.up * (vector - RLeg1.position).magnitude;
		alt1 = ((vector - vector3).magnitude - (vector2 - vector3).magnitude) * (100f / (vector - vector3).magnitude);
		Transform child2 = LLeg3.GetChild(0);
		float magnitude2 = (child2.position - child2.GetChild(0).position).magnitude;
		Vector3 vector4 = child2.position - base.transform.up * magnitude2;
		float num2 = Mathf.Clamp(Vector3.Cross(child2.position - base.transform.position, LLeg1.position - base.transform.position).y, -1f, 1f);
		LLeg1.rotation *= Quaternion.Euler(BL1 - (BL1 + BL_Add), 0f, 0f);
		a2 = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position);
		LLeg2.rotation *= Quaternion.Euler((0f - BL1) * 2f, 0f, 0f);
		LLeg3.rotation *= Quaternion.Euler(BL1 + BL_Add * num2, 0f, 0f);
		b2 = Vector3.Angle(-BL_Norm, -child2.GetChild(0).up) - 90f;
		c2 = Vector3.Angle(-BL_Norm, child2.up) - 90f;
		child2.rotation *= Quaternion.Euler(BL3, 0f, 0f);
		child2.GetChild(0).rotation *= Quaternion.Euler(0f, 0f, BL2);
		Vector3 vector5 = BL_HIT + (BL_HIT - child2.GetChild(0).position) + base.transform.up * magnitude2;
		Vector3 vector6 = vector4 + base.transform.up * (vector4 - LLeg1.position).magnitude;
		alt2 = ((vector4 - vector6).magnitude - (vector5 - vector6).magnitude) * (100f / (vector4 - vector6).magnitude);
		if (!IsConstrained && !IsDead && IsOnGround)
		{
			BR_Add = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position) - a1;
			BL_Add = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position) - a2;
		}
	}

	public void LgBiped(Transform RLeg1, Transform RLeg2, Transform RLeg3, Transform LLeg1, Transform LLeg2, Transform LLeg3)
	{
		Transform child = RLeg3.GetChild(0);
		float magnitude = (child.position - child.GetChild(1).position).magnitude;
		Vector3 vector = child.position - base.transform.up * magnitude;
		float num = Mathf.Clamp(Vector3.Cross(child.position - base.transform.position, RLeg1.position - base.transform.position).y, -1f, 1f);
		RLeg1.rotation *= Quaternion.Euler(0f, BR1 - (BR1 + BR_Add), 0f);
		a1 = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position);
		RLeg2.rotation *= Quaternion.Euler(0f, (0f - BR1) * 2f, 0f);
		RLeg3.rotation *= Quaternion.Euler(0f, BR1 - BR_Add * num, 0f);
		b1 = Vector3.Angle(-BR_Norm, child.GetChild(1).right) - 90f;
		c1 = Vector3.Angle(-BR_Norm, child.up) - 90f;
		child.rotation *= Quaternion.Euler(BR3, 0f, 0f);
		child.GetChild(0).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		child.GetChild(1).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		child.GetChild(2).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		Vector3 vector2 = BR_HIT + (BR_HIT - child.position) + base.transform.up * magnitude;
		Vector3 vector3 = vector + base.transform.up * (vector - RLeg1.position).magnitude;
		alt1 = ((vector - vector3).magnitude - (vector2 - vector3).magnitude) * (100f / (vector - vector3).magnitude);
		Transform child2 = LLeg3.GetChild(0);
		float magnitude2 = (child2.position - child2.GetChild(1).position).magnitude;
		Vector3 vector4 = child2.position - base.transform.up * magnitude2;
		float num2 = Mathf.Clamp(Vector3.Cross(child2.position - base.transform.position, LLeg1.position - base.transform.position).y, -1f, 1f);
		LLeg1.rotation *= Quaternion.Euler(0f, BL1 - (BL1 + BL_Add), 0f);
		a2 = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position);
		LLeg2.rotation *= Quaternion.Euler(0f, (0f - BL1) * 2f, 0f);
		LLeg3.rotation *= Quaternion.Euler(0f, BL1 + BL_Add * num2, 0f);
		b2 = Vector3.Angle(-BL_Norm, child2.GetChild(1).up) - 90f;
		c2 = Vector3.Angle(-BL_Norm, child2.up) - 90f;
		child2.rotation *= Quaternion.Euler(BL3, 0f, 0f);
		child2.GetChild(0).rotation *= Quaternion.Euler(0f, BL2, 0f);
		child2.GetChild(1).rotation *= Quaternion.Euler(BL2, 0f, 0f);
		child2.GetChild(2).rotation *= Quaternion.Euler(0f, BL2, 0f);
		Vector3 vector5 = BL_HIT + (BL_HIT - child2.position) + base.transform.up * magnitude2;
		Vector3 vector6 = vector4 + base.transform.up * (vector4 - LLeg1.position).magnitude;
		alt2 = ((vector4 - vector6).magnitude - (vector5 - vector6).magnitude) * (100f / (vector4 - vector6).magnitude);
		if (!IsDead && IsOnGround)
		{
			BR_Add = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position) - a1;
			BL_Add = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position) - a2;
		}
	}

	private void Convex(Transform RLeg1, Transform RLeg2, Transform RLeg3, Transform LLeg1, Transform LLeg2, Transform LLeg3, Transform RArm1, Transform RArm2, Transform RArm3, Transform LArm1, Transform LArm2, Transform LArm3)
	{
		float magnitude = (RArm3.position - RArm3.GetChild(0).position).magnitude;
		Vector3 vector = RArm3.position - base.transform.up * magnitude;
		RArm1.rotation *= Quaternion.Euler(FR1 - (FR1 + FR_Add), 0f, 0f);
		a1 = Vector3.Angle(RArm1.position - RArm2.position, RArm1.position - RArm3.GetChild(0).GetChild(0).position);
		RArm2.rotation *= Quaternion.Euler(0f, FR1 - FR_Add, 0f);
		b1 = Vector3.Angle(FR_Norm, RArm3.GetChild(0).right) - 90f;
		c1 = Vector3.Angle(FR_Norm, -RArm3.GetChild(0).up) - 90f;
		RArm3.rotation *= Quaternion.Euler((0f - FR3) / 2f, (0f - FR2) / 2f, 0f);
		RArm3.GetChild(0).rotation *= Quaternion.Euler((0f - FR3) / 2f, (0f - FR2) / 2f, 0f);
		Vector3 vector2 = FR_HIT + (FR_HIT - RArm3.GetChild(0).GetChild(0).position) + base.transform.up * magnitude;
		Vector3 vector3 = new Vector3(vector.x, vector.y - (vector.y - RArm1.position.y) - (vector.y - FR_HIT.y), vector.z);
		alt1 = ((vector - vector3).magnitude - (vector2 - vector3).magnitude) * (100f / (vector - vector3).magnitude);
		float magnitude2 = (LArm3.position - LArm3.GetChild(0).position).magnitude;
		Vector3 vector4 = LArm3.position - base.transform.up * magnitude2;
		LArm1.rotation *= Quaternion.Euler(FL1 - (FL1 + FL_Add), 0f, 0f);
		a2 = Vector3.Angle(LArm1.position - LArm2.position, LArm1.position - LArm3.GetChild(0).GetChild(0).position);
		LArm2.rotation *= Quaternion.Euler(0f - FL1 + FL_Add, 0f, 0f);
		b2 = Vector3.Angle(FL_Norm, -LArm3.GetChild(0).up) - 90f;
		c2 = Vector3.Angle(FL_Norm, LArm3.GetChild(0).right) - 90f;
		LArm3.rotation *= Quaternion.Euler((0f - FL2) / 2f, (0f - FL3) / 2f, 0f);
		LArm3.GetChild(0).rotation *= Quaternion.Euler((0f - FL2) / 2f, (0f - FL3) / 2f, 0f);
		Vector3 vector5 = FL_HIT + (FL_HIT - LArm3.GetChild(0).GetChild(0).position) + base.transform.up * magnitude2;
		Vector3 vector6 = new Vector3(vector4.x, vector4.y - (vector4.y - LArm1.position.y) - (vector4.y - FL_HIT.y), vector4.z);
		alt2 = ((vector4 - vector6).magnitude - (vector5 - vector6).magnitude) * (100f / (vector4 - vector6).magnitude);
		float magnitude3 = (RLeg3.position - RLeg3.GetChild(0).GetChild(0).position).magnitude;
		Vector3 vector7 = RLeg3.position - base.transform.up * magnitude3;
		RLeg1.rotation *= Quaternion.Euler(0f, 0f - (BR1 + (BR1 + BR_Add)), 0f);
		a3 = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position);
		RLeg2.rotation *= Quaternion.Euler(0f, BR1 * 2f - BR_Add, 0f);
		b3 = Vector3.Angle(BR_Norm, RLeg3.GetChild(0).right) - 90f;
		c3 = Vector3.Angle(-BR_Norm, RLeg3.GetChild(0).up) - 90f;
		RLeg3.rotation *= Quaternion.Euler((0f - BR3) / 2f, (0f - BR2) / 2f, 0f);
		RLeg3.GetChild(0).rotation *= Quaternion.Euler((0f - BR3) / 2f, (0f - BR2) / 2f, 0f);
		Vector3 vector8 = BR_HIT + (BR_HIT - RLeg3.position) + base.transform.up * magnitude3;
		Vector3 vector9 = new Vector3(vector7.x, vector7.y - (vector7.y - RLeg1.position.y) - (vector7.y - BR_HIT.y), vector7.z);
		alt3 = ((vector7 - vector9).magnitude - (vector8 - vector9).magnitude) * (100f / (vector7 - vector9).magnitude);
		float magnitude4 = (LLeg3.position - LLeg3.GetChild(0).GetChild(0).position).magnitude;
		Vector3 vector10 = LLeg3.position - base.transform.up * magnitude4;
		LLeg1.rotation *= Quaternion.Euler(BL1 + (BL1 + BL_Add), 0f, 0f);
		a4 = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position);
		LLeg2.rotation *= Quaternion.Euler(0f - BL1 * 2f + BL_Add, 0f, 0f);
		b4 = Vector3.Angle(BL_Norm, LLeg3.GetChild(0).right) - 90f;
		c4 = Vector3.Angle(-BL_Norm, LLeg3.GetChild(0).up) - 90f;
		LLeg3.rotation *= Quaternion.Euler((0f - BL3) / 2f, (0f - BL2) / 2f, 0f);
		LLeg3.GetChild(0).rotation *= Quaternion.Euler((0f - BL3) / 2f, (0f - BL2) / 2f, 0f);
		Vector3 vector11 = BL_HIT + (BL_HIT - LLeg3.position) + base.transform.up * magnitude4;
		Vector3 vector12 = new Vector3(vector10.x, vector10.y - (vector10.y - LLeg1.position.y) - (vector10.y - BL_HIT.y), vector10.z);
		alt4 = ((vector10 - vector12).magnitude - (vector11 - vector12).magnitude) * (100f / (vector10 - vector12).magnitude);
		if (!IsConstrained && !IsDead && IsOnGround && !IsInWater)
		{
			FR_Add = Vector3.Angle(RArm1.position - RArm2.position, RArm1.position - RArm3.GetChild(0).GetChild(0).position) - a1;
			FL_Add = Vector3.Angle(LArm1.position - LArm2.position, LArm1.position - LArm3.GetChild(0).GetChild(0).position) - a2;
			BR_Add = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.position) - a3;
			BL_Add = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.position) - a4;
		}
	}

	private void Flying(Transform RLeg1, Transform RLeg2, Transform RLeg3, Transform LLeg1, Transform LLeg2, Transform LLeg3, Transform RArm1, Transform RArm2, Transform RArm3, Transform LArm1, Transform LArm2, Transform LArm3)
	{
		Vector3 position = RArm3.GetChild(1).position;
		RArm1.rotation *= Quaternion.Euler(FR1, FR1 - (FR1 - FR_Add), FR1);
		a1 = Vector3.Angle(RArm1.position - RArm2.position, RArm1.position - RArm3.GetChild(1).position);
		RArm2.rotation *= Quaternion.Euler(0f, 0f, (0f - FR1) * 2.4f - FR_Add);
		b1 = Vector3.Angle(FR_Norm, RArm3.right) - 90f;
		c1 = Vector3.Angle(-FR_Norm, RArm3.up) - 90f;
		RArm3.rotation *= Quaternion.Euler(FR3, FR2, 0f);
		Vector3 vector = FR_HIT + (FR_HIT - RArm3.GetChild(1).position);
		Vector3 vector2 = new Vector3(position.x, position.y - (position.y - RArm1.position.y) - (position.y - FR_HIT.y), position.z);
		alt1 = ((position - vector2).magnitude - (vector - vector2).magnitude) * (100f / (position - vector2).magnitude);
		Vector3 position2 = LArm3.GetChild(1).position;
		LArm1.rotation *= Quaternion.Euler(0f - FL1, FL1 - (FL1 - FL_Add), 0f - FL1);
		a2 = Vector3.Angle(LArm1.position - LArm2.position, LArm1.position - LArm3.GetChild(1).position);
		LArm2.rotation *= Quaternion.Euler(0f, 0f, FL1 * 2.4f + FL_Add);
		b2 = Vector3.Angle(FL_Norm, LArm3.right) - 90f;
		c2 = Vector3.Angle(-FL_Norm, LArm3.up) - 90f;
		LArm3.rotation *= Quaternion.Euler(FL3, FL2, 0f);
		Vector3 vector3 = FL_HIT + (FL_HIT - LArm3.GetChild(1).position);
		Vector3 vector4 = new Vector3(position2.x, position2.y - (position2.y - LArm1.position.y) - (position2.y - FL_HIT.y), position2.z);
		alt2 = ((position2 - vector4).magnitude - (vector3 - vector4).magnitude) * (100f / (position2 - vector4).magnitude);
		float num = (RLeg3.position - RLeg3.GetChild(2).position).magnitude / 1.5f;
		Vector3 vector5 = RLeg3.position - base.transform.up * num;
		float num2 = Mathf.Clamp(Vector3.Cross(RLeg3.GetChild(2).position - base.transform.position, RLeg1.position - base.transform.position).y, -1f, 1f);
		RLeg1.rotation *= Quaternion.Euler(0f, 0f - BR1 + (BR1 - BR_Add), 0f);
		a3 = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.GetChild(2).position);
		RLeg2.rotation *= Quaternion.Euler(0f, (0f - BR1) * 2f, 0f);
		c3 = Vector3.Angle(BR_Norm, RLeg3.GetChild(2).up) - 90f;
		RLeg3.rotation *= Quaternion.Euler(0f, BR1 - BR_Add * num2, BR3);
		b3 = Vector3.Angle(BR_Norm, RLeg3.GetChild(2).right) - 90f;
		RLeg3.GetChild(0).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		RLeg3.GetChild(1).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		RLeg3.GetChild(2).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		RLeg3.GetChild(3).rotation *= Quaternion.Euler(0f, 0f - BR2, 0f);
		Vector3 vector6 = BR_HIT + (BR_HIT - RLeg3.GetChild(2).position) + base.transform.up * num;
		Vector3 vector7 = vector5 + base.transform.up * (vector5 - RLeg1.position).magnitude;
		alt3 = ((vector5 - vector7).magnitude - (vector6 - vector7).magnitude) * (100f / (vector5 - vector7).magnitude);
		float num3 = (LLeg3.position - LLeg3.GetChild(2).position).magnitude / 1.5f;
		Vector3 vector8 = LLeg3.position - base.transform.up * num3;
		float num4 = Mathf.Clamp(Vector3.Cross(LLeg3.GetChild(2).position - base.transform.position, LLeg1.position - base.transform.position).y, -1f, 1f);
		LLeg1.rotation *= Quaternion.Euler(0f, 0f - BL1 + (BL1 - BL_Add), 0f);
		a4 = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.GetChild(2).position);
		LLeg2.rotation *= Quaternion.Euler(0f, (0f - BL1) * 2f, 0f);
		c4 = Vector3.Angle(BL_Norm, LLeg3.GetChild(2).up) - 90f;
		LLeg3.rotation *= Quaternion.Euler(0f, BL1 - BL_Add * num4, BL3);
		b4 = Vector3.Angle(BL_Norm, LLeg3.GetChild(2).right) - 90f;
		LLeg3.GetChild(0).rotation *= Quaternion.Euler(0f, 0f - BL2, 0f);
		LLeg3.GetChild(1).rotation *= Quaternion.Euler(0f, 0f - BL2, 0f);
		LLeg3.GetChild(2).rotation *= Quaternion.Euler(0f, 0f - BL2, 0f);
		LLeg3.GetChild(3).rotation *= Quaternion.Euler(0f, 0f - BL2, 0f);
		Vector3 vector9 = BL_HIT + (BL_HIT - LLeg3.GetChild(2).position) + base.transform.up * num3;
		Vector3 vector10 = vector8 + base.transform.up * (vector8 - LLeg1.position).magnitude;
		alt4 = ((vector8 - vector10).magnitude - (vector9 - vector10).magnitude) * (100f / (vector8 - vector10).magnitude);
		if (!IsConstrained && !IsDead && IsOnGround && !IsOnLevitation)
		{
			FR_Add = Vector3.Angle(RArm1.position - RArm2.position, LArm1.position - RArm3.GetChild(1).position) - a1;
			FL_Add = Vector3.Angle(LArm1.position - LArm2.position, LArm1.position - LArm3.GetChild(1).position) - a2;
			BR_Add = Vector3.Angle(RLeg1.position - RLeg2.position, RLeg1.position - RLeg3.GetChild(2).position) - a3;
			BL_Add = Vector3.Angle(LLeg1.position - LLeg2.position, LLeg1.position - LLeg3.GetChild(2).position) - a4;
		}
	}

	public void GetUserInputs(int idle1 = 0, int idle2 = 0, int idle3 = 0, int idle4 = 0, int eat = 0, int drink = 0, int sleep = 0, int rise = 0)
	{
		if (behavior == "Repose" && anm.GetInteger("Move") != 0)
		{
			behavior = "Player";
		}
		else if (behaviorCount <= 0f)
		{
			objTGT = null;
			behavior = "Player";
			behaviorCount = 0f;
		}
		else
		{
			behaviorCount -= 1f;
		}
		if (base.transform.gameObject == main.creaturesList[main.selected].gameObject && main.CameraMode != 0)
		{
			bool flag = (Input.GetKey(KeyCode.LeftShift) ? true : false);
			if (CanAttack)
			{
				if (Input.GetKey(KeyCode.Mouse0))
				{
					behaviorCount = 500f;
					behavior = "Hunt";
					anm.SetBool("Attack", value: true);
				}
				else
				{
					anm.SetBool("Attack", value: false);
				}
			}
			if (main.UseIK && Input.GetKey(KeyCode.LeftControl))
			{
				crouch = Crouch_Max * size;
				OnCrouch = true;
			}
			else
			{
				OnCrouch = false;
			}
			if (CanFly | CanSwim)
			{
				if (Input.GetKey(KeyCode.Mouse1))
				{
					anm.SetFloat("Turn", base.transform.eulerAngles.y + Input.GetAxis("Mouse X") * 22.5f);
					if (Input.GetAxis("Mouse Y") != 0f && anm.GetInteger("Move") == 3)
					{
						anm.SetFloat("Pitch", Input.GetAxis("Mouse Y"));
					}
					else if (Input.GetKey(KeyCode.LeftControl))
					{
						anm.SetFloat("Pitch", 1f);
					}
					else if (Input.GetKey(KeyCode.Space))
					{
						anm.SetFloat("Pitch", -1f);
					}
				}
				else if (Input.GetKey(KeyCode.LeftControl))
				{
					anm.SetFloat("Pitch", 1f);
				}
				else if (Input.GetKey(KeyCode.Space))
				{
					anm.SetFloat("Pitch", -1f);
				}
				else
				{
					anm.SetFloat("Pitch", 0f);
				}
			}
			if (CanJump && Input.GetKey(KeyCode.Space) && !OnJump)
			{
				anm.SetInteger("Move", 3);
			}
			else if ((Input.GetAxis("Horizontal") != 0f) | (Input.GetAxis("Vertical") != 0f))
			{
				if (CanSwim | (CanFly && !IsOnGround))
				{
					if (Input.GetKey(KeyCode.Mouse1))
					{
						if (Input.GetAxis("Vertical") < 0f)
						{
							anm.SetInteger("Move", -1);
						}
						else if (Input.GetAxis("Vertical") > 0f)
						{
							anm.SetInteger("Move", 3);
						}
						else if (Input.GetAxis("Horizontal") > 0f)
						{
							anm.SetInteger("Move", -10);
						}
						else if (Input.GetAxis("Horizontal") < 0f)
						{
							anm.SetInteger("Move", 10);
						}
						else
						{
							anm.SetInteger("Move", 0);
						}
					}
					else
					{
						if (flag)
						{
							anm.SetInteger("Move", (!CanSwim) ? 1 : 2);
						}
						else
						{
							anm.SetInteger("Move", CanSwim ? 1 : 2);
						}
						float value = main.transform.eulerAngles.y + Mathf.Atan2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical")) * 57.29578f;
						anm.SetFloat("Turn", value);
					}
				}
				else if (Input.GetKey(KeyCode.Mouse1))
				{
					if (Input.GetAxis("Vertical") > 0f && !flag)
					{
						anm.SetInteger("Move", 1);
					}
					else if (Input.GetAxis("Vertical") > 0f)
					{
						anm.SetInteger("Move", 2);
					}
					else if (Input.GetAxis("Vertical") < 0f)
					{
						anm.SetInteger("Move", -1);
					}
					else if (Input.GetAxis("Horizontal") > 0f)
					{
						anm.SetInteger("Move", -10);
					}
					else if (Input.GetAxis("Horizontal") < 0f)
					{
						anm.SetInteger("Move", 10);
					}
					anm.SetFloat("Turn", base.transform.eulerAngles.y + Input.GetAxis("Mouse X") * 22.5f);
				}
				else
				{
					float value2 = main.transform.eulerAngles.y + Mathf.Atan2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical")) * 57.29578f;
					anm.SetInteger("Move", (!flag) ? 1 : 2);
					anm.SetFloat("Turn", value2);
				}
			}
			else if ((CanSwim | CanFly) && !IsOnGround)
			{
				if (CanSwim && anm.GetFloat("Pitch") != 0f && !Input.GetKey(KeyCode.Mouse1))
				{
					anm.SetInteger("Move", (!flag) ? 1 : 2);
				}
				else
				{
					anm.SetInteger("Move", 0);
				}
			}
			else if (Input.GetKey(KeyCode.Mouse1))
			{
				if (Input.GetAxis("Mouse X") > 0f)
				{
					anm.SetInteger("Move", 10);
				}
				else if (Input.GetAxis("Mouse X") < 0f)
				{
					anm.SetInteger("Move", -10);
				}
				else
				{
					anm.SetInteger("Move", 0);
				}
				anm.SetFloat("Turn", base.transform.eulerAngles.y + Input.GetAxis("Mouse X") * 22.5f);
			}
			else
			{
				anm.SetInteger("Move", 0);
			}
			if (CanInvertBody && Input.GetKeyDown(KeyCode.R))
			{
				if (OnInvert)
				{
					OnInvert = false;
				}
				else
				{
					OnInvert = true;
				}
			}
			if (Input.GetKey(KeyCode.E))
			{
				int num = 0;
				if (idle1 > 0)
				{
					num++;
				}
				if (idle2 > 0)
				{
					num++;
				}
				if (idle3 > 0)
				{
					num++;
				}
				if (idle4 > 0)
				{
					num++;
				}
				rndIdle = UnityEngine.Random.Range(1, num + 1);
				switch (rndIdle)
				{
				case 1:
					anm.SetInteger("Idle", idle1);
					break;
				case 2:
					anm.SetInteger("Idle", idle2);
					break;
				case 3:
					anm.SetInteger("Idle", idle3);
					break;
				case 4:
					anm.SetInteger("Idle", idle4);
					break;
				}
			}
			else if (Input.GetKey(KeyCode.F))
			{
				if (posTGT == Vector3.zero)
				{
					FindPlayerFood();
				}
				if (IsOnWater)
				{
					anm.SetInteger("Idle", drink);
					if (Water < 100f)
					{
						behavior = "Water";
						Water = Mathf.Clamp(Water + 0.05f, 0f, 100f);
					}
					if (Input.GetKeyUp(KeyCode.F))
					{
						posTGT = Vector3.zero;
					}
					else
					{
						posTGT = base.transform.position;
					}
				}
				else if (posTGT != Vector3.zero)
				{
					anm.SetInteger("Idle", eat);
					behavior = "Food";
					if (Food < 100f)
					{
						Food = Mathf.Clamp(Food + 0.05f, 0f, 100f);
					}
					if (Water < 25f)
					{
						Water += 0.05f;
					}
					if (Input.GetKeyUp(KeyCode.F))
					{
						posTGT = Vector3.zero;
					}
				}
				else
				{
					main.message = 1;
				}
			}
			else if (Input.GetKey(KeyCode.Q))
			{
				anm.SetInteger("Idle", sleep);
				if (anm.GetInteger("Move") != 0)
				{
					anm.SetInteger("Idle", 0);
				}
			}
			else if (rise != 0 && Input.GetKey(KeyCode.Space))
			{
				anm.SetInteger("Idle", rise);
			}
			else
			{
				anm.SetInteger("Idle", 0);
				posTGT = Vector3.zero;
			}
			if (Input.GetKey(KeyCode.Mouse2))
			{
				OnHeadMove = true;
				headX = Mathf.Lerp(headX, Mathf.Clamp(headX - Input.GetAxis("Mouse X"), 0f - Yaw_Max, Yaw_Max), 0.5f);
				headY = Mathf.Lerp(headY, Mathf.Clamp(headY + Input.GetAxis("Mouse Y"), 0f - Pitch_Max, Pitch_Max), 0.5f);
			}
			else
			{
				OnHeadMove = false;
			}
			delta = Mathf.DeltaAngle(main.transform.eulerAngles.y, anm.GetFloat("Turn"));
			if (OnAnm.IsName(specie + "|Sleep"))
			{
				behavior = "Repose";
				Stamina = Mathf.Clamp(Stamina + 0.05f, 0f, 100f);
			}
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", 0);
			if (CanAttack)
			{
				anm.SetBool("Attack", value: false);
			}
			if (CanFly | CanSwim)
			{
				anm.SetFloat("Pitch", 0f);
			}
		}
	}

	private bool FindPlayerFood()
	{
		if (!Herbivorous)
		{
			GameObject[] array = main.creaturesList.ToArray();
			foreach (GameObject gameObject in array)
			{
				if (!((gameObject.transform.position - Head.position).magnitude > boxscale.z))
				{
					Creature component = gameObject.GetComponent<Creature>();
					if (component.IsDead)
					{
						objTGT = component.gameObject;
						posTGT = component.body.worldCenterOfMass;
						return true;
					}
				}
			}
		}
		else if ((bool)main.T)
		{
			if (withersSize > 8f)
			{
				if (Physics.CheckSphere(Head.position, withersSize, main.treeLayer))
				{
					posTGT = Head.position;
					return true;
				}
				return false;
			}
			int num = 0;
			float num2 = (base.transform.position.x - main.T.transform.position.x) / main.tdata.size.z * main.tres;
			float num3 = (base.transform.position.z - main.T.transform.position.z) / main.tdata.size.x * main.tres;
			for (num = 0; num < main.tdata.detailPrototypes.Length; num++)
			{
				if (main.tdata.GetDetailLayer((int)num2, (int)num3, 1, 1, num)[0, 0] > 0)
				{
					posTGT.x = main.tdata.size.x / main.tres * num2 + main.T.transform.position.x;
					posTGT.z = main.tdata.size.z / main.tres * num3 + main.T.transform.position.z;
					posTGT.y = main.T.SampleHeight(new Vector3(posTGT.x, 0f, posTGT.z));
					objTGT = null;
					return true;
				}
			}
		}
		objTGT = null;
		posTGT = Vector3.zero;
		return false;
	}

	public void AICore(int idle1 = 0, int idle2 = 0, int idle3 = 0, int idle4 = 0, int eat = 0, int drink = 0, int sleep = 0)
	{
		if (posTGT == Vector3.zero)
		{
			if (nextPath >= PathEditor.Count)
			{
				nextPath = 0;
			}
			if (PathEditor.Count > 0 && UnityEngine.Random.Range(0, 100) < PathEditor[nextPath]._Priority)
			{
				objTGT = PathEditor[nextPath]._Waypoint;
				posTGT = PathEditor[nextPath]._Waypoint.transform.position;
				behavior = "ToWaypoint";
				behaviorCount = 4000f;
			}
			else if (CanWalk && (float)UnityEngine.Random.Range(0, 75) > Water)
			{
				FindWater();
				behaviorCount = 4000f;
			}
			else if ((float)UnityEngine.Random.Range(0, 75) > Food)
			{
				if (!Herbivorous)
				{
					if (!FindFood())
					{
						FindPrey();
					}
				}
				else
				{
					FindFood();
				}
				behaviorCount = 4000f;
			}
			else if (!CanSwim && (float)UnityEngine.Random.Range(0, 50) > Stamina)
			{
				behavior = "ToRepose";
				FindPath();
				behaviorCount = 4000f;
			}
			else if (UnityEngine.Random.Range(0, 5) == 0)
			{
				FindFriend();
				behaviorCount = 4000f;
			}
			if (posTGT == Vector3.zero)
			{
				behavior = "ToPath";
				FindPath();
				behaviorCount = 4000f;
			}
			return;
		}
		if (TargetEditor.Count > 0)
		{
			if (!FindCustomTarget())
			{
				FindEnemy();
			}
		}
		else
		{
			FindEnemy();
		}
		ExecuteBehavior(idle1, idle2, idle3, idle4, eat, drink, sleep);
	}

	private bool FindWater()
	{
		objTGT = null;
		Vector3 zero = Vector3.zero;
		float num = 0f;
		float num2 = withersSize;
		while (num2 < 200f)
		{
			while (num < 360f)
			{
				zero = base.transform.position + Quaternion.Euler(0f, num, 0f) * Vector3.forward * num2;
				if (Physics.Raycast(zero + Vector3.up * withersSize, -Vector3.up * 200f, out var hitInfo) && !Physics.Linecast(base.transform.position + Vector3.up * withersSize, zero + Vector3.up * withersSize))
				{
					if (hitInfo.transform.gameObject.layer.Equals(main.waterLayer) && Physics.Linecast(hitInfo.point, hitInfo.point - Vector3.up, -1, QueryTriggerInteraction.Ignore))
					{
						behavior = "ToWater";
						posTGT = hitInfo.point;
						return true;
					}
					num += 15f;
					zero = Vector3.zero;
				}
				else
				{
					num += 15f;
					zero = Vector3.zero;
				}
			}
			num2 += withersSize;
			num = 0f;
		}
		posTGT = Vector3.zero;
		return false;
	}

	private bool FindFood()
	{
		if (!Herbivorous)
		{
			GameObject[] array = main.creaturesList.ToArray();
			foreach (GameObject gameObject in array)
			{
				if (!((gameObject.transform.position - base.transform.position).magnitude > 200f) && !(gameObject.gameObject == base.transform.gameObject))
				{
					Creature component = gameObject.GetComponent<Creature>();
					if ((CanSwim || !component.IsInWater) && (!CanSwim || CanWalk || component.IsInWater) && component.IsDead)
					{
						behavior = "ToFood";
						objTGT = component.gameObject;
						posTGT = component.body.worldCenterOfMass;
						return true;
					}
				}
			}
		}
		else if ((bool)main.T)
		{
			if (withersSize > 8f)
			{
				_ = Vector3.zero;
				float num = 0f;
				while (num < 360f)
				{
					if (Physics.Linecast(base.transform.position + Quaternion.Euler(0f, num, 0f) * Vector3.forward * 50f + Vector3.up * withersSize, base.transform.position + Vector3.up * withersSize, out var hitInfo, main.treeLayer))
					{
						behavior = "ToFood";
						posTGT = hitInfo.point;
						return true;
					}
					num += 1f;
					_ = Vector3.zero;
				}
				objTGT = null;
				posTGT = Vector3.zero;
				return false;
			}
			int num2 = 0;
			float num3 = (base.transform.position.x - main.T.transform.position.x) / main.tdata.size.x * main.tres - 2f;
			float num4 = num3;
			float num5 = (base.transform.position.z - main.T.transform.position.z) / main.tdata.size.z * main.tres - 2f;
			float num6 = num5;
			for (num6 = num5; num6 < num5 + 2f; num6 += 1f)
			{
				for (num4 = num3; num4 < num3 + 2f; num4 += 1f)
				{
					for (num2 = 0; num2 < main.tdata.detailPrototypes.Length; num2++)
					{
						if (main.tdata.GetDetailLayer((int)num4, (int)num6, 1, 1, num2)[0, 0] > 0)
						{
							posTGT.x = main.tdata.size.x / main.tres * num4 + main.T.transform.position.x;
							posTGT.z = main.tdata.size.z / main.tres * num6 + main.T.transform.position.z;
							posTGT.y = main.T.SampleHeight(new Vector3(posTGT.x, 0f, posTGT.z)) + main.T.GetPosition().y;
							if (!Physics.Linecast(base.transform.position + Vector3.up * withersSize, posTGT + Vector3.up * withersSize))
							{
								objTGT = null;
								behavior = "ToFood";
								return true;
							}
						}
					}
				}
			}
		}
		objTGT = null;
		posTGT = Vector3.zero;
		return false;
	}

	private bool FindPrey()
	{
		Vector3 vector = Vector3.zero;
		GameObject[] array = main.creaturesList.ToArray();
		foreach (GameObject gameObject in array)
		{
			if ((gameObject.transform.position - base.transform.position).magnitude > 200f || gameObject.gameObject == base.transform.gameObject)
			{
				continue;
			}
			Creature component = gameObject.GetComponent<Creature>();
			if ((CanSwim || !component.IsInWater) && (!CanSwim || CanWalk || component.IsInWater))
			{
				if (component.Herbivorous && component.withersSize < withersSize * 3f)
				{
					behavior = "ToHunt";
					objTGT = component.gameObject;
					posTGT = component.body.worldCenterOfMass;
					return true;
				}
				if (!component.Herbivorous && component.withersSize < withersSize * 1.5f && !component.specie.Equals(specie))
				{
					behavior = "ToHunt";
					objTGT = component.gameObject;
					posTGT = component.body.worldCenterOfMass;
				}
				else if (Food == 0f && component.withersSize < withersSize * 3f)
				{
					objTGT = component.gameObject;
					vector = component.body.worldCenterOfMass;
				}
			}
		}
		if (vector == Vector3.zero)
		{
			return false;
		}
		behavior = "ToHunt";
		posTGT = vector;
		return true;
	}

	private bool FindFriend()
	{
		GameObject[] array = main.creaturesList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			Creature component = array[i].GetComponent<Creature>();
			float magnitude = (component.transform.position - base.transform.position).magnitude;
			if (!((magnitude > 200f) | (magnitude < boxscale.x * 25f)) && !(!component.specie.Equals(specie) | component.IsDead) && !(component.gameObject == base.transform.gameObject) && (!component.IsInWater || CanSwim) && (component.IsInWater || !CanSwim))
			{
				if (component.behavior.EndsWith("Hunt") && component.objTGT != base.transform.gameObject)
				{
					behavior = "ToHunt";
					objTGT = component.objTGT;
					posTGT = component.posTGT;
					return true;
				}
				if (component.behavior.Equals("Battle") && component.objTGT != base.transform.gameObject)
				{
					behavior = "Battle";
					objTGT = component.objTGT;
					posTGT = component.posTGT;
					return true;
				}
				if (component.behavior.EndsWith("Food") && Food < 75f)
				{
					behavior = "ToFood";
					objTGT = component.objTGT;
					posTGT = component.posTGT;
					return true;
				}
				if (component.behavior.EndsWith("Water") && Water < 75f)
				{
					behavior = "ToWater";
					posTGT = component.posTGT;
					return true;
				}
				lookTGT = component.transform.position;
				behavior = "ToHerd";
				objTGT = component.gameObject;
				posTGT = component.body.worldCenterOfMass;
				return true;
			}
		}
		objTGT = null;
		posTGT = Vector3.zero;
		return false;
	}

	private bool FindEnemy()
	{
		if (loop == 0 && !behavior.Equals("ToFlee") && !behavior.Equals("Battle") && !behavior.EndsWith("Hunt") && !behavior.Equals("ToTarget"))
		{
			GameObject[] array = main.creaturesList.ToArray();
			foreach (GameObject gameObject in array)
			{
				if (gameObject.gameObject == base.transform.gameObject || (gameObject.transform.position - base.transform.position).magnitude > 50f)
				{
					continue;
				}
				Creature component = gameObject.GetComponent<Creature>();
				if (component.IsDead)
				{
					continue;
				}
				if (!Herbivorous)
				{
					if (!component.Herbivorous && (component.behavior.EndsWith("Hunt") | component.behavior.Equals("Battle")))
					{
						if (!(component.specie == specie) || !(component.objTGT != base.transform.gameObject))
						{
							if (boxscale.z > component.boxscale.z / 1.5f)
							{
								behavior = "Battle";
								objTGT = component.gameObject;
								posTGT = component.transform.position;
								return true;
							}
							behavior = "ToFlee";
							objTGT = component.gameObject;
							FindPath(invert: true);
							return true;
						}
					}
					else if (component.Herbivorous && component.behavior.Equals("Battle") && boxscale.z > component.boxscale.z / 3f && component.objTGT == base.transform.gameObject)
					{
						behavior = "ToFlee";
						behaviorCount = 1000f;
						objTGT = component.gameObject;
						FindPath(invert: true);
						return true;
					}
				}
				else if (!component.Herbivorous && (component.behavior.EndsWith("Hunt") | (component.objTGT == base.transform.gameObject && component.behavior.Equals("Battle"))))
				{
					if (CanAttack && boxscale.z > component.boxscale.z / 3f && Health > 25f && component.objTGT == base.transform.gameObject)
					{
						behavior = "Battle";
						behaviorCount = 1000f;
						objTGT = component.gameObject;
						posTGT = component.body.worldCenterOfMass;
						return true;
					}
					if (!component.behavior.Equals("ToFlee"))
					{
						behavior = "ToFlee";
						behaviorCount = 1000f;
						objTGT = component.gameObject;
						FindPath(invert: true);
						return true;
					}
				}
			}
		}
		return false;
	}

	private bool FindCustomTarget()
	{
		if (loop == 0)
		{
			foreach (_TargetEditor item in TargetEditor)
			{
				if (!item._GameObject)
				{
					TargetEditor.Remove(item);
				}
				else
				{
					if (item.MaxRange != 0 && (item._GameObject.transform.position - base.transform.position).magnitude > (float)item.MaxRange)
					{
						continue;
					}
					if (item._TargetType == TargetType.Enemy)
					{
						if (CanAttack)
						{
							if ((item._GameObject.transform.position - base.transform.position).magnitude > 50f)
							{
								objTGT = item._GameObject;
								posTGT = item._GameObject.transform.position;
								behavior = "ToTarget";
								return true;
							}
							objTGT = item._GameObject;
							posTGT = item._GameObject.transform.position;
							behavior = "Battle";
							return true;
						}
						if ((item._GameObject.transform.position - base.transform.position).magnitude < 50f)
						{
							objTGT = item._GameObject;
							behavior = "ToFlee";
							FindPath(invert: true);
							return true;
						}
					}
					else
					{
						if ((item._GameObject.transform.position - base.transform.position).magnitude < boxscale.z * 10f)
						{
							continue;
						}
						Creature component = item._GameObject.GetComponent<Creature>();
						if ((bool)component)
						{
							if (component.behavior.EndsWith("Hunt") && component.objTGT != base.transform.gameObject)
							{
								if (!Herbivorous)
								{
									behavior = "ToHunt";
								}
								else
								{
									behavior = "Battle";
								}
								objTGT = component.objTGT;
								posTGT = component.posTGT;
								return true;
							}
							if (component.behavior.Equals("Battle") && component.objTGT != base.transform.gameObject)
							{
								behavior = "Battle";
								objTGT = component.objTGT;
								posTGT = component.posTGT;
								return true;
							}
							if (component.behavior.EndsWith("Food") && Food < 75f)
							{
								behavior = "ToFood";
								objTGT = component.objTGT;
								posTGT = component.posTGT;
								return true;
							}
							if (component.behavior.EndsWith("Water") && Water < 75f)
							{
								behavior = "ToWater";
								posTGT = component.posTGT;
								return true;
							}
							lookTGT = component.transform.position;
							behavior = "ToFriend";
							objTGT = component.gameObject;
							posTGT = component.body.worldCenterOfMass;
							return true;
						}
						objTGT = item._GameObject;
						lookTGT = objTGT.transform.position;
						posTGT = item._GameObject.transform.position;
						behavior = "ToFriend";
						return true;
					}
				}
			}
			return false;
		}
		return true;
	}

	private bool FindPath(bool invert = false)
	{
		Vector3 vector = Vector3.zero;
		RaycastHit hitInfo;
		if (CanFly)
		{
			float x = (IsOnGround ? UnityEngine.Random.Range(-90f, 0f) : ((!(posY < (float)(LowAltitude ? (-75) : (-150)))) ? UnityEngine.Random.Range(-15f, 0f) : UnityEngine.Random.Range(0f, 45f)));
			float num = UnityEngine.Random.Range(boxscale.z * 10f, boxscale.z * 20f);
			if (invert && (bool)objTGT)
			{
				float num2 = UnityEngine.Random.Range(-15f - angleAdd, 15f + angleAdd);
				vector = base.transform.position + Quaternion.Euler(x, objTGT.transform.eulerAngles.y + num2, 0f) * Vector3.forward * num;
			}
			else
			{
				float num2 = UnityEngine.Random.Range(-45f - angleAdd, 45f + angleAdd);
				vector = base.transform.position + Quaternion.Euler(x, base.transform.eulerAngles.y + num2, 0f) * Vector3.forward * num;
			}
			if (behavior.Equals("ToRepose"))
			{
				if (Physics.Linecast(vector + Vector3.up * withersSize, vector - Vector3.up * 200f, out hitInfo))
				{
					vector = ((!hitInfo.collider.gameObject.layer.Equals(main.waterLayer)) ? hitInfo.point : Vector3.zero);
				}
			}
			else if (Physics.Linecast(base.transform.position + Vector3.up * withersSize, vector + Vector3.up * withersSize))
			{
				vector = Vector3.zero;
			}
		}
		else if ((CanWalk && !CanSwim) | (CanSwim && CanWalk && !IsOnWater && !IsInWater))
		{
			if (invert && (bool)objTGT)
			{
				float num = UnityEngine.Random.Range(boxscale.z * 4f, boxscale.z * 10f);
				float num2 = UnityEngine.Random.Range(-15f - angleAdd, 15f + angleAdd);
				vector = base.transform.position + Quaternion.Euler(0f, objTGT.transform.eulerAngles.y + num2, 0f) * Vector3.forward * num;
			}
			else
			{
				float num = UnityEngine.Random.Range(boxscale.z * 4f, boxscale.z * 10f);
				float num2 = UnityEngine.Random.Range(-45f - angleAdd, 45f + angleAdd);
				vector = base.transform.position + Quaternion.Euler(0f, base.transform.eulerAngles.y + num2, 0f) * Vector3.forward * num;
			}
			vector = ((Physics.Linecast(base.transform.position + Vector3.up * withersSize, vector + Vector3.up * withersSize) || !Physics.Linecast(vector + Vector3.up * withersSize, vector - Vector3.up * withersSize * 2f, out hitInfo)) ? Vector3.zero : ((!hitInfo.collider.gameObject.layer.Equals(main.waterLayer) || CanSwim) ? hitInfo.point : Vector3.zero));
		}
		else if (CanSwim)
		{
			float x = ((!IsInWater) ? UnityEngine.Random.Range(0f, 45f) : (LowAltitude ? ((!IsOnGround) ? UnityEngine.Random.Range(0f, 45f) : 0f) : ((!IsOnWater) ? UnityEngine.Random.Range(-60f, 60f) : UnityEngine.Random.Range(0f, 45f))));
			if (invert && (bool)objTGT)
			{
				float num = UnityEngine.Random.Range(boxscale.z * 10f, boxscale.z * 20f);
				float num2 = UnityEngine.Random.Range(-15f - angleAdd, 15f + angleAdd);
				vector = base.transform.position + Quaternion.Euler(x, objTGT.transform.eulerAngles.y + num2, 0f) * Vector3.forward * num;
			}
			else
			{
				float num = UnityEngine.Random.Range(boxscale.z * 4f, boxscale.z * 15f);
				float num2 = UnityEngine.Random.Range(-45f - angleAdd, 45f + angleAdd);
				x = ((!IsInWater) ? UnityEngine.Random.Range(0f, 45f) : (LowAltitude ? ((!IsOnGround) ? UnityEngine.Random.Range(0f, 45f) : 0f) : ((!IsOnWater) ? UnityEngine.Random.Range(-60f, 60f) : UnityEngine.Random.Range(0f, 45f))));
				vector = base.transform.position + Quaternion.Euler(x, base.transform.eulerAngles.y + num2, 0f) * Vector3.forward * num;
			}
			if (IsInWater && vector.y > waterY)
			{
				vector = Vector3.zero;
			}
			if (Physics.Linecast(base.transform.position + Vector3.up * withersSize, vector + Vector3.up * withersSize))
			{
				vector = Vector3.zero;
			}
		}
		if (angleAdd > 360f)
		{
			angleAdd = 0f;
			posTGT = Vector3.zero;
			return false;
		}
		if (vector == Vector3.zero)
		{
			angleAdd += 5f;
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", 0);
			if (!invert)
			{
				posTGT = Vector3.zero;
			}
			return false;
		}
		angleAdd = 0f;
		posTGT = vector;
		return true;
	}

	private void ExecuteBehavior(int idle1 = 0, int idle2 = 0, int idle3 = 0, int idle4 = 0, int eat = 0, int drink = 0, int sleep = 0)
	{
		if (posTGT == Vector3.zero)
		{
			return;
		}
		bool flag = false;
		Creature creature = null;
		int num = 0;
		if (idle1 > 0)
		{
			num++;
		}
		if (idle2 > 0)
		{
			num++;
		}
		if (idle3 > 0)
		{
			num++;
		}
		if (idle4 > 0)
		{
			num++;
		}
		if (loop == 0)
		{
			rndMove = UnityEngine.Random.Range(0, 100);
			if (num > 0)
			{
				rndIdle = UnityEngine.Random.Range(0, num + 1);
			}
		}
		if ((bool)objCOL)
		{
			avoidDelta = Mathf.DeltaAngle(Quaternion.LookRotation(posCOL - base.transform.position).eulerAngles.y, base.transform.eulerAngles.y);
			if (Mathf.Abs(avoidDelta) > 90f)
			{
				avoidDelta = 0f;
			}
		}
		if ((bool)objTGT)
		{
			creature = objTGT.GetComponent<Creature>();
			if ((bool)creature && !behavior.Equals("ToFlee"))
			{
				posTGT = creature.body.worldCenterOfMass;
			}
		}
		distTGT = (base.transform.position - posTGT).magnitude;
		angTGT = Quaternion.LookRotation(posTGT - base.transform.position);
		delta = Mathf.DeltaAngle(angTGT.eulerAngles.y, base.transform.eulerAngles.y);
		actionDist = (base.transform.position - HeadPos).magnitude;
		UnityEngine.Debug.DrawLine(Head.transform.position, posTGT);
		switch (behavior)
		{
		case "ToPath":
			if (CanFly)
			{
				if (distTGT > boxscale.z * 4f)
				{
					AnmRun(rndMove);
					break;
				}
				if (IsOnGround)
				{
					anmStop();
				}
				flag = true;
			}
			else if (distTGT > actionDist * 2f)
			{
				anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "ToWaypoint":
			if (distTGT > actionDist * 3f)
			{
				if (PathEditor[nextPath]._PathType == PathType.Run)
				{
					AnmRun(rndMove);
				}
				else
				{
					anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
				}
			}
			else if (PathEditor[nextPath]._TargetAction == TargetAction.Sleep && Stamina != 100f)
			{
				AnmSleep(sleep);
			}
			else if (PathEditor[nextPath]._TargetAction == TargetAction.Eat && Food != 100f)
			{
				AnmEat(rndMove, eat, rndIdle, idle1, idle2, idle3, idle4);
			}
			else if (PathEditor[nextPath]._TargetAction == TargetAction.Drink && Water != 100f)
			{
				AnmDrink(drink);
			}
			else
			{
				anmStop();
				flag = true;
				nextPath++;
			}
			break;
		case "ToTarget":
		case "ToFriend":
			if ((bool)objTGT)
			{
				if (distTGT > actionDist * 4f)
				{
					AnmRun(rndMove);
				}
				else if (distTGT > actionDist * 2f)
				{
					if (CanFly)
					{
						AnmRun(rndMove);
					}
					else
					{
						anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
					}
				}
				else
				{
					anmStop();
					flag = true;
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "ToFlee":
			if ((bool)objTGT && (objTGT.transform.position - base.transform.position).magnitude < 100f)
			{
				AnmRun(rndMove);
				if (distTGT < actionDist * 4f)
				{
					FindPath(invert: true);
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "ToHerd":
			if ((bool)objTGT)
			{
				if ((bool)creature && creature.Health == 0f)
				{
					anmStop();
					flag = true;
				}
				else if ((bool)creature && creature.IsInWater && !CanSwim && !CanWalk)
				{
					anmStop();
					flag = true;
				}
				else if ((bool)creature && !creature.IsInWater && CanSwim && !CanWalk)
				{
					anmStop();
					flag = true;
				}
				else if (distTGT > actionDist * 10f && CanFly)
				{
					AnmRun(rndMove);
				}
				else if (distTGT > actionDist * 3f)
				{
					anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
				}
				else if ((bool)creature)
				{
					if (creature.behavior.Equals("Contest"))
					{
						AnmRun(rndMove);
						behavior = "ToFlee";
						FindPath(invert: true);
					}
					else if (CanWalk && CanAttack && !CanTailAttack && rndMove <= 10 && creature.behavior.Equals("ToHerd"))
					{
						creature.objTGT = base.transform.gameObject;
						creature.behavior = "Contest";
						creature.behaviorCount = 500f;
						behavior = "Contest";
						behaviorCount = 500f;
						anmStop();
					}
					else
					{
						anmStop();
						flag = true;
					}
				}
				else
				{
					anmStop();
					flag = true;
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "ToFood":
			if ((Food == 100f) | (!Herbivorous && !objTGT))
			{
				anmStop();
				flag = true;
			}
			else if ((bool)creature && creature.Health != 0f)
			{
				anmStop();
				flag = true;
			}
			else if (!CanSwim && IsInWater)
			{
				anmStop();
				flag = true;
			}
			else if (!CanWalk && !IsInWater)
			{
				anmStop();
				flag = true;
			}
			else if (CanFly && distTGT > actionDist * 4f)
			{
				AnmRun(rndMove);
			}
			else if (!Herbivorous && distTGT > actionDist * 1.25f)
			{
				anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
			}
			else if (Herbivorous && distTGT > actionDist)
			{
				anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
			}
			else
			{
				anmStop();
				behavior = "Food";
				behaviorCount = 5000f;
			}
			break;
		case "Food":
			if ((Food == 100f) | (!Herbivorous && !objTGT))
			{
				anmStop();
				flag = true;
			}
			else if ((bool)creature && creature.Health != 0f)
			{
				anmStop();
				flag = true;
			}
			else if (!CanSwim && IsInWater)
			{
				anmStop();
				flag = true;
			}
			else if (!CanWalk && !IsInWater)
			{
				anmStop();
				flag = true;
			}
			else if (!Herbivorous && ((distTGT < actionDist * 1.25f) | (objTGT == objCOL)))
			{
				AnmEat(rndMove, eat, rndIdle, idle1, idle2, idle3, idle4);
			}
			else if (Herbivorous && distTGT < actionDist)
			{
				AnmEat(rndMove, eat, rndIdle, idle1, idle2, idle3, idle4);
			}
			else
			{
				behavior = "ToFood";
			}
			break;
		case "ToWater":
			if ((Water == 100f) | IsInWater)
			{
				anmStop();
				flag = true;
			}
			else if (CanFly && distTGT > actionDist)
			{
				anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
			}
			else if (IsOnWater && IsOnGround)
			{
				if (CanSwim)
				{
					anmStop();
					behavior = "ToPath";
					FindPath();
				}
				else
				{
					anmStop();
					behavior = "Water";
					behaviorCount = 5000f;
				}
			}
			else
			{
				anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
			}
			break;
		case "Water":
			if ((Water == 100f) | IsInWater)
			{
				anmStop();
				flag = true;
			}
			else if (IsOnWater && IsOnGround && !CanSwim)
			{
				AnmDrink(drink);
			}
			else
			{
				behavior = "ToWater";
			}
			break;
		case "ToRepose":
			if (Stamina == 100f)
			{
				anmStop();
				flag = true;
			}
			else if (CanFly && distTGT > boxscale.z * 5f)
			{
				AnmRun(rndMove);
			}
			else if (distTGT > boxscale.z)
			{
				anmWalk(rndMove, rndIdle, idle1, idle2, idle3, idle4);
			}
			else
			{
				anmStop();
				behavior = "Repose";
				behaviorCount = 5000f;
			}
			break;
		case "Repose":
			if (Stamina == 100f)
			{
				anmStop();
				flag = true;
			}
			else
			{
				AnmSleep(sleep);
			}
			break;
		case "Contest":
			if ((bool)objTGT)
			{
				if (distTGT > 50f)
				{
					anmStop();
					flag = true;
				}
				else if (IsInWater)
				{
					anmStop();
					flag = true;
				}
				else
				{
					AnmBattle(rndMove, idle1, idle2, idle3, idle4, creature);
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "Battle":
			if ((bool)objTGT)
			{
				if (distTGT > 50f)
				{
					anmStop();
					flag = true;
				}
				else if (!CanSwim && IsInWater)
				{
					anmStop();
					flag = true;
				}
				else if (!CanWalk && IsOnGround && !IsOnWater)
				{
					anmStop();
					flag = true;
				}
				else if ((bool)creature && creature.behavior.Equals("ToFlee") && !Herbivorous)
				{
					anmStop();
					behavior = "ToHunt";
				}
				else if ((bool)creature && creature.behavior.Equals("ToFlee") && Herbivorous)
				{
					anmStop();
					flag = true;
				}
				else if ((bool)creature && creature.Health == 0f && !Herbivorous)
				{
					anmStop();
					behavior = "ToFood";
				}
				else if ((bool)creature && creature.Health == 0f && Herbivorous)
				{
					anmStop();
					flag = true;
				}
				else
				{
					AnmBattle(rndMove, idle1, idle2, idle3, idle4, creature);
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "ToHunt":
			if ((bool)objTGT)
			{
				if ((bool)creature && creature.Health == 0f)
				{
					anmStop();
					behavior = "ToFood";
				}
				else if ((bool)creature && distTGT < 50f && (creature.behavior.Equals("ToHunt") | creature.behavior.Equals("Battle")))
				{
					anmStop();
					behavior = "Battle";
				}
				else if (!CanSwim && IsInWater)
				{
					anmStop();
					flag = true;
				}
				else if (!CanWalk && IsOnGround && !IsOnWater)
				{
					anmStop();
					flag = true;
				}
				else if (distTGT > actionDist * 1.5f)
				{
					AnmRun(rndMove);
				}
				else
				{
					behavior = "Hunt";
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		case "Hunt":
			if ((bool)objTGT)
			{
				if ((bool)creature && creature.Health == 0f)
				{
					anmStop();
					behavior = "ToFood";
				}
				else if ((bool)creature && distTGT < 50f && (creature.behavior.Equals("Hunt") | creature.behavior.Equals("Battle")))
				{
					anmStop();
					behavior = "Battle";
				}
				else if (!CanSwim && IsInWater)
				{
					anmStop();
					flag = true;
				}
				else if (!CanWalk && IsOnGround && !IsOnWater)
				{
					anmStop();
					flag = true;
				}
				else if (distTGT < actionDist * 1.5f)
				{
					AnmHunt(rndMove, creature);
				}
				else
				{
					behavior = "ToHunt";
				}
			}
			else
			{
				anmStop();
				flag = true;
			}
			break;
		default:
			anmStop();
			flag = true;
			break;
		}
		if (behaviorCount <= 0f)
		{
			flag = true;
		}
		else
		{
			behaviorCount -= 1f;
		}
		if (flag)
		{
			objTGT = null;
			posTGT = Vector3.zero;
		}
	}

	private void AnmTurn(Vect type)
	{
		switch (type)
		{
		case Vect.backward:
			anm.SetFloat("Turn", angTGT.eulerAngles.y + ((delta > 0f) ? 180f : (-180f)));
			break;
		case Vect.strafe:
			anm.SetFloat("Turn", angTGT.eulerAngles.y + (float)((delta > 0f) ? 90 : (-90)));
			break;
		case Vect.forward:
			anm.SetFloat("Turn", angTGT.eulerAngles.y + avoidAdd);
			break;
		case Vect.zero:
			if ((delta > 135f) | (delta < -135f) | (CanSwim && distTGT < actionDist * 0.9f) | (CanWalk && distTGT < actionDist * 0.4f))
			{
				anm.SetInteger("Move", -1);
			}
			else if (delta > 45f)
			{
				anm.SetInteger("Move", 10);
			}
			else if (delta < -45f)
			{
				anm.SetInteger("Move", -10);
			}
			anm.SetFloat("Turn", angTGT.eulerAngles.y);
			break;
		}
	}

	private void anmStop()
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		anm.SetInteger("Move", 0);
		anm.SetInteger("Idle", 0);
	}

	private void anmWalk(int rndMove, int rndIdle, int idle1, int idle2, int idle3, int idle4)
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		if (CanFly)
		{
			if (!IsOnGround)
			{
				anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
			}
			else
			{
				anm.SetFloat("Pitch", 0.25f);
			}
			if (rndMove > 95)
			{
				AnmIdles(rndIdle, idle1, idle2, idle3, idle4);
			}
			else
			{
				anm.SetInteger("Idle", 0);
				anm.SetInteger("Move", 1);
			}
			AnmTurn(Vect.forward);
			return;
		}
		if (CanSwim)
		{
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
		}
		if (rndMove > 98)
		{
			AnmIdles(rndIdle, idle1, idle2, idle3, idle4);
		}
		else if (rndMove > 96)
		{
			anm.SetInteger("Move", 1);
			anm.SetInteger("Idle", 1);
		}
		else
		{
			anm.SetInteger("Move", 1);
			anm.SetInteger("Idle", 0);
		}
		AnmTurn(Vect.forward);
	}

	private void AnmRun(int rndMove)
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		if (CanSwim)
		{
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
		}
		if (CanFly)
		{
			anm.SetFloat("Pitch", IsOnGround ? (-0.75f) : ((Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f));
		}
		if (rndMove > 98)
		{
			anm.SetInteger("Idle", 1);
		}
		else
		{
			anm.SetInteger("Idle", 0);
		}
		anm.SetInteger("Move", 2);
		AnmTurn(Vect.forward);
	}

	private void AnmDrink(int drink)
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		anm.SetInteger("Move", 0);
		if (CanFly && !IsOnGround)
		{
			anm.SetFloat("Pitch", 0.25f);
			return;
		}
		anm.SetInteger("Idle", drink);
		Water = Mathf.Clamp(Water + 0.025f, 0f, 100f);
	}

	private void AnmEat(int rndMove, int eat, int rndIdle, int idle1, int idle2, int idle3, int idle4)
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		anm.SetInteger("Move", 0);
		if (CanSwim)
		{
			body.MovePosition(Vector3.Lerp(base.transform.position, posTGT + (base.transform.position - Head.GetChild(0).GetChild(0).position), 0.01f));
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
		}
		if (CanFly && !IsOnGround)
		{
			anm.SetFloat("Pitch", 0.25f);
		}
		else if (delta < 45f && delta > -45f)
		{
			if (anm.GetInteger("Idle") == eat)
			{
				Food = Mathf.Clamp(Food + 0.05f, 0f, 100f);
				if (Water < 25f)
				{
					Water += 0.1f;
				}
			}
			if (rndMove > 50)
			{
				anm.SetInteger("Idle", eat);
			}
			else if (rndMove > 25)
			{
				anm.SetInteger("Idle", 0);
			}
			else
			{
				AnmIdles(rndIdle, idle1, idle2, idle3, idle4);
			}
		}
		else
		{
			anm.SetInteger("Idle", 0);
		}
		AnmTurn(Vect.zero);
	}

	private void AnmSleep(int sleep)
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		anm.SetInteger("Move", 0);
		if (CanFly && !IsOnGround)
		{
			anm.SetFloat("Pitch", 0.25f);
			return;
		}
		Stamina = Mathf.Clamp(Stamina + 0.01f, 0f, 100f);
		if (!OnAnm.IsName(specie + "|SitIdle"))
		{
			anm.SetInteger("Idle", sleep);
		}
		else if (Herbivorous && rndMove > 95)
		{
			anm.SetInteger("Idle", sleep);
		}
		else if (Herbivorous && rndMove > 90)
		{
			anm.SetInteger("Idle", 1);
		}
		else if (Herbivorous)
		{
			anm.SetInteger("Idle", 0);
		}
	}

	private void AnmIdles(int rndIdle, int idle1, int idle2, int idle3, int idle4)
	{
		if (CanAttack)
		{
			anm.SetBool("Attack", value: false);
		}
		anm.SetInteger("Move", 0);
		switch (rndIdle)
		{
		case 0:
			anm.SetInteger("Idle", 0);
			break;
		case 1:
			anm.SetInteger("Idle", idle1);
			break;
		case 2:
			anm.SetInteger("Idle", idle2);
			break;
		case 3:
			anm.SetInteger("Idle", idle3);
			break;
		case 4:
			anm.SetInteger("Idle", idle4);
			break;
		}
	}

	private void AnmHunt(int rndMove, Creature other)
	{
		bool flag = false;
		if ((delta < -25f) | (delta > 25f) | ((bool)other && !other.anm.GetInteger("Move").Equals(2)))
		{
			flag = true;
		}
		if (CanFly)
		{
			AnmTurn(Vect.forward);
			anm.SetBool("OnGround", value: false);
			IsOnGround = false;
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
			if ((bool)other)
			{
				body.velocity = other.body.velocity;
				body.MovePosition(Vector3.Lerp(base.transform.position, other.body.worldCenterOfMass + (base.transform.position - Head.GetChild(0).position) + base.transform.up, 0.1f));
			}
			else
			{
				body.MovePosition(Vector3.Lerp(base.transform.position, objTGT.transform.position + (base.transform.position - Head.GetChild(0).position) + base.transform.up, 0.025f));
			}
			if (rndMove < 25)
			{
				anm.SetInteger("Move", 1);
				anm.SetBool("Attack", value: true);
				anm.SetInteger("Idle", 0);
			}
			else if (rndMove < 50)
			{
				anm.SetInteger("Move", -10);
				anm.SetBool("Attack", value: true);
				anm.SetInteger("Idle", 0);
			}
			else if (rndMove < 75)
			{
				anm.SetInteger("Move", -10);
				anm.SetBool("Attack", value: true);
				anm.SetInteger("Idle", 0);
			}
			else
			{
				anm.SetInteger("Move", -1);
				anm.SetBool("Attack", value: false);
				anm.SetInteger("Idle", 1);
			}
		}
		else if (!CanSwim | (CanSwim && CanWalk && !IsInWater))
		{
			if (objCOL == objTGT)
			{
				anm.SetBool("Attack", value: true);
				AnmTurn(Vect.zero);
			}
			else if (distTGT < actionDist)
			{
				anm.SetInteger("Move", 0);
				anm.SetBool("Attack", value: false);
				AnmTurn(Vect.zero);
			}
			else if (distTGT < actionDist * 1.25f)
			{
				anm.SetInteger("Move", (rndMove < 50) ? 1 : 2);
				anm.SetBool("Attack", value: true);
				AnmTurn(Vect.forward);
			}
			else
			{
				anm.SetInteger("Move", (!flag) ? 2 : 0);
				anm.SetBool("Attack", value: false);
				AnmTurn(Vect.forward);
			}
		}
		else
		{
			if ((bool)other)
			{
				body.MovePosition(Vector3.Lerp(base.transform.position, other.body.worldCenterOfMass + (base.transform.position - Head.GetChild(0).position), 0.01f));
			}
			else
			{
				body.MovePosition(Vector3.Lerp(base.transform.position, objTGT.transform.position + (base.transform.position - Head.GetChild(0).position), 0.01f));
			}
			anm.SetInteger("Idle", 0);
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
			if (distTGT < actionDist)
			{
				anm.SetInteger("Move", 0);
				anm.SetBool("Attack", value: false);
				AnmTurn(Vect.zero);
			}
			else if ((distTGT < actionDist * 1.25f) | (objCOL == objTGT))
			{
				anm.SetInteger("Move", (rndMove < 50) ? 1 : 2);
				anm.SetBool("Attack", value: true);
				AnmTurn(Vect.forward);
			}
			else
			{
				anm.SetInteger("Move", (!flag) ? 2 : 0);
				anm.SetBool("Attack", value: false);
				AnmTurn(Vect.forward);
			}
		}
	}

	private void AnmBattle(int rndMove, int idle1, int idle2, int idle3, int idle4, Creature other)
	{
		if (CanFly)
		{
			bool flag = false;
			if ((delta < -25f) | (delta > 25f))
			{
				flag = true;
			}
			AnmTurn(Vect.forward);
			anm.SetBool("OnGround", value: false);
			IsOnGround = false;
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
			if (rndMove < 75)
			{
				if ((bool)other)
				{
					body.MovePosition(Vector3.Lerp(base.transform.position, other.body.worldCenterOfMass + (base.transform.position - Head.GetChild(0).position) + base.transform.up, 0.025f));
				}
				else
				{
					body.MovePosition(Vector3.Lerp(base.transform.position, objTGT.transform.position + (base.transform.position - Head.GetChild(0).position) + base.transform.up, 0.025f));
				}
				if ((objCOL == objTGT) | (distTGT < actionDist * 1.25f))
				{
					anm.SetBool("Attack", value: true);
				}
				else
				{
					anm.SetBool("Attack", value: false);
				}
				if (rndMove > 40)
				{
					anm.SetInteger("Move", (!flag) ? 1 : 0);
				}
				else if (rndMove > 30)
				{
					anm.SetInteger("Move", (!flag) ? (-1) : 0);
				}
				else if (rndMove > 20)
				{
					anm.SetInteger("Move", (!flag) ? 10 : 0);
				}
				else if (rndMove > 10)
				{
					anm.SetInteger("Move", (!flag) ? (-10) : 0);
				}
				else
				{
					anm.SetInteger("Move", 0);
				}
			}
			else if (distTGT < actionDist * 5f)
			{
				anm.SetBool("Attack", value: false);
				anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 100) == 0) ? 1 : 0);
				if (rndMove > 95)
				{
					anm.SetInteger("Move", (!flag) ? 1 : 0);
				}
				else if (rndMove > 90)
				{
					anm.SetInteger("Move", (!flag) ? (-1) : 0);
				}
				else if (rndMove > 85)
				{
					anm.SetInteger("Move", (!flag) ? 10 : 0);
				}
				else if (rndMove > 80)
				{
					anm.SetInteger("Move", (!flag) ? (-10) : 0);
				}
				else
				{
					anm.SetInteger("Move", 0);
				}
			}
			else
			{
				anm.SetInteger("Move", 2);
				anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 100) == 0) ? 1 : 0);
			}
		}
		else if (!CanSwim | (CanSwim && CanWalk && !IsInWater))
		{
			if (((bool)other && ((rndMove < 50) | (other.rndMove < 50)) && distTGT < actionDist * 2f) | (!other && rndMove < 50 && distTGT < actionDist * 2f))
			{
				anm.SetInteger("Idle", 0);
				if (distTGT < actionDist)
				{
					anm.SetInteger("Move", -1);
					AnmTurn(Vect.forward);
					anm.SetBool("Attack", value: false);
				}
				else if (distTGT < actionDist * 1.25f)
				{
					anm.SetInteger("Move", (rndMove >= 25) ? 1 : 0);
					AnmTurn(Vect.forward);
					anm.SetBool("Attack", value: true);
				}
				else
				{
					anm.SetInteger("Move", (rndMove < 25) ? 1 : 2);
					AnmTurn(Vect.forward);
					anm.SetBool("Attack", value: true);
				}
			}
			else if (distTGT < actionDist * 5f)
			{
				anm.SetBool("Attack", value: false);
				if ((bool)other && distTGT < actionDist * 2f && rndMove > 50 && other.rndMove < 50)
				{
					anm.SetInteger("Move", -1);
					AnmTurn(Vect.forward);
					anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 10) == 0) ? 1 : 0);
				}
				else if (distTGT < actionDist * 2f && rndMove > 50)
				{
					anm.SetInteger("Move", -1);
					AnmTurn(Vect.forward);
					anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 10) == 0) ? 1 : 0);
				}
				else if ((bool)other && rndMove < 50 && other.rndMove < 50)
				{
					anm.SetInteger("Move", 2);
					AnmTurn(Vect.forward);
					anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 10) == 0) ? 1 : 0);
				}
				else if (!other && rndMove < 50)
				{
					anm.SetInteger("Move", 2);
					AnmTurn(Vect.forward);
					anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 10) == 0) ? 1 : 0);
				}
				else if (!CanSwim && rndMove < 75)
				{
					anm.SetInteger("Move", 1);
					AnmTurn(Vect.strafe);
					anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 10) == 0) ? 1 : 0);
				}
				else
				{
					anm.SetInteger("Move", 0);
					AnmTurn(Vect.forward);
					AnmIdles(rndIdle, idle1, idle2, idle3, idle4);
				}
			}
			else
			{
				anm.SetInteger("Move", 2);
				anm.SetBool("Attack", value: false);
				AnmTurn(Vect.forward);
				anm.SetInteger("Idle", (UnityEngine.Random.Range(0, 10) == 0) ? 1 : 0);
			}
		}
		else
		{
			if (!CanSwim)
			{
				return;
			}
			anm.SetFloat("Pitch", (Vector3.Angle(Vector3.up, (body.worldCenterOfMass - posTGT).normalized) - 90f) / -90f);
			if (Mathf.Abs(delta) < 25f)
			{
				AnmTurn(Vect.forward);
				if (distTGT < actionDist * 2f)
				{
					anm.SetInteger("Move", (rndMove >= 50) ? 1 : 0);
					anm.SetBool("Attack", value: true);
				}
				else if (distTGT < actionDist * 3f)
				{
					anm.SetInteger("Move", 2);
					anm.SetBool("Attack", value: true);
				}
				else
				{
					anm.SetInteger("Move", 2);
					anm.SetBool("Attack", value: false);
				}
			}
			else if (rndMove < 33)
			{
				AnmTurn(Vect.strafe);
				anm.SetInteger("Move", 1);
			}
			else if (rndMove < 66)
			{
				AnmTurn(Vect.forward);
				anm.SetInteger("Move", 2);
			}
			else
			{
				AnmTurn(Vect.zero);
			}
		}
	}
}
public class Manager : MonoBehaviour
{
	private const string ManagerHelp = "Disable creatures management.\nCreatures A.I. still work, player inputs, camera behavior and GUI features are disabled.\nUseful if you want to use a third party asset e.g. fps controller. However, manager component still to be attached to the MainCam. ";

	[Header("JURASSIC PACK MANAGER")]
	[Tooltip("Disable creatures management.\nCreatures A.I. still work, player inputs, camera behavior and GUI features are disabled.\nUseful if you want to use a third party asset e.g. fps controller. However, manager component still to be attached to the MainCam. ")]
	public bool UseManager = true;

	[SerializeField]
	private bool ShowGUI = true;

	[SerializeField]
	private bool ShowFPS = true;

	public Texture2D helpscreen;

	public Texture2D icons;

	[SerializeField]
	private bool InvertYAxis;

	[SerializeField]
	[Range(0.1f, 10f)]
	private float sensivity = 2.5f;

	public AudioClip Wind;

	[Space(10f)]
	[Header("GLOBAL CREATURES SETTINGS")]
	[Tooltip("Add your creatures prefabs here, this will make it spawnable during game.")]
	public List<GameObject> CollectionList;

	private const string IKHelp = "Inverse Kinematics - Accurate feet placement on ground";

	[Tooltip("Inverse Kinematics - Accurate feet placement on ground")]
	public bool UseIK;

	[Tooltip("Creatures will be active even if they are no longer visible. (performance may be affected).")]
	public bool RealtimeGame;

	[Tooltip("Countdown to destroy the creature after his dead. Put 0 to cancels the countdown, the body will remain on the scene without disappearing.")]
	public int TimeAfterDead = 10000;

	private const string RaycastHelp = "ENABLED : allow creatures to walk on all kind of collider. (more expensive).\n\nDISABLED : creatures can only walk on Terrain collider (faster).\n";

	[Tooltip("ENABLED : allow creatures to walk on all kind of collider. (more expensive).\n\nDISABLED : creatures can only walk on Terrain collider (faster).\n")]
	public bool UseRaycast;

	[Tooltip("Layer used for water.")]
	public int waterLayer;

	[Tooltip("Unity terrain tree layer, the layer must be defined into tree model prefab")]
	public int treeLayer;

	[Tooltip("The maximium walkable slope before the creature start slipping.")]
	[Range(0.1f, 1f)]
	public float MaxSlope = 0.75f;

	[Tooltip("Water plane altitude")]
	public float WaterAlt = 55f;

	[Tooltip("Blood particle for creatures")]
	public ParticleSystem blood;

	[HideInInspector]
	public List<GameObject> creaturesList;

	[HideInInspector]
	public List<GameObject> playersList;

	[HideInInspector]
	public int selected;

	[HideInInspector]
	public int CameraMode = 1;

	[HideInInspector]
	public int message;

	[HideInInspector]
	public Terrain T;

	[HideInInspector]
	public TerrainData tdata;

	[HideInInspector]
	public Vector3 tpos = Vector3.zero;

	[HideInInspector]
	public float tres;

	[HideInInspector]
	public int toolBarTab = -1;

	[HideInInspector]
	public int addCreatureTab = -2;

	[HideInInspector]
	public int count;

	private bool browser;

	private Vector2 scroll1 = Vector2.zero;

	private Vector2 scroll2 = Vector2.zero;

	private float vx;

	private float vy;

	private float vz = 25f;

	private float timer;

	private float frame;

	private float fps;

	private Rigidbody body;

	private AudioSource source;

	private bool spawnAI;

	private bool rndSkin;

	private bool rndSize;

	private bool rndSetting;

	private int rndSizeSpan = 1;

	private void Awake()
	{
		GameObject[] array = GameObject.FindGameObjectsWithTag("Creature");
		GameObject[] array2 = GameObject.FindGameObjectsWithTag("Player");
		GameObject[] array3 = array;
		foreach (GameObject gameObject in array3)
		{
			if (!gameObject.name.EndsWith("(Clone)"))
			{
				creaturesList.Add(gameObject.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(gameObject.gameObject);
			}
		}
		array3 = array2;
		foreach (GameObject gameObject2 in array3)
		{
			playersList.Add(gameObject2.gameObject);
		}
		if (UseManager)
		{
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			body = base.transform.root.GetComponent<Rigidbody>();
			source = base.transform.root.GetComponent<AudioSource>();
		}
		if ((bool)Terrain.activeTerrain)
		{
			T = Terrain.activeTerrain;
			tdata = T.terrainData;
			tpos = T.GetPosition();
			tres = tdata.heightmapResolution;
		}
		treeLayer = 1 << treeLayer;
	}

	private void Update()
	{
		if (!UseManager)
		{
			return;
		}
		if (ShowFPS)
		{
			frame += 1f;
			timer += Time.deltaTime;
			if (timer > 1f)
			{
				fps = frame;
				timer = 0f;
				frame = 0f;
			}
		}
		if (Application.isEditor)
		{
			if (Input.GetKeyDown(KeyCode.Escape) && toolBarTab == -1)
			{
				Cursor.lockState = CursorLockMode.None;
				toolBarTab = 1;
			}
			else if (Input.GetKeyDown(KeyCode.Escape) && toolBarTab != -1)
			{
				Cursor.lockState = CursorLockMode.None;
				toolBarTab = -1;
			}
			else if (toolBarTab == -1)
			{
				Cursor.lockState = CursorLockMode.Locked;
			}
		}
		else if (Cursor.lockState == CursorLockMode.None && Input.GetKeyDown(KeyCode.Escape))
		{
			Cursor.lockState = CursorLockMode.Locked;
		}
		else if (Input.GetKeyDown(KeyCode.Escape))
		{
			Cursor.lockState = CursorLockMode.None;
		}
		if (Input.GetKeyDown(KeyCode.X))
		{
			if (selected > 0)
			{
				selected--;
			}
			else
			{
				selected = creaturesList.Count - 1;
			}
		}
		else if (Input.GetKeyDown(KeyCode.Y))
		{
			if (selected < creaturesList.Count - 1)
			{
				selected++;
			}
			else
			{
				selected = 0;
			}
		}
		if (Input.GetKeyDown(KeyCode.C))
		{
			if (CameraMode == 2)
			{
				CameraMode = 0;
			}
			else
			{
				CameraMode++;
			}
		}
	}

	private void FixedUpdate()
	{
		if (!UseManager)
		{
			return;
		}
		Creature creature = null;
		if (creaturesList.Count == 0)
		{
			CameraMode = 0;
		}
		else if (!creaturesList[selected] | !creaturesList[selected].activeInHierarchy)
		{
			CameraMode = 0;
		}
		else
		{
			creature = creaturesList[selected].GetComponent<Creature>();
		}
		if ((bool)T && T.SampleHeight(base.transform.root.position) + T.GetPosition().y > base.transform.root.position.y - 1f)
		{
			body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
			base.transform.root.position = new Vector3(base.transform.root.position.x, T.SampleHeight(base.transform.root.position) + T.GetPosition().y + 1f, base.transform.root.position.z);
		}
		switch (CameraMode)
		{
		case 0:
		{
			if (source.clip == null)
			{
				source.clip = Wind;
			}
			else if (source.clip == Wind)
			{
				if (source.isPlaying)
				{
					source.volume = body.velocity.magnitude / 128f;
					source.pitch = source.volume;
				}
				else
				{
					source.PlayOneShot(Wind);
				}
			}
			Vector3 zero = Vector3.zero;
			float num = 0f;
			if (Input.GetKey(KeyCode.LeftShift))
			{
				body.mass = 0.025f;
			}
			else
			{
				body.mass = 0.1f;
			}
			body.drag = 1f;
			if ((Cursor.lockState == CursorLockMode.Locked) | Input.GetKey(KeyCode.Mouse2))
			{
				vx += Input.GetAxis("Mouse X") * sensivity;
				vy = Mathf.Clamp(InvertYAxis ? (vy + Input.GetAxis("Mouse Y") * sensivity) : (vy - Input.GetAxis("Mouse Y") * sensivity), -89.9f, 89.9f);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.AngleAxis(vx, Vector3.up) * Quaternion.AngleAxis(vy, Vector3.right), 0.1f);
			}
			num = (Input.GetKey(KeyCode.Space) ? 1f : ((!Input.GetKey(KeyCode.LeftControl)) ? 0f : (-1f)));
			zero = base.transform.rotation * new Vector3(Input.GetAxis("Horizontal"), num, Input.GetAxis("Vertical"));
			body.AddForce(zero * (base.transform.root.position - (base.transform.root.position + zero)).magnitude);
			break;
		}
		case 1:
		{
			body.mass = 1f;
			body.drag = 10f;
			float withersSize = creature.withersSize;
			if ((Cursor.lockState == CursorLockMode.Locked) | Input.GetKey(KeyCode.Mouse2))
			{
				if (Input.GetKey(KeyCode.Mouse1))
				{
					vx = creaturesList[selected].transform.eulerAngles.y;
					if (creature.IsOnLevitation)
					{
						vy = Mathf.Clamp(Mathf.Lerp(vy, creature.anm.GetFloat("Pitch") * 90f, 0.01f), -45f, 90f);
					}
					else
					{
						vy = Mathf.Clamp(InvertYAxis ? (vy - Input.GetAxis("Mouse Y") * sensivity) : (vy + Input.GetAxis("Mouse Y") * sensivity), -90f, 90f);
					}
				}
				else if (!Input.GetKey(KeyCode.Mouse2) | (Cursor.lockState != CursorLockMode.Locked))
				{
					vx += Input.GetAxis("Mouse X") * sensivity;
					vy = Mathf.Clamp(InvertYAxis ? (vy - Input.GetAxis("Mouse Y") * sensivity) : (vy + Input.GetAxis("Mouse Y") * sensivity), -90f, 90f);
				}
			}
			vz = Mathf.Clamp(vz - Input.GetAxis("Mouse ScrollWheel") * 10f, withersSize, withersSize * 32f);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.Euler(vy, vx, 0f), 0.1f);
			Vector3 vector = creaturesList[selected].transform.root.position + Vector3.up * withersSize * 1.5f - base.transform.root.position - base.transform.forward * vz;
			body.AddForce(vector * 128f);
			break;
		}
		case 2:
		{
			float withersSize = creature.withersSize;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(creaturesList[selected].transform.root.position + Vector3.up * withersSize * 1.5f - base.transform.root.position), 0.1f);
			break;
		}
		default:
			CameraMode = 0;
			break;
		}
	}

	private void OnGUI()
	{
		if (!UseManager)
		{
			return;
		}
		float num = Screen.width;
		float num2 = Screen.height;
		Creature creature = null;
		if (creaturesList.Count > 0 && (bool)creaturesList[selected] && creaturesList[selected].activeInHierarchy)
		{
			creature = creaturesList[selected].GetComponent<Creature>();
		}
		GUIStyle gUIStyle = new GUIStyle("box");
		gUIStyle.fontSize = 16;
		if (Cursor.lockState == CursorLockMode.None)
		{
			if ((bool)creature && CameraMode != 0)
			{
				GUI.Box(new Rect(0f, 0f, num, 50f), creaturesList[selected].name);
				GUI.color = Color.yellow;
				if (GUI.Button(new Rect(0f, 5f, num / 16f - 4f, 20f), "Free"))
				{
					CameraMode = 0;
				}
				if (CameraMode == 1)
				{
					GUI.color = Color.green;
				}
				if (GUI.Button(new Rect(num / 16f * 1.5f, 5f, num / 16f - 4f, 20f), "Follow"))
				{
					CameraMode = 1;
				}
				GUI.color = Color.yellow;
				if (CameraMode == 2)
				{
					GUI.color = Color.green;
				}
				if (GUI.Button(new Rect(num / 16f * 3f, 5f, num / 16f - 4f, 20f), "POV"))
				{
					CameraMode = 2;
				}
			}
			else
			{
				GUI.Box(new Rect(0f, 0f, num, 50f), "", gUIStyle);
				if ((bool)creature)
				{
					GUI.color = Color.green;
					GUI.Button(new Rect(0f, 5f, num / 16f - 4f, 20f), "Free");
					GUI.color = Color.yellow;
					if (GUI.Button(new Rect(num / 16f * 1.5f, 5f, num / 16f - 4f, 20f), "Follow"))
					{
						CameraMode = 1;
					}
					if (GUI.Button(new Rect(num / 16f * 3f, 5f, num / 16f - 4f, 20f), "POV"))
					{
						CameraMode = 2;
					}
				}
			}
			GUI.color = Color.white;
			Cursor.visible = true;
			if (!ShowGUI)
			{
				GUI.Box(new Rect(0f, 0f, num, 50f), "");
			}
			string[] texts = new string[4] { "File", "Creatures", "Options", "Help" };
			GUI.color = Color.yellow;
			toolBarTab = GUI.Toolbar(new Rect(0f, 30f, num, 20f), toolBarTab, texts);
			GUI.color = Color.white;
			switch (toolBarTab)
			{
			case 0:
				GUI.Box(new Rect(0f, 50f, num, num2 - 50f), "", gUIStyle);
				if (GUI.Button(new Rect(num / 2f - 60f, num2 / 2f - 35f, 120f, 30f), "Reset"))
				{
					SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
				}
				if (GUI.Button(new Rect(num / 2f - 60f, num2 / 2f + 5f, 120f, 30f), "Quit"))
				{
					Application.Quit();
				}
				break;
			case 1:
				if ((bool)creature)
				{
					GUI.Box(new Rect(0f, 50f, num * 0.25f, num2 * 0.75f - 50f), "");
					string text = creaturesList[selected].name;
					creaturesList[selected].name = GUI.TextField(new Rect(25f, 50f, num * 0.25f - 25f, 25f), text, gUIStyle);
					if (GUI.Button(new Rect(0f, 50f, 25f, 25f), "X"))
					{
						UnityEngine.Object.Destroy(creaturesList[selected].gameObject);
						creaturesList.RemoveAt(selected);
						if (selected > 0)
						{
							selected--;
						}
						else
						{
							if (creaturesList.Count <= 0)
							{
								return;
							}
							selected = creaturesList.Count - 1;
						}
					}
					if (browser)
					{
						if (GUI.Button(new Rect(0f, 75f, num * 0.25f, 25f), "Close Browser"))
						{
							browser = false;
						}
						GUI.Box(new Rect(0f, 100f, num * 0.25f, num2 * 0.75f - 100f), "Creatures : " + creaturesList.Count);
						scroll1 = GUI.BeginScrollView(new Rect(0f, 130f, num * 0.25f, num2 * 0.75f - 140f), scroll1, new Rect(0f, 0f, 270f, creaturesList.Count * 40), alwaysShowHorizontal: false, alwaysShowVertical: true);
						int value = creaturesList.Count;
						int num3 = Mathf.RoundToInt(scroll1.y / 40f);
						value = Mathf.Clamp(value, num3, num3 + Mathf.RoundToInt(num2 * 0.75f / 40f));
						for (int i = num3; i < value; i++)
						{
							float num4 = 40 * i;
							if (selected != i)
							{
								GUI.color = Color.gray;
							}
							else
							{
								GUI.color = Color.white;
							}
							GUI.Label(new Rect(5f, num4, num * 0.25f - 30f, 25f), i + 1 + ". ");
							if (GUI.Button(new Rect(30f, num4, 20f, 20f), "X"))
							{
								if (i <= selected && ((selected > 0) | (selected == creaturesList.Count - 1)))
								{
									selected--;
								}
								UnityEngine.Object.Destroy(creaturesList[i].gameObject);
								creaturesList.RemoveAt(i);
								return;
							}
							if (GUI.Button(new Rect(50f, num4, 140f, 20f), creaturesList[i].name))
							{
								selected = i;
								CameraMode = 1;
							}
							if (GUI.Button(new Rect(190f, num4, 40f, 20f), "Edit"))
							{
								selected = i;
								browser = false;
							}
							Creature component = creaturesList[i].gameObject.GetComponent<Creature>();
							GUI.Label(new Rect(235f, num4, num * 0.25f - 30f, 25f), component.behavior + "  " + component.behaviorCount);
							Rect texCoords = new Rect(0f, 0f, 0.1f, 0.1f);
							GUI.color = Color.black;
							GUI.DrawTextureWithTexCoords(new Rect(30f, num4 + 22f, 50f, 4f), icons, texCoords, alphaBlend: false);
							GUI.DrawTextureWithTexCoords(new Rect(85f, num4 + 22f, 50f, 4f), icons, texCoords, alphaBlend: false);
							GUI.color = Color.green;
							GUI.DrawTextureWithTexCoords(new Rect(30f, num4 + 22f, component.Health / 2f, 4f), icons, texCoords, alphaBlend: false);
							GUI.color = Color.yellow;
							GUI.DrawTextureWithTexCoords(new Rect(85f, num4 + 22f, component.Food / 2f, 4f), icons, texCoords, alphaBlend: false);
							if (!component.CanSwim)
							{
								GUI.color = Color.black;
								GUI.DrawTextureWithTexCoords(new Rect(140f, num4 + 22f, 50f, 4f), icons, texCoords, alphaBlend: false);
								GUI.DrawTextureWithTexCoords(new Rect(195f, num4 + 22f, 50f, 4f), icons, texCoords, alphaBlend: false);
								GUI.color = Color.cyan;
								GUI.DrawTextureWithTexCoords(new Rect(140f, num4 + 22f, component.Water / 2f, 4f), icons, texCoords, alphaBlend: false);
								GUI.color = Color.gray;
								GUI.DrawTextureWithTexCoords(new Rect(195f, num4 + 22f, component.Stamina / 2f, 4f), icons, texCoords, alphaBlend: false);
							}
						}
						GUI.EndScrollView();
					}
					else
					{
						if (GUI.Button(new Rect(num * 0.25f / 4f, 75f, num * 0.25f / 2f, 20f), "Browse : " + (selected + 1) + "/" + creaturesList.Count))
						{
							browser = true;
						}
						if (GUI.Button(new Rect(0f, 75f, num * 0.25f / 4f, 20f), "<<"))
						{
							if (selected > 0)
							{
								selected--;
							}
							else
							{
								selected = creaturesList.Count - 1;
							}
						}
						if (GUI.Button(new Rect(num * 0.25f / 4f * 3f, 75f, num * 0.25f / 4f, 20f), ">>"))
						{
							if (selected < creaturesList.Count - 1)
							{
								selected++;
							}
							else
							{
								selected = 0;
							}
						}
						scroll1 = GUI.BeginScrollView(new Rect(0f, 110f, num * 0.25f, num2 * 0.75f - 110f), scroll1, new Rect(0f, 0f, 0f, 430f), alwaysShowHorizontal: false, alwaysShowVertical: true);
						if (creature.UseAI)
						{
							GUI.color = Color.gray;
							if (GUI.Button(new Rect(num * 0.25f / 2f, 0f, num * 0.25f / 2f - 20f, 25f), "Player"))
							{
								creature.SetAI(UseAI: false);
							}
							GUI.color = Color.green;
							GUI.Box(new Rect(10f, 0f, num * 0.25f / 2f - 10f, 25f), "A.I. : " + creature.behavior);
						}
						else
						{
							GUI.color = Color.green;
							GUI.Box(new Rect(num * 0.25f / 2f, 0f, num * 0.25f / 2f - 20f, 25f), "Player");
							GUI.color = Color.gray;
							if (GUI.Button(new Rect(10f, 0f, num * 0.25f / 2f - 10f, 25f), "A.I."))
							{
								creature.SetAI(UseAI: true);
							}
						}
						GUI.color = Color.white;
						int num5 = creature.bodyTexture.GetHashCode();
						int hashCode = creature.eyesTexture.GetHashCode();
						if (GUI.Button(new Rect(10f, 30f, num * 0.25f - 30f, 25f), "Body Skin : " + creature.bodyTexture))
						{
							num5 = ((num5 < 2) ? (num5 + 1) : 0);
							creature.SetMaterials(num5, hashCode);
						}
						if (GUI.Button(new Rect(10f, 60f, num * 0.25f - 30f, 25f), "Eyes Skin : " + creature.eyesTexture))
						{
							hashCode = ((hashCode < 15) ? (hashCode + 1) : 0);
							creature.SetMaterials(num5, hashCode);
						}
						float x = creaturesList[selected].transform.localScale.x;
						GUI.Box(new Rect(10f, 90f, num * 0.25f - 30f, 25f), "Scale : " + Mathf.Round(x * 100f) / 100f);
						x = GUI.HorizontalSlider(new Rect(10f, 110f, num * 0.25f - 30f, 25f), creaturesList[selected].transform.localScale.x, 0.1f, 1f);
						if (x != creaturesList[selected].transform.localScale.x)
						{
							creaturesList[selected].SendMessage("SetScale", Mathf.Round(x * 100f) / 100f);
						}
						GUI.Box(new Rect(10f, 125f, num * 0.25f - 30f, 25f), "Animation Speed : " + Mathf.Round(creature.AnimSpeed * 100f) / 100f);
						creature.AnimSpeed = GUI.HorizontalSlider(new Rect(10f, 145f, num * 0.25f - 30f, 25f), creature.AnimSpeed, 0f, 2f);
						GUI.Box(new Rect(10f, 160f, num * 0.25f - 30f, 25f), "Health : " + Mathf.Round(creature.Health * 10f) / 10f);
						creature.Health = GUI.HorizontalSlider(new Rect(10f, 180f, num * 0.25f - 30f, 25f), creature.Health, 0f, 100f);
						GUI.Box(new Rect(10f, 200f, num * 0.25f - 30f, 20f), "Food : " + Mathf.Round(creature.Food * 10f) / 10f);
						creature.Food = GUI.HorizontalSlider(new Rect(10f, 220f, num * 0.25f - 30f, 20f), creature.Food, 0f, 100f);
						GUI.Box(new Rect(10f, 240f, num * 0.25f - 30f, 20f), "Water : " + Mathf.Round(creature.Water * 10f) / 10f);
						creature.Water = GUI.HorizontalSlider(new Rect(10f, 260f, num * 0.25f - 30f, 20f), creature.Water, 0f, 100f);
						GUI.Box(new Rect(10f, 280f, num * 0.25f - 30f, 20f), "Stamina : " + Mathf.Round(creature.Stamina * 10f) / 10f);
						creature.Stamina = GUI.HorizontalSlider(new Rect(10f, 300f, num * 0.25f - 30f, 20f), creature.Stamina, 0f, 100f);
						GUI.Box(new Rect(10f, 320f, num * 0.25f - 30f, 20f), "Damages X" + Mathf.Round(creature.DamageMultiplier * 100f) / 100f);
						creature.DamageMultiplier = GUI.HorizontalSlider(new Rect(10f, 340f, num * 0.25f - 30f, 20f), creature.DamageMultiplier, 1f, 10f);
						GUI.Box(new Rect(10f, 360f, num * 0.25f - 30f, 20f), "Armor X" + Mathf.Round(creature.ArmorMultiplier * 100f) / 100f);
						creature.ArmorMultiplier = GUI.HorizontalSlider(new Rect(10f, 380f, num * 0.25f - 30f, 20f), creature.ArmorMultiplier, 1f, 10f);
						GUI.EndScrollView();
					}
				}
				else
				{
					GUI.Box(new Rect(0f, 50f, num * 0.25f, num2 * 0.75f - 50f), "None", gUIStyle);
				}
				GUI.color = Color.yellow;
				if (addCreatureTab == -2)
				{
					if (GUI.Button(new Rect(0f, num2 * 0.75f, num * 0.25f, 25f), ""))
					{
						addCreatureTab = -1;
					}
					GUI.Box(new Rect(0f, num2 * 0.75f, num / 4f, num2 / 4f), "Add a new creature", gUIStyle);
				}
				else
				{
					if (addCreatureTab != -1)
					{
						break;
					}
					if (GUI.Button(new Rect(num - 25f, 50f, 25f, 25f), "X"))
					{
						addCreatureTab = -2;
					}
					GUI.Box(new Rect(0f, num2 * 0.75f, num / 4f, num2 / 4f), "Spawn Settings", gUIStyle);
					GUI.color = Color.white;
					scroll2 = GUI.BeginScrollView(new Rect(0f, num2 * 0.75f + 40f, num * 0.25f, num2 * 0.25f - 40f), scroll2, new Rect(0f, 0f, 0f, 130f), alwaysShowHorizontal: false, alwaysShowVertical: true);
					GUI.Box(new Rect(10f, 0f, num * 0.25f - 30f, 25f), "");
					spawnAI = GUI.Toggle(new Rect(18f, 0f, 120f, 25f), spawnAI, " Spawn with AI ");
					GUI.Box(new Rect(10f, 30f, num * 0.25f - 30f, 25f), "");
					rndSkin = GUI.Toggle(new Rect(18f, 30f, 100f, 25f), rndSkin, " Random skin");
					GUI.Box(new Rect(10f, 60f, num * 0.25f - 30f, 25f), "");
					rndSize = GUI.Toggle(new Rect(18f, 60f, 100f, 25f), rndSize, " Random size");
					if (rndSize && GUI.Button(new Rect(130f, 60f, num * 0.25f - 150f, 25f), "Span : " + rndSizeSpan))
					{
						if (rndSizeSpan < 5)
						{
							rndSizeSpan++;
						}
						else
						{
							rndSizeSpan = 1;
						}
					}
					GUI.Box(new Rect(10f, 90f, num * 0.25f - 30f, 25f), "");
					rndSetting = GUI.Toggle(new Rect(18f, 90f, num * 0.25f - 30f, 25f), rndSetting, " Random status settings");
					GUI.EndScrollView();
					GUI.Box(new Rect(num / 4f, 50f, num * 0.75f, num2 - 50f), "Select a specie. " + CollectionList.Count + " creature(s) available.", gUIStyle);
					for (int j = 0; j < CollectionList.Count; j++)
					{
						int num6 = (int)num2 / 36;
						int num7 = j / num6;
						int num8 = j - num6 * num7;
						if (CollectionList[j].GetComponent<Creature>().Herbivorous)
						{
							GUI.color = Color.green;
						}
						else if (CollectionList[j].GetComponent<Creature>().CanFly)
						{
							GUI.color = Color.yellow;
						}
						else if (CollectionList[j].GetComponent<Creature>().CanSwim)
						{
							GUI.color = Color.cyan;
						}
						else
						{
							GUI.color = new Color(1f, 0.6f, 0f);
						}
						if (GUI.Button(new Rect(num / 4f + 15f + (float)(200 * num7), 100 + 30 * num8, 180f, 25f), CollectionList[j].name))
						{
							GameObject gameObject = UnityEngine.Object.Instantiate(CollectionList[j], base.transform.position + base.transform.forward * 10f, Quaternion.identity);
							Creature component2 = gameObject.GetComponent<Creature>();
							if (!spawnAI)
							{
								CameraMode = 1;
							}
							component2.UseAI = spawnAI;
							if (rndSkin)
							{
								component2.SetMaterials(UnityEngine.Random.Range(0, 3), UnityEngine.Random.Range(0, 16));
							}
							if (rndSize)
							{
								component2.SetScale(0.5f + UnityEngine.Random.Range((float)rndSizeSpan / -10f, (float)rndSizeSpan / 10f));
							}
							else
							{
								component2.SetScale(0.5f);
							}
							if (rndSetting)
							{
								component2.Health = 100f;
								component2.Stamina = UnityEngine.Random.Range(0, 100);
								component2.Food = UnityEngine.Random.Range(0, 100);
								component2.Water = UnityEngine.Random.Range(0, 100);
							}
							gameObject.name = CollectionList[j].name;
							creaturesList.Add(gameObject.gameObject);
							selected = creaturesList.IndexOf(gameObject.gameObject);
						}
					}
					GUI.color = Color.white;
				}
				break;
			case 2:
			{
				GUI.Box(new Rect(0f, 50f, num, num2 - 50f), "Options", gUIStyle);
				GUI.Box(new Rect(num / 2f - 225f, num2 / 2f - 110f, 150f, 220f), "Screen", gUIStyle);
				bool fullScreen = Screen.fullScreen;
				fullScreen = GUI.Toggle(new Rect(num / 2f - 220f, num2 / 2f - 80f, 140f, 20f), fullScreen, " Fullscreen");
				if (fullScreen != Screen.fullScreen)
				{
					Screen.fullScreen = !Screen.fullScreen;
				}
				ShowFPS = GUI.Toggle(new Rect(num / 2f - 220f, num2 / 2f - 40f, 140f, 20f), ShowFPS, " Show Fps");
				ShowGUI = GUI.Toggle(new Rect(num / 2f - 220f, num2 / 2f, 140f, 20f), ShowGUI, " Show GUI");
				GUI.Box(new Rect(num / 2f - 75f, num2 / 2f - 110f, 150f, 220f), "Controls", gUIStyle);
				InvertYAxis = GUI.Toggle(new Rect(num / 2f - 70f, num2 / 2f - 80f, 140f, 20f), InvertYAxis, " Invert Y Axe");
				GUI.Label(new Rect(num / 2f - 70f, num2 / 2f - 40f, 140f, 20f), "Sensivity");
				sensivity = GUI.HorizontalSlider(new Rect(num / 2f - 70f, num2 / 2f, 140f, 20f), sensivity, 0.1f, 10f);
				GUI.Box(new Rect(num / 2f + 75f, num2 / 2f - 110f, 150f, 220f), "Creatures", gUIStyle);
				UseIK = GUI.Toggle(new Rect(num / 2f + 80f, num2 / 2f - 80f, 140f, 20f), UseIK, " Use IK");
				UseRaycast = GUI.Toggle(new Rect(num / 2f + 80f, num2 / 2f - 40f, 140f, 20f), UseRaycast, " Use Raycast");
				RealtimeGame = GUI.Toggle(new Rect(num / 2f + 80f, num2 / 2f, 140f, 20f), RealtimeGame, " Realtime Game");
				break;
			}
			case 3:
				GUI.Box(new Rect(0f, 50f, num, num2 - 50f), "Controls", gUIStyle);
				GUI.DrawTexture(new Rect(0f, 50f, num, num2 - 50f), helpscreen);
				break;
			}
		}
		else
		{
			Cursor.visible = false;
		}
		if ((bool)creature && ShowGUI && CameraMode == 1)
		{
			Rect texCoords2 = new Rect(0f, 0.5f, 0.5f, 0.5f);
			Rect texCoords3 = new Rect(0.5f, 0.5f, 0.5f, 0.5f);
			Rect texCoords4 = new Rect(0.5f, 0f, 0.5f, 0.5f);
			Rect texCoords5 = new Rect(0f, 0f, 0.5f, 0.5f);
			Rect texCoords6 = new Rect(0f, 0f, 0.1f, 0.1f);
			GUI.color = Color.white;
			GUI.DrawTextureWithTexCoords(new Rect(num / 4f, num2 / 1.1f, num / 48f, num / 48f), icons, texCoords2, alphaBlend: true);
			GUI.DrawTextureWithTexCoords(new Rect(num / 2f, num2 / 1.1f, num / 48f, num / 48f), icons, texCoords3, alphaBlend: true);
			GUI.DrawTextureWithTexCoords(new Rect(num / 2f, num2 / 1.05f, num / 48f, num / 48f), icons, texCoords4, alphaBlend: true);
			GUI.DrawTextureWithTexCoords(new Rect(num / 4f, num2 / 1.05f, num / 48f, num / 48f), icons, texCoords5, alphaBlend: true);
			GUI.color = Color.black;
			GUI.DrawTextureWithTexCoords(new Rect(num / 3.5f, num2 / 1.09f, num * 0.002f * 100f, num2 / 100f), icons, texCoords6, alphaBlend: false);
			GUI.DrawTextureWithTexCoords(new Rect(num / 1.85f, num2 / 1.09f, num * 0.002f * 100f, num2 / 100f), icons, texCoords6, alphaBlend: false);
			GUI.DrawTextureWithTexCoords(new Rect(num / 1.85f, num2 / 1.04f, num * 0.002f * 100f, num2 / 100f), icons, texCoords6, alphaBlend: false);
			GUI.DrawTextureWithTexCoords(new Rect(num / 3.5f, num2 / 1.04f, num * 0.002f * 100f, num2 / 100f), icons, texCoords6, alphaBlend: false);
			if (((creature.Food == 0f) | (creature.Stamina == 0f) | (creature.Water == 0f)) && creature.loop <= 25)
			{
				GUI.color = Color.red;
			}
			else
			{
				GUI.color = Color.green;
			}
			GUI.DrawTextureWithTexCoords(new Rect(num / 3.5f, num2 / 1.09f, num * 0.002f * creature.Health, num2 / 100f), icons, texCoords6, alphaBlend: false);
			if (creature.Food < 25f && creature.loop <= 25)
			{
				GUI.color = Color.red;
			}
			else
			{
				GUI.color = Color.yellow;
			}
			GUI.DrawTextureWithTexCoords(new Rect(num / 1.85f, num2 / 1.09f, num * 0.002f * creature.Food, num2 / 100f), icons, texCoords6, alphaBlend: false);
			if (creature.Water < 25f && creature.loop <= 25)
			{
				GUI.color = Color.red;
			}
			else
			{
				GUI.color = Color.cyan;
			}
			GUI.DrawTextureWithTexCoords(new Rect(num / 1.85f, num2 / 1.04f, num * 0.002f * creature.Water, num2 / 100f), icons, texCoords6, alphaBlend: false);
			if (creature.Stamina < 25f && creature.loop <= 25)
			{
				GUI.color = Color.red;
			}
			else
			{
				GUI.color = Color.gray;
			}
			GUI.DrawTextureWithTexCoords(new Rect(num / 3.5f, num2 / 1.04f, num * 0.002f * creature.Stamina, num2 / 100f), icons, texCoords6, alphaBlend: false);
		}
		GUI.color = Color.white;
		if (ShowFPS)
		{
			GUI.Label(new Rect(num - 60f, 1f, 55f, 20f), "Fps : " + fps);
		}
		if (message == 0)
		{
			return;
		}
		count++;
		if (message == 1)
		{
			GUI.Box(new Rect(num / 2f - 120f, num2 / 2f, 240f, 25f), "Nothing to eat or drink...", gUIStyle);
		}
		else if (message == 2)
		{
			GUI.color = Color.yellow;
			GUI.Box(new Rect(num / 2f - 140f, num2 / 2f, 280f, 25f), "AI/IK Script Extension Asset Required", gUIStyle);
			GUI.color = Color.white;
			if (GUI.Button(new Rect(num / 2f - 140f, num2 / 2f + 25f, 280f, 25f), "Get it : www.assetstore.unity3d.com"))
			{
				Application.OpenURL("https://assetstore.unity.com/packages/3d/characters/animals/jp-script-extension-94813");
			}
		}
		if (count > 512)
		{
			count = 0;
			message = 0;
		}
	}
}
public class AmmoLP : Creature
{
	public Transform Root;

	public Transform Body;

	public Transform Tentacles;

	public Transform Right0;

	public Transform Right1;

	public Transform Right2;

	public Transform Right3;

	public Transform Right4;

	public Transform Right5;

	public Transform Right6;

	public Transform Right7;

	public Transform Right8;

	public Transform Left0;

	public Transform Left1;

	public Transform Left2;

	public Transform Left3;

	public Transform Left4;

	public Transform Left5;

	public Transform Left6;

	public Transform Left7;

	public Transform Left8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Ammo1;

	public AudioClip Ammo2;

	public AudioClip Ammo3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Ammo1;
			break;
		case 1:
			pain = Ammo2;
			break;
		case 2:
			pain = Ammo3;
			break;
		}
		ManageCollision(col, 0f, 0f, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Smallsplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Smallstep, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			if (num == 0)
			{
				source[0].PlayOneShot(Ammo1, 0.1f);
			}
			else
			{
				source[0].PlayOneShot(Ammo2, 0.1f);
			}
			lastframe = currframe;
			break;
		}
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[0].PlayOneShot(Ammo3, 0.1f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		Vector3 vector = -Root.up.normalized;
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 0, 5);
			if (behavior.EndsWith("Hunt") | behavior.EndsWith("Food") | behavior.Equals("Battle"))
			{
				OnInvert = true;
			}
			else
			{
				OnInvert = false;
			}
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 0, 5);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f && !OnAnm.IsName("Ammo|ToHide") && !OnAnm.IsName("Ammo|ToHide-"))
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, normAng, Ang_T);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * (OnInvert ? (-90f) : 90f), Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(OnInvert ? vector : (-vector), 25f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(OnInvert ? (-vector) : vector, 25f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(OnInvert ? (-Head.right.normalized) : Head.right.normalized, 25f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(OnInvert ? Head.right.normalized : (-Head.right.normalized), 25f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(OnInvert ? (-vector) : vector, 50f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			anm.SetBool("OnGround", value: false);
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			anm.SetBool("OnGround", value: false);
			OnJump = true;
			body.drag = 0.5f;
			body.angularDrag = 0.5f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Ammo|Die") | OnAnm.IsName("Ammo|DieGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Ammo|Swim"))
		{
			PlaySound("Swim", 5);
		}
		else if (OnAnm.IsName("Ammo|SwimFast"))
		{
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Ammo|Swim-"))
		{
			PlaySound("Swim", 5);
		}
		else if (OnAnm.IsName("Ammo|Atk"))
		{
			OnAttack = true;
			PlaySound("Atk", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Ammo|IdleC"))
		{
			if (IsInWater && (double)OnAnm.normalizedTime < 0.4)
			{
				PlaySound("Flush", 2);
				Move(OnInvert ? (-vector) : vector, 60f);
			}
			PlaySound("Atk", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Ammo|OnGround"))
		{
			OnReset = true;
			Move(base.transform.forward, 40f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Ammo|Eat"))
		{
			PlaySound("Atk", 1);
		}
		else if (OnAnm.IsName("Ammo|ToHide") | OnAnm.IsName("Ammo|ToHide-"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Ammo|Die-"))
		{
			PlaySound("Atk", 1);
			IsDead = false;
		}
		RotateBone(IkType.None, 60f, 30f, CanMoveHead: false);
		if (OnInvert)
		{
			spineY *= -1f;
		}
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.RotateAround(base.transform.position, Vector3.up, reverse = Mathf.Lerp(reverse, OnInvert ? 180f : 0f, Ang_T));
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), roll * 2f, 0f);
			Body.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tentacles.rotation *= Quaternion.Euler(spineY * 4f, 0f, (0f - spineX) * 2f);
			Right0.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right1.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right2.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right3.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right4.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right5.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right6.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right7.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right8.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Left0.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left1.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left2.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left3.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left4.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left5.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left6.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left7.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left8.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			GetGroundPos(IkType.None);
		}
	}
}
public class AnomLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip MedSplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(MedSplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Flush":
			source[1].pitch = UnityEngine.Random.Range(1.25f, 1.5f);
			source[1].PlayOneShot(Waterflush, 0.25f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.25f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Neck0.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 30f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 30f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 30f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 30f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 60f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 1f;
			body.angularDrag = 1f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Anom|Die") | OnAnm.IsName("Anom|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Anom|Swim"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|SwimStrafe-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|SwimStrafe+"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|SwimInpulse"))
		{
			if (IsInWater && (double)OnAnm.normalizedTime < 0.4)
			{
				PlaySound("Flush", 2);
				Move(base.transform.forward, 80f);
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|Atk") | OnAnm.IsName("Anom|SwimAtk"))
		{
			if (OnAnm.IsName("Anom|SwimAtk"))
			{
				PlaySound("Flush", 2);
				PlaySound("Bite", 7);
				OnAttack = true;
			}
			else
			{
				PlaySound("Flush", 1);
				PlaySound("Bite", 10);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Anom|OnGround"))
		{
			Move(base.transform.forward, 25f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Anom|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Anom|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), roll * 6f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class ArcheLP : Creature
{
	public Transform Root;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Medsplash;

	public AudioClip Arche1;

	public AudioClip Arche2;

	public AudioClip Arche3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Arche1;
			break;
		case 1:
			pain = Arche2;
			break;
		case 2:
			pain = Arche3;
			break;
		}
		ManageCollision(col, 0f, 0f, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Medsplash, 0.25f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.25f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[1].PlayOneShot(Bite, 0.1f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
			if (num == 0)
			{
				source[0].PlayOneShot(Arche1, 0.1f);
			}
			else
			{
				source[0].PlayOneShot(Arche2, 0.1f);
			}
			lastframe = currframe;
			break;
		}
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
			source[0].PlayOneShot(Arche3, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		Vector3 vector = -Root.up;
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 4, 0, 3, 0, 4);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 4, 0, 3, 0, 4);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f && !OnAnm.IsName("Arche|ToHide") && !OnAnm.IsName("Arche|ToHide-"))
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 25f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 25f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 25f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 25f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 50f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 1f;
			body.angularDrag = 1f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Arche|Die") | OnAnm.IsName("Arche|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Arche|Swim") | OnAnm.IsName("Arche|SwimGrowl") | OnAnm.IsName("Arche|SwimGlide"))
		{
			if (OnAnm.IsName("Arche|SwimGrowl"))
			{
				PlaySound("Growl", 2);
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Arche|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Arche|SwimFast") | OnAnm.IsName("Arche|SwimFastGrowl"))
		{
			if (OnAnm.IsName("Arche|SwimFastGrowl"))
			{
				PlaySound("Growl", 2);
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Arche|SwimFastAtk") | OnAnm.IsName("Arche|SwimAtk"))
		{
			if (OnAnm.IsName("Arche|SwimFastAtk"))
			{
				PlaySound("Growl", 2);
				PlaySound("Bite", 10);
				OnAttack = true;
			}
			else
			{
				PlaySound("Growl", 2);
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Arche|Walk") | OnAnm.IsName("Arche|AtkOnGround") | OnAnm.IsName("Arche|IdleOnGround"))
		{
			if (!OnAnm.IsName("Arche|IdleOnGround"))
			{
				if (OnAnm.normalizedTime > 0.4f && OnAnm.normalizedTime < 0.9f)
				{
					Move(base.transform.forward, 32f);
				}
				else
				{
					Move(Vector3.zero);
				}
				if (OnAnm.IsName("Arche|AtkOnGround"))
				{
					PlaySound("Growl", 2);
					PlaySound("Bite", 10);
					OnAttack = true;
				}
				else
				{
					PlaySound("Swim", 7);
				}
			}
			else
			{
				Move(Vector3.zero);
			}
		}
		else if (OnAnm.IsName("Arche|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Arche|ToHide") | OnAnm.IsName("Arche|ToHide-"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Arche|Die-"))
		{
			PlaySound("Growl", 2);
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), roll * 3f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX * 2f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class CameLP : Creature
{
	public Transform Root;

	public Transform Body;

	public Transform Tentacles;

	public Transform Right0;

	public Transform Right1;

	public Transform Right2;

	public Transform Right3;

	public Transform Right4;

	public Transform Right5;

	public Transform Right6;

	public Transform Right7;

	public Transform Right8;

	public Transform Left0;

	public Transform Left1;

	public Transform Left2;

	public Transform Left3;

	public Transform Left4;

	public Transform Left5;

	public Transform Left6;

	public Transform Left7;

	public Transform Left8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Ammo1;

	public AudioClip Ammo2;

	public AudioClip Ammo3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Ammo1;
			break;
		case 1:
			pain = Ammo2;
			break;
		case 2:
			pain = Ammo3;
			break;
		}
		ManageCollision(col, 0f, 0f, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.5f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Bigstep, 0.5f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(0.6f, 0.75f);
			if (num == 0)
			{
				source[0].PlayOneShot(Ammo1, 0.1f);
			}
			else
			{
				source[0].PlayOneShot(Ammo2, 0.1f);
			}
			lastframe = currframe;
			break;
		}
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.6f, 0.75f);
			source[0].PlayOneShot(Ammo3, 0.1f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Root.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 0, 5);
			if (behavior.EndsWith("Hunt") | behavior.EndsWith("Food") | behavior.Equals("Battle"))
			{
				OnInvert = true;
			}
			else
			{
				OnInvert = false;
			}
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 0, 5);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f && !OnAnm.IsName("Came|ToHide") && !OnAnm.IsName("Came|ToHide-"))
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, normAng, Ang_T);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * (OnInvert ? (-90f) : 90f), Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(OnInvert ? vector : (-vector), 25f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(OnInvert ? (-vector) : vector, 25f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(OnInvert ? (-Head.right.normalized) : Head.right.normalized, 25f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(OnInvert ? Head.right.normalized : (-Head.right.normalized), 25f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(OnInvert ? (-vector) : vector, 50f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			anm.SetBool("OnGround", value: false);
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			anm.SetBool("OnGround", value: false);
			OnJump = true;
			body.drag = 0.5f;
			body.angularDrag = 0.5f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Came|Die") | OnAnm.IsName("Came|DieGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Came|Swim"))
		{
			PlaySound("Swim", 5);
		}
		else if (OnAnm.IsName("Came|SwimFast"))
		{
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Came|Swim-"))
		{
			PlaySound("Swim", 5);
		}
		else if (OnAnm.IsName("Came|Atk"))
		{
			OnAttack = true;
			PlaySound("Atk", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Came|IdleC"))
		{
			if (IsInWater && (double)OnAnm.normalizedTime < 0.4)
			{
				PlaySound("Flush", 2);
				Move(OnInvert ? (-vector) : vector, 60f);
			}
			PlaySound("Atk", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Came|OnGround"))
		{
			OnReset = true;
			Move(base.transform.forward, 40f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Came|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Atk", 1);
		}
		else if (OnAnm.IsName("Came|ToHide") | OnAnm.IsName("Came|ToHide-"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Came|Die-"))
		{
			OnInvert = false;
			PlaySound("Atk", 1);
			IsDead = false;
		}
		RotateBone(IkType.None, 60f, 30f, CanMoveHead: false);
		if (OnInvert)
		{
			spineY *= -1f;
		}
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.RotateAround(base.transform.position, Vector3.up, reverse = Mathf.Lerp(reverse, OnInvert ? 180f : 0f, Ang_T));
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), roll * 2f, 0f);
			Body.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tentacles.rotation *= Quaternion.Euler(spineY * 4f, 0f, (0f - spineX) * 2f);
			Right0.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right1.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right2.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right3.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right4.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right5.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right6.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right7.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Right8.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Left0.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left1.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left2.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left3.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left4.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left5.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left6.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left7.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			Left8.rotation *= Quaternion.Euler(spineY, 0f, 0f - spineX);
			GetGroundPos(IkType.None);
		}
	}
}
public class DunkLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Spine6;

	public Transform Spine7;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largesplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.3f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Head.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 20f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 100f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 0.75f;
			body.angularDrag = 0.75f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Dunk|Die") | OnAnm.IsName("Dunk|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Dunk|Swim"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Dunk|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Dunk|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Dunk|SwimFastAtk") | OnAnm.IsName("Dunk|SwimAtk"))
		{
			if (OnAnm.IsName("Dunk|SwimFastAtk"))
			{
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			else
			{
				PlaySound("Bite", 2);
				PlaySound("Bite", 5);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Dunk|OnGround"))
		{
			Move(base.transform.forward, 32f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Dunk|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
			PlaySound("Bite", 3);
			PlaySound("Bite", 6);
		}
		else if (OnAnm.IsName("Dunk|IdleC"))
		{
			PlaySound("Bite", 4);
			PlaySound("Bite", 6);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Dunk|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Spine0.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine4.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine5.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine6.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine7.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.transform.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.transform.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class HeliLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Spine6;

	public Transform Spine7;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Smallsplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Smallsplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Root.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 20f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 120f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 0.75f;
			body.angularDrag = 0.75f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Heli|Die") | OnAnm.IsName("Heli|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Heli|Swim"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Heli|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Heli|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Heli|SwimFastAtk") | OnAnm.IsName("Heli|SwimAtk"))
		{
			if (OnAnm.IsName("Heli|SwimFastAtk"))
			{
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			else
			{
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Heli|OnGround"))
		{
			Move(base.transform.forward, 32f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Heli|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Heli|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine5.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine6.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine7.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class IchthyLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largesplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		Vector3 vector = -Neck0.up;
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 20f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 50f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 120f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 0.5f;
			body.angularDrag = 0.5f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Ichthy|Die") | OnAnm.IsName("Ichthy|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Ichthy|Swim") | OnAnm.IsName("Ichthy|SwimGlide"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Ichthy|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Ichthy|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Ichthy|SwimFastAtk") | OnAnm.IsName("Ichthy|SwimAtk"))
		{
			if (OnAnm.IsName("Ichthy|SwimFastAtk"))
			{
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			else
			{
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Ichthy|OnGround"))
		{
			Move(base.transform.forward, 32f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Ichthy|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Ichthy|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 40f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), roll * 3f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class LeedLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Spine6;

	public Transform Spine7;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largesplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Root.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 20f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 100f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 1f;
			body.angularDrag = 1f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Leed|Die") | OnAnm.IsName("Leed|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Leed|Swim"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Leed|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Leed|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Leed|SwimFastAtk") | OnAnm.IsName("Leed|SwimAtk"))
		{
			if (OnAnm.IsName("Leed|SwimFastAtk"))
			{
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			else
			{
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Leed|OnGround"))
		{
			Move(base.transform.forward, 60f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Leed|Eat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Leed|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine5.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine6.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine7.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class MosaLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largesplash;

	public AudioClip Mosa1;

	public AudioClip Mosa2;

	public AudioClip Mosa3;

	public AudioClip Mosa4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Mosa1;
			break;
		case 1:
			pain = Mosa2;
			break;
		case 2:
			pain = Mosa3;
			break;
		case 3:
			pain = Mosa4;
			break;
		}
		ManageCollision(col, 0f, 0f, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.25f, 0.4f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Mosa1, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Mosa2, 0.5f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num3 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
			if (num3 == 0)
			{
				source[0].PlayOneShot(Mosa3, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Mosa4, 0.5f);
			}
			lastframe = currframe;
			break;
		}
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.25f);
			lastframe = currframe;
			break;
		case "Die":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.5f);
			if (num == 0)
			{
				source[0].PlayOneShot(Mosa3, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Mosa4, 0.5f);
			}
			lastframe = currframe;
			IsDead = true;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Neck0.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 150f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 0.75f;
			body.angularDrag = 0.75f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Mosa|Die") | OnAnm.IsName("Mosa|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Mosa|Swim") | OnAnm.IsName("Mosa|SwimGlide"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Mosa|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Mosa|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Mosa|SwimGrowl") | OnAnm.IsName("Mosa|SwimFastGrowl"))
		{
			if (OnAnm.IsName("Mosa|SwimFastGrowl"))
			{
				PlaySound("Atk", 2);
			}
			else
			{
				PlaySound("Growl", 2);
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Mosa|SwimFastAtk") | OnAnm.IsName("Mosa|SwimAtk"))
		{
			if (OnAnm.IsName("Mosa|SwimFastAtk"))
			{
				PlaySound("Growl", 2);
				PlaySound("Bite", 10);
				PlaySound("Atk", 11);
				OnAttack = true;
			}
			else
			{
				PlaySound("Atk", 2);
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				PlaySound("Atk", 9);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Mosa|OnGround"))
		{
			Move(base.transform.forward, 60f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Mosa|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Mosa|Die-"))
		{
			PlaySound("Atk", 2);
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class OnchoLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largesplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Neck0.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 20f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 50f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 120f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 0.75f;
			body.angularDrag = 0.75f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Oncho|Die") | OnAnm.IsName("Oncho|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Oncho|Swim") | OnAnm.IsName("Oncho|SwimGlide"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Oncho|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Oncho|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Oncho|SwimFastAtk") | OnAnm.IsName("Oncho|SwimAtk"))
		{
			if (OnAnm.IsName("Oncho|SwimFastAtk"))
			{
				PlaySound("Bite", 10);
				PlaySound("Atk", 11);
				OnAttack = true;
			}
			else
			{
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Oncho|OnGround"))
		{
			Move(base.transform.forward, 32f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Oncho|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Oncho|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 15f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class PlesioLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Neck4;

	public Transform Neck5;

	public Transform Neck6;

	public Transform Neck7;

	public Transform Neck8;

	public Transform Neck9;

	public Transform Neck10;

	public Transform Neck11;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largesplash;

	public AudioClip Plesio1;

	public AudioClip Plesio2;

	public AudioClip Plesio3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Plesio1;
			break;
		case 1:
			pain = Plesio2;
			break;
		case 2:
			pain = Plesio3;
			break;
		}
		ManageCollision(col, 0f, 0f, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Largesplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Plesio1, 0.5f);
				break;
			case 1:
				source[0].PlayOneShot(Plesio2, 0.5f);
				break;
			default:
				source[0].PlayOneShot(Plesio3, 0.5f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.25f);
			lastframe = currframe;
			break;
		case "Die":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Plesio1, 0.5f);
				break;
			case 1:
				source[0].PlayOneShot(Plesio2, 0.5f);
				break;
			default:
				source[0].PlayOneShot(Plesio3, 0.5f);
				break;
			}
			lastframe = currframe;
			IsDead = true;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Neck0.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 40f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 100f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 1f;
			body.angularDrag = 1f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Plesio|Die") | OnAnm.IsName("Plesio|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Plesio|Swim") | OnAnm.IsName("Plesio|SwimGlide"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Plesio|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Plesio|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Plesio|SwimGrowl") | OnAnm.IsName("Plesio|SwimFastGrowl"))
		{
			PlaySound("Growl", 3);
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Plesio|SwimFastAtk") | OnAnm.IsName("Plesio|SwimAtk"))
		{
			if (OnAnm.IsName("Plesio|SwimFastAtk"))
			{
				PlaySound("Growl", 3);
				PlaySound("Bite", 11);
				OnAttack = true;
			}
			else
			{
				PlaySound("Growl", 3);
				PlaySound("Bite", 12);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Plesio|OnGround"))
		{
			if (OnAnm.normalizedTime > 0.4f && OnAnm.normalizedTime < 0.9f)
			{
				Move(base.transform.forward, 60f);
			}
			else
			{
				Move(Vector3.zero);
			}
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Plesio|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Plesio|IdleC"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Plesio|Die-"))
		{
			PlaySound("Growl", 2);
			IsDead = false;
		}
		RotateBone(IkType.None, 32f, 16f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Neck0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck4.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck5.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck6.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck7.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck8.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck9.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck10.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Neck11.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class SarcoLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idlecarn;

	public AudioClip Sarco1;

	public AudioClip Sarco2;

	public AudioClip Sarco3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Sarco1;
			break;
		case 1:
			pain = Sarco2;
			break;
		case 2:
			pain = Sarco3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			source[1].PlayOneShot(Bite, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.75f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff2, 0.5f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Sarco1, 0.75f);
				break;
			case 1:
				source[0].PlayOneShot(Sarco2, 0.75f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sarco3, 0.75f);
			lastframe = currframe;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		Vector3 right = Root.right;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				if (!OnAnm.IsName("Sarco|SwimEat"))
				{
					pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				}
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-right, 20f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(right, 40f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(-Head.up.normalized, 20f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(Head.up.normalized, 20f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(right, 100f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			anm.SetBool("OnGround", value: false);
			IsOnLevitation = true;
			if (IsOnWater)
			{
				ApplyYPos();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			pitch = Mathf.Lerp(pitch, 0f, Ang_T);
		}
		else
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Sarco|Idle1A") | OnAnm.IsName("Sarco|Idle2A") | OnAnm.IsName("Sarco|Die1") | OnAnm.IsName("Sarco|Die2") | OnAnm.IsName("Sarco|SwimDie"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Sarco|Die1") | OnAnm.IsName("Sarco|Die2") | OnAnm.IsName("Sarco|SwimDie"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 1);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Sarco|Walk") | OnAnm.IsName("Sarco|WalkGrowl") | (OnAnm.IsName("Sarco|Step1") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Sarco|Step2") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Sarco|StepAtk1") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Sarco|StepAtk2") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Sarco|ToIdle1C") && (double)OnAnm.normalizedTime < 0.7))
		{
			Move(base.transform.forward, 30f);
			if (OnAnm.IsName("Sarco|WalkGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Sarco|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Sarco|StepAtk1") | OnAnm.IsName("Sarco|StepAtk2"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 4);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Sarco|Run") | OnAnm.IsName("Sarco|RunGrowl") | OnAnm.IsName("Sarco|WalkAtk"))
		{
			Move(base.transform.forward, 75f);
			if (OnAnm.IsName("Sarco|WalkAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 6);
			}
			else if (OnAnm.IsName("Sarco|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Sarco|Run"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 8);
			}
		}
		else if (OnAnm.IsName("Sarco|Step1-") | OnAnm.IsName("Sarco|Step2-") | OnAnm.IsName("Sarco|ToIdle2C") | OnAnm.IsName("Sarco|ToEatA") | OnAnm.IsName("Sarco|ToEatC"))
		{
			Move(-base.transform.forward, 20f);
			PlaySound("Step", 8);
		}
		else if (OnAnm.IsName("Sarco|Strafe1-") | OnAnm.IsName("Sarco|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Sarco|Strafe1+") | OnAnm.IsName("Sarco|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Sarco|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 4);
		}
		else if (OnAnm.IsName("Sarco|Idle1B"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Sarco|Idle1C"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Sarco|Idle2B"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Sarco|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Sarco|Die1-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Sarco|Die2-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Sarco|Swim") | OnAnm.IsName("Sarco|SwimGlide"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Sarco|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Sarco|SwimFast") | OnAnm.IsName("Sarco|SwimGrowl") | OnAnm.IsName("Sarco|SwimFastGrowl"))
		{
			if (OnAnm.IsName("Sarco|SwimFastGrowl"))
			{
				PlaySound("Atk", 2);
			}
			else if (OnAnm.IsName("Sarco|SwimGrowl"))
			{
				PlaySound("Growl", 2);
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Sarco|SwimFastAtk") | OnAnm.IsName("Sarco|SwimAtk"))
		{
			if (OnAnm.IsName("Sarco|SwimFastAtk"))
			{
				PlaySound("Atk", 2);
				PlaySound("Bite", 10);
				OnAttack = true;
			}
			else
			{
				PlaySound("Atk", 2);
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Sarco|SwimEat"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Sarco|Die1-") | OnAnm.IsName("Sarco|Die2-") | OnAnm.IsName("Sarco|SwimDie-"))
		{
			PlaySound("Atk", 2);
			IsDead = false;
		}
		RotateBone(IkType.Convex, 48f, 20f, IsOnGround);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(0f, Mathf.Clamp(pitch, -90f, 90f), 0f);
			Neck0.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Neck1.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Neck2.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Head.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Spine0.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f - spineY, 0f - spineX);
			Tail0.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail1.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail2.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail3.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail4.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail5.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail6.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail7.rotation *= Quaternion.Euler(0f, spineY, spineX);
			Tail8.rotation *= Quaternion.Euler(0f, spineY, spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.Convex, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand);
		}
	}
}
public class XenaLP : Creature
{
	public Transform Root;

	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Spine6;

	public Transform Spine7;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Slip;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Smallsplash;

	private void OnCollisionStay(Collision col)
	{
		ManageCollision(col, 0f, 0f, source, Bite, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Swim":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			if (IsOnWater && IsOnGround)
			{
				source[1].PlayOneShot(Smallsplash, 0.1f);
			}
			else if (IsOnGround && !IsInWater)
			{
				source[1].PlayOneShot(Slip, 0.1f);
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Waterflush, 0.1f);
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(0.25f, 0.5f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnJump = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnReset = false;
		Vector3 vector = -Root.up;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 0, 0, 3);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 0, 0, 3);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 1f;
			body.angularDrag = 1f;
			if (Health != 0f)
			{
				anm.SetBool("OnGround", value: false);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
				if (anm.GetInteger("Move").Equals(-1))
				{
					Move(-vector, 30f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(vector, 30f);
				}
				else if (anm.GetInteger("Move").Equals(10))
				{
					Move(Head.right.normalized, 30f);
				}
				else if (anm.GetInteger("Move").Equals(-10))
				{
					Move(-Head.right.normalized, 30f);
				}
				else if (!anm.GetInteger("Move").Equals(0))
				{
					Move(vector, 60f);
				}
				else
				{
					Move(Vector3.zero);
				}
				IsOnLevitation = true;
			}
			if (IsOnWater)
			{
				ApplyGravity();
			}
		}
		else if (IsOnGround)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			anm.SetBool("OnGround", value: true);
			ApplyYPos();
		}
		else
		{
			if (Health != 0f)
			{
				Move(Vector3.zero);
				pitch = Mathf.Lerp(pitch, anm.GetFloat("Pitch") * 90f, Ang_T);
			}
			OnJump = true;
			body.drag = 0.5f;
			body.angularDrag = 0.5f;
			ApplyGravity();
		}
		if (OnAnm.IsName("Xena|Die") | OnAnm.IsName("Xena|DieOnGround"))
		{
			OnReset = true;
			if (!IsDead)
			{
				PlaySound("Die", 2);
			}
		}
		else if (OnAnm.IsName("Xena|Swim"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Xena|Swim-"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Xena|SwimFast"))
		{
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Xena|SwimFastAtk") | OnAnm.IsName("Xena|SwimAtk"))
		{
			if (OnAnm.IsName("Xena|SwimFastAtk"))
			{
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			else
			{
				PlaySound("Bite", 3);
				PlaySound("Bite", 8);
				OnAttack = true;
			}
			PlaySound("Swim", (int)currframe);
		}
		else if (OnAnm.IsName("Xena|OnGround"))
		{
			Move(base.transform.forward, 15f);
			PlaySound("Swim", 5);
			PlaySound("Swim", 10);
		}
		else if (OnAnm.IsName("Xena|Eat"))
		{
			IsConstrained = true;
			PlaySound("Food", 2);
		}
		else if (OnAnm.IsName("Xena|Die-"))
		{
			IsDead = false;
		}
		RotateBone(IkType.None, 30f, 20f, CanMoveHead: false);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(Mathf.Clamp(0f - pitch, -90f, 90f), 0f, 0f);
			Spine0.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine5.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine6.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Spine7.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Head.rotation *= Quaternion.Euler(spineY, 0f, spineX);
			Tail0.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f - spineY, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.None);
		}
	}
}
public class ArgeLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Neck4;

	public Transform Neck5;

	public Transform Neck6;

	public Transform Neck7;

	public Transform Neck8;

	public Transform Neck9;

	public Transform Neck10;

	public Transform Neck11;

	public Transform Neck12;

	public Transform Neck13;

	public Transform Neck14;

	public Transform Neck15;

	public Transform Neck16;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Chew;

	public AudioClip Arge1;

	public AudioClip Arge2;

	public AudioClip Arge3;

	public AudioClip Arge4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Arge1;
			break;
		case 1:
			pain = Arge2;
			break;
		case 2:
			pain = Arge3;
			break;
		case 3:
			pain = Arge4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Largestep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.75f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(0.7f, 0.8f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Arge1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Arge2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Arge3, 1f);
				break;
			case 3:
				source[0].PlayOneShot(Arge4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 4, 0, 0, 2, 3, 5);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 4, 0, 0, 2, 3, 5, 4);
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Arge|IdleA") | OnAnm.IsName("Arge|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Arge|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 3);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Arge|Walk") | OnAnm.IsName("Arge|WalkGrowl"))
		{
			Move(base.transform.forward, 12f);
			if (OnAnm.IsName("Arge|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Arge|Run") | OnAnm.IsName("Arge|RunGrowl"))
		{
			Move(base.transform.forward, 30f);
			if (OnAnm.IsName("Arge|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Arge|Walk-") | OnAnm.IsName("Arge|WalkGrowl-"))
		{
			Move(-base.transform.forward, 11f);
			if (OnAnm.IsName("Arge|WalkGrowl-"))
			{
				PlaySound("Growl", 4);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Arge|Strafe-"))
		{
			Move(base.transform.right, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Arge|Strafe+"))
		{
			Move(-base.transform.right, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Arge|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Arge|EatB"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Arge|EatC"))
		{
			OnReset = true;
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Arge|ToSit"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Arge|ToSit-"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Arge|SitIdle"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Arge|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Arge|SitGrowl"))
		{
			OnReset = true;
			PlaySound("Growl", 2);
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Arge|IdleB"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Arge|RiseIdle"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Arge|RiseGrowl"))
		{
			OnReset = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Arge|ToRise"))
		{
			OnReset = true;
			PlaySound("Growl", 5);
		}
		else if (OnAnm.IsName("Arge|ToRise-"))
		{
			OnReset = true;
			PlaySound("Growl", 1);
			PlaySound("Hit", 4);
		}
		else if (OnAnm.IsName("Arge|Die-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 40f, 0f, CanMoveHead: true, 0.1f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck1.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck2.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck3.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck4.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck5.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck6.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck7.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck8.rotation *= Quaternion.Euler(headY, 0f, headX);
			Neck9.rotation *= Quaternion.Euler(headY, 0f, headX);
			Neck10.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck11.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck12.rotation *= Quaternion.Euler(headY, y, 0f);
			Neck13.rotation *= Quaternion.Euler(headY, y, 0f);
			Neck14.rotation *= Quaternion.Euler(headY, y, 0f);
			Neck15.rotation *= Quaternion.Euler(headY, y, 0f);
			Neck16.rotation *= Quaternion.Euler(headY, y, 0f);
			Head.rotation *= Quaternion.Euler(headY, y, 0f);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.1f * size);
		}
	}
}
public class BaryLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Largestep;

	public AudioClip Idlecarn;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Sniff1;

	public AudioClip Bary1;

	public AudioClip Bary2;

	public AudioClip Bary3;

	public AudioClip Bary4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Bary1;
			break;
		case 1:
			pain = Bary2;
			break;
		case 2:
			pain = Bary3;
			break;
		case 3:
			pain = Bary4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Bigstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[1].PlayOneShot(Bite, 2f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.75f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Bary3, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Bary4, 0.6f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Bary1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Bary2, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Bary|Idle1A") | OnAnm.IsName("Bary|Idle2A") | OnAnm.IsName("Bary|Die1") | OnAnm.IsName("Bary|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Bary|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Bary|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.5 && (OnAnm.IsName("Bary|Step1+") | OnAnm.IsName("Bary|Step2+") | OnAnm.IsName("Bary|ToIdle1C") | OnAnm.IsName("Bary|ToIdle2B") | OnAnm.IsName("Bary|ToIdle2D") | OnAnm.IsName("Bary|ToEatA") | OnAnm.IsName("Bary|ToEatC") | OnAnm.IsName("Bary|StepAtk1") | OnAnm.IsName("Bary|StepAtk2")))
		{
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Bary|Walk") | OnAnm.IsName("Bary|WalkGrowl") | ((double)OnAnm.normalizedTime < 0.5 && (OnAnm.IsName("Bary|Step1+") | OnAnm.IsName("Bary|Step2+") | OnAnm.IsName("Bary|ToIdle2B") | OnAnm.IsName("Bary|ToIdle1C") | OnAnm.IsName("Bary|ToIdle2D") | OnAnm.IsName("Bary|ToEatA") | OnAnm.IsName("Bary|ToEatC"))))
		{
			Move(base.transform.forward, 50f);
			if (OnAnm.IsName("Bary|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Bary|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 8);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Bary|Run") | OnAnm.IsName("Bary|RunGrowl") | OnAnm.IsName("Bary|WalkAtk1") | OnAnm.IsName("Bary|WalkAtk2") | ((double)OnAnm.normalizedTime < 0.6 && (OnAnm.IsName("Bary|StepAtk1") | OnAnm.IsName("Bary|StepAtk2"))))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 5f, 0.05f), -20f, 20f);
			Move(base.transform.forward, 128f);
			if (OnAnm.IsName("Bary|RunGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Bary|Run"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Bary|StepAtk1") | OnAnm.IsName("Bary|StepAtk2"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 5);
			}
			else
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Step", 6);
				PlaySound("Bite", 9);
				PlaySound("Step", 13);
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.4 && (double)OnAnm.normalizedTime < 0.8 && (OnAnm.IsName("Bary|Step1-") | OnAnm.IsName("Bary|Step2-") | OnAnm.IsName("Bary|ToSleep2")))
		{
			Move(-base.transform.forward, 50f);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Bary|Strafe1-") | OnAnm.IsName("Bary|Strafe2+"))
		{
			Move(base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Bary|Strafe1+") | OnAnm.IsName("Bary|Strafe2-"))
		{
			Move(-base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Bary|IdleAtk1") | OnAnm.IsName("Bary|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("Atk", 1);
			PlaySound("Step", 3);
			PlaySound("Bite", 6);
		}
		else if (OnAnm.IsName("Bary|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 4);
			PlaySound("Bite", 5);
		}
		else if (OnAnm.IsName("Bary|EatB") | OnAnm.IsName("Bary|EatC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Bary|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Bary|ToSleep1") | OnAnm.IsName("Bary|ToSleep2"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Bary|ToIdle2A"))
		{
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Bary|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Bary|Idle1C"))
		{
			PlaySound("Sniff", 4);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 10);
		}
		else if (OnAnm.IsName("Bary|Idle2B"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 6);
			PlaySound("Bite", 8);
		}
		else if (OnAnm.IsName("Bary|Idle2C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Bary|Idle2D"))
		{
			OnReset = true;
			PlaySound("Atk", 2);
		}
		else if (OnAnm.IsName("Bary|Die1-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Bary|Die2-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.LgBiped, 65f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Spine0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Spine2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck1.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Head.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Tail2.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail3.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail4.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail5.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail6.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.LgBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class CarnLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Largestep;

	public AudioClip Idlecarn;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Sniff1;

	public AudioClip Carn1;

	public AudioClip Carn2;

	public AudioClip Carn3;

	public AudioClip Carn4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Carn1;
			break;
		case 1:
			pain = Carn3;
			break;
		case 2:
			pain = Carn4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Bigstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[1].PlayOneShot(Bite, 2f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.75f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Carn3, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Carn4, 0.5f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Carn1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Carn2, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Carn|Idle1A") | OnAnm.IsName("Carn|Idle2A") | OnAnm.IsName("Carn|Die1") | OnAnm.IsName("Carn|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Carn|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Carn|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.5 && (OnAnm.IsName("Carn|Step1+") | OnAnm.IsName("Carn|Step2+") | OnAnm.IsName("Carn|ToIdle1C") | OnAnm.IsName("Carn|ToIdle2B") | OnAnm.IsName("Carn|ToIdle2D") | OnAnm.IsName("Carn|ToEatA") | OnAnm.IsName("Carn|ToEatC") | OnAnm.IsName("Carn|StepAtk1") | OnAnm.IsName("Carn|StepAtk2")))
		{
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Carn|Walk") | OnAnm.IsName("Carn|WalkGrowl") | ((double)OnAnm.normalizedTime < 0.5 && (OnAnm.IsName("Carn|Step1+") | OnAnm.IsName("Carn|Step2+") | OnAnm.IsName("Carn|ToIdle2B") | OnAnm.IsName("Carn|ToIdle1C") | OnAnm.IsName("Carn|ToIdle2D") | OnAnm.IsName("Carn|ToEatA") | OnAnm.IsName("Carn|ToEatC"))))
		{
			Move(base.transform.forward, 50f);
			if (OnAnm.IsName("Carn|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Carn|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 8);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Carn|Run") | OnAnm.IsName("Carn|RunGrowl") | OnAnm.IsName("Carn|WalkAtk1") | OnAnm.IsName("Carn|WalkAtk2") | ((double)OnAnm.normalizedTime < 0.6 && (OnAnm.IsName("Carn|StepAtk1") | OnAnm.IsName("Carn|StepAtk2"))))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 5f, 0.05f), -20f, 20f);
			Move(base.transform.forward, 128f);
			if (OnAnm.IsName("Carn|RunGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Carn|Run"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Carn|StepAtk1") | OnAnm.IsName("Carn|StepAtk2"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 5);
			}
			else
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Step", 6);
				PlaySound("Bite", 9);
				PlaySound("Step", 13);
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.4 && (double)OnAnm.normalizedTime < 0.8 && (OnAnm.IsName("Carn|Step1-") | OnAnm.IsName("Carn|Step2-") | OnAnm.IsName("Carn|ToSleep2")))
		{
			Move(-base.transform.forward, 50f);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Carn|Strafe1-") | OnAnm.IsName("Carn|Strafe2+"))
		{
			Move(base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Carn|Strafe1+") | OnAnm.IsName("Carn|Strafe2-"))
		{
			Move(-base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Carn|IdleAtk1") | OnAnm.IsName("Carn|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("Atk", 1);
			PlaySound("Step", 3);
			PlaySound("Bite", 6);
		}
		else if (OnAnm.IsName("Carn|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 4);
			PlaySound("Bite", 5);
		}
		else if (OnAnm.IsName("Carn|EatB") | OnAnm.IsName("Carn|EatC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Carn|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Carn|ToSleep1") | OnAnm.IsName("Carn|ToSleep2"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Carn|ToIdle2A"))
		{
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Carn|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Carn|Idle1C"))
		{
			PlaySound("Sniff", 4);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 10);
		}
		else if (OnAnm.IsName("Carn|Idle2B"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 6);
			PlaySound("Bite", 8);
		}
		else if (OnAnm.IsName("Carn|Idle2C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Carn|Idle2D"))
		{
			OnReset = true;
			PlaySound("Atk", 2);
		}
		else if (OnAnm.IsName("Carn|Die1-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Carn|Die2-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.LgBiped, 65f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Spine0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Spine2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck1.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Head.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Tail2.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail3.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail4.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail5.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail6.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.LgBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class DimoLP : Creature
{
	public Transform Root;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Right_Wing0;

	public Transform Left_Wing0;

	public Transform Right_Wing1;

	public Transform Left_Wing1;

	public Transform Right_Hand;

	public Transform Left_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Idlecarn;

	public AudioClip Bite;

	public AudioClip Sniff2;

	public AudioClip Swallow;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Dimo1;

	public AudioClip Dimo2;

	public AudioClip Dimo3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Dimo1;
			break;
		case 1:
			pain = Dimo2;
			break;
		case 2:
			pain = Dimo3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else
			{
				source[1].PlayOneShot(Sniff2, UnityEngine.Random.Range(0.1f, 0.2f));
			}
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Medsplash : Medstep, 0.5f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.25f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.75f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Dimo1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Dimo2, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			if (num == 0)
			{
				source[0].PlayOneShot(Dimo1, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Dimo3, 0.5f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		_ = -Root.right;
		anm.SetBool("OnGround", IsOnGround);
		OnReset = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnJump = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
			anm.SetInteger("Move", 1);
		}
		else if (IsOnGround)
		{
			roll = Mathf.Lerp(roll, 0f, 0.1f);
			pitch = Mathf.Lerp(pitch, 0f, 0.1f);
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
		}
		else if (Health == 0f)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyGravity(0.5f);
		}
		else
		{
			body.drag = 1f;
			body.angularDrag = 1f;
		}
		if (OnAnm.IsName("Dimo|IdleA") | OnAnm.IsName("Dimo|Die1") | OnAnm.IsName("Dimo|Die2") | OnAnm.IsName("Dimo|Fall"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Dimo|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 1);
					PlaySound("Die", 11);
				}
			}
			else if (OnAnm.IsName("Dimo|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Die", 0);
				}
			}
			else if (OnAnm.IsName("Dimo|Fall"))
			{
				OnReset = true;
				IsOnLevitation = true;
				if (IsInWater)
				{
					anm.SetBool("OnGround", value: true);
				}
				if (OnAnm.normalizedTime < 0.1f)
				{
					source[0].PlayOneShot(Dimo2, 1f);
				}
			}
		}
		else if (OnAnm.IsName("Dimo|Walk"))
		{
			Move(base.transform.forward, 10f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Dimo|Run") | OnAnm.IsName("Dimo|FlightToRun") | OnAnm.IsName("Dimo|RunToFlight"))
		{
			IsOnLevitation = true;
			Move(base.transform.forward, 40f);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Dimo|Walk-"))
		{
			Move(-base.transform.forward, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Dimo|Strafe+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Dimo|Strafe-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Dimo|Takeoff"))
		{
			if ((double)OnAnm.normalizedTime > 0.5)
			{
				IsOnLevitation = true;
				OnJump = true;
				Move(Vector3.up, 50f);
			}
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Dimo|Flight") | OnAnm.IsName("Dimo|FlightGrowl") | OnAnm.IsName("Dimo|Glide") | OnAnm.IsName("Dimo|GlideGrowl"))
		{
			IsOnLevitation = true;
			roll = Mathf.Lerp(roll, (0f - spineX) * 10f, Ang_T);
			pitch = Mathf.Lerp(pitch, Mathf.Clamp(anm.GetFloat("Pitch"), -0.75f, 1f) * 90f, Ang_T);
			Move(-Root.right, 100f + Mathf.Abs(anm.GetFloat("Pitch") * 50f));
			if (OnAnm.IsName("Dimo|Flight"))
			{
				PlaySound("Sniff", 5);
				PlaySound("Sniff", 6);
			}
			else if (OnAnm.IsName("Dimo|FlightGrowl"))
			{
				PlaySound("Atk", 2);
				PlaySound("Sniff", 5);
			}
			else if (OnAnm.IsName("Dimo|GlideGrowl"))
			{
				PlaySound("Growl", 2);
			}
		}
		else if (OnAnm.IsName("Dimo|Statio") | OnAnm.IsName("Dimo|StatioGrowl") | OnAnm.IsName("Dimo|IdleD") | OnAnm.IsName("Dimo|FlyAtk"))
		{
			IsOnLevitation = true;
			roll = Mathf.Lerp(roll, 0f, Ang_T);
			pitch = Mathf.Lerp(pitch, 0f, Ang_T);
			Move(Vector3.up, 100f * (0f - anm.GetFloat("Pitch")));
			if (IsOnGround && OnAnm.IsName("Dimo|FlyAtk"))
			{
				Move(Vector3.up, 50f);
			}
			if (anm.GetInteger("Move") > 0 && anm.GetInteger("Move") < 4)
			{
				Move(base.transform.forward, 100f);
			}
			else if (anm.GetInteger("Move") == -1)
			{
				Move(-base.transform.forward, 100f);
			}
			else if (anm.GetInteger("Move") == -10)
			{
				Move(base.transform.right, 100f);
			}
			else if (anm.GetInteger("Move") == 10)
			{
				Move(-base.transform.right, 100f);
			}
			if (OnAnm.IsName("Dimo|StatioGrowl"))
			{
				PlaySound("Atk", 2);
			}
			else if (OnAnm.IsName("Dimo|IdleD"))
			{
				PlaySound("Atk", 2);
				PlaySound("Step", 10);
			}
			else if (OnAnm.IsName("Dimo|FlyAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 3);
				PlaySound("Bite", 8);
			}
			else
			{
				PlaySound("Sniff", 5);
				PlaySound("Sniff", 6);
			}
		}
		else if (OnAnm.IsName("Dimo|Landing"))
		{
			IsOnLevitation = true;
			PlaySound("Step", 2);
			PlaySound("Step", 3);
		}
		else if (OnAnm.IsName("Dimo|IdleB"))
		{
			PlaySound("Atk", 2);
		}
		else if (OnAnm.IsName("Dimo|IdleC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Dimo|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Dimo|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Bite", 0);
		}
		else if (OnAnm.IsName("Dimo|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Dimo|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Dimo|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Dimo|Die-"))
		{
			IsConstrained = true;
			PlaySound("Atk", 2);
			IsDead = false;
		}
		RotateBone(IkType.Flying, 64f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(roll, pitch, 0f);
			Right_Wing0.rotation *= Quaternion.Euler(roll / 2f, Mathf.Clamp(roll, -35f, 0f), Mathf.Clamp(0f - pitch, -35f, 0f));
			Left_Wing0.rotation *= Quaternion.Euler(roll / 2f, Mathf.Clamp(0f - roll, -35f, 0f), Mathf.Clamp(pitch, 0f, 35f));
			Right_Wing0.GetChild(0).rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(pitch, 0f, 90f) + Mathf.Abs(roll) / 3f);
			Left_Wing0.GetChild(0).rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(0f - pitch, -90f, 0f) - Mathf.Abs(roll) / 3f);
			Right_Hand.rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(0f - pitch, -90f, 0f) - Mathf.Abs(roll) / 2f);
			Left_Hand.rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(pitch, 0f, 90f) + Mathf.Abs(roll) / 2f);
			float num = headY * headX / Yaw_Max;
			Neck0.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck1.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck2.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck3.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Head.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.Flying, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Wing0, Right_Wing1, Right_Hand, Left_Wing0, Left_Wing1, Left_Hand);
			anm.SetBool("OnGround", IsOnGround);
		}
	}
}
public class GalliLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Tail9;

	public Transform Tail10;

	public Transform Tail11;

	public Transform Arm1;

	public Transform Arm2;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Chew;

	public AudioClip Bite;

	public AudioClip Idlecarn;

	public AudioClip Galli1;

	public AudioClip Galli2;

	public AudioClip Galli3;

	public AudioClip Galli4;

	private Vector3 dir = Vector3.zero;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Galli1;
			break;
		case 1:
			pain = Galli2;
			break;
		case 2:
			pain = Galli3;
			break;
		case 3:
			pain = Galli4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot(Bite, 0.75f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "GrowlA":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Galli1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Galli2, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "GrowlB":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Galli3, 1f);
			}
			else
			{
				source[0].PlayOneShot(Galli4, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			dir = new Vector3(base.transform.forward.x, 0f, base.transform.forward.z);
		}
		else
		{
			ApplyGravity();
			anm.SetBool("OnGround", value: false);
		}
		if (OnAnm.IsName("Galli|IdleA") | OnAnm.IsName("Galli|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Galli|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("AtkB", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Galli|IdleJumpStart") | OnAnm.IsName("Galli|RunJumpStart") | OnAnm.IsName("Galli|JumpIdle") | OnAnm.IsName("Galli|IdleJumpEnd") | OnAnm.IsName("Galli|RunJumpEnd"))
		{
			if (OnAnm.IsName("Galli|IdleJumpStart") | OnAnm.IsName("Galli|RunJumpStart"))
			{
				if ((double)OnAnm.normalizedTime > 0.4)
				{
					Move(Vector3.up, 3f, jump: true);
				}
				else
				{
					OnJump = true;
				}
				if (anm.GetInteger("Move").Equals(2))
				{
					Move(dir, 160f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(dir, 32f);
				}
				PlaySound("Step", 1);
				PlaySound("Step", 2);
			}
			else if (OnAnm.IsName("Galli|IdleJumpEnd") | OnAnm.IsName("Galli|RunJumpEnd"))
			{
				if (OnAnm.IsName("Galli|RunJumpEnd"))
				{
					Move(dir, 160f);
				}
				body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
				OnJump = false;
				PlaySound("Step", 3);
				PlaySound("Step", 4);
			}
			else if (!anm.GetInteger("Move").Equals(0))
			{
				Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
			}
		}
		else if (OnAnm.IsName("Galli|Walk") | OnAnm.IsName("Galli|WalkGrowl"))
		{
			Move(base.transform.forward, 32f);
			if (OnAnm.IsName("Galli|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
			else if (OnAnm.IsName("Galli|WalkGrowl"))
			{
				PlaySound("GrowlB", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
		}
		else if (OnAnm.IsName("Galli|Run") | OnAnm.IsName("Galli|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 160f);
			if (OnAnm.IsName("Galli|Run"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("GrowlB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Galli|Walk-"))
		{
			if ((double)OnAnm.normalizedTime > 0.25 && (((double)OnAnm.normalizedTime < 0.45) | ((double)OnAnm.normalizedTime > 0.75)) && (double)OnAnm.normalizedTime < 0.9)
			{
				Move(-base.transform.forward, 32f);
			}
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Galli|Strafe-"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Galli|Strafe+"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Galli|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Galli|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("GrowlB", 3);
		}
		else if (OnAnm.IsName("Galli|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Galli|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Galli|EatA"))
		{
			OnReset = true;
			PlaySound("Food", 5);
			PlaySound("Food", 7);
		}
		else if (OnAnm.IsName("Galli|EatB"))
		{
			OnReset = true;
			PlaySound("Step", 3);
			PlaySound("Step", 6);
			PlaySound("Step", 11);
		}
		else if (OnAnm.IsName("Galli|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Galli|IdleC"))
		{
			PlaySound("GrowlB", 4);
			PlaySound("Bite", 3);
			PlaySound("Bite", 8);
		}
		else if (OnAnm.IsName("Galli|IdleD"))
		{
			PlaySound("GrowlA", 1);
			PlaySound("GrowlA", 4);
			PlaySound("GrowlA", 8);
		}
		else if (OnAnm.IsName("Galli|Die-"))
		{
			OnReset = true;
			PlaySound("GrowlB", 1);
			IsDead = false;
		}
		RotateBone(IkType.SmBiped, 60f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine4.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine5.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Arm1.rotation *= Quaternion.Euler(headY * 8f, 0f, 0f);
			Arm2.rotation *= Quaternion.Euler(0f, headY * 8f, 0f);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail9.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail10.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail11.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.SmBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class IguaLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Igua1;

	public AudioClip Igua2;

	public AudioClip Igua3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Igua1;
			break;
		case 1:
			pain = Igua2;
			break;
		case 2:
			pain = Igua3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff2, 0.5f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Igua1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Igua2, 1f);
				break;
			default:
				source[0].PlayOneShot(Igua3, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7, 4);
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Igua|Idle1A") | OnAnm.IsName("Igua|Idle2A") | OnAnm.IsName("Igua|Die1") | OnAnm.IsName("Igua|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Igua|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Igua|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Igua|Walk") | OnAnm.IsName("Igua|WalkGrowl") | OnAnm.IsName("Igua|Step1") | OnAnm.IsName("Igua|Step2") | OnAnm.IsName("Igua|ToEatA") | OnAnm.IsName("Igua|ToEatC") | OnAnm.IsName("Igua|ToIdle1D"))
		{
			if (!(OnAnm.IsName("Igua|Step1") | OnAnm.IsName("Igua|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Igua|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Igua|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Igua|Run") | OnAnm.IsName("Igua|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, Ang_T), -20f, 20f);
			Move(base.transform.forward, 80f);
			if (OnAnm.IsName("Igua|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Igua|Step1-") | OnAnm.IsName("Igua|Step2-") | OnAnm.IsName("Igua|ToSit1"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Igua|Strafe1+") | OnAnm.IsName("Igua|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Igua|Strafe1-") | OnAnm.IsName("Igua|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Igua|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Igua|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Igua|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Igua|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Igua|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Igua|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Igua|ToSit-"))
		{
			IsConstrained = false;
		}
		else if (OnAnm.IsName("Igua|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Igua|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Igua|Idle1C"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Igua|Idle1D"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Igua|Idle2B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Igua|Idle2C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Igua|ToRise1") | OnAnm.IsName("Igua|ToRise2"))
		{
			OnReset = true;
			PlaySound("Sniff", 3);
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Igua|ToRise1-") | OnAnm.IsName("Igua|ToRise2-"))
		{
			PlaySound("Hit", 7);
		}
		else if (OnAnm.IsName("Igua|Rise1Idle") | OnAnm.IsName("Igua|Rise2Idle"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Igua|Rise1Growl") | OnAnm.IsName("Igua|Rise2Growl"))
		{
			OnReset = true;
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Igua|Die1-") | OnAnm.IsName("Igua|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 50f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, headX, headX);
			Neck1.rotation *= Quaternion.Euler(headY, headX, headX);
			Neck2.rotation *= Quaternion.Euler(0f, headX, headX);
			Neck3.rotation *= Quaternion.Euler(0f, headX, headX);
			Head.rotation *= Quaternion.Euler(headY * 3f, 0f, 0f);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.5f * size);
		}
	}
}
public class KentLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Idleherb;

	public AudioClip Sniff1;

	public AudioClip Chew;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Kent1;

	public AudioClip Kent2;

	public AudioClip Kent3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Kent1;
			break;
		case 1:
			pain = Kent2;
			break;
		case 2:
			pain = Kent3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Kent1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Kent2, 1f);
				break;
			default:
				source[0].PlayOneShot(Kent3, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		anm.SetInteger("Delta", (int)delta);
		OnReset = false;
		OnAttack = false;
		OnTailAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Kent|Idle1A") | OnAnm.IsName("Kent|Idle2A") | OnAnm.IsName("Kent|Die1") | OnAnm.IsName("Kent|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Kent|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Kent|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Kent|Walk") | OnAnm.IsName("Kent|WalkGrowl") | OnAnm.IsName("Kent|Step1") | OnAnm.IsName("Kent|Step2") | OnAnm.IsName("Kent|ToIdle2C") | OnAnm.IsName("Kent|ToEatA") | (OnAnm.IsName("Kent|ToEatC") && (double)OnAnm.normalizedTime < 0.9))
		{
			if (!(OnAnm.IsName("Kent|Step1") | OnAnm.IsName("Kent|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Kent|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Kent|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Kent|Run") | OnAnm.IsName("Kent|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			Move(base.transform.forward, 60f);
			if (OnAnm.IsName("Kent|Run"))
			{
				PlaySound("Step", 3);
				PlaySound("Step", 9);
			}
			else
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Kent|Step1-") | OnAnm.IsName("Kent|Step2-") | OnAnm.IsName("Kent|ToIdle1C") | OnAnm.IsName("Kent|ToSit1"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Kent|Strafe1-") | OnAnm.IsName("Kent|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Kent|Strafe1+") | OnAnm.IsName("Kent|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Kent|AtkIdle") | OnAnm.IsName("Kent|AtkA") | OnAnm.IsName("Kent|AtkGrowl"))
		{
			OnTailAttack = true;
			Move(Vector3.zero);
			if (OnAnm.IsName("Kent|AtkGrowl"))
			{
				PlaySound("Growl", 2);
			}
			else if (OnAnm.IsName("Kent|AtkA"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Sniff", 3);
			}
		}
		else if (OnAnm.IsName("Kent|AtkB-") | OnAnm.IsName("Kent|AtkB+"))
		{
			OnTailAttack = true;
			Move(Vector3.zero);
			if ((double)OnAnm.normalizedTime < 0.9)
			{
				if (OnAnm.IsName("Kent|AtkB-"))
				{
					base.transform.rotation *= Quaternion.Euler(0f, Mathf.Lerp(0f, -10f, 0.5f), 0f);
				}
				else if (OnAnm.IsName("Kent|AtkB+"))
				{
					base.transform.rotation *= Quaternion.Euler(0f, Mathf.Lerp(0f, 10f, 0.5f), 0f);
				}
				OnAttack = true;
				anm.SetFloat("Turn", base.transform.eulerAngles.y);
			}
			PlaySound("Hit", 8);
			PlaySound("Hit", 10);
			PlaySound("Sniff", 3);
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Kent|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Kent|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Kent|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Kent|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Kent|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Kent|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Kent|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
			PlaySound("Step", 8);
		}
		else if (OnAnm.IsName("Kent|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Kent|Idle1C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Kent|Idle2B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Kent|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Kent|Die1-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Kent|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 40f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = headY * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			float y2 = spineY * spineX / Yaw_Max;
			Tail0.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.3f * size);
		}
	}
}
public class OuraLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Oura1;

	public AudioClip Oura2;

	public AudioClip Oura3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Oura1;
			break;
		case 1:
			pain = Oura2;
			break;
		case 2:
			pain = Oura3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff2, 0.5f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Oura1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Oura2, 1f);
				break;
			default:
				source[0].PlayOneShot(Oura3, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7, 4);
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Oura|Idle1A") | OnAnm.IsName("Oura|Idle2A") | OnAnm.IsName("Oura|Die1") | OnAnm.IsName("Oura|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Oura|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Oura|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Oura|Walk") | OnAnm.IsName("Oura|WalkGrowl") | OnAnm.IsName("Oura|Step1") | OnAnm.IsName("Oura|Step2") | OnAnm.IsName("Oura|ToEatA") | OnAnm.IsName("Oura|ToEatC") | OnAnm.IsName("Oura|ToIdle1D"))
		{
			if (!(OnAnm.IsName("Oura|Step1") | OnAnm.IsName("Oura|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Oura|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Oura|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Oura|Run") | OnAnm.IsName("Oura|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, Ang_T), -20f, 20f);
			Move(base.transform.forward, 80f);
			if (OnAnm.IsName("Oura|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Oura|Step1-") | OnAnm.IsName("Oura|Step2-") | OnAnm.IsName("Oura|ToSit1"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Oura|Strafe1+") | OnAnm.IsName("Oura|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Oura|Strafe1-") | OnAnm.IsName("Oura|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Oura|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Oura|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Oura|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Oura|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Oura|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Oura|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Oura|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Oura|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Oura|Idle1C"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Oura|Idle1D"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Oura|Idle2B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Oura|Idle2C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Oura|ToRise1") | OnAnm.IsName("Oura|ToRise2"))
		{
			OnReset = true;
			PlaySound("Sniff", 3);
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Oura|ToRise1-") | OnAnm.IsName("Oura|ToRise2-"))
		{
			PlaySound("Hit", 7);
		}
		else if (OnAnm.IsName("Oura|Rise1Idle") | OnAnm.IsName("Oura|Rise2Idle"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Oura|Rise1Growl") | OnAnm.IsName("Oura|Rise2Growl"))
		{
			OnReset = true;
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Oura|Die1-") | OnAnm.IsName("Oura|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 50f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float z = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, headX, z);
			Neck1.rotation *= Quaternion.Euler(headY, headX, z);
			Neck2.rotation *= Quaternion.Euler(headY, headX, z);
			Neck3.rotation *= Quaternion.Euler(headY, headX, z);
			Head.rotation *= Quaternion.Euler(headY, headX, z);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.5f * size);
		}
	}
}
public class PachyLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Idleherb;

	public AudioClip Pachy1;

	public AudioClip Pachy2;

	public AudioClip Pachy3;

	public AudioClip Pachy4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Pachy1;
			break;
		case 1:
			pain = Pachy2;
			break;
		case 2:
			pain = Pachy3;
			break;
		case 3:
			pain = Pachy4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Medsplash : Medstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1.25f, 1.5f);
			source[0].PlayOneShot(Sniff2, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Pachy2, 1f);
			}
			else
			{
				source[0].PlayOneShot(Pachy4, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Pachy1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Pachy3, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Pachy|IdleA") | OnAnm.IsName("Pachy|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Pachy|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 1);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Pachy|Walk") | OnAnm.IsName("Pachy|WalkGrowl"))
		{
			Move(base.transform.forward, 48f);
			if (OnAnm.IsName("Pachy|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
		}
		else if (OnAnm.IsName("Pachy|Run") | OnAnm.IsName("Pachy|RunGrowl") | (OnAnm.IsName("Pachy|RunAtk") && (double)OnAnm.normalizedTime < 0.6))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.05f), -30f, 30f);
			Move(base.transform.forward, 128f);
			PlaySound("Step", 4);
			PlaySound("Step", 12);
			if (OnAnm.IsName("Pachy|RunGrowl"))
			{
				PlaySound("Growl", 1);
			}
			else if (OnAnm.IsName("Pachy|RunAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 3);
			}
		}
		else if (OnAnm.IsName("Pachy|Walk-") | OnAnm.IsName("Pachy|WalkGrowl-"))
		{
			Move(-base.transform.forward, 40f);
			PlaySound("Step", 4);
			PlaySound("Step", 12);
			if (OnAnm.IsName("Pachy|WalkGrowl-"))
			{
				PlaySound("Growl", 1);
			}
		}
		else if (OnAnm.IsName("Pachy|Strafe-"))
		{
			Move(base.transform.right, 20f);
			PlaySound("Step", 4);
			PlaySound("Step", 10);
		}
		else if (OnAnm.IsName("Pachy|Strafe+"))
		{
			Move(-base.transform.right, 20f);
			PlaySound("Step", 4);
			PlaySound("Step", 10);
		}
		else if (OnAnm.IsName("Pachy|IdleAtk"))
		{
			Move(Vector3.zero);
			OnAttack = true;
			PlaySound("Atk", 2);
			PlaySound("Step", 3);
		}
		else if (OnAnm.IsName("Pachy|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Pachy|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Pachy|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Pachy|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Pachy|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Pachy|ToSleep-"))
		{
			IsConstrained = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Pachy|IdleB"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Pachy|IdleC"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Pachy|IdleD"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Pachy|Die-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.LgBiped, 65f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, 0f, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, 0f, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, 0f, headX);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.LgBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class ProtoLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Slip;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Proto1;

	public AudioClip Proto2;

	public AudioClip Proto3;

	public AudioClip Proto4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Proto1;
			break;
		case 1:
			pain = Proto2;
			break;
		case 2:
			pain = Proto3;
			break;
		case 3:
			pain = Proto4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Slip":
			source[1].pitch = UnityEngine.Random.Range(2f, 2.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Slip, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Medsplash : Smallstep, UnityEngine.Random.Range(0.5f, 0.75f));
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(2f, 2.5f);
			source[0].PlayOneShot(Sniff2, 0.25f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(2f, 2.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3.5f, 3.75f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Proto1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Proto2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Proto3, 1f);
				break;
			default:
				source[0].PlayOneShot(Proto4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Proto|IdleA") | OnAnm.IsName("Proto|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Proto|Die"))
			{
				OnReset = true;
				IsConstrained = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Proto|Walk") | OnAnm.IsName("Proto|WalkGrowl"))
		{
			Move(base.transform.forward, 15f);
			if (OnAnm.IsName("Proto|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Proto|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Proto|Run") | OnAnm.IsName("Proto|RunGrowl") | OnAnm.IsName("Proto|RunAtk1") | (OnAnm.IsName("Proto|RunAtk2") && (double)OnAnm.normalizedTime < 0.5))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			Move(base.transform.forward, 80f);
			if (OnAnm.IsName("Proto|Run"))
			{
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
			else if (OnAnm.IsName("Proto|RunAtk1"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
			else if (OnAnm.IsName("Proto|RunAtk2"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Slip", 6);
			}
			else
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
		}
		else if (OnAnm.IsName("Proto|Walk-") | OnAnm.IsName("Proto|WalkGrowl-"))
		{
			Move(-base.transform.forward, 15f);
			if (OnAnm.IsName("Proto|Walk-"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 11);
			}
			else if (OnAnm.IsName("Proto|WalkGrowl-"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 4);
				PlaySound("Step", 11);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Proto|Strafe-"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Proto|Strafe+"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Proto|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Proto|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Proto|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Proto|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Proto|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Proto|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Proto|ToSit-"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Proto|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Proto|IdleB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Sniff", 2);
			PlaySound("Sniff", 5);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Proto|IdleC"))
		{
			PlaySound("Growl", 2);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
			PlaySound("Sniff", 9);
		}
		else if (OnAnm.IsName("Proto|IdleD"))
		{
			PlaySound("Growl", 2);
			PlaySound("Slip", 3);
		}
		else if (OnAnm.IsName("Proto|IdleE"))
		{
			PlaySound("Sniff", 1);
			PlaySound("Growl", 4);
			PlaySound("Step", 9);
			PlaySound("Step", 11);
		}
		else if (OnAnm.IsName("Proto|IdleAtk"))
		{
			OnAttack = true;
			PlaySound("Growl", 2);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
		}
		else if (OnAnm.IsName("Proto|Die-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 55f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = headY * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.25f * size);
		}
	}
}
public class QuetLP : Creature
{
	public Transform Root;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Neck4;

	public Transform Neck5;

	public Transform Neck6;

	public Transform Right_Wing0;

	public Transform Left_Wing0;

	public Transform Right_Wing1;

	public Transform Left_Wing1;

	public Transform Right_Hand;

	public Transform Left_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Wind;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Swallow;

	public AudioClip Idlecarn;

	public AudioClip Sniff2;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Quet1;

	public AudioClip Quet2;

	public AudioClip Quet3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Quet1;
			break;
		case 1:
			pain = Quet2;
			break;
		case 2:
			pain = Quet3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[1].PlayOneShot(Bigstep, 0.25f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else
			{
				source[1].PlayOneShot(Sniff2, UnityEngine.Random.Range(0.1f, 0.2f));
			}
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Bigstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Quet1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Quet3, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Quet2, 1f);
			lastframe = currframe;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		_ = -Root.right;
		anm.SetBool("OnGround", IsOnGround);
		OnReset = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnJump = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
			anm.SetInteger("Move", 1);
		}
		else if (IsOnGround)
		{
			roll = Mathf.Lerp(roll, 0f, 0.1f);
			pitch = Mathf.Lerp(pitch, 0f, 0.1f);
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
		}
		else if (Health == 0f)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyGravity();
		}
		else
		{
			body.drag = 1f;
			body.angularDrag = 1f;
		}
		if (OnAnm.IsName("Quet|IdleA") | OnAnm.IsName("Quet|Die1") | OnAnm.IsName("Quet|Die2") | OnAnm.IsName("Quet|Fall"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Quet|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 1);
					PlaySound("Die", 11);
				}
			}
			else if (OnAnm.IsName("Quet|Die2"))
			{
				OnReset = true;
				body.velocity = new Vector3(0f, 0f, 0f);
				if (!IsDead)
				{
					PlaySound("Die", 0);
				}
			}
			else if (OnAnm.IsName("Quet|Fall"))
			{
				OnReset = true;
				IsOnLevitation = true;
				if (IsInWater)
				{
					anm.SetBool("OnGround", value: true);
				}
				if (OnAnm.normalizedTime < 0.1f)
				{
					source[0].PlayOneShot(Quet2, 1f);
				}
			}
		}
		else if (OnAnm.IsName("Quet|Walk"))
		{
			Move(base.transform.forward, 20f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Quet|Run") | OnAnm.IsName("Quet|FlightToRun") | OnAnm.IsName("Quet|RunToFlight"))
		{
			IsOnLevitation = true;
			Move(base.transform.forward, 100f);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Quet|Walk-"))
		{
			Move(-base.transform.forward, 10f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Quet|Strafe+"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Quet|Strafe-"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Quet|Takeoff"))
		{
			if ((double)OnAnm.normalizedTime > 0.5)
			{
				IsOnLevitation = true;
				OnJump = true;
				Move(Vector3.up, 50f);
			}
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Quet|Flight") | OnAnm.IsName("Quet|FlightGrowl") | OnAnm.IsName("Quet|Glide") | OnAnm.IsName("Quet|GlideGrowl"))
		{
			IsOnLevitation = true;
			roll = Mathf.Lerp(roll, (0f - spineX) * 10f, Ang_T);
			pitch = Mathf.Lerp(pitch, Mathf.Clamp(anm.GetFloat("Pitch"), -0.75f, 1f) * 90f, Ang_T);
			Move(-Root.right, 200f + Mathf.Abs(anm.GetFloat("Pitch") * 100f));
			if (OnAnm.IsName("Quet|Flight"))
			{
				PlaySound("Sniff", 5);
				PlaySound("Sniff", 6);
			}
			else if (OnAnm.IsName("Quet|FlightGrowl"))
			{
				PlaySound("Atk", 2);
				PlaySound("Sniff", 5);
			}
			else if (OnAnm.IsName("Quet|GlideGrowl"))
			{
				PlaySound("Growl", 2);
			}
		}
		else if (OnAnm.IsName("Quet|Statio") | OnAnm.IsName("Quet|StatioGrowl") | OnAnm.IsName("Quet|IdleD") | OnAnm.IsName("Quet|FlyAtk"))
		{
			IsOnLevitation = true;
			roll = Mathf.Lerp(roll, 0f, Ang_T);
			pitch = Mathf.Lerp(pitch, 0f, Ang_T);
			Move(Vector3.up, 100f * (0f - anm.GetFloat("Pitch")));
			if (IsOnGround && OnAnm.IsName("Quet|FlyAtk"))
			{
				Move(Vector3.up, 50f);
			}
			if (anm.GetInteger("Move") > 0 && anm.GetInteger("Move") < 4)
			{
				Move(base.transform.forward, 100f);
			}
			else if (anm.GetInteger("Move") == -1)
			{
				Move(-base.transform.forward, 100f);
			}
			else if (anm.GetInteger("Move") == -10)
			{
				Move(base.transform.right, 100f);
			}
			else if (anm.GetInteger("Move") == 10)
			{
				Move(-base.transform.right, 100f);
			}
			if (OnAnm.IsName("Quet|StatioGrowl"))
			{
				PlaySound("Atk", 3);
			}
			else if (OnAnm.IsName("Quet|IdleD"))
			{
				PlaySound("Atk", 2);
				PlaySound("Step", 10);
			}
			else if (OnAnm.IsName("Quet|FlyAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 3);
				PlaySound("Bite", 7);
			}
			else
			{
				PlaySound("Sniff", 5);
				PlaySound("Sniff", 6);
			}
		}
		else if (OnAnm.IsName("Quet|Landing"))
		{
			IsOnLevitation = true;
			PlaySound("Step", 2);
			PlaySound("Step", 3);
		}
		else if (OnAnm.IsName("Quet|IdleB"))
		{
			PlaySound("Atk", 2);
			PlaySound("Bite", 5);
			PlaySound("Bite", 8);
			PlaySound("Bite", 10);
		}
		else if (OnAnm.IsName("Quet|IdleC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Quet|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Quet|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Step", 0);
		}
		else if (OnAnm.IsName("Quet|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Quet|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Quet|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Quet|Die-"))
		{
			IsConstrained = true;
			PlaySound("Atk", 2);
			IsDead = false;
		}
		if (IsOnLevitation)
		{
			if (!source[2].isPlaying)
			{
				source[2].PlayOneShot(Wind);
			}
			source[2].volume = body.velocity.magnitude / (40f * size);
			source[2].pitch = body.velocity.magnitude / (40f * size);
		}
		else if (source[2].isPlaying)
		{
			source[2].Pause();
		}
		RotateBone(IkType.Flying, 32f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(roll, pitch, 0f);
			Right_Wing0.rotation *= Quaternion.Euler(roll / 2f, 0f, Mathf.Clamp(0f - pitch, -35f, 0f));
			Left_Wing0.rotation *= Quaternion.Euler(roll / 2f, 0f, Mathf.Clamp(pitch, 0f, 35f));
			Right_Wing0.GetChild(0).rotation *= Quaternion.Euler(0f, Mathf.Clamp(0f - roll, -15f, 10f), Mathf.Clamp(pitch, 0f, 90f) + Mathf.Abs(roll) / 2f);
			Left_Wing0.GetChild(0).rotation *= Quaternion.Euler(0f, Mathf.Clamp(roll, -15f, 10f), Mathf.Clamp(0f - pitch, -90f, 0f) - Mathf.Abs(roll) / 2f);
			Right_Hand.rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(0f - pitch, -90f, 0f) - Mathf.Abs(roll));
			Left_Hand.rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(pitch, 0f, 90f) + Mathf.Abs(roll));
			float num = headY * headX / Yaw_Max;
			Neck0.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck1.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck2.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck3.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck4.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck5.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck6.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Head.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.Flying, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Wing0, Right_Wing1, Right_Hand, Left_Wing0, Left_Wing1, Left_Hand);
			anm.SetBool("OnGround", IsOnGround);
		}
	}
}
public class StyraLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Slip;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Styra1;

	public AudioClip Styra2;

	public AudioClip Styra3;

	public AudioClip Styra4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Styra1;
			break;
		case 1:
			pain = Styra2;
			break;
		case 2:
			pain = Styra3;
			break;
		case 3:
			pain = Styra4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Slip":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Slip, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1.2f, 1.5f);
			source[0].PlayOneShot(Sniff2, 0.25f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Styra1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Styra2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Styra3, 1f);
				break;
			default:
				source[0].PlayOneShot(Styra4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Styra|Idle1A") | OnAnm.IsName("Styra|Idle2A") | OnAnm.IsName("Styra|Die1") | OnAnm.IsName("Styra|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Styra|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Styra|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Styra|Walk") | OnAnm.IsName("Styra|WalkGrowl") | OnAnm.IsName("Styra|Step1") | OnAnm.IsName("Styra|Step2") | OnAnm.IsName("Styra|ToEatA") | OnAnm.IsName("Styra|ToEatC") | OnAnm.IsName("Styra|ToIdle2C"))
		{
			if (!(OnAnm.IsName("Styra|Step1") | OnAnm.IsName("Styra|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Styra|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Styra|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Styra|Run") | OnAnm.IsName("Styra|RunGrowl") | OnAnm.IsName("Styra|StepAtk1") | OnAnm.IsName("Styra|StepAtk2") | OnAnm.IsName("Styra|RunAtk1") | (OnAnm.IsName("Styra|RunAtk2") && (double)OnAnm.normalizedTime < 0.5))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			if ((OnAnm.IsName("Styra|StepAtk1") | OnAnm.IsName("Styra|StepAtk2")) && (double)OnAnm.normalizedTime > 0.3)
			{
				Move(Vector3.zero);
			}
			else
			{
				Move(base.transform.forward, 100f);
			}
			if (OnAnm.IsName("Styra|Run"))
			{
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
			else if (OnAnm.IsName("Styra|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
			else if (OnAnm.IsName("Styra|RunAtk2"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Slip", 6);
			}
			else
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
		}
		else if (OnAnm.IsName("Styra|Step1-") | OnAnm.IsName("Styra|Step2-") | OnAnm.IsName("Styra|ToSit1") | OnAnm.IsName("Styra|ToIdle1C") | OnAnm.IsName("Styra|ToIdle1D"))
		{
			Move(-base.transform.forward, 10f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Styra|Strafe1-") | OnAnm.IsName("Styra|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Styra|Strafe1+") | OnAnm.IsName("Styra|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Styra|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Styra|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Styra|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Styra|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Styra|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Styra|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Styra|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Styra|Idle1B"))
		{
			PlaySound("Growl", 2);
			PlaySound("Slip", 3);
		}
		else if (OnAnm.IsName("Styra|Idle1C"))
		{
			PlaySound("Growl", 2);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
			PlaySound("Sniff", 9);
		}
		else if (OnAnm.IsName("Styra|Idle1D"))
		{
			PlaySound("Sniff", 1);
			PlaySound("Growl", 4);
			PlaySound("Step", 9);
			PlaySound("Step", 11);
		}
		else if (OnAnm.IsName("Styra|Idle2B"))
		{
			PlaySound("Growl", 2);
			PlaySound("Slip", 3);
		}
		else if (OnAnm.IsName("Styra|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Styra|IdleAtk1") | OnAnm.IsName("Styra|IdleAtk2"))
		{
			OnAttack = true;
			PlaySound("Growl", 2);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
		}
		else if (OnAnm.IsName("Styra|Die1-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Styra|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 55f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = headY * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.5f * size);
		}
	}
}
public class TrooLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Tail9;

	public Transform Tail10;

	public Transform Tail11;

	public Transform Arm1;

	public Transform Arm2;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Idlecarn;

	public AudioClip Swallow;

	public AudioClip Bite;

	public AudioClip Troo1;

	public AudioClip Troo2;

	public AudioClip Troo3;

	public AudioClip Troo4;

	public AudioClip Troo5;

	public AudioClip Troo6;

	private Vector3 dir = Vector3.zero;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Troo1;
			break;
		case 1:
			pain = Troo2;
			break;
		case 2:
			pain = Troo3;
			break;
		case 3:
			pain = Troo5;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Swallow, 0.025f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Idlecarn, 0.01f);
			lastframe = currframe;
			break;
		case "Call":
			source[0].pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			source[0].PlayOneShot(Troo4, 1f);
			lastframe = currframe;
			break;
		case "AtkA":
		{
			int num3 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num3 == 0)
			{
				source[0].PlayOneShot(Troo2, 1f);
			}
			else
			{
				source[0].PlayOneShot(Troo3, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "AtkB":
		{
			int num2 = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num2)
			{
			case 0:
				source[0].PlayOneShot(Troo1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Troo6, 1f);
				break;
			default:
				source[0].PlayOneShot(Troo4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Troo5, 1f);
			}
			else
			{
				source[0].PlayOneShot(Troo6, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			dir = new Vector3(base.transform.forward.x, 0f, base.transform.forward.z);
		}
		else
		{
			ApplyGravity();
			anm.SetBool("OnGround", value: false);
		}
		if (OnAnm.IsName("Troo|IdleA") | OnAnm.IsName("Troo|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Troo|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("AtkB", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Troo|IdleJumpStart") | OnAnm.IsName("Troo|RunJumpStart") | OnAnm.IsName("Troo|JumpIdle") | OnAnm.IsName("Troo|IdleJumpEnd") | OnAnm.IsName("Troo|RunJumpEnd") | OnAnm.IsName("Troo|JumpAtk"))
		{
			if (OnAnm.IsName("Troo|IdleJumpStart") | OnAnm.IsName("Troo|RunJumpStart"))
			{
				if ((double)OnAnm.normalizedTime > 0.4)
				{
					Move(Vector3.up, 3f, jump: true);
				}
				else
				{
					OnJump = true;
				}
				if (anm.GetInteger("Move").Equals(2))
				{
					Move(dir, 160f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(dir, 32f);
				}
				PlaySound("Step", 1);
				PlaySound("Step", 2);
			}
			else if (OnAnm.IsName("Troo|IdleJumpEnd") | OnAnm.IsName("Troo|RunJumpEnd"))
			{
				if (OnAnm.IsName("Troo|RunJumpEnd"))
				{
					Move(dir, 160f);
				}
				body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
				OnJump = false;
				PlaySound("Step", 3);
				PlaySound("Step", 4);
			}
			else if (OnAnm.IsName("Troo|JumpAtk"))
			{
				if (anm.GetInteger("Move").Equals(1) | anm.GetInteger("Move").Equals(2))
				{
					Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
				}
				OnAttack = true;
				PlaySound("AtkB", 1);
				PlaySound("Bite", 9);
				body.velocity = new Vector3(body.velocity.x, (body.velocity.y > 0f) ? body.velocity.y : 0f, body.velocity.z);
			}
			else if (!anm.GetInteger("Move").Equals(0))
			{
				Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
			}
		}
		else if (OnAnm.IsName("Troo|Walk") | OnAnm.IsName("Troo|WalkGrowl"))
		{
			Move(base.transform.forward, 32f);
			if (OnAnm.IsName("Troo|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
			else if (OnAnm.IsName("Troo|WalkGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
		}
		else if (OnAnm.IsName("Troo|Run") | OnAnm.IsName("Troo|RunGrowl") | OnAnm.IsName("Troo|RunAtk1") | (OnAnm.IsName("Troo|RunAtk2") && (double)OnAnm.normalizedTime < 0.9) | (OnAnm.IsName("Troo|IdleAtk3") && (double)OnAnm.normalizedTime > 0.5 && (double)OnAnm.normalizedTime < 0.9))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 160f);
			if (OnAnm.IsName("Troo|Run"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Troo|RunGrowl"))
			{
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Troo|RunAtk1"))
			{
				OnAttack = true;
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Troo|RunAtk2") | OnAnm.IsName("Troo|IdleAtk3"))
			{
				OnAttack = true;
				PlaySound("AtkA", 2);
				PlaySound("Step", 4);
				PlaySound("Bite", 9);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Troo|Walk-") | OnAnm.IsName("Troo|WalkGrowl-"))
		{
			if ((double)OnAnm.normalizedTime > 0.25 && (((double)OnAnm.normalizedTime < 0.45) | ((double)OnAnm.normalizedTime > 0.75)) && (double)OnAnm.normalizedTime < 0.9)
			{
				Move(-base.transform.forward, 32f);
			}
			if (OnAnm.IsName("Troo|WalkGrowl-"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
		}
		else if (OnAnm.IsName("Troo|Strafe-"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Troo|Strafe+"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Troo|IdleAtk3"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkB", 1);
		}
		else if (OnAnm.IsName("Troo|GroundAtk"))
		{
			OnAttack = true;
			PlaySound("AtkB", 2);
			PlaySound("Bite", 4);
		}
		else if (OnAnm.IsName("Troo|IdleAtk1") | OnAnm.IsName("Troo|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkB", 2);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Troo|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Troo|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Troo|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Troo|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Bite", 3);
		}
		else if (OnAnm.IsName("Troo|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Troo|IdleC"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Troo|IdleD"))
		{
			PlaySound("Call", 1);
			PlaySound("Call", 4);
			PlaySound("Call", 8);
		}
		else if (OnAnm.IsName("Troo|IdleE"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 7);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Troo|Die-"))
		{
			OnReset = true;
			PlaySound("AtkA", 1);
			IsDead = false;
		}
		RotateBone(IkType.SmBiped, 60f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine4.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine5.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Arm1.rotation *= Quaternion.Euler(headY * 8f, 0f, 0f);
			Arm2.rotation *= Quaternion.Euler(0f, headY * 8f, 0f);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail9.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail10.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail11.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.SmBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class AnkyLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Idleherb;

	public AudioClip Sniff1;

	public AudioClip Chew;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Anky1;

	public AudioClip Anky2;

	public AudioClip Anky3;

	public AudioClip Anky4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Anky1;
			break;
		case 1:
			pain = Anky2;
			break;
		case 2:
			pain = Anky3;
			break;
		case 3:
			pain = Anky4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Anky1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Anky2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Anky3, 1f);
				break;
			case 3:
				source[0].PlayOneShot(Anky4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		anm.SetInteger("Delta", (int)delta);
		OnReset = false;
		OnAttack = false;
		OnTailAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Anky|Idle1A") | OnAnm.IsName("Anky|Idle2A") | OnAnm.IsName("Anky|Die1") | OnAnm.IsName("Anky|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Anky|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Anky|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		if (OnAnm.IsName("Anky|Walk") | OnAnm.IsName("Anky|WalkGrowl") | OnAnm.IsName("Anky|Step1") | OnAnm.IsName("Anky|Step2") | OnAnm.IsName("Anky|ToIdle2C") | OnAnm.IsName("Anky|ToEatA") | (OnAnm.IsName("Anky|ToEatC") && (double)OnAnm.normalizedTime < 0.9))
		{
			if (!(OnAnm.IsName("Anky|Step1") | OnAnm.IsName("Anky|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Anky|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Anky|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Anky|Run") | OnAnm.IsName("Anky|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			Move(base.transform.forward, 60f);
			if (OnAnm.IsName("Anky|Run"))
			{
				PlaySound("Step", 3);
				PlaySound("Step", 9);
			}
			else
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Anky|Step1-") | OnAnm.IsName("Anky|Step2-") | OnAnm.IsName("Anky|ToIdle1C") | OnAnm.IsName("Anky|ToSit1"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Anky|Strafe1-") | OnAnm.IsName("Anky|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Anky|Strafe1+") | OnAnm.IsName("Anky|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Anky|AtkIdle") | OnAnm.IsName("Anky|AtkA") | OnAnm.IsName("Anky|AtkGrowl"))
		{
			OnTailAttack = true;
			Move(Vector3.zero);
			if (OnAnm.IsName("Anky|AtkGrowl"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Hit", 7);
			}
			else if (OnAnm.IsName("Anky|AtkA"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Sniff", 3);
			}
		}
		else if (OnAnm.IsName("Anky|AtkB-") | OnAnm.IsName("Anky|AtkB+"))
		{
			OnTailAttack = true;
			Move(Vector3.zero);
			if ((double)OnAnm.normalizedTime < 0.9)
			{
				if (OnAnm.IsName("Anky|AtkB-"))
				{
					base.transform.rotation *= Quaternion.Euler(0f, Mathf.Lerp(0f, -10f, 0.5f), 0f);
				}
				else if (OnAnm.IsName("Anky|AtkB+"))
				{
					base.transform.rotation *= Quaternion.Euler(0f, Mathf.Lerp(0f, 10f, 0.5f), 0f);
				}
				OnAttack = true;
				anm.SetFloat("Turn", base.transform.eulerAngles.y);
			}
			PlaySound("Hit", 8);
			PlaySound("Hit", 10);
			PlaySound("Sniff", 3);
			PlaySound("Growl", 2);
		}
		if (OnAnm.IsName("Anky|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Anky|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Anky|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Anky|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Anky|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Anky|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Anky|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
			PlaySound("Step", 8);
		}
		else if (OnAnm.IsName("Anky|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Anky|Idle1C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Anky|Idle2B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Anky|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Anky|Die1-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Anky|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 40f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = headY * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			float y2 = spineY * spineX / Yaw_Max;
			Tail0.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(spineY, y2, 0f - spineX);
			roll = Mathf.Lerp(roll, 0f, Ang_T);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.4f * size);
		}
	}
}
public class BrachLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Neck4;

	public Transform Neck5;

	public Transform Neck6;

	public Transform Neck7;

	public Transform Neck8;

	public Transform Neck9;

	public Transform Neck10;

	public Transform Neck11;

	public Transform Neck12;

	public Transform Neck13;

	public Transform Neck14;

	public Transform Neck15;

	public Transform Neck16;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Chew;

	public AudioClip Brach1;

	public AudioClip Brach2;

	public AudioClip Brach3;

	public AudioClip Brach4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Brach1;
			break;
		case 1:
			pain = Brach2;
			break;
		case 2:
			pain = Brach3;
			break;
		case 3:
			pain = Brach4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Largestep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.75f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Brach1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Brach2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Brach3, 1f);
				break;
			case 3:
				source[0].PlayOneShot(Brach4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 4, 0, 0, 2, 3, 5);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 4, 0, 0, 2, 3, 5, 4);
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Brach|IdleA") | OnAnm.IsName("Brach|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Brach|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 3);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Brach|Walk") | OnAnm.IsName("Brach|WalkGrowl"))
		{
			Move(base.transform.forward, 15f);
			if (OnAnm.IsName("Brach|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Brach|Run") | OnAnm.IsName("Brach|RunGrowl"))
		{
			Move(base.transform.forward, 30f);
			if (OnAnm.IsName("Brach|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Brach|Walk-") | OnAnm.IsName("Brach|WalkGrowl-"))
		{
			Move(-base.transform.forward, 15f);
			if (OnAnm.IsName("Brach|WalkGrowl-"))
			{
				PlaySound("Growl", 4);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Brach|Strafe-"))
		{
			Move(base.transform.right, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Brach|Strafe+"))
		{
			Move(-base.transform.right, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Brach|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Brach|EatB"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Brach|EatC"))
		{
			OnReset = true;
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Brach|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Brach|ToSit-"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Brach|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Brach|Sleep") | OnAnm.IsName("Brach|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Brach|SitGrowl"))
		{
			PlaySound("Growl", 7);
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Brach|IdleB"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Brach|RiseIdle"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Brach|RiseGrowl"))
		{
			OnReset = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Brach|ToRise"))
		{
			OnReset = true;
			PlaySound("Growl", 5);
		}
		else if (OnAnm.IsName("Brach|ToRise-"))
		{
			OnReset = true;
			PlaySound("Growl", 1);
			PlaySound("Hit", 4);
		}
		else if (OnAnm.IsName("Brach|Die-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 40f, 0f, CanMoveHead: true, 0.25f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck1.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck2.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck3.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck4.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck5.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck6.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck7.rotation *= Quaternion.Euler(0f, 0f, headX);
			Neck8.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck9.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck10.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck11.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck12.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck13.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck14.rotation *= Quaternion.Euler(headY, 0f, 0f);
			Neck15.rotation *= Quaternion.Euler(headY, y, headX);
			Neck16.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.6f * size);
		}
	}
}
public class CompLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Arm1;

	public Transform Arm2;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Bite;

	public AudioClip Comp1;

	public AudioClip Comp2;

	public AudioClip Comp3;

	public AudioClip Comp4;

	public AudioClip Comp5;

	private Vector3 dir = Vector3.zero;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Comp1;
			break;
		case 1:
			pain = Comp2;
			break;
		case 2:
			pain = Comp3;
			break;
		case 3:
			pain = Comp4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Call":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Comp4, 1f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.75f);
			switch (num2)
			{
			case 0:
				source[0].PlayOneShot(Comp2, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Comp3, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Comp5, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 5);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.75f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Comp1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Comp2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Comp3, 1f);
				break;
			case 3:
				source[0].PlayOneShot(Comp4, 1f);
				break;
			case 4:
				source[0].PlayOneShot(Comp5, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			dir = new Vector3(base.transform.forward.x, 0f, base.transform.forward.z);
		}
		else
		{
			ApplyGravity(0.5f);
			anm.SetBool("OnGround", value: false);
		}
		if (OnAnm.IsName("Comp|IdleA") | OnAnm.IsName("Comp|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Comp|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("AtkB", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Comp|IdleJumpStart") | OnAnm.IsName("Comp|RunJumpStart") | OnAnm.IsName("Comp|JumpIdle") | OnAnm.IsName("Comp|IdleJumpEnd") | OnAnm.IsName("Comp|RunJumpEnd") | OnAnm.IsName("Comp|JumpAtk"))
		{
			if (OnAnm.IsName("Comp|IdleJumpStart") | OnAnm.IsName("Comp|RunJumpStart"))
			{
				if ((double)OnAnm.normalizedTime > 0.4)
				{
					Move(Vector3.up, 1.5f, jump: true);
				}
				else
				{
					OnJump = true;
				}
				if (anm.GetInteger("Move").Equals(2))
				{
					Move(dir, 80f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(dir, 32f);
				}
				PlaySound("Step", 1);
				PlaySound("Step", 2);
			}
			else if (OnAnm.IsName("Comp|IdleJumpEnd") | OnAnm.IsName("Comp|RunJumpEnd"))
			{
				if (OnAnm.IsName("Comp|RunJumpEnd"))
				{
					Move(dir, 80f);
				}
				body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
				OnJump = false;
				PlaySound("Step", 3);
				PlaySound("Step", 4);
			}
			else if (OnAnm.IsName("Comp|JumpAtk"))
			{
				if (anm.GetInteger("Move").Equals(1) | anm.GetInteger("Move").Equals(2))
				{
					Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 80f);
				}
				OnAttack = true;
				PlaySound("AtkB", 1);
				PlaySound("Bite", 9);
				body.velocity = new Vector3(body.velocity.x, (body.velocity.y > 0f) ? body.velocity.y : 0f, body.velocity.z);
			}
			else if (!anm.GetInteger("Move").Equals(0))
			{
				Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 80f);
			}
		}
		else if (OnAnm.IsName("Comp|Walk"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 20f);
			PlaySound("Step", 8);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Comp|Run") | OnAnm.IsName("Comp|RunGrowl") | OnAnm.IsName("Comp|RunAtk1") | (OnAnm.IsName("Comp|RunAtk2") && (double)OnAnm.normalizedTime < 0.9) | (OnAnm.IsName("Comp|IdleAtk3") && (double)OnAnm.normalizedTime > 0.5 && (double)OnAnm.normalizedTime < 0.9))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 80f);
			if (OnAnm.IsName("Comp|Run"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Comp|RunGrowl"))
			{
				PlaySound("Atk", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Comp|RunAtk1"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Comp|RunAtk2") | OnAnm.IsName("Comp|IdleAtk3"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Step", 4);
				PlaySound("Bite", 9);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Comp|Walk-"))
		{
			Move(-base.transform.forward, 16f);
			PlaySound("Step", 8);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Comp|Strafe-"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 8);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Comp|Strafe+"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 8);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Comp|IdleAtk3"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("Atk", 1);
		}
		else if (OnAnm.IsName("Comp|GroundAtk"))
		{
			OnAttack = true;
			PlaySound("Atk", 2);
			PlaySound("Bite", 4);
		}
		else if (OnAnm.IsName("Comp|IdleAtk1") | OnAnm.IsName("Comp|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("Atk", 2);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Comp|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Comp|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Comp|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Comp|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Bite", 3);
		}
		else if (OnAnm.IsName("Comp|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Comp|IdleB"))
		{
			OnReset = true;
			PlaySound("Atk", 1);
		}
		else if (OnAnm.IsName("Comp|IdleC"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Step", 2);
		}
		else if (OnAnm.IsName("Comp|IdleD"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Comp|IdleE"))
		{
			PlaySound("Call", 1);
			PlaySound("Call", 4);
			PlaySound("Call", 8);
		}
		else if (OnAnm.IsName("Comp|Die-"))
		{
			OnReset = true;
			PlaySound("Atk", 1);
			IsDead = false;
		}
		RotateBone(IkType.SmBiped, 60f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine4.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine5.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Arm1.rotation *= Quaternion.Euler(headY * 8f, 0f, 0f);
			Arm2.rotation *= Quaternion.Euler(0f, headY * 8f, 0f);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.SmBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class DiloLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Tail9;

	public Transform Tail10;

	public Transform Tail11;

	public Transform Arm1;

	public Transform Arm2;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Idlecarn;

	public AudioClip Swallow;

	public AudioClip Bite;

	public AudioClip Dilo1;

	public AudioClip Dilo2;

	public AudioClip Dilo3;

	public AudioClip Dilo4;

	public AudioClip Dilo5;

	public AudioClip Dilo6;

	private Vector3 dir = Vector3.zero;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Dilo3;
			break;
		case 1:
			pain = Dilo4;
			break;
		case 2:
			pain = Dilo5;
			break;
		case 3:
			pain = Dilo6;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Swallow, 0.025f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "AtkA":
		{
			int num3 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num3)
			{
			case 0:
				source[0].PlayOneShot(Dilo4, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Dilo5, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "AtkB":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num2)
			{
			case 0:
				source[0].PlayOneShot(Dilo3, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Dilo6, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Dilo1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Dilo2, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			dir = new Vector3(base.transform.forward.x, 0f, base.transform.forward.z);
		}
		else
		{
			ApplyGravity();
			anm.SetBool("OnGround", value: false);
		}
		if (OnAnm.IsName("Dilo|IdleA") | OnAnm.IsName("Dilo|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Dilo|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("AtkB", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Dilo|IdleJumpStart") | OnAnm.IsName("Dilo|RunJumpStart") | OnAnm.IsName("Dilo|JumpIdle") | OnAnm.IsName("Dilo|IdleJumpEnd") | OnAnm.IsName("Dilo|RunJumpEnd") | OnAnm.IsName("Dilo|JumpAtk"))
		{
			if (OnAnm.IsName("Dilo|IdleJumpStart") | OnAnm.IsName("Dilo|RunJumpStart"))
			{
				if ((double)OnAnm.normalizedTime > 0.4)
				{
					Move(Vector3.up, 3f, jump: true);
				}
				else
				{
					OnJump = true;
				}
				if (anm.GetInteger("Move").Equals(2))
				{
					Move(dir, 160f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(dir, 32f);
				}
				PlaySound("Step", 1);
				PlaySound("Step", 2);
			}
			else if (OnAnm.IsName("Dilo|IdleJumpEnd") | OnAnm.IsName("Dilo|RunJumpEnd"))
			{
				if (OnAnm.IsName("Dilo|RunJumpEnd"))
				{
					Move(dir, 160f);
				}
				body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
				OnJump = false;
				PlaySound("Step", 3);
				PlaySound("Step", 4);
			}
			else if (OnAnm.IsName("Dilo|JumpAtk"))
			{
				if (anm.GetInteger("Move").Equals(1) | anm.GetInteger("Move").Equals(2))
				{
					Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
				}
				OnAttack = true;
				PlaySound("AtkB", 1);
				PlaySound("Bite", 9);
				body.velocity = new Vector3(body.velocity.x, (body.velocity.y > 0f) ? body.velocity.y : 0f, body.velocity.z);
			}
			else if (!anm.GetInteger("Move").Equals(0))
			{
				Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
			}
		}
		else if (OnAnm.IsName("Dilo|Walk") | OnAnm.IsName("Dilo|WalkGrowl"))
		{
			Move(base.transform.forward, 32f);
			if (OnAnm.IsName("Dilo|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
			else if (OnAnm.IsName("Dilo|WalkGrowl"))
			{
				PlaySound("AtkA", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
		}
		else if (OnAnm.IsName("Dilo|Run") | OnAnm.IsName("Dilo|RunGrowl") | OnAnm.IsName("Dilo|RunAtk1") | (OnAnm.IsName("Dilo|RunAtk2") && (double)OnAnm.normalizedTime < 0.9) | (OnAnm.IsName("Dilo|IdleAtk3") && (double)OnAnm.normalizedTime > 0.5 && (double)OnAnm.normalizedTime < 0.9))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 160f);
			if (OnAnm.IsName("Dilo|Run"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Dilo|RunGrowl"))
			{
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Dilo|RunAtk1"))
			{
				OnAttack = true;
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Dilo|RunAtk2") | OnAnm.IsName("Dilo|IdleAtk3"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Step", 4);
				PlaySound("Bite", 9);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Dilo|Walk-") | OnAnm.IsName("Dilo|WalkGrowl-"))
		{
			if ((double)OnAnm.normalizedTime > 0.25 && (((double)OnAnm.normalizedTime < 0.45) | ((double)OnAnm.normalizedTime > 0.75)) && (double)OnAnm.normalizedTime < 0.9)
			{
				Move(-base.transform.forward, 32f);
			}
			if (OnAnm.IsName("Dilo|WalkGrowl-"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
		}
		else if (OnAnm.IsName("Dilo|Strafe-"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Dilo|Strafe+"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Dilo|IdleAtk3"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkA", 1);
		}
		else if (OnAnm.IsName("Dilo|GroundAtk"))
		{
			OnAttack = true;
			PlaySound("AtkB", 2);
			PlaySound("Bite", 4);
		}
		else if (OnAnm.IsName("Dilo|IdleAtk1") | OnAnm.IsName("Dilo|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkA", 2);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Dilo|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Dilo|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Dilo|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Dilo|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Bite", 3);
		}
		else if (OnAnm.IsName("Dilo|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Dilo|IdleC"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Dilo|IdleD"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Dilo|IdleE"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 7);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Dilo|Die-"))
		{
			OnReset = true;
			PlaySound("AtkA", 1);
			IsDead = false;
		}
		RotateBone(IkType.SmBiped, 60f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine4.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine5.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Arm1.rotation *= Quaternion.Euler(headY * 8f, 0f, 0f);
			Arm2.rotation *= Quaternion.Euler(0f, headY * 8f, 0f);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail9.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail10.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail11.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.SmBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class DimeLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idlecarn;

	public AudioClip Dime1;

	public AudioClip Dime2;

	public AudioClip Dime3;

	public AudioClip Dime4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Dime1;
			break;
		case 1:
			pain = Dime2;
			break;
		case 2:
			pain = Dime3;
			break;
		case 3:
			pain = Dime4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.75f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff2, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Dime2, 1f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Dime1, 1f);
			}
			if (num == 1)
			{
				source[0].PlayOneShot(Dime3, 1f);
			}
			else
			{
				source[0].PlayOneShot(Dime4, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Dime|Idle1A") | OnAnm.IsName("Dime|Idle2A") | OnAnm.IsName("Dime|Die1") | OnAnm.IsName("Dime|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Dime|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 1);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Dime|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 1);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Dime|Walk") | OnAnm.IsName("Dime|WalkGrowl") | (OnAnm.IsName("Dime|Step1") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Dime|Step2") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Dime|StepAtk1") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Dime|StepAtk2") && (double)OnAnm.normalizedTime < 0.7) | (OnAnm.IsName("Dime|ToIdle1C") && (double)OnAnm.normalizedTime < 0.7))
		{
			Move(base.transform.forward, 18f);
			if (OnAnm.IsName("Dime|WalkGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Dime|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Dime|StepAtk1") | OnAnm.IsName("Dime|StepAtk2"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 4);
			}
			else
			{
				PlaySound("Step", 8);
			}
		}
		else if (OnAnm.IsName("Dime|Run") | OnAnm.IsName("Dime|RunGrowl") | OnAnm.IsName("Dime|WalkAtk"))
		{
			Move(base.transform.forward, 60f);
			if (OnAnm.IsName("Dime|WalkAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 4);
			}
			else if (OnAnm.IsName("Dime|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Dime|Run"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 8);
			}
		}
		else if (OnAnm.IsName("Dime|Step1-") | OnAnm.IsName("Dime|Step2-") | OnAnm.IsName("Dime|ToSleep2") | OnAnm.IsName("Dime|ToIdle2C") | OnAnm.IsName("Dime|ToEatA") | OnAnm.IsName("Dime|ToEatC"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 8);
		}
		else if (OnAnm.IsName("Dime|Strafe1-") | OnAnm.IsName("Dime|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Dime|Strafe1+") | OnAnm.IsName("Dime|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Dime|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 4);
		}
		else if (OnAnm.IsName("Dime|EatB") | OnAnm.IsName("Dime|EatC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Dime|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Dime|ToSleep1") | OnAnm.IsName("Dime|ToSleep2"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Dime|ToSleep-"))
		{
			IsConstrained = true;
			PlaySound("Sniff", 2);
		}
		else if (OnAnm.IsName("Dime|Idle1B"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Dime|Idle1C"))
		{
			PlaySound("Sniff", 4);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 10);
		}
		else if (OnAnm.IsName("Dime|Idle2B"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Dime|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Dime|Die1-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Dime|Die2-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Convex, 48f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Neck0.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Neck1.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Neck2.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Head.rotation *= Quaternion.Euler(0f, 0f - headY, 0f - headX);
			Spine0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, spineX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.Convex, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand);
		}
	}
}
public class OviLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Tail9;

	public Transform Tail10;

	public Transform Tail11;

	public Transform Arm1;

	public Transform Arm2;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Idlecarn;

	public AudioClip Swallow;

	public AudioClip Bite;

	public AudioClip Ovi1;

	public AudioClip Ovi2;

	public AudioClip Ovi3;

	public AudioClip Ovi4;

	public AudioClip Ovi5;

	public AudioClip Ovi6;

	private Vector3 dir = Vector3.zero;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Ovi1;
			break;
		case 1:
			pain = Ovi2;
			break;
		case 2:
			pain = Ovi3;
			break;
		case 3:
			pain = Ovi5;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Swallow, 0.025f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Call":
			source[0].pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			source[0].PlayOneShot(Ovi4, 1f);
			lastframe = currframe;
			break;
		case "AtkA":
		{
			int num3 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num3 == 0)
			{
				source[0].PlayOneShot(Ovi2, 1f);
			}
			else
			{
				source[0].PlayOneShot(Ovi3, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "AtkB":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Ovi1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Ovi6, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Ovi5, 1f);
			}
			else
			{
				source[0].PlayOneShot(Ovi6, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			dir = new Vector3(base.transform.forward.x, 0f, base.transform.forward.z);
		}
		else
		{
			ApplyGravity();
			anm.SetBool("OnGround", value: false);
		}
		if (OnAnm.IsName("Ovi|IdleA") | OnAnm.IsName("Ovi|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Ovi|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("AtkB", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Ovi|IdleJumpStart") | OnAnm.IsName("Ovi|RunJumpStart") | OnAnm.IsName("Ovi|JumpIdle") | OnAnm.IsName("Ovi|IdleJumpEnd") | OnAnm.IsName("Ovi|RunJumpEnd") | OnAnm.IsName("Ovi|JumpAtk"))
		{
			if (OnAnm.IsName("Ovi|IdleJumpStart") | OnAnm.IsName("Ovi|RunJumpStart"))
			{
				if ((double)OnAnm.normalizedTime > 0.4)
				{
					Move(Vector3.up, 3f, jump: true);
				}
				else
				{
					OnJump = true;
				}
				if (anm.GetInteger("Move").Equals(2))
				{
					Move(dir, 160f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(dir, 32f);
				}
				PlaySound("Step", 1);
				PlaySound("Step", 2);
			}
			else if (OnAnm.IsName("Ovi|IdleJumpEnd") | OnAnm.IsName("Ovi|RunJumpEnd"))
			{
				if (OnAnm.IsName("Ovi|RunJumpEnd"))
				{
					Move(dir, 160f);
				}
				body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
				OnJump = false;
				PlaySound("Step", 3);
				PlaySound("Step", 4);
			}
			else if (OnAnm.IsName("Ovi|JumpAtk"))
			{
				if (anm.GetInteger("Move").Equals(1) | anm.GetInteger("Move").Equals(2))
				{
					Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
				}
				OnAttack = true;
				PlaySound("AtkB", 1);
				PlaySound("Bite", 9);
				body.velocity = new Vector3(body.velocity.x, (body.velocity.y > 0f) ? body.velocity.y : 0f, body.velocity.z);
			}
			else if (!anm.GetInteger("Move").Equals(0))
			{
				Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
			}
		}
		else if (OnAnm.IsName("Ovi|Walk") | OnAnm.IsName("Ovi|WalkGrowl"))
		{
			Move(base.transform.forward, 32f);
			if (OnAnm.IsName("Ovi|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
			else if (OnAnm.IsName("Ovi|WalkGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
		}
		else if (OnAnm.IsName("Ovi|Run") | OnAnm.IsName("Ovi|RunGrowl") | OnAnm.IsName("Ovi|RunAtk1") | (OnAnm.IsName("Ovi|RunAtk2") && (double)OnAnm.normalizedTime < 0.9) | (OnAnm.IsName("Ovi|IdleAtk3") && (double)OnAnm.normalizedTime > 0.5 && (double)OnAnm.normalizedTime < 0.9))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 160f);
			if (OnAnm.IsName("Ovi|Run"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Ovi|RunGrowl"))
			{
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Ovi|RunAtk1"))
			{
				OnAttack = true;
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Ovi|RunAtk2") | OnAnm.IsName("Ovi|IdleAtk3"))
			{
				OnAttack = true;
				PlaySound("AtkA", 2);
				PlaySound("Step", 4);
				PlaySound("Bite", 9);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Ovi|Walk-") | OnAnm.IsName("Ovi|WalkGrowl-"))
		{
			if ((double)OnAnm.normalizedTime > 0.25 && (((double)OnAnm.normalizedTime < 0.45) | ((double)OnAnm.normalizedTime > 0.75)) && (double)OnAnm.normalizedTime < 0.9)
			{
				Move(-base.transform.forward, 32f);
			}
			if (OnAnm.IsName("Ovi|WalkGrowl-"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
		}
		else if (OnAnm.IsName("Ovi|Strafe-"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Ovi|Strafe+"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Ovi|IdleAtk3"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkB", 1);
		}
		else if (OnAnm.IsName("Ovi|GroundAtk"))
		{
			OnAttack = true;
			PlaySound("AtkB", 2);
			PlaySound("Bite", 4);
		}
		else if (OnAnm.IsName("Ovi|IdleAtk1") | OnAnm.IsName("Ovi|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkB", 2);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Ovi|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Ovi|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Ovi|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Ovi|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Bite", 3);
		}
		else if (OnAnm.IsName("Ovi|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Ovi|IdleB"))
		{
			PlaySound("AtkB", 1);
			PlaySound("Bite", 7);
			PlaySound("Bite", 9);
			PlaySound("Bite", 11);
		}
		else if (OnAnm.IsName("Ovi|IdleC"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Ovi|IdleD"))
		{
			PlaySound("Call", 1);
			PlaySound("Call", 4);
			PlaySound("Call", 8);
		}
		else if (OnAnm.IsName("Ovi|IdleE"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 7);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Ovi|Die-"))
		{
			OnReset = true;
			PlaySound("AtkA", 1);
			IsDead = false;
		}
		RotateBone(IkType.SmBiped, 60f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine4.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine5.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Arm1.rotation *= Quaternion.Euler(headY * 8f, 0f, 0f);
			Arm2.rotation *= Quaternion.Euler(0f, headY * 8f, 0f);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail9.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail10.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail11.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.SmBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class ParaLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Para1;

	public AudioClip Para2;

	public AudioClip Para3;

	public AudioClip Para4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Para1;
			break;
		case 1:
			pain = Para2;
			break;
		case 2:
			pain = Para3;
			break;
		case 3:
			pain = Para4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff2, 0.5f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Para1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Para2, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "Call":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Para3, 1f);
			}
			else
			{
				source[0].PlayOneShot(Para4, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7, 4);
		}
		else
		{
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Para|Idle1A") | OnAnm.IsName("Para|Idle2A") | OnAnm.IsName("Para|Die1") | OnAnm.IsName("Para|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Para|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Para|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Para|Walk") | OnAnm.IsName("Para|WalkGrowl") | OnAnm.IsName("Para|Step1") | OnAnm.IsName("Para|Step2") | OnAnm.IsName("Para|ToEatA") | OnAnm.IsName("Para|ToEatC") | OnAnm.IsName("Para|ToIdle1D"))
		{
			if (!(OnAnm.IsName("Para|Step1") | OnAnm.IsName("Para|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Para|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Para|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Para|Run") | OnAnm.IsName("Para|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			Move(base.transform.forward, 80f);
			if (OnAnm.IsName("Para|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
			else
			{
				PlaySound("Step", 5);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Para|Step1-") | OnAnm.IsName("Para|Step2-") | OnAnm.IsName("Para|ToSit1"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Para|Strafe1+") | OnAnm.IsName("Para|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Para|Strafe1-") | OnAnm.IsName("Para|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Para|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Para|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Para|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Para|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Para|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Para|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Para|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Para|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Para|Idle1C"))
		{
			PlaySound("Call", 1);
		}
		else if (OnAnm.IsName("Para|Idle1D"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Para|Idle2B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Para|Idle2C"))
		{
			PlaySound("Call", 2);
		}
		else if (OnAnm.IsName("Para|ToRise1") | OnAnm.IsName("Para|ToRise2"))
		{
			OnReset = true;
			PlaySound("Sniff", 3);
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Para|ToRise1-") | OnAnm.IsName("Para|ToRise2-"))
		{
			OnReset = true;
			PlaySound("Hit", 7);
		}
		else if (OnAnm.IsName("Para|Rise1Growl"))
		{
			OnReset = true;
			PlaySound("Call", 1);
		}
		else if (OnAnm.IsName("Para|Rise2Growl"))
		{
			OnReset = true;
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Para|Rise1Idle") | OnAnm.IsName("Para|Rise2Idle"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Para|Die1-") | OnAnm.IsName("Para|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 50f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(0f, headX, headX);
			Neck1.rotation *= Quaternion.Euler(0f, headX, headX);
			Neck2.rotation *= Quaternion.Euler(headY, headX, headX);
			Neck3.rotation *= Quaternion.Euler(headY * 1.5f, headX, headX);
			Head.rotation *= Quaternion.Euler(headY * 2f, headX, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.5f * size);
		}
	}
}
public class PteraLP : Creature
{
	public Transform Root;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Neck4;

	public Transform Neck5;

	public Transform Neck6;

	public Transform Right_Wing0;

	public Transform Left_Wing0;

	public Transform Right_Wing1;

	public Transform Left_Wing1;

	public Transform Right_Hand;

	public Transform Left_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Wind;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Swallow;

	public AudioClip Idlecarn;

	public AudioClip Bite;

	public AudioClip Sniff2;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Ptera1;

	public AudioClip Ptera2;

	public AudioClip Ptera3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Ptera1;
			break;
		case 1:
			pain = Ptera2;
			break;
		case 2:
			pain = Ptera3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else
			{
				source[1].PlayOneShot(Sniff2, UnityEngine.Random.Range(0.1f, 0.2f));
			}
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Bigstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.25f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Ptera1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Ptera3, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Ptera2, 1f);
			lastframe = currframe;
			break;
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		_ = -Root.right;
		anm.SetBool("OnGround", IsOnGround);
		OnReset = false;
		OnAttack = false;
		IsOnLevitation = false;
		IsConstrained = false;
		OnJump = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsInWater)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
			anm.SetInteger("Move", 1);
		}
		else if (IsOnGround)
		{
			roll = Mathf.Lerp(roll, 0f, 0.1f);
			pitch = Mathf.Lerp(pitch, 0f, 0.1f);
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyYPos();
		}
		else if (Health == 0f)
		{
			body.drag = 4f;
			body.angularDrag = 4f;
			ApplyGravity();
		}
		else
		{
			body.drag = 1f;
			body.angularDrag = 1f;
		}
		if (OnAnm.IsName("Ptera|IdleA") | OnAnm.IsName("Ptera|Die1") | OnAnm.IsName("Ptera|Die2") | OnAnm.IsName("Ptera|Fall"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Ptera|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 1);
					PlaySound("Die", 11);
				}
			}
			else if (OnAnm.IsName("Ptera|Die2"))
			{
				OnReset = true;
				body.velocity = new Vector3(0f, 0f, 0f);
				if (!IsDead)
				{
					PlaySound("Die", 0);
				}
			}
			else if (OnAnm.IsName("Ptera|Fall"))
			{
				OnReset = true;
				IsOnLevitation = true;
				if (IsInWater)
				{
					anm.SetBool("OnGround", value: true);
				}
				if (OnAnm.normalizedTime < 0.1f)
				{
					source[0].PlayOneShot(Ptera2, 1f);
				}
			}
		}
		else if (OnAnm.IsName("Ptera|Walk"))
		{
			Move(base.transform.forward, 10f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Ptera|Run") | OnAnm.IsName("Ptera|FlightToRun") | OnAnm.IsName("Ptera|RunToFlight"))
		{
			IsOnLevitation = true;
			Move(base.transform.forward, 100f);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Ptera|Walk-"))
		{
			Move(-base.transform.forward, 5f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Ptera|Strafe+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Ptera|Strafe-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Ptera|Takeoff"))
		{
			if ((double)OnAnm.normalizedTime > 0.5)
			{
				IsOnLevitation = true;
				OnJump = true;
				Move(Vector3.up, 50f);
			}
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 8);
		}
		else if (OnAnm.IsName("Ptera|Flight") | OnAnm.IsName("Ptera|FlightGrowl") | OnAnm.IsName("Ptera|Glide") | OnAnm.IsName("Ptera|GlideGrowl"))
		{
			IsOnLevitation = true;
			roll = Mathf.Lerp(roll, (0f - spineX) * 10f, Ang_T);
			pitch = Mathf.Lerp(pitch, Mathf.Clamp(anm.GetFloat("Pitch"), -0.75f, 1f) * 90f, Ang_T);
			Move(-Root.right, 200f + Mathf.Abs(anm.GetFloat("Pitch") * 100f));
			if (OnAnm.IsName("Ptera|Flight"))
			{
				PlaySound("Sniff", 5);
				PlaySound("Sniff", 6);
			}
			else if (OnAnm.IsName("Ptera|FlightGrowl"))
			{
				PlaySound("Atk", 3);
				PlaySound("Sniff", 5);
			}
			else if (OnAnm.IsName("Ptera|GlideGrowl"))
			{
				PlaySound("Growl", 2);
			}
		}
		else if (OnAnm.IsName("Ptera|Statio") | OnAnm.IsName("Ptera|StatioGrowl") | OnAnm.IsName("Ptera|IdleD") | OnAnm.IsName("Ptera|FlyAtk"))
		{
			IsOnLevitation = true;
			roll = Mathf.Lerp(roll, 0f, Ang_T);
			pitch = Mathf.Lerp(pitch, 0f, Ang_T);
			Move(Vector3.up, 100f * (0f - anm.GetFloat("Pitch")));
			if (IsOnGround && OnAnm.IsName("Ptera|FlyAtk"))
			{
				Move(Vector3.up, 50f);
			}
			if (anm.GetInteger("Move") > 0 && anm.GetInteger("Move") < 4)
			{
				Move(base.transform.forward, 100f);
			}
			else if (anm.GetInteger("Move") == -1)
			{
				Move(-base.transform.forward, 100f);
			}
			else if (anm.GetInteger("Move") == -10)
			{
				Move(base.transform.right, 100f);
			}
			else if (anm.GetInteger("Move") == 10)
			{
				Move(-base.transform.right, 100f);
			}
			if (OnAnm.IsName("Ptera|StatioGrowl"))
			{
				PlaySound("Atk", 2);
			}
			else if (OnAnm.IsName("Ptera|IdleD"))
			{
				PlaySound("Atk", 2);
				PlaySound("Step", 10);
			}
			else if (OnAnm.IsName("Ptera|FlyAtk"))
			{
				OnAttack = true;
				PlaySound("Atk", 3);
				PlaySound("Bite", 8);
			}
			else
			{
				PlaySound("Sniff", 5);
				PlaySound("Sniff", 6);
			}
		}
		else if (OnAnm.IsName("Ptera|Landing"))
		{
			IsOnLevitation = true;
			PlaySound("Step", 2);
			PlaySound("Step", 3);
		}
		else if (OnAnm.IsName("Ptera|IdleB"))
		{
			PlaySound("Atk", 2);
		}
		else if (OnAnm.IsName("Ptera|IdleC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Ptera|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Ptera|EatB"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Bite", 0);
		}
		else if (OnAnm.IsName("Ptera|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Ptera|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Ptera|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 1);
		}
		else if (OnAnm.IsName("Ptera|Die-"))
		{
			IsConstrained = true;
			PlaySound("Atk", 2);
			IsDead = false;
		}
		if (IsOnLevitation)
		{
			if (!source[2].isPlaying)
			{
				source[2].PlayOneShot(Wind);
			}
			source[2].volume = body.velocity.magnitude / (40f * size);
			source[2].pitch = body.velocity.magnitude / (40f * size);
		}
		else if (source[2].isPlaying)
		{
			source[2].Pause();
		}
		RotateBone(IkType.Flying, 32f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Root.rotation *= Quaternion.Euler(roll, pitch, 0f);
			Right_Wing0.rotation *= Quaternion.Euler(roll / 2f, Mathf.Clamp(roll, -35f, 0f), Mathf.Clamp(0f - pitch, -35f, 0f));
			Left_Wing0.rotation *= Quaternion.Euler(roll / 2f, Mathf.Clamp(0f - roll, -35f, 0f), Mathf.Clamp(pitch, 0f, 35f));
			Right_Wing0.GetChild(0).rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(pitch, 0f, 90f) + Mathf.Abs(roll) / 2f);
			Left_Wing0.GetChild(0).rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(0f - pitch, -90f, 0f) - Mathf.Abs(roll) / 2f);
			Right_Hand.rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(0f - pitch, -90f, 0f) - Mathf.Abs(roll));
			Left_Hand.rotation *= Quaternion.Euler(0f, 0f, Mathf.Clamp(pitch, 0f, 90f) + Mathf.Abs(roll));
			float num = headY * headX / Yaw_Max;
			Neck0.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck1.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck2.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck3.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck4.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck5.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Neck6.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			Head.rotation *= Quaternion.Euler(0f - num, 0f - headY, headX);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f, lastHit, 0f);
			}
			GetGroundPos(IkType.Flying, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Wing0, Right_Wing1, Right_Hand, Left_Wing0, Left_Wing1, Left_Hand);
			anm.SetBool("OnGround", IsOnGround);
		}
	}
}
public class RapLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Spine5;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Tail9;

	public Transform Tail10;

	public Transform Tail11;

	public Transform Arm1;

	public Transform Arm2;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Smallstep;

	public AudioClip Smallsplash;

	public AudioClip Idlecarn;

	public AudioClip Swallow;

	public AudioClip Bite;

	public AudioClip Rap1;

	public AudioClip Rap2;

	public AudioClip Rap3;

	public AudioClip Rap4;

	public AudioClip Rap5;

	public AudioClip Rap6;

	private Vector3 dir = Vector3.zero;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Rap1;
			break;
		case 1:
			pain = Rap2;
			break;
		case 2:
			pain = Rap3;
			break;
		case 3:
			pain = Rap6;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Smallsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Smallstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot(Bite, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(0.8f, 1f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Smallsplash : Smallstep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Swallow, 0.025f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(3f, 3.5f);
			source[0].PlayOneShot(Idlecarn, 0.01f);
			lastframe = currframe;
			break;
		case "Call":
			source[0].pitch = UnityEngine.Random.Range(0.9f, 1.1f);
			source[0].PlayOneShot(Rap4, 1f);
			lastframe = currframe;
			break;
		case "AtkA":
		{
			int num3 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num3 == 0)
			{
				source[0].PlayOneShot(Rap2, 1f);
			}
			else
			{
				source[0].PlayOneShot(Rap3, 1f);
			}
			lastframe = currframe;
			break;
		}
		case "AtkB":
		{
			int num2 = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num2)
			{
			case 0:
				source[0].PlayOneShot(Rap1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Rap6, 1f);
				break;
			default:
				source[0].PlayOneShot(Rap4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Rap5, 1f);
			}
			else
			{
				source[0].PlayOneShot(Rap6, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
			anm.SetBool("OnGround", value: true);
			dir = new Vector3(base.transform.forward.x, 0f, base.transform.forward.z);
		}
		else
		{
			ApplyGravity();
			anm.SetBool("OnGround", value: false);
		}
		if (OnAnm.IsName("Rap|IdleA") | OnAnm.IsName("Rap|Die"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Rap|Die"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("AtkB", 2);
					PlaySound("Die", 12);
				}
			}
		}
		else if (OnAnm.IsName("Rap|IdleJumpStart") | OnAnm.IsName("Rap|RunJumpStart") | OnAnm.IsName("Rap|JumpIdle") | OnAnm.IsName("Rap|IdleJumpEnd") | OnAnm.IsName("Rap|RunJumpEnd") | OnAnm.IsName("Rap|JumpAtk"))
		{
			if (OnAnm.IsName("Rap|IdleJumpStart") | OnAnm.IsName("Rap|RunJumpStart"))
			{
				if ((double)OnAnm.normalizedTime > 0.4)
				{
					Move(Vector3.up, 3f, jump: true);
				}
				else
				{
					OnJump = true;
				}
				if (anm.GetInteger("Move").Equals(2))
				{
					Move(dir, 160f);
				}
				else if (anm.GetInteger("Move").Equals(1))
				{
					Move(dir, 32f);
				}
				PlaySound("Step", 1);
				PlaySound("Step", 2);
			}
			else if (OnAnm.IsName("Rap|IdleJumpEnd") | OnAnm.IsName("Rap|RunJumpEnd"))
			{
				if (OnAnm.IsName("Rap|RunJumpEnd"))
				{
					Move(dir, 160f);
				}
				body.velocity = new Vector3(body.velocity.x, 0f, body.velocity.z);
				OnJump = false;
				PlaySound("Step", 3);
				PlaySound("Step", 4);
			}
			else if (OnAnm.IsName("Rap|JumpAtk"))
			{
				if (anm.GetInteger("Move").Equals(1) | anm.GetInteger("Move").Equals(2))
				{
					Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
				}
				OnAttack = true;
				PlaySound("AtkB", 1);
				PlaySound("Bite", 9);
				body.velocity = new Vector3(body.velocity.x, (body.velocity.y > 0f) ? body.velocity.y : 0f, body.velocity.z);
			}
			else if (!anm.GetInteger("Move").Equals(0))
			{
				Move(Vector3.Lerp(dir, Vector3.zero, 0.5f), 160f);
			}
		}
		else if (OnAnm.IsName("Rap|Walk") | OnAnm.IsName("Rap|WalkGrowl"))
		{
			Move(base.transform.forward, 32f);
			if (OnAnm.IsName("Rap|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
			else if (OnAnm.IsName("Rap|WalkGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 6);
				PlaySound("Step", 14);
			}
		}
		else if (OnAnm.IsName("Rap|Run") | OnAnm.IsName("Rap|RunGrowl") | OnAnm.IsName("Rap|RunAtk1") | (OnAnm.IsName("Rap|RunAtk2") && (double)OnAnm.normalizedTime < 0.9) | (OnAnm.IsName("Rap|IdleAtk3") && (double)OnAnm.normalizedTime > 0.5 && (double)OnAnm.normalizedTime < 0.9))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 15f, 0.1f), -30f, 30f);
			Move(base.transform.forward, 160f);
			if (OnAnm.IsName("Rap|Run"))
			{
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Rap|RunGrowl"))
			{
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Rap|RunAtk1"))
			{
				OnAttack = true;
				PlaySound("AtkB", 2);
				PlaySound("Step", 4);
				PlaySound("Step", 12);
			}
			else if (OnAnm.IsName("Rap|RunAtk2") | OnAnm.IsName("Rap|IdleAtk3"))
			{
				OnAttack = true;
				PlaySound("AtkA", 2);
				PlaySound("Step", 4);
				PlaySound("Bite", 9);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Rap|Walk-") | OnAnm.IsName("Rap|WalkGrowl-"))
		{
			if ((double)OnAnm.normalizedTime > 0.25 && (((double)OnAnm.normalizedTime < 0.45) | ((double)OnAnm.normalizedTime > 0.75)) && (double)OnAnm.normalizedTime < 0.9)
			{
				Move(-base.transform.forward, 32f);
			}
			if (OnAnm.IsName("Rap|WalkGrowl-"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
		}
		else if (OnAnm.IsName("Rap|Strafe-"))
		{
			Move(base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Rap|Strafe+"))
		{
			Move(-base.transform.right, 16f);
			PlaySound("Step", 6);
			PlaySound("Step", 14);
		}
		else if (OnAnm.IsName("Rap|IdleAtk3"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkA", 1);
		}
		else if (OnAnm.IsName("Rap|GroundAtk"))
		{
			OnAttack = true;
			PlaySound("AtkB", 2);
			PlaySound("Bite", 4);
		}
		else if (OnAnm.IsName("Rap|IdleAtk1") | OnAnm.IsName("Rap|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("AtkB", 2);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Rap|ToSleep"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Rap|Sleep"))
		{
			OnReset = true;
			PlaySound("Repose", 1);
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Rap|EatA"))
		{
			IsConstrained = true;
			OnReset = true;
			PlaySound("Food", 1);
		}
		else if (OnAnm.IsName("Rap|EatB"))
		{
			IsConstrained = true;
			OnReset = true;
			PlaySound("Bite", 3);
		}
		else if (OnAnm.IsName("Rap|EatC"))
		{
			IsConstrained = true;
			OnReset = true;
		}
		else if (OnAnm.IsName("Rap|IdleC"))
		{
			PlaySound("Growl", 1);
		}
		else if (OnAnm.IsName("Rap|IdleD"))
		{
			PlaySound("Call", 1);
			PlaySound("Call", 4);
			PlaySound("Call", 8);
		}
		else if (OnAnm.IsName("Rap|IdleE"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 7);
			PlaySound("Bite", 9);
		}
		else if (OnAnm.IsName("Rap|Die-"))
		{
			OnReset = true;
			PlaySound("AtkA", 1);
			IsDead = false;
		}
		RotateBone(IkType.SmBiped, 60f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = (0f - headY) * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine4.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Spine5.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Arm1.rotation *= Quaternion.Euler(headY * 8f, 0f, 0f);
			Arm2.rotation *= Quaternion.Euler(0f, headY * 8f, 0f);
			Neck0.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Head.rotation *= Quaternion.Euler(0f - headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail9.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail10.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail11.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.SmBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class RexLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Largestep;

	public AudioClip Idlecarn;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Sniff1;

	public AudioClip Rex1;

	public AudioClip Rex2;

	public AudioClip Rex3;

	public AudioClip Rex4;

	public AudioClip Rex5;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Rex2;
			break;
		case 1:
			pain = Rex3;
			break;
		case 2:
			pain = Rex4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Bigstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[1].PlayOneShot(Bite, 2f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.5f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.75f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Rex3, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Rex4, 0.5f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Rex1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Rex2, 1f);
				break;
			default:
				source[0].PlayOneShot(Rex5, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Rex|Idle1A") | OnAnm.IsName("Rex|Idle2A") | OnAnm.IsName("Rex|Die1") | OnAnm.IsName("Rex|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Rex|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Rex|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.5 && (OnAnm.IsName("Rex|Step1+") | OnAnm.IsName("Rex|Step2+") | OnAnm.IsName("Rex|ToIdle1C") | OnAnm.IsName("Rex|ToIdle2B") | OnAnm.IsName("Rex|ToIdle2D") | OnAnm.IsName("Rex|ToEatA") | OnAnm.IsName("Rex|ToEatC") | OnAnm.IsName("Rex|StepAtk1") | OnAnm.IsName("Rex|StepAtk2")))
		{
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Rex|Walk") | OnAnm.IsName("Rex|WalkGrowl") | ((double)OnAnm.normalizedTime < 0.5 && (OnAnm.IsName("Rex|Step1+") | OnAnm.IsName("Rex|Step2+") | OnAnm.IsName("Rex|ToIdle2B") | OnAnm.IsName("Rex|ToIdle1C") | OnAnm.IsName("Rex|ToIdle2D") | OnAnm.IsName("Rex|ToEatA") | OnAnm.IsName("Rex|ToEatC"))))
		{
			Move(base.transform.forward, 50f);
			if (OnAnm.IsName("Rex|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Rex|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 8);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Rex|Run") | OnAnm.IsName("Rex|RunGrowl") | OnAnm.IsName("Rex|WalkAtk1") | OnAnm.IsName("Rex|WalkAtk2") | ((double)OnAnm.normalizedTime < 0.6 && (OnAnm.IsName("Rex|StepAtk1") | OnAnm.IsName("Rex|StepAtk2"))))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 5f, 0.05f), -20f, 20f);
			Move(base.transform.forward, 128f);
			if (OnAnm.IsName("Rex|RunGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Rex|Run"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Rex|StepAtk1") | OnAnm.IsName("Rex|StepAtk2"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 5);
			}
			else
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Step", 6);
				PlaySound("Bite", 9);
				PlaySound("Step", 13);
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.4 && (double)OnAnm.normalizedTime < 0.8 && (OnAnm.IsName("Rex|Step1-") | OnAnm.IsName("Rex|Step2-") | OnAnm.IsName("Rex|ToSleep2")))
		{
			Move(-base.transform.forward, 50f);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Rex|Strafe1-") | OnAnm.IsName("Rex|Strafe2+"))
		{
			Move(base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Rex|Strafe1+") | OnAnm.IsName("Rex|Strafe2-"))
		{
			Move(-base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Rex|IdleAtk1") | OnAnm.IsName("Rex|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("Atk", 1);
			PlaySound("Step", 3);
			PlaySound("Bite", 6);
		}
		else if (OnAnm.IsName("Rex|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 4);
			PlaySound("Bite", 5);
		}
		else if (OnAnm.IsName("Rex|EatB") | OnAnm.IsName("Rex|EatC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Rex|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Rex|ToSleep1") | OnAnm.IsName("Rex|ToSleep2"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Rex|ToIdle2A"))
		{
			Move(Vector3.zero);
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Rex|Idle1B"))
		{
			Move(Vector3.zero);
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Rex|Idle1C"))
		{
			Move(Vector3.zero);
			PlaySound("Sniff", 4);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 10);
		}
		else if (OnAnm.IsName("Rex|Idle2B"))
		{
			Move(Vector3.zero);
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 6);
			PlaySound("Bite", 8);
		}
		else if (OnAnm.IsName("Rex|Idle2C"))
		{
			Move(Vector3.zero);
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Rex|Idle2D"))
		{
			Move(Vector3.zero);
			OnReset = true;
			PlaySound("Atk", 2);
		}
		else if (OnAnm.IsName("Rex|Die1-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Rex|Die2-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.LgBiped, 65f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Spine0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Spine2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck1.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Head.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Tail2.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail3.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail4.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail5.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail6.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.LgBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class SpinoLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot0;

	public Transform Right_Foot0;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Bigstep;

	public AudioClip Largesplash;

	public AudioClip Largestep;

	public AudioClip Idlecarn;

	public AudioClip Bite;

	public AudioClip Swallow;

	public AudioClip Sniff1;

	public AudioClip Spino1;

	public AudioClip Spino2;

	public AudioClip Spino3;

	public AudioClip Spino4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Spino1;
			break;
		case 1:
			pain = Spino2;
			break;
		case 2:
			pain = Spino3;
			break;
		case 3:
			pain = Spino4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Largesplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Bigstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Bite":
			source[1].pitch = UnityEngine.Random.Range(0.5f, 0.75f);
			source[1].PlayOneShot(Bite, 2f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Food":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Swallow, 0.1f);
			lastframe = currframe;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			source[0].PlayOneShot(Idlecarn, 0.25f);
			lastframe = currframe;
			break;
		case "Atk":
		{
			int num2 = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(0.75f, 1.75f);
			if (num2 == 0)
			{
				source[0].PlayOneShot(Spino3, 0.5f);
			}
			else
			{
				source[0].PlayOneShot(Spino4, 0.5f);
			}
			lastframe = currframe;
			break;
		}
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 2);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			if (num == 0)
			{
				source[0].PlayOneShot(Spino1, 1f);
			}
			else
			{
				source[0].PlayOneShot(Spino2, 1f);
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Spino|Idle1A") | OnAnm.IsName("Spino|Idle2A") | OnAnm.IsName("Spino|Die1") | OnAnm.IsName("Spino|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Spino|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Spino|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Atk", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.5 && (OnAnm.IsName("Spino|Step1+") | OnAnm.IsName("Spino|Step2+") | OnAnm.IsName("Spino|ToIdle1C") | OnAnm.IsName("Spino|ToIdle2B") | OnAnm.IsName("Spino|ToIdle2D") | OnAnm.IsName("Spino|ToEatA") | OnAnm.IsName("Spino|ToEatC") | OnAnm.IsName("Spino|StepAtk1") | OnAnm.IsName("Spino|StepAtk2")))
		{
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Spino|Walk") | OnAnm.IsName("Spino|WalkGrowl") | ((double)OnAnm.normalizedTime < 0.5 && (OnAnm.IsName("Spino|Step1+") | OnAnm.IsName("Spino|Step2+") | OnAnm.IsName("Spino|ToIdle2B") | OnAnm.IsName("Spino|ToIdle1C") | OnAnm.IsName("Spino|ToIdle2D") | OnAnm.IsName("Spino|ToEatA") | OnAnm.IsName("Spino|ToEatC"))))
		{
			Move(base.transform.forward, 50f);
			if (OnAnm.IsName("Spino|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Spino|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 8);
				PlaySound("Step", 12);
			}
		}
		else if (OnAnm.IsName("Spino|Run") | OnAnm.IsName("Spino|RunGrowl") | OnAnm.IsName("Spino|WalkAtk1") | OnAnm.IsName("Spino|WalkAtk2") | ((double)OnAnm.normalizedTime < 0.6 && (OnAnm.IsName("Spino|StepAtk1") | OnAnm.IsName("Spino|StepAtk2"))))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 5f, 0.05f), -20f, 20f);
			Move(base.transform.forward, 128f);
			if (OnAnm.IsName("Spino|RunGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Spino|Run"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Spino|StepAtk1") | OnAnm.IsName("Spino|StepAtk2"))
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Bite", 5);
			}
			else
			{
				OnAttack = true;
				PlaySound("Atk", 2);
				PlaySound("Step", 6);
				PlaySound("Bite", 9);
				PlaySound("Step", 13);
			}
		}
		else if ((double)OnAnm.normalizedTime > 0.4 && (double)OnAnm.normalizedTime < 0.8 && (OnAnm.IsName("Spino|Step1-") | OnAnm.IsName("Spino|Step2-") | OnAnm.IsName("Spino|ToSleep2")))
		{
			Move(-base.transform.forward, 50f);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Spino|Strafe1-") | OnAnm.IsName("Spino|Strafe2+"))
		{
			Move(base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Spino|Strafe1+") | OnAnm.IsName("Spino|Strafe2-"))
		{
			Move(-base.transform.right, 25f);
			PlaySound("Step", 6);
			PlaySound("Step", 13);
		}
		else if (OnAnm.IsName("Spino|IdleAtk1") | OnAnm.IsName("Spino|IdleAtk2"))
		{
			OnAttack = true;
			Move(Vector3.zero);
			PlaySound("Atk", 1);
			PlaySound("Step", 3);
			PlaySound("Bite", 6);
		}
		else if (OnAnm.IsName("Spino|EatA"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Food", 4);
			PlaySound("Bite", 5);
		}
		else if (OnAnm.IsName("Spino|EatB") | OnAnm.IsName("Spino|EatC"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Spino|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Spino|ToSleep1") | OnAnm.IsName("Spino|ToSleep2"))
		{
			OnReset = true;
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Spino|ToIdle2A"))
		{
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Spino|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Spino|Idle1C"))
		{
			PlaySound("Sniff", 4);
			PlaySound("Sniff", 7);
			PlaySound("Sniff", 10);
		}
		else if (OnAnm.IsName("Spino|Idle2B"))
		{
			OnReset = true;
			PlaySound("Bite", 4);
			PlaySound("Bite", 6);
			PlaySound("Bite", 8);
		}
		else if (OnAnm.IsName("Spino|Idle2C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Spino|Idle2D"))
		{
			OnReset = true;
			PlaySound("Atk", 2);
		}
		else if (OnAnm.IsName("Spino|Die1-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Spino|Die2-"))
		{
			IsConstrained = true;
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.LgBiped, 65f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			Spine0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Spine2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck0.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck1.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Neck2.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Head.rotation *= Quaternion.AngleAxis(headX, Vector3.forward) * Quaternion.AngleAxis(0f - headY, Vector3.right);
			Tail2.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail3.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail4.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail5.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Tail6.rotation *= Quaternion.AngleAxis(0f - spineX, Vector3.forward);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.LgBiped, Right_Hips, Right_Leg, Right_Foot0, Left_Hips, Left_Leg, Left_Foot0);
		}
	}
}
public class StegLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Idleherb;

	public AudioClip Sniff1;

	public AudioClip Chew;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Steg1;

	public AudioClip Steg2;

	public AudioClip Steg3;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 3);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Steg1;
			break;
		case 1:
			pain = Steg2;
			break;
		case 2:
			pain = Steg3;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Hit":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Sniff1, 0.5f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 3);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Steg1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Steg2, 1f);
				break;
			default:
				source[0].PlayOneShot(Steg3, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		anm.SetInteger("Delta", (int)delta);
		OnReset = false;
		OnAttack = false;
		OnTailAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 0, 4, 5, 6);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 0, 4, 5, 6);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Steg|Idle1A") | OnAnm.IsName("Steg|Idle2A") | OnAnm.IsName("Steg|Die1") | OnAnm.IsName("Steg|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Steg|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Steg|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Steg|Walk") | OnAnm.IsName("Steg|WalkGrowl") | OnAnm.IsName("Steg|Step1") | OnAnm.IsName("Steg|Step2") | OnAnm.IsName("Steg|ToIdle2C") | OnAnm.IsName("Steg|ToEatA") | (OnAnm.IsName("Steg|ToEatC") && (double)OnAnm.normalizedTime < 0.9))
		{
			if (!(OnAnm.IsName("Steg|Step1") | OnAnm.IsName("Steg|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 15f);
			}
			if (OnAnm.IsName("Steg|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Steg|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Steg|Run") | OnAnm.IsName("Steg|RunGrowl"))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			Move(base.transform.forward, 60f);
			if (OnAnm.IsName("Steg|Run"))
			{
				PlaySound("Step", 3);
				PlaySound("Step", 9);
			}
			else
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Steg|Step1-") | OnAnm.IsName("Steg|Step2-") | OnAnm.IsName("Steg|ToIdle1C") | OnAnm.IsName("Steg|ToSit1"))
		{
			Move(-base.transform.forward, 15f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Steg|Strafe1-") | OnAnm.IsName("Steg|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Steg|Strafe1+") | OnAnm.IsName("Steg|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Steg|AtkIdle") | OnAnm.IsName("Steg|AtkA") | OnAnm.IsName("Steg|AtkGrowl"))
		{
			OnTailAttack = true;
			Move(Vector3.zero);
			if (OnAnm.IsName("Steg|AtkGrowl"))
			{
				PlaySound("Growl", 2);
			}
			else if (OnAnm.IsName("Steg|AtkA"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Sniff", 3);
			}
		}
		else if (OnAnm.IsName("Steg|AtkB-") | OnAnm.IsName("Steg|AtkB+"))
		{
			OnTailAttack = true;
			Move(Vector3.zero);
			if ((double)OnAnm.normalizedTime < 0.9)
			{
				if (OnAnm.IsName("Steg|AtkB-"))
				{
					base.transform.rotation *= Quaternion.Euler(0f, Mathf.Lerp(0f, -10f, 0.5f), 0f);
				}
				else if (OnAnm.IsName("Steg|AtkB+"))
				{
					base.transform.rotation *= Quaternion.Euler(0f, Mathf.Lerp(0f, 10f, 0.5f), 0f);
				}
				OnAttack = true;
				anm.SetFloat("Turn", base.transform.eulerAngles.y);
			}
			PlaySound("Hit", 8);
			PlaySound("Hit", 10);
			PlaySound("Sniff", 3);
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Steg|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Steg|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Steg|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Steg|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Steg|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Steg|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Steg|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
			PlaySound("Step", 8);
		}
		else if (OnAnm.IsName("Steg|Idle1B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Steg|Idle1C"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Steg|Idle2B"))
		{
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Steg|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Steg|Die1-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Steg|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 40f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = headY * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.5f * size);
		}
	}
}
public class TricLP : Creature
{
	public Transform Spine0;

	public Transform Spine1;

	public Transform Spine2;

	public Transform Spine3;

	public Transform Spine4;

	public Transform Neck0;

	public Transform Neck1;

	public Transform Neck2;

	public Transform Neck3;

	public Transform Tail0;

	public Transform Tail1;

	public Transform Tail2;

	public Transform Tail3;

	public Transform Tail4;

	public Transform Tail5;

	public Transform Tail6;

	public Transform Tail7;

	public Transform Tail8;

	public Transform Left_Arm0;

	public Transform Right_Arm0;

	public Transform Left_Arm1;

	public Transform Right_Arm1;

	public Transform Left_Hand;

	public Transform Right_Hand;

	public Transform Left_Hips;

	public Transform Right_Hips;

	public Transform Left_Leg;

	public Transform Right_Leg;

	public Transform Left_Foot;

	public Transform Right_Foot;

	public AudioClip Waterflush;

	public AudioClip Hit_jaw;

	public AudioClip Hit_head;

	public AudioClip Hit_tail;

	public AudioClip Medstep;

	public AudioClip Medsplash;

	public AudioClip Sniff2;

	public AudioClip Chew;

	public AudioClip Slip;

	public AudioClip Largestep;

	public AudioClip Largesplash;

	public AudioClip Idleherb;

	public AudioClip Tric1;

	public AudioClip Tric2;

	public AudioClip Tric3;

	public AudioClip Tric4;

	private void OnCollisionStay(Collision col)
	{
		int num = UnityEngine.Random.Range(0, 4);
		AudioClip pain = null;
		switch (num)
		{
		case 0:
			pain = Tric1;
			break;
		case 1:
			pain = Tric2;
			break;
		case 2:
			pain = Tric3;
			break;
		case 3:
			pain = Tric4;
			break;
		}
		ManageCollision(col, Pitch_Max, Crouch_Max, source, pain, Hit_jaw, Hit_head, Hit_tail);
	}

	private void PlaySound(string name, int time)
	{
		if ((float)time != currframe || lastframe == currframe || name == null)
		{
			return;
		}
		switch (name)
		{
		case "Step":
			source[1].pitch = UnityEngine.Random.Range(0.75f, 1.25f);
			if (IsInWater)
			{
				source[1].PlayOneShot(Waterflush, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnWater)
			{
				source[1].PlayOneShot(Medsplash, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			else if (IsOnGround)
			{
				source[1].PlayOneShot(Medstep, UnityEngine.Random.Range(0.25f, 0.5f));
			}
			lastframe = currframe;
			break;
		case "Slip":
			source[1].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Slip, 0.5f);
			lastframe = currframe;
			break;
		case "Die":
			source[1].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[1].PlayOneShot((IsOnWater | IsInWater) ? Largesplash : Largestep, 1f);
			lastframe = currframe;
			IsDead = true;
			break;
		case "Sniff":
			source[0].pitch = UnityEngine.Random.Range(1.2f, 1.5f);
			source[0].PlayOneShot(Sniff2, 0.25f);
			lastframe = currframe;
			break;
		case "Chew":
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			source[0].PlayOneShot(Chew, 0.5f);
			lastframe = currframe;
			break;
		case "Repose":
			source[0].pitch = UnityEngine.Random.Range(1.5f, 1.75f);
			source[0].PlayOneShot(Idleherb, 0.25f);
			lastframe = currframe;
			break;
		case "Growl":
		{
			int num = UnityEngine.Random.Range(0, 4);
			source[0].pitch = UnityEngine.Random.Range(1f, 1.25f);
			switch (num)
			{
			case 0:
				source[0].PlayOneShot(Tric1, 1f);
				break;
			case 1:
				source[0].PlayOneShot(Tric2, 1f);
				break;
			case 2:
				source[0].PlayOneShot(Tric3, 1f);
				break;
			default:
				source[0].PlayOneShot(Tric4, 1f);
				break;
			}
			lastframe = currframe;
			break;
		}
		}
	}

	private void FixedUpdate()
	{
		StatusUpdate();
		if (!IsActive | (AnimSpeed == 0f))
		{
			body.Sleep();
			return;
		}
		OnReset = false;
		OnAttack = false;
		IsConstrained = false;
		if (UseAI && Health != 0f)
		{
			AICore(1, 2, 3, 4, 5, 6, 7);
		}
		else if (Health != 0f)
		{
			GetUserInputs(1, 2, 3, 4, 5, 6, 7);
		}
		else
		{
			anm.SetBool("Attack", value: false);
			anm.SetInteger("Move", 0);
			anm.SetInteger("Idle", -1);
		}
		if (IsOnGround | IsInWater | IsOnWater)
		{
			if (!IsOnGround)
			{
				body.drag = 1f;
				body.angularDrag = 1f;
			}
			else
			{
				body.drag = 4f;
				body.angularDrag = 4f;
			}
			ApplyYPos();
		}
		else
		{
			ApplyGravity();
		}
		if (OnAnm.IsName("Tric|Idle1A") | OnAnm.IsName("Tric|Idle2A") | OnAnm.IsName("Tric|Die1") | OnAnm.IsName("Tric|Die2"))
		{
			Move(Vector3.zero);
			if (OnAnm.IsName("Tric|Die1"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 12);
				}
			}
			else if (OnAnm.IsName("Tric|Die2"))
			{
				OnReset = true;
				if (!IsDead)
				{
					PlaySound("Growl", 2);
					PlaySound("Die", 10);
				}
			}
		}
		else if (OnAnm.IsName("Tric|Walk") | OnAnm.IsName("Tric|WalkGrowl") | OnAnm.IsName("Tric|Step1") | OnAnm.IsName("Tric|Step2") | OnAnm.IsName("Tric|ToEatA") | OnAnm.IsName("Tric|ToEatC") | OnAnm.IsName("Tric|ToIdle2C"))
		{
			if (!(OnAnm.IsName("Tric|Step1") | OnAnm.IsName("Tric|Step2")) || !((double)OnAnm.normalizedTime > 0.8))
			{
				Move(base.transform.forward, 18f);
			}
			if (OnAnm.IsName("Tric|WalkGrowl"))
			{
				PlaySound("Growl", 1);
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else if (OnAnm.IsName("Tric|Walk"))
			{
				PlaySound("Step", 6);
				PlaySound("Step", 13);
			}
			else
			{
				PlaySound("Step", 9);
			}
		}
		else if (OnAnm.IsName("Tric|Run") | OnAnm.IsName("Tric|RunGrowl") | OnAnm.IsName("Tric|StepAtk1") | OnAnm.IsName("Tric|StepAtk2") | OnAnm.IsName("Tric|RunAtk1") | (OnAnm.IsName("Tric|RunAtk2") && (double)OnAnm.normalizedTime < 0.5))
		{
			roll = Mathf.Clamp(Mathf.Lerp(roll, spineX * 10f, 0.1f), -20f, 20f);
			if ((OnAnm.IsName("Tric|StepAtk1") | OnAnm.IsName("Tric|StepAtk2")) && (double)OnAnm.normalizedTime > 0.3)
			{
				Move(Vector3.zero);
			}
			else
			{
				Move(base.transform.forward, 100f);
			}
			if (OnAnm.IsName("Tric|Run"))
			{
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
			else if (OnAnm.IsName("Tric|RunGrowl"))
			{
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
			else if (OnAnm.IsName("Tric|RunAtk2"))
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Slip", 6);
			}
			else
			{
				OnAttack = true;
				PlaySound("Growl", 2);
				PlaySound("Step", 3);
				PlaySound("Step", 6);
			}
		}
		else if (OnAnm.IsName("Tric|Step1-") | OnAnm.IsName("Tric|Step2-") | OnAnm.IsName("Tric|ToSit1") | OnAnm.IsName("Tric|ToIdle1C") | OnAnm.IsName("Tric|ToIdle1D"))
		{
			Move(-base.transform.forward, 10f);
			PlaySound("Step", 9);
		}
		else if (OnAnm.IsName("Tric|Strafe1-") | OnAnm.IsName("Tric|Strafe2+"))
		{
			Move(base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Tric|Strafe1+") | OnAnm.IsName("Tric|Strafe2-"))
		{
			Move(-base.transform.right, 8f);
			PlaySound("Step", 5);
			PlaySound("Step", 12);
		}
		else if (OnAnm.IsName("Tric|EatA"))
		{
			PlaySound("Chew", 10);
		}
		else if (OnAnm.IsName("Tric|EatB"))
		{
			PlaySound("Chew", 1);
			PlaySound("Chew", 4);
			PlaySound("Chew", 8);
			PlaySound("Chew", 12);
		}
		else if (OnAnm.IsName("Tric|EatC"))
		{
			OnReset = true;
		}
		else if (OnAnm.IsName("Tric|ToSit"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Tric|SitIdle"))
		{
			IsConstrained = true;
		}
		else if (OnAnm.IsName("Tric|Sleep"))
		{
			OnReset = true;
			IsConstrained = true;
			PlaySound("Repose", 2);
		}
		else if (OnAnm.IsName("Tric|SitGrowl"))
		{
			IsConstrained = true;
			PlaySound("Growl", 2);
		}
		else if (OnAnm.IsName("Tric|Idle1B"))
		{
			PlaySound("Growl", 2);
			PlaySound("Slip", 3);
		}
		else if (OnAnm.IsName("Tric|Idle1C"))
		{
			PlaySound("Growl", 2);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
			PlaySound("Sniff", 9);
		}
		else if (OnAnm.IsName("Tric|Idle1D"))
		{
			PlaySound("Sniff", 1);
			PlaySound("Growl", 4);
			PlaySound("Step", 9);
			PlaySound("Step", 11);
		}
		else if (OnAnm.IsName("Tric|Idle2B"))
		{
			PlaySound("Growl", 2);
			PlaySound("Slip", 3);
		}
		else if (OnAnm.IsName("Tric|Idle2C"))
		{
			OnReset = true;
			PlaySound("Sniff", 1);
		}
		else if (OnAnm.IsName("Tric|IdleAtk1") | OnAnm.IsName("Tric|IdleAtk2"))
		{
			OnAttack = true;
			PlaySound("Growl", 2);
			PlaySound("Step", 5);
			PlaySound("Step", 6);
		}
		else if (OnAnm.IsName("Tric|Die1-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		else if (OnAnm.IsName("Tric|Die2-"))
		{
			PlaySound("Growl", 3);
			IsDead = false;
		}
		RotateBone(IkType.Quad, 55f);
	}

	private void LateUpdate()
	{
		if (IsActive)
		{
			HeadPos = Head.GetChild(0).GetChild(0).position;
			float y = headY * headX / Yaw_Max;
			Spine0.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine1.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine2.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine3.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Spine4.rotation *= Quaternion.Euler(0f, 0f, spineX);
			Neck0.rotation *= Quaternion.Euler(headY, y, headX);
			Neck1.rotation *= Quaternion.Euler(headY, y, headX);
			Neck2.rotation *= Quaternion.Euler(headY, y, headX);
			Neck3.rotation *= Quaternion.Euler(headY, y, headX);
			Head.rotation *= Quaternion.Euler(headY, y, headX);
			Tail0.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail1.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail2.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail3.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail4.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail5.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail6.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail7.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Tail8.rotation *= Quaternion.Euler(0f, 0f, 0f - spineX);
			Right_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Hips.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Right_Arm0.rotation *= Quaternion.Euler(0f - roll, 0f, 0f);
			Left_Arm1.rotation *= Quaternion.Euler(0f, roll, 0f);
			if (!IsDead)
			{
				Head.GetChild(0).transform.rotation *= Quaternion.Euler(0f - lastHit, 0f, 0f);
			}
			GetGroundPos(IkType.Quad, Right_Hips, Right_Leg, Right_Foot, Left_Hips, Left_Leg, Left_Foot, Right_Arm0, Right_Arm1, Right_Hand, Left_Arm0, Left_Arm1, Left_Hand, -0.5f * size);
		}
	}
}
public class AnimationControl : MonoBehaviour
{
	private string currentAnimation = "";

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void SetAnimation(string animationName)
	{
		if (currentAnimation != "")
		{
			GetComponent<Animator>().SetBool(currentAnimation, value: false);
		}
		GetComponent<Animator>().SetBool(animationName, value: true);
		currentAnimation = animationName;
	}

	public void SetAnimationIdle()
	{
		if (currentAnimation != "")
		{
			GetComponent<Animator>().SetBool(currentAnimation, value: false);
		}
	}

	public void SetDeathAnimation(int numOfClips)
	{
		int num = UnityEngine.Random.Range(0, numOfClips);
		string text = "Death";
		UnityEngine.Debug.Log(num);
		GetComponent<Animator>().SetInteger(text, num);
	}
}
public class DeathButtonControl : MonoBehaviour
{
	public int countOfAnimations;

	public Button button;

	private void Start()
	{
		for (int i = 0; i < countOfAnimations; i++)
		{
			float y = button.GetComponent<RectTransform>().sizeDelta.y;
			Vector2 vector = new Vector2(0f, 115f + y * (float)i);
			Button obj = UnityEngine.Object.Instantiate(button, vector, Quaternion.identity);
			RectTransform component = obj.GetComponent<RectTransform>();
			obj.transform.SetParent(base.transform);
			component.anchoredPosition = vector;
		}
	}

	private void Update()
	{
	}
}
public class KillSwitch : MonoBehaviour
{
	private Animator anim;

	private void Start()
	{
		anim = GetComponent<Animator>();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			anim.SetBool("isDead", value: true);
		}
	}
}
public class PanelControll : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public void PanelToggle()
	{
		if (base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: false);
		}
		else
		{
			base.gameObject.SetActive(value: true);
		}
	}
}
public class PeriodicShake : MonoBehaviour
{
	public float duration = 0.5f;

	public float speed = 3f;

	public float magnitude = 0.1f;

	public bool test;

	public void PlayShake()
	{
		StopAllCoroutines();
		StartCoroutine("Shake");
	}

	private void Update()
	{
		if (test)
		{
			test = false;
			PlayShake();
		}
	}

	private IEnumerator Shake()
	{
		float elapsed = 0f;
		float randomStartX = UnityEngine.Random.Range(-1000f, 1000f);
		float randomStartY = UnityEngine.Random.Range(-1000f, 1000f);
		Vector3 originalCamPos = Camera.main.transform.position;
		while (elapsed < duration)
		{
			elapsed += Time.deltaTime;
			float num = elapsed / duration;
			float num2 = 1f - Mathf.Clamp(4f * num - 3f, 0f, 1f);
			float num3 = Mathf.Sin(randomStartX + num * speed);
			float num4 = Mathf.Cos(randomStartY + num * speed);
			num3 *= magnitude * num2;
			num4 *= magnitude * num2;
			Camera.main.transform.position = new Vector3(num3, num4, originalCamPos.z);
			yield return null;
		}
		Camera.main.transform.position = originalCamPos;
	}
}
public class Player : MonoBehaviour
{
	private Animator anim;

	private CharacterController controller;

	public float speed = 600f;

	public float turnSpeed = 400f;

	private Vector3 moveDirection = Vector3.zero;

	public float gravity = 20f;

	private void Start()
	{
		controller = GetComponent<CharacterController>();
		anim = base.gameObject.GetComponentInChildren<Animator>();
	}

	private void Update()
	{
		if (Input.GetKey("w"))
		{
			anim.SetInteger("AnimationPar", 1);
		}
		else
		{
			anim.SetInteger("AnimationPar", 0);
		}
		if (controller.isGrounded)
		{
			moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
		}
		float axis = Input.GetAxis("Horizontal");
		base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
		controller.Move(moveDirection * Time.deltaTime);
		moveDirection.y -= gravity * Time.deltaTime;
	}
}
public class ThirdPersonCamera : MonoBehaviour
{
	private const float Y_ANGLE_MIN = 0f;

	private const float Y_ANGLE_MAX = 50f;

	public Transform lookAt;

	public Transform camTransform;

	public float distance = 5f;

	private float currentX;

	private float currentY = 45f;

	private float sensitivityX = 20f;

	private float sensitivityY = 20f;

	private void Start()
	{
		camTransform = base.transform;
	}

	private void Update()
	{
		currentX += Input.GetAxis("Mouse X");
		currentY += Input.GetAxis("Mouse Y");
		currentY = Mathf.Clamp(currentY, 0f, 50f);
	}

	private void LateUpdate()
	{
		Vector3 vector = new Vector3(0f, 0f, 0f - distance);
		Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
		camTransform.position = lookAt.position + quaternion * vector;
		camTransform.LookAt(lookAt.position);
	}
}
public class CameraMovement : MonoBehaviour
{
	[SerializeField]
	private float lookSpeedH = 2f;

	[SerializeField]
	private float lookSpeedV = 2f;

	[SerializeField]
	private float zoomSpeed = 2f;

	[SerializeField]
	private float dragSpeed = 3f;

	private float yaw;

	private float pitch;

	private void Start()
	{
		yaw = base.transform.eulerAngles.y;
		pitch = base.transform.eulerAngles.x;
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.LeftAlt))
		{
			if (Input.GetMouseButton(0))
			{
				yaw += lookSpeedH * Input.GetAxis("Mouse X");
				pitch -= lookSpeedV * Input.GetAxis("Mouse Y");
				base.transform.eulerAngles = new Vector3(pitch, yaw, 0f);
			}
			if (Input.GetMouseButton(2))
			{
				base.transform.Translate((0f - Input.GetAxisRaw("Mouse X")) * Time.deltaTime * dragSpeed, (0f - Input.GetAxisRaw("Mouse Y")) * Time.deltaTime * dragSpeed, 0f);
			}
			if (Input.GetMouseButton(1))
			{
				base.transform.Translate(0f, 0f, Input.GetAxisRaw("Mouse X") * zoomSpeed * 0.07f, Space.Self);
			}
			base.transform.Translate(0f, 0f, Input.GetAxis("Mouse ScrollWheel") * zoomSpeed, Space.Self);
		}
	}
}
public class Character_control : MonoBehaviour
{
	public int animation_num;

	private Animator animator;

	private void Start()
	{
		animator = GetComponent<Animator>();
		animator.SetBool("animation_" + animation_num, value: true);
	}

	private void Update()
	{
	}
}
public class CheckForDuplicates : MonoBehaviour
{
	[Button(null, EButtonEnableMode.Always)]
	public void Check()
	{
		MeshFilter[] array = UnityEngine.Object.FindObjectsOfType<MeshFilter>();
		MeshFilter[] array2 = array;
		foreach (MeshFilter meshFilter in array2)
		{
			MeshFilter[] array3 = array;
			foreach (MeshFilter meshFilter2 in array3)
			{
				if (!(meshFilter == meshFilter2) && !(Vector3.Distance(meshFilter.transform.position, meshFilter2.transform.position) > 0.01f) && !(meshFilter.transform.rotation * Quaternion.Inverse(meshFilter2.transform.rotation) != Quaternion.identity) && !(meshFilter.sharedMesh != meshFilter2.sharedMesh))
				{
					UnityEngine.Debug.LogError("1: " + meshFilter.name + "\n", meshFilter);
					UnityEngine.Debug.LogError("1: " + meshFilter2.name + "\n", meshFilter2);
					UnityEngine.Debug.LogError("========================\n");
				}
			}
		}
	}
}
public class DemoCamera : MonoBehaviour
{
	[Tooltip("Local space motion direction")]
	public Vector3 motionDir = Vector3.forward;

	[Tooltip("Speed the camera should move at in units per second")]
	public float speed = 1f;

	[Tooltip("Time this camera should be active before moving to the next")]
	public float time = 5f;

	[Tooltip("Camera to activate after this one")]
	public DemoCamera nextCamera;

	private Vector3 startPos;

	private float timer;

	private void Start()
	{
		timer = 0f;
		startPos = base.transform.position;
	}

	private void Update()
	{
		timer += Time.deltaTime;
		base.transform.Translate(motionDir * speed * Time.deltaTime, Space.Self);
		if (timer > time && nextCamera != null)
		{
			base.gameObject.SetActive(value: false);
			nextCamera.gameObject.SetActive(value: true);
			timer = 0f;
			base.transform.position = startPos;
		}
	}
}
public class GodRays : MonoBehaviour
{
	[Range(0f, 10f)]
	public float animSpeed = 3f;

	public float fadeDistanceStart = 10f;

	public float fadeDistanceEnd = 5f;

	private Material mat;

	private int fadeId;

	private int yOffsetId;

	private float yOffset;

	private void Start()
	{
		mat = GetComponent<Renderer>().material;
		fadeId = Shader.PropertyToID("_Fade");
		yOffsetId = Shader.PropertyToID("_YOffset");
	}

	private void Update()
	{
		Vector3 position = Camera.main.transform.position;
		Vector3 position2 = base.transform.position;
		Vector3 up = base.transform.up;
		Vector3 forward = position2 + up * Vector3.Dot(position - position2, up) - position;
		base.transform.rotation = Quaternion.LookRotation(forward, base.transform.up);
		float num = Mathf.Clamp01((forward.magnitude - fadeDistanceEnd) / (fadeDistanceStart - fadeDistanceEnd));
		mat.SetFloat(fadeId, 1f - num);
		yOffset += 0.01f * Time.deltaTime * animSpeed;
		yOffset = Mathf.Repeat(yOffset, 1f);
		mat.SetFloat(yOffsetId, yOffset);
	}
}
public class ModularTerrainCameraControl : MonoBehaviour
{
	[Range(-100f, 100f)]
	public float cameraMoveSpeed_x;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_y;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cameraMoveSpeed_x * Time.deltaTime, cameraMoveSpeed_y * Time.deltaTime, cameraMoveSpeed_z * Time.deltaTime);
	}
}
public class ModularTerrainCloudsControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_x;

	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cloudsMoveSpeed_x * Time.deltaTime, 0f, cloudsMoveSpeed_z * Time.deltaTime);
	}
}
public class ModularTerrainSunControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float sunRotationSpeed_x;

	[Range(-10f, 10f)]
	public float sunRotationSpeed_y;

	private void Update()
	{
		base.gameObject.transform.Rotate(sunRotationSpeed_x * Time.deltaTime, sunRotationSpeed_y * Time.deltaTime, 0f);
	}
}
public class LowPolyRocks_CameraControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float cameraMoveSpeed_x;

	[Range(-10f, 10f)]
	public float cameraMoveSpeed_y;

	[Range(-10f, 10f)]
	public float cameraMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cameraMoveSpeed_x * Time.deltaTime, cameraMoveSpeed_y * Time.deltaTime, cameraMoveSpeed_z * Time.deltaTime);
	}
}
public class LowPolyRocks_CloudsControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_x;

	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cloudsMoveSpeed_x * Time.deltaTime, 0f, cloudsMoveSpeed_z * Time.deltaTime);
	}
}
public class LowPolyRocks_FireLightControl : MonoBehaviour
{
	private Light fireLight;

	[Range(0f, 8f)]
	public float minIntensity = 1.5f;

	[Range(0f, 8f)]
	public float maxIntensity = 2.5f;

	private float randomValue;

	private void Start()
	{
		fireLight = GetComponent<Light>();
		randomValue = UnityEngine.Random.Range(0f, 65000f);
	}

	private void Update()
	{
		float t = Mathf.PerlinNoise(randomValue, Time.time);
		fireLight.intensity = Mathf.Lerp(minIntensity, maxIntensity, t);
	}
}
public class LowPolyRocks_SunControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float sunRotationSpeed_x;

	[Range(-10f, 10f)]
	public float sunRotationSpeed_y;

	private void Update()
	{
		base.gameObject.transform.Rotate(sunRotationSpeed_x * Time.deltaTime, sunRotationSpeed_y * Time.deltaTime, 0f);
	}
}
public class LowPolyTrees_CameraControl : MonoBehaviour
{
	[Range(-100f, 100f)]
	public float cameraMoveSpeed_x;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_y;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cameraMoveSpeed_x * Time.deltaTime, cameraMoveSpeed_y * Time.deltaTime, cameraMoveSpeed_z * Time.deltaTime);
	}
}
public class LowPolyTrees_CloudsControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_x;

	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cloudsMoveSpeed_x * Time.deltaTime, 0f, cloudsMoveSpeed_z * Time.deltaTime);
	}
}
public class LowPolyTrees_SunControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float sunRotationSpeed_x;

	[Range(-10f, 10f)]
	public float sunRotationSpeed_y;

	private void Update()
	{
		base.gameObject.transform.Rotate(sunRotationSpeed_x * Time.deltaTime, sunRotationSpeed_y * Time.deltaTime, 0f);
	}
}
public class LowPolyVegetation_CameraControl : MonoBehaviour
{
	[Range(-100f, 100f)]
	public float cameraMoveSpeed_x;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_y;

	[Range(-100f, 100f)]
	public float cameraMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cameraMoveSpeed_x * Time.deltaTime, cameraMoveSpeed_y * Time.deltaTime, cameraMoveSpeed_z * Time.deltaTime);
	}
}
public class LowPolyVegetation_CloudsControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_x;

	[Range(-10f, 10f)]
	public float cloudsMoveSpeed_z;

	private void Update()
	{
		base.gameObject.transform.Translate(cloudsMoveSpeed_x * Time.deltaTime, 0f, cloudsMoveSpeed_z * Time.deltaTime);
	}
}
public class LowPolyVegetation_SunControl : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float sunRotationSpeed_x;

	[Range(-10f, 10f)]
	public float sunRotationSpeed_y;

	private void Update()
	{
		base.gameObject.transform.Rotate(sunRotationSpeed_x * Time.deltaTime, sunRotationSpeed_y * Time.deltaTime, 0f);
	}
}
public class QT_InteractContainer : MonoBehaviour
{
	public GameObject ContainerTop;

	public string OpenText = "Press E to Open.";

	public string CloseText = "Press E to Close.";

	public AnimationClip OpenClip;

	public AnimationClip CloseClip;

	private Vector3 centerScreen;

	private bool isOpen;

	private Animator Anim;

	private void Start()
	{
		centerScreen = new Vector3(0.5f, 0.5f, 0f);
		Anim = ContainerTop.GetComponent<Animator>();
	}

	private void OnTriggerStay()
	{
		Vector3 origin = Camera.main.ViewportToWorldPoint(centerScreen);
		Vector3 forward = Camera.main.transform.forward;
		if (!Physics.Raycast(origin, forward, out var hitInfo, 5f))
		{
			return;
		}
		if (hitInfo.collider.name.Equals(ContainerTop.name) && !isOpen)
		{
			if (Input.GetKeyDown(KeyCode.E))
			{
				Anim.Play(OpenClip.name);
				isOpen = true;
			}
		}
		else if (hitInfo.collider.name.Equals(ContainerTop.name) && isOpen && Input.GetKeyDown(KeyCode.E))
		{
			Anim.Play(CloseClip.name);
			isOpen = false;
		}
	}

	private void OnTriggerExit()
	{
	}
}
public class QT_LightFlicker : MonoBehaviour
{
	public float minFlickerSpeed = 0.01f;

	public float maxFlickerSpeed = 0.1f;

	public float minLightIntensity = 0.7f;

	public float maxLightIntensity = 1f;

	private void Start()
	{
		StartCoroutine(Flicker());
	}

	private IEnumerator Flicker()
	{
		while (true)
		{
			GetComponent<Light>().intensity = UnityEngine.Random.Range(minLightIntensity, maxLightIntensity);
			yield return new WaitForSeconds(UnityEngine.Random.Range(minFlickerSpeed, maxFlickerSpeed));
		}
	}
}
[ExecuteInEditMode]
public class QT_ModifyColor : MonoBehaviour
{
	public bool Replace = true;

	public string meshFileName = "new mesh";

	public string newPrefabName = "";

	public QT_MCChannels[] AllChannels = new QT_MCChannels[6];

	public Color[] tempColors = new Color[6];

	[HideInInspector]
	public float[] tempSmoothness = new float[6];

	[HideInInspector]
	public float[] tempMetallic = new float[6];

	public float globalAlpha = 1f;

	public float Contrast = 0.5f;

	public float Shadows = 1f;

	public float MidTones = 1f;

	public float Highlights;

	public float ContrastClamp1;

	public float ContrastClamp2 = 1f;

	public bool preserveShading;

	[HideInInspector]
	public Color[] originalVCs;

	[HideInInspector]
	public Vector3[] originalVC_HSVs;

	[HideInInspector]
	public float[] originalValues;

	[HideInInspector]
	public float[] newValues;

	[HideInInspector]
	public float[] newShading;

	[HideInInspector]
	public bool isPWMesh;

	public bool hasCollider;

	public bool isSaving;

	public bool pwMeshOverride;

	public bool updateMeshCollider = true;

	public bool isSM;

	public bool isMesh;

	public Mesh mesh;

	public Mesh tempMesh;

	public MeshFilter sourceMF;

	public SkinnedMeshRenderer sourceSMR;

	[HideInInspector]
	public bool isPrefab;

	public void AssignVCs(Color32[] c)
	{
		tempMesh.colors32 = c;
	}

	public void AssignVCs(Color[] c)
	{
		tempMesh.colors = c;
	}

	public void AssignUV4s(Vector2[] v)
	{
		tempMesh.uv4 = v;
	}

	public void AssignVCs(float[] v)
	{
		Color32[] array = new Color32[tempMesh.colors32.Length];
		for (int i = 0; i < tempMesh.colors32.Length; i++)
		{
			array[i].r = (byte)(v[i] * 255f);
			array[i].g = (byte)(v[i] * 255f);
			array[i].b = (byte)(v[i] * 255f);
			array[i].a = mesh.colors32[i].a;
		}
		tempMesh.colors32 = array;
	}

	private void Awake()
	{
		for (int i = 0; i < AllChannels.Length; i++)
		{
			AllChannels[i] = new QT_MCChannels();
		}
		tempColors[0] = new Color(0.47f, 0.439f, 0.372f);
		tempColors[1] = new Color(0.309f, 0.243f, 0.176f);
		tempColors[2] = new Color(0.439f, 0.372f, 0.301f);
		tempColors[3] = new Color(0.239f, 0.239f, 0.239f);
		tempColors[4] = new Color(0.384f, 0.384f, 0.384f);
		tempColors[5] = new Color(0.243f, 0.2f, 0.137f);
		AllChannels[0].Color = new float[4] { 0.47f, 0.439f, 0.372f, 1f };
		AllChannels[1].Color = new float[4] { 0.309f, 0.243f, 0.176f, 1f };
		AllChannels[2].Color = new float[4] { 0.439f, 0.372f, 0.301f, 1f };
		AllChannels[3].Color = new float[4] { 0.239f, 0.239f, 0.239f, 1f };
		AllChannels[4].Color = new float[4] { 0.384f, 0.384f, 0.384f, 1f };
		AllChannels[5].Color = new float[4] { 0.243f, 0.2f, 0.137f, 1f };
	}

	private void Start()
	{
		meshFileName = base.gameObject.name + "-Colored";
		newPrefabName = base.gameObject.transform.root.gameObject.name;
	}

	public float[] RemapFloats(float[] v, float high, float low)
	{
		float[] array = new float[v.Length];
		float num = ((IEnumerable<float>)v).Max<float>();
		float num2 = ((IEnumerable<float>)v).Min<float>();
		float num3 = num - num2;
		float num4 = high - low;
		for (int i = 0; i < v.Length; i++)
		{
			array[i] = (v[i] - num2) * num4 / num3 + low;
			Mathf.Clamp01(array[i]);
		}
		return array;
	}

	public void CleanUp()
	{
		tempMesh = null;
		mesh = null;
		for (int i = 0; i < AllChannels.Length; i++)
		{
			AllChannels[i].Color = new float[4] { 0f, 0f, 0f, 1f };
			AllChannels[i].sampledColor = new Color(0f, 0f, 0f, 1f);
			AllChannels[i].targetVertices = null;
		}
	}
}
public class QT_MCChannels
{
	public float[] Color = new float[4] { 0f, 0f, 0f, 1f };

	public Color sampledColor = new Color(1f, 0f, 1f, 0.123f);

	public List<int> targetVertices = new List<int>();

	public float hueRange = 0.5f;

	public float valRange = 0.25f;

	public float satRange = 0.5f;

	public float Smoothness;

	public float Metallic;
}
[ExecuteInEditMode]
public class QT_PolyWorldTerrain : MonoBehaviour
{
}
public class QT_SimpleRotate : MonoBehaviour
{
	public bool XAxis;

	public bool YAxis;

	public bool ZAxis;

	public float Speed = 25f;

	private Vector3 rotationAxis = new Vector3(0f, 0f, 0f);

	private void Start()
	{
		if (XAxis)
		{
			rotationAxis += new Vector3(1f, 0f, 0f);
		}
		if (YAxis)
		{
			rotationAxis += new Vector3(0f, 1f, 0f);
		}
		if (ZAxis)
		{
			rotationAxis += new Vector3(0f, 0f, 1f);
		}
	}

	private void FixedUpdate()
	{
		if (rotationAxis != Vector3.zero)
		{
			base.transform.Rotate(rotationAxis * Time.deltaTime * Speed);
		}
	}
}
public class QT_SurfaceNoise : MonoBehaviour
{
	public float baseWaveSpeed = 0.02f;

	public float waveScale = 2.0105f;

	public float speedMultiplier = 15f;

	public float strengthMultiplier = 1f;

	public float baseNoiseStrength = 0.03f;

	public bool RecalculateNormals;

	public bool useVertexAlpha;

	public bool enableMultiMesh;

	public bool useOverride;

	public bool enableDebug = true;

	public bool enableOffset;

	public bool enableLOD;

	public int LODDistance = 50;

	public int scaleMultiplier = 1;

	private Vector3[] baseHeight;

	private Vector3[] baseHeightWorld;

	private Vector3[] newVerts;

	private Vector3 vertex;

	public bool ZAxis = true;

	public bool XAxis;

	public bool YAxis;

	public bool showDebugSphere;

	public Camera TargetCamera;

	private Mesh[] meshes;

	private List<Vector3[]> allBaseVertices;

	private List<Color[]> allBaseVertexAlphas;

	private float[] randomOffsets;

	private bool isStatic;

	private void Start()
	{
		MeshFilter[] componentsInChildren = base.gameObject.GetComponentsInChildren<MeshFilter>(includeInactive: false);
		meshes = new Mesh[componentsInChildren.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			meshes[i] = componentsInChildren[i].mesh;
		}
		if (enableMultiMesh)
		{
			allBaseVertices = new List<Vector3[]>(meshes.Length);
			allBaseVertexAlphas = new List<Color[]>(meshes.Length);
			if (enableOffset)
			{
				randomOffsets = new float[meshes.Length];
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				allBaseVertices.Add(meshes[j].vertices);
				allBaseVertexAlphas.Add(meshes[j].colors);
				if (enableOffset)
				{
					randomOffsets[j] = UnityEngine.Random.Range(2, 6);
				}
			}
		}
		else
		{
			allBaseVertexAlphas = new List<Color[]>();
			baseHeight = meshes[0].vertices;
			allBaseVertexAlphas.Add(meshes[0].colors);
			newVerts = new Vector3[baseHeight.Length];
		}
		if (TargetCamera == null)
		{
			UnityEngine.Debug.LogWarning("No Camera Chosen. SurfaceNoise LOD will not run on GameObject: " + base.gameObject.name);
		}
		for (int k = 0; k < componentsInChildren.Length; k++)
		{
			if (componentsInChildren[k].gameObject.isStatic)
			{
				isStatic = true;
				break;
			}
		}
	}

	private void OnRenderObject()
	{
		if (!isStatic)
		{
			if (TargetCamera != null)
			{
				if (enableLOD)
				{
					if (Vector3.Distance(base.transform.position, TargetCamera.transform.position) < (float)LODDistance)
					{
						RunWave();
					}
				}
				else
				{
					RunWave();
				}
			}
			else
			{
				UnityEngine.Debug.LogError("No camera is found for SurfaceNoise.");
			}
		}
		else
		{
			UnityEngine.Debug.LogError("One or more meshes in " + base.gameObject.name + "'s hierarchy is tagged static. SurfaceNoise requires all objects to be not tagged static.");
		}
	}

	private void RunWave()
	{
		float num = Time.time;
		float num2 = speedMultiplier * baseWaveSpeed;
		float num3 = strengthMultiplier * baseNoiseStrength;
		if (enableMultiMesh)
		{
			int count = allBaseVertices.Count;
			for (int i = 0; i < count; i++)
			{
				if (enableOffset)
				{
					num += randomOffsets[i];
				}
				Vector3[] array = new Vector3[allBaseVertices[i].Length];
				for (int j = 0; j < allBaseVertices[i].Length; j++)
				{
					vertex = allBaseVertices[i][j];
					float num4 = Mathf.Sin(1.25f * ((num * num2 + vertex.x + vertex.y + vertex.z) * waveScale)) * num3;
					if (useVertexAlpha)
					{
						num4 *= allBaseVertexAlphas[i][j].a;
					}
					if (ZAxis)
					{
						vertex.z += num4;
					}
					if (XAxis)
					{
						vertex.x += num4;
					}
					if (YAxis)
					{
						vertex.y += num4;
					}
					array[j] = vertex;
				}
				meshes[i].vertices = array;
				if (RecalculateNormals)
				{
					meshes[i].RecalculateNormals();
				}
			}
			return;
		}
		for (int k = 0; k < meshes[0].vertexCount; k++)
		{
			vertex = baseHeight[k];
			float num5 = Mathf.Sin(1.25f * ((num * num2 + vertex.x + vertex.y + vertex.z) * waveScale)) * num3;
			if (useVertexAlpha)
			{
				num5 *= allBaseVertexAlphas[0][k].a;
			}
			if (ZAxis)
			{
				vertex.z += num5;
			}
			if (XAxis)
			{
				vertex.x += num5;
			}
			if (YAxis)
			{
				vertex.y += num5;
			}
			newVerts[k] = vertex;
		}
		if (RecalculateNormals)
		{
			meshes[0].RecalculateNormals();
		}
		Mesh[] array2 = meshes;
		foreach (Mesh mesh in array2)
		{
			mesh.vertices = newVerts;
			if (RecalculateNormals)
			{
				mesh.normals = meshes[0].normals;
			}
		}
	}
}
public class MeshCombineUtility
{
	public struct MeshInstance
	{
		public Mesh mesh;

		public int subMeshIndex;

		public Matrix4x4 transform;
	}

	public static Mesh Combine(MeshInstance[] combines, bool generateStrips)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		MeshInstance[] array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance = array[i];
			if (!meshInstance.mesh)
			{
				continue;
			}
			num += meshInstance.mesh.vertexCount;
			if (!generateStrips)
			{
				continue;
			}
			int num4 = meshInstance.mesh.GetTriangles(meshInstance.subMeshIndex).Length;
			if (num4 != 0)
			{
				if (num3 != 0)
				{
					num3 = (((num3 & 1) != 1) ? (num3 + 2) : (num3 + 3));
				}
				num3 += num4;
			}
			else
			{
				generateStrips = false;
			}
		}
		if (!generateStrips)
		{
			array = combines;
			for (int i = 0; i < array.Length; i++)
			{
				MeshInstance meshInstance2 = array[i];
				if ((bool)meshInstance2.mesh)
				{
					num2 += meshInstance2.mesh.GetTriangles(meshInstance2.subMeshIndex).Length;
				}
			}
		}
		Vector3[] array2 = new Vector3[num];
		Vector3[] array3 = new Vector3[num];
		Vector4[] array4 = new Vector4[num];
		Vector2[] array5 = new Vector2[num];
		Vector2[] array6 = new Vector2[num];
		Color[] array7 = new Color[num];
		int[] array8 = new int[num2];
		int[] array9 = new int[num3];
		int offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance3 = array[i];
			if ((bool)meshInstance3.mesh)
			{
				Copy(meshInstance3.mesh.vertexCount, meshInstance3.mesh.vertices, array2, ref offset, meshInstance3.transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance4 = array[i];
			if ((bool)meshInstance4.mesh)
			{
				Matrix4x4 transform = meshInstance4.transform;
				transform = transform.inverse.transpose;
				CopyNormal(meshInstance4.mesh.vertexCount, meshInstance4.mesh.normals, array3, ref offset, transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance5 = array[i];
			if ((bool)meshInstance5.mesh)
			{
				Matrix4x4 transform2 = meshInstance5.transform;
				transform2 = transform2.inverse.transpose;
				CopyTangents(meshInstance5.mesh.vertexCount, meshInstance5.mesh.tangents, array4, ref offset, transform2);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance6 = array[i];
			if ((bool)meshInstance6.mesh)
			{
				Copy(meshInstance6.mesh.vertexCount, meshInstance6.mesh.uv, array5, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance7 = array[i];
			if ((bool)meshInstance7.mesh)
			{
				Copy(meshInstance7.mesh.vertexCount, meshInstance7.mesh.uv2, array6, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance8 = array[i];
			if ((bool)meshInstance8.mesh)
			{
				CopyColors(meshInstance8.mesh.vertexCount, meshInstance8.mesh.colors, array7, ref offset);
			}
		}
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance9 = array[i];
			if (!meshInstance9.mesh)
			{
				continue;
			}
			if (generateStrips)
			{
				int[] triangles = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				if (num6 != 0)
				{
					if ((num6 & 1) == 1)
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						array9[num6 + 2] = triangles[0] + num7;
						num6 += 3;
					}
					else
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						num6 += 2;
					}
				}
				for (int j = 0; j < triangles.Length; j++)
				{
					array9[j + num6] = triangles[j] + num7;
				}
				num6 += triangles.Length;
			}
			else
			{
				int[] triangles2 = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				for (int k = 0; k < triangles2.Length; k++)
				{
					array8[k + num5] = triangles2[k] + num7;
				}
				num5 += triangles2.Length;
			}
			num7 += meshInstance9.mesh.vertexCount;
		}
		Mesh mesh = new Mesh();
		mesh.name = "Combined Mesh";
		mesh.vertices = array2;
		mesh.normals = array3;
		mesh.colors = array7;
		mesh.uv = array5;
		mesh.uv2 = array6;
		mesh.tangents = array4;
		if (generateStrips)
		{
			mesh.SetTriangles(array9, 0);
		}
		else
		{
			mesh.triangles = array8;
		}
		return mesh;
	}

	private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyPoint(src[i]);
		}
		offset += vertexcount;
	}

	private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyVector(src[i]).normalized;
		}
		offset += vertexcount;
	}

	private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyColors(int vertexcount, Color[] src, Color[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			Vector4 vector = src[i];
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			vector2 = transform.MultiplyVector(vector2).normalized;
			dst[i + offset] = new Vector4(vector2.x, vector2.y, vector2.z, vector.w);
		}
		offset += vertexcount;
	}
}
public class QT_MeshCombineUtility
{
	public struct MeshInstance
	{
		public Mesh mesh;

		public int subMeshIndex;

		public Matrix4x4 transform;
	}

	public static Mesh Combine(MeshInstance[] combines, bool generateStrips)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		MeshInstance[] array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance = array[i];
			if (!meshInstance.mesh)
			{
				continue;
			}
			num += meshInstance.mesh.vertexCount;
			if (!generateStrips)
			{
				continue;
			}
			int num4 = meshInstance.mesh.GetTriangles(meshInstance.subMeshIndex).Length;
			if (num4 != 0)
			{
				if (num3 != 0)
				{
					num3 = (((num3 & 1) != 1) ? (num3 + 2) : (num3 + 3));
				}
				num3 += num4;
			}
			else
			{
				generateStrips = false;
			}
		}
		if (!generateStrips)
		{
			array = combines;
			for (int i = 0; i < array.Length; i++)
			{
				MeshInstance meshInstance2 = array[i];
				if ((bool)meshInstance2.mesh)
				{
					num2 += meshInstance2.mesh.GetTriangles(meshInstance2.subMeshIndex).Length;
				}
			}
		}
		Vector3[] array2 = new Vector3[num];
		Vector3[] array3 = new Vector3[num];
		Vector4[] array4 = new Vector4[num];
		Vector2[] array5 = new Vector2[num];
		Vector2[] array6 = new Vector2[num];
		Color[] array7 = new Color[num];
		int[] array8 = new int[num2];
		int[] array9 = new int[num3];
		int offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance3 = array[i];
			if ((bool)meshInstance3.mesh)
			{
				Copy(meshInstance3.mesh.vertexCount, meshInstance3.mesh.vertices, array2, ref offset, meshInstance3.transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance4 = array[i];
			if ((bool)meshInstance4.mesh)
			{
				Matrix4x4 transform = meshInstance4.transform;
				transform = transform.inverse.transpose;
				CopyNormal(meshInstance4.mesh.vertexCount, meshInstance4.mesh.normals, array3, ref offset, transform);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance5 = array[i];
			if ((bool)meshInstance5.mesh)
			{
				Matrix4x4 transform2 = meshInstance5.transform;
				transform2 = transform2.inverse.transpose;
				CopyTangents(meshInstance5.mesh.vertexCount, meshInstance5.mesh.tangents, array4, ref offset, transform2);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance6 = array[i];
			if ((bool)meshInstance6.mesh)
			{
				Copy(meshInstance6.mesh.vertexCount, meshInstance6.mesh.uv, array5, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance7 = array[i];
			if ((bool)meshInstance7.mesh)
			{
				Copy(meshInstance7.mesh.vertexCount, meshInstance7.mesh.uv2, array6, ref offset);
			}
		}
		offset = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance8 = array[i];
			if ((bool)meshInstance8.mesh)
			{
				CopyColors(meshInstance8.mesh.vertexCount, meshInstance8.mesh.colors, array7, ref offset);
			}
		}
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		array = combines;
		for (int i = 0; i < array.Length; i++)
		{
			MeshInstance meshInstance9 = array[i];
			if (!meshInstance9.mesh)
			{
				continue;
			}
			if (generateStrips)
			{
				int[] triangles = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				if (num6 != 0)
				{
					if ((num6 & 1) == 1)
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						array9[num6 + 2] = triangles[0] + num7;
						num6 += 3;
					}
					else
					{
						array9[num6] = array9[num6 - 1];
						array9[num6 + 1] = triangles[0] + num7;
						num6 += 2;
					}
				}
				for (int j = 0; j < triangles.Length; j++)
				{
					array9[j + num6] = triangles[j] + num7;
				}
				num6 += triangles.Length;
			}
			else
			{
				int[] triangles2 = meshInstance9.mesh.GetTriangles(meshInstance9.subMeshIndex);
				for (int k = 0; k < triangles2.Length; k++)
				{
					array8[k + num5] = triangles2[k] + num7;
				}
				num5 += triangles2.Length;
			}
			num7 += meshInstance9.mesh.vertexCount;
		}
		Mesh mesh = new Mesh();
		mesh.name = "Combined Mesh";
		mesh.vertices = array2;
		mesh.normals = array3;
		mesh.colors = array7;
		mesh.uv = array5;
		mesh.uv2 = array6;
		mesh.tangents = array4;
		if (generateStrips)
		{
			mesh.SetTriangles(array9, 0);
		}
		else
		{
			mesh.triangles = array8;
		}
		return mesh;
	}

	private static void Copy(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyPoint(src[i]);
		}
		offset += vertexcount;
	}

	private static void CopyNormal(int vertexcount, Vector3[] src, Vector3[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = transform.MultiplyVector(src[i]).normalized;
		}
		offset += vertexcount;
	}

	private static void Copy(int vertexcount, Vector2[] src, Vector2[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyColors(int vertexcount, Color[] src, Color[] dst, ref int offset)
	{
		for (int i = 0; i < src.Length; i++)
		{
			dst[i + offset] = src[i];
		}
		offset += vertexcount;
	}

	private static void CopyTangents(int vertexcount, Vector4[] src, Vector4[] dst, ref int offset, Matrix4x4 transform)
	{
		for (int i = 0; i < src.Length; i++)
		{
			Vector4 vector = src[i];
			Vector3 vector2 = new Vector3(vector.x, vector.y, vector.z);
			vector2 = transform.MultiplyVector(vector2).normalized;
			dst[i + offset] = new Vector4(vector2.x, vector2.y, vector2.z, vector.w);
		}
		offset += vertexcount;
	}
}
[ExecuteInEditMode]
public class Caustics : MonoBehaviour
{
	public bool runEditor = true;

	public float fps = 30f;

	public Texture2D[] frames;

	private int frameIndex;

	private Light projector;

	private void Awake()
	{
		projector = GetComponent<Light>();
		NextFrame();
		InvokeRepeating("NextFrame", 1f / fps, 1f / fps);
	}

	private void NextFrame()
	{
		projector.cookie = frames[frameIndex];
		frameIndex = (frameIndex + 1) % frames.Length;
	}
}
public class anm_tex_01 : MonoBehaviour
{
	public int uvAnimationTileX = 8;

	public int uvAnimationTileY = 8;

	public float framesPerSecond = 24f;

	private void Update()
	{
		int num = (int)(Time.time * framesPerSecond) % (uvAnimationTileX * uvAnimationTileY);
		Vector2 value = new Vector2(1f / (float)uvAnimationTileX, 1f / (float)uvAnimationTileY);
		int num2 = num % uvAnimationTileX;
		int num3 = num / uvAnimationTileX;
		Vector2 value2 = new Vector2((float)num2 * value.x, 1f - value.y - (float)num3 * value.y);
		GetComponent<Renderer>().material.SetTextureOffset("_MainTex", value2);
		GetComponent<Renderer>().material.SetTextureScale("_MainTex", value);
	}
}
public class FlickerLight : MonoBehaviour
{
	public float MinLightIntensity = 0.5f;

	public float MaxLightIntensity = 2.3f;

	public float AccelerateTime = 0.15f;

	private float _targetIntensity = 1f;

	private float _lastIntensity = 1f;

	private float _timePassed;

	private Light _lt;

	private const double Tolerance = 0.0001;

	private void Start()
	{
		_lt = GetComponent<Light>();
		_lastIntensity = _lt.intensity;
		FixedUpdate();
	}

	private void FixedUpdate()
	{
		_timePassed += Time.deltaTime;
		_lt.intensity = Mathf.Lerp(_lastIntensity, _targetIntensity, _timePassed / AccelerateTime);
		if ((double)Mathf.Abs(_lt.intensity - _targetIntensity) < 0.0001)
		{
			_lastIntensity = _lt.intensity;
			_targetIntensity = UnityEngine.Random.Range(MinLightIntensity, MaxLightIntensity);
			_timePassed = 0f;
		}
	}
}
[RequireComponent(typeof(MeshRenderer))]
public class UVOffset : MonoBehaviour
{
	public float scrollSpeed = 0.5f;

	public bool scrollY = true;

	private MeshRenderer renderer;

	private void Start()
	{
		renderer = GetComponent<MeshRenderer>();
	}

	private void Update()
	{
		float num = Time.time * scrollSpeed;
		renderer.material.SetTextureOffset("_MainTex", scrollY ? new Vector2(num, 0f) : new Vector2(0f, num));
	}
}
public class CamerSwitch : MonoBehaviour
{
	public GameObject camera1;

	public GameObject camera2;

	public GameObject camera3;

	public GameObject camera4;

	public GameObject camera5;

	public GameObject camera6;

	public GameObject camera7;

	public GameObject camera8;

	public GameObject camera9;

	public GameObject camera10;

	private void setCamera01()
	{
		onActiveFalse();
		camera1.active = true;
	}

	private void setCamera02()
	{
		onActiveFalse();
		camera2.active = true;
	}

	private void setCamera03()
	{
		onActiveFalse();
		camera3.active = true;
	}

	private void setCamera04()
	{
		onActiveFalse();
		camera4.active = true;
	}

	private void setCamera05()
	{
		onActiveFalse();
		camera5.active = true;
	}

	private void setCamera06()
	{
		onActiveFalse();
		camera6.active = true;
	}

	private void setCamera07()
	{
		onActiveFalse();
		camera7.active = true;
	}

	private void setCamera08()
	{
		onActiveFalse();
		camera8.active = true;
	}

	private void setCamera09()
	{
		onActiveFalse();
		camera9.active = true;
	}

	private void setCamera10()
	{
		onActiveFalse();
		camera10.active = true;
	}

	private void onActiveFalse()
	{
		camera1.active = false;
		camera2.active = false;
		camera3.active = false;
		camera4.active = false;
		camera5.active = false;
		camera6.active = false;
		camera7.active = false;
		camera8.active = false;
		camera9.active = false;
		camera10.active = false;
	}
}
public class FreeCamera : MonoBehaviour
{
	public float initialSpeed = 2f;

	public float increaseSpeed = 1.5f;

	public bool allowMovement = true;

	public bool allowRotation = true;

	public KeyCode forwardButton = KeyCode.W;

	public KeyCode backwardButton = KeyCode.S;

	public KeyCode rightButton = KeyCode.D;

	public KeyCode leftButton = KeyCode.A;

	public float cursorSensitivity = 0.005f;

	public bool cursorToggleAllowed;

	public KeyCode cursorToggleButton = KeyCode.Escape;

	private float currentSpeed;

	private bool moving;

	private bool togglePressed = true;

	private void OnEnable()
	{
		if (cursorToggleAllowed)
		{
			Screen.lockCursor = true;
			Cursor.visible = false;
		}
	}

	private void Update()
	{
		if (allowMovement)
		{
			bool flag = moving;
			Vector3 deltaPosition = Vector3.zero;
			if (moving)
			{
				currentSpeed += increaseSpeed * Time.deltaTime;
			}
			moving = false;
			CheckMove(forwardButton, ref deltaPosition, base.transform.forward);
			CheckMove(backwardButton, ref deltaPosition, -base.transform.forward);
			CheckMove(rightButton, ref deltaPosition, base.transform.right);
			CheckMove(leftButton, ref deltaPosition, -base.transform.right);
			if (moving)
			{
				if (moving != flag)
				{
					currentSpeed = initialSpeed;
				}
				base.transform.position += deltaPosition * currentSpeed * Time.deltaTime;
			}
			else
			{
				currentSpeed = 0f;
			}
		}
		if (allowRotation)
		{
			Vector3 eulerAngles = base.transform.eulerAngles;
			eulerAngles.x += (0f - Input.GetAxis("Mouse Y")) * 359f * cursorSensitivity;
			eulerAngles.y += Input.GetAxis("Mouse X") * 359f * cursorSensitivity;
			base.transform.eulerAngles = eulerAngles;
		}
		if (cursorToggleAllowed)
		{
			if (Input.GetKey(cursorToggleButton))
			{
				if (!togglePressed)
				{
					togglePressed = true;
					Screen.lockCursor = !Screen.lockCursor;
					Cursor.visible = !Cursor.visible;
				}
			}
			else
			{
				togglePressed = false;
			}
		}
		else
		{
			togglePressed = false;
			Cursor.visible = true;
		}
	}

	private void CheckMove(KeyCode keyCode, ref Vector3 deltaPosition, Vector3 directionVector)
	{
		if (Input.GetKey(keyCode))
		{
			moving = true;
			deltaPosition += directionVector;
		}
	}
}
public class ObjectRotate : MonoBehaviour
{
	public float a;

	private void Play()
	{
		a = 0.3f;
	}

	private void Stop()
	{
		a = 0f;
	}

	private void Update()
	{
		base.transform.Rotate(0f, a, 0f);
	}
}
public class AnimatorSwitch : MonoBehaviour
{
	private Animator animator;

	private void Start()
	{
		animator = GetComponent<Animator>();
	}

	private void Update()
	{
	}

	private void A1()
	{
		animator.Play("Shot-01");
	}

	private void A2()
	{
		animator.Play("Shot-02");
	}

	private void A3()
	{
		animator.Play("Run");
	}

	private void A4()
	{
		animator.Play("Walk");
	}

	private void A5()
	{
		animator.Play("Defense");
	}

	private void A6()
	{
		animator.Play("Hit");
	}

	private void A7()
	{
		animator.Play("Death-01");
	}

	private void A8()
	{
		animator.Play("Death-02");
	}

	private void A9()
	{
		animator.Play("Shot-03");
	}

	private void A10()
	{
		animator.Play("Shot-04");
	}

	private void A11()
	{
		animator.Play("Reload-01");
	}

	private void A12()
	{
		animator.Play("Idle");
	}
}
public class SetMatColor : MonoBehaviour
{
	public Material mat1;

	public Material mat2;

	public Slider targetSliderOject;

	public Color color1;

	public Color color2;

	public Color color3;

	public Color color4;

	public Color color5;

	public Color color6;

	public Color color7;

	public Color color8;

	public Color color9;

	public Color color10;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void onValueChanged()
	{
		if (targetSliderOject.value == 0f)
		{
			mat1.SetColor("_Color", color1);
			mat2.SetColor("_Color", color2);
		}
		if (targetSliderOject.value == 1f)
		{
			mat1.SetColor("_Color", color3);
			mat2.SetColor("_Color", color4);
		}
		if (targetSliderOject.value == 2f)
		{
			mat1.SetColor("_Color", color5);
			mat2.SetColor("_Color", color6);
		}
		if (targetSliderOject.value == 3f)
		{
			mat1.SetColor("_Color", color7);
			mat2.SetColor("_Color", color8);
		}
		if (targetSliderOject.value == 4f)
		{
			mat1.SetColor("_Color", color9);
			mat2.SetColor("_Color", color10);
		}
	}
}
public class TakeScreenshot : MonoBehaviour
{
	private int screenshotCount;

	private string imagePath;

	private void Update()
	{
		if (Input.GetKeyDown("f1"))
		{
			string text;
			do
			{
				screenshotCount++;
				text = "screenshot" + screenshotCount + ".png";
			}
			while (File.Exists(text));
			ScreenCapture.CaptureScreenshot(text);
			if (Application.platform == RuntimePlatform.Android || Application.platform == RuntimePlatform.IPhonePlayer)
			{
				imagePath = Application.persistentDataPath;
			}
			else if (Application.platform == RuntimePlatform.WindowsPlayer)
			{
				imagePath = Application.dataPath;
			}
			else if (Application.platform == RuntimePlatform.WindowsEditor)
			{
				imagePath = Application.dataPath;
				imagePath = imagePath.Replace("/Assets", null);
			}
			imagePath += text;
		}
	}
}
public class customizableSliderEvent : MonoBehaviour
{
	public GameObject botton;

	public GameObject central;

	public GameObject top;

	public GameObject B1;

	public GameObject B2;

	public GameObject B3;

	public GameObject B4;

	public GameObject B5;

	public GameObject C1;

	public GameObject C2;

	public GameObject C3;

	public GameObject C4;

	public GameObject C5;

	public GameObject T1;

	public GameObject T2;

	public GameObject T3;

	public GameObject T4;

	public GameObject T5;

	public Slider targetSliderOject1;

	public Slider targetSliderOject2;

	public Slider targetSliderOject3;

	private void Start()
	{
		setBotton();
		setCentral();
		setTop();
		B1.SetActive(value: true);
		central.transform.localPosition = new Vector3(0f, 0.358f, 0f);
		C1.SetActive(value: true);
		top.transform.localPosition = new Vector3(0f, 0.358f, 0f);
		T1.SetActive(value: true);
	}

	private void Update()
	{
	}

	private void onValueChanged()
	{
		if (targetSliderOject1.value == 0f)
		{
			setBotton();
			B1.SetActive(value: true);
			central.transform.localPosition = new Vector3(0f, 0.329f, 0f);
		}
		if (targetSliderOject1.value == 1f)
		{
			setBotton();
			B2.SetActive(value: true);
			central.transform.localPosition = new Vector3(0f, 0.394f, 0f);
		}
		if (targetSliderOject1.value == 2f)
		{
			setBotton();
			B3.SetActive(value: true);
			central.transform.localPosition = new Vector3(0f, 0.306f, 0f);
		}
		if (targetSliderOject1.value == 3f)
		{
			setBotton();
			B4.SetActive(value: true);
			central.transform.localPosition = new Vector3(0f, 0.414f, 0f);
		}
		if (targetSliderOject1.value == 4f)
		{
			setBotton();
			B5.SetActive(value: true);
			central.transform.localPosition = new Vector3(0f, 0.4508f, 0f);
		}
		if (targetSliderOject2.value == 0f)
		{
			setCentral();
			C1.SetActive(value: true);
			top.transform.localPosition = new Vector3(0f, 0.658f, 0f);
		}
		if (targetSliderOject2.value == 1f)
		{
			setCentral();
			C2.SetActive(value: true);
			top.transform.localPosition = new Vector3(0f, 0.876f, 0f);
		}
		if (targetSliderOject2.value == 2f)
		{
			setCentral();
			C3.SetActive(value: true);
			top.transform.localPosition = new Vector3(0f, 0.469f, 0f);
		}
		if (targetSliderOject2.value == 3f)
		{
			setCentral();
			C4.SetActive(value: true);
			top.transform.localPosition = new Vector3(0f, 0.33f, 0f);
		}
		if (targetSliderOject2.value == 4f)
		{
			setCentral();
			C5.SetActive(value: true);
			top.transform.localPosition = new Vector3(0f, 0.799f, 0f);
		}
		if (targetSliderOject3.value == 0f)
		{
			setTop();
			T1.SetActive(value: true);
		}
		if (targetSliderOject3.value == 1f)
		{
			setTop();
			T2.SetActive(value: true);
		}
		if (targetSliderOject3.value == 2f)
		{
			setTop();
			T3.SetActive(value: true);
		}
		if (targetSliderOject3.value == 3f)
		{
			setTop();
			T4.SetActive(value: true);
		}
		if (targetSliderOject3.value == 4f)
		{
			setTop();
			T5.SetActive(value: true);
		}
	}

	private void setBotton()
	{
		central.transform.localPosition = Vector3.zero;
		B1.SetActive(value: false);
		B2.SetActive(value: false);
		B3.SetActive(value: false);
		B4.SetActive(value: false);
		B5.SetActive(value: false);
	}

	private void setCentral()
	{
		top.transform.localPosition = Vector3.zero;
		C1.SetActive(value: false);
		C2.SetActive(value: false);
		C3.SetActive(value: false);
		C4.SetActive(value: false);
		C5.SetActive(value: false);
	}

	private void setTop()
	{
		T1.SetActive(value: false);
		T2.SetActive(value: false);
		T3.SetActive(value: false);
		T4.SetActive(value: false);
		T5.SetActive(value: false);
	}
}
public class legacyCamerSwitch : MonoBehaviour
{
	public GameObject camera1;

	public GameObject camera2;

	public GameObject camera3;

	public GameObject camera4;

	public GameObject camera5;

	public GameObject camera6;

	public GameObject camera7;

	public GameObject camera8;

	public GameObject camera9;

	public GameObject camera10;

	private void Update()
	{
		if (Input.GetKeyDown("1"))
		{
			onActiveFalse();
			camera1.active = true;
		}
		if (Input.GetKeyDown("2"))
		{
			onActiveFalse();
			camera2.active = true;
		}
		if (Input.GetKeyDown("3"))
		{
			onActiveFalse();
			camera3.active = true;
		}
		if (Input.GetKeyDown("4"))
		{
			onActiveFalse();
			camera4.active = true;
		}
		if (Input.GetKeyDown("5"))
		{
			onActiveFalse();
			camera5.active = true;
		}
		if (Input.GetKeyDown("6"))
		{
			onActiveFalse();
			camera6.active = true;
		}
		if (Input.GetKeyDown("7"))
		{
			onActiveFalse();
			camera7.active = true;
		}
		if (Input.GetKeyDown("8"))
		{
			onActiveFalse();
			camera8.active = true;
		}
		if (Input.GetKeyDown("9"))
		{
			onActiveFalse();
			camera9.active = true;
		}
		if (Input.GetKeyDown("f"))
		{
			onActiveFalse();
			camera10.active = true;
		}
	}

	private void onActiveFalse()
	{
		camera1.active = false;
		camera2.active = false;
		camera3.active = false;
		camera4.active = false;
		camera5.active = false;
		camera6.active = false;
		camera7.active = false;
		camera8.active = false;
		camera9.active = false;
		camera10.active = false;
	}
}
public class PropMovementScript : MonoBehaviour
{
	public float TrahsHold;

	public bool isMoving;

	public Vector3 targetPosition;

	public float speed;

	public bool isRotating;

	public Vector3 targetRotation;

	public float speedRotation;

	private Vector3 startPosition;

	private Vector3 startRotation;

	private void Start()
	{
		startPosition = base.gameObject.transform.position;
		startRotation = base.gameObject.transform.localEulerAngles;
		if (TrahsHold < 0.15f)
		{
			TrahsHold = 0.15f;
		}
	}

	private void Update()
	{
		if (isMoving)
		{
			Vector3 position = Vector3.MoveTowards(base.gameObject.transform.position, targetPosition, speed * Time.deltaTime);
			if (Mathf.Abs(targetPosition.x - position.x) < TrahsHold && Mathf.Abs(targetPosition.y - position.y) < TrahsHold && Mathf.Abs(targetPosition.z - position.z) < TrahsHold)
			{
				base.transform.position = startPosition;
			}
			else
			{
				base.transform.position = position;
			}
		}
		if (isRotating)
		{
			Vector3 localEulerAngles = Vector3.RotateTowards(base.gameObject.transform.localEulerAngles, targetRotation, speedRotation * Time.deltaTime, 1f);
			if (Mathf.Abs(targetRotation.x - localEulerAngles.x) < TrahsHold && Mathf.Abs(targetRotation.y - localEulerAngles.y) < TrahsHold && Mathf.Abs(targetRotation.z - localEulerAngles.z) < TrahsHold)
			{
				base.transform.localEulerAngles = startRotation;
			}
			else
			{
				base.transform.localEulerAngles = localEulerAngles;
			}
		}
	}
}
public class AnimRandomizer : MonoBehaviour
{
	private Animator anim;

	public string[] animationNames;

	private void Start()
	{
		anim = GetComponent<Animator>();
		anim.Play(animationNames[UnityEngine.Random.Range(0, animationNames.Length)], 0, UnityEngine.Random.Range(0f, 0.3f));
	}
}
public class Rotator : MonoBehaviour
{
	public Vector3 _value;

	public bool Enable_Noise;

	public Vector3 _Noisevalue;

	public float NoiseUpdateRate = 3f;

	private Vector3 smoothFactor;

	private Vector3 smoothFactor2;

	private float RefreshTime = 10f;

	private void Update()
	{
		RefreshTime += Time.deltaTime;
		if (Enable_Noise && RefreshTime > NoiseUpdateRate)
		{
			RefreshTime = 0f;
			smoothFactor2 = new Vector3(UnityEngine.Random.Range(0f - _Noisevalue.x, _Noisevalue.x), UnityEngine.Random.Range(0f - _Noisevalue.y, _Noisevalue.y), UnityEngine.Random.Range(0f - _Noisevalue.z, _Noisevalue.z));
		}
		smoothFactor = Vector3.Lerp(smoothFactor, smoothFactor2, Time.deltaTime * 2f);
		Vector3 vector = (_value + smoothFactor) * Time.deltaTime * 5f;
		base.transform.eulerAngles = base.transform.eulerAngles + vector;
	}
}
public class WNDDisabler : MonoBehaviour
{
	public bool DisableAtPosition = true;

	public Vector3 disablingPosition;

	public float timeToDisableMin;

	public float timeToDisableMax;

	private bool mooving;

	private float moovingA;

	private Vector3 startPos;

	private Vector3 startScale;

	private void Start()
	{
		StartCoroutine(Disabler());
	}

	private void FixedUpdate()
	{
		if (mooving)
		{
			base.transform.localPosition = Vector3.Lerp(startPos, startPos + disablingPosition, moovingA);
			base.transform.localScale = Vector3.Lerp(startScale, Vector3.zero, moovingA);
			if (moovingA >= 1f)
			{
				base.gameObject.SetActive(value: false);
			}
			else
			{
				moovingA += Time.fixedDeltaTime;
			}
		}
	}

	private IEnumerator Disabler()
	{
		yield return new WaitForSeconds(UnityEngine.Random.Range(timeToDisableMin, timeToDisableMax));
		if (DisableAtPosition)
		{
			mooving = true;
			startPos = base.transform.localPosition;
			startScale = base.transform.localScale;
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class WNDDispenser : MonoBehaviour
{
	public GameObject projectilePrefab;

	public GameObject particlePrefab;

	public float shootingDelay;

	public float power;

	public float randomPowerMinMultiplier;

	public float randomPowerMaxMultiplier;

	private Transform arrowsParent;

	private GameObject currentArrow;

	private bool arrowReady = true;

	private float arrowSize;

	private float timeToShoot;

	private float delayToSpawn;

	private void Start()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		foreach (Transform transform in componentsInChildren)
		{
			if (transform.gameObject.name.Contains("[Projectile Parent]"))
			{
				arrowsParent = transform;
				break;
			}
		}
		CreateArrow();
	}

	public void CreateArrow()
	{
		arrowReady = false;
		arrowSize = 0f;
		currentArrow = UnityEngine.Object.Instantiate(projectilePrefab, arrowsParent);
		if (currentArrow.GetComponent<WNDPrefabVariator>() != null)
		{
			currentArrow.GetComponent<WNDPrefabVariator>().RandomPrefab();
		}
		currentArrow.GetComponent<Rigidbody>().isKinematic = true;
		currentArrow.transform.localScale = Vector3.zero;
		timeToShoot = shootingDelay;
	}

	public void Shoot()
	{
		UnityEngine.Object.Instantiate(particlePrefab, arrowsParent.transform.position, default(Quaternion)).transform.localEulerAngles = Vector3.zero;
		currentArrow.transform.parent = null;
		currentArrow.GetComponent<Rigidbody>().isKinematic = false;
		currentArrow.GetComponent<Rigidbody>().AddForce(base.transform.up * (power * UnityEngine.Random.Range(randomPowerMinMultiplier, randomPowerMaxMultiplier)), ForceMode.Impulse);
		delayToSpawn = 1f;
	}

	private void FixedUpdate()
	{
		if (!arrowReady)
		{
			arrowSize += Time.fixedDeltaTime * 4f;
			currentArrow.transform.localScale = Vector3.Lerp(Vector3.zero, Vector3.one, arrowSize);
			if (arrowSize >= 1f)
			{
				arrowReady = true;
			}
		}
		else if (delayToSpawn <= 0f)
		{
			if (timeToShoot > 0f)
			{
				timeToShoot -= Time.fixedDeltaTime;
			}
			else
			{
				Shoot();
			}
		}
		else
		{
			delayToSpawn -= Time.fixedDeltaTime;
			if (delayToSpawn <= 0f)
			{
				CreateArrow();
			}
		}
	}
}
public class WNDMoover : MonoBehaviour
{
	public float distance;

	[Range(0.01f, 0.5f)]
	public float speed;

	public bool reversed;

	public bool randomStartPos;

	private List<Vector3> posToMoove;

	public List<Transform> objsToMoove;

	private void Start()
	{
		posToMoove = new List<Vector3>();
		for (int i = 0; i < objsToMoove.Count; i++)
		{
			if (objsToMoove[i] != null)
			{
				Vector3 localPosition = objsToMoove[i].localPosition;
				if (!reversed)
				{
					localPosition.x -= distance;
				}
				else
				{
					localPosition.x += distance;
				}
				posToMoove.Add(localPosition);
			}
		}
		if (randomStartPos)
		{
			RandomStartPos();
		}
	}

	private void RandomStartPos()
	{
		for (int i = 0; i < objsToMoove.Count; i++)
		{
			if (objsToMoove[i] != null)
			{
				objsToMoove[i].localPosition = Vector3.Lerp(objsToMoove[i].localPosition, posToMoove[i], UnityEngine.Random.Range(0f, 1f));
			}
		}
	}

	private void FixedUpdate()
	{
		for (int i = 0; i < objsToMoove.Count; i++)
		{
			if (objsToMoove[i] != null)
			{
				objsToMoove[i].localPosition = Vector3.MoveTowards(objsToMoove[i].localPosition, posToMoove[i], speed);
				if (Vector3.Distance(objsToMoove[i].localPosition, posToMoove[i]) < 0.1f)
				{
					Vector3 value = posToMoove[i];
					value.x *= -1f;
					posToMoove[i] = value;
				}
			}
		}
	}
}
public class WNDParticlesDestroyer : MonoBehaviour
{
	private ParticleSystem ParticleSystem;

	private void Awake()
	{
		ParticleSystem = GetComponent<ParticleSystem>();
	}

	private void FixedUpdate()
	{
		if (!ParticleSystem.IsAlive())
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class WNDParticlesSpawner : MonoBehaviour
{
	public GameObject particle0;

	public GameObject particle1;

	public void Particle0()
	{
		UnityEngine.Object.Instantiate(particle0, base.transform.position, default(Quaternion));
	}

	public void Particle1()
	{
		UnityEngine.Object.Instantiate(particle1, base.transform.position, default(Quaternion));
	}
}
public class WNDPrefabVariator : MonoBehaviour
{
	public int selectedType;

	public int selectedColor;

	public int selectedStyle;

	public int selectedPillars;

	public List<Transform> types;

	public bool partsInitialized;

	public Texture headerLogo;

	public bool typesSelector;

	public bool isDynamicFence;

	public float fenceLength = 10f;

	public float fencePillarsFrequency = 2f;

	public ParticleSystem myPs;

	public bool hasStyle
	{
		get
		{
			if (isDynamicFence)
			{
				return true;
			}
			if (types[selectedType].GetChild(selectedColor).childCount > 1)
			{
				return true;
			}
			return false;
		}
	}

	public void InitializeParts()
	{
		if (partsInitialized)
		{
			return;
		}
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		types = new List<Transform>();
		Transform[] array = componentsInChildren;
		foreach (Transform transform in array)
		{
			if (transform.name.Contains("[Type]"))
			{
				types.Add(transform);
			}
		}
		if (types.Count == 0)
		{
			types.Add(base.transform);
		}
		else
		{
			typesSelector = true;
		}
		partsInitialized = true;
	}

	public void ChooseType(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedType++;
			if (selectedType >= types.Count)
			{
				selectedType = 0;
			}
		}
		else
		{
			selectedType--;
			if (selectedType < 0)
			{
				selectedType = types.Count - 1;
			}
		}
		Refresh();
	}

	public void RandomType()
	{
		InitializeParts();
		selectedType = UnityEngine.Random.Range(0, types.Count);
		Refresh();
	}

	public void ChooseColor(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedColor++;
			if (selectedColor >= types[selectedType].childCount)
			{
				selectedColor = 0;
			}
			else if (types[selectedType].GetChild(selectedColor).gameObject.name.Contains("[Ignore]"))
			{
				selectedColor = 0;
			}
		}
		else
		{
			selectedColor--;
			if (selectedColor < 0)
			{
				if (types[selectedType].GetChild(types[selectedType].childCount - 1).gameObject.name.Contains("[Ignore]"))
				{
					selectedColor = types[selectedType].childCount - 2;
				}
				else
				{
					selectedColor = types[selectedType].childCount - 1;
				}
			}
		}
		Refresh();
	}

	public void RandomColor()
	{
		InitializeParts();
		selectedColor = UnityEngine.Random.Range(0, types[selectedType].childCount);
		Refresh();
	}

	public void ChooseStyle(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedStyle++;
		}
		else
		{
			selectedStyle--;
			if (!isDynamicFence)
			{
				if (selectedStyle < 0)
				{
					selectedStyle = types[selectedType].GetChild(selectedColor).childCount - 1;
				}
				else if (selectedStyle < 0)
				{
					selectedStyle = types[selectedType].GetChild(selectedColor).GetChild(0).childCount - 1;
				}
			}
		}
		Refresh();
	}

	public void ChoosePillars(bool next)
	{
		InitializeParts();
		if (next)
		{
			selectedPillars++;
			if (selectedPillars >= types[selectedType].GetChild(selectedColor).GetChild(1).childCount)
			{
				selectedPillars = 0;
			}
		}
		else
		{
			selectedPillars--;
			if (selectedPillars < 0)
			{
				selectedPillars = types[selectedType].GetChild(selectedColor).GetChild(1).childCount - 1;
			}
		}
		Refresh();
	}

	public void RandomStyle()
	{
		InitializeParts();
		if (!isDynamicFence)
		{
			selectedStyle = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).childCount);
		}
		else
		{
			selectedStyle = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).GetChild(0).childCount);
		}
		Refresh();
	}

	public void RandomPillars()
	{
		InitializeParts();
		if (!isDynamicFence)
		{
			selectedPillars = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).childCount);
		}
		else
		{
			selectedPillars = UnityEngine.Random.Range(0, types[selectedType].GetChild(selectedColor).GetChild(1).childCount);
		}
		Refresh();
	}

	public void RandomPrefab()
	{
		InitializeParts();
		RandomType();
		RandomColor();
		RandomStyle();
		Refresh();
	}

	private void Refresh()
	{
		for (int i = 0; i < types.Count; i++)
		{
			if (i != selectedType)
			{
				types[i].gameObject.SetActive(value: false);
				continue;
			}
			types[i].gameObject.SetActive(value: true);
			if (selectedColor >= types[i].childCount)
			{
				selectedColor = 0;
			}
			for (int j = 0; j < types[i].childCount; j++)
			{
				if (j != selectedColor)
				{
					if (!types[i].GetChild(j).gameObject.name.Contains("[Ignore]"))
					{
						types[i].GetChild(j).gameObject.SetActive(value: false);
					}
					continue;
				}
				types[i].GetChild(j).gameObject.SetActive(value: true);
				if (!isDynamicFence)
				{
					if (selectedStyle >= types[i].GetChild(j).childCount)
					{
						selectedStyle = 0;
					}
					for (int k = 0; k < types[i].GetChild(j).childCount; k++)
					{
						if (k != selectedStyle)
						{
							types[i].GetChild(j).GetChild(k).gameObject.SetActive(value: false);
							continue;
						}
						types[i].GetChild(j).GetChild(k).gameObject.SetActive(value: true);
						if (myPs != null)
						{
							myPs.transform.parent = types[i].GetChild(j).GetChild(k);
							ParticleSystem.ShapeModule shape = myPs.shape;
							shape.meshRenderer = types[i].GetChild(j).GetChild(k).GetComponent<MeshRenderer>();
						}
					}
					continue;
				}
				if (selectedStyle >= types[i].GetChild(j).GetChild(0).childCount)
				{
					selectedStyle = 0;
				}
				for (int l = 0; l < types[i].GetChild(j).GetChild(0).childCount; l++)
				{
					if (l != selectedStyle)
					{
						types[i].GetChild(j).GetChild(0).GetChild(l)
							.gameObject.SetActive(value: false);
					}
					else
					{
						types[i].GetChild(j).GetChild(0).GetChild(l)
							.gameObject.SetActive(value: true);
					}
				}
				if (selectedPillars >= types[i].GetChild(j).GetChild(1).childCount)
				{
					selectedPillars = 0;
				}
				for (int m = 0; m < types[i].GetChild(j).GetChild(1).childCount; m++)
				{
					if (m != selectedPillars)
					{
						types[i].GetChild(j).GetChild(1).GetChild(m)
							.gameObject.SetActive(value: false);
					}
					else
					{
						types[i].GetChild(j).GetChild(1).GetChild(m)
							.gameObject.SetActive(value: true);
					}
				}
				RefreshPillars();
			}
		}
	}

	public void RefreshPillars()
	{
		types[selectedType].GetChild(selectedColor).GetChild(0).GetChild(selectedStyle)
			.transform.localScale = new Vector3(1f, 1f, 1f * (fenceLength / 18f));
		for (int num = types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars)
			.childCount - 1; num >= 0; num--)
		{
			UnityEngine.Object.DestroyImmediate(types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars)
				.GetChild(num)
				.gameObject);
			}
			GameObject original = types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars)
				.gameObject;
			Transform child = types[selectedType].GetChild(selectedColor).GetChild(1).GetChild(selectedPillars);
			float num2 = fenceLength / 2f;
			float num3 = num2 / (float)((int)fencePillarsFrequency + 1);
			List<Transform> list = new List<Transform>();
			if (fencePillarsFrequency > 0f)
			{
				for (float num4 = num3; num4 <= num2; num4 += num3)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(original, child);
					gameObject.transform.localPosition = new Vector3(0f, 0f, num4);
					list.Add(gameObject.transform);
					gameObject.transform.parent = null;
					gameObject = UnityEngine.Object.Instantiate(original, child);
					gameObject.transform.localPosition = new Vector3(0f, 0f, 0f - num4);
					list.Add(gameObject.transform);
					gameObject.transform.parent = null;
				}
			}
			else if (fencePillarsFrequency > -1f)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(original, child);
				gameObject2.transform.localPosition = new Vector3(0f, 0f, num2);
				list.Add(gameObject2.transform);
				gameObject2.transform.parent = null;
				gameObject2 = UnityEngine.Object.Instantiate(original, child);
				gameObject2.transform.localPosition = new Vector3(0f, 0f, 0f - num2);
				list.Add(gameObject2.transform);
				gameObject2.transform.parent = null;
			}
			foreach (Transform item in list)
			{
				item.parent = child;
			}
		}
	}
	public class WNDRotator : MonoBehaviour
	{
		public Vector3 rotationSpeed;

		private void FixedUpdate()
		{
			base.transform.Rotate(rotationSpeed);
		}
	}
	public class HYPEPOLY_Dispenser : MonoBehaviour
	{
		public GameObject arrowPrefab;

		public float arrowSpeed;

		public float shootingDistance;

		public float shootingSpeed;

		private Transform arrowsParent;

		private GameObject currentArrow;

		private bool arrowReady = true;

		private float arrowSize;

		private List<GameObject> arrows;

		private Vector3 targetPosition;

		private void Start()
		{
			arrows = new List<GameObject>();
			GetComponent<Animator>().speed = shootingSpeed;
			arrowsParent = base.transform.GetChild(0);
			targetPosition = base.transform.TransformPoint(new Vector3(0f, 0f, 0f - shootingDistance));
			targetPosition.y = arrowsParent.position.y;
		}

		public void CreateArrow()
		{
			arrowReady = false;
			arrowSize = 0f;
			currentArrow = UnityEngine.Object.Instantiate(arrowPrefab, arrowsParent);
			currentArrow.transform.localScale = Vector3.zero;
		}

		public void Shoot()
		{
			currentArrow.transform.parent = null;
			arrows.Add(currentArrow);
		}

		private void FixedUpdate()
		{
			if (!arrowReady)
			{
				arrowSize += Time.fixedDeltaTime * shootingSpeed;
				currentArrow.transform.localScale = Vector3.Lerp(Vector3.zero, Vector3.one, arrowSize);
				if (arrowSize >= 1f)
				{
					arrowReady = true;
				}
			}
			if (arrows.Count <= 0)
			{
				return;
			}
			for (int num = arrows.Count - 1; num >= 0; num--)
			{
				if (Vector3.Distance(arrows[num].transform.position, targetPosition) < 0.1f)
				{
					GameObject gameObject = arrows[num];
					arrows.Remove(gameObject);
					UnityEngine.Object.Destroy(gameObject);
				}
			}
			for (int i = 0; i < arrows.Count; i++)
			{
				arrows[i].transform.position = Vector3.MoveTowards(arrows[i].transform.position, targetPosition, arrowSpeed);
			}
		}
	}
	public class HYPEPOLY_Moover : MonoBehaviour
	{
		public float distance;

		[Range(0.01f, 0.5f)]
		public float speed;

		private Vector3 posToMoove;

		private void Start()
		{
			posToMoove = base.transform.localPosition;
			posToMoove.x -= distance;
		}

		private void FixedUpdate()
		{
			base.transform.localPosition = Vector3.MoveTowards(base.transform.localPosition, posToMoove, speed);
			if (Vector3.Distance(base.transform.localPosition, posToMoove) < 0.1f)
			{
				posToMoove *= -1f;
			}
		}
	}
	public class HYPEPOLY_Rotator : MonoBehaviour
	{
		public Vector3 rotationSpeed;

		private void FixedUpdate()
		{
			base.transform.localEulerAngles += rotationSpeed;
		}
	}
	public class AnimatorSpeed : MonoBehaviour
	{
		[Range(0f, 5f)]
		public float Speed;

		private void Start()
		{
		}

		private void Update()
		{
			base.gameObject.GetComponent<Animator>().speed = Speed;
		}
	}
	[ExecuteInEditMode]
	public class ShowroomAudioplayer : MonoBehaviour
	{
		public AudioSource ShowroomAudio;

		private void OnEnable()
		{
			ShowroomAudio = GetComponent<AudioSource>();
			float length = ShowroomAudio.clip.length;
			float time = UnityEngine.Random.Range(2f, length);
			ShowroomAudio.time = time;
		}

		private void Update()
		{
		}
	}
	[ExecuteInEditMode]
	public class Fade : MonoBehaviour
	{
		public Color _Color = Color.white;

		private Shader _FadeShader;

		[HideInInspector]
		public Material _FadeMaterial;

		public Material FadeMaterial
		{
			get
			{
				if (_FadeMaterial == null)
				{
					_FadeMaterial = new Material(_FadeShader);
					_FadeMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return _FadeMaterial;
			}
		}

		private void OnEnable()
		{
			_FadeShader = Shader.Find("Hidden/Fade");
			if (_FadeShader == null)
			{
				MonoBehaviour.print("Hidden/Fade #SHADER ERROR#");
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if ((bool)FadeMaterial)
			{
				FadeMaterial.SetColor("_Color", _Color);
				Graphics.Blit(source, destination, FadeMaterial);
			}
			else
			{
				Graphics.Blit(source, destination);
			}
		}

		private void OnDisable()
		{
			UnityEngine.Object.DestroyImmediate(_FadeMaterial);
		}
	}
	[ExecuteInEditMode]
	public class MockupManager : MonoBehaviour
	{
		private struct BoundingBox
		{
			public Vector3 min;

			public Vector3 max;

			public BoundingBox(Vector3 _min, Vector3 _max)
			{
				min = Vector3.zero;
				max = Vector3.zero;
				min.x = _min.x;
				min.y = _min.y;
				min.x = _min.x;
				max.x = _max.x;
				max.y = _max.y;
				max.x = _max.x;
			}
		}

		public GameObject CameraRoot;

		public GameObject BoundariesInterior;

		public GameObject BoundariesExterior;

		private Rotator _Rotator;

		private Camera GameCamera;

		public FogVolume _FogVolume;

		public FogVolume _ShadowCaster;

		private ExplorationCamera _ExplorationCamera;

		private FogVolumeRenderer _FogVolumeRenderer;

		public ShadowCamera.TextureSize OutsideShadowResolution = ShadowCamera.TextureSize._256;

		public ShadowCamera.TextureSize InsideShadowResolution = ShadowCamera.TextureSize._128;

		[Range(0.001f, 0.1f)]
		public float FOVTransitionSpeed = 0.01f;

		public bool EnableFogVolumeRendererOutsideBox;

		public float CurrentFOV;

		public float targetFOV = 90f;

		private float _InitialFogVolumeSize;

		public float AtmosphereSizeInside = 100f;

		public float AtmosphereSizeOutside = 49.99f;

		private ReflectionProbe[] SceneReflectionProbes;

		private bool isInside;

		public GameObject[] ObjectsToToggle;

		private bool[] ObjectsToToggleDefaultVisible;

		private int count;

		public float InitialFOV;

		public Transform RespawnPoint;

		private Vector3 CurrentCameraPosition;

		private bool exit;

		private bool enter;

		public GameObject DebugIntersectionPoint;

		private BoxCollider[] BoundariesCollider;

		private BoundingBox _InteriorBox;

		private BoundingBox _CurrentPlayableBoundingBox;

		private float fade;

		public float CameraRotation = 1f;

		private Fade FadeEffect;

		private Vector3 _ClosestPoint;

		public float InteriorRadiusFade = 74.6f;

		public float RadialPow = 10.1f;

		private void OnEnable()
		{
			BoundariesCollider = new BoxCollider[2];
			BoundariesCollider[0] = BoundariesExterior.GetComponent<BoxCollider>();
			BoundariesCollider[1] = BoundariesInterior.GetComponent<BoxCollider>();
			GameCamera = Camera.main;
			InitialFOV = GameCamera.fieldOfView;
			_ExplorationCamera = GameCamera.GetComponent<ExplorationCamera>();
			_FogVolumeRenderer = Camera.main.GetComponent<FogVolumeRenderer>();
			if ((bool)CameraRoot)
			{
				_Rotator = CameraRoot.GetComponent<Rotator>();
			}
			if ((bool)_ShadowCaster)
			{
				AtmosphereSizeOutside = _ShadowCaster.fogVolumeScale.x;
			}
			SceneReflectionProbes = UnityEngine.Object.FindObjectsOfType(typeof(ReflectionProbe)) as ReflectionProbe[];
			ObjectsToToggleDefaultVisible = new bool[ObjectsToToggle.Length];
			for (int i = 0; i < ObjectsToToggle.Length; i++)
			{
				ObjectsToToggleDefaultVisible[i] = ObjectsToToggle[i].activeInHierarchy;
			}
			SetupOverlayEffect();
			_ExplorationCamera.enabled = true;
		}

		private void PointIsInsideVolume(Vector3 PointPosition)
		{
			bool flag = false;
			Vector3 zero = Vector3.zero;
			GameObject gameObject;
			if (isInside)
			{
				gameObject = BoundariesInterior;
				zero = BoundariesInterior.transform.localScale;
			}
			else
			{
				gameObject = BoundariesExterior;
				zero = BoundariesExterior.transform.localScale;
			}
			float num = gameObject.transform.position.x + zero.x / 2f;
			float num2 = gameObject.transform.position.x - zero.x / 2f;
			float num3 = gameObject.transform.position.y + zero.y / 2f;
			float num4 = gameObject.transform.position.y - zero.y / 2f;
			float num5 = gameObject.transform.position.z + zero.z / 2f;
			float num6 = gameObject.transform.position.z - zero.z / 2f;
			if (num > PointPosition.x && num2 < PointPosition.x && num3 > PointPosition.y && num4 < PointPosition.y && num5 > PointPosition.z && num6 < PointPosition.z)
			{
				flag = true;
			}
			_CurrentPlayableBoundingBox.max = new Vector3(num, num3, num3);
			_CurrentPlayableBoundingBox.min = new Vector3(num2, num4, num4);
			isInside = flag;
		}

		private void ToggleObjects()
		{
			for (int i = 0; i < ObjectsToToggle.Length; i++)
			{
				if (isInside)
				{
					ObjectsToToggle[i].SetActive(!ObjectsToToggleDefaultVisible[i]);
				}
				else
				{
					ObjectsToToggle[i].SetActive(ObjectsToToggleDefaultVisible[i]);
				}
			}
		}

		private void SetupOverlayEffect()
		{
			FadeEffect = GameCamera.GetComponent<Fade>();
			if (FadeEffect == null)
			{
				FadeEffect = GameCamera.gameObject.AddComponent<Fade>();
				FadeEffect._Color.a = 0f;
			}
		}

		private void Fade()
		{
			if ((bool)FadeEffect)
			{
				fade = Mathf.Lerp(fade, 0f, 0.1f);
				FadeEffect._Color.a = fade;
			}
			else
			{
				UnityEngine.Debug.LogError("Fade effect not set");
			}
		}

		private void Teleport()
		{
			GameCamera.transform.localRotation = RespawnPoint.localRotation;
			GameCamera.transform.localPosition = RespawnPoint.localPosition;
		}

		private void OnBoxExit()
		{
			fade = 1f;
			GameCamera.transform.parent.eulerAngles = Vector3.zero;
			exit = true;
			_ExplorationCamera.enabled = false;
			Teleport();
			GameCamera.fieldOfView = InitialFOV;
			_ExplorationCamera.FOV = InitialFOV;
			_ExplorationCamera.tilt = 0f;
			_ExplorationCamera.Speed = _ExplorationCamera.InitialSpeed;
			_ExplorationCamera.enabled = true;
		}

		private void OnBoxEnter()
		{
			enter = true;
			fade = 1f;
		}

		private Vector3 ClosestPoint(BoundingBox _BoundingBox, Vector3 Point)
		{
			Vector3 result = default(Vector3);
			if (Point.x > _BoundingBox.max.x)
			{
				result.x = _BoundingBox.max.x;
			}
			else if (Point.x < _BoundingBox.min.x)
			{
				result.x = _BoundingBox.min.x;
			}
			else
			{
				result.x = Point.x;
			}
			if (Point.y > _BoundingBox.max.y)
			{
				result.y = _BoundingBox.max.y;
			}
			else if (Point.y < _BoundingBox.min.y)
			{
				result.y = _BoundingBox.min.y;
			}
			else
			{
				result.y = Point.y;
			}
			if (Point.z > _BoundingBox.max.z)
			{
				result.z = _BoundingBox.max.z;
			}
			else if (Point.z < _BoundingBox.min.z)
			{
				result.z = _BoundingBox.min.z;
			}
			else
			{
				result.z = Point.z;
			}
			return result;
		}

		private void BoundariesDistanceCheck()
		{
			if (isInside)
			{
				float num = Vector3.Magnitude(CurrentCameraPosition - BoundariesExterior.transform.position);
				num /= InteriorRadiusFade;
				num = Mathf.Pow(num, RadialPow);
				num = Mathf.Clamp(num, 0f, 1.1f);
				if ((double)num > 0.1)
				{
					fade = num;
				}
				if (num > 0.99f)
				{
					Teleport();
				}
			}
			_ClosestPoint = ClosestPoint(_CurrentPlayableBoundingBox, CurrentCameraPosition);
			if (DebugIntersectionPoint != null)
			{
				DebugIntersectionPoint.transform.position = _ClosestPoint;
			}
		}

		private void FixedUpdate()
		{
			CurrentCameraPosition = GameCamera.transform.position;
			if ((bool)_ShadowCaster && (bool)_ExplorationCamera && (bool)_Rotator && (bool)_FogVolumeRenderer && (bool)GameCamera && (bool)_FogVolume)
			{
				_ExplorationCamera.FOVTransitionSpeed = FOVTransitionSpeed;
				PointIsInsideVolume(GameCamera.transform.position);
				BoundariesDistanceCheck();
				if (isInside)
				{
					if (!enter)
					{
						OnBoxEnter();
					}
					Fade();
					ToggleObjects();
					count++;
					_ShadowCaster.fogVolumeScale.x = AtmosphereSizeInside;
					_ShadowCaster.fogVolumeScale.x = AtmosphereSizeInside;
					_ShadowCaster.UpdateBoxMesh();
					CurrentFOV = Mathf.Lerp(CurrentFOV, targetFOV, FOVTransitionSpeed);
					_ExplorationCamera.FOV = CurrentFOV;
					_Rotator.enabled = false;
					_FogVolumeRenderer.enabled = true;
					GameCamera.clearFlags = CameraClearFlags.Skybox;
					for (int i = 0; i < SceneReflectionProbes.Length; i++)
					{
						SceneReflectionProbes[i].enabled = false;
					}
					exit = false;
				}
				else
				{
					Fade();
					enter = false;
					for (int j = 0; j < SceneReflectionProbes.Length; j++)
					{
						SceneReflectionProbes[j].enabled = true;
					}
					ToggleObjects();
					GameCamera.clearFlags = CameraClearFlags.Color;
					_ShadowCaster.fogVolumeScale.x = AtmosphereSizeOutside;
					_ShadowCaster.UpdateBoxMesh();
					if (count < 1)
					{
						_Rotator.enabled = true;
					}
					CurrentFOV = _ExplorationCamera.FOV;
					if (!EnableFogVolumeRendererOutsideBox)
					{
						_FogVolumeRenderer.enabled = false;
					}
					if (RespawnPoint != null && !exit)
					{
						OnBoxExit();
						_ExplorationCamera.enabled = true;
					}
				}
			}
			else
			{
				MonoBehaviour.print("Config not complete");
			}
			_ShadowCaster.UpdateBoxMesh();
			_FogVolume.UpdateBoxMesh();
		}

		private void Update()
		{
			if (!isInside)
			{
				if (EnableFogVolumeRendererOutsideBox)
				{
					_FogVolumeRenderer.enabled = true;
				}
				else
				{
					_FogVolumeRenderer.enabled = false;
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class SunDirection : MonoBehaviour
	{
		public Material _Material;

		public bool RealtimeUpdate;

		public Vector3 L;

		private void SetVector()
		{
			if ((bool)_Material)
			{
				L = base.transform.forward;
				_Material.SetVector("_L", -L);
			}
		}

		private void OnEnable()
		{
			SetVector();
		}

		private void Update()
		{
			if (RealtimeUpdate)
			{
				SetVector();
			}
		}
	}
	[ExecuteInEditMode]
	public class TOD_Values : MonoBehaviour
	{
		public bool Active;

		public Color ambientLight;

		public Vector3 SunDirection = Vector3.zero;

		private Light Sun;

		public float SunIntensity = 1f;

		public Color SunColor = Color.white;

		private void OnEnable()
		{
			Sun = base.gameObject.GetComponent<FogVolume>().Sun;
		}

		private void Update()
		{
			if (Active && (bool)Sun)
			{
				Sun.transform.eulerAngles = SunDirection;
				Sun.color = SunColor;
				Sun.intensity = SunIntensity;
				RenderSettings.ambientLight = ambientLight;
			}
		}
	}
	public class MainMenuButton : MonoBehaviour
	{
		public static GameObject menuInstance;

		private void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			if (menuInstance == null)
			{
				menuInstance = base.gameObject;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.Escape))
			{
				if (SceneManager.GetActiveScene().buildIndex != 0)
				{
					SceneManager.LoadScene(0, LoadSceneMode.Single);
				}
				else
				{
					Application.Quit();
				}
			}
		}

		public void LoadMainMenu()
		{
			SceneManager.LoadScene(0, LoadSceneMode.Single);
		}
	}
	public class SceneMenu : MonoBehaviour
	{
		public string[] sceneNames;

		public float Height = 70f;

		public Transform prefabButton;

		private Canvas canvas;

		private void FixedUpdate()
		{
			if (Input.GetKey(KeyCode.Escape))
			{
				Application.Quit();
			}
		}

		private void Start()
		{
			canvas = GetComponent<Canvas>();
			for (int i = 0; i < sceneNames.Length; i++)
			{
				Transform obj = UnityEngine.Object.Instantiate(prefabButton, Vector3.zero, Quaternion.identity);
				obj.SetParent(canvas.transform);
				obj.position -= Vector3.up * i * 50f;
				obj.position += Vector3.up * Height;
				obj.GetComponentInChildren<Text>().text = sceneNames[i];
				string a = sceneNames[i];
				obj.GetComponent<Button>().onClick.AddListener(delegate
				{
					onClick(a);
				});
			}
		}

		private void onClick(string _nameScene)
		{
			SceneManager.LoadScene(_nameScene, LoadSceneMode.Single);
		}
	}
	public class VerticalOscilator : MonoBehaviour
	{
		private Vector3 _Position;

		private float _Time;

		private float _Random;

		[Range(0f, 1f)]
		public float Speed = 1f;

		[Range(0f, 1f)]
		public float Amplitude = 1f;

		[Range(0.1f, 10f)]
		public float random = 1f;

		private void Start()
		{
			_Position = base.transform.localPosition;
			_Random = UnityEngine.Random.Range(0.1f, random);
		}

		private void Update()
		{
			_Time += Time.deltaTime * Speed;
			_Position.y = Mathf.Sin(_Time + _Random) * Amplitude + base.transform.localPosition.y;
			base.transform.localPosition = _Position;
		}
	}
	public enum EFogVolumeLightType
	{
		None,
		FogVolumePointLight,
		FogVolumeSpotLight,
		PointLight,
		SpotLight
	}
	public enum EFogVolumePrimitiveType
	{
		Box,
		Sphere,
		None
	}
	[ExecuteInEditMode]
	public class FogVolume : MonoBehaviour
	{
		public enum FogType
		{
			Uniform,
			Textured
		}

		public enum SamplingMethod
		{
			Eye2Box,
			ViewAligned
		}

		public enum DebugMode
		{
			Lit,
			Iterations,
			Inscattering,
			VolumetricShadows,
			VolumeFogInscatterClamp,
			VolumeFogPhase
		}

		public enum VortexAxis
		{
			X,
			Y,
			Z
		}

		public enum LightScatterMethod
		{
			BeersLaw,
			InverseSquare,
			Linear
		}

		public FogType _FogType;

		public bool RenderableInSceneView = true;

		private GameObject FogVolumeGameObject;

		public FogVolume ShadowCaster;

		public Texture2D _PerformanceLUT;

		public Vector3 fogVolumeScale = new Vector3(20f, 20f, 20f);

		[SerializeField]
		public Color FogMainColor = Color.white;

		public Color _FogColor = Color.white;

		public bool _AmbientAffectsFogColor;

		[Range(1f, 5f)]
		public float Exposure = 2.5f;

		[Range(-0.5f, 0.5f)]
		public float Offset;

		[Range(0.01f, 3f)]
		public float Gamma = 1f;

		public bool Tonemap;

		public float Visibility = 25f;

		[HideInInspector]
		public bool ColorAdjust;

		[Header("Lighting")]
		public int _SelfShadowSteps = 3;

		public int ShadowCameraSkippedFrames;

		public Color _SelfShadowColor = Color.black;

		public float VolumeFogInscatteringAnisotropy = 0.5f;

		public float VolumeFogInscatteringIntensity = 0.1f;

		public float VolumeFogInscatteringStartDistance = 10f;

		public float VolumeFogInscatteringTransitionWideness = 1f;

		public Color VolumeFogInscatteringColor = Color.white;

		public bool VolumeFogInscattering;

		public float HeightAbsorption;

		public float HeightAbsorptionMin = -1f;

		public float HeightAbsorptionMax = -1f;

		public bool SunAttached;

		[SerializeField]
		public Light Sun;

		[SerializeField]
		public bool _ShadeNoise;

		public bool _DirectionalLighting;

		public float _DirectionalLightingDistance = 0.01f;

		public float DirectLightingShadowDensity = 1f;

		public Color LightExtinctionColor = new Color(27f / 85f, 0.1764706f, 0.101960786f, 0f);

		public int DirectLightingShadowSteps = 1;

		public bool bAbsorption = true;

		public float Absorption = 0.5f;

		public float _LightExposure = 1f;

		public bool Lambert;

		public float LambertianBias = 1f;

		public float NormalDistance = 0.01f;

		public float DirectLightingAmount = 1f;

		public float DirectLightingDistance = 10f;

		[Range(1f, 3f)]
		public float ShadowBrightness = 1f;

		public Color _AmbientColor = Color.gray;

		private bool _ProxyVolume;

		[SerializeField]
		[Range(0f, 0.15f)]
		public float ShadowShift = 0.0094f;

		[Range(0f, 5f)]
		public float PointLightsIntensity = 1f;

		public float PointLightingDistance = 1000f;

		public float PointLightingDistance2Camera = 50f;

		public float PointLightCullSizeMultiplier = 1f;

		public bool PointLightsActive;

		public bool EnableInscattering;

		public Color InscatteringColor = Color.white;

		public Texture2D _LightHaloTexture;

		public Texture2D CoverageTex;

		public bool LightHalo;

		public float _HaloWidth = 0.75f;

		public float _HaloOpticalDispersion = 1f;

		public float _HaloRadius = 1f;

		public float _HaloIntensity = 1f;

		public float _HaloAbsorption = 0.5f;

		[Range(-1f, 1f)]
		public float InscatteringShape;

		public float InscatteringIntensity = 0.2f;

		public float InscatteringStartDistance;

		public float InscatteringTransitionWideness = 1f;

		[Header("Noise")]
		public bool EnableNoise;

		public int Octaves = 1;

		public float _DetailMaskingThreshold = 18f;

		public bool bSphericalFade;

		public float SphericalFadeDistance = 10f;

		public float DetailDistance = 500f;

		public float DetailTiling = 1f;

		public float _DetailRelativeSpeed = 10f;

		public float _BaseRelativeSpeed = 1f;

		public float _NoiseDetailRange = 0.5f;

		public float _Curl = 0.5f;

		public float BaseTiling = 8f;

		public float Coverage = 1.5f;

		public float NoiseDensity = 1f;

		public float _3DNoiseScale = 80f;

		[Range(10f, 300f)]
		public int Iterations = 85;

		public FogVolumeRenderer.BlendMode _BlendMode = FogVolumeRenderer.BlendMode.TraditionalTransparency;

		public float IterationStep = 500f;

		public float _OptimizationFactor;

		public SamplingMethod _SamplingMethod;

		public bool _VisibleByReflectionProbeStatic = true;

		private FogVolumeRenderer _FogVolumeRenderer;

		public GameObject GameCameraGO;

		public DebugMode _DebugMode;

		public bool useHeightGradient;

		public float GradMin = 1f;

		public float GradMax = -1f;

		public float GradMin2 = -1f;

		public float GradMax2 = -1f;

		public Texture3D _NoiseVolume2;

		public Texture3D _NoiseVolume;

		[Range(0f, 10f)]
		public float NoiseIntensity = 0.3f;

		[Range(0f, 5f)]
		public float NoiseContrast = 12f;

		public float FadeDistance = 5000f;

		[Range(0f, 20f)]
		public float Vortex;

		public VortexAxis _VortexAxis = VortexAxis.Z;

		public bool bVolumeFog;

		public bool VolumeFogInscatterColorAffectedWithFogColor = true;

		public LightScatterMethod _LightScatterMethod = LightScatterMethod.InverseSquare;

		[Range(0f, 360f)]
		public float rotation;

		[Range(0f, 10f)]
		public float RotationSpeed;

		public Vector4 Speed = new Vector4(0f, 0f, 0f, 0f);

		public Vector4 Stretch = new Vector4(0f, 0f, 0f, 0f);

		[SerializeField]
		[Header("Collision")]
		public bool SceneCollision = true;

		public bool ShowPrimitives;

		public bool EnableDistanceFields;

		public float _PrimitiveEdgeSoftener = 1f;

		public float _PrimitiveCutout;

		public float Constrain;

		[SerializeField]
		[Range(1f, 200f)]
		public float _SceneIntersectionSoftness = 1f;

		[SerializeField]
		[Range(0f, 0.1f)]
		public float _jitter = 0.0045f;

		public MeshRenderer FogRenderer;

		public Texture2D[] _InspectorBackground;

		public int _InspectorBackgroundIndex;

		public string Description = "";

		[Header("Gradient")]
		public bool EnableGradient;

		public Texture2D Gradient;

		[SerializeField]
		public bool HideWireframe = true;

		[SerializeField]
		public bool SaveMaterials;

		[SerializeField]
		public bool RequestSavingMaterials;

		[SerializeField]
		public int DrawOrder;

		[SerializeField]
		public bool ShowDebugGizmos;

		private MeshFilter filter;

		private Mesh mesh;

		public RenderTexture RT_Opacity;

		public RenderTexture RT_OpacityBlur;

		public float ShadowCutoff = 1f;

		private Vector3 currentFogVolume = Vector3.one;

		public bool CastShadows;

		public GameObject ShadowCameraGO;

		public int shadowCameraPosition = 20;

		public ShadowCamera _ShadowCamera;

		public float _PushAlpha = 1f;

		[SerializeField]
		private Material fogMaterial;

		public Shader FogVolumeShader;

		[SerializeField]
		private GameObject ShadowProjector;

		private MeshRenderer ShadowProjectorRenderer;

		private MeshFilter ShadowProjectorMeshFilter;

		private Material ShadowProjectorMaterial;

		public Mesh ShadowProjectorMesh;

		public Color ShadowColor = new Color(0.5f, 0.5f, 0.5f, 0.25f);

		public CompareFunction _ztest;

		private Plane[] FrustumPlanes;

		private Camera GameCamera;

		private Material SurrogateMaterial;

		private BoxCollider _BoxCollider;

		public FogVolumeData _FogVolumeData;

		private GameObject _FogVolumeDataGO;

		public bool ExcludeFromLowRes;

		public float PointLightCPUMaxDistance = 1f;

		private GameObject PointLightsCameraGO;

		private Camera PointLightsCamera;

		public float PointLightScreenMargin = 1f;

		public bool PointLightsRealTimeUpdate = true;

		public bool PointLightBoxCheck = true;

		public bool PrimitivesRealTimeUpdate = true;

		public bool IsVisible;

		public bool CreateSurrogate = true;

		public bool InjectCustomDepthBuffer;

		public bool UseConvolvedLightshafts;

		private bool m_hasUpdatedBoxMesh;

		private FogVolumeLightManager m_lightManager;

		private FogVolumePrimitiveManager m_primitiveManager;

		public int ShadowCameraPosition
		{
			get
			{
				return shadowCameraPosition;
			}
			set
			{
				if (value != shadowCameraPosition)
				{
					shadowCameraPosition = value;
					_ShadowCamera.CameraTransform();
				}
			}
		}

		public Material FogMaterial
		{
			get
			{
				if (fogMaterial == null)
				{
					CreateMaterial();
				}
				return fogMaterial;
			}
		}

		public bool HasUpdatedBoxMesh
		{
			get
			{
				bool hasUpdatedBoxMesh = m_hasUpdatedBoxMesh;
				m_hasUpdatedBoxMesh = false;
				return hasUpdatedBoxMesh;
			}
		}

		public void setNoiseIntensity(float value)
		{
			NoiseIntensity = value;
		}

		public float GetVisibility()
		{
			return Visibility;
		}

		private void RemoveMaterial()
		{
		}

		private void CreateMaterial()
		{
			if (SaveMaterials)
			{
				FogVolumeShader = Shader.Find("Hidden/FogVolume");
				fogMaterial = new Material(FogVolumeShader);
				return;
			}
			UnityEngine.Object.DestroyImmediate(fogMaterial);
			FogVolumeShader = Shader.Find("Hidden/FogVolume");
			fogMaterial = new Material(FogVolumeShader);
			try
			{
				fogMaterial.name = FogVolumeGameObject.name + " Material";
			}
			catch
			{
				MonoBehaviour.print(base.name);
			}
			fogMaterial.hideFlags = HideFlags.HideAndDontSave;
		}

		private void ShadowProjectorLock()
		{
			if ((bool)ShadowProjector)
			{
				ShadowProjector.transform.position = new Vector3(FogVolumeGameObject.transform.position.x, ShadowProjector.transform.position.y, FogVolumeGameObject.transform.position.z);
				Vector3 localScale = new Vector3(fogVolumeScale.x, ShadowProjector.transform.localScale.y, fogVolumeScale.z);
				ShadowProjector.transform.localScale = localScale;
				ShadowProjector.transform.localRotation = default(Quaternion);
			}
		}

		private void ShadowMapSetup()
		{
			if ((bool)ShadowCameraGO)
			{
				ShadowCameraGO.GetComponent<Camera>().cullingMask = 1 << LayerMask.NameToLayer("FogVolumeShadowCaster");
				ShadowCameraGO.GetComponent<Camera>().renderingPath = RenderingPath.Forward;
				_ShadowCamera.CameraTransform();
			}
			if (CastShadows)
			{
				fogVolumeScale.z = fogVolumeScale.x;
			}
			if (CastShadows)
			{
				ShadowProjector = GameObject.Find(FogVolumeGameObject.name + " Shadow Projector");
				if (ShadowProjector == null)
				{
					ShadowProjector = new GameObject();
					ShadowProjector.AddComponent<MeshFilter>();
					ShadowProjector.AddComponent<MeshRenderer>();
					ShadowProjector.transform.parent = FogVolumeGameObject.transform;
					ShadowProjector.transform.position = FogVolumeGameObject.transform.position;
					ShadowProjector.transform.rotation = FogVolumeGameObject.transform.rotation;
					ShadowProjector.transform.localScale = fogVolumeScale;
					ShadowProjector.GetComponent<MeshRenderer>().shadowCastingMode = ShadowCastingMode.Off;
					ShadowProjector.GetComponent<MeshRenderer>().receiveShadows = false;
					ShadowProjector.GetComponent<MeshRenderer>().reflectionProbeUsage = ReflectionProbeUsage.Off;
					ShadowProjector.GetComponent<MeshRenderer>().lightProbeUsage = LightProbeUsage.Off;
				}
				ShadowProjectorMeshFilter = ShadowProjector.GetComponent<MeshFilter>();
				ShadowProjectorMeshFilter.mesh = ShadowProjectorMesh;
				if (ShadowProjectorMesh == null)
				{
					GameObject gameObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
					ShadowProjectorMesh = gameObject.GetComponent<MeshFilter>().sharedMesh;
					UnityEngine.Object.DestroyImmediate(gameObject, allowDestroyingAssets: true);
				}
				if (ShadowProjector.GetComponent<MeshFilter>().sharedMesh == null)
				{
					ShadowProjector.GetComponent<MeshFilter>().mesh = ShadowProjectorMesh;
				}
				if (ShadowProjectorMesh == null)
				{
					MonoBehaviour.print("Missing mesh");
				}
				ShadowProjectorRenderer = ShadowProjector.GetComponent<MeshRenderer>();
				ShadowProjectorRenderer.lightProbeUsage = LightProbeUsage.Off;
				ShadowProjectorRenderer.reflectionProbeUsage = ReflectionProbeUsage.Off;
				ShadowProjectorRenderer.shadowCastingMode = ShadowCastingMode.Off;
				ShadowProjectorRenderer.receiveShadows = false;
				ShadowProjectorMaterial = ShadowProjectorRenderer.sharedMaterial;
				ShadowProjector.name = FogVolumeGameObject.name + " Shadow Projector";
				if (ShadowProjectorMaterial == null)
				{
					ShadowProjectorMaterial = new Material(Shader.Find("Fog Volume/Shadow Projector"));
					ShadowProjectorMaterial.name = "Shadow Projector Material";
				}
				ShadowProjectorRenderer.sharedMaterial = ShadowProjectorMaterial;
			}
		}

		private void SetShadowProyectorLayer()
		{
			if (!ShadowProjector)
			{
				return;
			}
			if (!RenderableInSceneView)
			{
				if (ShadowProjector.layer == LayerMask.NameToLayer("Default"))
				{
					ShadowProjector.layer = LayerMask.NameToLayer("UI");
				}
			}
			else if (ShadowProjector.layer == LayerMask.NameToLayer("UI"))
			{
				ShadowProjector.layer = LayerMask.NameToLayer("Default");
			}
		}

		private void FindDirectionalLight()
		{
			Light[] array = UnityEngine.Object.FindObjectsOfType<Light>();
			if (!Sun)
			{
				Sun = RenderSettings.sun;
			}
			if (!Sun)
			{
				Light[] array2 = array;
				foreach (Light light in array2)
				{
					if (light.type == LightType.Directional)
					{
						Sun = light;
						break;
					}
				}
			}
			if (Sun == null)
			{
				UnityEngine.Debug.LogError("Fog Volume: No valid light found\nDirectional light is required. Light component can be disabled.");
				return;
			}
			Sun.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeUniform"));
			Sun.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolume"));
			Sun.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeSurrogate"));
		}

		public void FindFogVolumeData()
		{
			if (_FogVolumeDataGO == null)
			{
				FogVolumeData[] array = UnityEngine.Object.FindObjectsOfType<FogVolumeData>();
				if (array.Length == 0)
				{
					_FogVolumeDataGO = new GameObject();
					_FogVolumeData = _FogVolumeDataGO.AddComponent<FogVolumeData>();
					_FogVolumeDataGO.name = "Fog Volume Data";
				}
				else
				{
					_FogVolumeDataGO = array[0].gameObject;
					_FogVolumeData = array[0];
				}
			}
			else
			{
				_FogVolumeData = _FogVolumeDataGO.GetComponent<FogVolumeData>();
			}
		}

		private void MoveToLayer()
		{
			if (CastShadows || ExcludeFromLowRes)
			{
				return;
			}
			if (_FogType == FogType.Textured)
			{
				if (FogVolumeGameObject.layer != LayerMask.NameToLayer("FogVolume"))
				{
					FogVolumeGameObject.layer = LayerMask.NameToLayer("FogVolume");
				}
			}
			else if (FogVolumeGameObject.layer != LayerMask.NameToLayer("FogVolumeUniform"))
			{
				FogVolumeGameObject.layer = LayerMask.NameToLayer("FogVolumeUniform");
			}
		}

		public void AssignCamera()
		{
			FindFogVolumeData();
			if (_FogVolumeDataGO == null)
			{
				return;
			}
			if (_FogVolumeData.GetFogVolumeCamera != null)
			{
				GameCameraGO = _FogVolumeData.GetFogVolumeCamera.gameObject;
			}
			if (GameCameraGO == null)
			{
				base.enabled = false;
				return;
			}
			base.enabled = true;
			GameCamera = GameCameraGO.GetComponent<Camera>();
			_FogVolumeRenderer = GameCameraGO.GetComponent<FogVolumeRenderer>();
			if (_FogVolumeRenderer == null)
			{
				if (!_FogVolumeData.ForceNoRenderer)
				{
					_FogVolumeRenderer = GameCameraGO.AddComponent<FogVolumeRenderer>();
					_FogVolumeRenderer.enabled = true;
				}
			}
			else if (!_FogVolumeData.ForceNoRenderer)
			{
				_FogVolumeRenderer.enabled = true;
			}
		}

		private void SetIcon()
		{
		}

		private void OnEnable()
		{
			m_lightManager = null;
			m_primitiveManager = null;
			SetIcon();
			AssignCamera();
			SurrogateMaterial = Resources.Load("Fog Volume Surrogate", typeof(Material)) as Material;
			FindDirectionalLight();
			_BoxCollider = GetComponent<BoxCollider>();
			if (_BoxCollider == null)
			{
				_BoxCollider = base.gameObject.AddComponent<BoxCollider>();
			}
			_BoxCollider.hideFlags = HideFlags.HideAndDontSave;
			_BoxCollider.isTrigger = true;
			FogVolumeGameObject = base.gameObject;
			FogRenderer = FogVolumeGameObject.GetComponent<MeshRenderer>();
			if (FogRenderer == null)
			{
				FogRenderer = FogVolumeGameObject.AddComponent<MeshRenderer>();
			}
			FogRenderer.sharedMaterial = FogMaterial;
			ToggleKeyword();
			if (FogRenderer.shadowCastingMode == ShadowCastingMode.On)
			{
				string text = FogVolumeGameObject.name + " Shadow Camera";
				ShadowCameraGO = GameObject.Find(text);
				if (ShadowCameraGO == null)
				{
					ShadowCameraGO = new GameObject(text);
					ShadowCameraGO.transform.parent = FogVolumeGameObject.transform;
					ShadowCameraGO.AddComponent<Camera>();
					Camera component = ShadowCameraGO.GetComponent<Camera>();
					component.orthographic = true;
					component.depth = -6f;
					component.clearFlags = CameraClearFlags.Color;
					component.backgroundColor = new Color(0f, 0f, 0f, 0f);
					component.allowHDR = false;
					component.allowMSAA = false;
					_ShadowCamera = ShadowCameraGO.AddComponent<ShadowCamera>();
				}
				ShadowCameraGO.hideFlags = HideFlags.HideInHierarchy;
				_ShadowCamera = ShadowCameraGO.GetComponent<ShadowCamera>();
				ShadowMapSetup();
			}
			if (filter == null)
			{
				filter = base.gameObject.GetComponent<MeshFilter>();
				CreateBoxMesh(base.transform.localScale);
				base.transform.localScale = Vector3.one;
			}
			filter.hideFlags = HideFlags.HideInInspector;
			UpdateBoxMesh();
			_PerformanceLUT = Resources.Load("PerformanceLUT") as Texture2D;
			GetShadowMap();
			_FogVolumeData.FindFogVolumes();
			if (FrustumPlanes == null)
			{
				FrustumPlanes = new Plane[6];
			}
			_InitializeLightManagerIfNeccessary();
			_InitializePrimitiveManagerIfNeccessary();
		}

		private float GetPointLightDistance2Camera(Vector3 lightPosition)
		{
			PointLightsCameraGO = Camera.current.gameObject;
			return (lightPosition - PointLightsCameraGO.transform.position).magnitude;
		}

		private bool PointIsVisible(Vector3 point)
		{
			PointLightsCamera = PointLightsCameraGO.GetComponent<Camera>();
			float num = 0f - PointLightScreenMargin;
			float num2 = 1f + PointLightScreenMargin;
			bool flag = true;
			Vector3 vector = PointLightsCamera.WorldToViewportPoint(point);
			if (vector.z > num && vector.x > num && vector.x < num2 && vector.y > num && vector.y < num2)
			{
				return true;
			}
			return false;
		}

		public bool PointIsInsideVolume(Vector3 PointPosition)
		{
			bool result = false;
			float num = base.gameObject.transform.position.x + fogVolumeScale.x / 2f;
			float num2 = base.gameObject.transform.position.x - fogVolumeScale.x / 2f;
			float num3 = base.gameObject.transform.position.y + fogVolumeScale.y / 2f;
			float num4 = base.gameObject.transform.position.y - fogVolumeScale.y / 2f;
			float num5 = base.gameObject.transform.position.z + fogVolumeScale.z / 2f;
			float num6 = base.gameObject.transform.position.z - fogVolumeScale.z / 2f;
			if (num > PointPosition.x && num2 < PointPosition.x && num3 > PointPosition.y && num4 < PointPosition.y && num5 > PointPosition.z && num6 < PointPosition.z)
			{
				result = true;
			}
			return result;
		}

		private Vector3 LocalDirectionalSunLight(Light Sun)
		{
			return base.transform.InverseTransformVector(-Sun.transform.forward);
		}

		private void OnDisable()
		{
			m_lightManager = null;
			m_primitiveManager = null;
		}

		public static void Wireframe(GameObject obj, bool Enable)
		{
		}

		private void OnBecameVisible()
		{
		}

		private void GetShadowMap()
		{
			if (!FogRenderer)
			{
				FogRenderer = FogVolumeGameObject.GetComponent<MeshRenderer>();
			}
			if (!IsVisible)
			{
				return;
			}
			if (FogRenderer != null && FogRenderer.shadowCastingMode == ShadowCastingMode.Off)
			{
				CastShadows = false;
			}
			if (FogRenderer.shadowCastingMode == ShadowCastingMode.On)
			{
				if (_FogType == FogType.Textured)
				{
					CastShadows = true;
				}
				else
				{
					FogRenderer.shadowCastingMode = ShadowCastingMode.Off;
				}
			}
			if (CastShadows && _ShadowCamera == null)
			{
				ShadowMapSetup();
				RT_OpacityBlur = _ShadowCamera.GetOpacityBlurRT();
			}
			if ((bool)_ShadowCamera)
			{
				ShadowCameraGO.SetActive(CastShadows);
			}
			if (CastShadows)
			{
				RT_Opacity = _ShadowCamera.GetOpacityRT();
			}
			else if ((bool)ShadowCaster && FogRenderer.receiveShadows)
			{
				RT_Opacity = ShadowCaster.RT_Opacity;
				RT_OpacityBlur = ShadowCaster.RT_OpacityBlur;
				fogVolumeScale.x = ShadowCaster.fogVolumeScale.x;
				fogVolumeScale.z = fogVolumeScale.x;
			}
			if (CastShadows)
			{
				FogVolumeGameObject.layer = LayerMask.NameToLayer("FogVolumeShadowCaster");
			}
			if (CastShadows && (bool)ShadowCaster)
			{
				FogMaterial.DisableKeyword("VOLUME_SHADOWS");
			}
			if (((bool)ShadowCaster && ShadowCaster.CastShadows) || FogRenderer.receiveShadows)
			{
				FogMaterial.EnableKeyword("VOLUME_SHADOWS");
			}
			if (((bool)ShadowCaster && !ShadowCaster.CastShadows) || !FogRenderer.receiveShadows)
			{
				FogMaterial.DisableKeyword("VOLUME_SHADOWS");
			}
		}

		private void Update()
		{
			if (InjectCustomDepthBuffer && !FogMaterial.IsKeywordEnabled("ExternalDepth") && ExcludeFromLowRes)
			{
				FogMaterial.EnableKeyword("ExternalDepth");
			}
			if (FogMaterial.IsKeywordEnabled("ExternalDepth") && ExcludeFromLowRes && !InjectCustomDepthBuffer)
			{
				FogMaterial.DisableKeyword("ExternalDepth");
			}
			if (GameCamera == null)
			{
				AssignCamera();
			}
			if (PointLightCullSizeMultiplier < 1f)
			{
				PointLightCullSizeMultiplier = 1f;
			}
			if (m_lightManager != null)
			{
				m_lightManager.DrawDebugData = ShowDebugGizmos;
				m_lightManager.SetPointLightCullSizeMultiplier(PointLightCullSizeMultiplier);
			}
			if (m_primitiveManager != null)
			{
				m_primitiveManager.SetVisibility(ShowPrimitives);
			}
			if (GameCamera != null)
			{
				FrustumPlanes = GeometryUtility.CalculateFrustumPlanes(GameCamera);
				if (Application.isPlaying)
				{
					if (GeometryUtility.TestPlanesAABB(FrustumPlanes, _BoxCollider.bounds))
					{
						IsVisible = true;
					}
					else
					{
						IsVisible = false;
					}
				}
				else
				{
					IsVisible = true;
				}
			}
			if (EnableNoise || EnableGradient)
			{
				_FogType = FogType.Textured;
			}
			else
			{
				_FogType = FogType.Uniform;
			}
			UpdateBoxMesh();
			ShadowProjectorLock();
			RenderSurrogate();
			if (ShadowProjector != null && CastShadows)
			{
				ShadowProjectorMaterial.SetColor("_ShadowColor", ShadowColor);
			}
			if ((FogMaterial.GetTexture("_NoiseVolume") == null && _NoiseVolume != null) || FogMaterial.GetTexture("_NoiseVolume") != _NoiseVolume)
			{
				FogMaterial.SetTexture("_NoiseVolume", _NoiseVolume);
			}
			if ((FogMaterial.GetTexture("_NoiseVolume2") == null && _NoiseVolume2 != null) || FogMaterial.GetTexture("_NoiseVolume2") != _NoiseVolume2)
			{
				FogMaterial.SetTexture("_NoiseVolume2", _NoiseVolume2);
			}
			if ((FogMaterial.GetTexture("CoverageTex") == null && CoverageTex != null) || FogMaterial.GetTexture("CoverageTex") != CoverageTex)
			{
				FogMaterial.SetTexture("CoverageTex", CoverageTex);
			}
		}

		public void RenderSurrogate()
		{
			if (IsVisible)
			{
				if (GameCameraGO == null)
				{
					AssignCamera();
				}
				FogVolumeRenderer fogVolumeRenderer = GameCameraGO.GetComponent<FogVolumeRenderer>();
				if (fogVolumeRenderer == null && !_FogVolumeData.ForceNoRenderer)
				{
					fogVolumeRenderer = GameCameraGO.AddComponent<FogVolumeRenderer>();
					fogVolumeRenderer.enabled = true;
				}
				if (!_FogVolumeData.ForceNoRenderer && fogVolumeRenderer._Downsample > 0 && CreateSurrogate && mesh != null && _FogType == FogType.Textured)
				{
					Graphics.DrawMesh(mesh, base.transform.position, base.transform.rotation, SurrogateMaterial, LayerMask.NameToLayer("FogVolumeSurrogate"), null, 0, null, castShadows: false, receiveShadows: false, useLightProbes: false);
				}
			}
		}

		private void UpdateParams()
		{
			if (!IsVisible)
			{
				return;
			}
			if ((bool)_PerformanceLUT && _DebugMode == DebugMode.Iterations)
			{
				FogMaterial.SetTexture("_PerformanceLUT", _PerformanceLUT);
			}
			if (_DebugMode != 0)
			{
				FogMaterial.SetInt("_DebugMode", (int)_DebugMode);
			}
			if (FogType.Textured == _FogType)
			{
				FogMaterial.SetInt("_SrcBlend", (int)_BlendMode);
			}
			else
			{
				FogMaterial.SetInt("_SrcBlend", 5);
			}
			FogMaterial.SetInt("_ztest", (int)_ztest);
			if (m_lightManager != null && m_lightManager.CurrentLightCount > 0 && PointLightsActive && SystemInfo.graphicsShaderLevel > 30)
			{
				FogMaterial.SetVectorArray("_LightPositions", m_lightManager.GetLightPositionArray());
				FogMaterial.SetVectorArray("_LightRotations", m_lightManager.GetLightRotationArray());
				FogMaterial.SetColorArray("_LightColors", m_lightManager.GetLightColorArray());
				FogMaterial.SetVectorArray("_LightData", m_lightManager.GetLightData());
				FogMaterial.SetFloat("PointLightingDistance", 1f / PointLightingDistance);
				FogMaterial.SetFloat("PointLightingDistance2Camera", 1f / PointLightingDistance2Camera);
			}
			if (m_primitiveManager != null && m_primitiveManager.CurrentPrimitiveCount > 0 && EnableDistanceFields)
			{
				FogMaterial.SetFloat("Constrain", Constrain);
				FogMaterial.SetVectorArray("_PrimitivePosition", m_primitiveManager.GetPrimitivePositionArray());
				FogMaterial.SetVectorArray("_PrimitiveScale", m_primitiveManager.GetPrimitiveScaleArray());
				FogMaterial.SetInt("_PrimitiveCount", m_primitiveManager.VisiblePrimitiveCount);
				FogMaterial.SetMatrixArray("_PrimitivesTransform", m_primitiveManager.GetPrimitiveTransformArray());
				FogMaterial.SetFloat("_PrimitiveEdgeSoftener", 1f / _PrimitiveEdgeSoftener);
				FogMaterial.SetFloat("_PrimitiveCutout", _PrimitiveCutout);
				FogMaterial.SetVectorArray("_PrimitiveData", m_primitiveManager.GetPrimitiveDataArray());
			}
			if ((bool)Sun && Sun.enabled)
			{
				FogMaterial.SetFloat("_LightExposure", _LightExposure);
				if (LightHalo && (bool)_LightHaloTexture)
				{
					FogMaterial.SetTexture("_LightHaloTexture", _LightHaloTexture);
					FogMaterial.SetFloat("_HaloOpticalDispersion", _HaloOpticalDispersion);
					FogMaterial.SetFloat("_HaloWidth", _HaloWidth.Remap(0f, 1f, 10f, 1f));
					FogMaterial.SetFloat("_HaloIntensity", _HaloIntensity * 2000f);
					FogMaterial.SetFloat("_HaloRadius", _HaloRadius.Remap(0f, 1f, 2f, 0.1f));
					FogMaterial.SetFloat("_HaloAbsorption", _HaloAbsorption.Remap(0f, 1f, 0f, 16f));
				}
				FogMaterial.SetVector("L", -Sun.transform.forward);
				Shader.SetGlobalVector("L", -Sun.transform.forward);
				FogMaterial.SetVector("_LightLocalDirection", LocalDirectionalSunLight(Sun));
				if (EnableInscattering)
				{
					FogMaterial.SetFloat("_InscatteringIntensity", InscatteringIntensity * 50f);
					FogMaterial.SetFloat("InscatteringShape", InscatteringShape);
					FogMaterial.SetFloat("InscatteringTransitionWideness", InscatteringTransitionWideness);
					FogMaterial.SetColor("_InscatteringColor", InscatteringColor);
				}
				if (VolumeFogInscattering)
				{
					FogMaterial.SetFloat("VolumeFogInscatteringIntensity", VolumeFogInscatteringIntensity * 50f);
					FogMaterial.SetFloat("VolumeFogInscatteringAnisotropy", VolumeFogInscatteringAnisotropy);
					FogMaterial.SetColor("VolumeFogInscatteringColor", VolumeFogInscatteringColor);
					VolumeFogInscatteringStartDistance = Mathf.Max(0f, VolumeFogInscatteringStartDistance);
					FogMaterial.SetFloat("VolumeFogInscatteringStartDistance", VolumeFogInscatteringStartDistance);
					VolumeFogInscatteringTransitionWideness = Mathf.Max(0.01f, VolumeFogInscatteringTransitionWideness);
					FogMaterial.SetFloat("VolumeFogInscatteringTransitionWideness", VolumeFogInscatteringTransitionWideness);
				}
				FogMaterial.SetColor("_LightColor", Sun.color * Sun.intensity);
				if (EnableNoise && _NoiseVolume != null)
				{
					FogMaterial.SetFloat("_NoiseDetailRange", _NoiseDetailRange * 1f);
					FogMaterial.SetFloat("_Curl", _Curl);
					if (_DirectionalLighting)
					{
						FogMaterial.SetFloat("_DirectionalLightingDistance", _DirectionalLightingDistance);
						FogMaterial.SetInt("DirectLightingShadowSteps", DirectLightingShadowSteps);
						FogMaterial.SetFloat("DirectLightingShadowDensity", DirectLightingShadowDensity);
					}
				}
			}
			FogMaterial.SetFloat("_Cutoff", ShadowCutoff);
			FogMaterial.SetFloat("Absorption", Absorption);
			LightExtinctionColor.r = Mathf.Max(0.1f, LightExtinctionColor.r);
			LightExtinctionColor.g = Mathf.Max(0.1f, LightExtinctionColor.g);
			LightExtinctionColor.b = Mathf.Max(0.1f, LightExtinctionColor.b);
			FogMaterial.SetColor("LightExtinctionColor", LightExtinctionColor);
			if (Vortex > 0f)
			{
				FogMaterial.SetFloat("_Vortex", Vortex);
				FogMaterial.SetFloat("_Rotation", (float)Math.PI / 180f * rotation);
				FogMaterial.SetFloat("_RotationSpeed", 0f - RotationSpeed);
			}
			DetailDistance = Mathf.Max(1f, DetailDistance);
			FogMaterial.SetFloat("DetailDistance", DetailDistance);
			FogMaterial.SetFloat("Octaves", Octaves);
			FogMaterial.SetFloat("_DetailMaskingThreshold", _DetailMaskingThreshold);
			FogMaterial.SetVector("_VolumePosition", base.gameObject.transform.position);
			FogMaterial.SetFloat("gain", NoiseIntensity);
			FogMaterial.SetFloat("threshold", NoiseContrast * 0.5f - 5f);
			FogMaterial.SetFloat("_3DNoiseScale", _3DNoiseScale * 0.001f);
			FadeDistance = Mathf.Max(1f, FadeDistance);
			FogMaterial.SetFloat("FadeDistance", FadeDistance);
			FogMaterial.SetFloat("STEP_COUNT", Iterations);
			FogMaterial.SetFloat("DetailTiling", DetailTiling);
			FogMaterial.SetFloat("BaseTiling", BaseTiling * 0.1f);
			FogMaterial.SetFloat("Coverage", Coverage);
			FogMaterial.SetFloat("NoiseDensity", NoiseDensity);
			FogMaterial.SetVector("Speed", Speed * 0.1f);
			FogMaterial.SetVector("Stretch", new Vector4(1f, 1f, 1f, 1f) + Stretch * 0.01f);
			if (useHeightGradient)
			{
				FogMaterial.SetVector("_VerticalGradientParams", new Vector4(GradMin, GradMax, GradMin2, GradMax2));
			}
			FogMaterial.SetColor("_AmbientColor", _AmbientColor);
			if (FogRenderer.lightProbeUsage == LightProbeUsage.UseProxyVolume)
			{
				_ProxyVolume = true;
			}
			else
			{
				_ProxyVolume = false;
			}
			FogMaterial.SetFloat("_ProxyVolume", _ProxyVolume ? 1 : 0);
			FogMaterial.SetFloat("ShadowBrightness", ShadowBrightness);
			FogMaterial.SetFloat("_DetailRelativeSpeed", _DetailRelativeSpeed);
			FogMaterial.SetFloat("_BaseRelativeSpeed", _BaseRelativeSpeed);
			if (bSphericalFade)
			{
				SphericalFadeDistance = Mathf.Max(1f, SphericalFadeDistance);
				FogMaterial.SetFloat("SphericalFadeDistance", SphericalFadeDistance);
			}
			FogMaterial.SetVector("VolumeSize", new Vector4(fogVolumeScale.x, fogVolumeScale.y, fogVolumeScale.z, 0f));
			FogMaterial.SetFloat("Exposure", Mathf.Max(0f, Exposure));
			FogMaterial.SetFloat("Offset", Offset);
			FogMaterial.SetFloat("Gamma", Gamma);
			if (Gradient != null)
			{
				FogMaterial.SetTexture("_Gradient", Gradient);
			}
			FogMaterial.SetFloat("InscatteringStartDistance", InscatteringStartDistance);
			Vector3 vector = currentFogVolume;
			FogMaterial.SetVector("_BoxMin", vector * -0.5f);
			FogMaterial.SetVector("_BoxMax", vector * 0.5f);
			FogMaterial.SetColor("_Color", FogMainColor);
			FogMaterial.SetColor("_FogColor", _FogColor);
			FogMaterial.SetInt("_AmbientAffectsFogColor", _AmbientAffectsFogColor ? 1 : 0);
			FogMaterial.SetFloat("_SceneIntersectionSoftness", _SceneIntersectionSoftness);
			FogMaterial.SetFloat("_RayStep", IterationStep * 0.001f);
			FogMaterial.SetFloat("_OptimizationFactor", _OptimizationFactor);
			FogMaterial.SetFloat("_Visibility", ((bVolumeFog && EnableNoise && (bool)_NoiseVolume) || EnableGradient) ? (Visibility * 100f) : Visibility);
			FogRenderer.sortingOrder = DrawOrder;
			FogMaterial.SetInt("VolumeFogInscatterColorAffectedWithFogColor", VolumeFogInscatterColorAffectedWithFogColor ? 1 : 0);
			FogMaterial.SetFloat("_FOV", GameCamera.fieldOfView);
			FogMaterial.SetFloat("HeightAbsorption", HeightAbsorption);
			FogMaterial.SetVector("_AmbientHeightAbsorption", new Vector4(HeightAbsorptionMin, HeightAbsorptionMax, HeightAbsorption, 0f));
			FogMaterial.SetFloat("NormalDistance", NormalDistance);
			FogMaterial.SetFloat("DirectLightingAmount", DirectLightingAmount);
			DirectLightingDistance = Mathf.Max(1f, DirectLightingDistance);
			FogMaterial.SetFloat("DirectLightingDistance", DirectLightingDistance);
			FogMaterial.SetFloat("LambertianBias", LambertianBias);
			FogMaterial.SetFloat("_jitter", _jitter);
			FogMaterial.SetInt("SamplingMethod", (int)_SamplingMethod);
			FogMaterial.SetFloat("_PushAlpha", _PushAlpha);
			if (_ShadeNoise && EnableNoise)
			{
				FogMaterial.SetColor("_SelfShadowColor", _SelfShadowColor);
				FogMaterial.SetInt("_SelfShadowSteps", _SelfShadowSteps);
				FogMaterial.SetFloat("ShadowShift", ShadowShift);
			}
		}

		private void LateUpdate()
		{
		}

		private void OnWillRenderObject()
		{
			GetShadowMap();
			SurrogateMaterial.DisableKeyword("_EDITOR_WINDOW");
			if (PointLightsActive && SystemInfo.graphicsShaderLevel > 30)
			{
				_InitializeLightManagerIfNeccessary();
				if (m_lightManager != null)
				{
					if (PointLightsRealTimeUpdate)
					{
						m_lightManager.Deinitialize();
						if (PointLightBoxCheck)
						{
							m_lightManager.FindLightsInFogVolume();
						}
						else
						{
							m_lightManager.FindLightsInScene();
						}
					}
					if (!m_lightManager.AlreadyUsesTransformForPoI)
					{
						m_lightManager.SetPointOfInterest(_FogVolumeData.GameCamera.transform);
					}
					m_lightManager.ManualUpdate(ref FrustumPlanes);
				}
				FogMaterial.SetInt("_LightsCount", GetVisibleLightCount());
			}
			else
			{
				_DeinitializeLightManagerIfNeccessary();
			}
			if (EnableDistanceFields)
			{
				_InitializePrimitiveManagerIfNeccessary();
				if (m_primitiveManager != null)
				{
					if (PrimitivesRealTimeUpdate)
					{
						m_primitiveManager.Deinitialize();
						m_primitiveManager.FindPrimitivesInFogVolume();
					}
					if (!m_primitiveManager.AlreadyUsesTransformForPoI)
					{
						m_primitiveManager.SetPointOfInterest(_FogVolumeData.GameCamera.transform);
					}
					m_primitiveManager.ManualUpdate(ref FrustumPlanes);
				}
				FogMaterial.SetInt("_PrimitivesCount", GetVisiblePrimitiveCount());
			}
			else
			{
				_DeinitializePrimitiveManagerIfNeccessary();
			}
			if (RT_Opacity != null)
			{
				Shader.SetGlobalTexture("RT_Opacity", RT_Opacity);
				if (UseConvolvedLightshafts)
				{
					FogMaterial.SetTexture("LightshaftTex", RT_OpacityBlur);
				}
				else
				{
					FogMaterial.SetTexture("LightshaftTex", RT_Opacity);
				}
			}
			UpdateParams();
			if (!RenderableInSceneView && Camera.current.name == "SceneCamera")
			{
				FogMaterial.SetVector("_BoxMin", new Vector3(0f, 0f, 0f));
				FogMaterial.SetVector("_BoxMax", new Vector3(0f, 0f, 0f));
			}
			else
			{
				FogMaterial.SetVector("_BoxMin", currentFogVolume * -0.5f);
				FogMaterial.SetVector("_BoxMax", currentFogVolume * 0.5f);
			}
		}

		private void ToggleKeyword()
		{
			if (!IsVisible)
			{
				return;
			}
			if (_jitter > 0f)
			{
				FogMaterial.EnableKeyword("JITTER");
			}
			else
			{
				FogMaterial.DisableKeyword("JITTER");
			}
			if (_DebugMode != 0)
			{
				FogMaterial.EnableKeyword("DEBUG");
			}
			else
			{
				FogMaterial.DisableKeyword("DEBUG");
			}
			switch (_SamplingMethod)
			{
			case SamplingMethod.Eye2Box:
				FogMaterial.DisableKeyword("SAMPLING_METHOD_ViewAligned");
				FogMaterial.EnableKeyword("SAMPLING_METHOD_Eye2Box");
				break;
			case SamplingMethod.ViewAligned:
				FogMaterial.EnableKeyword("SAMPLING_METHOD_ViewAligned");
				FogMaterial.DisableKeyword("SAMPLING_METHOD_Eye2Box");
				break;
			}
			if (LightHalo && (bool)_LightHaloTexture)
			{
				FogMaterial.EnableKeyword("HALO");
			}
			else
			{
				FogMaterial.DisableKeyword("HALO");
			}
			if (ShadowCaster != null)
			{
				if (ShadowCaster.SunAttached)
				{
					FogMaterial.EnableKeyword("LIGHT_ATTACHED");
				}
				if (!ShadowCaster.SunAttached)
				{
					FogMaterial.DisableKeyword("LIGHT_ATTACHED");
				}
			}
			if (Vortex > 0f)
			{
				FogMaterial.EnableKeyword("Twirl");
				switch (_VortexAxis)
				{
				case VortexAxis.X:
					FogMaterial.EnableKeyword("Twirl_X");
					FogMaterial.DisableKeyword("Twirl_Y");
					FogMaterial.DisableKeyword("Twirl_Z");
					break;
				case VortexAxis.Y:
					FogMaterial.DisableKeyword("Twirl_X");
					FogMaterial.EnableKeyword("Twirl_Y");
					FogMaterial.DisableKeyword("Twirl_Z");
					break;
				case VortexAxis.Z:
					FogMaterial.DisableKeyword("Twirl_X");
					FogMaterial.DisableKeyword("Twirl_Y");
					FogMaterial.EnableKeyword("Twirl_Z");
					break;
				}
			}
			else
			{
				FogMaterial.DisableKeyword("Twirl_X");
				FogMaterial.DisableKeyword("Twirl_Y");
				FogMaterial.DisableKeyword("Twirl_Z");
			}
			if (Lambert && (bool)Sun && EnableNoise)
			{
				FogMaterial.EnableKeyword("_LAMBERT_SHADING");
			}
			else
			{
				FogMaterial.DisableKeyword("_LAMBERT_SHADING");
			}
			if (PointLightsActive && SystemInfo.graphicsShaderLevel > 30)
			{
				switch (_LightScatterMethod)
				{
				case LightScatterMethod.BeersLaw:
					FogMaterial.EnableKeyword("ATTEN_METHOD_1");
					FogMaterial.DisableKeyword("ATTEN_METHOD_2");
					FogMaterial.DisableKeyword("ATTEN_METHOD_3");
					break;
				case LightScatterMethod.InverseSquare:
					FogMaterial.DisableKeyword("ATTEN_METHOD_1");
					FogMaterial.EnableKeyword("ATTEN_METHOD_2");
					FogMaterial.DisableKeyword("ATTEN_METHOD_3");
					break;
				case LightScatterMethod.Linear:
					FogMaterial.DisableKeyword("ATTEN_METHOD_1");
					FogMaterial.DisableKeyword("ATTEN_METHOD_2");
					FogMaterial.EnableKeyword("ATTEN_METHOD_3");
					break;
				}
			}
			else
			{
				FogMaterial.DisableKeyword("ATTEN_METHOD_1");
				FogMaterial.DisableKeyword("ATTEN_METHOD_2");
				FogMaterial.DisableKeyword("ATTEN_METHOD_3");
			}
			if (EnableNoise && (bool)_NoiseVolume && useHeightGradient)
			{
				FogMaterial.EnableKeyword("HEIGHT_GRAD");
			}
			else
			{
				FogMaterial.DisableKeyword("HEIGHT_GRAD");
			}
			if (ColorAdjust)
			{
				FogMaterial.EnableKeyword("ColorAdjust");
			}
			else
			{
				FogMaterial.DisableKeyword("ColorAdjust");
			}
			if (bVolumeFog)
			{
				FogMaterial.EnableKeyword("VOLUME_FOG");
			}
			else
			{
				FogMaterial.DisableKeyword("VOLUME_FOG");
			}
			if ((bool)FogMaterial)
			{
				if (EnableGradient && Gradient != null)
				{
					FogMaterial.EnableKeyword("_FOG_GRADIENT");
				}
				else
				{
					FogMaterial.DisableKeyword("_FOG_GRADIENT");
				}
				if (EnableNoise)
				{
					FogMaterial.EnableKeyword("_FOG_VOLUME_NOISE");
				}
				else
				{
					FogMaterial.DisableKeyword("_FOG_VOLUME_NOISE");
				}
				if (EnableInscattering && (bool)Sun && Sun.enabled && Sun.isActiveAndEnabled)
				{
					FogMaterial.EnableKeyword("_INSCATTERING");
				}
				else
				{
					FogMaterial.DisableKeyword("_INSCATTERING");
				}
				if (VolumeFogInscattering && (bool)Sun && Sun.enabled && bVolumeFog)
				{
					FogMaterial.EnableKeyword("_VOLUME_FOG_INSCATTERING");
				}
				else
				{
					FogMaterial.DisableKeyword("_VOLUME_FOG_INSCATTERING");
				}
				FogMaterial.SetFloat("Collisions", SceneCollision ? 1 : 0);
				if (ShadowShift > 0f && EnableNoise && (bool)Sun && _ShadeNoise)
				{
					FogMaterial.EnableKeyword("_SHADE");
				}
				else
				{
					FogMaterial.DisableKeyword("_SHADE");
				}
				if (Tonemap)
				{
					FogMaterial.EnableKeyword("_TONEMAP");
				}
				else
				{
					FogMaterial.DisableKeyword("_TONEMAP");
				}
				if (bSphericalFade)
				{
					FogMaterial.EnableKeyword("SPHERICAL_FADE");
				}
				else
				{
					FogMaterial.DisableKeyword("SPHERICAL_FADE");
				}
				if (EnableDistanceFields)
				{
					FogMaterial.EnableKeyword("DF");
				}
				else
				{
					FogMaterial.DisableKeyword("DF");
				}
				if (bAbsorption)
				{
					FogMaterial.EnableKeyword("ABSORPTION");
				}
				else
				{
					FogMaterial.DisableKeyword("ABSORPTION");
				}
				if (_DirectionalLighting && EnableNoise && _NoiseVolume != null && _DirectionalLightingDistance > 0f && DirectLightingShadowDensity > 0f)
				{
					FogMaterial.EnableKeyword("DIRECTIONAL_LIGHTING");
				}
				else
				{
					FogMaterial.DisableKeyword("DIRECTIONAL_LIGHTING");
				}
			}
		}

		public void UpdateBoxMesh()
		{
			if (currentFogVolume != fogVolumeScale || filter == null)
			{
				CreateBoxMesh(fogVolumeScale);
				ShadowMapSetup();
				_BoxCollider.size = fogVolumeScale;
				m_hasUpdatedBoxMesh = true;
			}
			base.transform.localScale = Vector3.one;
		}

		private void CreateBoxMesh(Vector3 scale)
		{
			currentFogVolume = scale;
			if (filter == null)
			{
				filter = base.gameObject.AddComponent<MeshFilter>();
			}
			if (mesh == null)
			{
				mesh = new Mesh();
				mesh.name = base.gameObject.name;
				filter.sharedMesh = mesh;
			}
			mesh.Clear();
			float y = scale.y;
			float z = scale.z;
			float x = scale.x;
			Vector3 vector = new Vector3((0f - x) * 0.5f, (0f - y) * 0.5f, z * 0.5f);
			Vector3 vector2 = new Vector3(x * 0.5f, (0f - y) * 0.5f, z * 0.5f);
			Vector3 vector3 = new Vector3(x * 0.5f, (0f - y) * 0.5f, (0f - z) * 0.5f);
			Vector3 vector4 = new Vector3((0f - x) * 0.5f, (0f - y) * 0.5f, (0f - z) * 0.5f);
			Vector3 vector5 = new Vector3((0f - x) * 0.5f, y * 0.5f, z * 0.5f);
			Vector3 vector6 = new Vector3(x * 0.5f, y * 0.5f, z * 0.5f);
			Vector3 vector7 = new Vector3(x * 0.5f, y * 0.5f, (0f - z) * 0.5f);
			Vector3 vector8 = new Vector3((0f - x) * 0.5f, y * 0.5f, (0f - z) * 0.5f);
			Vector3[] vertices = new Vector3[24]
			{
				vector, vector2, vector3, vector4, vector8, vector5, vector, vector4, vector5, vector6,
				vector2, vector, vector7, vector8, vector4, vector3, vector6, vector7, vector3, vector2,
				vector8, vector7, vector6, vector5
			};
			Vector3 up = Vector3.up;
			Vector3 down = Vector3.down;
			Vector3 forward = Vector3.forward;
			Vector3 back = Vector3.back;
			Vector3 left = Vector3.left;
			Vector3 right = Vector3.right;
			Vector3[] normals = new Vector3[24]
			{
				down, down, down, down, left, left, left, left, forward, forward,
				forward, forward, back, back, back, back, right, right, right, right,
				up, up, up, up
			};
			Vector2 vector9 = new Vector2(0f, 0f);
			Vector2 vector10 = new Vector2(1f, 0f);
			Vector2 vector11 = new Vector2(0f, 1f);
			Vector2 vector12 = new Vector2(1f, 1f);
			Vector2[] uv = new Vector2[24]
			{
				vector12, vector11, vector9, vector10, vector12, vector11, vector9, vector10, vector12, vector11,
				vector9, vector10, vector12, vector11, vector9, vector10, vector12, vector11, vector9, vector10,
				vector12, vector11, vector9, vector10
			};
			int[] triangles = new int[36]
			{
				3, 1, 0, 3, 2, 1, 7, 5, 4, 7,
				6, 5, 11, 9, 8, 11, 10, 9, 15, 13,
				12, 15, 14, 13, 19, 17, 16, 19, 18, 17,
				23, 21, 20, 23, 22, 21
			};
			mesh.vertices = vertices;
			mesh.triangles = triangles;
			mesh.normals = normals;
			mesh.uv = uv;
			mesh.RecalculateBounds();
		}

		private void _InitializeLightManagerIfNeccessary()
		{
			if (m_lightManager == null)
			{
				m_lightManager = GetComponent<FogVolumeLightManager>();
				if (m_lightManager == null)
				{
					m_lightManager = base.gameObject.AddComponent<FogVolumeLightManager>();
				}
				m_lightManager.Initialize();
				if (PointLightBoxCheck)
				{
					m_lightManager.FindLightsInFogVolume();
				}
				else
				{
					m_lightManager.FindLightsInScene();
				}
			}
		}

		private void _DeinitializeLightManagerIfNeccessary()
		{
			if (m_lightManager != null)
			{
				m_lightManager.Deinitialize();
			}
		}

		public int GetVisibleLightCount()
		{
			if (m_lightManager != null)
			{
				return m_lightManager.VisibleLightCount;
			}
			return 0;
		}

		public int GetTotalLightCount()
		{
			if (m_lightManager != null)
			{
				return m_lightManager.CurrentLightCount;
			}
			return 0;
		}

		private void _InitializePrimitiveManagerIfNeccessary()
		{
			if (m_primitiveManager == null)
			{
				m_primitiveManager = GetComponent<FogVolumePrimitiveManager>();
				if (m_primitiveManager == null)
				{
					m_primitiveManager = base.gameObject.AddComponent<FogVolumePrimitiveManager>();
				}
				m_primitiveManager.Initialize();
				m_primitiveManager.FindPrimitivesInFogVolume();
			}
		}

		private void _DeinitializePrimitiveManagerIfNeccessary()
		{
			if (m_primitiveManager != null)
			{
				m_primitiveManager.Deinitialize();
			}
		}

		public int GetVisiblePrimitiveCount()
		{
			if (m_primitiveManager != null)
			{
				return m_primitiveManager.VisiblePrimitiveCount;
			}
			return 0;
		}

		public int GetTotalPrimitiveCount()
		{
			if (m_primitiveManager != null)
			{
				return m_primitiveManager.CurrentPrimitiveCount;
			}
			return 0;
		}
	}
	[ExecuteInEditMode]
	public class FogVolumeData : MonoBehaviour
	{
		[SerializeField]
		private bool _ForceNoRenderer;

		[SerializeField]
		private Camera _GameCamera;

		[SerializeField]
		private List<Camera> FoundCameras;

		[SerializeField]
		private FogVolume[] SceneFogVolumes;

		public bool ForceNoRenderer
		{
			get
			{
				return _ForceNoRenderer;
			}
			set
			{
				if (_ForceNoRenderer != value)
				{
					_ForceNoRenderer = value;
					ToggleFogVolumeRenderers();
				}
			}
		}

		public Camera GameCamera
		{
			get
			{
				return _GameCamera;
			}
			set
			{
				if (_GameCamera != value)
				{
					_GameCamera = value;
					RefreshCamera();
				}
			}
		}

		public Camera GetFogVolumeCamera => GameCamera;

		public void setDownsample(int val)
		{
			if ((bool)_GameCamera.GetComponent<FogVolumeRenderer>())
			{
				_GameCamera.GetComponent<FogVolumeRenderer>()._Downsample = val;
			}
		}

		private void RefreshCamera()
		{
			FindFogVolumes();
			FogVolume[] sceneFogVolumes = SceneFogVolumes;
			for (int i = 0; i < sceneFogVolumes.Length; i++)
			{
				sceneFogVolumes[i].AssignCamera();
			}
			ToggleFogVolumeRenderers();
		}

		private void OnEnable()
		{
			Initialize();
		}

		private void Initialize()
		{
			if (FoundCameras == null)
			{
				FoundCameras = new List<Camera>();
			}
			FindCamera();
			RefreshCamera();
			if (FoundCameras.Count == 0)
			{
				UnityEngine.Debug.Log("Definetly, no camera available for Fog Volume");
			}
		}

		public void FindFogVolumes()
		{
			SceneFogVolumes = (FogVolume[])UnityEngine.Object.FindObjectsOfType(typeof(FogVolume));
		}

		private void Update()
		{
			if (GameCamera == null)
			{
				UnityEngine.Debug.Log("No Camera available for Fog Volume. Trying to find another one");
				Initialize();
			}
		}

		private void ToggleFogVolumeRenderers()
		{
			if (FoundCameras == null)
			{
				return;
			}
			for (int i = 0; i < FoundCameras.Count; i++)
			{
				if (FoundCameras[i] != _GameCamera)
				{
					if ((bool)FoundCameras[i].GetComponent<FogVolumeRenderer>())
					{
						FoundCameras[i].GetComponent<FogVolumeRenderer>().enabled = false;
					}
					continue;
				}
				if ((bool)FoundCameras[i].GetComponent<FogVolumeRenderer>() && !_ForceNoRenderer)
				{
					FoundCameras[i].GetComponent<FogVolumeRenderer>().enabled = true;
					continue;
				}
				FogVolumeRenderer fogVolumeRenderer = FoundCameras[i].GetComponent<FogVolumeRenderer>();
				if (fogVolumeRenderer == null)
				{
					if (ForceNoRenderer)
					{
						continue;
					}
					fogVolumeRenderer = FoundCameras[i].gameObject.AddComponent<FogVolumeRenderer>();
				}
				if (ForceNoRenderer)
				{
					fogVolumeRenderer.enabled = false;
				}
			}
		}

		public void FindCamera()
		{
			if (FoundCameras != null && FoundCameras.Count > 0)
			{
				FoundCameras.Clear();
			}
			Camera[] array = (Camera[])UnityEngine.Object.FindObjectsOfType(typeof(Camera));
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].name.Contains("FogVolumeCamera") && !array[i].name.Contains("Shadow Camera") && array[i].gameObject.hideFlags == HideFlags.None)
				{
					FoundCameras.Add(array[i]);
				}
			}
			if (GameCamera == null)
			{
				GameCamera = Camera.main;
			}
			if (GameCamera == null)
			{
				foreach (Camera foundCamera in FoundCameras)
				{
					if (foundCamera.isActiveAndEnabled && foundCamera.gameObject.activeInHierarchy && foundCamera.gameObject.hideFlags == HideFlags.None)
					{
						GameCamera = foundCamera;
						break;
					}
				}
			}
			_ = GameCamera != null;
		}

		private void OnDisable()
		{
			FoundCameras.Clear();
			SceneFogVolumes = null;
		}
	}
	[ExecuteInEditMode]
	public class FogVolumeDirectionalLight : MonoBehaviour
	{
		public enum Resolution
		{
			_256 = 0x100,
			_512 = 0x200,
			_1024 = 0x400,
			_2048 = 0x800,
			_4096 = 0x1000
		}

		public enum Antialiasing
		{
			_1 = 1,
			_2 = 2,
			_4 = 4,
			_8 = 8
		}

		public enum ScaleMode
		{
			VolumeMaxAxis,
			Manual
		}

		public enum UpdateMode
		{
			OnStart,
			Interleaved
		}

		public enum FocusMode
		{
			VolumeCenter,
			GameCameraPosition,
			GameObject
		}

		public FogVolume[] _TargetFogVolumes;

		public Vector2 MiniaturePosition = new Vector2(110f, 320f);

		public FogVolume _ProminentFogVolume;

		public Material FogVolumeMaterial;

		public float _CameraVerticalPosition = 500f;

		private RenderTexture depthRT;

		public Antialiasing _Antialiasing = Antialiasing._1;

		public Resolution Size = Resolution._512;

		public Camera ShadowCamera;

		public float _FogVolumeShadowMapEdgeSoftness = 0.001f;

		public ScaleMode _ScaleMode;

		public LayerMask LayersToRender;

		[HideInInspector]
		public Shader outputDepth;

		[HideInInspector]
		public GameObject GOShadowCamera;

		public bool CameraVisible;

		private Image _CanvasImage;

		public UpdateMode _UpdateMode = UpdateMode.Interleaved;

		public float Scale = 50f;

		[Range(0f, 100f)]
		public int SkipFrames = 2;

		public bool ShowMiniature;

		private GameObject _GO_Canvas;

		private GameObject _GO_Image;

		private Canvas _Canvas;

		public Material DebugViewMaterial;

		private GameObject Quad;

		private Vector3 FocusPosition;

		private FogVolumeData _FogVolumeData;

		private Camera _GameCamera;

		public Transform _GameObjectFocus;

		public FocusMode _FocusMode;

		private Material quadMaterial;

		public Shader quadShader;

		private RenderTextureFormat rt_DepthFormat;

		public Material QuadMaterial
		{
			get
			{
				if (quadMaterial == null)
				{
					CreateMaterial();
				}
				return quadMaterial;
			}
		}

		private void OnEnable()
		{
			_GO_Canvas = GameObject.Find("FogVolume Debug Canvas");
			if (!_GO_Canvas)
			{
				_GO_Canvas = new GameObject("FogVolume Debug Canvas");
			}
			_GO_Image = GameObject.Find("FogVolume Image");
			if (!_GO_Image)
			{
				_GO_Image = new GameObject("FogVolume Image");
				_CanvasImage = _GO_Image.AddComponent<Image>();
				_CanvasImage.material = DebugViewMaterial;
				_CanvasImage.rectTransform.position = new Vector3(MiniaturePosition.x, MiniaturePosition.y, 0f);
				_CanvasImage.rectTransform.pivot = new Vector2(0.5f, 0.5f);
				_CanvasImage.rectTransform.anchorMax = new Vector2(0f, 0f);
				_CanvasImage.rectTransform.anchorMin = new Vector2(0f, 0f);
				_CanvasImage.rectTransform.localScale = new Vector3(2f, 2f, 2f);
			}
			if (!_CanvasImage)
			{
				_CanvasImage = _GO_Image.GetComponent<Image>();
			}
			_CanvasImage.material = DebugViewMaterial;
			_GO_Image.transform.SetParent(_GO_Canvas.transform);
			_GO_Canvas.AddComponent<CanvasScaler>();
			_GO_Canvas.GetComponent<CanvasScaler>().scaleFactor = 1f;
			_GO_Canvas.GetComponent<CanvasScaler>().referencePixelsPerUnit = 100f;
			_Canvas = _GO_Canvas.GetComponent<Canvas>();
			_GO_Canvas.hideFlags = HideFlags.HideInHierarchy;
			_GO_Canvas.layer = LayerMask.NameToLayer("UI");
			_GO_Image.layer = LayerMask.NameToLayer("UI");
			_Canvas.renderMode = RenderMode.ScreenSpaceOverlay;
			Initialize();
			if (_UpdateMode == UpdateMode.OnStart)
			{
				Render();
			}
		}

		private void CreateMaterial()
		{
			UnityEngine.Object.DestroyImmediate(quadMaterial);
			quadShader = Shader.Find("Hidden/DepthMapQuad");
			quadMaterial = new Material(quadShader);
			quadMaterial.name = "Depth camera quad material";
			quadMaterial.hideFlags = HideFlags.HideAndDontSave;
		}

		private void Initialize()
		{
			CreateMaterial();
			if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGFloat))
			{
				rt_DepthFormat = RenderTextureFormat.RGFloat;
			}
			else
			{
				rt_DepthFormat = RenderTextureFormat.DefaultHDR;
			}
			GameObject gameObject = GameObject.Find("Fog Volume Data");
			if ((bool)gameObject)
			{
				_FogVolumeData = gameObject.GetComponent<FogVolumeData>();
				_GameCamera = _FogVolumeData.GameCamera;
				GOShadowCamera = GameObject.Find("FogVolumeShadowCamera");
				if (!GOShadowCamera)
				{
					GOShadowCamera = new GameObject();
					GOShadowCamera.name = "FogVolumeShadowCamera";
				}
				if (!GOShadowCamera)
				{
					MonoBehaviour.print("Shadow camera is lost");
				}
				else
				{
					ShadowCamera = GOShadowCamera.GetComponent<Camera>();
				}
				if (!depthRT)
				{
					depthRT = new RenderTexture((int)Size, (int)Size, 16, rt_DepthFormat);
					depthRT.antiAliasing = (int)_Antialiasing;
					depthRT.filterMode = FilterMode.Bilinear;
					depthRT.name = "FogVolumeShadowMap";
					depthRT.wrapMode = TextureWrapMode.Clamp;
				}
				if (!ShadowCamera)
				{
					ShadowCamera = GOShadowCamera.AddComponent<Camera>();
				}
				else
				{
					ShadowCamera = GOShadowCamera.GetComponent<Camera>();
				}
				ShadowCamera.clearFlags = CameraClearFlags.Color;
				ShadowCamera.backgroundColor = Color.black;
				ShadowCamera.orthographic = true;
				ShadowCamera.farClipPlane = 10000f;
				ShadowCamera.enabled = false;
				ShadowCamera.stereoTargetEye = StereoTargetEyeMask.None;
				ShadowCamera.targetTexture = depthRT;
				ShadowCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolume"));
				ShadowCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeUniform"));
				ShadowCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeSurrogate"));
				ShadowCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeShadowCaster"));
				ShadowCamera.transform.parent = base.gameObject.transform;
				Quad = GameObject.Find("Depth map background");
				if (!Quad)
				{
					Quad = GameObject.CreatePrimitive(PrimitiveType.Quad);
				}
				Quad.name = "Depth map background";
				Quad.GetComponent<MeshRenderer>().sharedMaterial = QuadMaterial;
				Quad.transform.parent = ShadowCamera.transform;
				UnityEngine.Object.DestroyImmediate(Quad.GetComponent<MeshCollider>());
				Quad.hideFlags = HideFlags.HideInHierarchy;
			}
		}

		private void EnableVolumetricShadow(bool b)
		{
			if (_TargetFogVolumes == null || _TargetFogVolumes.Length == 0)
			{
				return;
			}
			float num = 0f;
			int num2 = 0;
			for (int i = 0; i < _TargetFogVolumes.Length; i++)
			{
				FogVolume fogVolume = _TargetFogVolumes[i];
				if (fogVolume != null && fogVolume._FogType == FogVolume.FogType.Textured)
				{
					if (fogVolume.enabled)
					{
						FogVolumeMaterial = fogVolume.FogMaterial;
						FogVolumeMaterial.SetInt("_VolumetricShadowsEnabled", b ? 1 : 0);
					}
					float num3 = _MaxOf(fogVolume.fogVolumeScale.x, fogVolume.fogVolumeScale.y, fogVolume.fogVolumeScale.z);
					if (num3 > num)
					{
						num = num3;
						num2 = i;
					}
				}
			}
			_ProminentFogVolume = _TargetFogVolumes[num2];
		}

		private void Update()
		{
			if (_CanvasImage.material != null)
			{
				_CanvasImage.material = DebugViewMaterial;
			}
			if (!ShadowCamera)
			{
				Initialize();
			}
			if (_TargetFogVolumes != null && _AtLeastOneFogVolumeInArray())
			{
				EnableVolumetricShadow(depthRT);
				LayersToRender = (int)LayersToRender & ~(1 << LayerMask.NameToLayer("FogVolume"));
				LayersToRender = (int)LayersToRender & ~(1 << LayerMask.NameToLayer("FogVolumeUniform"));
				LayersToRender = (int)LayersToRender & ~(1 << LayerMask.NameToLayer("FogVolumeSurrogate"));
				LayersToRender = (int)LayersToRender & ~(1 << LayerMask.NameToLayer("FogVolumeShadowCaster"));
				ShadowCamera.cullingMask = LayersToRender;
				Refresh();
				if (_ScaleMode == ScaleMode.VolumeMaxAxis)
				{
					if (_ProminentFogVolume != null)
					{
						ShadowCamera.orthographicSize = _MaxOf(_ProminentFogVolume.fogVolumeScale.x, _ProminentFogVolume.fogVolumeScale.y, _ProminentFogVolume.fogVolumeScale.z) * 0.5f;
					}
				}
				else
				{
					ShadowCamera.orthographicSize = Scale;
				}
				if (ShadowCamera.cullingMask != 0 && _ProminentFogVolume != null && _UpdateMode == UpdateMode.Interleaved && ExtensionMethods.TimeSnap(SkipFrames))
				{
					Render();
				}
			}
			else if ((bool)depthRT)
			{
				UnityEngine.Object.DestroyImmediate(depthRT);
				UnityEngine.Object.DestroyImmediate(GOShadowCamera);
			}
			if (!ShowMiniature && _GO_Canvas.activeInHierarchy)
			{
				_GO_Canvas.SetActive(ShowMiniature);
			}
			if (ShowMiniature && !_GO_Canvas.activeInHierarchy)
			{
				_GO_Canvas.SetActive(ShowMiniature);
			}
		}

		public void Refresh()
		{
			if (_TargetFogVolumes == null)
			{
				_ProminentFogVolume = null;
				return;
			}
			for (int i = 0; i < _TargetFogVolumes.Length; i++)
			{
				FogVolume fogVolume = _TargetFogVolumes[i];
				if (fogVolume != null && fogVolume._FogType == FogVolume.FogType.Textured && fogVolume.HasUpdatedBoxMesh)
				{
					float num = ((_ProminentFogVolume != null) ? _MaxOf(_ProminentFogVolume.fogVolumeScale.x, _ProminentFogVolume.fogVolumeScale.y, _ProminentFogVolume.fogVolumeScale.z) : 0f);
					if (_MaxOf(fogVolume.fogVolumeScale.x, fogVolume.fogVolumeScale.y, fogVolume.fogVolumeScale.z) > num)
					{
						_ProminentFogVolume = fogVolume;
					}
				}
			}
		}

		public void Render()
		{
			if (!depthRT)
			{
				Initialize();
			}
			if (depthRT.height != (int)Size)
			{
				UnityEngine.Object.DestroyImmediate(depthRT);
				Initialize();
			}
			if (_Antialiasing != (Antialiasing)depthRT.antiAliasing)
			{
				UnityEngine.Object.DestroyImmediate(depthRT);
				Initialize();
			}
			if (!ShadowCamera)
			{
				Initialize();
			}
			switch (_FocusMode)
			{
			case FocusMode.GameCameraPosition:
				FocusPosition = _GameCamera.transform.position;
				break;
			case FocusMode.VolumeCenter:
				if (_ProminentFogVolume != null)
				{
					FocusPosition = _ProminentFogVolume.transform.position;
				}
				else
				{
					FocusPosition = Vector3.zero;
				}
				break;
			case FocusMode.GameObject:
				if ((bool)_GameObjectFocus)
				{
					FocusPosition = _GameObjectFocus.transform.position;
				}
				break;
			}
			Vector3 translation = new Vector3(0f, 0f, FocusPosition.y - _CameraVerticalPosition);
			ShadowCamera.transform.position = FocusPosition;
			ShadowCamera.transform.Translate(translation, Space.Self);
			Vector3 localScale = new Vector3(ShadowCamera.orthographicSize * 2f, ShadowCamera.orthographicSize * 2f, ShadowCamera.orthographicSize * 2f);
			Quad.transform.localScale = localScale;
			Quad.transform.position = ShadowCamera.transform.position;
			Vector3 translation2 = new Vector3(0f, 0f, ShadowCamera.farClipPlane - 50f);
			Quad.transform.Translate(translation2, Space.Self);
			ShadowCamera.transform.rotation = Quaternion.LookRotation(base.transform.forward);
			Shader.SetGlobalVector("_ShadowCameraPosition", ShadowCamera.transform.position);
			Shader.SetGlobalMatrix("_ShadowCameraProjection", ShadowCamera.worldToCameraMatrix);
			Shader.SetGlobalFloat("_ShadowCameraSize", ShadowCamera.orthographicSize);
			Shader.SetGlobalVector("_ShadowLightDir", ShadowCamera.transform.forward);
			quadShader.maximumLOD = 1;
			Shader.SetGlobalFloat("_FogVolumeShadowMapEdgeSoftness", 20f / _FogVolumeShadowMapEdgeSoftness);
			ShadowCamera.RenderWithShader(outputDepth, "RenderType");
			quadShader.maximumLOD = 100;
			Shader.SetGlobalTexture("_ShadowTexture", depthRT);
		}

		private void OnDisable()
		{
			UnityEngine.Object.DestroyImmediate(depthRT);
			if ((bool)_GO_Canvas)
			{
				_GO_Canvas.SetActive(value: false);
			}
			EnableVolumetricShadow(b: false);
		}

		private void OnDestroy()
		{
			UnityEngine.Object.DestroyImmediate(GOShadowCamera);
			UnityEngine.Object.DestroyImmediate(_GO_Canvas);
			UnityEngine.Object.DestroyImmediate(Quad);
		}

		private bool _AtLeastOneFogVolumeInArray()
		{
			if (_TargetFogVolumes != null)
			{
				for (int i = 0; i < _TargetFogVolumes.Length; i++)
				{
					if (_TargetFogVolumes[i] != null)
					{
						return true;
					}
				}
			}
			return false;
		}

		public void AddAllFogVolumesToThisLight()
		{
			_ProminentFogVolume = null;
			FogVolume[] array = UnityEngine.Object.FindObjectsOfType<FogVolume>();
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null && array[i]._FogType == FogVolume.FogType.Textured)
				{
					num++;
				}
			}
			_TargetFogVolumes = new FogVolume[num];
			int num2 = 0;
			for (int j = 0; j < array.Length; j++)
			{
				FogVolume fogVolume = array[j];
				if (fogVolume != null && fogVolume._FogType == FogVolume.FogType.Textured)
				{
					_TargetFogVolumes[num2++] = array[j];
				}
			}
		}

		public void RemoveAllFogVolumesFromThisLight()
		{
			_ProminentFogVolume = null;
			_TargetFogVolumes = null;
		}

		private float _MaxOf(float _a, float _b)
		{
			if (!(_a >= _b))
			{
				return _b;
			}
			return _a;
		}

		private float _MaxOf(float _a, float _b, float _c)
		{
			return _MaxOf(_MaxOf(_a, _b), _c);
		}
	}
	[ExecuteInEditMode]
	public class FogVolumeLight : MonoBehaviour
	{
		public bool IsAddedToNormalLight;

		public bool IsPointLight;

		public bool Enabled = true;

		public Color Color = Color.white;

		public float Intensity = 1f;

		public float Range = 10f;

		public float Angle = 30f;

		private void OnEnable()
		{
			SphereCollider component = GetComponent<SphereCollider>();
			if (component != null)
			{
				UnityEngine.Object.Destroy(component);
			}
		}
	}
	public class FogVolumeLightManager : MonoBehaviour
	{
		protected class LightData
		{
			public EFogVolumeLightType LightType { get; set; }

			public Light Light { get; set; }

			public FogVolumeLight FogVolumeLight { get; set; }

			public Transform Transform { get; set; }

			public float SqDistance { get; set; }

			public float Distance2Camera { get; set; }

			public Bounds Bounds { get; set; }

			public LightData()
			{
				LightType = EFogVolumeLightType.None;
				Light = null;
				FogVolumeLight = null;
				Transform = null;
				SqDistance = 0f;
				Distance2Camera = 0f;
				Bounds = default(Bounds);
			}
		}

		private float m_pointLightCullSizeMultiplier = 1f;

		private FogVolume m_fogVolume;

		private FogVolumeData m_fogVolumeData;

		private Camera m_camera;

		private BoxCollider m_boxCollider;

		private Transform m_pointOfInterestTf;

		private Vector3 m_pointOfInterest = Vector3.zero;

		private readonly Vector4[] m_lightPos = new Vector4[64];

		private readonly Vector4[] m_lightRot = new Vector4[64];

		private readonly Color[] m_lightColor = new Color[64];

		private readonly Vector4[] m_lightData = new Vector4[64];

		private List<LightData> m_lights;

		private List<LightData> m_lightsInFrustum;

		private int m_inFrustumCount;

		private Plane[] FrustumPlanes;

		private const int InvalidIndex = -1;

		private const int MaxVisibleLights = 64;

		private const float InvalidSpotLightAngle = -1f;

		private const float NoData = 0f;

		private const float PointLightRangeDivider = 5f;

		private const float SpotLightRangeDivider = 5f;

		private const int MaxLightCount = 1000;

		private const float LightInVolumeBoundsSize = 5f;

		public int CurrentLightCount { get; private set; }

		public int VisibleLightCount { get; private set; }

		public bool DrawDebugData { get; set; }

		public bool AlreadyUsesTransformForPoI => m_pointOfInterestTf != null;

		public void FindLightsInScene()
		{
			CurrentLightCount = 0;
			VisibleLightCount = 0;
			m_lights.Clear();
			m_lightsInFrustum.Clear();
			for (int i = 0; i < 1000; i++)
			{
				m_lights.Add(new LightData());
				m_lightsInFrustum.Add(new LightData());
			}
			FogVolumeLight[] array = UnityEngine.Object.FindObjectsOfType<FogVolumeLight>();
			for (int j = 0; j < array.Length; j++)
			{
				Light component = array[j].GetComponent<Light>();
				if (component != null)
				{
					switch (component.type)
					{
					case LightType.Point:
						AddPointLight(component);
						array[j].IsAddedToNormalLight = true;
						break;
					case LightType.Spot:
						AddSpotLight(component);
						array[j].IsAddedToNormalLight = true;
						break;
					}
				}
				else if (array[j].IsPointLight)
				{
					AddSimulatedPointLight(array[j]);
					array[j].IsAddedToNormalLight = false;
				}
				else
				{
					AddSimulatedSpotLight(array[j]);
					array[j].IsAddedToNormalLight = false;
				}
			}
		}

		public void FindLightsInFogVolume()
		{
			CurrentLightCount = 0;
			VisibleLightCount = 0;
			m_lights.Clear();
			m_lightsInFrustum.Clear();
			for (int i = 0; i < 1000; i++)
			{
				m_lights.Add(new LightData());
				m_lightsInFrustum.Add(new LightData());
			}
			if (m_boxCollider == null)
			{
				m_boxCollider = base.gameObject.GetComponent<BoxCollider>();
			}
			Bounds bounds = m_boxCollider.bounds;
			FogVolumeLight[] array = UnityEngine.Object.FindObjectsOfType<FogVolumeLight>();
			for (int j = 0; j < array.Length; j++)
			{
				if (!bounds.Intersects(new Bounds(array[j].gameObject.transform.position, Vector3.one * 5f)))
				{
					continue;
				}
				Light component = array[j].GetComponent<Light>();
				if (component != null)
				{
					switch (component.type)
					{
					case LightType.Point:
						AddPointLight(component);
						array[j].IsAddedToNormalLight = true;
						break;
					case LightType.Spot:
						AddSpotLight(component);
						array[j].IsAddedToNormalLight = true;
						break;
					}
				}
				else if (array[j].IsPointLight)
				{
					AddSimulatedPointLight(array[j]);
					array[j].IsAddedToNormalLight = false;
				}
				else
				{
					AddSimulatedSpotLight(array[j]);
					array[j].IsAddedToNormalLight = false;
				}
			}
		}

		public bool AddSimulatedPointLight(FogVolumeLight _light)
		{
			int num = _FindFirstFreeLight();
			if (num != -1)
			{
				LightData lightData = m_lights[num];
				CurrentLightCount++;
				lightData.LightType = EFogVolumeLightType.FogVolumePointLight;
				lightData.Transform = _light.transform;
				lightData.Light = null;
				lightData.FogVolumeLight = _light;
				lightData.Bounds = new Bounds(lightData.Transform.position, Vector3.one * lightData.FogVolumeLight.Range * 2.5f);
				return true;
			}
			return false;
		}

		public bool AddSimulatedSpotLight(FogVolumeLight _light)
		{
			int num = _FindFirstFreeLight();
			if (num != -1)
			{
				LightData lightData = m_lights[num];
				CurrentLightCount++;
				lightData.LightType = EFogVolumeLightType.FogVolumeSpotLight;
				lightData.Transform = _light.transform;
				lightData.Light = null;
				lightData.FogVolumeLight = _light;
				Vector3 center = lightData.Transform.position + lightData.Transform.forward * lightData.FogVolumeLight.Range * 0.5f;
				lightData.Bounds = new Bounds(center, Vector3.one * lightData.FogVolumeLight.Range * (0.75f + lightData.FogVolumeLight.Angle * 0.03f));
				return true;
			}
			return false;
		}

		public bool AddPointLight(Light _light)
		{
			int num = _FindFirstFreeLight();
			if (num != -1)
			{
				LightData lightData = m_lights[num];
				CurrentLightCount++;
				lightData.LightType = EFogVolumeLightType.PointLight;
				lightData.Transform = _light.transform;
				lightData.Light = _light;
				lightData.FogVolumeLight = null;
				lightData.Bounds = new Bounds(lightData.Transform.position, Vector3.one * lightData.Light.range * 2.5f);
				return true;
			}
			return false;
		}

		public bool AddSpotLight(Light _light)
		{
			int num = _FindFirstFreeLight();
			if (num != -1)
			{
				LightData lightData = m_lights[num];
				CurrentLightCount++;
				lightData.LightType = EFogVolumeLightType.SpotLight;
				lightData.Transform = _light.transform;
				lightData.Light = _light;
				lightData.FogVolumeLight = null;
				Vector3 center = lightData.Transform.position + lightData.Transform.forward * lightData.Light.range * 0.5f;
				lightData.Bounds = new Bounds(center, Vector3.one * lightData.Light.range * (0.75f + lightData.Light.spotAngle * 0.03f));
				return true;
			}
			return false;
		}

		public bool RemoveLight(Transform _lightToRemove)
		{
			int count = m_lights.Count;
			for (int i = 0; i < count; i++)
			{
				if ((object)m_lights[i].Transform == _lightToRemove)
				{
					m_lights[i].LightType = EFogVolumeLightType.None;
					CurrentLightCount--;
					return true;
				}
			}
			return false;
		}

		public void ManualUpdate(ref Plane[] _frustumPlanes)
		{
			FrustumPlanes = _frustumPlanes;
			m_camera = ((m_fogVolumeData != null) ? m_fogVolumeData.GameCamera : null);
			if (!(m_camera == null))
			{
				if (m_boxCollider == null)
				{
					m_boxCollider = m_fogVolume.GetComponent<BoxCollider>();
				}
				if (m_pointOfInterestTf != null)
				{
					m_pointOfInterest = m_pointOfInterestTf.position;
				}
				_UpdateBounds();
				_FindLightsInFrustum();
				if (m_lightsInFrustum.Count > 64)
				{
					_SortLightsInFrustum();
				}
				_PrepareShaderArrays();
			}
		}

		public void OnDrawGizmos()
		{
			base.hideFlags = HideFlags.HideInInspector;
			if (!(m_camera == null) && DrawDebugData)
			{
				Color color = Gizmos.color;
				Gizmos.color = Color.green;
				for (int i = 0; i < VisibleLightCount; i++)
				{
					Gizmos.DrawWireCube(m_lightsInFrustum[i].Bounds.center, m_lightsInFrustum[i].Bounds.size);
				}
				Gizmos.color = Color.magenta;
				Matrix4x4 matrix = Gizmos.matrix;
				Gizmos.matrix = Matrix4x4.TRS(m_camera.transform.position, m_camera.transform.rotation, Vector3.one);
				Gizmos.DrawFrustum(m_camera.transform.position, m_camera.fieldOfView, m_camera.nearClipPlane, m_fogVolume.PointLightingDistance2Camera, m_camera.aspect);
				Gizmos.color = color;
				Gizmos.matrix = matrix;
			}
		}

		public void SetPointLightCullSizeMultiplier(float _cullSizeMultiplier)
		{
			m_pointLightCullSizeMultiplier = _cullSizeMultiplier;
		}

		public void SetPointOfInterest(Vector3 _pointOfInterest)
		{
			m_pointOfInterestTf = null;
			m_pointOfInterest = _pointOfInterest;
		}

		public void SetPointOfInterest(Transform _pointOfInterest)
		{
			m_pointOfInterestTf = _pointOfInterest;
		}

		public Vector4[] GetLightPositionArray()
		{
			return m_lightPos;
		}

		public Vector4[] GetLightRotationArray()
		{
			return m_lightRot;
		}

		public Color[] GetLightColorArray()
		{
			return m_lightColor;
		}

		public Vector4[] GetLightData()
		{
			return m_lightData;
		}

		public void Initialize()
		{
			m_fogVolume = base.gameObject.GetComponent<FogVolume>();
			m_fogVolumeData = UnityEngine.Object.FindObjectOfType<FogVolumeData>();
			m_camera = null;
			m_boxCollider = null;
			CurrentLightCount = 0;
			DrawDebugData = false;
			if (m_lights == null)
			{
				m_lights = new List<LightData>(1000);
				m_lightsInFrustum = new List<LightData>(1000);
				for (int i = 0; i < 1000; i++)
				{
					m_lights.Add(new LightData());
					m_lightsInFrustum.Add(new LightData());
				}
			}
		}

		public void Deinitialize()
		{
			VisibleLightCount = 0;
			DrawDebugData = false;
		}

		public void SetFrustumPlanes(ref Plane[] _frustumPlanes)
		{
			FrustumPlanes = _frustumPlanes;
		}

		private void _UpdateBounds()
		{
			int count = m_lights.Count;
			for (int i = 0; i < count; i++)
			{
				LightData lightData = m_lights[i];
				if (lightData.LightType != 0)
				{
					switch (lightData.LightType)
					{
					case EFogVolumeLightType.PointLight:
						lightData.Bounds = new Bounds(lightData.Transform.position, Vector3.one * lightData.Light.range * m_pointLightCullSizeMultiplier);
						break;
					case EFogVolumeLightType.SpotLight:
					{
						Vector3 center2 = lightData.Transform.position + lightData.Transform.forward * lightData.Light.range * 0.5f;
						lightData.Bounds = new Bounds(center2, Vector3.one * lightData.Light.range * m_pointLightCullSizeMultiplier * 1.25f);
						break;
					}
					case EFogVolumeLightType.FogVolumePointLight:
						lightData.Bounds = new Bounds(lightData.Transform.position, Vector3.one * lightData.FogVolumeLight.Range * m_pointLightCullSizeMultiplier);
						break;
					case EFogVolumeLightType.FogVolumeSpotLight:
					{
						Vector3 center = lightData.Transform.position + lightData.Transform.forward * lightData.FogVolumeLight.Range * 0.5f;
						lightData.Bounds = new Bounds(center, Vector3.one * lightData.FogVolumeLight.Range * m_pointLightCullSizeMultiplier * 1.25f);
						break;
					}
					}
				}
			}
		}

		private int _FindFirstFreeLight()
		{
			if (CurrentLightCount < 1000)
			{
				int count = m_lights.Count;
				for (int i = 0; i < count; i++)
				{
					if (m_lights[i].LightType == EFogVolumeLightType.None)
					{
						return i;
					}
				}
			}
			return -1;
		}

		private void _FindLightsInFrustum()
		{
			m_inFrustumCount = 0;
			Vector3 position = m_camera.gameObject.transform.position;
			int count = m_lights.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_lights[i].Transform == null)
				{
					m_lights[i].LightType = EFogVolumeLightType.None;
				}
				if (m_lights[i].LightType == EFogVolumeLightType.None || (m_lights[i].Transform.position - position).magnitude > m_fogVolume.PointLightingDistance2Camera)
				{
					continue;
				}
				switch (m_lights[i].LightType)
				{
				case EFogVolumeLightType.PointLight:
				case EFogVolumeLightType.SpotLight:
					if (!m_lights[i].Light.enabled)
					{
						continue;
					}
					break;
				case EFogVolumeLightType.FogVolumePointLight:
					if (!m_lights[i].FogVolumeLight.Enabled)
					{
						continue;
					}
					break;
				case EFogVolumeLightType.FogVolumeSpotLight:
					if (!m_lights[i].FogVolumeLight.Enabled)
					{
						continue;
					}
					break;
				case EFogVolumeLightType.None:
					continue;
				}
				if (!GeometryUtility.TestPlanesAABB(FrustumPlanes, m_lights[i].Bounds))
				{
					continue;
				}
				LightData lightData = m_lights[i];
				Vector3 position2 = lightData.Transform.position;
				lightData.SqDistance = (position2 - m_pointOfInterest).sqrMagnitude;
				lightData.Distance2Camera = (position2 - position).magnitude;
				m_lightsInFrustum[m_inFrustumCount++] = lightData;
				if (lightData.FogVolumeLight != null)
				{
					if (lightData.LightType == EFogVolumeLightType.FogVolumePointLight && !lightData.FogVolumeLight.IsPointLight)
					{
						lightData.LightType = EFogVolumeLightType.FogVolumeSpotLight;
					}
					else if (lightData.LightType == EFogVolumeLightType.FogVolumeSpotLight && lightData.FogVolumeLight.IsPointLight)
					{
						lightData.LightType = EFogVolumeLightType.FogVolumePointLight;
					}
				}
			}
		}

		private void _SortLightsInFrustum()
		{
			bool flag = false;
			do
			{
				flag = true;
				for (int i = 0; i < m_inFrustumCount - 1; i++)
				{
					if (m_lightsInFrustum[i].SqDistance > m_lightsInFrustum[i + 1].SqDistance)
					{
						LightData value = m_lightsInFrustum[i];
						m_lightsInFrustum[i] = m_lightsInFrustum[i + 1];
						m_lightsInFrustum[i + 1] = value;
						flag = false;
					}
				}
			}
			while (!flag);
		}

		private void _PrepareShaderArrays()
		{
			VisibleLightCount = 0;
			for (int i = 0; i < 64 && i < m_inFrustumCount; i++)
			{
				LightData lightData = m_lightsInFrustum[i];
				switch (lightData.LightType)
				{
				case EFogVolumeLightType.FogVolumePointLight:
				{
					FogVolumeLight fogVolumeLight2 = lightData.FogVolumeLight;
					m_lightPos[i] = base.gameObject.transform.InverseTransformPoint(lightData.Transform.position);
					m_lightRot[i] = base.gameObject.transform.InverseTransformVector(lightData.Transform.forward);
					m_lightColor[i] = fogVolumeLight2.Color;
					m_lightData[i] = new Vector4(fogVolumeLight2.Intensity * m_fogVolume.PointLightsIntensity * (1f - Mathf.Clamp01(lightData.Distance2Camera / m_fogVolume.PointLightingDistance2Camera)), fogVolumeLight2.Range / 5f, -1f, 0f);
					VisibleLightCount++;
					break;
				}
				case EFogVolumeLightType.FogVolumeSpotLight:
				{
					FogVolumeLight fogVolumeLight = lightData.FogVolumeLight;
					m_lightPos[i] = base.gameObject.transform.InverseTransformPoint(lightData.Transform.position);
					m_lightRot[i] = base.gameObject.transform.InverseTransformVector(lightData.Transform.forward);
					m_lightColor[i] = fogVolumeLight.Color;
					m_lightData[i] = new Vector4(fogVolumeLight.Intensity * m_fogVolume.PointLightsIntensity * (1f - Mathf.Clamp01(lightData.Distance2Camera / m_fogVolume.PointLightingDistance2Camera)), fogVolumeLight.Range / 5f, fogVolumeLight.Angle, 0f);
					VisibleLightCount++;
					break;
				}
				case EFogVolumeLightType.PointLight:
				{
					Light light2 = lightData.Light;
					m_lightPos[i] = base.gameObject.transform.InverseTransformPoint(lightData.Transform.position);
					m_lightRot[i] = base.gameObject.transform.InverseTransformVector(lightData.Transform.forward);
					m_lightColor[i] = light2.color;
					m_lightData[i] = new Vector4(light2.intensity * m_fogVolume.PointLightsIntensity * (1f - Mathf.Clamp01(lightData.Distance2Camera / m_fogVolume.PointLightingDistance2Camera)), light2.range / 5f, -1f, 0f);
					VisibleLightCount++;
					break;
				}
				case EFogVolumeLightType.SpotLight:
				{
					Light light = lightData.Light;
					m_lightPos[i] = base.gameObject.transform.InverseTransformPoint(lightData.Transform.position);
					m_lightRot[i] = base.gameObject.transform.InverseTransformVector(lightData.Transform.forward);
					m_lightColor[i] = light.color;
					m_lightData[i] = new Vector4(light.intensity * m_fogVolume.PointLightsIntensity * (1f - Mathf.Clamp01(lightData.Distance2Camera / m_fogVolume.PointLightingDistance2Camera)), light.range / 5f, light.spotAngle, 0f);
					VisibleLightCount++;
					break;
				}
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class FogVolumePrimitive : MonoBehaviour
	{
		public BoxCollider BoxColl;

		public SphereCollider SphereColl;

		public bool IsPersistent = true;

		public EFogVolumePrimitiveType Type;

		public bool IsSubtractive;

		public Material PrimitiveMaterial;

		private GameObject Primitive;

		private Renderer _Renderer;

		private readonly float MinScale = 0.0001f;

		public Transform GetTransform => base.gameObject.transform;

		public Vector3 GetPrimitiveScale => new Vector3(Mathf.Max(MinScale, base.transform.lossyScale.x), Mathf.Max(MinScale, base.transform.lossyScale.y), Mathf.Max(MinScale, base.transform.lossyScale.z));

		public Bounds Bounds
		{
			get
			{
				if (BoxColl != null)
				{
					return BoxColl.bounds;
				}
				if (SphereColl != null)
				{
					return SphereColl.bounds;
				}
				return new Bounds(base.gameObject.transform.position, base.gameObject.transform.lossyScale);
			}
		}

		public FogVolumePrimitive()
		{
			SphereColl = null;
			BoxColl = null;
		}

		public void AddColliderIfNeccessary(EFogVolumePrimitiveType _type)
		{
			Type = _type;
			switch (Type)
			{
			case EFogVolumePrimitiveType.Box:
				if (BoxColl == null)
				{
					BoxColl = base.gameObject.AddComponent<BoxCollider>();
				}
				break;
			case EFogVolumePrimitiveType.Sphere:
				if (SphereColl == null)
				{
					SphereColl = base.gameObject.AddComponent<SphereCollider>();
				}
				break;
			case EFogVolumePrimitiveType.None:
				break;
			}
		}

		private void OnEnable()
		{
			Primitive = base.gameObject;
			_Renderer = Primitive.GetComponent<MeshRenderer>();
			if (!PrimitiveMaterial)
			{
				PrimitiveMaterial = (Material)Resources.Load("PrimitiveMaterial");
			}
			_Renderer.reflectionProbeUsage = ReflectionProbeUsage.Off;
			_Renderer.lightProbeUsage = LightProbeUsage.Off;
			_Renderer.shadowCastingMode = ShadowCastingMode.Off;
			_Renderer.receiveShadows = false;
			GetComponent<MeshRenderer>().material = PrimitiveMaterial;
			BoxColl = GetComponent<BoxCollider>();
			SphereColl = GetComponent<SphereCollider>();
			if (BoxColl == null && SphereColl == null)
			{
				BoxColl = base.gameObject.AddComponent<BoxCollider>();
				Type = EFogVolumePrimitiveType.Box;
			}
			else if (BoxColl != null)
			{
				Type = EFogVolumePrimitiveType.Box;
			}
			else if (SphereColl != null)
			{
				Type = EFogVolumePrimitiveType.Sphere;
			}
			else
			{
				Type = EFogVolumePrimitiveType.None;
			}
		}
	}
	public class FogVolumePrimitiveManager : MonoBehaviour
	{
		protected class PrimitiveData
		{
			public EFogVolumePrimitiveType PrimitiveType { get; set; }

			public FogVolumePrimitive Primitive { get; set; }

			public Transform Transform { get; set; }

			public Renderer Renderer { get; set; }

			public float SqDistance { get; set; }

			public float Distance2Camera { get; set; }

			public Bounds Bounds { get; set; }

			public PrimitiveData()
			{
				PrimitiveType = EFogVolumePrimitiveType.None;
				Primitive = null;
				Transform = null;
				Renderer = null;
				SqDistance = 0f;
				Distance2Camera = 0f;
				Bounds = default(Bounds);
			}

			public void Reset()
			{
				PrimitiveType = EFogVolumePrimitiveType.None;
				Primitive = null;
				Transform = null;
				Renderer = null;
				SqDistance = 0f;
				Distance2Camera = 0f;
			}
		}

		private FogVolume m_fogVolume;

		private FogVolumeData m_fogVolumeData;

		private Camera m_camera;

		private BoxCollider m_boxCollider;

		private Transform m_pointOfInterestTf;

		private Vector3 m_pointOfInterest = Vector3.zero;

		private List<PrimitiveData> m_primitives;

		private List<PrimitiveData> m_primitivesInFrustum;

		private int m_inFrustumCount;

		private Plane[] FrustumPlanes;

		private readonly Vector4[] m_primitivePos = new Vector4[20];

		private readonly Vector4[] m_primitiveScale = new Vector4[20];

		private readonly Matrix4x4[] m_primitiveTf = new Matrix4x4[20];

		private readonly Vector4[] m_primitiveData = new Vector4[20];

		private const int InvalidIndex = -1;

		private const int MaxVisiblePrimitives = 20;

		private const int MaxPrimitivesCount = 1000;

		public int CurrentPrimitiveCount { get; private set; }

		public int VisiblePrimitiveCount { get; private set; }

		public bool AlreadyUsesTransformForPoI => m_pointOfInterestTf != null;

		public void FindPrimitivesInFogVolume()
		{
			CurrentPrimitiveCount = 0;
			VisiblePrimitiveCount = 0;
			m_primitives.Clear();
			m_primitivesInFrustum.Clear();
			for (int i = 0; i < 1000; i++)
			{
				m_primitives.Add(new PrimitiveData());
				m_primitivesInFrustum.Add(new PrimitiveData());
			}
			if (m_boxCollider == null)
			{
				m_boxCollider = base.gameObject.GetComponent<BoxCollider>();
			}
			Bounds bounds = m_boxCollider.bounds;
			FogVolumePrimitive[] array = UnityEngine.Object.FindObjectsOfType<FogVolumePrimitive>();
			foreach (FogVolumePrimitive fogVolumePrimitive in array)
			{
				if (bounds.Intersects(fogVolumePrimitive.Bounds))
				{
					if (fogVolumePrimitive.BoxColl != null)
					{
						fogVolumePrimitive.Type = EFogVolumePrimitiveType.Box;
					}
					else if (fogVolumePrimitive.SphereColl != null)
					{
						fogVolumePrimitive.Type = EFogVolumePrimitiveType.Sphere;
					}
					else
					{
						fogVolumePrimitive.BoxColl = fogVolumePrimitive.GetTransform.gameObject.AddComponent<BoxCollider>();
						fogVolumePrimitive.Type = EFogVolumePrimitiveType.Box;
					}
					if (fogVolumePrimitive.Type == EFogVolumePrimitiveType.Box)
					{
						AddPrimitiveBox(fogVolumePrimitive);
					}
					else if (fogVolumePrimitive.Type == EFogVolumePrimitiveType.Sphere)
					{
						AddPrimitiveSphere(fogVolumePrimitive);
					}
				}
			}
		}

		public bool AddPrimitiveBox(FogVolumePrimitive _box)
		{
			int num = _FindFirstFreePrimitive();
			if (num != -1)
			{
				PrimitiveData primitiveData = m_primitives[num];
				CurrentPrimitiveCount++;
				primitiveData.PrimitiveType = EFogVolumePrimitiveType.Box;
				primitiveData.Transform = _box.transform;
				primitiveData.Renderer = _box.GetComponent<Renderer>();
				primitiveData.Primitive = _box;
				primitiveData.Bounds = new Bounds(primitiveData.Transform.position, _box.GetPrimitiveScale);
				return true;
			}
			return false;
		}

		public bool AddPrimitiveSphere(FogVolumePrimitive _sphere)
		{
			int num = _FindFirstFreePrimitive();
			if (num != -1)
			{
				PrimitiveData primitiveData = m_primitives[num];
				CurrentPrimitiveCount++;
				primitiveData.PrimitiveType = EFogVolumePrimitiveType.Sphere;
				primitiveData.Transform = _sphere.transform;
				primitiveData.Renderer = _sphere.GetComponent<Renderer>();
				primitiveData.Primitive = _sphere;
				primitiveData.Bounds = new Bounds(primitiveData.Transform.position, _sphere.GetPrimitiveScale);
				return true;
			}
			return false;
		}

		public bool RemovePrimitive(Transform _primitiveToRemove)
		{
			int count = m_primitives.Count;
			for (int i = 0; i < count; i++)
			{
				PrimitiveData primitiveData = m_primitives[i];
				if ((object)m_primitives[i].Transform == _primitiveToRemove)
				{
					primitiveData.Reset();
					CurrentPrimitiveCount--;
					return true;
				}
			}
			return false;
		}

		public void SetPointOfInterest(Vector3 _pointOfInterest)
		{
			m_pointOfInterestTf = null;
			m_pointOfInterest = _pointOfInterest;
		}

		public void SetPointOfInterest(Transform _pointOfInterest)
		{
			m_pointOfInterestTf = _pointOfInterest;
		}

		public void OnDrawGizmos()
		{
			base.hideFlags = HideFlags.HideInInspector;
		}

		public void ManualUpdate(ref Plane[] _frustumPlanes)
		{
			m_camera = ((m_fogVolumeData != null) ? m_fogVolumeData.GameCamera : null);
			if (!(m_camera == null))
			{
				FrustumPlanes = _frustumPlanes;
				if (m_boxCollider == null)
				{
					m_boxCollider = m_fogVolume.GetComponent<BoxCollider>();
				}
				_UpdateBounds();
				_FindPrimitivesInFrustum();
				if (m_primitivesInFrustum.Count > 20)
				{
					_SortPrimitivesInFrustum();
				}
				_PrepareShaderArrays();
			}
		}

		public void SetVisibility(bool _enabled)
		{
			int count = m_primitives.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_primitives[i].Renderer != null)
				{
					m_primitives[i].Renderer.enabled = _enabled;
				}
			}
		}

		public void Initialize()
		{
			m_fogVolume = base.gameObject.GetComponent<FogVolume>();
			m_fogVolumeData = UnityEngine.Object.FindObjectOfType<FogVolumeData>();
			m_camera = null;
			m_boxCollider = null;
			CurrentPrimitiveCount = 0;
			if (m_primitives == null)
			{
				m_primitives = new List<PrimitiveData>(1000);
				m_primitivesInFrustum = new List<PrimitiveData>();
				for (int i = 0; i < 1000; i++)
				{
					m_primitives.Add(new PrimitiveData());
					m_primitivesInFrustum.Add(new PrimitiveData());
				}
			}
		}

		public void Deinitialize()
		{
			VisiblePrimitiveCount = 0;
		}

		public Vector4[] GetPrimitivePositionArray()
		{
			return m_primitivePos;
		}

		public Vector4[] GetPrimitiveScaleArray()
		{
			return m_primitiveScale;
		}

		public Matrix4x4[] GetPrimitiveTransformArray()
		{
			return m_primitiveTf;
		}

		public Vector4[] GetPrimitiveDataArray()
		{
			return m_primitiveData;
		}

		private void _UpdateBounds()
		{
			int count = m_primitives.Count;
			for (int i = 0; i < count; i++)
			{
				PrimitiveData primitiveData = m_primitives[i];
				if (primitiveData.PrimitiveType == EFogVolumePrimitiveType.None)
				{
					continue;
				}
				if (primitiveData.Primitive == null)
				{
					RemovePrimitive(primitiveData.Transform);
				}
				else if (primitiveData.PrimitiveType == EFogVolumePrimitiveType.Box)
				{
					if (primitiveData.Primitive.BoxColl == null)
					{
						UnityEngine.Debug.LogWarning("FogVolumePrimitive requires a collider.\nThe collider will be automatically created.");
						primitiveData.Primitive.AddColliderIfNeccessary(EFogVolumePrimitiveType.Box);
					}
					primitiveData.Bounds = primitiveData.Primitive.BoxColl.bounds;
				}
				else if (primitiveData.PrimitiveType == EFogVolumePrimitiveType.Sphere)
				{
					if (primitiveData.Primitive.SphereColl == null)
					{
						UnityEngine.Debug.LogWarning("FogVolumePrimitive requires a collider.\nThe collider will be automatically created.");
						primitiveData.Primitive.AddColliderIfNeccessary(EFogVolumePrimitiveType.Sphere);
					}
					primitiveData.Bounds = primitiveData.Primitive.SphereColl.bounds;
				}
			}
		}

		private int _FindFirstFreePrimitive()
		{
			if (CurrentPrimitiveCount < 1000)
			{
				int count = m_primitives.Count;
				for (int i = 0; i < count; i++)
				{
					if (m_primitives[i].PrimitiveType == EFogVolumePrimitiveType.None)
					{
						return i;
					}
				}
			}
			return -1;
		}

		private void _FindPrimitivesInFrustum()
		{
			m_inFrustumCount = 0;
			Vector3 position = m_camera.gameObject.transform.position;
			int count = m_primitives.Count;
			for (int i = 0; i < count; i++)
			{
				PrimitiveData primitiveData = m_primitives[i];
				if (primitiveData.Transform == null)
				{
					primitiveData.PrimitiveType = EFogVolumePrimitiveType.None;
				}
				if (primitiveData.PrimitiveType != EFogVolumePrimitiveType.None)
				{
					if (primitiveData.Primitive.IsPersistent)
					{
						Vector3 position2 = primitiveData.Transform.position;
						primitiveData.SqDistance = (position2 - m_pointOfInterest).sqrMagnitude;
						primitiveData.Distance2Camera = (position2 - position).magnitude;
						m_primitivesInFrustum[m_inFrustumCount++] = primitiveData;
					}
					else if (GeometryUtility.TestPlanesAABB(FrustumPlanes, m_primitives[i].Bounds))
					{
						Vector3 position3 = primitiveData.Transform.position;
						primitiveData.SqDistance = (position3 - m_pointOfInterest).sqrMagnitude;
						primitiveData.Distance2Camera = (position3 - position).magnitude;
						m_primitivesInFrustum[m_inFrustumCount++] = primitiveData;
					}
				}
			}
		}

		private void _SortPrimitivesInFrustum()
		{
			bool flag = false;
			do
			{
				flag = true;
				for (int i = 0; i < m_inFrustumCount - 1; i++)
				{
					if (m_primitivesInFrustum[i].SqDistance > m_primitivesInFrustum[i + 1].SqDistance)
					{
						PrimitiveData value = m_primitivesInFrustum[i];
						m_primitivesInFrustum[i] = m_primitivesInFrustum[i + 1];
						m_primitivesInFrustum[i + 1] = value;
						flag = false;
					}
				}
			}
			while (!flag);
		}

		private void _PrepareShaderArrays()
		{
			VisiblePrimitiveCount = 0;
			Quaternion rotation = m_fogVolume.gameObject.transform.rotation;
			for (int i = 0; i < 20 && i < m_inFrustumCount; i++)
			{
				PrimitiveData primitiveData = m_primitivesInFrustum[i];
				Vector3 position = primitiveData.Transform.position;
				m_primitivePos[i] = base.gameObject.transform.InverseTransformPoint(position);
				m_primitiveTf[i].SetTRS(position, Quaternion.Inverse(primitiveData.Transform.rotation) * rotation, Vector3.one);
				m_primitiveScale[i] = primitiveData.Primitive.GetPrimitiveScale;
				m_primitiveData[i] = new Vector4((primitiveData.PrimitiveType == EFogVolumePrimitiveType.Box) ? 0.5f : 1.5f, primitiveData.Primitive.IsSubtractive ? 1.5f : 0.5f, 0f, 0f);
				VisiblePrimitiveCount++;
			}
		}
	}
	[ExecuteInEditMode]
	public class FogVolumeRenderer : MonoBehaviour
	{
		public enum BlendMode
		{
			PremultipliedTransparency = 1,
			TraditionalTransparency = 5
		}

		[Serializable]
		[SerializeField]
		public enum UpsampleMode
		{
			DOWNSAMPLE_MIN,
			DOWNSAMPLE_MAX,
			DOWNSAMPLE_CHESSBOARD
		}

		public enum UpsampleMaterialPass
		{
			DEPTH_DOWNSAMPLE,
			BILATERAL_UPSAMPLE
		}

		private bool ShowCamerasBack = true;

		public bool ShowCamera;

		private int m_screenWidth;

		private int m_screenHeight;

		public string FogVolumeResolution;

		private RenderTextureFormat rt_DepthFormat;

		public BlendMode _BlendMode = BlendMode.PremultipliedTransparency;

		public bool GenerateDepth = true;

		private RenderTexture RT_FogVolume;

		private RenderTexture RT_FogVolumeR;

		[SerializeField]
		[Range(0f, 8f)]
		public int _Downsample = 1;

		public bool _showBilateralEdge;

		private Material bilateralMaterial;

		public bool _useBilateralUpsampling = true;

		public UpsampleMode _upsampleMode = UpsampleMode.DOWNSAMPLE_MAX;

		private Camera ThisCamera;

		private RenderTexture RT_Depth;

		private RenderTexture RT_DepthR;

		private Shader depthShader;

		[HideInInspector]
		private Camera _FogVolumeCamera;

		private GameObject _FogVolumeCameraGO;

		[SerializeField]
		[Range(0f, 0.01f)]
		public float upsampleDepthThreshold = 0.00187f;

		public bool HDR;

		public bool TAA;

		public FogVolumeTAA _TAA;

		private VelocityBuffer _TAAvelocity;

		private FrustumJitter _TAAjitter;

		[SerializeField]
		public int DepthLayer2;

		public RenderTexture[] lowProfileDepthRT;

		public RenderTexture[] lowProfileDepthRRT;

		private Vector4 TexelSize = Vector4.zero;

		private Material SurrogateMaterial;

		public bool SceneBlur = true;

		public bool showBilateralEdge
		{
			get
			{
				return _showBilateralEdge;
			}
			set
			{
				if (value != _showBilateralEdge)
				{
					ShowBilateralEdge(value);
				}
			}
		}

		public bool useBilateralUpsampling
		{
			get
			{
				return _useBilateralUpsampling;
			}
			set
			{
				if (_useBilateralUpsampling != value)
				{
					SetUseBilateralUpsampling(value);
				}
			}
		}

		public UpsampleMode upsampleMode
		{
			get
			{
				return _upsampleMode;
			}
			set
			{
				if (value != _upsampleMode)
				{
					SetUpsampleMode(value);
				}
			}
		}

		public void setDownsample(int val)
		{
			_Downsample = val;
		}

		public void ShowBilateralEdge(bool b)
		{
			_showBilateralEdge = b;
			if ((bool)bilateralMaterial)
			{
				if (showBilateralEdge)
				{
					bilateralMaterial.EnableKeyword("VISUALIZE_EDGE");
				}
				else
				{
					bilateralMaterial.DisableKeyword("VISUALIZE_EDGE");
				}
			}
		}

		private void SetUseBilateralUpsampling(bool b)
		{
			_useBilateralUpsampling = b;
			if (_useBilateralUpsampling)
			{
				if (bilateralMaterial == null)
				{
					bilateralMaterial = new Material(Shader.Find("Hidden/Upsample"));
					if (bilateralMaterial == null)
					{
						UnityEngine.Debug.Log("#ERROR# Hidden/Upsample");
					}
					UpdateBilateralDownsampleModeSwitch();
					ShowBilateralEdge(_showBilateralEdge);
				}
			}
			else
			{
				bilateralMaterial = null;
			}
		}

		private void UpdateBilateralDownsampleModeSwitch()
		{
			if (bilateralMaterial != null)
			{
				switch (_upsampleMode)
				{
				case UpsampleMode.DOWNSAMPLE_MIN:
					bilateralMaterial.EnableKeyword("DOWNSAMPLE_DEPTH_MODE_MIN");
					bilateralMaterial.DisableKeyword("DOWNSAMPLE_DEPTH_MODE_MAX");
					bilateralMaterial.DisableKeyword("DOWNSAMPLE_DEPTH_MODE_CHESSBOARD");
					break;
				case UpsampleMode.DOWNSAMPLE_MAX:
					bilateralMaterial.DisableKeyword("DOWNSAMPLE_DEPTH_MODE_MIN");
					bilateralMaterial.EnableKeyword("DOWNSAMPLE_DEPTH_MODE_MAX");
					bilateralMaterial.DisableKeyword("DOWNSAMPLE_DEPTH_MODE_CHESSBOARD");
					break;
				case UpsampleMode.DOWNSAMPLE_CHESSBOARD:
					bilateralMaterial.DisableKeyword("DOWNSAMPLE_DEPTH_MODE_MIN");
					bilateralMaterial.DisableKeyword("DOWNSAMPLE_DEPTH_MODE_MAX");
					bilateralMaterial.EnableKeyword("DOWNSAMPLE_DEPTH_MODE_CHESSBOARD");
					break;
				}
			}
		}

		private void SetUpsampleMode(UpsampleMode value)
		{
			_upsampleMode = value;
			UpdateBilateralDownsampleModeSwitch();
		}

		public RenderTextureReadWrite GetRTReadWrite()
		{
			if (!ThisCamera.allowHDR)
			{
				return RenderTextureReadWrite.Linear;
			}
			return RenderTextureReadWrite.Default;
		}

		public RenderTextureFormat GetRTFormat()
		{
			if (!ThisCamera.allowHDR)
			{
				return RenderTextureFormat.Default;
			}
			return RenderTextureFormat.DefaultHDR;
		}

		protected void GetRT(ref RenderTexture rt, int2 size, string name)
		{
			ReleaseRT(rt);
			rt = RenderTexture.GetTemporary(size.x, size.y, 0, GetRTFormat(), GetRTReadWrite());
			rt.filterMode = FilterMode.Bilinear;
			rt.name = name;
			rt.wrapMode = TextureWrapMode.Clamp;
		}

		public void ReleaseRT(RenderTexture rt)
		{
			if (rt != null)
			{
				RenderTexture.ReleaseTemporary(rt);
				rt = null;
			}
		}

		protected void Get_RT_Depth(ref RenderTexture rt, int2 size, string name)
		{
			ReleaseRT(rt);
			rt = RenderTexture.GetTemporary(size.x, size.y, 16, rt_DepthFormat);
			rt.filterMode = FilterMode.Bilinear;
			rt.name = name;
			rt.wrapMode = TextureWrapMode.Clamp;
		}

		private void RenderDepth()
		{
			if (!GenerateDepth || !_FogVolumeCamera)
			{
				return;
			}
			if ((bool)_TAAjitter)
			{
				_TAAjitter.patternScale = 0f;
			}
			_FogVolumeCamera.cullingMask = DepthLayer2;
			if (ThisCamera.stereoEnabled)
			{
				Shader.EnableKeyword("FOG_VOLUME_STEREO_ON");
				if (ThisCamera.stereoTargetEye == StereoTargetEyeMask.Both || ThisCamera.stereoTargetEye == StereoTargetEyeMask.Left)
				{
					_FogVolumeCamera.worldToCameraMatrix = ThisCamera.GetStereoViewMatrix(Camera.StereoscopicEye.Left);
					_FogVolumeCamera.projectionMatrix = ThisCamera.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);
					Get_RT_Depth(ref RT_Depth, new int2(m_screenWidth, m_screenHeight), "RT_DepthLeft");
					_FogVolumeCamera.targetTexture = RT_Depth;
					_FogVolumeCamera.RenderWithShader(depthShader, "RenderType");
				}
				if (ThisCamera.stereoTargetEye == StereoTargetEyeMask.Both || ThisCamera.stereoTargetEye == StereoTargetEyeMask.Right)
				{
					_FogVolumeCamera.worldToCameraMatrix = ThisCamera.GetStereoViewMatrix(Camera.StereoscopicEye.Right);
					_FogVolumeCamera.projectionMatrix = ThisCamera.GetStereoProjectionMatrix(Camera.StereoscopicEye.Right);
					Get_RT_Depth(ref RT_DepthR, new int2(m_screenWidth, m_screenHeight), "RT_DepthRight");
					_FogVolumeCamera.targetTexture = RT_DepthR;
					_FogVolumeCamera.RenderWithShader(depthShader, "RenderType");
					Shader.SetGlobalTexture("RT_DepthR", RT_DepthR);
				}
			}
			else
			{
				_FogVolumeCamera.projectionMatrix = ThisCamera.projectionMatrix;
				Shader.DisableKeyword("FOG_VOLUME_STEREO_ON");
				Get_RT_Depth(ref RT_Depth, new int2(m_screenWidth, m_screenHeight), "RT_Depth");
				_FogVolumeCamera.targetTexture = RT_Depth;
				_FogVolumeCamera.RenderWithShader(depthShader, "RenderType");
			}
			Shader.SetGlobalTexture("RT_Depth", RT_Depth);
		}

		private void ReleaseLowProfileDepthRT()
		{
			if (lowProfileDepthRT != null)
			{
				for (int i = 0; i < lowProfileDepthRT.Length; i++)
				{
					RenderTexture.ReleaseTemporary(lowProfileDepthRT[i]);
				}
				lowProfileDepthRT = null;
			}
		}

		private void ReleaseLowProfileDepthRRT()
		{
			if (lowProfileDepthRRT != null)
			{
				for (int i = 0; i < lowProfileDepthRRT.Length; i++)
				{
					RenderTexture.ReleaseTemporary(lowProfileDepthRRT[i]);
				}
				lowProfileDepthRRT = null;
			}
		}

		private void RenderColor()
		{
			if ((bool)_TAA && (bool)_TAAjitter)
			{
				_TAA.enabled = TAA;
				_TAAvelocity.enabled = false;
				_TAAjitter.enabled = TAA;
				_TAAjitter.patternScale = 0.2f;
			}
			_FogVolumeCamera.cullingMask = 1 << LayerMask.NameToLayer("FogVolume");
			_FogVolumeCamera.cullingMask |= 1 << LayerMask.NameToLayer("FogVolumeShadowCaster");
			int2 size = new int2(m_screenWidth / _Downsample, m_screenHeight / _Downsample);
			FogVolumeResolution = size.x + " X " + size.y;
			if (ThisCamera.stereoEnabled)
			{
				Shader.EnableKeyword("FOG_VOLUME_STEREO_ON");
				if (ThisCamera.stereoTargetEye == StereoTargetEyeMask.Both || ThisCamera.stereoTargetEye == StereoTargetEyeMask.Left)
				{
					_FogVolumeCamera.projectionMatrix = ThisCamera.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);
					_FogVolumeCamera.worldToCameraMatrix = ThisCamera.GetStereoViewMatrix(Camera.StereoscopicEye.Left);
					GetRT(ref RT_FogVolume, size, "RT_FogVolumeLeft");
					_FogVolumeCamera.targetTexture = RT_FogVolume;
					_FogVolumeCamera.Render();
				}
				if (ThisCamera.stereoTargetEye == StereoTargetEyeMask.Both || ThisCamera.stereoTargetEye == StereoTargetEyeMask.Right)
				{
					_FogVolumeCamera.projectionMatrix = ThisCamera.GetStereoProjectionMatrix(Camera.StereoscopicEye.Right);
					_FogVolumeCamera.worldToCameraMatrix = ThisCamera.GetStereoViewMatrix(Camera.StereoscopicEye.Right);
					GetRT(ref RT_FogVolumeR, size, "RT_FogVolumeRight");
					_FogVolumeCamera.targetTexture = RT_FogVolumeR;
					_FogVolumeCamera.Render();
				}
			}
			else
			{
				Shader.DisableKeyword("FOG_VOLUME_STEREO_ON");
				_FogVolumeCamera.projectionMatrix = ThisCamera.projectionMatrix;
				GetRT(ref RT_FogVolume, size, "RT_FogVolume");
				_FogVolumeCamera.targetTexture = RT_FogVolume;
				_FogVolumeCamera.Render();
			}
			if (TAA)
			{
				_TAA.TAA(ref RT_FogVolume);
			}
			if (ThisCamera.stereoEnabled && TAA)
			{
				_TAA.TAA(ref RT_FogVolumeR);
			}
			if (useBilateralUpsampling && GenerateDepth)
			{
				if ((bool)bilateralMaterial)
				{
					bilateralMaterial.SetInt("RightSide", 0);
					ReleaseLowProfileDepthRT();
					lowProfileDepthRT = new RenderTexture[_Downsample];
					for (int i = 0; i < _Downsample; i++)
					{
						int width = m_screenWidth / (i + 1);
						int height = m_screenHeight / (i + 1);
						int num = m_screenWidth / Mathf.Max(i, 1);
						int num2 = m_screenHeight / Mathf.Max(i, 1);
						Vector4 value = new Vector4(1f / (float)num, 1f / (float)num2, 0f, 0f);
						bilateralMaterial.SetFloat("_UpsampleDepthThreshold", upsampleDepthThreshold);
						bilateralMaterial.SetVector("_TexelSize", value);
						bilateralMaterial.SetTexture("_HiResDepthBuffer", RT_Depth);
						lowProfileDepthRT[i] = RenderTexture.GetTemporary(width, height, 0, rt_DepthFormat, GetRTReadWrite());
						lowProfileDepthRT[i].name = "lowProfileDepthRT_" + i;
						Graphics.Blit(null, lowProfileDepthRT[i], bilateralMaterial, 0);
					}
					Shader.SetGlobalTexture("RT_Depth", lowProfileDepthRT[lowProfileDepthRT.Length - 1]);
				}
				if ((bool)bilateralMaterial)
				{
					for (int num3 = _Downsample - 1; num3 >= 0; num3--)
					{
						int width2 = m_screenWidth / Mathf.Max(num3, 1);
						int height2 = m_screenHeight / Mathf.Max(num3, 1);
						int num4 = m_screenWidth / (num3 + 1);
						Vector4 value2 = new Vector4(y: 1f / (float)(m_screenHeight / (num3 + 1)), x: 1f / (float)num4, z: 0f, w: 0f);
						bilateralMaterial.SetVector("_TexelSize", value2);
						bilateralMaterial.SetVector("_InvdUV", new Vector4(RT_FogVolume.width, RT_FogVolume.height, 0f, 0f));
						bilateralMaterial.SetTexture("_HiResDepthBuffer", RT_Depth);
						bilateralMaterial.SetTexture("_LowResDepthBuffer", lowProfileDepthRT[num3]);
						bilateralMaterial.SetTexture("_LowResColor", RT_FogVolume);
						RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, GetRTFormat(), GetRTReadWrite());
						temporary.filterMode = FilterMode.Bilinear;
						Graphics.Blit(null, temporary, bilateralMaterial, 1);
						RenderTexture rT_FogVolume = RT_FogVolume;
						RT_FogVolume = temporary;
						RenderTexture.ReleaseTemporary(rT_FogVolume);
					}
				}
				ReleaseLowProfileDepthRT();
				if (ThisCamera.stereoEnabled)
				{
					if ((bool)bilateralMaterial)
					{
						bilateralMaterial.EnableKeyword("FOG_VOLUME_STEREO_ON");
						bilateralMaterial.SetInt("RightSide", 1);
						ReleaseLowProfileDepthRRT();
						lowProfileDepthRRT = new RenderTexture[_Downsample];
						for (int j = 0; j < _Downsample; j++)
						{
							int width3 = m_screenWidth / (j + 1);
							int height3 = m_screenHeight / (j + 1);
							int num5 = m_screenWidth / Mathf.Max(j, 1);
							int num6 = m_screenHeight / Mathf.Max(j, 1);
							Vector4 value3 = new Vector4(1f / (float)num5, 1f / (float)num6, 0f, 0f);
							bilateralMaterial.SetFloat("_UpsampleDepthThreshold", upsampleDepthThreshold);
							bilateralMaterial.SetVector("_TexelSize", value3);
							bilateralMaterial.SetTexture("_HiResDepthBufferR", RT_DepthR);
							lowProfileDepthRRT[j] = RenderTexture.GetTemporary(width3, height3, 0, rt_DepthFormat, GetRTReadWrite());
							lowProfileDepthRRT[j].name = "lowProfileDepthRRT_" + j;
							Graphics.Blit(null, lowProfileDepthRRT[j], bilateralMaterial, 0);
						}
						Shader.SetGlobalTexture("RT_DepthR", lowProfileDepthRRT[lowProfileDepthRRT.Length - 1]);
					}
					if ((bool)bilateralMaterial)
					{
						for (int num7 = _Downsample - 1; num7 >= 0; num7--)
						{
							int width4 = m_screenWidth / Mathf.Max(num7, 1);
							int height4 = m_screenHeight / Mathf.Max(num7, 1);
							int num8 = m_screenWidth / (num7 + 1);
							Vector4 value4 = new Vector4(y: 1f / (float)(m_screenHeight / (num7 + 1)), x: 1f / (float)num8, z: 0f, w: 0f);
							bilateralMaterial.SetVector("_TexelSize", value4);
							bilateralMaterial.SetVector("_InvdUV", new Vector4(RT_FogVolumeR.width, RT_FogVolumeR.height, 0f, 0f));
							bilateralMaterial.SetTexture("_HiResDepthBufferR", RT_DepthR);
							bilateralMaterial.SetTexture("_LowResDepthBufferR", lowProfileDepthRRT[num7]);
							bilateralMaterial.SetTexture("_LowResColorR", RT_FogVolumeR);
							RenderTexture temporary2 = RenderTexture.GetTemporary(width4, height4, 0, GetRTFormat(), GetRTReadWrite());
							temporary2.filterMode = FilterMode.Bilinear;
							Graphics.Blit(null, temporary2, bilateralMaterial, 1);
							RenderTexture rT_FogVolumeR = RT_FogVolumeR;
							RT_FogVolumeR = temporary2;
							RenderTexture.ReleaseTemporary(rT_FogVolumeR);
						}
					}
					ReleaseLowProfileDepthRRT();
				}
				else
				{
					bilateralMaterial.DisableKeyword("FOG_VOLUME_STEREO_ON");
				}
			}
			if (ThisCamera.stereoEnabled)
			{
				Shader.SetGlobalTexture("RT_FogVolumeR", RT_FogVolumeR);
			}
			Shader.SetGlobalTexture("RT_FogVolume", RT_FogVolume);
		}

		private void CameraUpdateSharedProperties()
		{
			if ((bool)_FogVolumeCamera)
			{
				_FogVolumeCamera.farClipPlane = ThisCamera.farClipPlane;
				_FogVolumeCamera.nearClipPlane = ThisCamera.nearClipPlane;
				_FogVolumeCamera.allowHDR = ThisCamera.allowHDR;
				if (!_FogVolumeCamera.stereoEnabled)
				{
					_FogVolumeCamera.fieldOfView = ThisCamera.fieldOfView;
					_FogVolumeCamera.projectionMatrix = ThisCamera.projectionMatrix;
				}
			}
		}

		private void TAASetup()
		{
			if (_Downsample > 1 && TAA)
			{
				if (_FogVolumeCameraGO.GetComponent<FogVolumeTAA>() == null)
				{
					_FogVolumeCameraGO.AddComponent<FogVolumeTAA>();
				}
				_TAA = _FogVolumeCameraGO.GetComponent<FogVolumeTAA>();
				_TAAvelocity = _FogVolumeCameraGO.GetComponent<VelocityBuffer>();
				_TAAjitter = _FogVolumeCameraGO.GetComponent<FrustumJitter>();
			}
		}

		private void CreateFogCamera()
		{
			_FogVolumeCameraGO = new GameObject();
			_FogVolumeCameraGO.transform.parent = base.gameObject.transform;
			_FogVolumeCameraGO.transform.localEulerAngles = Vector3.zero;
			_FogVolumeCameraGO.transform.localPosition = Vector3.zero;
			_FogVolumeCameraGO.name = "FogVolumeCamera";
			_FogVolumeCamera = _FogVolumeCameraGO.AddComponent<Camera>();
			_FogVolumeCamera.depth = -666f;
			_FogVolumeCamera.clearFlags = CameraClearFlags.Color;
			_FogVolumeCamera.backgroundColor = new Color(0f, 0f, 0f, 0f);
			_FogVolumeCamera.enabled = false;
			_FogVolumeCamera.renderingPath = RenderingPath.Forward;
			_FogVolumeCamera.allowMSAA = false;
		}

		private void FindFogCamera()
		{
			_FogVolumeCameraGO = GameObject.Find("FogVolumeCamera");
			if ((bool)_FogVolumeCameraGO)
			{
				_FogVolumeCamera = _FogVolumeCameraGO.GetComponent<Camera>();
			}
			if (_FogVolumeCameraGO == null)
			{
				CreateFogCamera();
			}
			TAASetup();
		}

		private void TexelUpdate()
		{
			TexelSize.x = 1f / (float)ThisCamera.pixelWidth;
			TexelSize.y = 1f / (float)ThisCamera.pixelHeight;
			TexelSize.z = ThisCamera.pixelWidth;
			TexelSize.w = ThisCamera.pixelHeight;
			Shader.SetGlobalVector("RT_FogVolume_TexelSize", TexelSize);
		}

		private void OnEnable()
		{
			SetUseBilateralUpsampling(_useBilateralUpsampling);
			SetUpsampleMode(_upsampleMode);
			ShowBilateralEdge(_showBilateralEdge);
			ThisCamera = base.gameObject.GetComponent<Camera>();
			depthShader = Shader.Find("Hidden/Fog Volume/Depth");
			if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RFloat))
			{
				rt_DepthFormat = RenderTextureFormat.RFloat;
			}
			else
			{
				rt_DepthFormat = RenderTextureFormat.DefaultHDR;
			}
			if (depthShader == null)
			{
				MonoBehaviour.print("Hidden/Fog Volume/Depth #SHADER ERROR#");
			}
			FindFogCamera();
			Component[] components = _FogVolumeCameraGO.GetComponents<Component>();
			if ((bool)_FogVolumeCamera.GetComponent("FogVolumeCamera"))
			{
				MonoBehaviour.print("Destroyed Old Camera");
				SafeDestroy(_FogVolumeCameraGO);
				CreateFogCamera();
			}
			for (int i = 0; i < components.Length; i++)
			{
				if (components[i] == null)
				{
					MonoBehaviour.print("Destroyed Old Camera");
					SafeDestroy(_FogVolumeCameraGO);
					CreateFogCamera();
					break;
				}
			}
			if ((bool)GetComponent<FogVolume>())
			{
				MonoBehaviour.print("Don't add FogVolume here. Create a new one using the menu buttons and follow the instructions");
				UnityEngine.Object.DestroyImmediate(GetComponent<FogVolume>());
			}
			if ((bool)ThisCamera.GetComponent<MeshFilter>())
			{
				UnityEngine.Object.DestroyImmediate(ThisCamera.GetComponent<MeshFilter>());
			}
			if ((bool)ThisCamera.GetComponent<MeshRenderer>())
			{
				UnityEngine.Object.DestroyImmediate(ThisCamera.GetComponent<MeshRenderer>());
			}
			SurrogateMaterial = (Material)Resources.Load("Fog Volume Surrogate");
			if (DepthLayer2 == 0)
			{
				DepthLayer2 = 1;
			}
		}

		private void UpdateParams()
		{
			if (useBilateralUpsampling)
			{
				_ = GenerateDepth;
			}
			if (GenerateDepth)
			{
				SurrogateMaterial.SetInt("_ztest", 8);
				DepthLayer2 &= ~(1 << LayerMask.NameToLayer("FogVolume"));
				DepthLayer2 &= ~(1 << LayerMask.NameToLayer("FogVolumeShadowCaster"));
				DepthLayer2 &= ~(1 << LayerMask.NameToLayer("FogVolumeSurrogate"));
				DepthLayer2 &= ~(1 << LayerMask.NameToLayer("FogVolumeUniform"));
				DepthLayer2 &= ~(1 << LayerMask.NameToLayer("UI"));
			}
			else
			{
				SurrogateMaterial.SetInt("_ztest", 4);
			}
			if (!_TAA)
			{
				TAASetup();
			}
			HDR = ThisCamera.allowHDR;
		}

		private void OnPreRender()
		{
			m_screenWidth = ThisCamera.pixelWidth;
			m_screenHeight = ThisCamera.pixelHeight;
			if (ThisCamera == null)
			{
				ThisCamera = base.gameObject.GetComponent<Camera>();
				UnityEngine.Debug.Log("No fucking camera found");
			}
			if (_FogVolumeCamera == null && _Downsample > 1)
			{
				FindFogCamera();
			}
			if (_Downsample == 1)
			{
				SafeDestroy(_FogVolumeCameraGO);
			}
			CameraUpdateSharedProperties();
			if (_Downsample > 0 && (bool)_FogVolumeCameraGO && base.isActiveAndEnabled)
			{
				ThisCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolume"));
				ThisCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeShadowCaster"));
				FogVolumeResolution = m_screenWidth + " X " + m_screenHeight;
				ThisCamera.cullingMask |= 1 << LayerMask.NameToLayer("FogVolumeSurrogate");
			}
			else
			{
				ThisCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeSurrogate"));
				ThisCamera.cullingMask |= 1 << LayerMask.NameToLayer("FogVolume");
				ThisCamera.cullingMask |= 1 << LayerMask.NameToLayer("FogVolumeShadowCaster");
			}
			int pixelLightCount = QualitySettings.pixelLightCount;
			ShadowQuality shadows = QualitySettings.shadows;
			QualitySettings.pixelLightCount = 0;
			QualitySettings.shadows = ShadowQuality.Disable;
			if (ThisCamera == null)
			{
				ThisCamera = base.gameObject.GetComponent<Camera>();
			}
			UpdateParams();
			SurrogateMaterial.SetInt("_SrcBlend", (int)_BlendMode);
			if (_Downsample > 1 && (bool)_FogVolumeCamera)
			{
				Shader.EnableKeyword("_FOG_LOWRES_RENDERER");
				RenderDepth();
				RenderColor();
				Shader.DisableKeyword("_FOG_LOWRES_RENDERER");
			}
			else
			{
				Shader.DisableKeyword("_FOG_LOWRES_RENDERER");
			}
			QualitySettings.pixelLightCount = pixelLightCount;
			QualitySettings.shadows = shadows;
		}

		private void Update()
		{
			ShowCamerasBack = ShowCamera;
		}

		private void SafeDestroy(UnityEngine.Object obj)
		{
			if (obj != null)
			{
				obj = null;
				UnityEngine.Object.DestroyImmediate(obj);
			}
			obj = null;
		}

		private void OnDisable()
		{
			Shader.DisableKeyword("_FOG_LOWRES_RENDERER");
			ThisCamera.cullingMask |= 1 << LayerMask.NameToLayer("FogVolume");
			ThisCamera.cullingMask |= 1 << LayerMask.NameToLayer("FogVolumeShadowCaster");
			ThisCamera.cullingMask &= ~(1 << LayerMask.NameToLayer("FogVolumeSurrogate"));
			SafeDestroy(_TAA);
			SafeDestroy(_TAAvelocity);
			SafeDestroy(_TAAjitter);
			SafeDestroy(_FogVolumeCameraGO);
			SafeDestroy(RT_FogVolume);
			SafeDestroy(RT_FogVolumeR);
			SafeDestroy(RT_Depth);
			SafeDestroy(RT_DepthR);
		}
	}
	[ExecuteInEditMode]
	public class FogVolumeScreen : MonoBehaviour
	{
		public enum BlurType
		{
			Standard,
			Sgx
		}

		[Header("Scene blur")]
		[Range(1f, 8f)]
		public int Downsample = 8;

		[SerializeField]
		[Range(0.001f, 15f)]
		private float _Falloff = 1f;

		private float FOV_compensation;

		private Shader _BlurShader;

		private Camera UniformFogCamera;

		private GameObject UniformFogCameraGO;

		[HideInInspector]
		public Camera SceneCamera;

		private RenderTexture RT_FogVolumeConvolution;

		private RenderTextureFormat RT_Format;

		[HideInInspector]
		public int FogVolumeLayer = -1;

		[SerializeField]
		[HideInInspector]
		private string _FogVolumeLayerName = "FogVolumeUniform";

		private Material _BlurMaterial;

		[Range(0f, 10f)]
		public int iterations = 3;

		[Range(0f, 1f)]
		public float blurSpread = 0.6f;

		[Header("Bloom")]
		[Range(1f, 5f)]
		public int _BloomDowsample = 8;

		[Range(0f, 1.5f)]
		public float threshold = 0.35f;

		[Range(0f, 10f)]
		public float intensity = 2.5f;

		[Range(0f, 1f)]
		public float _Saturation = 1f;

		[Range(0f, 5f)]
		public float blurSize = 1f;

		[Range(1f, 10f)]
		public int blurIterations = 4;

		private BlurType blurType;

		private Shader fastBloomShader;

		private Material _fastBloomMaterial;

		private float initFOV;

		public bool SceneBloom;

		private static FogVolumeScreen _instance;

		private RenderTexture _source;

		public int screenX => SceneCamera.pixelWidth;

		public int screenY => SceneCamera.pixelHeight;

		public string FogVolumeLayerName
		{
			get
			{
				return _FogVolumeLayerName;
			}
			set
			{
				if (_FogVolumeLayerName != value)
				{
					SetFogVolumeLayer(value);
				}
			}
		}

		private Material BlurMaterial
		{
			get
			{
				if (_BlurMaterial == null)
				{
					_BlurMaterial = new Material(_BlurShader);
					_BlurMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return _BlurMaterial;
			}
		}

		private Material fastBloomMaterial
		{
			get
			{
				if (_fastBloomMaterial == null)
				{
					_fastBloomMaterial = new Material(fastBloomShader);
					_fastBloomMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return _fastBloomMaterial;
			}
		}

		public static FogVolumeScreen instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = UnityEngine.Object.FindObjectOfType<FogVolumeScreen>();
				}
				return _instance;
			}
		}

		private void SetFogVolumeLayer(string NewFogVolumeLayerName)
		{
			_FogVolumeLayerName = NewFogVolumeLayerName;
			FogVolumeLayer = LayerMask.NameToLayer(_FogVolumeLayerName);
		}

		private void OnValidate()
		{
			SetFogVolumeLayer(_FogVolumeLayerName);
		}

		private void CreateUniformFogCamera()
		{
			UniformFogCameraGO = GameObject.Find("Uniform Fog Volume Camera");
			if (UniformFogCameraGO == null)
			{
				UniformFogCameraGO = new GameObject();
				UniformFogCameraGO.name = "Uniform Fog Volume Camera";
				if (UniformFogCamera == null)
				{
					UniformFogCamera = UniformFogCameraGO.AddComponent<Camera>();
				}
				UniformFogCamera.backgroundColor = new Color(0f, 0f, 0f, 0f);
				UniformFogCamera.clearFlags = CameraClearFlags.Color;
				UniformFogCamera.renderingPath = RenderingPath.Forward;
				UniformFogCamera.enabled = false;
				UniformFogCamera.farClipPlane = SceneCamera.farClipPlane;
				UniformFogCamera.GetComponent<Camera>().allowMSAA = false;
			}
			else
			{
				UniformFogCamera = UniformFogCameraGO.GetComponent<Camera>();
			}
			UniformFogCameraGO.hideFlags = HideFlags.HideInHierarchy;
			initFOV = SceneCamera.fieldOfView;
		}

		private void OnEnable()
		{
			SceneCamera = base.gameObject.GetComponent<Camera>();
			_BlurShader = Shader.Find("Hidden/FogVolumeDensityFilter");
			if (_BlurShader == null)
			{
				MonoBehaviour.print("Hidden/FogVolumeDensityFilter #SHADER ERROR#");
			}
			fastBloomShader = Shader.Find("Hidden/FogVolumeBloom");
			if (fastBloomShader == null)
			{
				MonoBehaviour.print("Hidden/FogVolumeBloom #SHADER ERROR#");
			}
			CreateUniformFogCamera();
		}

		protected void OnDisable()
		{
			if ((bool)_BlurMaterial)
			{
				UnityEngine.Object.DestroyImmediate(_BlurMaterial);
			}
			if ((bool)_fastBloomMaterial)
			{
				UnityEngine.Object.DestroyImmediate(_fastBloomMaterial);
			}
			if ((bool)UniformFogCameraGO)
			{
				UnityEngine.Object.DestroyImmediate(UniformFogCameraGO);
			}
		}

		public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
		{
			float num = 0.5f + (float)iteration * blurSpread;
			Graphics.BlitMultiTap(source, dest, BlurMaterial, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void DownSample4x(RenderTexture source, RenderTexture dest)
		{
			float num = 1f;
			Graphics.BlitMultiTap(source, dest, BlurMaterial, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		public RenderTextureFormat GetRTFormat()
		{
			RT_Format = (SceneCamera.allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
			return RT_Format;
		}

		public void ReleaseRT(RenderTexture rt)
		{
			if (rt != null)
			{
				RenderTexture.ReleaseTemporary(rt);
				rt = null;
			}
		}

		public RenderTextureReadWrite GetRTReadWrite()
		{
			if (!SceneCamera.allowHDR)
			{
				return RenderTextureReadWrite.Linear;
			}
			return RenderTextureReadWrite.Default;
		}

		protected void GetRT(ref RenderTexture rt, int2 size, string name)
		{
			ReleaseRT(rt);
			rt = RenderTexture.GetTemporary(size.x, size.y, 0, GetRTFormat(), GetRTReadWrite());
			rt.filterMode = FilterMode.Bilinear;
			rt.name = name;
			rt.wrapMode = TextureWrapMode.Repeat;
		}

		public void ConvolveFogVolume()
		{
			if (UniformFogCameraGO == null)
			{
				CreateUniformFogCamera();
			}
			int2 size = new int2(screenX, screenY);
			UniformFogCamera.projectionMatrix = SceneCamera.projectionMatrix;
			UniformFogCamera.transform.position = SceneCamera.transform.position;
			UniformFogCamera.transform.rotation = SceneCamera.transform.rotation;
			GetRT(ref RT_FogVolumeConvolution, size, "RT_FogVolumeConvolution");
			UniformFogCamera.targetTexture = RT_FogVolumeConvolution;
			UniformFogCamera.Render();
			Shader.SetGlobalTexture("RT_FogVolumeConvolution", RT_FogVolumeConvolution);
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			ConvolveFogVolume();
			GetRT(ref _source, new int2(Screen.width, Screen.height), "_source");
			Graphics.Blit(source, _source);
			fastBloomMaterial.SetTexture("_source", _source);
			BlurMaterial.SetTexture("_source", _source);
			UniformFogCamera.cullingMask = 1 << instance.FogVolumeLayer;
			FOV_compensation = initFOV / SceneCamera.fieldOfView;
			Shader.SetGlobalFloat("FOV_compensation", FOV_compensation);
			fastBloomMaterial.SetFloat("_Falloff", _Falloff);
			RenderTexture renderTexture = RenderTexture.GetTemporary(screenX / Downsample, screenY / Downsample, 0, RT_Format);
			DownSample4x(source, renderTexture);
			for (int i = 0; i < iterations; i++)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(screenX / Downsample, screenY / Downsample, 0, RT_Format);
				FourTapCone(renderTexture, temporary, i);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary;
			}
			if (intensity > 0f)
			{
				Rendering.EnsureKeyword(fastBloomMaterial, "BLOOM", enabled: true);
				float num = 2f / (float)_BloomDowsample;
				fastBloomMaterial.SetFloat("_Saturation", _Saturation);
				fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num, 0f, threshold, intensity));
				int width = source.width / _BloomDowsample;
				int height = source.height / _BloomDowsample;
				RenderTexture renderTexture2 = RenderTexture.GetTemporary(width, height, 0, RT_Format);
				renderTexture2.filterMode = FilterMode.Bilinear;
				if (SceneBloom)
				{
					Graphics.Blit(source, renderTexture2, fastBloomMaterial, 1);
				}
				else
				{
					Graphics.Blit(renderTexture, renderTexture2, fastBloomMaterial, 1);
				}
				int num2 = ((blurType != 0) ? 2 : 0);
				for (int j = 1; j < blurIterations; j++)
				{
					fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num + (float)j * 1f, 0f, threshold, intensity));
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, RT_Format);
					temporary2.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture2, temporary2, fastBloomMaterial, 2 + num2);
					RenderTexture.ReleaseTemporary(renderTexture2);
					renderTexture2 = temporary2;
					temporary2 = RenderTexture.GetTemporary(width, height, 0, RT_Format);
					temporary2.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture2, temporary2, fastBloomMaterial, 3 + num2);
					RenderTexture.ReleaseTemporary(renderTexture2);
					renderTexture2 = temporary2;
				}
				fastBloomMaterial.SetTexture("_Bloom", renderTexture2);
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
			else
			{
				Rendering.EnsureKeyword(fastBloomMaterial, "BLOOM", enabled: false);
			}
			Graphics.Blit(renderTexture, destination, fastBloomMaterial, 0);
			RenderTexture.ReleaseTemporary(renderTexture);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera), typeof(FrustumJitter), typeof(VelocityBuffer))]
	public class FogVolumeTAA : EffectBase
	{
		public enum Neighborhood
		{
			MinMax3x3,
			MinMax3x3Rounded,
			MinMax4TapVarying
		}

		private static RenderBuffer[] mrt = new RenderBuffer[2];

		private Camera _FogVolumeCamera;

		private FrustumJitter _frustumJitter;

		private VelocityBuffer _velocityBuffer;

		public Shader reprojectionShader;

		private Material reprojectionMaterial;

		private RenderTexture[,] reprojectionBuffer;

		private int[] reprojectionIndex = new int[2] { -1, -1 };

		public Neighborhood neighborhood = Neighborhood.MinMax4TapVarying;

		public bool unjitterColorSamples = true;

		public bool unjitterNeighborhood = true;

		public bool unjitterReprojection = true;

		public bool useYCoCg = true;

		public bool useClipping = true;

		public bool useDilation;

		public bool useMotionBlur;

		public bool useOptimizations;

		[Range(0f, 1f)]
		public float feedbackMin = 0.88f;

		[Range(0f, 1f)]
		public float feedbackMax = 0.97f;

		public float motionBlurStrength = 1f;

		public bool motionBlurIgnoreFF;

		private void Reset()
		{
			_FogVolumeCamera = GetComponent<Camera>();
			reprojectionShader = Shader.Find("Hidden/TAA");
			_FogVolumeCamera = GetComponent<Camera>();
			_frustumJitter = GetComponent<FrustumJitter>();
			_velocityBuffer = GetComponent<VelocityBuffer>();
			_velocityBuffer.velocityShader = Shader.Find("Hidden/VelocityBuffer");
		}

		private void Clear()
		{
			EnsureArray(ref reprojectionIndex, 2, 0);
			reprojectionIndex[0] = -1;
			reprojectionIndex[1] = -1;
		}

		private void Awake()
		{
			Reset();
			Clear();
		}

		private void Resolve(RenderTexture source, RenderTexture destination)
		{
			_velocityBuffer.GenerateVelocityBuffer();
			EnsureArray(ref reprojectionBuffer, 2, 2);
			EnsureArray(ref reprojectionIndex, 2, -1);
			EnsureMaterial(ref reprojectionMaterial, reprojectionShader);
			if (reprojectionMaterial == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			int num = ((_FogVolumeCamera.stereoActiveEye == Camera.MonoOrStereoscopicEye.Right) ? 1 : 0);
			int width = source.width;
			int height = source.height;
			if (EnsureRenderTarget(ref reprojectionBuffer[num, 0], width, height, source.format, FilterMode.Bilinear, 0, source.antiAliasing))
			{
				Clear();
			}
			if (EnsureRenderTarget(ref reprojectionBuffer[num, 1], width, height, source.format, FilterMode.Bilinear, 0, source.antiAliasing))
			{
				Clear();
			}
			bool flag = !_FogVolumeCamera.stereoEnabled;
			EnsureKeyword(reprojectionMaterial, "CAMERA_PERSPECTIVE", !_FogVolumeCamera.orthographic);
			EnsureKeyword(reprojectionMaterial, "CAMERA_ORTHOGRAPHIC", _FogVolumeCamera.orthographic);
			EnsureKeyword(reprojectionMaterial, "MINMAX_3X3", neighborhood == Neighborhood.MinMax3x3);
			EnsureKeyword(reprojectionMaterial, "MINMAX_3X3_ROUNDED", neighborhood == Neighborhood.MinMax3x3Rounded);
			EnsureKeyword(reprojectionMaterial, "MINMAX_4TAP_VARYING", neighborhood == Neighborhood.MinMax4TapVarying);
			EnsureKeyword(reprojectionMaterial, "UNJITTER_COLORSAMPLES", unjitterColorSamples);
			EnsureKeyword(reprojectionMaterial, "UNJITTER_NEIGHBORHOOD", unjitterNeighborhood);
			EnsureKeyword(reprojectionMaterial, "UNJITTER_REPROJECTION", unjitterReprojection);
			EnsureKeyword(reprojectionMaterial, "USE_YCOCG", useYCoCg);
			EnsureKeyword(reprojectionMaterial, "USE_CLIPPING", useClipping);
			EnsureKeyword(reprojectionMaterial, "USE_DILATION", useDilation);
			EnsureKeyword(reprojectionMaterial, "USE_MOTION_BLUR", useMotionBlur && flag);
			EnsureKeyword(reprojectionMaterial, "USE_MOTION_BLUR_NEIGHBORMAX", _velocityBuffer.activeVelocityNeighborMax != null);
			EnsureKeyword(reprojectionMaterial, "USE_OPTIMIZATIONS", useOptimizations);
			if (reprojectionIndex[num] == -1)
			{
				reprojectionIndex[num] = 0;
				reprojectionBuffer[num, reprojectionIndex[num]].DiscardContents();
				Graphics.Blit(source, reprojectionBuffer[num, reprojectionIndex[num]]);
			}
			int num2 = reprojectionIndex[num];
			int num3 = (reprojectionIndex[num] + 1) % 2;
			Vector4 activeSample = _frustumJitter.activeSample;
			activeSample.x /= width;
			activeSample.y /= height;
			activeSample.z /= width;
			activeSample.w /= height;
			reprojectionMaterial.SetVector("_JitterUV", activeSample);
			reprojectionMaterial.SetTexture("_VelocityBuffer", _velocityBuffer.activeVelocityBuffer);
			reprojectionMaterial.SetTexture("_VelocityNeighborMax", _velocityBuffer.activeVelocityNeighborMax);
			reprojectionMaterial.SetTexture("_MainTex", source);
			reprojectionMaterial.SetTexture("_PrevTex", reprojectionBuffer[num, num2]);
			reprojectionMaterial.SetFloat("_FeedbackMin", feedbackMin);
			reprojectionMaterial.SetFloat("_FeedbackMax", feedbackMax);
			mrt[0] = reprojectionBuffer[num, num3].colorBuffer;
			mrt[1] = destination.colorBuffer;
			Graphics.SetRenderTarget(mrt, source.depthBuffer);
			reprojectionMaterial.SetPass(0);
			reprojectionBuffer[num, num3].DiscardContents();
			DrawFullscreenQuad();
			reprojectionIndex[num] = num3;
		}

		public void TAA(ref RenderTexture source)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
			Resolve(source, temporary);
			Graphics.Blit(temporary, source);
			RenderTexture.ReleaseTemporary(temporary);
		}

		private void OnDisable()
		{
			if (reprojectionBuffer != null)
			{
				ReleaseRenderTarget(ref reprojectionBuffer[0, 0]);
				ReleaseRenderTarget(ref reprojectionBuffer[0, 1]);
				ReleaseRenderTarget(ref reprojectionBuffer[1, 0]);
				ReleaseRenderTarget(ref reprojectionBuffer[1, 1]);
			}
		}
	}
	[ExecuteInEditMode]
	public class ColorAnimation : MonoBehaviour
	{
		private float X;

		private float Y;

		private float Z;

		[Range(0f, 10f)]
		public float _ColorSpeed = 6f;

		private float ColorSpeed;

		private Vector3 RandomRangeXYZ;

		[SerializeField]
		[Range(1f, 300f)]
		private float Intensity = 8f;

		private void OnEnable()
		{
			RandomRangeXYZ.x = UnityEngine.Random.Range(0f, 1f);
			RandomRangeXYZ.y = UnityEngine.Random.Range(0f, 1f);
			RandomRangeXYZ.z = UnityEngine.Random.Range(0f, 1f);
		}

		private void Update()
		{
			ColorSpeed += Time.deltaTime * _ColorSpeed;
			X = Mathf.Sin(ColorSpeed * RandomRangeXYZ.x) * 0.5f + 0.5f;
			Y = Mathf.Sin(ColorSpeed * RandomRangeXYZ.y) * 0.5f + 0.5f;
			Z = Mathf.Sin(ColorSpeed * RandomRangeXYZ.z) * 0.5f + 0.5f;
			float num = Mathf.Sin(ColorSpeed * RandomRangeXYZ.z) * 0.5f + 0.5f;
			Color color = new Color(X, Y, Z, 1f);
			GetComponent<Renderer>().sharedMaterial.SetColor("_EmissionColor", num * Intensity * color);
		}
	}
	[ExecuteInEditMode]
	public class EnableDepthInForwardCamera : MonoBehaviour
	{
		public string Message = "Add this script to generate depth if Fog Volume rendered is not used and rendering path is forward";

		private void OnEnable()
		{
		}

		private void Update()
		{
			if (GetComponent<Camera>().depthTextureMode != DepthTextureMode.Depth)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
		}
	}
	public class ExplorationCamera : MonoBehaviour
	{
		[Range(1f, 50f)]
		public float sensitivity = 30f;

		[Range(0.1f, 50f)]
		public float smoothing = 5f;

		private float speedZ;

		private float speedX;

		private float speedY;

		[Range(0.1f, 10f)]
		public float Speed = 0.1f;

		[HideInInspector]
		public float InitialSpeed = 0.1f;

		[HideInInspector]
		public float FOV;

		private float initialFOV;

		private Vector2 initialLook;

		private Vector2 Look;

		private Vector3 MovementDirection;

		public float MaxAcceleration = 4f;

		[Range(1f, 10f)]
		public float AccelerationSmoothing = 10f;

		[Range(1f, 10f)]
		public float SpeedSmooth = 1f;

		private Vector2 _smoothMouse;

		public bool HideCursor;

		private float focalLength;

		private float focalSize = 1f;

		public bool ConstantMove;

		private Camera ThisCamera;

		[HideInInspector]
		public float tilt;

		private Vector2 lastPos;

		public float tiltSmoothing = 50f;

		public float FOVTransitionSpeed = 0.1f;

		public float inclination = 13f;

		public bool ApplyGravity;

		[Range(0f, 1f)]
		public float gravityAccelerationScale = 0.1f;

		private float TriggerValue;

		private void Start()
		{
			try
			{
				Input.GetAxis("LookHorizontal");
			}
			catch
			{
				MonoBehaviour.print("Import the custom input to support gamepad in this camera script\n http://davidmiranda.me/files/FogVolume3/InputManager.asset");
			}
		}

		private void OnGUI()
		{
			if (Event.current.type == EventType.MouseDown)
			{
				lastPos = Event.current.mousePosition;
			}
			else if (Event.current.type == EventType.MouseDrag || Event.current.type == EventType.MouseMove)
			{
				Vector3 vector = Event.current.mousePosition - lastPos;
				Look += new Vector2(vector.x * sensitivity / 50f, (0f - vector.y) * sensitivity / 50f);
				lastPos = Event.current.mousePosition;
			}
		}

		private void OnDestroy()
		{
			Cursor.visible = true;
		}

		private void FixedUpdate()
		{
			try
			{
				if (Mathf.Abs(Input.GetAxis("LookHorizontal")) > 0.017f || Mathf.Abs(Input.GetAxis("LookVertical")) > 0.017f)
				{
					Look += new Vector2(Input.GetAxis("LookHorizontal"), 0f - Input.GetAxis("LookVertical")) * sensitivity;
					if (Input.GetAxis("LookHorizontal") > 0f)
					{
						tilt = Mathf.Lerp(tilt, (0f - inclination) * Mathf.Abs(Input.GetAxis("LookHorizontal")) * sensitivity, 1f / tiltSmoothing);
					}
					else
					{
						tilt = Mathf.Lerp(tilt, inclination * Mathf.Abs(Input.GetAxis("LookHorizontal")) * sensitivity, 1f / tiltSmoothing);
					}
				}
			}
			catch
			{
			}
			tilt = Mathf.Lerp(tilt, 0f, 1f / tiltSmoothing);
			if (Input.GetKey(KeyCode.PageDown))
			{
				focalLength -= 0.05f;
			}
			if (Input.GetKey(KeyCode.PageUp))
			{
				focalLength += 0.05f;
			}
			if (Input.GetKey(KeyCode.End))
			{
				focalSize -= 0.05f;
			}
			if (Input.GetKey(KeyCode.Home))
			{
				focalSize += 0.05f;
			}
			_smoothMouse.x = Mathf.Lerp(_smoothMouse.x, Look.x, 1f / smoothing);
			_smoothMouse.y = Mathf.Lerp(_smoothMouse.y, Look.y, 1f / smoothing);
			base.transform.localEulerAngles = new Vector3(0f - _smoothMouse.y, _smoothMouse.x, tilt);
			if (Input.GetKey(KeyCode.W) || Input.GetAxis("Vertical") > 0f || ConstantMove)
			{
				MovementDirection = new Vector3(0f, 0f, 1f);
				speedZ = Mathf.Lerp(speedZ, Speed, 1f / smoothing);
			}
			if (Input.GetKey(KeyCode.S) || Input.GetAxis("Vertical") < 0f)
			{
				MovementDirection = new Vector3(0f, 0f, -1f);
				speedZ = Mathf.Lerp(speedZ, 0f - Speed, 1f / smoothing);
			}
			if (Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f)
			{
				MovementDirection = new Vector3(-1f, 0f, 0f);
				speedX = Mathf.Lerp(speedX, 0f - Speed, 1f / smoothing);
			}
			if (Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f)
			{
				MovementDirection = new Vector3(1f, 0f, 0f);
				speedX = Mathf.Lerp(speedX, Speed, 1f / smoothing);
			}
			if (Input.GetKey(KeyCode.Q) || Input.GetKey(KeyCode.JoystickButton4))
			{
				MovementDirection = new Vector3(0f, -1f, 0f);
				speedY = Mathf.Lerp(speedY, 0f - Speed, 1f / smoothing);
			}
			if (Input.GetKey(KeyCode.E) || Input.GetKey(KeyCode.JoystickButton5))
			{
				MovementDirection = new Vector3(0f, 1f, 0f);
				speedY = Mathf.Lerp(speedY, Speed, 1f / smoothing);
			}
			speedZ = Mathf.Lerp(speedZ, 0f, 1f / smoothing);
			MovementDirection.z = speedZ;
			speedY = Mathf.Lerp(speedY, 0f, 1f / smoothing);
			MovementDirection.y = speedY;
			speedX = Mathf.Lerp(speedX, 0f, 1f / smoothing);
			MovementDirection = new Vector3(speedX, speedY, speedZ);
			if (ApplyGravity)
			{
				MovementDirection += Physics.gravity * gravityAccelerationScale;
			}
			base.transform.Translate(MovementDirection);
			Speed = Mathf.Clamp(Speed, 0.001f, 100f);
			if (Input.GetMouseButton(1))
			{
				InitialSpeed += Input.GetAxis("Mouse ScrollWheel") * 0.5f;
				InitialSpeed = Mathf.Max(0.1f, InitialSpeed);
			}
			if (Input.GetMouseButton(1) & Input.GetKey(KeyCode.C) & (FOV > 5f))
			{
				FOV -= 1f;
			}
			if (Input.GetMouseButton(1) & Input.GetKey(KeyCode.Z) & (FOV < 120f))
			{
				FOV += 1f;
			}
			if (!Input.GetMouseButton(1))
			{
				FOV = Mathf.Lerp(FOV, initialFOV, FOVTransitionSpeed);
			}
			if ((bool)ThisCamera && !ThisCamera.stereoEnabled)
			{
				GetComponent<Camera>().fieldOfView = FOV;
			}
		}

		private void Update()
		{
			try
			{
				TriggerValue = Mathf.Pow(Input.GetAxis("FasterCamera") * 1f / AccelerationSmoothing + 1f, 2f);
			}
			catch
			{
			}
			if (Input.GetKeyDown(KeyCode.LeftShift))
			{
				Speed *= MaxAcceleration;
			}
			try
			{
				if (Input.GetAxis("FasterCamera") > 0f && Speed < InitialSpeed * MaxAcceleration)
				{
					Speed *= TriggerValue;
				}
				else if (!Input.GetKey(KeyCode.LeftShift))
				{
					Speed = Mathf.Lerp(Speed, InitialSpeed, 1f / AccelerationSmoothing);
				}
			}
			catch
			{
				if (!Input.GetKey(KeyCode.LeftShift))
				{
					Speed = Mathf.Lerp(Speed, InitialSpeed, 1f / AccelerationSmoothing);
				}
			}
			if (Input.GetKeyUp(KeyCode.LeftShift))
			{
				Speed /= MaxAcceleration;
			}
		}

		private void OnEnable()
		{
			if ((bool)GetComponent<Camera>())
			{
				ThisCamera = GetComponent<Camera>();
			}
			InitialSpeed = Speed;
			if (HideCursor)
			{
				Cursor.visible = false;
			}
			if ((bool)ThisCamera)
			{
				FOV = base.gameObject.GetComponent<Camera>().fieldOfView;
			}
			initialFOV = FOV;
			initialLook = new Vector2(base.transform.eulerAngles.y, base.transform.eulerAngles.x * -1f);
			Look = initialLook;
			_smoothMouse = initialLook;
		}
	}
	[ExecuteInEditMode]
	public class FogVolumePriority : MonoBehaviour
	{
		public Camera GameCamera;

		public int FogOrderCameraAbove = 1;

		public int FogOrderCameraBelow = -1;

		public float HeightThreshold = 30f;

		public FogVolume thisFog;

		private FogVolumeData _FogVolumeData;

		public float CurrentHeight;

		public GameObject Horizon;

		private void OnEnable()
		{
			thisFog = GetComponent<FogVolume>();
			_FogVolumeData = thisFog._FogVolumeData;
		}

		private void Update()
		{
			if ((bool)Horizon)
			{
				HeightThreshold = Horizon.transform.position.y;
			}
			if ((bool)_FogVolumeData)
			{
				GameCamera = _FogVolumeData.GameCamera;
			}
			else
			{
				GameCamera = Camera.main;
			}
			if (!GameCamera)
			{
				return;
			}
			if (!Application.isPlaying)
			{
				if (Camera.current != null)
				{
					CurrentHeight = Camera.current.gameObject.transform.position.y;
				}
			}
			else
			{
				CurrentHeight = GameCamera.gameObject.transform.position.y;
			}
			if (HeightThreshold > CurrentHeight && Horizon != null)
			{
				thisFog.DrawOrder = FogOrderCameraBelow;
			}
			else
			{
				thisFog.DrawOrder = FogOrderCameraAbove;
			}
		}
	}
	[ExecuteInEditMode]
	public class ToggleChildren : MonoBehaviour
	{
		public KeyCode Key = KeyCode.F;

		private GameObject[] Children;

		private bool active = true;

		private void OnEnable()
		{
			Children = new GameObject[base.gameObject.transform.childCount];
			for (int i = 0; i < base.gameObject.transform.childCount; i++)
			{
				Children[i] = base.gameObject.transform.GetChild(i).gameObject;
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(Key))
			{
				active = !active;
				for (int i = 0; i < base.gameObject.transform.childCount; i++)
				{
					Children[i].SetActive(active);
				}
			}
		}
	}
	[ExecuteInEditMode]
	public class ShadowCamera : MonoBehaviour
	{
		[Serializable]
		public enum TextureSize
		{
			_64 = 0x40,
			_128 = 0x80,
			_256 = 0x100,
			_512 = 0x200,
			_1024 = 0x400
		}

		private Camera ThisCamera;

		private GameObject Dad;

		private FogVolume Fog;

		public RenderTexture RT_Opacity;

		public RenderTexture RT_OpacityBlur;

		public RenderTexture RT_PostProcess;

		public TextureSize textureSize = TextureSize._128;

		[Range(0f, 10f)]
		public int iterations = 3;

		[Range(0f, 1f)]
		public float blurSpread = 0.6f;

		public int Downsampling;

		private Shader blurShader;

		private Shader PostProcessShader;

		private Material blurMaterial;

		private Material postProcessMaterial;

		public TextureSize SetTextureSize
		{
			get
			{
				return textureSize;
			}
			set
			{
				if (value != textureSize)
				{
					SetQuality(value);
				}
			}
		}

		protected Material BlurMaterial
		{
			get
			{
				if (blurMaterial == null)
				{
					blurMaterial = new Material(blurShader);
					blurMaterial.hideFlags = HideFlags.DontSave;
				}
				return blurMaterial;
			}
		}

		protected Material PostProcessMaterial
		{
			get
			{
				if (postProcessMaterial == null)
				{
					postProcessMaterial = new Material(PostProcessShader);
					postProcessMaterial.hideFlags = HideFlags.DontSave;
				}
				return postProcessMaterial;
			}
		}

		public RenderTexture GetOpacityRT()
		{
			return RT_Opacity;
		}

		public RenderTexture GetOpacityBlurRT()
		{
			return RT_OpacityBlur;
		}

		private void SetQuality(TextureSize value)
		{
			textureSize = value;
		}

		protected void GetRT(ref RenderTexture rt, int size, string name)
		{
			ReleaseRT(rt);
			rt = RenderTexture.GetTemporary(size, size, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
			rt.filterMode = FilterMode.Bilinear;
			rt.name = name;
			rt.wrapMode = TextureWrapMode.Repeat;
		}

		public void ReleaseRT(RenderTexture rt)
		{
			if (rt != null)
			{
				RenderTexture.ReleaseTemporary(rt);
				rt = null;
			}
		}

		public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
		{
			float num = 0.5f + (float)iteration * blurSpread;
			Graphics.BlitMultiTap(source, dest, BlurMaterial, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void DownSample(RenderTexture source, RenderTexture dest)
		{
			float num = 1f;
			Graphics.BlitMultiTap(source, dest, BlurMaterial, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
		}

		private void Blur(RenderTexture Input, int BlurRTSize)
		{
			RenderTexture rt = null;
			GetRT(ref RT_OpacityBlur, BlurRTSize, "Shadow blurred");
			GetRT(ref rt, BlurRTSize, "Shadow blurred");
			DownSample(Input, RT_OpacityBlur);
			for (int i = 0; i < iterations; i++)
			{
				FourTapCone(RT_OpacityBlur, rt, i);
				ExtensionMethods.Swap(ref RT_OpacityBlur, ref rt);
			}
			Shader.SetGlobalTexture("RT_OpacityBlur", RT_OpacityBlur);
			Fog.RT_OpacityBlur = RT_OpacityBlur;
		}

		private void RenderShadowMap()
		{
			Fog.FogVolumeShader.maximumLOD = 100;
			SetQuality(textureSize);
			GetRT(ref RT_Opacity, (int)textureSize, "Opacity");
			ThisCamera.targetTexture = RT_Opacity;
			ThisCamera.Render();
			Fog.RT_Opacity = RT_Opacity;
			if (RT_Opacity != null)
			{
				GetRT(ref RT_PostProcess, (int)textureSize, "Shadow PostProcess");
				PostProcessMaterial.SetFloat("ShadowColor", Fog.ShadowColor.a);
				Graphics.Blit(RT_Opacity, RT_PostProcess, PostProcessMaterial);
				Graphics.Blit(RT_PostProcess, RT_Opacity);
				if (iterations > 0)
				{
					Blur(RT_Opacity, (int)textureSize >> Downsampling);
				}
				else
				{
					Shader.SetGlobalTexture("RT_OpacityBlur", RT_Opacity);
					Fog.RT_OpacityBlur = RT_Opacity;
				}
				Fog.RT_Opacity = RT_Opacity;
			}
			BlurMaterial.SetFloat("ShadowColor", Fog.ShadowColor.a);
			Fog.FogVolumeShader.maximumLOD = 600;
		}

		private void ShaderLoad()
		{
			blurShader = Shader.Find("Hidden/Fog Volume/BlurEffectConeTap");
			if (blurShader == null)
			{
				MonoBehaviour.print("Hidden / Fog Volume / BlurEffectConeTap #SHADER ERROR#");
			}
			PostProcessShader = Shader.Find("Hidden/Fog Volume/Shadow Postprocess");
			if (PostProcessShader == null)
			{
				MonoBehaviour.print("Hidden/Fog Volume/Shadow Postprocess #SHADER ERROR#");
			}
		}

		private void OnEnable()
		{
			ShaderLoad();
			Dad = base.transform.parent.gameObject;
			Fog = Dad.GetComponent<FogVolume>();
			ThisCamera = base.gameObject.GetComponent<Camera>();
			ThisCamera.depthTextureMode = DepthTextureMode.Depth;
			CameraTransform();
		}

		public void CameraTransform()
		{
			if (ThisCamera != null)
			{
				ThisCamera.orthographicSize = Dad.GetComponent<FogVolume>().fogVolumeScale.x / 2f;
				ThisCamera.transform.position = Dad.transform.position;
				ThisCamera.farClipPlane = Fog.fogVolumeScale.y + (float)Fog.shadowCameraPosition;
				Vector3 translation = new Vector3(0f, 0f, Fog.fogVolumeScale.y / 2f - (float)Fog.shadowCameraPosition);
				ThisCamera.transform.Translate(translation, Space.Self);
				Quaternion quaternion = Quaternion.Euler(90f, 0f, 0f);
				ThisCamera.transform.rotation = Dad.transform.rotation * quaternion;
				ThisCamera.enabled = false;
				if (Fog.SunAttached)
				{
					Fog.Sun.transform.rotation = Dad.transform.rotation * quaternion;
				}
			}
		}

		private void Update()
		{
			if (Fog.IsVisible && Fog.CastShadows)
			{
				if (ExtensionMethods.TimeSnap(Fog.ShadowCameraSkippedFrames))
				{
					RenderShadowMap();
				}
				CameraTransform();
			}
		}

		private void SafeDestroy(UnityEngine.Object obj)
		{
			obj = null;
			UnityEngine.Object.DestroyImmediate(obj);
		}

		private void OnDisable()
		{
			RenderTexture.active = null;
			ThisCamera.targetTexture = null;
			if ((bool)RT_Opacity)
			{
				SafeDestroy(RT_Opacity);
			}
			if ((bool)RT_OpacityBlur)
			{
				SafeDestroy(RT_OpacityBlur);
			}
			if ((bool)RT_PostProcess)
			{
				SafeDestroy(RT_PostProcess);
			}
			if ((bool)blurMaterial)
			{
				SafeDestroy(blurMaterial);
			}
			if ((bool)postProcessMaterial)
			{
				SafeDestroy(postProcessMaterial);
			}
		}
	}
	public class HittedObject : MonoBehaviour
	{
		public float startHealth = 100f;

		private float health;

		public Image healthBar;

		private void Start()
		{
			health = startHealth;
		}

		private void Update()
		{
		}

		public void TakeDamage(float amount)
		{
			health -= amount;
			healthBar.fillAmount = health / startHealth;
			if (health <= 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class Hovl_DemoLasers : MonoBehaviour
	{
		public GameObject FirePoint;

		public Camera Cam;

		public float MaxLength;

		public GameObject[] Prefabs;

		private Ray RayMouse;

		private Vector3 direction;

		private Quaternion rotation;

		[Header("GUI")]
		private float windowDpi;

		private int Prefab;

		private GameObject Instance;

		private Hovl_Laser LaserScript;

		private Hovl_Laser2 LaserScript2;

		private float buttonSaver;

		private void Start()
		{
			if (Screen.dpi < 1f)
			{
				windowDpi = 1f;
			}
			if (Screen.dpi < 200f)
			{
				windowDpi = 1f;
			}
			else
			{
				windowDpi = Screen.dpi / 200f;
			}
			Counter(0);
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				UnityEngine.Object.Destroy(Instance);
				Instance = UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
				Instance.transform.parent = base.transform;
				LaserScript = Instance.GetComponent<Hovl_Laser>();
				LaserScript2 = Instance.GetComponent<Hovl_Laser2>();
			}
			if (Input.GetMouseButtonUp(0))
			{
				if ((bool)LaserScript)
				{
					LaserScript.DisablePrepare();
				}
				if ((bool)LaserScript2)
				{
					LaserScript2.DisablePrepare();
				}
				UnityEngine.Object.Destroy(Instance, 1f);
			}
			if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
			{
				buttonSaver = 0f;
				Counter(-1);
			}
			if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
			{
				buttonSaver = 0f;
				Counter(1);
			}
			buttonSaver += Time.deltaTime;
			if (Cam != null)
			{
				Vector3 mousePosition = Input.mousePosition;
				RayMouse = Cam.ScreenPointToRay(mousePosition);
				if (Physics.Raycast(RayMouse.origin, RayMouse.direction, out var hitInfo, MaxLength))
				{
					RotateToMouseDirection(base.gameObject, hitInfo.point);
					return;
				}
				Vector3 point = RayMouse.GetPoint(MaxLength);
				RotateToMouseDirection(base.gameObject, point);
			}
			else
			{
				UnityEngine.Debug.Log("No camera");
			}
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change lazers!");
			GUI.Label(new Rect(10f * windowDpi, 20f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button for shooting!");
		}

		private void Counter(int count)
		{
			Prefab += count;
			if (Prefab > Prefabs.Length - 1)
			{
				Prefab = 0;
			}
			else if (Prefab < 0)
			{
				Prefab = Prefabs.Length - 1;
			}
		}

		private void RotateToMouseDirection(GameObject obj, Vector3 destination)
		{
			direction = destination - obj.transform.position;
			rotation = Quaternion.LookRotation(direction);
			obj.transform.localRotation = Quaternion.Lerp(obj.transform.rotation, rotation, 1f);
		}
	}
	public class Hovl_Laser : MonoBehaviour
	{
		public int damageOverTime = 30;

		public GameObject HitEffect;

		public float HitOffset;

		public bool useLaserRotation;

		public float MaxLength;

		private LineRenderer Laser;

		public float MainTextureLength = 1f;

		public float NoiseTextureLength = 1f;

		private Vector4 Length = new Vector4(1f, 1f, 1f, 1f);

		private bool LaserSaver;

		private bool UpdateSaver;

		private ParticleSystem[] Effects;

		private ParticleSystem[] Hit;

		private void Start()
		{
			Laser = GetComponent<LineRenderer>();
			Effects = GetComponentsInChildren<ParticleSystem>();
			Hit = HitEffect.GetComponentsInChildren<ParticleSystem>();
		}

		private void Update()
		{
			Laser.material.SetTextureScale("_MainTex", new Vector2(Length[0], Length[1]));
			Laser.material.SetTextureScale("_Noise", new Vector2(Length[2], Length[3]));
			if (!(Laser != null) || UpdateSaver)
			{
				return;
			}
			Laser.SetPosition(0, base.transform.position);
			if (Physics.Raycast(base.transform.position, base.transform.TransformDirection(Vector3.forward), out var hitInfo, MaxLength))
			{
				Laser.SetPosition(1, hitInfo.point);
				HitEffect.transform.position = hitInfo.point + hitInfo.normal * HitOffset;
				if (useLaserRotation)
				{
					HitEffect.transform.rotation = base.transform.rotation;
				}
				else
				{
					HitEffect.transform.LookAt(hitInfo.point + hitInfo.normal);
				}
				ParticleSystem[] effects = Effects;
				foreach (ParticleSystem particleSystem in effects)
				{
					if (!particleSystem.isPlaying)
					{
						particleSystem.Play();
					}
				}
				Length[0] = MainTextureLength * Vector3.Distance(base.transform.position, hitInfo.point);
				Length[2] = NoiseTextureLength * Vector3.Distance(base.transform.position, hitInfo.point);
			}
			else
			{
				Vector3 vector = base.transform.position + base.transform.forward * MaxLength;
				Laser.SetPosition(1, vector);
				HitEffect.transform.position = vector;
				ParticleSystem[] effects = Hit;
				foreach (ParticleSystem particleSystem2 in effects)
				{
					if (particleSystem2.isPlaying)
					{
						particleSystem2.Stop();
					}
				}
				Length[0] = MainTextureLength * Vector3.Distance(base.transform.position, vector);
				Length[2] = NoiseTextureLength * Vector3.Distance(base.transform.position, vector);
			}
			if (!Laser.enabled && !LaserSaver)
			{
				LaserSaver = true;
				Laser.enabled = true;
			}
		}

		public void DisablePrepare()
		{
			if (Laser != null)
			{
				Laser.enabled = false;
			}
			UpdateSaver = true;
			if (Effects == null)
			{
				return;
			}
			ParticleSystem[] effects = Effects;
			foreach (ParticleSystem particleSystem in effects)
			{
				if (particleSystem.isPlaying)
				{
					particleSystem.Stop();
				}
			}
		}
	}
	public class Hovl_Laser2 : MonoBehaviour
	{
		public float laserScale = 1f;

		public Color laserColor = new Vector4(1f, 1f, 1f, 1f);

		public GameObject HitEffect;

		public GameObject FlashEffect;

		public float HitOffset;

		public float MaxLength;

		private bool UpdateSaver;

		private ParticleSystem laserPS;

		private ParticleSystem[] Flash;

		private ParticleSystem[] Hit;

		private Material laserMat;

		private int particleCount;

		private ParticleSystem.Particle[] particles;

		private Vector3[] particlesPositions;

		private float dissovleTimer;

		private bool startDissovle;

		private void Start()
		{
			laserPS = GetComponent<ParticleSystem>();
			laserMat = GetComponent<ParticleSystemRenderer>().material;
			Flash = FlashEffect.GetComponentsInChildren<ParticleSystem>();
			Hit = HitEffect.GetComponentsInChildren<ParticleSystem>();
			laserMat.SetFloat("_Scale", laserScale);
		}

		private void Update()
		{
			if (laserPS != null && !UpdateSaver)
			{
				laserMat.SetVector("_StartPoint", base.transform.position);
				if (Physics.Raycast(base.transform.position, base.transform.TransformDirection(Vector3.forward), out var hitInfo, MaxLength))
				{
					particleCount = Mathf.RoundToInt(hitInfo.distance / (2f * laserScale));
					if ((float)particleCount < hitInfo.distance / (2f * laserScale))
					{
						particleCount++;
					}
					particlesPositions = new Vector3[particleCount];
					AddParticles();
					laserMat.SetFloat("_Distance", hitInfo.distance);
					laserMat.SetVector("_EndPoint", hitInfo.point);
					if (Hit != null)
					{
						HitEffect.transform.position = hitInfo.point + hitInfo.normal * HitOffset;
						HitEffect.transform.LookAt(hitInfo.point);
						ParticleSystem[] hit = Hit;
						foreach (ParticleSystem particleSystem in hit)
						{
							if (!particleSystem.isPlaying)
							{
								particleSystem.Play();
							}
						}
						hit = Flash;
						foreach (ParticleSystem particleSystem2 in hit)
						{
							if (!particleSystem2.isPlaying)
							{
								particleSystem2.Play();
							}
						}
					}
				}
				else
				{
					Vector3 vector = base.transform.position + base.transform.forward * MaxLength;
					float num = Vector3.Distance(vector, base.transform.position);
					particleCount = Mathf.RoundToInt(num / (2f * laserScale));
					if ((float)particleCount < num / (2f * laserScale))
					{
						particleCount++;
					}
					particlesPositions = new Vector3[particleCount];
					AddParticles();
					laserMat.SetFloat("_Distance", num);
					laserMat.SetVector("_EndPoint", vector);
					if (Hit != null)
					{
						HitEffect.transform.position = vector;
						ParticleSystem[] hit = Hit;
						foreach (ParticleSystem particleSystem3 in hit)
						{
							if (particleSystem3.isPlaying)
							{
								particleSystem3.Stop();
							}
						}
					}
				}
			}
			if (startDissovle)
			{
				dissovleTimer += Time.deltaTime;
				laserMat.SetFloat("_Dissolve", dissovleTimer * 5f);
			}
		}

		private void AddParticles()
		{
			particles = new ParticleSystem.Particle[particleCount];
			for (int i = 0; i < particleCount; i++)
			{
				particlesPositions[i] = new Vector3(0f, 0f, 0f) + new Vector3(0f, 0f, (float)(i * 2) * laserScale);
				particles[i].position = particlesPositions[i];
				particles[i].startSize3D = new Vector3(0.001f, 0.001f, 2f * laserScale);
				particles[i].startColor = laserColor;
			}
			laserPS.SetParticles(particles, particles.Length);
		}

		public void DisablePrepare()
		{
			base.transform.parent = null;
			dissovleTimer = 0f;
			startDissovle = true;
			UpdateSaver = true;
			if (Flash == null || Hit == null)
			{
				return;
			}
			ParticleSystem[] hit = Hit;
			foreach (ParticleSystem particleSystem in hit)
			{
				if (particleSystem.isPlaying)
				{
					particleSystem.Stop();
				}
			}
			hit = Flash;
			foreach (ParticleSystem particleSystem2 in hit)
			{
				if (particleSystem2.isPlaying)
				{
					particleSystem2.Stop();
				}
			}
		}
	}
	public class Hovl_LaserDemo : MonoBehaviour
	{
		public int damageOverTime = 30;

		public GameObject HitEffect;

		public float HitOffset;

		public bool useLaserRotation;

		public float MaxLength;

		private LineRenderer Laser;

		public float MainTextureLength = 1f;

		public float NoiseTextureLength = 1f;

		private Vector4 Length = new Vector4(1f, 1f, 1f, 1f);

		private bool LaserSaver;

		private bool UpdateSaver;

		private ParticleSystem[] Effects;

		private ParticleSystem[] Hit;

		private void Start()
		{
			Laser = GetComponent<LineRenderer>();
			Effects = GetComponentsInChildren<ParticleSystem>();
			Hit = HitEffect.GetComponentsInChildren<ParticleSystem>();
		}

		private void Update()
		{
			Laser.material.SetTextureScale("_MainTex", new Vector2(Length[0], Length[1]));
			Laser.material.SetTextureScale("_Noise", new Vector2(Length[2], Length[3]));
			if (!(Laser != null) || UpdateSaver)
			{
				return;
			}
			Laser.SetPosition(0, base.transform.position);
			if (Physics.Raycast(base.transform.position, base.transform.TransformDirection(Vector3.forward), out var hitInfo, MaxLength))
			{
				Laser.SetPosition(1, hitInfo.point);
				HitEffect.transform.position = hitInfo.point + hitInfo.normal * HitOffset;
				if (useLaserRotation)
				{
					HitEffect.transform.rotation = base.transform.rotation;
				}
				else
				{
					HitEffect.transform.LookAt(hitInfo.point + hitInfo.normal);
				}
				ParticleSystem[] effects = Effects;
				foreach (ParticleSystem particleSystem in effects)
				{
					if (!particleSystem.isPlaying)
					{
						particleSystem.Play();
					}
				}
				Length[0] = MainTextureLength * Vector3.Distance(base.transform.position, hitInfo.point);
				Length[2] = NoiseTextureLength * Vector3.Distance(base.transform.position, hitInfo.point);
				if (hitInfo.collider.tag == "Target")
				{
					hitInfo.collider.GetComponent<HittedObject>().TakeDamage((float)damageOverTime * Time.deltaTime);
				}
			}
			else
			{
				Vector3 vector = base.transform.position + base.transform.forward * MaxLength;
				Laser.SetPosition(1, vector);
				HitEffect.transform.position = vector;
				ParticleSystem[] effects = Hit;
				foreach (ParticleSystem particleSystem2 in effects)
				{
					if (particleSystem2.isPlaying)
					{
						particleSystem2.Stop();
					}
				}
				Length[0] = MainTextureLength * Vector3.Distance(base.transform.position, vector);
				Length[2] = NoiseTextureLength * Vector3.Distance(base.transform.position, vector);
			}
			if (!Laser.enabled && !LaserSaver)
			{
				LaserSaver = true;
				Laser.enabled = true;
			}
		}

		public void DisablePrepare()
		{
			if (Laser != null)
			{
				Laser.enabled = false;
			}
			UpdateSaver = true;
			if (Effects == null)
			{
				return;
			}
			ParticleSystem[] effects = Effects;
			foreach (ParticleSystem particleSystem in effects)
			{
				if (particleSystem.isPlaying)
				{
					particleSystem.Stop();
				}
			}
		}
	}
	public class DemoShooting : MonoBehaviour
	{
		public GameObject FirePoint;

		public Camera Cam;

		public float MaxLength;

		public GameObject[] Prefabs;

		private Ray RayMouse;

		private Vector3 direction;

		private Quaternion rotation;

		[Header("GUI")]
		private float windowDpi;

		private int Prefab;

		private GameObject Instance;

		private float hSliderValue = 0.1f;

		private float fireCountdown;

		private float buttonSaver;

		public Animation camAnim;

		private void Start()
		{
			if (Screen.dpi < 1f)
			{
				windowDpi = 1f;
			}
			if (Screen.dpi < 200f)
			{
				windowDpi = 1f;
			}
			else
			{
				windowDpi = Screen.dpi / 200f;
			}
			Counter(0);
		}

		private void Update()
		{
			if (Input.GetButtonDown("Fire1"))
			{
				camAnim.Play(camAnim.clip.name);
				UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
			}
			if (Input.GetMouseButton(1) && fireCountdown <= 0f)
			{
				UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
				fireCountdown = 0f;
				fireCountdown += hSliderValue;
			}
			fireCountdown -= Time.deltaTime;
			if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
			{
				buttonSaver = 0f;
				Counter(-1);
			}
			if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
			{
				buttonSaver = 0f;
				Counter(1);
			}
			buttonSaver += Time.deltaTime;
			if (Cam != null)
			{
				Vector3 mousePosition = Input.mousePosition;
				RayMouse = Cam.ScreenPointToRay(mousePosition);
				if (Physics.Raycast(RayMouse.origin, RayMouse.direction, out var hitInfo, MaxLength))
				{
					RotateToMouseDirection(base.gameObject, hitInfo.point);
				}
			}
			else
			{
				UnityEngine.Debug.Log("No camera");
			}
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button to single shoot!");
			GUI.Label(new Rect(10f * windowDpi, 25f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use and hold the right mouse button for quick shooting!");
			GUI.Label(new Rect(10f * windowDpi, 45f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Fire rate:");
			hSliderValue = GUI.HorizontalSlider(new Rect(70f * windowDpi, 50f * windowDpi, 100f * windowDpi, 20f * windowDpi), hSliderValue, 0f, 1f);
			GUI.Label(new Rect(10f * windowDpi, 65f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change projectiles!");
		}

		private void Counter(int count)
		{
			Prefab += count;
			if (Prefab > Prefabs.Length - 1)
			{
				Prefab = 0;
			}
			else if (Prefab < 0)
			{
				Prefab = Prefabs.Length - 1;
			}
		}

		private void RotateToMouseDirection(GameObject obj, Vector3 destination)
		{
			direction = destination - obj.transform.position;
			rotation = Quaternion.LookRotation(direction);
			obj.transform.localRotation = Quaternion.Lerp(obj.transform.rotation, rotation, 1f);
		}
	}
	public class DemoShooting2D : MonoBehaviour
	{
		public GameObject FirePoint;

		public Camera Cam;

		public float MaxLength;

		public GameObject[] Prefabs;

		private Ray RayMouse;

		private Vector3 direction;

		private Quaternion rotation;

		[Header("GUI")]
		private float windowDpi;

		private int Prefab;

		private GameObject Instance;

		private float hSliderValue = 0.1f;

		private float fireCountdown;

		private float buttonSaver;

		private void Start()
		{
			if (Screen.dpi < 1f)
			{
				windowDpi = 1f;
			}
			if (Screen.dpi < 200f)
			{
				windowDpi = 1f;
			}
			else
			{
				windowDpi = Screen.dpi / 200f;
			}
			Counter(0);
		}

		private void Update()
		{
			if (Input.GetButtonDown("Fire1"))
			{
				UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
			}
			if (Input.GetMouseButton(1) && fireCountdown <= 0f)
			{
				UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
				fireCountdown = 0f;
				fireCountdown += hSliderValue;
			}
			fireCountdown -= Time.deltaTime;
			if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
			{
				buttonSaver = 0f;
				Counter(-1);
			}
			if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
			{
				buttonSaver = 0f;
				Counter(1);
			}
			buttonSaver += Time.deltaTime;
			if (Cam != null)
			{
				Vector3 vector = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				base.transform.rotation = Quaternion.LookRotation(Vector3.forward, vector - base.transform.position);
			}
			else
			{
				UnityEngine.Debug.Log("No camera");
			}
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button to single shoot!");
			GUI.Label(new Rect(10f * windowDpi, 25f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use and hold the right mouse button for quick shooting!");
			GUI.Label(new Rect(10f * windowDpi, 45f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Fire rate:");
			hSliderValue = GUI.HorizontalSlider(new Rect(70f * windowDpi, 50f * windowDpi, 100f * windowDpi, 20f * windowDpi), hSliderValue, 0f, 1f);
			GUI.Label(new Rect(10f * windowDpi, 65f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change projectiles!");
		}

		private void Counter(int count)
		{
			Prefab += count;
			if (Prefab > Prefabs.Length - 1)
			{
				Prefab = 0;
			}
			else if (Prefab < 0)
			{
				Prefab = Prefabs.Length - 1;
			}
		}
	}
	public class AutoDestroyPS : MonoBehaviour
	{
		private float timeLeft;

		private void Awake()
		{
			ParticleSystem.MainModule main = GetComponent<ParticleSystem>().main;
			timeLeft = main.startLifetimeMultiplier + main.duration;
			UnityEngine.Object.Destroy(base.gameObject, timeLeft);
		}
	}
	public class ParticleCollisionInstance : MonoBehaviour
	{
		public GameObject[] EffectsOnCollision;

		public float DestroyTimeDelay = 5f;

		public bool UseWorldSpacePosition;

		public float Offset;

		public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

		public bool useOnlyRotationOffset = true;

		public bool UseFirePointRotation;

		public bool DestoyMainEffect = true;

		private ParticleSystem part;

		private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

		private ParticleSystem ps;

		private void Start()
		{
			part = GetComponent<ParticleSystem>();
		}

		private void OnParticleCollision(GameObject other)
		{
			int num = part.GetCollisionEvents(other, collisionEvents);
			for (int i = 0; i < num; i++)
			{
				GameObject[] effectsOnCollision = EffectsOnCollision;
				for (int j = 0; j < effectsOnCollision.Length; j++)
				{
					GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[j], collisionEvents[i].intersection + collisionEvents[i].normal * Offset, default(Quaternion));
					if (!UseWorldSpacePosition)
					{
						gameObject.transform.parent = base.transform;
					}
					if (UseFirePointRotation)
					{
						gameObject.transform.LookAt(base.transform.position);
					}
					else if (rotationOffset != Vector3.zero && useOnlyRotationOffset)
					{
						gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
					}
					else
					{
						gameObject.transform.LookAt(collisionEvents[i].intersection + collisionEvents[i].normal);
						gameObject.transform.rotation *= Quaternion.Euler(rotationOffset);
					}
					UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
				}
			}
			if (DestoyMainEffect)
			{
				UnityEngine.Object.Destroy(base.gameObject, DestroyTimeDelay + 0.5f);
			}
		}
	}
	public class ProjectileMover : MonoBehaviour
	{
		public float speed = 15f;

		public float hitOffset;

		public bool UseFirePointRotation;

		public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

		public GameObject hit;

		public GameObject flash;

		private Rigidbody rb;

		public GameObject[] Detached;

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
			if (flash != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(flash, base.transform.position, Quaternion.identity);
				gameObject.transform.forward = base.gameObject.transform.forward;
				ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
				if (component != null)
				{
					UnityEngine.Object.Destroy(gameObject, component.main.duration);
				}
				else
				{
					ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
					UnityEngine.Object.Destroy(gameObject, component2.main.duration);
				}
			}
			UnityEngine.Object.Destroy(base.gameObject, 5f);
		}

		private void FixedUpdate()
		{
			if (speed != 0f)
			{
				rb.velocity = base.transform.forward * speed;
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			rb.constraints = RigidbodyConstraints.FreezeAll;
			speed = 0f;
			ContactPoint contactPoint = collision.contacts[0];
			Quaternion rotation = Quaternion.FromToRotation(Vector3.up, contactPoint.normal);
			Vector3 position = contactPoint.point + contactPoint.normal * hitOffset;
			if (hit != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(hit, position, rotation);
				if (UseFirePointRotation)
				{
					gameObject.transform.rotation = base.gameObject.transform.rotation * Quaternion.Euler(0f, 180f, 0f);
				}
				else if (rotationOffset != Vector3.zero)
				{
					gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
				}
				else
				{
					gameObject.transform.LookAt(contactPoint.point + contactPoint.normal);
				}
				ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
				if (component != null)
				{
					UnityEngine.Object.Destroy(gameObject, component.main.duration);
				}
				else
				{
					ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
					UnityEngine.Object.Destroy(gameObject, component2.main.duration);
				}
			}
			GameObject[] detached = Detached;
			foreach (GameObject gameObject2 in detached)
			{
				if (gameObject2 != null)
				{
					gameObject2.transform.parent = null;
				}
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class ProjectileMover2D : MonoBehaviour
	{
		public float speed = 15f;

		public float hitOffset;

		public bool UseFirePointRotation;

		public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

		public GameObject hit;

		public GameObject flash;

		private Rigidbody2D rb;

		public GameObject[] Detached;

		private void Start()
		{
			rb = GetComponent<Rigidbody2D>();
			if (flash != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(flash, base.transform.position, Quaternion.identity);
				gameObject.transform.forward = base.gameObject.transform.forward;
				ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
				if (component != null)
				{
					UnityEngine.Object.Destroy(gameObject, component.main.duration);
				}
				else
				{
					ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
					UnityEngine.Object.Destroy(gameObject, component2.main.duration);
				}
			}
			UnityEngine.Object.Destroy(base.gameObject, 5f);
		}

		private void FixedUpdate()
		{
			if (speed != 0f)
			{
				rb.velocity = base.transform.forward * speed;
			}
		}

		private void OnCollisionEnter2D(Collision2D collision)
		{
			rb.constraints = RigidbodyConstraints2D.FreezeAll;
			speed = 0f;
			ContactPoint2D contactPoint2D = collision.contacts[0];
			Quaternion rotation = Quaternion.FromToRotation(Vector3.up, contactPoint2D.normal);
			Vector3 position = contactPoint2D.point + contactPoint2D.normal * hitOffset;
			if (hit != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(hit, position, rotation);
				if (UseFirePointRotation)
				{
					gameObject.transform.rotation = base.gameObject.transform.rotation * Quaternion.Euler(0f, 180f, 0f);
				}
				else if (rotationOffset != Vector3.zero)
				{
					gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
				}
				else
				{
					gameObject.transform.LookAt(contactPoint2D.point + contactPoint2D.normal);
				}
				ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
				if (component != null)
				{
					UnityEngine.Object.Destroy(gameObject, component.main.duration);
				}
				else
				{
					ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
					UnityEngine.Object.Destroy(gameObject, component2.main.duration);
				}
			}
			GameObject[] detached = Detached;
			foreach (GameObject gameObject2 in detached)
			{
				if (gameObject2 != null)
				{
					gameObject2.transform.parent = null;
				}
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class OVSwitchController : OVGenericSingleton<OVSwitchController>
	{
		private void Start()
		{
		}

		public void Save()
		{
		}

		public void Load()
		{
		}

		private void OnDestroy()
		{
		}
	}
	public class OVUnmountHelper : OVGenericSingleton<OVUnmountHelper>
	{
		private void OnApplicationQuit()
		{
		}
	}
	public class ExampleWriteFilesRequest : FileOps.FileOperationRequest
	{
		public string myTestData = "This is some text test data which will be written to a file.";

		public string myOtherTestData = "This is some more text which is written to another save file.";

		public byte[] largeData = new byte[2097152];

		public override void DoFileOperations(Mounting.MountPoint mp, FileOps.FileOperationResponse response)
		{
			ExampleWriteFilesResponse exampleWriteFilesResponse = response as ExampleWriteFilesResponse;
			string text = mp.PathName.Data + "/MySaveFile.txt";
			File.WriteAllText(text, myTestData);
			FileInfo fileInfo = new FileInfo(text);
			exampleWriteFilesResponse.totalFileSizeWritten = fileInfo.Length;
			string text2 = mp.PathName.Data + "/MyOtherSaveFile.txt";
			File.WriteAllText(text2, myOtherTestData);
			fileInfo = new FileInfo(text2);
			exampleWriteFilesResponse.totalFileSizeWritten += fileInfo.Length;
			string text3 = mp.PathName.Data + "/Data.dat";
			int num = 0;
			using (FileStream fileStream = File.OpenWrite(text3))
			{
				while (num < largeData.Length)
				{
					int num2 = Math.Min(largeData.Length - num, 1000);
					fileStream.Write(largeData, num, num2);
					num += num2;
					response.UpdateProgress((float)num / (float)largeData.Length);
				}
			}
			fileInfo = new FileInfo(text3);
			exampleWriteFilesResponse.lastWriteTime = fileInfo.LastWriteTime;
			exampleWriteFilesResponse.totalFileSizeWritten += fileInfo.Length;
		}
	}
	public class ExampleWriteFilesResponse : FileOps.FileOperationResponse
	{
		public DateTime lastWriteTime;

		public long totalFileSizeWritten;
	}
	public class ExampleEnumerateFilesRequest : FileOps.FileOperationRequest
	{
		public override void DoFileOperations(Mounting.MountPoint mp, FileOps.FileOperationResponse response)
		{
			ExampleEnumerateFilesResponse obj = response as ExampleEnumerateFilesResponse;
			string data = mp.PathName.Data;
			obj.files = Directory.GetFiles(data, "*.txt", SearchOption.AllDirectories);
		}
	}
	public class ExampleEnumerateFilesResponse : FileOps.FileOperationResponse
	{
		public string[] files;
	}
	public class ExampleReadFilesRequest : FileOps.FileOperationRequest
	{
		public override void DoFileOperations(Mounting.MountPoint mp, FileOps.FileOperationResponse response)
		{
			ExampleReadFilesResponse exampleReadFilesResponse = response as ExampleReadFilesResponse;
			string path = mp.PathName.Data + "/MySaveFile.txt";
			exampleReadFilesResponse.myTestData = File.ReadAllText(path);
			string path2 = mp.PathName.Data + "/MyOtherSaveFile.txt";
			exampleReadFilesResponse.myOtherTestData = File.ReadAllText(path2);
			string text = mp.PathName.Data + "/Data.dat";
			FileInfo fileInfo = new FileInfo(text);
			exampleReadFilesResponse.largeData = new byte[fileInfo.Length];
			int num = 0;
			using FileStream fileStream = File.OpenRead(text);
			while (num < fileInfo.Length)
			{
				int num2 = Math.Min((int)fileInfo.Length - num, 1000);
				fileStream.Read(exampleReadFilesResponse.largeData, num, num2);
				num += num2;
				response.UpdateProgress((float)num / (float)fileInfo.Length);
			}
		}
	}
	public class ExampleReadFilesResponse : FileOps.FileOperationResponse
	{
		public string myTestData;

		public string myOtherTestData;

		public byte[] largeData;
	}
	public class GetScreenShot : MonoBehaviour
	{
		private bool doScreenshot;

		public byte[] screenShotBytes;

		public bool IsWaiting => doScreenshot;

		public void DoScreenShot()
		{
			screenShotBytes = null;
			doScreenshot = true;
		}

		private void LateUpdate()
		{
		}
	}
	public static class SaveDataDirNames
	{
		private static List<string> dirNames = new List<string>();

		private static int currentIndex = -1;
	}
	public class SaveIconWithScreenShot : MonoBehaviour
	{
		private bool doScreenshot;

		private Mounting.MountPoint currentMP;

		public void DoScreenShot(Mounting.MountPoint mp)
		{
			currentMP = mp;
			if (mp != null)
			{
				doScreenshot = true;
			}
		}

		private void LateUpdate()
		{
			_ = doScreenshot;
		}

		public void SaveIcon(Mounting.MountPoint mp, byte[] pngBytes)
		{
		}
	}
	public class SpinCube : MonoBehaviour
	{
		public float speed = 10f;

		private void Update()
		{
			base.transform.Rotate(Vector3.up, speed * Time.deltaTime);
		}
	}
	public class PositionSetter : MonoBehaviour
	{
		public Transform positionSource;

		[Button(null, EButtonEnableMode.Always)]
		public void SetPosition()
		{
			base.transform.position = positionSource.position;
			base.transform.rotation = positionSource.rotation;
		}
	}
	[ExecuteInEditMode]
	public class SimpleLODConfig : MonoBehaviour
	{
		private void OnEnable()
		{
			Add();
		}

		public void Add()
		{
			LOD lOD = new LOD(0.9f, GetComponentsInChildren<Renderer>(includeInactive: true));
			LODGroup lODGroup = base.gameObject.AddComponent<LODGroup>();
			if (lODGroup == null)
			{
				GetComponent<LODGroup>();
			}
			lODGroup.SetLODs(new LOD[1] { lOD });
		}
	}
	public class EndPointEffectControllerV3D : MonoBehaviour
	{
		public Light pointLight;

		public float pointLightRange = 10f;

		public float pointLightIntensity = 1f;

		public Color finalColor;

		public AnimationCurve progressCurve;

		public AnimationCurve impactCurve;

		public LaserLineV3D getEndPointPositionFrom;

		public ParticleSystem[] emittingParticleSystems;

		public GameObject[] scalingComponents;

		public bool emit;

		private bool currentEmit;

		private Vector3 endPointPosition;

		private float globalProgress;

		private float globalResultProgress;

		private float globalImpactProgress;

		private float globalImpactResultProgress;

		private float resultProgress;

		private Vector3[] initialLocalScale;

		private void Start()
		{
			SetEmission();
			endPointPosition = getEndPointPositionFrom.GetEndPointPosition();
			initialLocalScale = new Vector3[scalingComponents.Length];
			for (int i = 0; i < scalingComponents.Length; i++)
			{
				initialLocalScale[i] = scalingComponents[i].transform.localScale;
			}
		}

		public void SetFinalColor(Color col)
		{
			finalColor = col;
		}

		private void SetEmission()
		{
			ParticleSystem[] array = emittingParticleSystems;
			for (int i = 0; i < array.Length; i++)
			{
				ParticleSystem.EmissionModule emission = array[i].emission;
				emission.enabled = emit;
			}
		}

		public void SetGlobalProgress(float gp)
		{
			globalProgress = gp;
		}

		public void SetGlobalImpactProgress(float gp)
		{
			globalImpactProgress = gp;
		}

		private void Update()
		{
			endPointPosition = getEndPointPositionFrom.GetEndPointPosition();
			base.gameObject.transform.position = endPointPosition;
			if (currentEmit != emit)
			{
				SetEmission();
			}
			currentEmit = emit;
			globalImpactResultProgress = impactCurve.Evaluate(globalImpactProgress);
			if (globalImpactResultProgress == 0f)
			{
				globalImpactResultProgress = 0.001f;
			}
			globalResultProgress = progressCurve.Evaluate(globalProgress);
			resultProgress = globalImpactResultProgress + globalResultProgress;
			for (int i = 0; i < scalingComponents.Length; i++)
			{
				scalingComponents[i].transform.localScale = initialLocalScale[i] * resultProgress;
				if (resultProgress < 0.01f)
				{
					scalingComponents[i].gameObject.SetActive(value: false);
				}
				else
				{
					scalingComponents[i].gameObject.SetActive(value: true);
				}
			}
			if (pointLight != null)
			{
				pointLight.color = finalColor;
				pointLight.range = base.transform.lossyScale.x * pointLightRange;
				pointLight.intensity = resultProgress * pointLightIntensity;
			}
		}
	}
	public class LaserLineV3D : MonoBehaviour
	{
		public float maxLength = 1f;

		public AnimationCurve shaderProgressCurve;

		public AnimationCurve shaderImpactCurve;

		public float moveHitToSource = 0.5f;

		public int particleMeshLength = 1;

		public bool scalingWithSize = true;

		public float finalSize = 1f;

		private float preSize;

		private float HitLength;

		private ParticleSystem ps;

		private ParticleSystemRenderer psr;

		private Vector3 positionForExplosion;

		private Vector3[] particleSpawnPositions;

		private Vector3 endPoint;

		private float globalProgress;

		private float globalimpactProgress;

		private ParticleSystem.Particle[] particles;

		private int positionArrayLength;

		private bool tempFix;

		private void LaserControl()
		{
			float value = shaderProgressCurve.Evaluate(globalProgress);
			psr.material.SetFloat("_Progress", value);
			float value2 = shaderImpactCurve.Evaluate(globalimpactProgress);
			psr.material.SetFloat("_ImpactProgress", value2);
			psr.material.SetVector("_StartPosition", base.transform.position);
			psr.material.SetVector("_EndPosition", endPoint);
			psr.material.SetFloat("_Distance", HitLength);
			psr.material.SetFloat("_MaxDist", HitLength);
			psr.material.SetFloat("_FinalSize", finalSize);
		}

		private void LaserCastRay()
		{
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, maxLength))
			{
				HitLength = hitInfo.distance;
				positionForExplosion = Vector3.MoveTowards(hitInfo.point, base.transform.position, moveHitToSource);
				positionArrayLength = Mathf.RoundToInt(hitInfo.distance / ((float)particleMeshLength * finalSize));
				if ((float)positionArrayLength < hitInfo.distance)
				{
					positionArrayLength++;
				}
				particleSpawnPositions = new Vector3[positionArrayLength];
				endPoint = hitInfo.point;
			}
			else
			{
				HitLength = maxLength;
				positionArrayLength = Mathf.RoundToInt(maxLength / ((float)particleMeshLength * finalSize));
				if ((float)positionArrayLength < maxLength)
				{
					positionArrayLength++;
				}
				particleSpawnPositions = new Vector3[positionArrayLength];
				endPoint = Vector3.MoveTowards(base.transform.position, base.transform.forward * 1000f, maxLength);
				positionForExplosion = endPoint;
			}
		}

		private void Start()
		{
			ps = GetComponent<ParticleSystem>();
			psr = GetComponent<ParticleSystemRenderer>();
			HitLength = 0f;
			LaserCastRay();
			LaserControl();
			UpdateLaserParts();
			tempFix = true;
		}

		private void OnEnable()
		{
			if (tempFix)
			{
				UpdateLaserParts();
			}
		}

		private void UpdateLaserParts()
		{
			particles = new ParticleSystem.Particle[positionArrayLength];
			for (int i = 0; i < positionArrayLength; i++)
			{
				particleSpawnPositions[i] = new Vector3(0f, 0f, 0f) + new Vector3(0f, 0f, (float)(i * particleMeshLength) * finalSize);
				particles[i].position = particleSpawnPositions[i];
				particles[i].startSize = finalSize;
				particles[i].startColor = new Color(1f, 1f, 1f);
			}
			ps.SetParticles(particles, particles.Length);
		}

		public void SetGlobalProgress(float gp)
		{
			globalProgress = gp;
		}

		public Vector3 GetEndPointPosition()
		{
			return positionForExplosion;
		}

		public void SetGlobalImpactProgress(float gp)
		{
			globalimpactProgress = gp;
		}

		private void Update()
		{
			if (scalingWithSize)
			{
				finalSize = base.gameObject.transform.lossyScale.x;
			}
			LaserCastRay();
			LaserControl();
			if (positionArrayLength != particles.Length || preSize != finalSize)
			{
				UpdateLaserParts();
			}
			preSize = finalSize;
		}
	}
	public class LightLineV3D : MonoBehaviour
	{
		public float maxLength = 32f;

		public AnimationCurve shaderProgressCurve;

		public AnimationCurve shaderImpactCurve;

		public float moveHitToSource = 0.5f;

		public int distanceBetweenLights = 1;

		public bool scalingWithSize = true;

		public float finalSize = 1f;

		public Light lightPrefab;

		public float lightRange = 5f;

		public float lightIntensity = 1f;

		public Color finalColor;

		public bool scaleDensityWithSize;

		private Color currentColor;

		private Vector3[] pointLightSpawnPositions;

		private float globalProgress;

		private float globalimpactProgress;

		private int positionArrayLenght;

		private Light[] lights;

		private int roundedMaxLength;

		private float progress;

		private float impactProgress;

		private float resultProgress;

		private void LaserControl()
		{
			progress = shaderProgressCurve.Evaluate(globalProgress);
			impactProgress = shaderImpactCurve.Evaluate(globalimpactProgress);
			resultProgress = progress + impactProgress;
		}

		public void SetFinalColor(Color col)
		{
			finalColor = col;
		}

		private void LaserCastRay()
		{
			if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, maxLength))
			{
				positionArrayLenght = Mathf.RoundToInt(hitInfo.distance / (float)distanceBetweenLights);
				pointLightSpawnPositions = new Vector3[positionArrayLenght];
			}
			else
			{
				positionArrayLenght = Mathf.RoundToInt(maxLength / (float)distanceBetweenLights);
				pointLightSpawnPositions = new Vector3[positionArrayLenght];
			}
		}

		private void CreateLights()
		{
			lights = new Light[roundedMaxLength];
			for (int i = 0; i < roundedMaxLength; i++)
			{
				lights[i] = UnityEngine.Object.Instantiate(lightPrefab);
				lights[i].transform.parent = base.transform;
				lights[i].gameObject.SetActive(value: false);
				lights[i].color = finalColor;
			}
		}

		private void ActivateLights()
		{
			for (int i = 0; i < roundedMaxLength; i++)
			{
				lights[i].gameObject.SetActive(value: false);
			}
			for (int j = 0; j < positionArrayLenght; j++)
			{
				lights[j].color = finalColor;
				lights[j].gameObject.SetActive(value: true);
			}
		}

		private void Start()
		{
			roundedMaxLength = Mathf.RoundToInt(maxLength);
			CreateLights();
			LaserCastRay();
			ActivateLights();
			LaserControl();
			UpdateLaserParts();
		}

		private void UpdateLaserParts()
		{
			for (int i = 0; i < positionArrayLenght; i++)
			{
				pointLightSpawnPositions[i] = new Vector3(0f, 0f, 0f) + new Vector3(0f, 0f, (float)(i * distanceBetweenLights) * (1f / finalSize));
				lights[i].transform.localPosition = pointLightSpawnPositions[i];
				lights[i].intensity = resultProgress * lightIntensity;
				lights[i].range = lightRange * finalSize;
			}
		}

		public void SetGlobalProgress(float gp)
		{
			globalProgress = gp;
		}

		public void SetGlobalImpactProgress(float gp)
		{
			globalimpactProgress = gp;
		}

		private void Update()
		{
			if (scalingWithSize)
			{
				finalSize = base.gameObject.transform.lossyScale.x;
			}
			LaserCastRay();
			LaserControl();
			if (positionArrayLenght != lights.Length || currentColor != finalColor)
			{
				ActivateLights();
			}
			UpdateLaserParts();
			currentColor = finalColor;
		}
	}
	public class MouseTargetV3D : MonoBehaviour
	{
		public Transform targetCursor;

		public float speed = 1f;

		private Vector3 mouseWorldPosition;

		private void FixedUpdate()
		{
			if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo))
			{
				mouseWorldPosition = hitInfo.point;
			}
			Quaternion b = Quaternion.LookRotation(mouseWorldPosition - base.transform.position);
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, speed * Time.deltaTime);
			targetCursor.position = mouseWorldPosition;
		}
	}
	public class ProgressControlV3D : MonoBehaviour
	{
		public bool changeAllMaxLength = true;

		public float maxLength = 32f;

		public float globalProgressSpeed = 1f;

		public float globalImpactProgressSpeed = 1f;

		public bool always = true;

		public bool colorizeAll = true;

		public Color finalColor;

		[Range(0.2f, 1f)]
		public float gammaLinear = 1f;

		public Renderer meshRend;

		public float meshRendPower = 3f;

		public Light pointLight;

		public StartPointEffectControllerV3D startPointEffect;

		public EndPointEffectControllerV3D endPointEffect;

		public SmartWaveParticlesControllerV3D smartWaveParticles;

		public SFXControllerV3D sfxcontroller;

		private float globalProgress;

		private float globalImpactProgress;

		private LaserLineV3D[] lls;

		private LightLineV3D[] lils;

		private Renderer[] renderers;

		private void Start()
		{
			globalProgress = 1f;
			globalImpactProgress = 1f;
			lls = GetComponentsInChildren<LaserLineV3D>(includeInactive: true);
			lils = GetComponentsInChildren<LightLineV3D>(includeInactive: true);
			renderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		}

		public void ChangeColor(Color color)
		{
			finalColor = color;
		}

		private void Update()
		{
			Renderer[] array = renderers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].material.SetFloat("_GammaLinear", gammaLinear);
			}
			startPointEffect.SetGlobalProgress(globalProgress);
			startPointEffect.SetGlobalImpactProgress(globalImpactProgress);
			endPointEffect.SetGlobalProgress(globalProgress);
			endPointEffect.SetGlobalImpactProgress(globalImpactProgress);
			smartWaveParticles.SetGlobalProgress(globalProgress);
			LightLineV3D[] array2;
			if (colorizeAll)
			{
				array2 = lils;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].SetFinalColor(finalColor);
				}
				startPointEffect.SetFinalColor(finalColor);
				endPointEffect.SetFinalColor(finalColor);
				array = renderers;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].material.SetColor("_FinalColor", finalColor);
				}
			}
			if (meshRend != null)
			{
				meshRend.material.SetColor("_EmissionColor", finalColor * meshRendPower);
			}
			if (globalProgress < 1f)
			{
				globalProgress += Time.deltaTime * globalProgressSpeed;
			}
			if (globalImpactProgress < 1f)
			{
				globalImpactProgress += Time.deltaTime * globalImpactProgressSpeed;
			}
			if (Input.GetMouseButton(0) || always)
			{
				globalProgress = 0f;
				endPointEffect.emit = true;
			}
			else
			{
				endPointEffect.emit = false;
			}
			if (Input.GetMouseButtonDown(0))
			{
				globalImpactProgress = 0f;
			}
			if (always)
			{
				globalProgress = 0f;
			}
			LaserLineV3D[] array3 = lls;
			foreach (LaserLineV3D laserLineV3D in array3)
			{
				laserLineV3D.SetGlobalProgress(globalProgress);
				laserLineV3D.SetGlobalImpactProgress(globalImpactProgress);
				if (changeAllMaxLength)
				{
					laserLineV3D.maxLength = maxLength;
				}
			}
			array2 = lils;
			foreach (LightLineV3D lightLineV3D in array2)
			{
				lightLineV3D.SetGlobalProgress(globalProgress);
				lightLineV3D.SetGlobalImpactProgress(globalImpactProgress);
				if (changeAllMaxLength)
				{
					lightLineV3D.maxLength = maxLength;
				}
			}
			sfxcontroller.SetGlobalProgress(1f - globalProgress);
		}
	}
	public class SFXControllerV3D : MonoBehaviour
	{
		public AudioSource loopingSFX;

		public GameObject[] waveSfxPrefabs;

		private float globalProgress;

		public void SetGlobalProgress(float gp)
		{
			globalProgress = gp;
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				UnityEngine.Object.Instantiate(waveSfxPrefabs[UnityEngine.Random.Range(0, waveSfxPrefabs.Length)], base.transform.position, base.transform.rotation);
			}
			loopingSFX.volume = globalProgress;
		}
	}
	public class SelfDestroyV3D : MonoBehaviour
	{
		public float timeToDestroy = 2f;

		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject, timeToDestroy);
		}
	}
	public class SmartWaveParticlesControllerV3D : MonoBehaviour
	{
		public Transform startLaserPoint;

		public ParticleSystem controlPS;

		public ParticleSystem distortionSpherePS;

		public AnimationCurve ac;

		private float globalProgress;

		private Renderer[] renderers;

		private ParticleSystem.Particle[] controlParticles;

		private Vector4[] controlParticlesPositions;

		private float[] controlParticlesSizes;

		private void Start()
		{
			controlParticlesPositions = new Vector4[5];
			controlParticlesSizes = new float[5];
			renderers = GetComponentsInChildren<Renderer>();
		}

		public void SetGlobalProgress(float gp)
		{
			globalProgress = gp;
		}

		public void SpawnWave()
		{
			controlParticles = new ParticleSystem.Particle[5];
			if (Input.GetMouseButtonDown(0))
			{
				distortionSpherePS.Emit(1);
				controlPS.Emit(1);
			}
		}

		private void Update()
		{
			SpawnWave();
			controlPS.GetParticles(controlParticles);
			for (int i = 0; i < 5; i++)
			{
				controlParticlesPositions[i] = controlParticles[i].position;
				controlParticlesSizes[i] = controlParticles[i].GetCurrentSize(controlPS) * controlPS.transform.lossyScale.x;
			}
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				for (int k = 0; k < 5; k++)
				{
					renderer.material.SetVector("_ControlParticlePosition" + k, controlParticlesPositions[k]);
					renderer.material.SetFloat("_ControlParticleSize" + k, controlParticlesSizes[k]);
				}
				renderer.material.SetVector("_StartLaserPosition", startLaserPoint.position);
				renderer.material.SetFloat("_StartLaserProgress", ac.Evaluate(globalProgress));
				renderer.material.SetFloat("_PSLossyScale", controlPS.transform.lossyScale.x);
			}
		}
	}
	public class StartPointEffectControllerV3D : MonoBehaviour
	{
		public Light pointLight;

		public float pointLightRange = 10f;

		public float pointLightIntensity = 1f;

		public ParticleSystem[] scalingParticleSystems;

		public ParticleSystem[] emittingParticleSystems;

		public bool emit;

		public AnimationCurve progressCurve;

		public AnimationCurve impactCurve;

		public Color finalColor;

		private float globalProgress;

		private float globalResultProgress;

		private float globalImpactProgress;

		private float globalImpactResultProgress;

		private float resultProgress;

		private Vector3[] initialLocalScale;

		private void Start()
		{
			initialLocalScale = new Vector3[scalingParticleSystems.Length];
			for (int i = 0; i < scalingParticleSystems.Length; i++)
			{
				initialLocalScale[i] = scalingParticleSystems[i].transform.localScale;
			}
		}

		public void SetGlobalProgress(float gp)
		{
			globalProgress = gp;
		}

		public void SetFinalColor(Color col)
		{
			finalColor = col;
		}

		public void SetGlobalImpactProgress(float gp)
		{
			globalImpactProgress = gp;
		}

		private void Update()
		{
			if (resultProgress > 0.9f)
			{
				emit = true;
			}
			else
			{
				emit = false;
			}
			globalImpactResultProgress = impactCurve.Evaluate(globalImpactProgress);
			if (globalImpactResultProgress == 0f)
			{
				globalImpactResultProgress = 0.001f;
			}
			globalResultProgress = progressCurve.Evaluate(globalProgress);
			resultProgress = globalImpactResultProgress + globalResultProgress;
			for (int i = 0; i < scalingParticleSystems.Length; i++)
			{
				scalingParticleSystems[i].transform.localScale = initialLocalScale[i] * resultProgress;
				if (resultProgress < 0.01f)
				{
					scalingParticleSystems[i].gameObject.SetActive(value: false);
				}
				else
				{
					scalingParticleSystems[i].gameObject.SetActive(value: true);
				}
			}
			if (emit)
			{
				ParticleSystem[] array = emittingParticleSystems;
				for (int j = 0; j < array.Length; j++)
				{
					ParticleSystem.EmissionModule emission = array[j].emission;
					emission.enabled = true;
				}
			}
			else
			{
				ParticleSystem[] array = emittingParticleSystems;
				for (int j = 0; j < array.Length; j++)
				{
					ParticleSystem.EmissionModule emission2 = array[j].emission;
					emission2.enabled = false;
				}
			}
			pointLight.color = finalColor;
			pointLight.range = base.transform.lossyScale.x * pointLightRange;
			pointLight.intensity = resultProgress * pointLightIntensity;
		}
	}
	public class UIControllerV3D : MonoBehaviour
	{
		public Light directionalLight;

		public ReflectionProbe reflectionProbe;

		public Material daySkyboxMaterial;

		public Material nightSkyboxMaterial;

		public Transform prefabHolder;

		public Text text;

		public Image handle;

		public Gradient handleGradient;

		public ProgressControlV3D pc;

		private Transform[] prefabs;

		private List<Transform> lt;

		private int activeNumber;

		private void Start()
		{
			lt = new List<Transform>();
			prefabs = prefabHolder.GetComponentsInChildren<Transform>(includeInactive: true);
			Transform[] array = prefabs;
			foreach (Transform transform in array)
			{
				if (transform.parent == prefabHolder)
				{
					lt.Add(transform);
				}
			}
			prefabs = lt.ToArray();
			EnableActive();
		}

		public void ChangeColor(float sliderValue)
		{
			pc.ChangeColor(handleGradient.Evaluate(sliderValue));
			handle.color = handleGradient.Evaluate(sliderValue);
		}

		public void EnableActive()
		{
			for (int i = 0; i < prefabs.Length; i++)
			{
				if (i == activeNumber)
				{
					prefabs[i].gameObject.SetActive(value: true);
					pc = prefabs[i].gameObject.GetComponentInChildren<ProgressControlV3D>();
					text.text = prefabs[i].name;
				}
				else
				{
					prefabs[i].gameObject.SetActive(value: false);
				}
			}
		}

		public void ChangeEffect(bool bo)
		{
			if (bo)
			{
				activeNumber++;
				if (activeNumber == prefabs.Length)
				{
					activeNumber = 0;
				}
			}
			else
			{
				activeNumber--;
				if (activeNumber == -1)
				{
					activeNumber = prefabs.Length - 1;
				}
			}
			EnableActive();
		}

		public void SetDay()
		{
			directionalLight.enabled = true;
			RenderSettings.skybox = daySkyboxMaterial;
			reflectionProbe.RenderProbe();
		}

		public void SetNight()
		{
			directionalLight.enabled = false;
			RenderSettings.skybox = nightSkyboxMaterial;
			reflectionProbe.RenderProbe();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Q))
			{
				SetDay();
			}
			if (Input.GetKeyDown(KeyCode.E))
			{
				SetNight();
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				ChangeEffect(bo: true);
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				ChangeEffect(bo: false);
			}
		}
	}
	public class RandomMaterial : MonoBehaviour
	{
		public Renderer targetRenderer;

		public Material[] materials;

		public void Start()
		{
			ChangeMaterial();
		}

		public void ChangeMaterial()
		{
			targetRenderer.sharedMaterial = materials[UnityEngine.Random.Range(0, materials.Length)];
		}
	}
	public class UnluckDistanceDisabler : MonoBehaviour
	{
		public int _distanceDisable = 1000;

		public Transform _distanceFrom;

		public bool _distanceFromMainCam;

		public float _disableCheckInterval = 10f;

		public float _enableCheckInterval = 1f;

		public bool _disableOnStart;

		public void Start()
		{
			if (_distanceFromMainCam)
			{
				_distanceFrom = Camera.main.transform;
			}
			InvokeRepeating("CheckDisable", _disableCheckInterval + UnityEngine.Random.value * _disableCheckInterval, _disableCheckInterval);
			InvokeRepeating("CheckEnable", _enableCheckInterval + UnityEngine.Random.value * _enableCheckInterval, _enableCheckInterval);
			Invoke("DisableOnStart", 0.01f);
		}

		public void DisableOnStart()
		{
			if (_disableOnStart)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		public void CheckDisable()
		{
			if (base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude > (float)(_distanceDisable * _distanceDisable))
			{
				base.gameObject.SetActive(value: false);
			}
		}

		public void CheckEnable()
		{
			if (!base.gameObject.activeInHierarchy && (base.transform.position - _distanceFrom.position).sqrMagnitude < (float)(_distanceDisable * _distanceDisable))
			{
				base.gameObject.SetActive(value: true);
			}
		}
	}
	public class LookAtCamera : MonoBehaviour
	{
		public Camera lookAtCamera;

		public bool lookOnlyOnAwake;

		public void Start()
		{
			if (lookAtCamera == null)
			{
				lookAtCamera = Camera.main;
			}
			if (lookOnlyOnAwake)
			{
				LookCam();
			}
		}

		public void Update()
		{
			if (!lookOnlyOnAwake)
			{
				LookCam();
			}
		}

		public void LookCam()
		{
			base.transform.LookAt(lookAtCamera.transform);
		}
	}
	[AddComponentMenu("Camera-Control/Smooth Mouse Orbit - Unluck Software")]
	public class SmoothCameraOrbit : MonoBehaviour
	{
		public Transform target;

		public Vector3 targetOffset;

		public float distance = 5f;

		public float maxDistance = 20f;

		public float minDistance = 0.6f;

		public float xSpeed = 200f;

		public float ySpeed = 200f;

		public int yMinLimit = -80;

		public int yMaxLimit = 80;

		public int zoomRate = 40;

		public float panSpeed = 0.3f;

		public float zoomDampening = 5f;

		public float autoRotate = 1f;

		public float autoRotateSpeed = 0.1f;

		private float xDeg;

		private float yDeg;

		private float currentDistance;

		private float desiredDistance;

		private Quaternion currentRotation;

		private Quaternion desiredRotation;

		private Quaternion rotation;

		private Vector3 position;

		private float idleTimer;

		private float idleSmooth;

		private void Start()
		{
			Init();
		}

		private void OnEnable()
		{
			Init();
		}

		public void Init()
		{
			if (!target)
			{
				GameObject gameObject = new GameObject("Cam Target");
				gameObject.transform.position = base.transform.position + base.transform.forward * distance;
				target = gameObject.transform;
			}
			currentDistance = distance;
			desiredDistance = distance;
			position = base.transform.position;
			rotation = base.transform.rotation;
			currentRotation = base.transform.rotation;
			desiredRotation = base.transform.rotation;
			xDeg = Vector3.Angle(Vector3.right, base.transform.right);
			yDeg = Vector3.Angle(Vector3.up, base.transform.up);
			position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
		}

		private void LateUpdate()
		{
			if (Input.GetMouseButton(2) && Input.GetKey(KeyCode.LeftAlt) && Input.GetKey(KeyCode.LeftControl))
			{
				desiredDistance -= Input.GetAxis("Mouse Y") * 0.02f * (float)zoomRate * 0.125f * Mathf.Abs(desiredDistance);
			}
			else if (Input.GetMouseButton(0))
			{
				xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
				yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
				desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
				currentRotation = base.transform.rotation;
				rotation = Quaternion.Lerp(currentRotation, desiredRotation, 0.02f * zoomDampening);
				base.transform.rotation = rotation;
				idleTimer = 0f;
				idleSmooth = 0f;
			}
			else
			{
				idleTimer += 0.02f;
				if (idleTimer > autoRotate && autoRotate > 0f)
				{
					idleSmooth += (0.02f + idleSmooth) * 0.005f;
					idleSmooth = Mathf.Clamp(idleSmooth, 0f, 1f);
					xDeg += xSpeed * Time.deltaTime * idleSmooth * autoRotateSpeed;
				}
				yDeg = ClampAngle(yDeg, yMinLimit, yMaxLimit);
				desiredRotation = Quaternion.Euler(yDeg, xDeg, 0f);
				currentRotation = base.transform.rotation;
				rotation = Quaternion.Lerp(currentRotation, desiredRotation, 0.02f * zoomDampening * 2f);
				base.transform.rotation = rotation;
			}
			desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * 0.02f * (float)zoomRate * Mathf.Abs(desiredDistance);
			desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
			currentDistance = Mathf.Lerp(currentDistance, desiredDistance, 0.02f * zoomDampening);
			position = target.position - (rotation * Vector3.forward * currentDistance + targetOffset);
			base.transform.position = position;
		}

		private static float ClampAngle(float angle, float min, float max)
		{
			if (angle < -360f)
			{
				angle += 360f;
			}
			if (angle > 360f)
			{
				angle -= 360f;
			}
			return Mathf.Clamp(angle, min, max);
		}
	}
	public class FlockChild : MonoBehaviour
	{
		[HideInInspector]
		public FlockController _spawner;

		[HideInInspector]
		public Vector3 _wayPoint;

		public float _speed;

		[HideInInspector]
		public bool _dived = true;

		[HideInInspector]
		public float _stuckCounter;

		[HideInInspector]
		public float _damping;

		[HideInInspector]
		public bool _soar = true;

		[HideInInspector]
		public bool _landing;

		[HideInInspector]
		public float _targetSpeed;

		[HideInInspector]
		public bool _move = true;

		public GameObject _model;

		public Transform _modelT;

		[HideInInspector]
		public float _avoidValue;

		[HideInInspector]
		public float _avoidDistance;

		private float _soarTimer;

		private bool _instantiated;

		private static int _updateNextSeed;

		private int _updateSeed = -1;

		[HideInInspector]
		public bool _avoid = true;

		public Transform _thisT;

		public Vector3 _landingPosOffset;

		public bool animate = true;

		public void Start()
		{
			FindRequiredComponents();
			Wander(0f);
			SetRandomScale();
			_thisT.position = findWaypoint();
			RandomizeStartAnimationFrame();
			InitAvoidanceValues();
			_speed = _spawner._minSpeed;
			_spawner._activeChildren += 1f;
			_instantiated = true;
			if (_spawner._updateDivisor > 1)
			{
				int num = _spawner._updateDivisor - 1;
				_updateNextSeed++;
				_updateSeed = _updateNextSeed;
				_updateNextSeed %= num;
			}
		}

		public void Update()
		{
			if (_spawner._updateDivisor <= 1 || _spawner._updateCounter == _updateSeed)
			{
				SoarTimeLimit();
				CheckForDistanceToWaypoint();
				RotationBasedOnWaypointOrAvoidance();
				LimitRotationOfModel();
			}
		}

		public void OnDisable()
		{
			CancelInvoke();
			_spawner._activeChildren -= 1f;
		}

		public void OnEnable()
		{
			if (!_instantiated)
			{
				return;
			}
			_spawner._activeChildren += 1f;
			if (animate)
			{
				if (_landing)
				{
					_model.GetComponent<Animation>().Play(_spawner._idleAnimation);
				}
				else
				{
					_model.GetComponent<Animation>().Play(_spawner._flapAnimation);
				}
			}
		}

		public void FindRequiredComponents()
		{
			if (_thisT == null)
			{
				_thisT = base.transform;
			}
			if (_model == null)
			{
				_model = _thisT.Find("Model").gameObject;
			}
			if (_modelT == null)
			{
				_modelT = _model.transform;
			}
		}

		public void RandomizeStartAnimationFrame()
		{
			if (!animate)
			{
				return;
			}
			foreach (AnimationState item in _model.GetComponent<Animation>())
			{
				item.time = UnityEngine.Random.value * item.length;
			}
		}

		public void InitAvoidanceValues()
		{
			_avoidValue = UnityEngine.Random.Range(0.3f, 0.1f);
			if (_spawner._birdAvoidDistanceMax != _spawner._birdAvoidDistanceMin)
			{
				_avoidDistance = UnityEngine.Random.Range(_spawner._birdAvoidDistanceMax, _spawner._birdAvoidDistanceMin);
			}
			else
			{
				_avoidDistance = _spawner._birdAvoidDistanceMin;
			}
		}

		public void SetRandomScale()
		{
			float num = UnityEngine.Random.Range(_spawner._minScale, _spawner._maxScale);
			_thisT.localScale = new Vector3(num, num, num);
		}

		public void SoarTimeLimit()
		{
			if (_soar && _spawner._soarMaxTime > 0f)
			{
				if (_soarTimer > _spawner._soarMaxTime)
				{
					Flap();
					_soarTimer = 0f;
				}
				else
				{
					_soarTimer += _spawner._newDelta;
				}
			}
		}

		public void CheckForDistanceToWaypoint()
		{
			if (!_landing && (_thisT.position - _wayPoint).magnitude < _spawner._waypointDistance + _stuckCounter)
			{
				Wander(0f);
				_stuckCounter = 0f;
			}
			else if (!_landing)
			{
				_stuckCounter += _spawner._newDelta;
			}
			else
			{
				_stuckCounter = 0f;
			}
		}

		public void RotationBasedOnWaypointOrAvoidance()
		{
			Vector3 vector = _wayPoint - _thisT.position;
			if (_targetSpeed > -1f && vector != Vector3.zero)
			{
				Quaternion b = Quaternion.LookRotation(vector);
				_thisT.rotation = Quaternion.Slerp(_thisT.rotation, b, _spawner._newDelta * _damping);
			}
			if (_spawner._childTriggerPos && (_thisT.position - _spawner._posBuffer).magnitude < 1f)
			{
				_spawner.SetFlockRandomPosition();
			}
			_speed = Mathf.Lerp(_speed, _targetSpeed, _spawner._newDelta * 2.5f);
			if (_move)
			{
				_thisT.position += _thisT.forward * _speed * _spawner._newDelta;
				if (_avoid && _spawner._birdAvoid)
				{
					Avoidance();
				}
			}
		}

		public bool Avoidance()
		{
			RaycastHit hitInfo = default(RaycastHit);
			Vector3 forward = _modelT.forward;
			bool result = false;
			Quaternion identity = Quaternion.identity;
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			zero2 = _thisT.position;
			identity = _thisT.rotation;
			zero = _thisT.rotation.eulerAngles;
			if (Physics.Raycast(_thisT.position, forward + _modelT.right * _avoidValue, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
			{
				zero.y -= (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
				identity.eulerAngles = zero;
				_thisT.rotation = identity;
				result = true;
			}
			else if (Physics.Raycast(_thisT.position, forward + _modelT.right * (0f - _avoidValue), out hitInfo, _avoidDistance, _spawner._avoidanceMask))
			{
				zero.y += (float)_spawner._birdAvoidHorizontalForce * _spawner._newDelta * _damping;
				identity.eulerAngles = zero;
				_thisT.rotation = identity;
				result = true;
			}
			if (_spawner._birdAvoidDown && !_landing && Physics.Raycast(_thisT.position, -Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
			{
				zero.x -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
				identity.eulerAngles = zero;
				_thisT.rotation = identity;
				zero2.y += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
				_thisT.position = zero2;
				result = true;
			}
			else if (_spawner._birdAvoidUp && !_landing && Physics.Raycast(_thisT.position, Vector3.up, out hitInfo, _avoidDistance, _spawner._avoidanceMask))
			{
				zero.x += (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * _damping;
				identity.eulerAngles = zero;
				_thisT.rotation = identity;
				zero2.y -= (float)_spawner._birdAvoidVerticalForce * _spawner._newDelta * 0.01f;
				_thisT.position = zero2;
				result = true;
			}
			return result;
		}

		public void LimitRotationOfModel()
		{
			Quaternion identity = Quaternion.identity;
			Vector3 zero = Vector3.zero;
			identity = _modelT.localRotation;
			zero = identity.eulerAngles;
			if ((((_soar && _spawner._flatSoar) || (_spawner._flatFly && !_soar)) && _wayPoint.y > _thisT.position.y) || _landing)
			{
				zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f - _thisT.localEulerAngles.x, _spawner._newDelta * 1.75f);
				identity.eulerAngles = zero;
				_modelT.localRotation = identity;
			}
			else
			{
				zero.x = Mathf.LerpAngle(_modelT.localEulerAngles.x, 0f, _spawner._newDelta * 1.75f);
				identity.eulerAngles = zero;
				_modelT.localRotation = identity;
			}
		}

		public void Wander(float delay)
		{
			if (!_landing)
			{
				_damping = UnityEngine.Random.Range(_spawner._minDamping, _spawner._maxDamping);
				_targetSpeed = UnityEngine.Random.Range(_spawner._minSpeed, _spawner._maxSpeed);
				Invoke("SetRandomMode", delay);
			}
		}

		public void SetRandomMode()
		{
			CancelInvoke("SetRandomMode");
			if (!_dived && UnityEngine.Random.value < _spawner._soarFrequency)
			{
				Soar();
			}
			else if (!_dived && UnityEngine.Random.value < _spawner._diveFrequency)
			{
				Dive();
			}
			else
			{
				Flap();
			}
		}

		public void Flap()
		{
			if (_move)
			{
				if (animate && _model != null)
				{
					_model.GetComponent<Animation>().CrossFade(_spawner._flapAnimation, 0.5f);
				}
				_soar = false;
				animationSpeed();
				_wayPoint = findWaypoint();
				_dived = false;
			}
		}

		public Vector3 findWaypoint()
		{
			Vector3 zero = Vector3.zero;
			zero.x = UnityEngine.Random.Range(0f - _spawner._spawnSphere, _spawner._spawnSphere) + _spawner._posBuffer.x;
			zero.z = UnityEngine.Random.Range(0f - _spawner._spawnSphereDepth, _spawner._spawnSphereDepth) + _spawner._posBuffer.z;
			zero.y = UnityEngine.Random.Range(0f - _spawner._spawnSphereHeight, _spawner._spawnSphereHeight) + _spawner._posBuffer.y;
			return zero;
		}

		public void Soar()
		{
			if (_move)
			{
				if (animate)
				{
					_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
				}
				_wayPoint = findWaypoint();
				_soar = true;
			}
		}

		public void Dive()
		{
			if (_spawner._soarAnimation != null)
			{
				if (animate)
				{
					_model.GetComponent<Animation>().CrossFade(_spawner._soarAnimation, 1.5f);
				}
			}
			else if (animate)
			{
				foreach (AnimationState item in _model.GetComponent<Animation>())
				{
					if (_thisT.position.y < _wayPoint.y + 25f)
					{
						item.speed = 0.1f;
					}
				}
			}
			_wayPoint = findWaypoint();
			_wayPoint.y -= _spawner._diveValue;
			_dived = true;
		}

		public void animationSpeed()
		{
			if (!animate)
			{
				return;
			}
			foreach (AnimationState item in _model.GetComponent<Animation>())
			{
				if (!_dived && !_landing)
				{
					item.speed = UnityEngine.Random.Range(_spawner._minAnimationSpeed, _spawner._maxAnimationSpeed);
				}
				else
				{
					item.speed = _spawner._maxAnimationSpeed;
				}
			}
		}
	}
	[RequireComponent(typeof(AudioSource))]
	public class FlockChildSound : MonoBehaviour
	{
		public AudioClip[] _idleSounds;

		public float _idleSoundRandomChance = 0.05f;

		public AudioClip[] _flightSounds;

		public float _flightSoundRandomChance = 0.05f;

		public AudioClip[] _scareSounds;

		public float _pitchMin = 0.85f;

		public float _pitchMax = 1f;

		public float _volumeMin = 0.6f;

		public float _volumeMax = 0.8f;

		private FlockChild _flockChild;

		private AudioSource _audio;

		private bool _hasLanded;

		public void Start()
		{
			_flockChild = GetComponent<FlockChild>();
			_audio = GetComponent<AudioSource>();
			InvokeRepeating("PlayRandomSound", UnityEngine.Random.value + 1f, 1f);
			if (_scareSounds.Length != 0)
			{
				InvokeRepeating("ScareSound", 1f, 0.01f);
			}
		}

		public void PlayRandomSound()
		{
			if (base.gameObject.activeInHierarchy)
			{
				if (!_audio.isPlaying && _flightSounds.Length != 0 && _flightSoundRandomChance > UnityEngine.Random.value && !_flockChild._landing)
				{
					_audio.clip = _flightSounds[UnityEngine.Random.Range(0, _flightSounds.Length)];
					_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
					_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
					_audio.Play();
				}
				else if (!_audio.isPlaying && _idleSounds.Length != 0 && _idleSoundRandomChance > UnityEngine.Random.value && _flockChild._landing)
				{
					_audio.clip = _idleSounds[UnityEngine.Random.Range(0, _idleSounds.Length)];
					_audio.pitch = UnityEngine.Random.Range(_pitchMin, _pitchMax);
					_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
					_audio.Play();
					_hasLanded = true;
				}
			}
		}

		public void ScareSound()
		{
			if (base.gameObject.activeInHierarchy && _hasLanded && !_flockChild._landing && _idleSoundRandomChance * 2f > UnityEngine.Random.value)
			{
				_audio.clip = _scareSounds[UnityEngine.Random.Range(0, _scareSounds.Length)];
				_audio.volume = UnityEngine.Random.Range(_volumeMin, _volumeMax);
				_audio.PlayDelayed(UnityEngine.Random.value * 0.2f);
				_hasLanded = false;
			}
		}
	}
	public class FlockController : MonoBehaviour
	{
		public FlockChild _childPrefab;

		public int _childAmount = 250;

		public bool _slowSpawn;

		public float _spawnSphere = 3f;

		public float _spawnSphereHeight = 3f;

		public float _spawnSphereDepth = -1f;

		public float _minSpeed = 6f;

		public float _maxSpeed = 10f;

		public float _minScale = 0.7f;

		public float _maxScale = 1f;

		public float _soarFrequency;

		public string _soarAnimation = "Soar";

		public string _flapAnimation = "Flap";

		public string _idleAnimation = "Idle";

		public float _diveValue = 7f;

		public float _diveFrequency = 0.5f;

		public float _minDamping = 1f;

		public float _maxDamping = 2f;

		public float _waypointDistance = 1f;

		public float _minAnimationSpeed = 2f;

		public float _maxAnimationSpeed = 4f;

		public float _randomPositionTimer = 10f;

		public float _positionSphere = 25f;

		public float _positionSphereHeight = 25f;

		public float _positionSphereDepth = -1f;

		public bool _childTriggerPos;

		public bool _forceChildWaypoints;

		public float _forcedRandomDelay = 1.5f;

		public bool _flatFly;

		public bool _flatSoar;

		public bool _birdAvoid;

		public int _birdAvoidHorizontalForce = 1000;

		public bool _birdAvoidDown;

		public bool _birdAvoidUp;

		public int _birdAvoidVerticalForce = 300;

		public float _birdAvoidDistanceMax = 4.5f;

		public float _birdAvoidDistanceMin = 5f;

		public float _soarMaxTime;

		public LayerMask _avoidanceMask = -1;

		public List<FlockChild> _roamers;

		public Vector3 _posBuffer;

		public int _updateDivisor = 1;

		public float _newDelta;

		public int _updateCounter;

		public float _activeChildren;

		public bool _groupChildToNewTransform;

		public Transform _groupTransform;

		public string _groupName = "";

		public bool _groupChildToFlock;

		public Vector3 _startPosOffset;

		public Transform _thisT;

		public void Start()
		{
			_thisT = base.transform;
			if (_positionSphereDepth == -1f)
			{
				_positionSphereDepth = _positionSphere;
			}
			if (_spawnSphereDepth == -1f)
			{
				_spawnSphereDepth = _spawnSphere;
			}
			_posBuffer = _thisT.position + _startPosOffset;
			if (!_slowSpawn)
			{
				AddChild(_childAmount);
			}
			if (_randomPositionTimer > 0f)
			{
				InvokeRepeating("SetFlockRandomPosition", _randomPositionTimer, _randomPositionTimer);
			}
		}

		public void AddChild(int amount)
		{
			if (_groupChildToNewTransform)
			{
				InstantiateGroup();
			}
			for (int i = 0; i < amount; i++)
			{
				FlockChild flockChild = UnityEngine.Object.Instantiate(_childPrefab);
				flockChild._spawner = this;
				_roamers.Add(flockChild);
				AddChildToParent(flockChild.transform);
			}
		}

		public void AddChildToParent(Transform obj)
		{
			if (_groupChildToFlock)
			{
				obj.parent = base.transform;
			}
			else if (_groupChildToNewTransform)
			{
				obj.parent = _groupTransform;
			}
		}

		public void RemoveChild(int amount)
		{
			for (int i = 0; i < amount; i++)
			{
				FlockChild flockChild = _roamers[_roamers.Count - 1];
				_roamers.RemoveAt(_roamers.Count - 1);
				UnityEngine.Object.Destroy(flockChild.gameObject);
			}
		}

		public void Update()
		{
			if (_activeChildren > 0f)
			{
				if (_updateDivisor > 1)
				{
					_updateCounter++;
					_updateCounter %= _updateDivisor;
					_newDelta = Time.deltaTime * (float)_updateDivisor;
				}
				else
				{
					_newDelta = Time.deltaTime;
				}
			}
			UpdateChildAmount();
		}

		public void InstantiateGroup()
		{
			if (!(_groupTransform != null))
			{
				GameObject gameObject = new GameObject();
				_groupTransform = gameObject.transform;
				_groupTransform.position = _thisT.position;
				if (_groupName != "")
				{
					gameObject.name = _groupName;
				}
				else
				{
					gameObject.name = _thisT.name + " Fish Container";
				}
			}
		}

		public void UpdateChildAmount()
		{
			if (_childAmount >= 0 && _childAmount < _roamers.Count)
			{
				RemoveChild(1);
			}
			else if (_childAmount > _roamers.Count)
			{
				AddChild(1);
			}
		}

		public void OnDrawGizmos()
		{
			if (_thisT == null)
			{
				_thisT = base.transform;
			}
			if (!Application.isPlaying && _posBuffer != _thisT.position + _startPosOffset)
			{
				_posBuffer = _thisT.position + _startPosOffset;
			}
			if (_positionSphereDepth == -1f)
			{
				_positionSphereDepth = _positionSphere;
			}
			if (_spawnSphereDepth == -1f)
			{
				_spawnSphereDepth = _spawnSphere;
			}
			Gizmos.color = Color.blue;
			Gizmos.DrawWireCube(_posBuffer, new Vector3(_spawnSphere * 2f, _spawnSphereHeight * 2f, _spawnSphereDepth * 2f));
			Gizmos.color = Color.cyan;
			Gizmos.DrawWireCube(_thisT.position, new Vector3(_positionSphere * 2f + _spawnSphere * 2f, _positionSphereHeight * 2f + _spawnSphereHeight * 2f, _positionSphereDepth * 2f + _spawnSphereDepth * 2f));
		}

		public void SetFlockRandomPosition()
		{
			Vector3 zero = Vector3.zero;
			zero.x = UnityEngine.Random.Range(0f - _positionSphere, _positionSphere) + _thisT.position.x;
			zero.z = UnityEngine.Random.Range(0f - _positionSphereDepth, _positionSphereDepth) + _thisT.position.z;
			zero.y = UnityEngine.Random.Range(0f - _positionSphereHeight, _positionSphereHeight) + _thisT.position.y;
			_posBuffer = zero;
			if (_forceChildWaypoints)
			{
				for (int i = 0; i < _roamers.Count; i++)
				{
					_roamers[i].Wander(UnityEngine.Random.value * _forcedRandomDelay);
				}
			}
		}

		public void destroyBirds()
		{
			for (int i = 0; i < _roamers.Count; i++)
			{
				UnityEngine.Object.Destroy(_roamers[i].gameObject);
			}
			_childAmount = 0;
			_roamers.Clear();
		}
	}
	public class FlockScare : MonoBehaviour
	{
		public LandingSpotController[] landingSpotControllers;

		public float scareInterval = 0.1f;

		public float distanceToScare = 2f;

		public int checkEveryNthLandingSpot = 1;

		public int InvokeAmounts = 1;

		private int lsc;

		private int ls;

		private LandingSpotController currentController;

		private void CheckProximityToLandingSpots()
		{
			IterateLandingSpots();
			if (currentController._activeLandingSpots > 0 && CheckDistanceToLandingSpot(landingSpotControllers[lsc]))
			{
				landingSpotControllers[lsc].ScareAll();
			}
			Invoke("CheckProximityToLandingSpots", scareInterval);
		}

		private void IterateLandingSpots()
		{
			ls += checkEveryNthLandingSpot;
			currentController = landingSpotControllers[lsc];
			int childCount = currentController.transform.childCount;
			if (ls > childCount - 1)
			{
				ls -= childCount;
				if (lsc < landingSpotControllers.Length - 1)
				{
					lsc++;
				}
				else
				{
					lsc = 0;
				}
			}
		}

		private bool CheckDistanceToLandingSpot(LandingSpotController lc)
		{
			Transform child = lc.transform.GetChild(ls);
			if (child.GetComponent<LandingSpot>().landingChild != null && (child.position - base.transform.position).sqrMagnitude < distanceToScare * distanceToScare)
			{
				return true;
			}
			return false;
		}

		private void Invoker()
		{
			for (int i = 0; i < InvokeAmounts; i++)
			{
				float num = scareInterval / (float)InvokeAmounts * (float)i;
				Invoke("CheckProximityToLandingSpots", scareInterval + num);
			}
		}

		private void OnEnable()
		{
			CancelInvoke("CheckProximityToLandingSpots");
			if (landingSpotControllers.Length != 0)
			{
				Invoker();
			}
		}

		private void OnDisable()
		{
			CancelInvoke("CheckProximityToLandingSpots");
		}
	}
	public class FlockWaypointTrigger : MonoBehaviour
	{
		public float _timer = 1f;

		public FlockChild _flockChild;

		public void Start()
		{
			if (_flockChild == null)
			{
				_flockChild = base.transform.parent.GetComponent<FlockChild>();
			}
			float num = UnityEngine.Random.Range(_timer, _timer * 3f);
			InvokeRepeating("Trigger", num, num);
		}

		public void Trigger()
		{
			_flockChild.Wander(0f);
		}
	}
	public class LandingButtons : MonoBehaviour
	{
		public LandingSpotController _landingSpotController;

		public FlockController _flockController;

		public float hSliderValue = 250f;

		public void OnGUI()
		{
			GUI.Label(new Rect(20f, 20f, 125f, 18f), "Landing Spots: " + _landingSpotController.transform.childCount);
			if (GUI.Button(new Rect(20f, 40f, 125f, 18f), "Scare All"))
			{
				_landingSpotController.ScareAll();
			}
			if (GUI.Button(new Rect(20f, 60f, 125f, 18f), "Land In Reach"))
			{
				_landingSpotController.LandAll();
			}
			if (GUI.Button(new Rect(20f, 80f, 125f, 18f), "Land Instant"))
			{
				StartCoroutine(_landingSpotController.InstantLand(0.01f));
			}
			if (GUI.Button(new Rect(20f, 100f, 125f, 18f), "Destroy"))
			{
				_flockController.destroyBirds();
			}
			GUI.Label(new Rect(20f, 120f, 125f, 18f), "Bird Amount: " + _flockController._childAmount);
			_flockController._childAmount = (int)GUI.HorizontalSlider(new Rect(20f, 140f, 125f, 18f), _flockController._childAmount, 0f, 250f);
		}
	}
	public class LandingSpot : MonoBehaviour
	{
		[HideInInspector]
		public FlockChild landingChild;

		[HideInInspector]
		public bool landing;

		private int lerpCounter;

		[HideInInspector]
		public LandingSpotController _controller;

		private bool _idle;

		public Transform _thisT;

		public bool _gotcha;

		public void Start()
		{
			if (_thisT == null)
			{
				_thisT = base.transform;
			}
			if (_controller == null)
			{
				_controller = _thisT.parent.GetComponent<LandingSpotController>();
			}
			if (_controller._autoCatchDelay.x > 0f)
			{
				StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
			}
		}

		public void OnDrawGizmos()
		{
			if (_thisT == null)
			{
				_thisT = base.transform;
			}
			if (_controller == null)
			{
				_controller = _thisT.parent.GetComponent<LandingSpotController>();
			}
			Gizmos.color = Color.yellow;
			if (landingChild != null && landing)
			{
				Gizmos.DrawLine(_thisT.position, landingChild._thisT.position);
			}
			if (_thisT.rotation.eulerAngles.x != 0f || _thisT.rotation.eulerAngles.z != 0f)
			{
				_thisT.eulerAngles = new Vector3(0f, _thisT.eulerAngles.y, 0f);
			}
			Gizmos.DrawCube(new Vector3(_thisT.position.x, _thisT.position.y, _thisT.position.z), Vector3.one * _controller._gizmoSize);
			Gizmos.DrawCube(_thisT.position + _thisT.forward * _controller._gizmoSize, Vector3.one * _controller._gizmoSize * 0.5f);
			Gizmos.color = new Color(1f, 1f, 0f, 0.05f);
			Gizmos.DrawWireSphere(_thisT.position, _controller._maxBirdDistance);
		}

		public void LateUpdate()
		{
			if (landingChild == null)
			{
				_gotcha = false;
				_idle = false;
				lerpCounter = 0;
				return;
			}
			if (_gotcha)
			{
				landingChild.transform.position = _thisT.position + landingChild._landingPosOffset;
				RotateBird();
				return;
			}
			if (_controller._flock.gameObject.activeInHierarchy && landing && landingChild != null)
			{
				if (!landingChild.gameObject.activeInHierarchy)
				{
					Invoke("ReleaseFlockChild", 0f);
				}
				float num = Vector3.Distance(landingChild._thisT.position, _thisT.position + landingChild._landingPosOffset);
				if (num < 5f && num > 0.5f)
				{
					if (_controller._soarLand)
					{
						landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._soarAnimation, 0.5f);
						if (num < 2f)
						{
							landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.5f);
						}
					}
					landingChild._targetSpeed = landingChild._spawner._maxSpeed * _controller._landingSpeedModifier;
					landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
					landingChild._damping = _controller._landingTurnSpeedModifier;
					landingChild._avoid = false;
				}
				else if (num <= 0.5f)
				{
					landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
					if (num < _controller._snapLandDistance && !_idle)
					{
						_idle = true;
						landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._idleAnimation, 0.55f);
					}
					if (num > _controller._snapLandDistance)
					{
						landingChild._targetSpeed = landingChild._spawner._minSpeed * _controller._landingSpeedModifier;
						landingChild._thisT.position += (_thisT.position + landingChild._landingPosOffset - landingChild._thisT.position) * Time.deltaTime * landingChild._speed * _controller._landingSpeedModifier * 2f;
					}
					else
					{
						_gotcha = true;
					}
					landingChild._move = false;
					RotateBird();
				}
				else
				{
					landingChild._wayPoint = _thisT.position + landingChild._landingPosOffset;
				}
				landingChild._damping += 0.01f;
			}
			StraightenBird();
		}

		public void StraightenBird()
		{
			if (landingChild._thisT.eulerAngles.x != 0f)
			{
				Vector3 eulerAngles = landingChild._thisT.eulerAngles;
				eulerAngles.z = 0f;
				landingChild._thisT.eulerAngles = eulerAngles;
			}
		}

		public void RotateBird()
		{
			if (!_controller._randomRotate || !_idle)
			{
				lerpCounter++;
				Quaternion rotation = landingChild._thisT.rotation;
				Vector3 eulerAngles = rotation.eulerAngles;
				eulerAngles.y = Mathf.LerpAngle(landingChild._thisT.rotation.eulerAngles.y, _thisT.rotation.eulerAngles.y, (float)lerpCounter * Time.deltaTime * _controller._landedRotateSpeed);
				rotation.eulerAngles = eulerAngles;
				landingChild._thisT.rotation = rotation;
			}
		}

		public IEnumerator GetFlockChild(float minDelay, float maxDelay)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(minDelay, maxDelay));
			if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
			{
				yield break;
			}
			FlockChild flockChild = null;
			for (int i = 0; i < _controller._flock._roamers.Count; i++)
			{
				FlockChild flockChild2 = _controller._flock._roamers[i];
				if (flockChild2._landing || flockChild2._dived)
				{
					continue;
				}
				if (!_controller._onlyBirdsAbove)
				{
					if (flockChild == null && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
					{
						flockChild = flockChild2;
						if (!_controller._takeClosest)
						{
							break;
						}
					}
					else if (flockChild != null && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
					{
						flockChild = flockChild2;
					}
				}
				else if (flockChild == null && flockChild2._thisT.position.y > _thisT.position.y && _controller._maxBirdDistance > Vector3.Distance(flockChild2._thisT.position, _thisT.position) && _controller._minBirdDistance < Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
					if (!_controller._takeClosest)
					{
						break;
					}
				}
				else if (flockChild != null && flockChild2._thisT.position.y > _thisT.position.y && Vector3.Distance(flockChild._thisT.position, _thisT.position) > Vector3.Distance(flockChild2._thisT.position, _thisT.position))
				{
					flockChild = flockChild2;
				}
			}
			if (flockChild != null)
			{
				landingChild = flockChild;
				landing = true;
				landingChild._landing = true;
				if (_controller._autoDismountDelay.x > 0f)
				{
					Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
				}
				_controller._activeLandingSpots++;
			}
			else if (_controller._autoCatchDelay.x > 0f)
			{
				StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
			}
		}

		public void InstantLand()
		{
			if (!_controller._flock.gameObject.activeInHierarchy || !(landingChild == null))
			{
				return;
			}
			FlockChild flockChild = null;
			for (int i = 0; i < _controller._flock._roamers.Count; i++)
			{
				FlockChild flockChild2 = _controller._flock._roamers[i];
				if (!flockChild2._landing && !flockChild2._dived)
				{
					flockChild = flockChild2;
				}
			}
			if (flockChild != null)
			{
				landingChild = flockChild;
				landing = true;
				_controller._activeLandingSpots++;
				landingChild._landing = true;
				landingChild._thisT.position = _thisT.position + landingChild._landingPosOffset;
				landingChild._model.GetComponent<Animation>().Play(landingChild._spawner._idleAnimation);
				landingChild._thisT.Rotate(Vector3.up, UnityEngine.Random.Range(0f, 360f));
				if (_controller._autoDismountDelay.x > 0f)
				{
					Invoke("ReleaseFlockChild", UnityEngine.Random.Range(_controller._autoDismountDelay.x, _controller._autoDismountDelay.y));
				}
			}
			else if (_controller._autoCatchDelay.x > 0f)
			{
				StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x, _controller._autoCatchDelay.y));
			}
		}

		public void ReleaseFlockChild()
		{
			if (_controller._flock.gameObject.activeInHierarchy && landingChild != null)
			{
				_gotcha = false;
				lerpCounter = 0;
				if (_controller._featherPS != null)
				{
					_controller._featherPS.position = landingChild._thisT.position;
					_controller._featherPS.GetComponent<ParticleSystem>().Emit(UnityEngine.Random.Range(0, 3));
				}
				landing = false;
				_idle = false;
				landingChild._avoid = true;
				landingChild._damping = landingChild._spawner._maxDamping;
				landingChild._model.GetComponent<Animation>().CrossFade(landingChild._spawner._flapAnimation, 0.2f);
				landingChild._dived = true;
				landingChild._speed = 0f;
				landingChild._move = true;
				landingChild._landing = false;
				landingChild.Flap();
				landingChild._wayPoint = new Vector3(landingChild._wayPoint.x, _thisT.position.y + 10f, landingChild._wayPoint.z);
				if (_controller._autoCatchDelay.x > 0f)
				{
					StartCoroutine(GetFlockChild(_controller._autoCatchDelay.x + 0.1f, _controller._autoCatchDelay.y + 0.1f));
				}
				landingChild = null;
				_controller._activeLandingSpots--;
			}
		}
	}
	public class LandingSpotController : MonoBehaviour
	{
		public bool _randomRotate = true;

		public Vector2 _autoCatchDelay = new Vector2(10f, 20f);

		public Vector2 _autoDismountDelay = new Vector2(10f, 20f);

		public float _maxBirdDistance = 20f;

		public float _minBirdDistance = 5f;

		public bool _takeClosest;

		public FlockController _flock;

		public bool _landOnStart;

		public bool _soarLand = true;

		public bool _onlyBirdsAbove;

		public float _landingSpeedModifier = 0.5f;

		public float _landingTurnSpeedModifier = 5f;

		public Transform _featherPS;

		public Transform _thisT;

		public int _activeLandingSpots;

		public float _snapLandDistance = 0.1f;

		public float _landedRotateSpeed = 0.01f;

		public float _gizmoSize = 0.2f;

		public void Start()
		{
			if (_thisT == null)
			{
				_thisT = base.transform;
			}
			if (_flock == null)
			{
				_flock = (FlockController)UnityEngine.Object.FindObjectOfType(typeof(FlockController));
				UnityEngine.Debug.Log(this?.ToString() + " has no assigned FlockController, a random FlockController has been assigned");
			}
			if (_landOnStart)
			{
				StartCoroutine(InstantLandOnStart(0.1f));
			}
		}

		public void ScareAll()
		{
			ScareAll(0f, 1f);
		}

		public void ScareAll(float minDelay, float maxDelay)
		{
			for (int i = 0; i < _thisT.childCount; i++)
			{
				if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
				{
					_thisT.GetChild(i).GetComponent<LandingSpot>().Invoke("ReleaseFlockChild", UnityEngine.Random.Range(minDelay, maxDelay));
				}
			}
		}

		public void LandAll()
		{
			for (int i = 0; i < _thisT.childCount; i++)
			{
				if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
				{
					LandingSpot component = _thisT.GetChild(i).GetComponent<LandingSpot>();
					StartCoroutine(component.GetFlockChild(0f, 2f));
				}
			}
		}

		public IEnumerator InstantLandOnStart(float delay)
		{
			yield return new WaitForSeconds(delay);
			for (int i = 0; i < _thisT.childCount; i++)
			{
				if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
				{
					_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
				}
			}
		}

		public IEnumerator InstantLand(float delay)
		{
			yield return new WaitForSeconds(delay);
			for (int i = 0; i < _thisT.childCount; i++)
			{
				if (_thisT.GetChild(i).GetComponent<LandingSpot>() != null)
				{
					_thisT.GetChild(i).GetComponent<LandingSpot>().InstantLand();
				}
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Anomaly")]
	public class CameraFilterPack_3D_Anomaly : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 23f;

		[Range(-0.5f, 0.99f)]
		public float Anomaly_Near = 0.045f;

		[Range(0f, 1f)]
		public float Anomaly_Far = 0.11f;

		[Range(0f, 2f)]
		public float Intensity = 1f;

		[Range(0f, 1f)]
		public float AnomalyWithoutObject = 1f;

		[Range(0.1f, 1f)]
		public float Anomaly_Distortion = 0.25f;

		[Range(4f, 64f)]
		public float Anomaly_Distortion_Size = 12f;

		[Range(-4f, 8f)]
		public float Anomaly_Intensity = 2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Anomaly");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("Anomaly_Distortion", Anomaly_Distortion);
				material.SetFloat("Anomaly_Distortion_Size", Anomaly_Distortion_Size);
				material.SetFloat("Anomaly_Intensity", Anomaly_Intensity);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("Anomaly_Near", Anomaly_Near);
				material.SetFloat("Anomaly_Far", Anomaly_Far);
				material.SetFloat("Anomaly_With_Obj", AnomalyWithoutObject);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Binary")]
	public class CameraFilterPack_3D_Binary : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 2f;

		[Range(-5f, 5f)]
		public float LightIntensity;

		[Range(0f, 8f)]
		public float MatrixSize = 2f;

		[Range(-4f, 4f)]
		public float MatrixSpeed = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float FadeFromBinary;

		public Color _MatrixColor = new Color(1f, 0.3f, 0.3f, 1f);

		public static Color ChangeColorRGB;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_3D_Binary1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/3D_Binary");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DepthLevel", Fade);
				material.SetFloat("_FadeFromBinary", FadeFromBinary);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_MatrixSize", MatrixSize);
				material.SetColor("_MatrixColor", _MatrixColor);
				material.SetFloat("_MatrixSpeed", MatrixSpeed * 2f);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_LightIntensity", LightIntensity);
				material.SetTexture("_MainTex2", Texture2);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/BlackHole")]
	public class CameraFilterPack_3D_BlackHole : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 5f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.05f;

		[Range(0f, 1f)]
		public float _Size = 0.25f;

		[Range(-2f, 2f)]
		public float DistortionLevel = 1.2f;

		[Range(0f, 1f)]
		public float DistortionSize;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_BlackHole");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_DistortionLevel", DistortionLevel);
				material.SetFloat("_DistortionSize", DistortionSize);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Computer")]
	public class CameraFilterPack_3D_Computer : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 2f;

		[Range(-5f, 5f)]
		public float LightIntensity = 1f;

		[Range(0f, 8f)]
		public float MatrixSize = 2f;

		[Range(-4f, 4f)]
		public float MatrixSpeed = 0.1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		public Color _MatrixColor = new Color(0f, 0.5f, 1f, 1f);

		public static Color ChangeColorRGB;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_3D_Computer1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/3D_Computer");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DepthLevel", Fade);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_MatrixSize", MatrixSize);
				material.SetColor("_MatrixColor", _MatrixColor);
				material.SetFloat("_MatrixSpeed", MatrixSpeed * 2f);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_LightIntensity", LightIntensity);
				material.SetTexture("_MainTex2", Texture2);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Distortion")]
	public class CameraFilterPack_3D_Distortion : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.5f;

		[Range(0f, 0.5f)]
		public float _Size = 0.1f;

		[Range(0f, 10f)]
		public float DistortionLevel = 1.2f;

		[Range(0.1f, 10f)]
		public float DistortionSize = 1.4f;

		[Range(-2f, 4f)]
		public float LightIntensity = 0.08f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Distortion");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_DistortionLevel", DistortionLevel * 28f);
				material.SetFloat("_DistortionSize", DistortionSize * 16f);
				material.SetFloat("_LightIntensity", LightIntensity * 64f);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Fog_Smoke")]
	public class CameraFilterPack_3D_Fog_Smoke : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.5f;

		[Range(0f, 0.5f)]
		public float _Size = 0.1f;

		[Range(0f, 10f)]
		public float DistortionLevel = 1.2f;

		[Range(0.1f, 10f)]
		public float DistortionSize = 1.4f;

		[Range(-2f, 4f)]
		public float LightIntensity = 0.08f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		private Texture2D Texture2;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_3D_Myst1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/3D_Myst");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_DistortionLevel", DistortionLevel * 28f);
				material.SetFloat("_DistortionSize", DistortionSize * 16f);
				material.SetFloat("_LightIntensity", LightIntensity * 64f);
				material.SetTexture("_MainTex2", Texture2);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Ghost")]
	public class CameraFilterPack_3D_Ghost : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 5f;

		[Range(-0.5f, 0.99f)]
		public float Ghost_Near = 0.08f;

		[Range(0f, 1f)]
		public float Ghost_Far = 0.55f;

		[Range(0f, 2f)]
		public float Intensity = 1f;

		[Range(0f, 1f)]
		public float GhostWithoutObject = 1f;

		[Range(-1f, 1f)]
		public float GhostPosX;

		[Range(-1f, 1f)]
		public float GhostPosY;

		[Range(0.1f, 8f)]
		public float GhostFade2 = 2f;

		[Range(-1f, 1f)]
		public float GhostFade;

		[Range(0.5f, 1.5f)]
		public float GhostSize = 0.9f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Ghost");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("GhostPosX", GhostPosX);
				material.SetFloat("GhostPosY", GhostPosY);
				material.SetFloat("GhostFade", GhostFade);
				material.SetFloat("GhostFade2", GhostFade2);
				material.SetFloat("GhostSize", GhostSize);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("Drop_Near", Ghost_Near);
				material.SetFloat("Drop_Far", Ghost_Far);
				material.SetFloat("Drop_With_Obj", GhostWithoutObject);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Inverse")]
	public class CameraFilterPack_3D_Inverse : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1.5f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.4f;

		[Range(0f, 0.5f)]
		public float _Size = 0.5f;

		[Range(0f, 1f)]
		public float LightIntensity = 1f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Inverse");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_LightIntensity", LightIntensity);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Matrix")]
	public class CameraFilterPack_3D_Matrix : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		public bool _Visualize;

		[Range(0f, 100f)]
		public float _FixDistance = 1f;

		[Range(-5f, 5f)]
		public float LightIntensity = 1f;

		[Range(0f, 6f)]
		public float MatrixSize = 1f;

		[Range(-4f, 4f)]
		public float MatrixSpeed = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		public Color _MatrixColor = new Color(0f, 1f, 0f, 1f);

		public static Color ChangeColorRGB;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_3D_Matrix1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/3D_Matrix");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DepthLevel", Fade);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_MatrixSize", MatrixSize);
				material.SetColor("_MatrixColor", _MatrixColor);
				material.SetFloat("_MatrixSpeed", MatrixSpeed * 2f);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_LightIntensity", LightIntensity);
				material.SetTexture("_MainTex2", Texture2);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Mirror")]
	public class CameraFilterPack_3D_Mirror : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1.5f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.4f;

		[Range(0f, 0.5f)]
		public float _Size = 0.5f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 2f)]
		public float Lightning = 2f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Mirror");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("Fade", Fade);
				material.SetFloat("Lightning", Lightning);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Myst")]
	public class CameraFilterPack_3D_Myst : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.5f;

		[Range(0f, 0.5f)]
		public float _Size = 0.1f;

		[Range(0f, 10f)]
		public float DistortionLevel = 1.2f;

		[Range(0.1f, 10f)]
		public float DistortionSize = 1.4f;

		[Range(-2f, 4f)]
		public float LightIntensity = 0.08f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		private Texture2D Texture2;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_3D_Myst1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/3D_Myst");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_DistortionLevel", DistortionLevel * 28f);
				material.SetFloat("_DistortionSize", DistortionSize * 16f);
				material.SetFloat("_LightIntensity", LightIntensity * 64f);
				material.SetTexture("_MainTex2", Texture2);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Scan_Scene")]
	public class CameraFilterPack_3D_Scan_Scene : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1f;

		[Range(0f, 0.99f)]
		public float _Distance = 1f;

		[Range(0f, 0.1f)]
		public float _Size = 0.01f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 1f;

		public Color ScanColor = new Color(2f, 0f, 0f, 1f);

		[Range(0f, 1f)]
		public float Fade = 1f;

		public static Color ChangeColorRGB;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Scan_Scene");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DepthLevel", Fade);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = 0f;
					}
					if (_Distance < 0f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetColor("_ColorRGB", ScanColor);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Shield")]
	public class CameraFilterPack_3D_Shield : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1.5f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.4f;

		[Range(0f, 0.5f)]
		public float _Size = 0.5f;

		[Range(0f, 1f)]
		public float _FadeShield = 0.75f;

		[Range(-0.2f, 0.2f)]
		public float LightIntensity = 0.025f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		[Range(0f, 10f)]
		public float Speed = 0.2f;

		[Range(0f, 10f)]
		public float Speed_X = 0.2f;

		[Range(0f, 1f)]
		public float Speed_Y = 0.3f;

		[Range(0f, 10f)]
		public float Intensity = 2.4f;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/3D_Shield");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_LightIntensity", LightIntensity * 64f);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_FadeShield", _FadeShield);
				material.SetFloat("_Value", Speed);
				material.SetFloat("_Value2", Speed_X);
				material.SetFloat("_Value3", Speed_Y);
				material.SetFloat("_Value4", Intensity);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/3D/Snow")]
	public class CameraFilterPack_3D_Snow : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 5f;

		[Range(-0.5f, 0.99f)]
		public float Snow_Near = 0.08f;

		[Range(0f, 1f)]
		public float Snow_Far = 0.55f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 2f)]
		public float Intensity = 1f;

		[Range(0.4f, 2f)]
		public float Size = 1f;

		[Range(0f, 0.5f)]
		public float Speed = 0.275f;

		[Range(0f, 1f)]
		public float SnowWithoutObject = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Blizzard1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/3D_Snow");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value4", Speed * 6f);
				material.SetFloat("_Value5", Size);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("Drop_Near", Snow_Near);
				material.SetFloat("Drop_Far", Snow_Far);
				material.SetFloat("Drop_With_Obj", SnowWithoutObject);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/Blood")]
	public class CameraFilterPack_AAA_Blood : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 128f)]
		public float Blood1;

		[Range(0f, 128f)]
		public float Blood2;

		[Range(0f, 128f)]
		public float Blood3;

		[Range(0f, 128f)]
		public float Blood4 = 1f;

		[Range(0f, 0.004f)]
		public float LightReflect = 0.002f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_AAA_Blood1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/AAA_Blood");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", LightReflect);
				material.SetFloat("_Value2", Blood1);
				material.SetFloat("_Value3", Blood2);
				material.SetFloat("_Value4", Blood3);
				material.SetFloat("_Value5", Blood4);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/Blood On Screen")]
	public class CameraFilterPack_AAA_BloodOnScreen : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0.02f, 1.6f)]
		public float Blood_On_Screen = 1f;

		public Color Blood_Color = Color.red;

		[Range(0f, 2f)]
		public float Blood_Intensify = 0.7f;

		[Range(0f, 2f)]
		public float Blood_Darkness = 0.5f;

		[Range(0f, 1f)]
		public float Blood_Distortion_Speed = 0.25f;

		[Range(0f, 1f)]
		public float Blood_Fade = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_AAA_BloodOnScreen1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/AAA_BloodOnScreen");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Mathf.Clamp(Blood_On_Screen, 0.02f, 1.6f));
				material.SetFloat("_Value2", Mathf.Clamp(Blood_Intensify, 0f, 2f));
				material.SetFloat("_Value3", Mathf.Clamp(Blood_Darkness, 0f, 2f));
				material.SetFloat("_Value4", Mathf.Clamp(Blood_Fade, 0f, 1f));
				material.SetFloat("_Value5", Mathf.Clamp(Blood_Distortion_Speed, 0f, 2f));
				material.SetColor("_Color2", Blood_Color);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/Blood_Hit")]
	public class CameraFilterPack_AAA_Blood_Hit : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Hit_Left = 1f;

		[Range(0f, 1f)]
		public float Hit_Up;

		[Range(0f, 1f)]
		public float Hit_Right;

		[Range(0f, 1f)]
		public float Hit_Down;

		[Range(0f, 1f)]
		public float Blood_Hit_Left;

		[Range(0f, 1f)]
		public float Blood_Hit_Up;

		[Range(0f, 1f)]
		public float Blood_Hit_Right;

		[Range(0f, 1f)]
		public float Blood_Hit_Down;

		[Range(0f, 1f)]
		public float Hit_Full;

		[Range(0f, 1f)]
		public float Blood_Hit_Full_1;

		[Range(0f, 1f)]
		public float Blood_Hit_Full_2;

		[Range(0f, 1f)]
		public float Blood_Hit_Full_3;

		[Range(0f, 1f)]
		public float LightReflect = 0.5f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_AAA_Blood_Hit1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/AAA_Blood_Hit");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", LightReflect);
				material.SetFloat("_Value2", Mathf.Clamp(Hit_Left, 0f, 1f));
				material.SetFloat("_Value3", Mathf.Clamp(Hit_Up, 0f, 1f));
				material.SetFloat("_Value4", Mathf.Clamp(Hit_Right, 0f, 1f));
				material.SetFloat("_Value5", Mathf.Clamp(Hit_Down, 0f, 1f));
				material.SetFloat("_Value6", Mathf.Clamp(Blood_Hit_Left, 0f, 1f));
				material.SetFloat("_Value7", Mathf.Clamp(Blood_Hit_Up, 0f, 1f));
				material.SetFloat("_Value8", Mathf.Clamp(Blood_Hit_Right, 0f, 1f));
				material.SetFloat("_Value9", Mathf.Clamp(Blood_Hit_Down, 0f, 1f));
				material.SetFloat("_Value10", Mathf.Clamp(Hit_Full, 0f, 1f));
				material.SetFloat("_Value11", Mathf.Clamp(Blood_Hit_Full_1, 0f, 1f));
				material.SetFloat("_Value12", Mathf.Clamp(Blood_Hit_Full_2, 0f, 1f));
				material.SetFloat("_Value13", Mathf.Clamp(Blood_Hit_Full_3, 0f, 1f));
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/Blood_Plus")]
	public class CameraFilterPack_AAA_Blood_Plus : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Blood_1 = 1f;

		[Range(0f, 1f)]
		public float Blood_2;

		[Range(0f, 1f)]
		public float Blood_3;

		[Range(0f, 1f)]
		public float Blood_4;

		[Range(0f, 1f)]
		public float Blood_5;

		[Range(0f, 1f)]
		public float Blood_6;

		[Range(0f, 1f)]
		public float Blood_7;

		[Range(0f, 1f)]
		public float Blood_8;

		[Range(0f, 1f)]
		public float Blood_9;

		[Range(0f, 1f)]
		public float Blood_10;

		[Range(0f, 1f)]
		public float Blood_11;

		[Range(0f, 1f)]
		public float Blood_12;

		[Range(0f, 1f)]
		public float LightReflect = 0.5f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_AAA_Blood2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/AAA_Blood_Plus");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", LightReflect);
				material.SetFloat("_Value2", Mathf.Clamp(Blood_1, 0f, 1f));
				material.SetFloat("_Value3", Mathf.Clamp(Blood_2, 0f, 1f));
				material.SetFloat("_Value4", Mathf.Clamp(Blood_3, 0f, 1f));
				material.SetFloat("_Value5", Mathf.Clamp(Blood_4, 0f, 1f));
				material.SetFloat("_Value6", Mathf.Clamp(Blood_5, 0f, 1f));
				material.SetFloat("_Value7", Mathf.Clamp(Blood_6, 0f, 1f));
				material.SetFloat("_Value8", Mathf.Clamp(Blood_7, 0f, 1f));
				material.SetFloat("_Value9", Mathf.Clamp(Blood_8, 0f, 1f));
				material.SetFloat("_Value10", Mathf.Clamp(Blood_9, 0f, 1f));
				material.SetFloat("_Value11", Mathf.Clamp(Blood_10, 0f, 1f));
				material.SetFloat("_Value12", Mathf.Clamp(Blood_11, 0f, 1f));
				material.SetFloat("_Value13", Mathf.Clamp(Blood_12, 0f, 1f));
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/Super Computer")]
	public class CameraFilterPack_AAA_SuperComputer : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 1f)]
		public float _AlphaHexa = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-20f, 20f)]
		public float ShapeFormula = 10f;

		[Range(0f, 6f)]
		public float Shape = 1f;

		[Range(-4f, 4f)]
		public float _BorderSize = 1f;

		public Color _BorderColor = new Color(0f, 0.2f, 1f, 1f);

		public float _SpotSize = 2.5f;

		public Vector2 center = new Vector2(0f, 0f);

		public float Radius = 0.77f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/AAA_Super_Computer");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime / 4f;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", ShapeFormula);
				material.SetFloat("_Value2", Shape);
				material.SetFloat("_PositionX", center.x);
				material.SetFloat("_PositionY", center.y);
				material.SetFloat("_Radius", Radius);
				material.SetFloat("_BorderSize", _BorderSize);
				material.SetColor("_BorderColor", _BorderColor);
				material.SetFloat("_AlphaHexa", _AlphaHexa);
				material.SetFloat("_SpotSize", _SpotSize);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/Super Hexagon")]
	public class CameraFilterPack_AAA_SuperHexagon : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 1f)]
		public float _AlphaHexa = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.2f, 10f)]
		public float HexaSize = 2.5f;

		public float _BorderSize = 1f;

		public Color _BorderColor = new Color(0.75f, 0.75f, 1f, 1f);

		public Color _HexaColor = new Color(0f, 0.5f, 1f, 1f);

		public float _SpotSize = 2.5f;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		public float Radius = 0.25f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/AAA_Super_Hexagon");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", HexaSize);
				material.SetFloat("_PositionX", center.x);
				material.SetFloat("_PositionY", center.y);
				material.SetFloat("_Radius", Radius);
				material.SetFloat("_BorderSize", _BorderSize);
				material.SetColor("_BorderColor", _BorderColor);
				material.SetColor("_HexaColor", _HexaColor);
				material.SetFloat("_AlphaHexa", _AlphaHexa);
				material.SetFloat("_SpotSize", _SpotSize);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/WaterDrop")]
	public class CameraFilterPack_AAA_WaterDrop : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(8f, 64f)]
		public float Distortion = 8f;

		[Range(0f, 7f)]
		public float SizeX = 1f;

		[Range(0f, 7f)]
		public float SizeY = 0.5f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_WaterDrop") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/AAA_WaterDrop");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_SizeX", SizeX);
				material.SetFloat("_SizeY", SizeY);
				material.SetFloat("_Speed", Speed);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/AAA/WaterDropPro")]
	public class CameraFilterPack_AAA_WaterDropPro : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(8f, 64f)]
		public float Distortion = 8f;

		[Range(0f, 7f)]
		public float SizeX = 1f;

		[Range(0f, 7f)]
		public float SizeY = 0.5f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_WaterDrop") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/AAA_WaterDropPro");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_SizeX", SizeX);
				material.SetFloat("_SizeY", SizeY);
				material.SetFloat("_Speed", Speed);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Alien/Vision")]
	public class CameraFilterPack_Alien_Vision : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.5f)]
		public float Therma_Variation = 0.5f;

		[Range(0f, 1f)]
		public float Speed = 0.5f;

		[Range(0f, 4f)]
		private float Burn;

		[Range(0f, 16f)]
		private float SceneCut = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Alien_Vision");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Therma_Variation);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", Burn);
				material.SetFloat("_Value4", SceneCut);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Antialiasing/FXAA")]
	public class CameraFilterPack_Antialiasing_FXAA : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Antialiasing_FXAA");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Weather/Fog")]
	public class CameraFilterPack_Atmosphere_Fog : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float _Near;

		[Range(0f, 1f)]
		public float _Far = 0.05f;

		public Color FogColor = new Color(0.4f, 0.4f, 0.4f, 1f);

		[Range(0f, 1f)]
		public float Fade = 1f;

		public static Color ChangeColorRGB;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Atmosphere_Fog");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DepthLevel", Fade);
				material.SetFloat("_Near", _Near);
				material.SetFloat("_Far", _Far);
				material.SetColor("_ColorRGB", FogColor);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Weather/Rain")]
	public class CameraFilterPack_Atmosphere_Rain : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 2f)]
		public float Intensity = 0.5f;

		[Range(-0.25f, 0.25f)]
		public float DirectionX = 0.12f;

		[Range(0.4f, 2f)]
		public float Size = 1.5f;

		[Range(0f, 0.5f)]
		public float Speed = 0.275f;

		[Range(0f, 0.5f)]
		public float Distortion = 0.05f;

		[Range(0f, 1f)]
		public float StormFlashOnOff = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Atmosphere_Rain");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value3", DirectionX);
				material.SetFloat("_Value4", Speed);
				material.SetFloat("_Value5", Size);
				material.SetFloat("_Value6", Distortion);
				material.SetFloat("_Value7", StormFlashOnOff);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Weather/Rain_Pro")]
	public class CameraFilterPack_Atmosphere_Rain_Pro : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 2f)]
		public float Intensity = 0.5f;

		[Range(-0.25f, 0.25f)]
		public float DirectionX = 0.12f;

		[Range(0.4f, 2f)]
		public float Size = 1.5f;

		[Range(0f, 0.5f)]
		public float Speed = 0.275f;

		[Range(0f, 0.5f)]
		public float Distortion = 0.025f;

		[Range(0f, 1f)]
		public float StormFlashOnOff = 1f;

		[Range(0f, 1f)]
		public float DropOnOff = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Atmosphere_Rain_Pro");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value3", DirectionX);
				material.SetFloat("_Value4", Speed);
				material.SetFloat("_Value5", Size);
				material.SetFloat("_Value6", Distortion);
				material.SetFloat("_Value7", StormFlashOnOff);
				material.SetFloat("_Value8", DropOnOff);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Weather/Rain_Pro_3D")]
	public class CameraFilterPack_Atmosphere_Rain_Pro_3D : MonoBehaviour
	{
		public Shader SCShader;

		public bool _Visualize;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 3f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 2f)]
		public float Intensity = 0.5f;

		public bool DirectionFollowCameraZ;

		[Range(-0.45f, 0.45f)]
		public float DirectionX = 0.12f;

		[Range(0.4f, 2f)]
		public float Size = 1.5f;

		[Range(0f, 0.5f)]
		public float Speed = 0.275f;

		[Range(0f, 0.5f)]
		public float Distortion = 0.025f;

		[Range(0f, 1f)]
		public float StormFlashOnOff = 1f;

		[Range(0f, 1f)]
		public float DropOnOff = 1f;

		[Range(-0.5f, 0.99f)]
		public float Drop_Near;

		[Range(0f, 1f)]
		public float Drop_Far = 0.5f;

		[Range(0f, 1f)]
		public float Drop_With_Obj = 0.2f;

		[Range(0f, 1f)]
		public float Myst = 0.1f;

		[Range(0f, 1f)]
		public float Drop_Floor_Fluid;

		public Color Myst_Color = new Color(0.5f, 0.5f, 0.5f, 1f);

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Atmosphere_Rain_FX") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Atmosphere_Rain_Pro_3D");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Intensity);
				if (DirectionFollowCameraZ)
				{
					float z = GetComponent<Camera>().transform.rotation.z;
					if (z > 0f && z < 360f)
					{
						material.SetFloat("_Value3", z);
					}
					if (z < 0f)
					{
						material.SetFloat("_Value3", z);
					}
				}
				else
				{
					material.SetFloat("_Value3", DirectionX);
				}
				material.SetFloat("_Value4", Speed);
				material.SetFloat("_Value5", Size);
				material.SetFloat("_Value6", Distortion);
				material.SetFloat("_Value7", StormFlashOnOff);
				material.SetFloat("_Value8", DropOnOff);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				material.SetFloat("Drop_Near", Drop_Near);
				material.SetFloat("Drop_Far", Drop_Far);
				material.SetFloat("Drop_With_Obj", 1f - Drop_With_Obj);
				material.SetFloat("Myst", Myst);
				material.SetColor("Myst_Color", Myst_Color);
				material.SetFloat("Drop_Floor_Fluid", Drop_Floor_Fluid);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixel/Snow_8bits")]
	public class CameraFilterPack_Atmosphere_Snow_8bits : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.9f, 2f)]
		public float Threshold = 1f;

		[Range(8f, 256f)]
		public float Size = 64f;

		[Range(-0.5f, 0.5f)]
		public float DirectionX;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Atmosphere_Snow_8bits");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Threshold);
				material.SetFloat("_Value2", Size);
				material.SetFloat("_Value3", DirectionX);
				material.SetFloat("_Value4", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Blend")]
	public class CameraFilterPack_Blend2Camera_Blend : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Blend";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetTexture("_MainTex2", Camera2tex);
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Chroma Key/BlueScreen")]
	public class CameraFilterPack_Blend2Camera_BlueScreen : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_BlueScreen";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float BlendFX = 1f;

		[Range(-0.2f, 0.2f)]
		public float Adjust;

		[Range(-0.2f, 0.2f)]
		public float Precision;

		[Range(-0.2f, 0.2f)]
		public float Luminosity;

		[Range(-0.3f, 0.3f)]
		public float Change_Red;

		[Range(-0.3f, 0.3f)]
		public float Change_Green;

		[Range(-0.3f, 0.3f)]
		public float Change_Blue;

		private RenderTexture Camera2tex;

		private Vector2 ScreenSize;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void OnValidate()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", Adjust);
				material.SetFloat("_Value3", Precision);
				material.SetFloat("_Value4", Luminosity);
				material.SetFloat("_Value5", Change_Red);
				material.SetFloat("_Value6", Change_Green);
				material.SetFloat("_Value7", Change_Blue);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
			_ = Application.isPlaying;
		}

		private void OnEnable()
		{
			Start();
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Color")]
	public class CameraFilterPack_Blend2Camera_Color : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Color";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/ColorBurn")]
	public class CameraFilterPack_Blend2Camera_ColorBurn : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_ColorBurn";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/ColorDodge")]
	public class CameraFilterPack_Blend2Camera_ColorDodge : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_ColorDodge";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Chroma Key/Color Key")]
	public class CameraFilterPack_Blend2Camera_ColorKey : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_ColorKey";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float BlendFX = 1f;

		public Color ColorKey;

		[Range(-0.2f, 0.2f)]
		public float Adjust;

		[Range(-0.2f, 0.2f)]
		public float Precision;

		[Range(-0.2f, 0.2f)]
		public float Luminosity;

		[Range(-0.3f, 0.3f)]
		public float Change_Red;

		[Range(-0.3f, 0.3f)]
		public float Change_Green;

		[Range(-0.3f, 0.3f)]
		public float Change_Blue;

		private RenderTexture Camera2tex;

		private Vector2 ScreenSize;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", Adjust);
				material.SetFloat("_Value3", Precision);
				material.SetFloat("_Value4", Luminosity);
				material.SetFloat("_Value5", Change_Red);
				material.SetFloat("_Value6", Change_Green);
				material.SetFloat("_Value7", Change_Blue);
				material.SetColor("_ColorKey", ColorKey);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
			_ = Application.isPlaying;
		}

		private void OnEnable()
		{
			Start();
			Update();
		}

		private void OnDisable()
		{
			if (Camera2 != null && Camera2.targetTexture != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Darken")]
	public class CameraFilterPack_Blend2Camera_Darken : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Darken";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/DarkerColor")]
	public class CameraFilterPack_Blend2Camera_DarkerColor : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_DarkerColor";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Difference")]
	public class CameraFilterPack_Blend2Camera_Difference : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Difference";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Divide")]
	public class CameraFilterPack_Blend2Camera_Divide : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Divide";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Exclusion")]
	public class CameraFilterPack_Blend2Camera_Exclusion : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Exclusion";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Chroma Key/GreenScreen")]
	public class CameraFilterPack_Blend2Camera_GreenScreen : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_GreenScreen";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float BlendFX = 1f;

		[Range(-0.2f, 0.2f)]
		public float Adjust;

		[Range(-0.2f, 0.2f)]
		public float Precision;

		[Range(-0.2f, 0.2f)]
		public float Luminosity;

		[Range(-0.3f, 0.3f)]
		public float Change_Red;

		[Range(-0.3f, 0.3f)]
		public float Change_Green;

		[Range(-0.3f, 0.3f)]
		public float Change_Blue;

		private RenderTexture Camera2tex;

		private Vector2 ScreenSize;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", Adjust);
				material.SetFloat("_Value3", Precision);
				material.SetFloat("_Value4", Luminosity);
				material.SetFloat("_Value5", Change_Red);
				material.SetFloat("_Value6", Change_Green);
				material.SetFloat("_Value7", Change_Blue);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
			_ = Application.isPlaying;
		}

		private void OnEnable()
		{
			Start();
			Update();
		}

		private void OnDisable()
		{
			if (Camera2 != null && Camera2.targetTexture != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/HardLight")]
	public class CameraFilterPack_Blend2Camera_HardLight : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_HardLight";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/HardMix")]
	public class CameraFilterPack_Blend2Camera_HardMix : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_HardMix";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Hue")]
	public class CameraFilterPack_Blend2Camera_Hue : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Hue";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Lighten")]
	public class CameraFilterPack_Blend2Camera_Lighten : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Lighten";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LighterColor")]
	public class CameraFilterPack_Blend2Camera_LighterColor : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_LighterColor";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LinearBurn")]
	public class CameraFilterPack_Blend2Camera_LinearBurn : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_LinearBurn";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LinearDodge")]
	public class CameraFilterPack_Blend2Camera_LinearDodge : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_LinearDodge";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/LinearLight")]
	public class CameraFilterPack_Blend2Camera_LinearLight : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_LinearLight";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Luminosity")]
	public class CameraFilterPack_Blend2Camera_Luminosity : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Luminosity";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Multiply")]
	public class CameraFilterPack_Blend2Camera_Multiply : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Multiply";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Overlay")]
	public class CameraFilterPack_Blend2Camera_Overlay : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Overlay";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/PhotoshopFilters")]
	public class CameraFilterPack_Blend2Camera_PhotoshopFilters : MonoBehaviour
	{
		public enum filters
		{
			Darken,
			Multiply,
			ColorBurn,
			LinearBurn,
			DarkerColor,
			Lighten,
			Screen,
			ColorDodge,
			LinearDodge,
			LighterColor,
			Overlay,
			SoftLight,
			HardLight,
			VividLight,
			LinearLight,
			PinLight,
			HardMix,
			Difference,
			Exclusion,
			Subtract,
			Divide,
			Hue,
			Saturation,
			Color,
			Luminosity
		}

		private string ShaderName = "CameraFilterPack/Blend2Camera_Darken";

		public Shader SCShader;

		public Camera Camera2;

		public filters filterchoice;

		private filters filterchoicememo;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void ChangeFilters()
		{
			if (filterchoice == filters.Darken)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Darken";
			}
			if (filterchoice == filters.Multiply)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Multiply";
			}
			if (filterchoice == filters.ColorBurn)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_ColorBurn";
			}
			if (filterchoice == filters.LinearBurn)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_LinearBurn";
			}
			if (filterchoice == filters.DarkerColor)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_DarkerColor";
			}
			if (filterchoice == filters.Lighten)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Lighten";
			}
			if (filterchoice == filters.Screen)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Screen";
			}
			if (filterchoice == filters.ColorDodge)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_ColorDodge";
			}
			if (filterchoice == filters.LinearDodge)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_LinearDodge";
			}
			if (filterchoice == filters.LighterColor)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_LighterColor";
			}
			if (filterchoice == filters.Overlay)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Overlay";
			}
			if (filterchoice == filters.SoftLight)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_SoftLight";
			}
			if (filterchoice == filters.HardLight)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_HardLight";
			}
			if (filterchoice == filters.VividLight)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_VividLight";
			}
			if (filterchoice == filters.LinearLight)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_LinearLight";
			}
			if (filterchoice == filters.PinLight)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_PinLight";
			}
			if (filterchoice == filters.HardMix)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_HardMix";
			}
			if (filterchoice == filters.Difference)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Difference";
			}
			if (filterchoice == filters.Exclusion)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Exclusion";
			}
			if (filterchoice == filters.Subtract)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Subtract";
			}
			if (filterchoice == filters.Divide)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Divide";
			}
			if (filterchoice == filters.Hue)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Hue";
			}
			if (filterchoice == filters.Saturation)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Saturation";
			}
			if (filterchoice == filters.Color)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Color";
			}
			if (filterchoice == filters.Luminosity)
			{
				ShaderName = "CameraFilterPack/Blend2Camera_Luminosity";
			}
		}

		private void Start()
		{
			filterchoicememo = filterchoice;
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			ChangeFilters();
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (filterchoice != filterchoicememo)
			{
				ChangeFilters();
				SCShader = Shader.Find(ShaderName);
				UnityEngine.Object.DestroyImmediate(SCMaterial);
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
			}
			filterchoicememo = filterchoice;
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/PinLight")]
	public class CameraFilterPack_Blend2Camera_PinLight : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_PinLight";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Saturation")]
	public class CameraFilterPack_Blend2Camera_Saturation : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Saturation";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Screen")]
	public class CameraFilterPack_Blend2Camera_Screen : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Screen";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/SoftLight")]
	public class CameraFilterPack_Blend2Camera_SoftLight : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_SoftLight";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Split Screen/SideBySide")]
	public class CameraFilterPack_Blend2Camera_SplitScreen : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_SplitScreen";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 1f;

		[Range(-3f, 3f)]
		public float SplitX = 0.5f;

		[Range(-3f, 3f)]
		public float SplitY = 0.5f;

		[Range(0f, 2f)]
		public float Smooth = 0.1f;

		[Range(-3.14f, 3.14f)]
		public float Rotation = 3.14f;

		private bool ForceYSwap;

		private RenderTexture Camera2tex;

		private Vector2 ScreenSize;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void OnValidate()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetFloat("_Value3", SplitX);
				material.SetFloat("_Value6", SplitY);
				material.SetFloat("_Value4", Smooth);
				material.SetFloat("_Value5", Rotation);
				material.SetInt("_ForceYSwap", (!ForceYSwap) ? 1 : 0);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
		}

		private void OnEnable()
		{
			Start();
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Split Screen/Split 3D")]
	public class CameraFilterPack_Blend2Camera_SplitScreen3D : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_SplitScreen3D";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.5f;

		[Range(0f, 0.5f)]
		public float _Size = 0.1f;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 1f;

		[Range(-3f, 3f)]
		public float SplitX = 0.5f;

		[Range(-3f, 3f)]
		public float SplitY = 0.5f;

		[Range(0f, 2f)]
		public float Smooth = 0.1f;

		[Range(-3.14f, 3.14f)]
		public float Rotation = 3.14f;

		private bool ForceYSwap;

		private RenderTexture Camera2tex;

		private Vector2 ScreenSize;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void OnValidate()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture((int)ScreenSize.x, (int)ScreenSize.y, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_Near", _Distance);
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetFloat("_Value3", SplitX);
				material.SetFloat("_Value6", SplitY);
				material.SetFloat("_Value4", Smooth);
				material.SetFloat("_Value5", Rotation);
				material.SetInt("_ForceYSwap", (!ForceYSwap) ? 1 : 0);
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			ScreenSize.x = Screen.width;
			ScreenSize.y = Screen.height;
		}

		private void OnEnable()
		{
			Start();
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/Subtract")]
	public class CameraFilterPack_Blend2Camera_Subtract : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_Subtract";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blend 2 Camera/VividLight")]
	public class CameraFilterPack_Blend2Camera_VividLight : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Blend2Camera_VividLight";

		public Shader SCShader;

		public Camera Camera2;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float SwitchCameraToCamera2;

		[Range(0f, 1f)]
		public float BlendFX = 0.5f;

		private RenderTexture Camera2tex;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (Camera2 != null)
				{
					material.SetTexture("_MainTex2", Camera2tex);
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", BlendFX);
				material.SetFloat("_Value2", SwitchCameraToCamera2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void Update()
		{
		}

		private void OnEnable()
		{
			if (Camera2 != null)
			{
				Camera2tex = new RenderTexture(Screen.width, Screen.height, 24);
				Camera2.targetTexture = Camera2tex;
			}
		}

		private void OnDisable()
		{
			if (Camera2 != null)
			{
				Camera2.targetTexture = null;
			}
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Weather/Blizzard")]
	public class CameraFilterPack_Blizzard : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 2f)]
		public float _Speed = 1f;

		[Range(0.2f, 2f)]
		public float _Size = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Blizzard1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Blizzard");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", _Speed);
				material.SetFloat("_Value2", _Size);
				material.SetFloat("_Value3", _Fade);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Bloom")]
	public class CameraFilterPack_Blur_Bloom : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Amount = 4.5f;

		[Range(0f, 1f)]
		public float Glow = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Bloom");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetFloat("_Glow", Glow);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Blur Hole")]
	public class CameraFilterPack_Blur_BlurHole : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 16f)]
		public float Size = 10f;

		[Range(-1f, 1f)]
		public float _Radius = 0.25f;

		[Range(-4f, 4f)]
		public float _SpotSize = 1f;

		[Range(0f, 1f)]
		public float _CenterX = 0.5f;

		[Range(0f, 1f)]
		public float _CenterY = 0.5f;

		[Range(0f, 1f)]
		public float _AlphaBlur = 1f;

		[Range(0f, 1f)]
		public float _AlphaBlurInside;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/BlurHole");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Size);
				material.SetFloat("_Radius", _Radius);
				material.SetFloat("_SpotSize", _SpotSize);
				material.SetFloat("_CenterX", _CenterX);
				material.SetFloat("_CenterY", _CenterY);
				material.SetFloat("_Alpha", _AlphaBlur);
				material.SetFloat("_Alpha2", _AlphaBlurInside);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Blurry")]
	public class CameraFilterPack_Blur_Blurry : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		public float Amount = 2f;

		[Range(1f, 8f)]
		public int FastFilter = 2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Blurry");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					temporary.filterMode = FilterMode.Trilinear;
					Graphics.Blit(sourceTexture, temporary, material);
					Graphics.Blit(temporary, destTexture);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/DitherOffset")]
	public class CameraFilterPack_Blur_DitherOffset : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 16f)]
		public int Level = 4;

		public Vector2 Distance = new Vector2(30f, 0f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_DitherOffset");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Level", Level);
				material.SetVector("_Distance", Distance);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Dithering2x2")]
	public class CameraFilterPack_Blur_Dithering2x2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(2f, 16f)]
		public int Level = 4;

		public Vector2 Distance = new Vector2(30f, 0f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Dithering2x2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Level", Level);
				material.SetVector("_Distance", Distance);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Focus")]
	public class CameraFilterPack_Blur_Focus : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float CenterX;

		[Range(-1f, 1f)]
		public float CenterY;

		[Range(0f, 10f)]
		public float _Size = 5f;

		[Range(0.12f, 64f)]
		public float _Eyes = 2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Focus");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_CenterX", CenterX);
				material.SetFloat("_CenterY", CenterY);
				float value = Mathf.Round(_Size / 0.2f) * 0.2f;
				material.SetFloat("_Size", value);
				material.SetFloat("_Circle", _Eyes);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/GaussianBlur")]
	public class CameraFilterPack_Blur_GaussianBlur : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 16f)]
		public float Size = 10f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_GaussianBlur");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Size);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Movie")]
	public class CameraFilterPack_Blur_Movie : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1000f)]
		public float Radius = 150f;

		[Range(0f, 1000f)]
		public float Factor = 200f;

		[Range(1f, 8f)]
		public int FastFilter = 2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Movie");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Radius", Radius / (float)fastFilter);
				material.SetFloat("_Factor", Factor);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					Graphics.Blit(sourceTexture, temporary, material);
					Graphics.Blit(temporary, destTexture);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Noise")]
	public class CameraFilterPack_Blur_Noise : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(2f, 16f)]
		public int Level = 4;

		public Vector2 Distance = new Vector2(30f, 0f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Noise");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Level", Level);
				material.SetVector("_Distance", Distance);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Radial")]
	public class CameraFilterPack_Blur_Radial : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-0.5f, 0.5f)]
		public float Intensity = 0.125f;

		[Range(-2f, 2f)]
		public float MovX = 0.5f;

		[Range(-2f, 2f)]
		public float MovY = 0.5f;

		[Range(0f, 10f)]
		private float blurWidth = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Radial");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Intensity);
				material.SetFloat("_Value2", MovX);
				material.SetFloat("_Value3", MovY);
				material.SetFloat("_Value4", blurWidth);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Radial_Fast")]
	public class CameraFilterPack_Blur_Radial_Fast : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-0.5f, 0.5f)]
		public float Intensity = 0.125f;

		[Range(-2f, 2f)]
		public float MovX = 0.5f;

		[Range(-2f, 2f)]
		public float MovY = 0.5f;

		[Range(0f, 10f)]
		private float blurWidth = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Radial_Fast");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Intensity);
				material.SetFloat("_Value2", MovX);
				material.SetFloat("_Value3", MovY);
				material.SetFloat("_Value4", blurWidth);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Regular")]
	public class CameraFilterPack_Blur_Regular : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 16f)]
		public int Level = 4;

		public Vector2 Distance = new Vector2(30f, 0f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Regular");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Level", Level);
				material.SetVector("_Distance", Distance);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Steam")]
	public class CameraFilterPack_Blur_Steam : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Radius = 0.1f;

		[Range(0f, 1f)]
		public float Quality = 0.75f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Blur_Steam");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Radius", Radius);
				material.SetFloat("_Quality", Quality);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Tilt_Shift")]
	public class CameraFilterPack_Blur_Tilt_Shift : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		public float Amount = 3f;

		[Range(2f, 16f)]
		public int FastFilter = 8;

		[Range(0f, 1f)]
		public float Smooth = 0.5f;

		[Range(0f, 1f)]
		public float Size = 0.5f;

		[Range(-1f, 1f)]
		public float Position = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/BlurTiltShift");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetFloat("_Value1", Smooth);
				material.SetFloat("_Value2", Size);
				material.SetFloat("_Value3", Position);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
					temporary.filterMode = FilterMode.Trilinear;
					Graphics.Blit(sourceTexture, temporary, material, 2);
					Graphics.Blit(temporary, temporary2, material, 0);
					material.SetFloat("_Amount", Amount * 2f);
					Graphics.Blit(temporary2, temporary, material, 2);
					Graphics.Blit(temporary, temporary2, material, 0);
					material.SetTexture("_MainTex2", temporary2);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(temporary2);
					Graphics.Blit(sourceTexture, destTexture, material, 1);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material, 0);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Tilt_Shift_Hole")]
	public class CameraFilterPack_Blur_Tilt_Shift_Hole : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		public float Amount = 3f;

		[Range(2f, 16f)]
		public int FastFilter = 8;

		[Range(0f, 1f)]
		public float Smooth = 0.5f;

		[Range(0f, 1f)]
		public float Size = 0.2f;

		[Range(-1f, 1f)]
		public float PositionX = 0.5f;

		[Range(-1f, 1f)]
		public float PositionY = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/BlurTiltShift_Hole");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetFloat("_Value1", Smooth);
				material.SetFloat("_Value2", Size);
				material.SetFloat("_Value3", PositionX);
				material.SetFloat("_Value4", PositionY);
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
					temporary.filterMode = FilterMode.Trilinear;
					Graphics.Blit(sourceTexture, temporary, material, 2);
					Graphics.Blit(temporary, temporary2, material, 0);
					material.SetFloat("_Amount", Amount * 2f);
					Graphics.Blit(temporary2, temporary, material, 2);
					Graphics.Blit(temporary, temporary2, material, 0);
					material.SetTexture("_MainTex2", temporary2);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(temporary2);
					Graphics.Blit(sourceTexture, destTexture, material, 1);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material, 0);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Blur/Tilt_Shift_V")]
	public class CameraFilterPack_Blur_Tilt_Shift_V : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		public float Amount = 3f;

		[Range(2f, 16f)]
		public int FastFilter = 8;

		[Range(0f, 1f)]
		public float Smooth = 0.5f;

		[Range(0f, 1f)]
		public float Size = 0.5f;

		[Range(-1f, 1f)]
		public float Position = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/BlurTiltShift_V");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetFloat("_Value1", Smooth);
				material.SetFloat("_Value2", Size);
				material.SetFloat("_Value3", Position);
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
					temporary.filterMode = FilterMode.Trilinear;
					Graphics.Blit(sourceTexture, temporary, material, 2);
					Graphics.Blit(temporary, temporary2, material, 0);
					material.SetFloat("_Amount", Amount * 2f);
					Graphics.Blit(temporary2, temporary, material, 2);
					Graphics.Blit(temporary, temporary2, material, 0);
					material.SetTexture("_MainTex2", temporary2);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(temporary2);
					Graphics.Blit(sourceTexture, destTexture, material, 1);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material, 0);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Broken/Broken_Screen")]
	public class CameraFilterPack_Broken_Screen : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(-1f, 1f)]
		public float Shadow = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Broken_Screen1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Broken_Screen");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", Fade);
				material.SetFloat("_Shadow", Shadow);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Broken/Simple")]
	public class CameraFilterPack_Broken_Simple : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _Broke1 = 1f;

		[Range(0f, 1f)]
		public float _Broke2 = 1f;

		[Range(0f, 1f)]
		public float _PosX = 0.5f;

		[Range(0f, 1f)]
		public float _PosY = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_Broken_Simple");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("Broke1", _Broke1);
				material.SetFloat("Broke2", _Broke2);
				material.SetFloat("PosX", _PosX);
				material.SetFloat("PosY", _PosY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Broken/Spliter")]
	public class CameraFilterPack_Broken_Spliter : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		private float __Speed = 1f;

		[Range(0f, 1f)]
		public float _PosX = 0.5f;

		[Range(0f, 1f)]
		public float _PosY = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_Broken_Spliter");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("PosX", _PosX);
				material.SetFloat("PosY", _PosY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Classic/ThermalVision")]
	public class CameraFilterPack_Classic_ThermalVision : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		[Range(0f, 1f)]
		public float _Crt = 1f;

		[Range(0f, 1f)]
		public float _Curve = 1f;

		[Range(0f, 1f)]
		public float _Color1 = 1f;

		[Range(0f, 1f)]
		public float _Color2 = 1f;

		[Range(0f, 1f)]
		public float _Color3 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_Classic_ThermalVision");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("Fade", _Fade);
				material.SetFloat("Crt", _Crt);
				material.SetFloat("Curve", _Curve);
				material.SetFloat("Color1", _Color1);
				material.SetFloat("Color2", _Color2);
				material.SetFloat("Color3", _Color3);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Levels")]
	public class CameraFilterPack_Color_Adjust_Levels : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float levelMinimum;

		[Range(0f, 1f)]
		public float levelMiddle = 0.5f;

		[Range(0f, 1f)]
		public float levelMaximum = 1f;

		[Range(0f, 1f)]
		public float minOutput;

		[Range(0f, 1f)]
		public float maxOutput = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Levels");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("levelMinimum", levelMinimum);
				material.SetFloat("levelMiddle", levelMiddle);
				material.SetFloat("levelMaximum", levelMaximum);
				material.SetFloat("minOutput", minOutput);
				material.SetFloat("maxOutput", maxOutput);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/BrightContrastSaturation")]
	public class CameraFilterPack_Color_BrightContrastSaturation : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Brightness = 2f;

		[Range(0f, 10f)]
		public float Saturation = 1.5f;

		[Range(0f, 10f)]
		public float Contrast = 1.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_BrightContrastSaturation");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_Brightness", Brightness);
				material.SetFloat("_Saturation", Saturation);
				material.SetFloat("_Contrast", Contrast);
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Chromatic_Aberration")]
	public class CameraFilterPack_Color_Chromatic_Aberration : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-0.02f, 0.02f)]
		public float Offset = 0.02f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Chromatic_Aberration");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Offset);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Chromatic_Plus")]
	public class CameraFilterPack_Color_Chromatic_Plus : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.8f)]
		public float Size = 0.55f;

		[Range(0.01f, 0.4f)]
		public float Smooth = 0.26f;

		[Range(-0.02f, 0.02f)]
		public float Offset = 0.005f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Chromatic_Plus");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Smooth);
				material.SetFloat("_Distortion", Offset);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Contrast")]
	public class CameraFilterPack_Color_Contrast : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Contrast = 4.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Contrast");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_Contrast", Contrast);
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/GrayScale")]
	public class CameraFilterPack_Color_GrayScale : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_GrayScale");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", _Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Invert")]
	public class CameraFilterPack_Color_Invert : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Invert");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", _Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Noise")]
	public class CameraFilterPack_Color_Noise : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Noise = 0.235f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Noise");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Noise", Noise);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/RGB")]
	public class CameraFilterPack_Color_RGB : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		public Color ColorRGB = new Color(1f, 1f, 1f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_RGB");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetColor("_ColorRGB", ColorRGB);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Sepia")]
	public class CameraFilterPack_Color_Sepia : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Sepia");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", _Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Switching")]
	public class CameraFilterPack_Color_Switching : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 5f)]
		public int Color = 1;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Switching");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Color);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Color_YUV")]
	public class CameraFilterPack_Color_YUV : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float _Y;

		[Range(-1f, 1f)]
		public float _U;

		[Range(-1f, 1f)]
		public float _V;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_YUV");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Y", _Y);
				material.SetFloat("_U", _U);
				material.SetFloat("_V", _V);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/ColorsAdjust/ColorRGB")]
	public class CameraFilterPack_Colors_Adjust_ColorRGB : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-2f, 2f)]
		public float Red;

		[Range(-2f, 2f)]
		public float Green;

		[Range(-2f, 2f)]
		public float Blue;

		[Range(-1f, 1f)]
		public float Brightness;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_Adjust_ColorRGB");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Red);
				material.SetFloat("_Value2", Green);
				material.SetFloat("_Value3", Blue);
				material.SetFloat("_Value4", Brightness);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/ColorsAdjust/FullColors")]
	public class CameraFilterPack_Colors_Adjust_FullColors : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-200f, 200f)]
		public float Red_R = 100f;

		[Range(-200f, 200f)]
		public float Red_G;

		[Range(-200f, 200f)]
		public float Red_B;

		[Range(-200f, 200f)]
		public float Red_Constant;

		[Range(-200f, 200f)]
		public float Green_R;

		[Range(-200f, 200f)]
		public float Green_G = 100f;

		[Range(-200f, 200f)]
		public float Green_B;

		[Range(-200f, 200f)]
		public float Green_Constant;

		[Range(-200f, 200f)]
		public float Blue_R;

		[Range(-200f, 200f)]
		public float Blue_G;

		[Range(-200f, 200f)]
		public float Blue_B = 100f;

		[Range(-200f, 200f)]
		public float Blue_Constant;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_Adjust_FullColors");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Red_R", Red_R / 100f);
				material.SetFloat("_Red_G", Red_G / 100f);
				material.SetFloat("_Red_B", Red_B / 100f);
				material.SetFloat("_Green_R", Green_R / 100f);
				material.SetFloat("_Green_G", Green_G / 100f);
				material.SetFloat("_Green_B", Green_B / 100f);
				material.SetFloat("_Blue_R", Blue_R / 100f);
				material.SetFloat("_Blue_G", Blue_G / 100f);
				material.SetFloat("_Blue_B", Blue_B / 100f);
				material.SetFloat("_Red_C", Red_Constant / 100f);
				material.SetFloat("_Green_C", Green_Constant / 100f);
				material.SetFloat("_Blue_C", Blue_Constant / 100f);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			_ = Application.isPlaying;
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/ColorsAdjust/Photo Filters")]
	public class CameraFilterPack_Colors_Adjust_PreFilters : MonoBehaviour
	{
		public enum filters
		{
			Normal,
			BlueLagoon,
			BlueMoon,
			RedWhite,
			NashVille,
			VintageYellow,
			GoldenPink,
			DarkPink,
			PopRocket,
			RedSoftLight,
			YellowSunSet,
			Walden,
			WhiteShine,
			Fluo,
			MarsSunRise,
			Amelie,
			BlueJeans,
			NightVision,
			BlueParadise,
			Blindness_Deuteranomaly,
			Blindness_Protanopia,
			Blindness_Protanomaly,
			Blindness_Deuteranopia,
			Blindness_Tritanomaly,
			Blindness_Achromatopsia,
			Blindness_Achromatomaly,
			Blindness_Tritanopia,
			BlackAndWhite_Blue,
			BlackAndWhite_Green,
			BlackAndWhite_Orange,
			BlackAndWhite_Red,
			BlackAndWhite_Yellow
		}

		private string ShaderName = "CameraFilterPack/Colors_Adjust_PreFilters";

		public Shader SCShader;

		public filters filterchoice;

		[Range(0f, 1f)]
		public float FadeFX = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		private float[] Matrix9;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void ChangeFilters()
		{
			if (filterchoice == filters.Normal)
			{
				Matrix9 = new float[12]
				{
					100f, 0f, 0f, 0f, 100f, 0f, 0f, 0f, 100f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Deuteranomaly)
			{
				Matrix9 = new float[12]
				{
					80f, 20f, 0f, 25.833f, 74.167f, 0f, 0f, 14.167f, 85.833f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Protanopia)
			{
				Matrix9 = new float[12]
				{
					56.667f, 43.333f, 0f, 55.833f, 44.167f, 0f, 0f, 24.167f, 75.833f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Protanomaly)
			{
				Matrix9 = new float[12]
				{
					81.667f, 18.333f, 0f, 33.333f, 66.667f, 0f, 0f, 12.5f, 87.5f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Deuteranopia)
			{
				Matrix9 = new float[12]
				{
					62.5f, 37.5f, 0f, 70f, 30f, 0f, 0f, 30f, 70f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Tritanomaly)
			{
				Matrix9 = new float[12]
				{
					96.667f, 3.333f, 0f, 0f, 73.333f, 26.667f, 0f, 18.333f, 81.667f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Achromatopsia)
			{
				Matrix9 = new float[12]
				{
					29.9f, 58.7f, 11.4f, 29.9f, 58.7f, 11.4f, 29.9f, 58.7f, 11.4f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Achromatomaly)
			{
				Matrix9 = new float[12]
				{
					61.8f, 32f, 6.2f, 16.3f, 77.5f, 6.2f, 16.3f, 32f, 51.6f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Blindness_Tritanopia)
			{
				Matrix9 = new float[12]
				{
					95f, 5f, 0f, 0f, 43.333f, 56.667f, 0f, 47.5f, 52.5f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.BlueLagoon)
			{
				Matrix9 = new float[12]
				{
					100f, 102f, 0f, 18f, 100f, 4f, 28f, -26f, 100f, -64f,
					0f, 12f
				};
			}
			if (filterchoice == filters.GoldenPink)
			{
				Matrix9 = new float[12]
				{
					70f, 200f, 0f, 0f, 100f, 8f, 6f, 12f, 110f, 0f,
					0f, -6f
				};
			}
			if (filterchoice == filters.BlueMoon)
			{
				Matrix9 = new float[12]
				{
					200f, 98f, -116f, 24f, 100f, 2f, 30f, 52f, 20f, -48f,
					-20f, 12f
				};
			}
			if (filterchoice == filters.DarkPink)
			{
				Matrix9 = new float[12]
				{
					60f, 112f, 36f, 24f, 100f, 2f, 0f, -26f, 100f, -56f,
					-20f, 12f
				};
			}
			if (filterchoice == filters.RedWhite)
			{
				Matrix9 = new float[12]
				{
					-42f, 68f, 108f, -96f, 100f, 116f, -92f, 104f, 96f, 0f,
					2f, 4f
				};
			}
			if (filterchoice == filters.VintageYellow)
			{
				Matrix9 = new float[12]
				{
					200f, 109f, -104f, 42f, 126f, -1f, -40f, 121f, -31f, -48f,
					-20f, 12f
				};
			}
			if (filterchoice == filters.NashVille)
			{
				Matrix9 = new float[12]
				{
					130f, 8f, 7f, 19f, 89f, 3f, -1f, 11f, 57f, 10f,
					19f, 47f
				};
			}
			if (filterchoice == filters.PopRocket)
			{
				Matrix9 = new float[12]
				{
					100f, 6f, -17f, 0f, 107f, 0f, 10f, 21f, 100f, 40f,
					0f, 8f
				};
			}
			if (filterchoice == filters.RedSoftLight)
			{
				Matrix9 = new float[12]
				{
					-4f, 200f, -30f, -58f, 200f, -30f, -58f, 200f, -30f, -11f,
					0f, 0f
				};
			}
			if (filterchoice == filters.BlackAndWhite_Blue)
			{
				Matrix9 = new float[12]
				{
					0f, 0f, 100f, 0f, 0f, 100f, 0f, 0f, 100f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.BlackAndWhite_Green)
			{
				Matrix9 = new float[12]
				{
					0f, 100f, 0f, 0f, 100f, 0f, 0f, 100f, 0f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.BlackAndWhite_Orange)
			{
				Matrix9 = new float[12]
				{
					50f, 50f, 0f, 50f, 50f, 0f, 50f, 50f, 0f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.BlackAndWhite_Red)
			{
				Matrix9 = new float[12]
				{
					100f, 0f, 0f, 100f, 0f, 0f, 100f, 0f, 0f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.BlackAndWhite_Yellow)
			{
				Matrix9 = new float[12]
				{
					34f, 66f, 0f, 34f, 66f, 0f, 34f, 66f, 0f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.YellowSunSet)
			{
				Matrix9 = new float[12]
				{
					117f, -6f, 53f, -68f, 135f, 19f, -146f, -61f, 200f, 0f,
					0f, 0f
				};
			}
			if (filterchoice == filters.Walden)
			{
				Matrix9 = new float[12]
				{
					99f, 2f, 13f, 100f, 1f, 40f, 50f, 8f, 71f, 0f,
					2f, 7f
				};
			}
			if (filterchoice == filters.WhiteShine)
			{
				Matrix9 = new float[12]
				{
					190f, 24f, -33f, 2f, 200f, -6f, -10f, 27f, 200f, -6f,
					-13f, 15f
				};
			}
			if (filterchoice == filters.Fluo)
			{
				Matrix9 = new float[12]
				{
					100f, 0f, 0f, 0f, 113f, 0f, 200f, -200f, -200f, 0f,
					0f, 36f
				};
			}
			if (filterchoice == filters.MarsSunRise)
			{
				Matrix9 = new float[12]
				{
					50f, 141f, -81f, -17f, 62f, 29f, -159f, -137f, -200f, 7f,
					-34f, -6f
				};
			}
			if (filterchoice == filters.Amelie)
			{
				Matrix9 = new float[12]
				{
					100f, 11f, 39f, 1f, 63f, 53f, -24f, 71f, 20f, -25f,
					-10f, -24f
				};
			}
			if (filterchoice == filters.BlueJeans)
			{
				Matrix9 = new float[12]
				{
					181f, 11f, 15f, 40f, 40f, 20f, 40f, 40f, 20f, -59f,
					0f, 0f
				};
			}
			if (filterchoice == filters.NightVision)
			{
				Matrix9 = new float[12]
				{
					200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
					10f, -200f
				};
			}
			if (filterchoice == filters.BlueParadise)
			{
				Matrix9 = new float[12]
				{
					66f, 200f, -200f, 25f, 38f, 36f, 30f, 150f, 114f, 17f,
					0f, 65f
				};
			}
		}

		private void Start()
		{
			ChangeFilters();
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Red_R", Matrix9[0] / 100f);
				material.SetFloat("_Red_G", Matrix9[1] / 100f);
				material.SetFloat("_Red_B", Matrix9[2] / 100f);
				material.SetFloat("_Green_R", Matrix9[3] / 100f);
				material.SetFloat("_Green_G", Matrix9[4] / 100f);
				material.SetFloat("_Green_B", Matrix9[5] / 100f);
				material.SetFloat("_Blue_R", Matrix9[6] / 100f);
				material.SetFloat("_Blue_G", Matrix9[7] / 100f);
				material.SetFloat("_Blue_B", Matrix9[8] / 100f);
				material.SetFloat("_Red_C", Matrix9[9] / 100f);
				material.SetFloat("_Green_C", Matrix9[10] / 100f);
				material.SetFloat("_Blue_C", Matrix9[11] / 100f);
				material.SetFloat("_FadeFX", FadeFX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			ChangeFilters();
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/BleachBypass")]
	public class CameraFilterPack_Colors_BleachBypass : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 2f)]
		public float Value = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_BleachBypass");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Brightness")]
	public class CameraFilterPack_Colors_Brightness : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 2f)]
		public float _Brightness = 1.5f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_Brightness");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				material.SetFloat("_Val", _Brightness);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/DarkColor")]
	public class CameraFilterPack_Colors_DarkColor : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-5f, 5f)]
		public float Alpha = 1f;

		[Range(0f, 16f)]
		private float Colors = 11f;

		[Range(-1f, 1f)]
		private float Green_Mod = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_DarkColor");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Alpha);
				material.SetFloat("_Value2", Colors);
				material.SetFloat("_Value3", Green_Mod);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/HSV")]
	public class CameraFilterPack_Colors_HSV : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 360f)]
		public float _HueShift = 180f;

		[Range(-32f, 32f)]
		public float _Saturation = 1f;

		[Range(-32f, 32f)]
		public float _ValueBrightness = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				material.SetFloat("_HueShift", _HueShift);
				material.SetFloat("_Sat", _Saturation);
				material.SetFloat("_Val", _ValueBrightness);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/HUE_Rotate")]
	public class CameraFilterPack_Colors_HUE_Rotate : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 20f)]
		public float Speed = 10f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_HUE_Rotate");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", Speed);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/NewPosterize")]
	public class CameraFilterPack_Colors_NewPosterize : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 2f)]
		public float Gamma = 1f;

		[Range(0f, 16f)]
		public float Colors = 11f;

		[Range(-1f, 1f)]
		public float Green_Mod = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_NewPosterize");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Gamma);
				material.SetFloat("_Value2", Colors);
				material.SetFloat("_Value3", Green_Mod);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/RgbClamp")]
	public class CameraFilterPack_Colors_RgbClamp : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Red_Start;

		[Range(0f, 1f)]
		public float Red_End = 1f;

		[Range(0f, 1f)]
		public float Green_Start;

		[Range(0f, 1f)]
		public float Green_End = 1f;

		[Range(0f, 1f)]
		public float Blue_Start;

		[Range(0f, 1f)]
		public float Blue_End = 1f;

		[Range(0f, 1f)]
		public float RGB_Start;

		[Range(0f, 1f)]
		public float RGB_End = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_RgbClamp");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Red_Start);
				material.SetFloat("_Value2", Red_End);
				material.SetFloat("_Value3", Green_Start);
				material.SetFloat("_Value4", Green_End);
				material.SetFloat("_Value5", Blue_Start);
				material.SetFloat("_Value6", Blue_End);
				material.SetFloat("_Value7", RGB_Start);
				material.SetFloat("_Value8", RGB_End);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Colors/Threshold")]
	public class CameraFilterPack_Colors_Threshold : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Threshold = 0.3f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Colors_Threshold");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Threshold);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Convert/NormalMap")]
	public class CameraFilterPack_Convert_Normal : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 0.5f)]
		public float _Heigh = 0.0125f;

		[Range(0f, 0.25f)]
		public float _Intervale = 0.0025f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Color_Convert_Normal");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				material.SetFloat("_Heigh", _Heigh);
				material.SetFloat("_Intervale", _Intervale);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Aspiration")]
	public class CameraFilterPack_Distortion_Aspiration : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Value = 0.8f;

		[Range(-1f, 1f)]
		public float PosX = 0.5f;

		[Range(-1f, 1f)]
		public float PosY = 0.5f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Aspiration");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", 1f - Value);
				material.SetFloat("_Value2", PosX);
				material.SetFloat("_Value3", PosY);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/BigFace")]
	public class CameraFilterPack_Distortion_BigFace : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 6.5f;

		private Material SCMaterial;

		public float _Size = 5f;

		[Range(2f, 10f)]
		public float Distortion = 2.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_BigFace");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_Size", _Size);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/BlackHole")]
	public class CameraFilterPack_Distortion_BlackHole : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float PositionX;

		[Range(-1f, 1f)]
		public float PositionY;

		[Range(-5f, 5f)]
		public float Size = 0.05f;

		[Range(0f, 180f)]
		public float Distortion = 30f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_BlackHole");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_PositionX", PositionX);
				material.SetFloat("_PositionY", PositionY);
				material.SetFloat("_Distortion", Size);
				material.SetFloat("_Distortion2", Distortion);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Dissipation")]
	public class CameraFilterPack_Distortion_Dissipation : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 2.99f)]
		public float Dissipation = 1f;

		[Range(0f, 16f)]
		private float Colors = 11f;

		[Range(-1f, 1f)]
		private float Green_Mod = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Dissipation");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Dissipation);
				material.SetFloat("_Value2", Colors);
				material.SetFloat("_Value3", Green_Mod);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Dream")]
	public class CameraFilterPack_Distortion_Dream : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 10f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Dream");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Dream2")]
	public class CameraFilterPack_Distortion_Dream2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float Distortion = 6f;

		[Range(0f, 32f)]
		public float Speed = 5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Dream2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", Speed);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/FishEye")]
	public class CameraFilterPack_Distortion_FishEye : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Distortion = 0.35f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_FishEye");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Flag")]
	public class CameraFilterPack_Distortion_Flag : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 2f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		public static float ChangeDistortion;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Flag");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Flush")]
	public class CameraFilterPack_Distortion_Flush : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-10f, 50f)]
		public float Value = 5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Flush");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Half_Sphere")]
	public class CameraFilterPack_Distortion_Half_Sphere : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 6f)]
		private Material SCMaterial;

		public float SphereSize = 2.5f;

		[Range(-1f, 1f)]
		public float SpherePositionX;

		[Range(-1f, 1f)]
		public float SpherePositionY;

		[Range(1f, 10f)]
		public float Strength = 5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Half_Sphere");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_SphereSize", SphereSize);
				material.SetFloat("_SpherePositionX", SpherePositionX);
				material.SetFloat("_SpherePositionY", SpherePositionY);
				material.SetFloat("_Strength", Strength);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Heat")]
	public class CameraFilterPack_Distortion_Heat : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 100f)]
		public float Distortion = 35f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Heat");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Lens")]
	public class CameraFilterPack_Distortion_Lens : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float CenterX;

		[Range(-1f, 1f)]
		public float CenterY;

		[Range(0f, 3f)]
		public float Distortion = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Lens");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_CenterX", CenterX);
				material.SetFloat("_CenterY", CenterY);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Noise")]
	public class CameraFilterPack_Distortion_Noise : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 3f)]
		public float Distortion = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Noise");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/ShockWave")]
	public class CameraFilterPack_Distortion_ShockWave : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1.5f, 1.5f)]
		public float PosX = 0.5f;

		[Range(-1.5f, 1.5f)]
		public float PosY = 0.5f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		[Range(0f, 10f)]
		private float Size = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_ShockWave");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", PosX);
				material.SetFloat("_Value2", PosY);
				material.SetFloat("_Value3", Speed);
				material.SetFloat("_Value4", Size);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/ShockWave Manual")]
	public class CameraFilterPack_Distortion_ShockWaveManual : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1.5f, 1.5f)]
		public float PosX = 0.5f;

		[Range(-1.5f, 1.5f)]
		public float PosY = 0.5f;

		[Range(-0.1f, 2f)]
		public float Value = 0.5f;

		[Range(0f, 10f)]
		public float Size = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_ShockWaveManual");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", PosX);
				material.SetFloat("_Value2", PosY);
				material.SetFloat("_Value3", Value);
				material.SetFloat("_Value4", Size);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Twist")]
	public class CameraFilterPack_Distortion_Twist : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-2f, 2f)]
		public float CenterX = 0.5f;

		[Range(-2f, 2f)]
		public float CenterY = 0.5f;

		[Range(-3.14f, 3.14f)]
		public float Distortion = 1f;

		[Range(-2f, 2f)]
		public float Size = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Twist");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_CenterX", CenterX);
				material.SetFloat("_CenterY", CenterY);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_Size", Size);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Twist_Square")]
	public class CameraFilterPack_Distortion_Twist_Square : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-2f, 2f)]
		public float CenterX = 0.5f;

		[Range(-2f, 2f)]
		public float CenterY = 0.5f;

		[Range(-3.14f, 3.14f)]
		public float Distortion = 0.5f;

		[Range(-2f, 2f)]
		public float Size = 0.25f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Twist_Square");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_CenterX", CenterX);
				material.SetFloat("_CenterY", CenterY);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_Size", Size);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Water_Drop")]
	public class CameraFilterPack_Distortion_Water_Drop : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float CenterX;

		[Range(-1f, 1f)]
		public float CenterY;

		[Range(0f, 10f)]
		public float WaveIntensity = 1f;

		[Range(0f, 20f)]
		public int NumberOfWaves = 5;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Water_Drop");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				material.SetFloat("_CenterX", CenterX);
				material.SetFloat("_CenterY", CenterY);
				material.SetFloat("_WaveIntensity", WaveIntensity);
				material.SetInt("_NumberOfWaves", NumberOfWaves);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Distortion/Wave_Horizontal")]
	public class CameraFilterPack_Distortion_Wave_Horizontal : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 100f)]
		public float WaveIntensity = 32f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Distortion_Wave_Horizontal");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_WaveIntensity", WaveIntensity);
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/BluePrint")]
	public class CameraFilterPack_Drawing_BluePrint : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public Color Pencil_Color = new Color(1f, 1f, 1f, 1f);

		[Range(0.0001f, 0.0022f)]
		public float Pencil_Size = 0.0008f;

		[Range(0f, 2f)]
		public float Pencil_Correction = 0.76f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(0f, 2f)]
		public float Speed_Animation = 1f;

		[Range(0f, 1f)]
		public float Corner_Lose = 0.5f;

		[Range(0f, 1f)]
		public float Fade_Paper_to_BackColor = 0.2f;

		[Range(0f, 1f)]
		public float Fade_With_Original = 1f;

		public Color Back_Color = new Color(0.175f, 0.402f, 0.687f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Paper2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Drawing_BluePrint");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetColor("_PColor", Pencil_Color);
				material.SetFloat("_Value1", Pencil_Size);
				material.SetFloat("_Value2", Pencil_Correction);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Speed_Animation);
				material.SetFloat("_Value5", Corner_Lose);
				material.SetFloat("_Value6", Fade_Paper_to_BackColor);
				material.SetFloat("_Value7", Fade_With_Original);
				material.SetColor("_PColor2", Back_Color);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/CellShading")]
	public class CameraFilterPack_Drawing_CellShading : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float EdgeSize = 0.1f;

		[Range(0f, 10f)]
		public float ColorLevel = 4f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_CellShading");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_EdgeSize", EdgeSize);
				material.SetFloat("_ColorLevel", ColorLevel);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/CellShading2")]
	public class CameraFilterPack_Drawing_CellShading2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float EdgeSize = 0.1f;

		[Range(0f, 10f)]
		public float ColorLevel = 4f;

		[Range(0f, 1f)]
		public float Blur = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_CellShading2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_EdgeSize", EdgeSize);
				material.SetFloat("_ColorLevel", ColorLevel);
				material.SetFloat("_Distortion", Blur);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Comics")]
	public class CameraFilterPack_Drawing_Comics : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float DotSize = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Comics");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Crosshatch")]
	public class CameraFilterPack_Drawing_Crosshatch : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float Width = 2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Crosshatch");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Width);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Curve")]
	public class CameraFilterPack_Drawing_Curve : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(3f, 5f)]
		public float Size = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Curve");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/EnhancedComics")]
	public class CameraFilterPack_Drawing_EnhancedComics : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float DotSize = 0.15f;

		[Range(0f, 1f)]
		public float _ColorR = 0.9f;

		[Range(0f, 1f)]
		public float _ColorG = 0.4f;

		[Range(0f, 1f)]
		public float _ColorB = 0.4f;

		[Range(0f, 1f)]
		public float _Blood = 0.5f;

		[Range(0f, 1f)]
		public float _SmoothStart = 0.02f;

		[Range(0f, 1f)]
		public float _SmoothEnd = 0.1f;

		public Color ColorRGB = new Color(1f, 0f, 0f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_EnhancedComics");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				material.SetFloat("_ColorR", _ColorR);
				material.SetFloat("_ColorG", _ColorG);
				material.SetFloat("_ColorB", _ColorB);
				material.SetFloat("_Blood", _Blood);
				material.SetColor("_ColorRGB", ColorRGB);
				material.SetFloat("_SmoothStart", _SmoothStart);
				material.SetFloat("_SmoothEnd", _SmoothEnd);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Halftone")]
	public class CameraFilterPack_Drawing_Halftone : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Threshold = 0.6f;

		[Range(1f, 16f)]
		public float DotSize = 4f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Halftone");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Threshold);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Laplacian")]
	public class CameraFilterPack_Drawing_Laplacian : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Laplacian");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			_ = Application.isPlaying;
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Lines")]
	public class CameraFilterPack_Drawing_Lines : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.1f, 10f)]
		public float Number = 1f;

		[Range(0f, 1f)]
		public float Random = 0.5f;

		[Range(0f, 10f)]
		private float PositionY = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Lines");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Number);
				material.SetFloat("_Value2", Random);
				material.SetFloat("_Value3", PositionY);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga")]
	public class CameraFilterPack_Drawing_Manga : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 8f)]
		public float DotSize = 4.72f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga2")]
	public class CameraFilterPack_Drawing_Manga2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 8f)]
		public float DotSize = 4.72f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga3")]
	public class CameraFilterPack_Drawing_Manga3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 8f)]
		public float DotSize = 4.72f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga3");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga4")]
	public class CameraFilterPack_Drawing_Manga4 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 8f)]
		public float DotSize = 4.72f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga4");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga5")]
	public class CameraFilterPack_Drawing_Manga5 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 8f)]
		public float DotSize = 4.72f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga5");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga_Color")]
	public class CameraFilterPack_Drawing_Manga_Color : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 8f)]
		public float DotSize = 1.6f;

		public static float ChangeDotSize;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_Color");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga_Flash")]
	public class CameraFilterPack_Drawing_Manga_Flash : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float Size = 1f;

		[Range(0f, 30f)]
		public int Speed = 5;

		[Range(-1f, 1f)]
		public float PosX = 0.5f;

		[Range(-1f, 1f)]
		public float PosY = 0.5f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_Flash");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetFloat("_Intensity", Intensity);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga_FlashWhite")]
	public class CameraFilterPack_Drawing_Manga_FlashWhite : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float Size = 1f;

		[Range(0f, 30f)]
		public int Speed = 5;

		[Range(-1f, 1f)]
		public float PosX = 0.5f;

		[Range(-1f, 1f)]
		public float PosY = 0.5f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_FlashWhite");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetFloat("_Intensity", Intensity);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Manga_Flash_Color")]
	public class CameraFilterPack_Drawing_Manga_Flash_Color : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float Size = 1f;

		public Color Color = new Color(0f, 0.7f, 1f, 1f);

		[Range(0f, 30f)]
		public int Speed = 5;

		[Range(0f, 1f)]
		public float PosX = 0.5f;

		[Range(0f, 1f)]
		public float PosY = 0.5f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Manga_Flash_Color");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetFloat("_Intensity", Intensity);
				material.SetColor("Color", Color);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/NewCellShading")]
	public class CameraFilterPack_Drawing_NewCellShading : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Threshold = 0.2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_NewCellShading");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Threshold", Threshold);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Paper")]
	public class CameraFilterPack_Drawing_Paper : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public Color Pencil_Color = new Color(0.156f, 0.3f, 0.738f, 1f);

		[Range(0.0001f, 0.0022f)]
		public float Pencil_Size = 0.0008f;

		[Range(0f, 2f)]
		public float Pencil_Correction = 0.76f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(0f, 2f)]
		public float Speed_Animation = 1f;

		[Range(0f, 1f)]
		public float Corner_Lose = 0.5f;

		[Range(0f, 1f)]
		public float Fade_Paper_to_BackColor;

		[Range(0f, 1f)]
		public float Fade_With_Original = 1f;

		public Color Back_Color = new Color(1f, 1f, 1f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Paper1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Drawing_Paper");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetColor("_PColor", Pencil_Color);
				material.SetFloat("_Value1", Pencil_Size);
				material.SetFloat("_Value2", Pencil_Correction);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Speed_Animation);
				material.SetFloat("_Value5", Corner_Lose);
				material.SetFloat("_Value6", Fade_Paper_to_BackColor);
				material.SetFloat("_Value7", Fade_With_Original);
				material.SetColor("_PColor2", Back_Color);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Paper2")]
	public class CameraFilterPack_Drawing_Paper2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public Color Pencil_Color = new Color(0f, 0.371f, 0.78f, 1f);

		[Range(0.0001f, 0.0022f)]
		public float Pencil_Size = 0.0008f;

		[Range(0f, 2f)]
		public float Pencil_Correction = 0.76f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(0f, 2f)]
		public float Speed_Animation = 1f;

		[Range(0f, 1f)]
		public float Corner_Lose = 0.85f;

		[Range(0f, 1f)]
		public float Fade_Paper_to_BackColor;

		[Range(0f, 1f)]
		public float Fade_With_Original = 1f;

		public Color Back_Color = new Color(1f, 1f, 1f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Paper3") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Drawing_Paper2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetColor("_PColor", Pencil_Color);
				material.SetFloat("_Value1", Pencil_Size);
				material.SetFloat("_Value2", Pencil_Correction);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Speed_Animation);
				material.SetFloat("_Value5", Corner_Lose);
				material.SetFloat("_Value6", Fade_Paper_to_BackColor);
				material.SetFloat("_Value7", Fade_With_Original);
				material.SetColor("_PColor2", Back_Color);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Paper3")]
	public class CameraFilterPack_Drawing_Paper3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public Color Pencil_Color = new Color(0f, 0f, 0f, 0f);

		[Range(0.0001f, 0.0022f)]
		public float Pencil_Size = 0.00125f;

		[Range(0f, 2f)]
		public float Pencil_Correction = 0.35f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(0f, 2f)]
		public float Speed_Animation = 1f;

		[Range(0f, 1f)]
		public float Corner_Lose = 1f;

		[Range(0f, 1f)]
		public float Fade_Paper_to_BackColor;

		[Range(0f, 1f)]
		public float Fade_With_Original = 1f;

		public Color Back_Color = new Color(1f, 1f, 1f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Paper4") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Drawing_Paper3");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetColor("_PColor", Pencil_Color);
				material.SetFloat("_Value1", Pencil_Size);
				material.SetFloat("_Value2", Pencil_Correction);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Speed_Animation);
				material.SetFloat("_Value5", Corner_Lose);
				material.SetFloat("_Value6", Fade_Paper_to_BackColor);
				material.SetFloat("_Value7", Fade_With_Original);
				material.SetColor("_PColor2", Back_Color);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Drawing/Toon")]
	public class CameraFilterPack_Drawing_Toon : MonoBehaviour
	{
		public Shader SCShader;

		private Material SCMaterial;

		private float TimeX = 1f;

		[Range(0f, 2f)]
		public float Threshold = 1f;

		[Range(0f, 8f)]
		public float DotSize = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Drawing_Toon");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Threshold);
				material.SetFloat("_DotSize", DotSize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/EXTRA/Rotation")]
	public class CameraFilterPack_EXTRA_Rotation : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-360f, 360f)]
		public float Rotation;

		[Range(-1f, 2f)]
		public float PositionX = 0.5f;

		[Range(-1f, 2f)]
		public float PositionY = 0.5f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/EXTRA_Rotation");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", 0f - Rotation);
				material.SetFloat("_Value2", PositionX);
				material.SetFloat("_Value3", PositionY);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/EXTRA/SHOWFPS")]
	public class CameraFilterPack_EXTRA_SHOWFPS : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(8f, 42f)]
		public float Size = 12f;

		[Range(0f, 100f)]
		private int FPS = 1;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private float accum;

		private int frames;

		public float frequency = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			FPS = 0;
			StartCoroutine(FPSX());
			SCShader = Shader.Find("CameraFilterPack/EXTRA_SHOWFPS");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", FPS);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private IEnumerator FPSX()
		{
			while (true)
			{
				float num = accum / (float)frames;
				FPS = (int)num;
				accum = 0f;
				frames = 0;
				yield return new WaitForSeconds(frequency);
			}
		}

		private void Update()
		{
			accum += Time.timeScale / Time.deltaTime;
			frames++;
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Edge/BlackLine")]
	public class CameraFilterPack_Edge_BlackLine : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Edge_BlackLine");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Edge/Edge_filter")]
	public class CameraFilterPack_Edge_Edge_filter : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float RedAmplifier;

		[Range(0f, 10f)]
		public float GreenAmplifier = 2f;

		[Range(0f, 10f)]
		public float BlueAmplifier;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Edge_Edge_filter");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_RedAmplifier", RedAmplifier);
				material.SetFloat("_GreenAmplifier", GreenAmplifier);
				material.SetFloat("_BlueAmplifier", BlueAmplifier);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Edge/Golden")]
	public class CameraFilterPack_Edge_Golden : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Edge_Golden");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Edge/Neon")]
	public class CameraFilterPack_Edge_Neon : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float EdgeWeight = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Edge_Neon");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_EdgeWeight", EdgeWeight);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Edge/Sigmoid")]
	public class CameraFilterPack_Edge_Sigmoid : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float Gain = 3f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Edge_Sigmoid");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Gain", Gain);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Edge/Sobel")]
	public class CameraFilterPack_Edge_Sobel : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Edge_Sobel");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Eyes 1")]
	public class CameraFilterPack_EyesVision_1 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 32f)]
		public float _EyeWave = 15f;

		[Range(0f, 10f)]
		public float _EyeSpeed = 1f;

		[Range(0f, 8f)]
		public float _EyeMove = 2f;

		[Range(0f, 1f)]
		public float _EyeBlink = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_eyes_vision_1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/EyesVision_1");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", _EyeWave);
				material.SetFloat("_Value2", _EyeSpeed);
				material.SetFloat("_Value3", _EyeMove);
				material.SetFloat("_Value4", _EyeBlink);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Eyes 2")]
	public class CameraFilterPack_EyesVision_2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 32f)]
		public float _EyeWave = 15f;

		[Range(0f, 10f)]
		public float _EyeSpeed = 1f;

		[Range(0f, 8f)]
		public float _EyeMove = 2f;

		[Range(0f, 1f)]
		public float _EyeBlink = 1f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_eyes_vision_2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/EyesVision_2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", _EyeWave);
				material.SetFloat("_Value2", _EyeSpeed);
				material.SetFloat("_Value3", _EyeMove);
				material.SetFloat("_Value4", _EyeBlink);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixel/8bits")]
	public class CameraFilterPack_FX_8bits : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float Brightness;

		[Range(80f, 640f)]
		public int ResolutionX = 160;

		[Range(60f, 480f)]
		public int ResolutionY = 240;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_8bits");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (Brightness == 0f)
				{
					Brightness = 0.001f;
				}
				material.SetFloat("_Distortion", Brightness);
				RenderTexture temporary = RenderTexture.GetTemporary(ResolutionX, ResolutionY, 0);
				Graphics.Blit(sourceTexture, temporary, material);
				temporary.filterMode = FilterMode.Point;
				Graphics.Blit(temporary, destTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixel/8bits_gb")]
	public class CameraFilterPack_FX_8bits_gb : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-1f, 1f)]
		public float Brightness;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_8bits_gb");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (Brightness == 0f)
				{
					Brightness = 0.001f;
				}
				material.SetFloat("_Distortion", Brightness);
				RenderTexture temporary = RenderTexture.GetTemporary(160, 144, 0);
				Graphics.Blit(sourceTexture, temporary, material);
				temporary.filterMode = FilterMode.Point;
				Graphics.Blit(temporary, destTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Ascii")]
	public class CameraFilterPack_FX_Ascii : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 2f)]
		public float Value = 1f;

		[Range(0.01f, 1f)]
		public float Fade = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Ascii");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Value", Value);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/DarkMatter")]
	public class CameraFilterPack_FX_DarkMatter : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-10f, 10f)]
		public float Speed = 0.8f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(-1f, 2f)]
		public float PosX = 0.5f;

		[Range(-1f, 2f)]
		public float PosY = 0.5f;

		[Range(-2f, 2f)]
		public float Zoom = 0.33f;

		[Range(0f, 5f)]
		public float DarkIntensity = 2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_DarkMatter");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Speed);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetFloat("_Value5", Zoom);
				material.SetFloat("_Value6", DarkIntensity);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/DigitalMatrix")]
	public class CameraFilterPack_FX_DigitalMatrix : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.4f, 5f)]
		public float Size = 1f;

		[Range(-10f, 10f)]
		public float Speed = 1f;

		[Range(-1f, 1f)]
		public float ColorR = -1f;

		[Range(-1f, 1f)]
		public float ColorG = 1f;

		[Range(-1f, 1f)]
		public float ColorB = -1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_DigitalMatrix");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", ColorR);
				material.SetFloat("_Value3", ColorG);
				material.SetFloat("_Value4", ColorB);
				material.SetFloat("_Value5", Speed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/DigitalMatrixDistortion")]
	public class CameraFilterPack_FX_DigitalMatrixDistortion : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.4f, 5f)]
		public float Size = 1.4f;

		[Range(-2f, 2f)]
		public float Speed = 0.5f;

		[Range(-5f, 5f)]
		public float Distortion = 2.3f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_DigitalMatrixDistortion");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Distortion);
				material.SetFloat("_Value5", Speed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Dot_Circle")]
	public class CameraFilterPack_FX_Dot_Circle : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(4f, 32f)]
		public float Value = 7f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Dot_Circle");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetFloat("_Value", Value);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Drunk")]
	public class CameraFilterPack_FX_Drunk : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[HideInInspector]
		[Range(0f, 20f)]
		public float Value = 6f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		[Range(0f, 1f)]
		public float Wavy = 1f;

		[Range(0f, 1f)]
		public float Distortion;

		[Range(0f, 1f)]
		public float DistortionWave;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(-2f, 2f)]
		public float ColoredSaturate = 1f;

		[Range(-1f, 2f)]
		public float ColoredChange;

		[Range(-1f, 1f)]
		public float ChangeRed;

		[Range(-1f, 1f)]
		public float ChangeGreen;

		[Range(-1f, 1f)]
		public float ChangeBlue;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Drunk");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Speed", Speed);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_DistortionWave", DistortionWave);
				material.SetFloat("_Wavy", Wavy);
				material.SetFloat("_Fade", Fade);
				material.SetFloat("_ColoredChange", ColoredChange);
				material.SetFloat("_ChangeRed", ChangeRed);
				material.SetFloat("_ChangeGreen", ChangeGreen);
				material.SetFloat("_ChangeBlue", ChangeBlue);
				material.SetFloat("_Colored", ColoredSaturate);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Drunk2")]
	public class CameraFilterPack_FX_Drunk2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		private float Value = 1f;

		[Range(0f, 10f)]
		private float Value2 = 1f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Drunk2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Earth Quake")]
	public class CameraFilterPack_FX_EarthQuake : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float Speed = 15f;

		[Range(0f, 0.2f)]
		public float X = 0.008f;

		[Range(0f, 0.2f)]
		public float Y = 0.008f;

		[Range(0f, 0.2f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_EarthQuake");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Speed);
				material.SetFloat("_Value2", X);
				material.SetFloat("_Value3", Y);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Funk")]
	public class CameraFilterPack_FX_Funk : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Funk");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/Glitch1")]
	public class CameraFilterPack_FX_Glitch1 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Glitch = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Glitch1");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Glitch", Glitch);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/Glitch2")]
	public class CameraFilterPack_FX_Glitch2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Glitch = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Glitch2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Glitch", Glitch);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/Glitch3")]
	public class CameraFilterPack_FX_Glitch3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float _Glitch = 1f;

		[Range(0f, 1f)]
		public float _Noise = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Glitch3");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Glitch", _Glitch);
				material.SetFloat("_Noise", _Noise);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Grid")]
	public class CameraFilterPack_FX_Grid : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 5f)]
		public float Distortion = 1f;

		public static float ChangeDistortion;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Grid");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Hexagon")]
	public class CameraFilterPack_FX_Hexagon : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Hexagon");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Hexagon_Black")]
	public class CameraFilterPack_FX_Hexagon_Black : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.2f, 10f)]
		public float Value = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Hexagon_Black");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Hypno")]
	public class CameraFilterPack_FX_Hypno : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Speed = 1f;

		[Range(-2f, 2f)]
		public float Red;

		[Range(-2f, 2f)]
		public float Green = 1f;

		[Range(-2f, 2f)]
		public float Blue = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Hypno");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Speed);
				material.SetFloat("_Value2", Red);
				material.SetFloat("_Value3", Green);
				material.SetFloat("_Value4", Blue);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/InverChromiLum")]
	public class CameraFilterPack_FX_InverChromiLum : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_InverChromiLum");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Mirror")]
	public class CameraFilterPack_FX_Mirror : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Mirror");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Plasma")]
	public class CameraFilterPack_FX_Plasma : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		private float Value = 6f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Plasma");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Psycho")]
	public class CameraFilterPack_FX_Psycho : MonoBehaviour
	{
		public Shader SCShader;

		private Material SCMaterial;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Distortion = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Psycho");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Scan")]
	public class CameraFilterPack_FX_Scan : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.001f, 0.1f)]
		public float Size = 0.025f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Scan");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Screens")]
	public class CameraFilterPack_FX_Screens : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 256f)]
		public float Tiles = 8f;

		[Range(0f, 5f)]
		public float Speed = 0.25f;

		public Color color = new Color(0f, 1f, 1f, 1f);

		[Range(-1f, 1f)]
		public float PosX;

		[Range(-1f, 1f)]
		public float PosY;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Screens");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Tiles);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetColor("_color", color);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/Spot")]
	public class CameraFilterPack_FX_Spot : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		public Vector2 center = new Vector2(0.5f, 0.5f);

		public float Radius = 0.2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_Spot");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_PositionX", center.x);
				material.SetFloat("_PositionY", center.y);
				material.SetFloat("_Radius", Radius);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/ZebraColor")]
	public class CameraFilterPack_FX_ZebraColor : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 10f)]
		public float Value = 3f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_ZebraColor");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/FX/SuperDot")]
	public class CameraFilterPack_FX_superDot : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/FX_superDot");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Film/ColorPerfection")]
	public class CameraFilterPack_Film_ColorPerfection : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 4f)]
		public float Gamma = 0.55f;

		[Range(0f, 10f)]
		private float Value2 = 1f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Film_ColorPerfection");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Gamma);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Film/Grain")]
	public class CameraFilterPack_Film_Grain : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-64f, 64f)]
		public float Value = 32f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Film_Grain");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Fly_Vision")]
	public class CameraFilterPack_Fly_Vision : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.04f, 1.5f)]
		public float Zoom = 0.25f;

		[Range(0f, 1f)]
		public float Distortion = 0.4f;

		[Range(0f, 1f)]
		public float Fade = 0.4f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Fly_VisionFX") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Fly_Vision");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Zoom);
				material.SetFloat("_Value2", Distortion);
				material.SetFloat("_Value3", Fade);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glasses/Classic Glasses")]
	public class CameraFilterPack_Glasses_On : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 0.2f;

		[Range(0f, 0.1f)]
		public float VisionBlur = 0.0095f;

		public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

		public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.25f, 0.25f);

		[Range(0f, 1f)]
		public float GlassDistortion = 0.45f;

		[Range(0f, 1f)]
		public float GlassAberration = 0.5f;

		[Range(0f, 1f)]
		public float UseFinalGlassColor;

		[Range(0f, 1f)]
		public float UseScanLine;

		[Range(1f, 512f)]
		public float UseScanLineSize = 1f;

		public Color GlassColor = new Color(0f, 0f, 0f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Glasses_On2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Glasses_On");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
				material.SetFloat("Fade", Fade);
				material.SetFloat("VisionBlur", VisionBlur);
				material.SetFloat("GlassDistortion", GlassDistortion);
				material.SetFloat("GlassAberration", GlassAberration);
				material.SetColor("GlassesColor", GlassesColor);
				material.SetColor("GlassesColor2", GlassesColor2);
				material.SetColor("GlassColor", GlassColor);
				material.SetFloat("UseScanLineSize", UseScanLineSize);
				material.SetFloat("UseScanLine", UseScanLine);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glasses/Vampire")]
	public class CameraFilterPack_Glasses_On_2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 0.2f;

		[Range(0f, 0.1f)]
		public float VisionBlur = 0.005f;

		public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

		public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.25f, 0.25f);

		[Range(0f, 1f)]
		public float GlassDistortion = 0.6f;

		[Range(0f, 1f)]
		public float GlassAberration = 0.5f;

		[Range(0f, 1f)]
		public float UseFinalGlassColor = 1f;

		[Range(0f, 1f)]
		public float UseScanLine;

		[Range(1f, 512f)]
		public float UseScanLineSize = 358f;

		public Color GlassColor = new Color(1f, 0f, 0f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Glasses_On3") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Glasses_OnX");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
				material.SetFloat("Fade", Fade);
				material.SetFloat("VisionBlur", VisionBlur);
				material.SetFloat("GlassDistortion", GlassDistortion);
				material.SetFloat("GlassAberration", GlassAberration);
				material.SetColor("GlassesColor", GlassesColor);
				material.SetColor("GlassesColor2", GlassesColor2);
				material.SetColor("GlassColor", GlassColor);
				material.SetFloat("UseScanLineSize", UseScanLineSize);
				material.SetFloat("UseScanLine", UseScanLine);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glasses/Night Glasses")]
	public class CameraFilterPack_Glasses_On_3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 0.3f;

		[Range(0f, 0.1f)]
		public float VisionBlur = 0.005f;

		public Color GlassesColor = new Color(0.7f, 0.7f, 0.7f, 1f);

		public Color GlassesColor2 = new Color(1f, 1f, 1f, 1f);

		[Range(0f, 1f)]
		public float GlassDistortion = 0.6f;

		[Range(0f, 1f)]
		public float GlassAberration = 0.3f;

		[Range(0f, 1f)]
		public float UseFinalGlassColor;

		[Range(0f, 1f)]
		public float UseScanLine = 0.4f;

		[Range(1f, 512f)]
		public float UseScanLineSize = 358f;

		public Color GlassColor = new Color(0f, 0.5f, 0f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Glasses_On4") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Glasses_On");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
				material.SetFloat("Fade", Fade);
				material.SetFloat("VisionBlur", VisionBlur);
				material.SetFloat("GlassDistortion", GlassDistortion);
				material.SetFloat("GlassAberration", GlassAberration);
				material.SetColor("GlassesColor", GlassesColor);
				material.SetColor("GlassesColor2", GlassesColor2);
				material.SetColor("GlassColor", GlassColor);
				material.SetFloat("UseScanLineSize", UseScanLineSize);
				material.SetFloat("UseScanLine", UseScanLine);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glasses/Futuristic Desert")]
	public class CameraFilterPack_Glasses_On_4 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 0.2f;

		[Range(0f, 0.1f)]
		public float VisionBlur = 0.005f;

		public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

		public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.25f, 0.25f);

		[Range(0f, 1f)]
		public float GlassDistortion = 0.6f;

		[Range(0f, 1f)]
		public float GlassAberration = 0.3f;

		[Range(0f, 1f)]
		public float UseFinalGlassColor;

		[Range(0f, 1f)]
		public float UseScanLine = 0.4f;

		[Range(1f, 512f)]
		public float UseScanLineSize = 358f;

		public Color GlassColor = new Color(1f, 0.4f, 0f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Glasses_On5") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Glasses_On");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
				material.SetFloat("Fade", Fade);
				material.SetFloat("VisionBlur", VisionBlur);
				material.SetFloat("GlassDistortion", GlassDistortion);
				material.SetFloat("GlassAberration", GlassAberration);
				material.SetColor("GlassesColor", GlassesColor);
				material.SetColor("GlassesColor2", GlassesColor2);
				material.SetColor("GlassColor", GlassColor);
				material.SetFloat("UseScanLineSize", UseScanLineSize);
				material.SetFloat("UseScanLine", UseScanLine);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glasses/Futuristic Montain")]
	public class CameraFilterPack_Glasses_On_5 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 0.2f;

		[Range(0f, 0.1f)]
		public float VisionBlur = 0.005f;

		public Color GlassesColor = new Color(0.1f, 0.1f, 0.1f, 1f);

		public Color GlassesColor2 = new Color(0.45f, 0.45f, 0.45f, 0.25f);

		[Range(0f, 1f)]
		public float GlassDistortion = 0.6f;

		[Range(0f, 1f)]
		public float GlassAberration = 0.3f;

		[Range(0f, 1f)]
		public float UseFinalGlassColor;

		[Range(0f, 1f)]
		public float UseScanLine = 0.4f;

		[Range(1f, 512f)]
		public float UseScanLineSize = 358f;

		public Color GlassColor = new Color(0.1f, 0.3f, 1f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Glasses_On6") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Glasses_On");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
				material.SetFloat("Fade", Fade);
				material.SetFloat("VisionBlur", VisionBlur);
				material.SetFloat("GlassDistortion", GlassDistortion);
				material.SetFloat("GlassAberration", GlassAberration);
				material.SetColor("GlassesColor", GlassesColor);
				material.SetColor("GlassesColor2", GlassesColor2);
				material.SetColor("GlassColor", GlassColor);
				material.SetFloat("UseScanLineSize", UseScanLineSize);
				material.SetFloat("UseScanLine", UseScanLine);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glasses/Spy")]
	public class CameraFilterPack_Glasses_On_6 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 0.2f;

		[Range(0f, 0.1f)]
		public float VisionBlur = 0.005f;

		public Color GlassesColor = new Color(0f, 0f, 0f, 1f);

		public Color GlassesColor2 = new Color(0.25f, 0.25f, 0.45f, 0.25f);

		[Range(0f, 1f)]
		public float GlassDistortion = 0.6f;

		[Range(0f, 1f)]
		public float GlassAberration = 0.3f;

		[Range(0f, 1f)]
		public float UseFinalGlassColor;

		[Range(0f, 1f)]
		public float UseScanLine = 0.4f;

		[Range(1f, 512f)]
		public float UseScanLineSize = 358f;

		public Color GlassColor = new Color(1f, 0.9f, 0f, 1f);

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Glasses_On7") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Glasses_On");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("UseFinalGlassColor", UseFinalGlassColor);
				material.SetFloat("Fade", Fade);
				material.SetFloat("VisionBlur", VisionBlur);
				material.SetFloat("GlassDistortion", GlassDistortion);
				material.SetFloat("GlassAberration", GlassAberration);
				material.SetColor("GlassesColor", GlassesColor);
				material.SetColor("GlassesColor2", GlassesColor2);
				material.SetColor("GlassColor", GlassColor);
				material.SetFloat("UseScanLineSize", UseScanLineSize);
				material.SetFloat("UseScanLine", UseScanLine);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/Mozaic")]
	public class CameraFilterPack_Glitch_Mozaic : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.001f, 10f)]
		public float Intensity = 1f;

		[Range(0f, 10f)]
		private float Value2 = 1f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Glitch_Mozaic");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Intensity);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glow/Glow")]
	public class CameraFilterPack_Glow_Glow : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		public float Amount = 4f;

		[Range(2f, 16f)]
		public int FastFilter = 4;

		[Range(0f, 1f)]
		public float Threshold = 0.5f;

		[Range(0f, 1f)]
		public float Intensity = 0.75f;

		[Range(-1f, 1f)]
		public float Precision = 0.56f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Glow_Glow");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetFloat("_Value1", Threshold);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value3", Precision);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
					temporary.filterMode = FilterMode.Trilinear;
					Graphics.Blit(sourceTexture, temporary, material, 3);
					Graphics.Blit(temporary, temporary2, material, 2);
					Graphics.Blit(temporary2, temporary, material, 0);
					material.SetFloat("_Amount", Amount * 2f);
					Graphics.Blit(temporary, temporary2, material, 2);
					Graphics.Blit(temporary2, temporary, material, 0);
					material.SetTexture("_MainTex2", temporary);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(temporary2);
					Graphics.Blit(sourceTexture, destTexture, material, 1);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material, 0);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glow/Glow_Color")]
	public class CameraFilterPack_Glow_Glow_Color : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 20f)]
		public float Amount = 4f;

		[Range(2f, 16f)]
		public int FastFilter = 4;

		[Range(0f, 1f)]
		public float Threshold = 0.5f;

		[Range(0f, 3f)]
		public float Intensity = 2.25f;

		[Range(-1f, 1f)]
		public float Precision = 0.56f;

		public Color GlowColor = new Color(0f, 0.7f, 1f, 1f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Glow_Glow_Color");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				int fastFilter = FastFilter;
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Amount", Amount);
				material.SetFloat("_Value1", Threshold);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value3", Precision);
				material.SetColor("_GlowColor", GlowColor);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width / fastFilter, Screen.height / fastFilter));
				int width = sourceTexture.width / fastFilter;
				int height = sourceTexture.height / fastFilter;
				if (FastFilter > 1)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0);
					temporary.filterMode = FilterMode.Trilinear;
					Graphics.Blit(sourceTexture, temporary, material, 3);
					Graphics.Blit(temporary, temporary2, material, 2);
					Graphics.Blit(temporary2, temporary, material, 0);
					material.SetFloat("_Amount", Amount * 2f);
					Graphics.Blit(temporary, temporary2, material, 2);
					Graphics.Blit(temporary2, temporary, material, 0);
					material.SetTexture("_MainTex2", temporary);
					RenderTexture.ReleaseTemporary(temporary);
					RenderTexture.ReleaseTemporary(temporary2);
					Graphics.Blit(sourceTexture, destTexture, material, 1);
				}
				else
				{
					Graphics.Blit(sourceTexture, destTexture, material, 0);
				}
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Ansi")]
	public class CameraFilterPack_Gradients_Ansi : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Ansi";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Desert")]
	public class CameraFilterPack_Gradients_Desert : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Desert";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Electric")]
	public class CameraFilterPack_Gradients_ElectricGradient : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_ElectricGradient";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Fire")]
	public class CameraFilterPack_Gradients_FireGradient : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_FireGradient";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Hue")]
	public class CameraFilterPack_Gradients_Hue : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Hue";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Neon")]
	public class CameraFilterPack_Gradients_NeonGradient : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_NeonGradient";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Rainbow")]
	public class CameraFilterPack_Gradients_Rainbow : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Rainbow";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Stripe")]
	public class CameraFilterPack_Gradients_Stripe : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Stripe";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Tech")]
	public class CameraFilterPack_Gradients_Tech : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Tech";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Gradients/Thermal")]
	public class CameraFilterPack_Gradients_Therma : MonoBehaviour
	{
		public Shader SCShader;

		private string ShaderName = "CameraFilterPack/Gradients_Therma";

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Switch = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Switch);
				material.SetFloat("_Value2", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Light/Rainbow")]
	public class CameraFilterPack_Light_Rainbow : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.01f, 5f)]
		public float Value = 1.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Light_Rainbow");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Light/Rainbow2")]
	public class CameraFilterPack_Light_Rainbow2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.01f, 5f)]
		public float Value = 1.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Light_Rainbow2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Light/Water")]
	public class CameraFilterPack_Light_Water : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Size = 4f;

		[Range(0f, 2f)]
		public float Alpha = 0.07f;

		[Range(0f, 32f)]
		public float Distance = 10f;

		[Range(-2f, 2f)]
		public float Speed = 0.4f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Light_Water");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime * Speed;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Alpha", Alpha);
				material.SetFloat("_Distance", Distance);
				material.SetFloat("_Size", Size);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Light/Water2")]
	public class CameraFilterPack_Light_Water2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Speed = 0.2f;

		[Range(0f, 10f)]
		public float Speed_X = 0.2f;

		[Range(0f, 1f)]
		public float Speed_Y = 0.3f;

		[Range(0f, 10f)]
		public float Intensity = 2.4f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Light_Water2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Speed);
				material.SetFloat("_Value2", Speed_X);
				material.SetFloat("_Value3", Speed_Y);
				material.SetFloat("_Value4", Intensity);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/Lut 2 Lut")]
	public class CameraFilterPack_Lut_2_Lut : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Vector4 ScreenResolution;

		private Material SCMaterial;

		public Texture2D LutTexture;

		public Texture2D LutTexture2;

		private Texture3D converted3DLut;

		private Texture3D converted3DLut2;

		[Range(0f, 1f)]
		public float Blend = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private string MemoPath;

		private string MemoPath2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_2_lut");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
			if ((bool)converted3DLut2)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut2);
			}
			converted3DLut2 = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut2.SetPixels(array);
			converted3DLut2.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public Texture3D Convert(Texture2D temp2DTex, Texture3D cv3D)
		{
			int num = 4096;
			if ((bool)temp2DTex)
			{
				num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return cv3D;
				}
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)cv3D)
			{
				UnityEngine.Object.DestroyImmediate(cv3D);
			}
			cv3D = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			cv3D.SetPixels(array);
			cv3D.Apply();
			return cv3D;
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					if (!LutTexture)
					{
						SetIdentityLut();
					}
					if ((bool)LutTexture)
					{
						converted3DLut = Convert(LutTexture, converted3DLut);
					}
				}
				if (converted3DLut2 == null)
				{
					if (!LutTexture2)
					{
						SetIdentityLut();
					}
					if ((bool)LutTexture2)
					{
						converted3DLut2 = Convert(LutTexture2, converted3DLut2);
					}
				}
				if ((bool)LutTexture)
				{
					converted3DLut.wrapMode = TextureWrapMode.Clamp;
				}
				if ((bool)LutTexture2)
				{
					converted3DLut2.wrapMode = TextureWrapMode.Clamp;
				}
				material.SetFloat("_Blend", Blend);
				material.SetFloat("_Fade", Fade);
				material.SetTexture("_LutTex", converted3DLut);
				material.SetTexture("_LutTex2", converted3DLut2);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/Lut 2 Lut Extra")]
	public class CameraFilterPack_Lut_2_Lut_Extra : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Vector4 ScreenResolution;

		private Material SCMaterial;

		public Texture2D LutTexture;

		public Texture2D LutTexture2;

		private Texture3D converted3DLut;

		private Texture3D converted3DLut2;

		[Range(0f, 1f)]
		public float FadeLut1 = 1f;

		[Range(0f, 1f)]
		public float FadeLut2 = 1f;

		[Range(0f, 1f)]
		public float Pos;

		[Range(0f, 1f)]
		public float Smooth = 1f;

		private string MemoPath;

		private string MemoPath2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_2_lut_Extra");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
			if ((bool)converted3DLut2)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut2);
			}
			converted3DLut2 = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut2.SetPixels(array);
			converted3DLut2.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public Texture3D Convert(Texture2D temp2DTex, Texture3D cv3D)
		{
			int num = 4096;
			if ((bool)temp2DTex)
			{
				num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return cv3D;
				}
			}
			Color[] pixels = temp2DTex.GetPixels();
			Color[] array = new Color[pixels.Length];
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						int num2 = num - j - 1;
						array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
					}
				}
			}
			if ((bool)cv3D)
			{
				UnityEngine.Object.DestroyImmediate(cv3D);
			}
			cv3D = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			cv3D.SetPixels(array);
			cv3D.Apply();
			return cv3D;
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					if (!LutTexture)
					{
						SetIdentityLut();
					}
					if ((bool)LutTexture)
					{
						converted3DLut = Convert(LutTexture, converted3DLut);
					}
				}
				if (converted3DLut2 == null)
				{
					if (!LutTexture2)
					{
						SetIdentityLut();
					}
					if ((bool)LutTexture2)
					{
						converted3DLut2 = Convert(LutTexture2, converted3DLut2);
					}
				}
				if ((bool)LutTexture)
				{
					converted3DLut.wrapMode = TextureWrapMode.Clamp;
				}
				if ((bool)LutTexture2)
				{
					converted3DLut2.wrapMode = TextureWrapMode.Clamp;
				}
				material.SetFloat("_Fade", FadeLut1);
				material.SetFloat("_Fade2", FadeLut2);
				material.SetFloat("_Pos", Pos);
				material.SetFloat("_Smooth", Smooth);
				material.SetTexture("_LutTex", converted3DLut);
				material.SetTexture("_LutTex2", converted3DLut2);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/Mask")]
	public class CameraFilterPack_Lut_Mask : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Vector4 ScreenResolution;

		private Material SCMaterial;

		public Texture2D LutTexture;

		private Texture3D converted3DLut;

		[Range(0f, 1f)]
		public float Blend = 1f;

		public Texture2D Mask;

		[Range(0f, 1f)]
		public float Inverse = 1f;

		private string MemoPath;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_Mask");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
			}
			else
			{
				SetIdentityLut();
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					Convert(LutTexture);
				}
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetFloat("_Blend", Blend);
				material.SetTexture("_LutTex", converted3DLut);
				material.SetTexture("_MaskTex", Mask);
				material.SetFloat("_Inverse", Inverse);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/PlayWith")]
	public class CameraFilterPack_Lut_PlayWith : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		public Texture2D LutTexture;

		private Texture3D converted3DLut;

		[Range(0f, 1f)]
		public float Blend = 1f;

		[Range(0f, 3f)]
		public float OriginalIntensity = 1f;

		[Range(-1f, 1f)]
		public float ResultIntensity;

		[Range(-1f, 1f)]
		public float FinalIntensity;

		private string MemoPath;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_PlayWith");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
			}
			else
			{
				SetIdentityLut();
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					Convert(LutTexture);
				}
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetTexture("_LutTex", converted3DLut);
				material.SetFloat("_Blend", Blend);
				material.SetFloat("_Intensity", OriginalIntensity);
				material.SetFloat("_Extra", ResultIntensity);
				material.SetFloat("_Extra2", FinalIntensity);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/Plus")]
	public class CameraFilterPack_Lut_Plus : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Vector4 ScreenResolution;

		private Material SCMaterial;

		public Texture2D LutTexture;

		private Texture3D converted3DLut;

		[Range(0f, 1f)]
		public float Blend = 1f;

		private string MemoPath;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_Plus");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
			}
			else
			{
				SetIdentityLut();
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					Convert(LutTexture);
				}
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetFloat("_Blend", Blend);
				material.SetTexture("_LutTex", converted3DLut);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/Simple")]
	public class CameraFilterPack_Lut_Simple : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		public Texture2D LutTexture;

		private Texture3D converted3DLut;

		private string MemoPath;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_Simple");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
			}
			else
			{
				SetIdentityLut();
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					Convert(LutTexture);
				}
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetTexture("_LutTex", converted3DLut);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Lut/TestMode")]
	public class CameraFilterPack_Lut_TestMode : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		public Texture2D LutTexture;

		private Texture3D converted3DLut;

		[Range(0f, 1f)]
		public float Blend = 1f;

		[Range(0f, 3f)]
		public float OriginalIntensity = 1f;

		[Range(-1f, 1f)]
		public float ResultIntensity;

		[Range(-1f, 1f)]
		public float FinalIntensity;

		[Range(0f, 1f)]
		public float TestMode = 0.5f;

		private string MemoPath;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Lut_TestMode");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public void SetIdentityLut()
		{
			int num = 16;
			Color[] array = new Color[num * num * num];
			float num2 = 1f / (1f * (float)num - 1f);
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < num; k++)
					{
						array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
					}
				}
			}
			if ((bool)converted3DLut)
			{
				UnityEngine.Object.DestroyImmediate(converted3DLut);
			}
			converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
			converted3DLut.SetPixels(array);
			converted3DLut.Apply();
		}

		public bool ValidDimensions(Texture2D tex2d)
		{
			if (!tex2d)
			{
				return false;
			}
			if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
			{
				return false;
			}
			return true;
		}

		public void Convert(Texture2D temp2DTex)
		{
			if ((bool)temp2DTex)
			{
				int num = temp2DTex.width * temp2DTex.height;
				num = temp2DTex.height;
				if (!ValidDimensions(temp2DTex))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
					return;
				}
				Color[] pixels = temp2DTex.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							int num2 = num - j - 1;
							array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
			}
			else
			{
				SetIdentityLut();
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null || !SystemInfo.supports3DTextures)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				if (converted3DLut == null)
				{
					Convert(LutTexture);
				}
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetTexture("_LutTex", converted3DLut);
				material.SetFloat("_Blend", Blend);
				material.SetFloat("_Intensity", OriginalIntensity);
				material.SetFloat("_Extra", ResultIntensity);
				material.SetFloat("_Extra2", FinalIntensity);
				material.SetFloat("_Extra3", TestMode);
				Graphics.Blit(sourceTexture, destTexture, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch1")]
	public class CameraFilterPack_NewGlitch1 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float _Seed = 1f;

		[Range(0f, 1f)]
		public float _Size = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch1");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Seed", _Seed);
				material.SetFloat("Size", _Size);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch2")]
	public class CameraFilterPack_NewGlitch2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _RedFade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("RedFade", _RedFade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch3")]
	public class CameraFilterPack_NewGlitch3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _RedFade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch3");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("RedFade", _RedFade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch4")]
	public class CameraFilterPack_NewGlitch4 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch4");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("Fade", _Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch5")]
	public class CameraFilterPack_NewGlitch5 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _Fade = 1f;

		[Range(0f, 1f)]
		public float _Parasite = 1f;

		[Range(0f, 0f)]
		public float _ZoomX = 1f;

		[Range(0f, 0f)]
		public float _ZoomY = 1f;

		[Range(0f, 0f)]
		public float _PosX = 1f;

		[Range(0f, 0f)]
		public float _PosY = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch5");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("Fade", _Fade);
				material.SetFloat("Parasite", _Parasite);
				material.SetFloat("ZoomX", _ZoomX);
				material.SetFloat("ZoomY", _ZoomY);
				material.SetFloat("PosX", _PosX);
				material.SetFloat("PosY", _PosY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/NewGlitch6")]
	public class CameraFilterPack_NewGlitch6 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _FadeLight = 1f;

		[Range(0f, 1f)]
		public float _FadeDark = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch6");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("FadeLight", _FadeLight);
				material.SetFloat("FadeDark", _FadeDark);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/Glitch Drawing")]
	public class CameraFilterPack_NewGlitch7 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float __Speed = 1f;

		[Range(0f, 1f)]
		public float _LightMin;

		[Range(0f, 1f)]
		public float _LightMax = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/CameraFilterPack_NewGlitch7");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Speed", __Speed);
				material.SetFloat("LightMin", _LightMin);
				material.SetFloat("LightMax", _LightMax);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision FX")]
	public class CameraFilterPack_NightVisionFX : MonoBehaviour
	{
		public enum preset
		{
			Night_Vision_Personalized = -1,
			Night_Vision_FX,
			Night_Vision_Classic,
			Night_Vision_Full,
			Night_Vision_Dark,
			Night_Vision_Sharp,
			Night_Vision_BlueSky,
			Night_Vision_Low_Light,
			Night_Vision_Pinky,
			Night_Vision_RedBurn,
			Night_Vision_PurpleShadow
		}

		public Shader SCShader;

		public preset Preset;

		private preset PresetMemo;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float OnOff;

		[Range(0.2f, 2f)]
		public float Greenness = 1f;

		[Range(0f, 1f)]
		public float Vignette = 1f;

		[Range(0f, 1f)]
		public float Vignette_Alpha = 1f;

		[Range(-10f, 10f)]
		public float Distortion = 1f;

		[Range(0f, 1f)]
		public float Noise = 1f;

		[Range(-2f, 1f)]
		public float Intensity = -1f;

		[Range(0f, 2f)]
		public float Light = 1f;

		[Range(0f, 1f)]
		public float Light2 = 1f;

		[Range(0f, 2f)]
		public float Line = 1f;

		[Range(-2f, 2f)]
		public float Color_R;

		[Range(-2f, 2f)]
		public float Color_G;

		[Range(-2f, 2f)]
		public float Color_B;

		[Range(0f, 1f)]
		public float _Binocular_Size = 0.499f;

		[Range(0f, 1f)]
		public float _Binocular_Smooth = 0.113f;

		[Range(0f, 1f)]
		public float _Binocular_Dist = 0.286f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/NightVisionFX");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_OnOff", OnOff);
				material.SetFloat("_Greenness", Greenness);
				material.SetFloat("_Vignette", Vignette);
				material.SetFloat("_Vignette_Alpha", Vignette_Alpha);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_Noise", Noise);
				material.SetFloat("_Intensity", Intensity);
				material.SetFloat("_Light", Light);
				material.SetFloat("_Light2", Light2);
				material.SetFloat("_Line", Line);
				material.SetFloat("_Color_R", Color_R);
				material.SetFloat("_Color_G", Color_G);
				material.SetFloat("_Color_B", Color_B);
				material.SetFloat("_Size", _Binocular_Size);
				material.SetFloat("_Dist", _Binocular_Dist);
				material.SetFloat("_Smooth", _Binocular_Smooth);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
			if (PresetMemo != Preset)
			{
				PresetMemo = Preset;
				float[] array = new float[12]
				{
					0.757f, 0.098f, 0.458f, -2.49f, 0.559f, -0.298f, 1.202f, 0.515f, 1f, 0f,
					0f, 0f
				};
				float[] array2 = new float[12]
				{
					0.2f, 0.202f, 0.68f, -1.49f, 0.084f, -0.019f, 2f, 0.166f, 1.948f, -0.1f,
					0.15f, -0.07f
				};
				float[] array3 = new float[12]
				{
					1.45f, 0.01f, 0.112f, -0.07f, 0.111f, -0.077f, 0.071f, 0f, 0.245f, 0f,
					0f, 0f
				};
				float[] array4 = new float[12]
				{
					0.779f, 0.185f, 0.706f, 1.21f, 0.24f, 0.138f, 2f, 0.07f, 1.224f, -0.21f,
					-0.34f, 0f
				};
				float[] array5 = new float[12]
				{
					0.2f, 0.028f, 0.706f, 1.21f, 0.397f, -0.24f, 2f, 0.298f, 1.224f, -0.08f,
					0.48f, -0.57f
				};
				float[] array6 = new float[12]
				{
					0.2f, 0.159f, 0.622f, -2.28f, 0.409f, -0.24f, 0.166f, 0.028f, 2f, -0.08f,
					0.22f, 0.57f
				};
				float[] array7 = new float[12]
				{
					2f, 0.054f, 1f, -2.28f, 0.409f, -1f, 2f, 0.187f, 0.241f, 0f,
					1.58f, 0.21f
				};
				float[] array8 = new float[12]
				{
					2f, 0.054f, 1f, 1.28f, 0.409f, -1f, 0.41f, 0.656f, 0.427f, 0.95f,
					-0.35f, 1.41f
				};
				float[] array9 = new float[12]
				{
					2f, 0.281f, 0.156f, 1.85f, 0.709f, -1f, 0.41f, 0.109f, 0.34f, 0.95f,
					0.36f, -0.14f
				};
				float[] array10 = new float[12]
				{
					0.905f, 0.281f, 0.156f, 1.85f, 0.558f, -0.974f, 1.639f, 0.252f, 1.074f, 0.46f,
					0.95f, 0.58f
				};
				float[] array11 = new float[12];
				if (Preset == preset.Night_Vision_FX)
				{
					array11 = array;
				}
				if (Preset == preset.Night_Vision_Classic)
				{
					array11 = array2;
				}
				if (Preset == preset.Night_Vision_Full)
				{
					array11 = array3;
				}
				if (Preset == preset.Night_Vision_Dark)
				{
					array11 = array4;
				}
				if (Preset == preset.Night_Vision_Sharp)
				{
					array11 = array5;
				}
				if (Preset == preset.Night_Vision_BlueSky)
				{
					array11 = array6;
				}
				if (Preset == preset.Night_Vision_Low_Light)
				{
					array11 = array7;
				}
				if (Preset == preset.Night_Vision_Pinky)
				{
					array11 = array8;
				}
				if (Preset == preset.Night_Vision_RedBurn)
				{
					array11 = array9;
				}
				if (Preset == preset.Night_Vision_PurpleShadow)
				{
					array11 = array10;
				}
				if (Preset != preset.Night_Vision_Personalized)
				{
					Greenness = array11[0];
					Vignette = array11[1];
					Vignette_Alpha = array11[2];
					Distortion = array11[3];
					Noise = array11[4];
					Intensity = array11[5];
					Light = array11[6];
					Light2 = array11[7];
					Line = array11[8];
					Color_R = array11[9];
					Color_G = array11[10];
					Color_B = array11[11];
				}
			}
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 4")]
	public class CameraFilterPack_NightVision_4 : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/NightVision_4";

		public Shader SCShader;

		[Range(0f, 1f)]
		public float FadeFX = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		private float[] Matrix9;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void ChangeFilters()
		{
			Matrix9 = new float[12]
			{
				200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
				10f, -200f
			};
		}

		private void Start()
		{
			ChangeFilters();
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Red_R", Matrix9[0] / 100f);
				material.SetFloat("_Red_G", Matrix9[1] / 100f);
				material.SetFloat("_Red_B", Matrix9[2] / 100f);
				material.SetFloat("_Green_R", Matrix9[3] / 100f);
				material.SetFloat("_Green_G", Matrix9[4] / 100f);
				material.SetFloat("_Green_B", Matrix9[5] / 100f);
				material.SetFloat("_Blue_R", Matrix9[6] / 100f);
				material.SetFloat("_Blue_G", Matrix9[7] / 100f);
				material.SetFloat("_Blue_B", Matrix9[8] / 100f);
				material.SetFloat("_Red_C", Matrix9[9] / 100f);
				material.SetFloat("_Green_C", Matrix9[10] / 100f);
				material.SetFloat("_Blue_C", Matrix9[11] / 100f);
				material.SetFloat("_FadeFX", FadeFX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			ChangeFilters();
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Noise/TV")]
	public class CameraFilterPack_Noise_TV : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 10f)]
		private float Value2 = 1f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_Noise") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Noise_TV");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Noise/TV_2")]
	public class CameraFilterPack_Noise_TV_2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float Fade_Additive;

		[Range(0f, 1f)]
		public float Fade_Distortion;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_Noise2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Noise_TV_2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Fade_Additive);
				material.SetFloat("_Value3", Fade_Distortion);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Noise/TV_3")]
	public class CameraFilterPack_Noise_TV_3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float Fade_Additive;

		[Range(0f, 1f)]
		public float Fade_Distortion;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_Noise3") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Noise_TV_3");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Value2", Fade_Additive);
				material.SetFloat("_Value3", Fade_Distortion);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 1")]
	public class CameraFilterPack_Oculus_NightVision1 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private float Distortion = 1f;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float Vignette = 1.3f;

		[Range(1f, 150f)]
		public float Linecount = 90f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Oculus_NightVision1");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetFloat("_Vignette", Vignette);
				material.SetFloat("_Linecount", Linecount);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 2")]
	public class CameraFilterPack_Oculus_NightVision2 : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Oculus_NightVision2";

		public Shader SCShader;

		[Range(0f, 1f)]
		public float FadeFX = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		private float[] Matrix9;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void ChangeFilters()
		{
			Matrix9 = new float[12]
			{
				200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
				10f, -200f
			};
		}

		private void Start()
		{
			ChangeFilters();
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Red_R", Matrix9[0] / 100f);
				material.SetFloat("_Red_G", Matrix9[1] / 100f);
				material.SetFloat("_Red_B", Matrix9[2] / 100f);
				material.SetFloat("_Green_R", Matrix9[3] / 100f);
				material.SetFloat("_Green_G", Matrix9[4] / 100f);
				material.SetFloat("_Green_B", Matrix9[5] / 100f);
				material.SetFloat("_Blue_R", Matrix9[6] / 100f);
				material.SetFloat("_Blue_G", Matrix9[7] / 100f);
				material.SetFloat("_Blue_B", Matrix9[8] / 100f);
				material.SetFloat("_Red_C", Matrix9[9] / 100f);
				material.SetFloat("_Green_C", Matrix9[10] / 100f);
				material.SetFloat("_Blue_C", Matrix9[11] / 100f);
				material.SetFloat("_FadeFX", FadeFX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			ChangeFilters();
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 3")]
	public class CameraFilterPack_Oculus_NightVision3 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.2f, 2f)]
		public float Greenness = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Oculus_NightVision3");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Greenness", Greenness);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Night Vision/Night Vision 5")]
	public class CameraFilterPack_Oculus_NightVision5 : MonoBehaviour
	{
		private string ShaderName = "CameraFilterPack/Oculus_NightVision5";

		public Shader SCShader;

		[Range(0f, 1f)]
		public float FadeFX = 1f;

		[Range(0f, 1f)]
		public float _Size = 0.37f;

		[Range(0f, 1f)]
		public float _Smooth = 0.15f;

		[Range(0f, 1f)]
		public float _Dist = 0.285f;

		private float TimeX = 1f;

		private Material SCMaterial;

		private float[] Matrix9;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void ChangeFilters()
		{
			Matrix9 = new float[12]
			{
				200f, -200f, -200f, 195f, 4f, -160f, 200f, -200f, -200f, -200f,
				10f, -200f
			};
		}

		private void Start()
		{
			ChangeFilters();
			SCShader = Shader.Find(ShaderName);
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Red_R", Matrix9[0] / 100f);
				material.SetFloat("_Red_G", Matrix9[1] / 100f);
				material.SetFloat("_Red_B", Matrix9[2] / 100f);
				material.SetFloat("_Green_R", Matrix9[3] / 100f);
				material.SetFloat("_Green_G", Matrix9[4] / 100f);
				material.SetFloat("_Green_B", Matrix9[5] / 100f);
				material.SetFloat("_Blue_R", Matrix9[6] / 100f);
				material.SetFloat("_Blue_G", Matrix9[7] / 100f);
				material.SetFloat("_Blue_B", Matrix9[8] / 100f);
				material.SetFloat("_Red_C", Matrix9[9] / 100f);
				material.SetFloat("_Green_C", Matrix9[10] / 100f);
				material.SetFloat("_Blue_C", Matrix9[11] / 100f);
				material.SetFloat("_FadeFX", FadeFX);
				material.SetFloat("_Size", _Size);
				material.SetFloat("_Dist", _Dist);
				material.SetFloat("_Smooth", _Smooth);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void OnValidate()
		{
			ChangeFilters();
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/ThermaVision")]
	public class CameraFilterPack_Oculus_ThermaVision : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Therma_Variation = 0.5f;

		[Range(0f, 8f)]
		private float Contrast = 3f;

		[Range(0f, 4f)]
		private float Burn;

		[Range(0f, 16f)]
		private float SceneCut = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Oculus_ThermaVision");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Therma_Variation);
				material.SetFloat("_Value2", Contrast);
				material.SetFloat("_Value3", Burn);
				material.SetFloat("_Value4", SceneCut);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Old Film/Cutting 1")]
	public class CameraFilterPack_OldFilm_Cutting1 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		[Range(0f, 2f)]
		public float Luminosity = 1.5f;

		[Range(0f, 1f)]
		public float Vignette = 1f;

		[Range(0f, 2f)]
		public float Negative;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_OldFilm1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/OldFilm_Cutting1");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Luminosity);
				material.SetFloat("_Value2", 1f - Vignette);
				material.SetFloat("_Value3", Negative);
				material.SetFloat("_Speed", Speed);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Old Film/Cutting 2")]
	public class CameraFilterPack_OldFilm_Cutting2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 10f)]
		public float Speed = 5f;

		[Range(0f, 2f)]
		public float Luminosity = 1f;

		[Range(0f, 1f)]
		public float Vignette = 1f;

		[Range(0f, 1f)]
		public float Negative;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_OldFilm2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/OldFilm_Cutting2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", 2f - Luminosity);
				material.SetFloat("_Value2", 1f - Vignette);
				material.SetFloat("_Value3", Negative);
				material.SetFloat("_Speed", Speed);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixel/Pixelisation")]
	public class CameraFilterPack_Pixel_Pixelisation : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0.6f, 120f)]
		public float _Pixelisation = 8f;

		[Range(0.6f, 120f)]
		public float _SizeX = 1f;

		[Range(0.6f, 120f)]
		public float _SizeY = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Pixel_Pixelisation");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				material.SetFloat("_Val", _Pixelisation);
				material.SetFloat("_Val2", _SizeX);
				material.SetFloat("_Val3", _SizeY);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixelisation/Deep OilPaint HQ")]
	public class CameraFilterPack_Pixelisation_DeepOilPaintHQ : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		public bool _Visualize;

		private Material SCMaterial;

		[Range(0f, 100f)]
		public float _FixDistance = 1.5f;

		[Range(-0.99f, 0.99f)]
		public float _Distance = 0.4f;

		[Range(0f, 0.5f)]
		public float _Size = 0.5f;

		[Range(0f, 8f)]
		public float Intensity = 1f;

		public bool AutoAnimatedNear;

		[Range(-5f, 5f)]
		public float AutoAnimatedNearSpeed = 0.5f;

		public static Color ChangeColorRGB;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Deep_OilPaintHQ");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (AutoAnimatedNear)
				{
					_Distance += Time.deltaTime * AutoAnimatedNearSpeed;
					if (_Distance > 1f)
					{
						_Distance = -1f;
					}
					if (_Distance < -1f)
					{
						_Distance = 1f;
					}
					material.SetFloat("_Near", _Distance);
				}
				else
				{
					material.SetFloat("_Near", _Distance);
				}
				material.SetFloat("_Far", _Size);
				material.SetFloat("_FixDistance", _FixDistance);
				material.SetFloat("_LightIntensity", Intensity);
				material.SetFloat("_Visualize", _Visualize ? 1 : 0);
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				material.SetFloat("_FarCamera", 1000f / farClipPlane);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixelisation/Dot")]
	public class CameraFilterPack_Pixelisation_Dot : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.0001f, 0.5f)]
		public float Size = 0.005f;

		[Range(0f, 1f)]
		public float LightBackGround = 0.3f;

		[Range(0f, 10f)]
		private float Speed = 1f;

		[Range(0f, 10f)]
		private float Size2 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Pixelisation_Dot");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", LightBackGround);
				material.SetFloat("_Value3", Speed);
				material.SetFloat("_Value4", Size2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixelisation/OilPaint")]
	public class CameraFilterPack_Pixelisation_OilPaint : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 5f)]
		public float Value = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Pixelisation_OilPaint");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetFloat("_Value", Value);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixelisation/OilPaintHQ")]
	public class CameraFilterPack_Pixelisation_OilPaintHQ : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 5f)]
		public float Value = 2f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Pixelisation_OilPaintHQ");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetFloat("_Value", Value);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Pixelisation/Pixelisation_Sweater")]
	public class CameraFilterPack_Pixelisation_Sweater : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(16f, 128f)]
		public float SweaterSize = 64f;

		[Range(0f, 2f)]
		public float _Intensity = 1.4f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_Sweater") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/Pixelisation_Sweater");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", Fade);
				material.SetFloat("_SweaterSize", SweaterSize);
				material.SetFloat("_Intensity", _Intensity);
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Weather/New Rain FX")]
	public class CameraFilterPack_Rain_RainFX : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-8f, 8f)]
		public float Speed = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[HideInInspector]
		public int Count;

		private Vector4[] Coord = new Vector4[4];

		public static Color ChangeColorRGB;

		private Texture2D Texture2;

		private Texture2D Texture3;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_RainFX_Anm2") as Texture2D;
			Texture3 = Resources.Load("CameraFilterPack_RainFX_Anm") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/RainFX");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Fade);
				material.SetFloat("_Speed", Speed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				GetComponent<Camera>().depthTextureMode = DepthTextureMode.Depth;
				AnimationCurve animationCurve = new AnimationCurve();
				animationCurve = new AnimationCurve();
				animationCurve.AddKey(0f, 0.01f);
				animationCurve.AddKey(64f, 5f);
				animationCurve.AddKey(128f, 80f);
				animationCurve.AddKey(255f, 255f);
				animationCurve.AddKey(300f, 255f);
				for (int i = 0; i < 4; i++)
				{
					Coord[i].z += 0.5f;
					if (Coord[i].w == -1f)
					{
						Coord[i].x = -5f;
					}
					if (Coord[i].z > 254f)
					{
						Coord[i] = new Vector4(UnityEngine.Random.Range(0f, 0.9f), UnityEngine.Random.Range(0.2f, 1.1f), 0f, UnityEngine.Random.Range(0, 3));
					}
					material.SetVector("Coord" + (i + 1), new Vector4(Coord[i].x, Coord[i].y, (int)animationCurve.Evaluate(Coord[i].z), Coord[i].w));
				}
				material.SetTexture("Texture2", Texture2);
				material.SetTexture("Texture3", Texture3);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/VHS/Real VHS HQ")]
	public class CameraFilterPack_Real_VHS : MonoBehaviour
	{
		public Shader SCShader;

		private Material SCMaterial;

		private Texture2D VHS;

		private Texture2D VHS2;

		[Range(0f, 1f)]
		public float TRACKING = 0.212f;

		[Range(0f, 1f)]
		public float JITTER = 1f;

		[Range(0f, 1f)]
		public float GLITCH = 1f;

		[Range(0f, 1f)]
		public float NOISE = 1f;

		[Range(-1f, 1f)]
		public float Brightness;

		[Range(0f, 1.5f)]
		public float Constrast = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Real_VHS");
			VHS = Resources.Load("CameraFilterPack_VHS1") as Texture2D;
			VHS2 = Resources.Load("CameraFilterPack_VHS2") as Texture2D;
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		public static Texture2D GetRTPixels(Texture2D t, RenderTexture rt, int sx, int sy)
		{
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = rt;
			t.ReadPixels(new Rect(0f, 0f, t.width, t.height), 0, 0);
			RenderTexture.active = active;
			return t;
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				material.SetTexture("VHS", VHS);
				material.SetTexture("VHS2", VHS2);
				material.SetFloat("TRACKING", TRACKING);
				material.SetFloat("JITTER", JITTER);
				material.SetFloat("GLITCH", GLITCH);
				material.SetFloat("NOISE", NOISE);
				material.SetFloat("Brightness", Brightness);
				material.SetFloat("CONTRAST", 1f - Constrast);
				int height = 576;
				RenderTexture temporary = RenderTexture.GetTemporary(382, height, 0);
				temporary.filterMode = FilterMode.Trilinear;
				Graphics.Blit(sourceTexture, temporary, material);
				Graphics.Blit(temporary, destTexture);
				RenderTexture.ReleaseTemporary(temporary);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Retro/Loading")]
	public class CameraFilterPack_Retro_Loading : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.1f, 10f)]
		public float Speed = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Retro_Loading");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Speed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Sharpen/Sharpen")]
	public class CameraFilterPack_Sharpen_Sharpen : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0.001f, 100f)]
		public float Value = 4f;

		[Range(0.001f, 32f)]
		public float Value2 = 1f;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Sharpen_Sharpen");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", Value2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Special/Bubble")]
	public class CameraFilterPack_Special_Bubble : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-4f, 4f)]
		public float X = 0.5f;

		[Range(-4f, 4f)]
		public float Y = 0.5f;

		[Range(0f, 5f)]
		public float Rate = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Special_Bubble");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", X);
				material.SetFloat("_Value2", Y);
				material.SetFloat("_Value3", Rate);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/50s")]
	public class CameraFilterPack_TV_50 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_50");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/80s")]
	public class CameraFilterPack_TV_80 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_80");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/ARCADE")]
	public class CameraFilterPack_TV_ARCADE : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_ARCADE");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/ARCADE_2")]
	public class CameraFilterPack_TV_ARCADE_2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Interferance_Size = 1f;

		[Range(0f, 10f)]
		public float Interferance_Speed = 0.5f;

		[Range(0f, 10f)]
		public float Contrast = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_ARCADE_2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Interferance_Size);
				material.SetFloat("_Value2", Interferance_Speed);
				material.SetFloat("_Value3", Contrast);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/ARCADE_Fast")]
	public class CameraFilterPack_TV_ARCADE_Fast : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.05f)]
		public float Interferance_Size = 0.02f;

		[Range(0f, 4f)]
		public float Interferance_Speed = 0.5f;

		[Range(0f, 10f)]
		public float Contrast = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_Arcade1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/TV_ARCADE_Fast");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Interferance_Size);
				material.SetFloat("_Value2", Interferance_Speed);
				material.SetFloat("_Value3", Contrast);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Artefact")]
	public class CameraFilterPack_TV_Artefact : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(-10f, 10f)]
		public float Colorisation = 1f;

		[Range(-10f, 10f)]
		public float Parasite = 1f;

		[Range(-10f, 10f)]
		public float Noise = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Artefact");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Colorisation", Colorisation);
				material.SetFloat("_Parasite", Parasite);
				material.SetFloat("_Noise", Noise);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Broken Glass")]
	public class CameraFilterPack_TV_BrokenGlass : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 128f)]
		public float Broken_Small;

		[Range(0f, 128f)]
		public float Broken_Medium;

		[Range(0f, 128f)]
		public float Broken_High;

		[Range(0f, 128f)]
		public float Broken_Big = 1f;

		[Range(0f, 0.004f)]
		public float LightReflect = 0.002f;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_BrokenGlass1") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/TV_BrokenGlass");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", LightReflect);
				material.SetFloat("_Value2", Broken_Small);
				material.SetFloat("_Value3", Broken_Medium);
				material.SetFloat("_Value4", Broken_High);
				material.SetFloat("_Value5", Broken_Big);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Broken Glass2")]
	public class CameraFilterPack_TV_BrokenGlass2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Bullet_1;

		[Range(0f, 1f)]
		public float Bullet_2;

		[Range(0f, 1f)]
		public float Bullet_3;

		[Range(0f, 1f)]
		public float Bullet_4 = 1f;

		[Range(0f, 1f)]
		public float Bullet_5;

		[Range(0f, 1f)]
		public float Bullet_6;

		[Range(0f, 1f)]
		public float Bullet_7;

		[Range(0f, 1f)]
		public float Bullet_8;

		[Range(0f, 1f)]
		public float Bullet_9;

		[Range(0f, 1f)]
		public float Bullet_10;

		[Range(0f, 1f)]
		public float Bullet_11;

		[Range(0f, 1f)]
		public float Bullet_12;

		private Material SCMaterial;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_BrokenGlass_2") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/TV_BrokenGlass2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				if (Bullet_1 < 0f)
				{
					Bullet_1 = 0f;
				}
				if (Bullet_2 < 0f)
				{
					Bullet_2 = 0f;
				}
				if (Bullet_3 < 0f)
				{
					Bullet_3 = 0f;
				}
				if (Bullet_4 < 0f)
				{
					Bullet_4 = 0f;
				}
				if (Bullet_5 < 0f)
				{
					Bullet_5 = 0f;
				}
				if (Bullet_6 < 0f)
				{
					Bullet_6 = 0f;
				}
				if (Bullet_7 < 0f)
				{
					Bullet_7 = 0f;
				}
				if (Bullet_8 < 0f)
				{
					Bullet_8 = 0f;
				}
				if (Bullet_9 < 0f)
				{
					Bullet_9 = 0f;
				}
				if (Bullet_10 < 0f)
				{
					Bullet_10 = 0f;
				}
				if (Bullet_11 < 0f)
				{
					Bullet_11 = 0f;
				}
				if (Bullet_12 < 0f)
				{
					Bullet_12 = 0f;
				}
				if (Bullet_1 > 1f)
				{
					Bullet_1 = 1f;
				}
				if (Bullet_2 > 1f)
				{
					Bullet_2 = 1f;
				}
				if (Bullet_3 > 1f)
				{
					Bullet_3 = 1f;
				}
				if (Bullet_4 > 1f)
				{
					Bullet_4 = 1f;
				}
				if (Bullet_5 > 1f)
				{
					Bullet_5 = 1f;
				}
				if (Bullet_6 > 1f)
				{
					Bullet_6 = 1f;
				}
				if (Bullet_7 > 1f)
				{
					Bullet_7 = 1f;
				}
				if (Bullet_8 > 1f)
				{
					Bullet_8 = 1f;
				}
				if (Bullet_9 > 1f)
				{
					Bullet_9 = 1f;
				}
				if (Bullet_10 > 1f)
				{
					Bullet_10 = 1f;
				}
				if (Bullet_11 > 1f)
				{
					Bullet_11 = 1f;
				}
				if (Bullet_12 > 1f)
				{
					Bullet_12 = 1f;
				}
				material.SetFloat("_Bullet_1", Bullet_1);
				material.SetFloat("_Bullet_2", Bullet_2);
				material.SetFloat("_Bullet_3", Bullet_3);
				material.SetFloat("_Bullet_4", Bullet_4);
				material.SetFloat("_Bullet_5", Bullet_5);
				material.SetFloat("_Bullet_6", Bullet_6);
				material.SetFloat("_Bullet_7", Bullet_7);
				material.SetFloat("_Bullet_8", Bullet_8);
				material.SetFloat("_Bullet_9", Bullet_9);
				material.SetFloat("_Bullet_10", Bullet_10);
				material.SetFloat("_Bullet_11", Bullet_11);
				material.SetFloat("_Bullet_12", Bullet_12);
				material.SetTexture("_MainTex2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Chromatical")]
	public class CameraFilterPack_TV_Chromatical : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(0f, 3f)]
		public float Speed = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Chromatical");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime * 2f;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Fade", Fade);
				material.SetFloat("Intensity", Intensity);
				material.SetFloat("Speed", Speed);
				material.SetVector("_ScreenResolution", new Vector2(Screen.width, Screen.height));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Chromatical2")]
	public class CameraFilterPack_TV_Chromatical2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Aberration = 2f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float ZoomFade = 1f;

		[Range(0f, 8f)]
		public float ZoomSpeed = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Chromatical2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Aberration);
				material.SetFloat("Fade", Fade);
				material.SetFloat("ZoomFade", ZoomFade);
				material.SetFloat("ZoomSpeed", ZoomSpeed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Glitch/Compression FX")]
	public class CameraFilterPack_TV_CompressionFX : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(-10f, 10f)]
		public float Parasite = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_CompressionFX");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Parasite", Parasite);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Distorted")]
	public class CameraFilterPack_TV_Distorted : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 10f)]
		public float Distortion = 1f;

		[Range(-0.01f, 0.01f)]
		public float RGB = 0.002f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Distorted");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("_RGB", RGB);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Horror")]
	public class CameraFilterPack_TV_Horror : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float Distortion = 1f;

		private Texture2D Texture2;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			Texture2 = Resources.Load("CameraFilterPack_TV_HorrorFX") as Texture2D;
			SCShader = Shader.Find("CameraFilterPack/TV_Horror");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Fade", Fade);
				material.SetFloat("Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				material.SetTexture("Texture2", Texture2);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/LED")]
	public class CameraFilterPack_TV_LED : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0f, 1f)]
		public float Fade;

		[Range(1f, 10f)]
		private float Distortion = 1f;

		[Range(1f, 15f)]
		public int Size = 5;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_LED");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Size", Size);
				material.SetFloat("Fade", Fade);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Movie Noise")]
	public class CameraFilterPack_TV_MovieNoise : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.0001f, 1f)]
		public float Fade = 0.01f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_MovieNoise");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Noise")]
	public class CameraFilterPack_TV_Noise : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.0001f, 1f)]
		public float Fade = 0.01f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Noise");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Old Film/Old")]
	public class CameraFilterPack_TV_Old : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 10f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Old");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Old Film/Old_Movie")]
	public class CameraFilterPack_TV_Old_Movie : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 10f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Old_Movie");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Old Film/Old_Movie_2")]
	public class CameraFilterPack_TV_Old_Movie_2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 60f)]
		public float FramePerSecond = 15f;

		[Range(0f, 5f)]
		public float Contrast = 1f;

		[Range(0f, 4f)]
		public float Burn;

		[Range(0f, 16f)]
		public float SceneCut = 1f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Old_Movie_2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", FramePerSecond);
				material.SetFloat("_Value2", Contrast);
				material.SetFloat("_Value3", Burn);
				material.SetFloat("_Value4", SceneCut);
				material.SetFloat("_Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Planet Mars")]
	public class CameraFilterPack_TV_PlanetMars : MonoBehaviour
	{
		public Shader SCShader;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private float TimeX = 1f;

		[Range(-10f, 10f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_PlanetMars");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Posterize")]
	public class CameraFilterPack_TV_Posterize : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 256f)]
		public float Posterize = 64f;

		[Range(0f, 1f)]
		public float Fade = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Posterize");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("Fade", Fade);
				material.SetFloat("_Distortion", Posterize);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/RGB Display")]
	public class CameraFilterPack_TV_Rgb : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(0.01f, 4f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Rgb");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Tiles")]
	public class CameraFilterPack_TV_Tiles : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.5f, 2f)]
		public float Size = 1f;

		[Range(0f, 10f)]
		public float Intensity = 4f;

		[Range(0f, 1f)]
		public float StretchX = 0.6f;

		[Range(0f, 1f)]
		public float StretchY = 0.4f;

		[Range(0f, 1f)]
		public float Fade = 0.6f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Tiles");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Intensity);
				material.SetFloat("_Value3", StretchX);
				material.SetFloat("_Value4", StretchY);
				material.SetFloat("Fade", Fade);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/VHS/VHS")]
	public class CameraFilterPack_TV_VHS : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(1f, 256f)]
		public float Cryptage = 64f;

		[Range(1f, 100f)]
		public float Parasite = 32f;

		[Range(0f, 3f)]
		public float Calibrage;

		[Range(0f, 1f)]
		public float WhiteParasite = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_VHS");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Cryptage);
				material.SetFloat("_Value2", Parasite);
				material.SetFloat("_Value3", Calibrage);
				material.SetFloat("_Value4", WhiteParasite);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/VHS/VHS_Rewind")]
	public class CameraFilterPack_TV_VHS_Rewind : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Cryptage = 1f;

		[Range(-20f, 20f)]
		public float Parasite = 9f;

		[Range(-20f, 20f)]
		public float Parasite2 = 12f;

		[Range(0f, 1f)]
		private float WhiteParasite = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_VHS_Rewind");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Cryptage);
				material.SetFloat("_Value2", Parasite);
				material.SetFloat("_Value3", Parasite2);
				material.SetFloat("_Value4", WhiteParasite);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/VHS/VCR Distortion")]
	public class CameraFilterPack_TV_Vcr : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 10f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Vcr");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Video3D")]
	public class CameraFilterPack_TV_Video3D : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Video3D");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Videoflip")]
	public class CameraFilterPack_TV_Videoflip : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Videoflip");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Vignetting")]
	public class CameraFilterPack_TV_Vignetting : MonoBehaviour
	{
		public Shader SCShader;

		private Material SCMaterial;

		private Texture2D Vignette;

		[Range(0f, 1f)]
		public float Vignetting = 1f;

		[Range(0f, 1f)]
		public float VignettingFull;

		[Range(0f, 1f)]
		public float VignettingDirt;

		public Color VignettingColor = new Color(0f, 0f, 0f, 1f);

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Vignetting");
			Vignette = Resources.Load("CameraFilterPack_TV_Vignetting1") as Texture2D;
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				material.SetTexture("Vignette", Vignette);
				material.SetFloat("_Vignetting", Vignetting);
				material.SetFloat("_Vignetting2", VignettingFull);
				material.SetColor("_VignettingColor", VignettingColor);
				material.SetFloat("_VignettingDirt", VignettingDirt);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/Vintage")]
	public class CameraFilterPack_TV_Vintage : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		[Range(1f, 10f)]
		public float Distortion = 1f;

		private Material SCMaterial;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_Vintage");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Distortion", Distortion);
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/WideScreenCircle")]
	public class CameraFilterPack_TV_WideScreenCircle : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.8f)]
		public float Size = 0.55f;

		[Range(0.01f, 0.4f)]
		public float Smooth = 0.01f;

		[Range(0f, 10f)]
		private float StretchX = 1f;

		[Range(0f, 10f)]
		private float StretchY = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_WideScreenCircle");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Smooth);
				material.SetFloat("_Value3", StretchX);
				material.SetFloat("_Value4", StretchY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/WideScreenHV")]
	public class CameraFilterPack_TV_WideScreenHV : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.8f)]
		public float Size = 0.55f;

		[Range(0.001f, 0.4f)]
		public float Smooth = 0.01f;

		[Range(0f, 10f)]
		private float StretchX = 1f;

		[Range(0f, 10f)]
		private float StretchY = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_WideScreenHV");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Smooth);
				material.SetFloat("_Value3", StretchX);
				material.SetFloat("_Value4", StretchY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/WideScreenHorizontal")]
	public class CameraFilterPack_TV_WideScreenHorizontal : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.8f)]
		public float Size = 0.55f;

		[Range(0.001f, 0.4f)]
		public float Smooth = 0.01f;

		[Range(0f, 10f)]
		private float StretchX = 1f;

		[Range(0f, 10f)]
		private float StretchY = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_WideScreenHorizontal");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Smooth);
				material.SetFloat("_Value3", StretchX);
				material.SetFloat("_Value4", StretchY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/TV/WideScreenVertical")]
	public class CameraFilterPack_TV_WideScreenVertical : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.8f)]
		public float Size = 0.55f;

		[Range(0.001f, 0.4f)]
		public float Smooth = 0.01f;

		[Range(0f, 10f)]
		private float StretchX = 1f;

		[Range(0f, 10f)]
		private float StretchY = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/TV_WideScreenVertical");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Smooth);
				material.SetFloat("_Value3", StretchX);
				material.SetFloat("_Value4", StretchY);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/VHS/Tracking")]
	public class CameraFilterPack_VHS_Tracking : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 2f)]
		public float Tracking = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/VHS_Tracking");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Tracking);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Aura")]
	public class CameraFilterPack_Vision_Aura : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 2f)]
		public float Twist = 1f;

		[Range(-4f, 4f)]
		public float Speed = 1f;

		public Color Color = new Color(0.16f, 0.57f, 0.19f);

		[Range(-1f, 2f)]
		public float PosX = 0.5f;

		[Range(-1f, 2f)]
		public float PosY = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Aura");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Twist);
				material.SetColor("_Value2", Color);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetFloat("_Value5", Speed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/AuraDistortion")]
	public class CameraFilterPack_Vision_AuraDistortion : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 2f)]
		public float Twist = 1f;

		[Range(-4f, 4f)]
		public float Speed = 1f;

		public Color Color = new Color(0.16f, 0.57f, 0.19f);

		[Range(-1f, 2f)]
		public float PosX = 0.5f;

		[Range(-1f, 2f)]
		public float PosY = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_AuraDistortion");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Twist);
				material.SetColor("_Value2", Color);
				material.SetFloat("_Value3", PosX);
				material.SetFloat("_Value4", PosY);
				material.SetFloat("_Value5", Speed);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Blood")]
	public class CameraFilterPack_Vision_Blood : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.01f, 1f)]
		public float HoleSize = 0.6f;

		[Range(-1f, 1f)]
		public float HoleSmooth = 0.3f;

		[Range(-2f, 2f)]
		public float Color1 = 0.2f;

		[Range(-2f, 2f)]
		public float Color2 = 0.9f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Blood");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", HoleSize);
				material.SetFloat("_Value2", HoleSmooth);
				material.SetFloat("_Value3", Color1);
				material.SetFloat("_Value4", Color2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Blood_Fast")]
	public class CameraFilterPack_Vision_Blood_Fast : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.01f, 1f)]
		public float HoleSize = 0.6f;

		[Range(-1f, 1f)]
		public float HoleSmooth = 0.3f;

		[Range(-2f, 2f)]
		public float Color1 = 0.2f;

		[Range(-2f, 2f)]
		public float Color2 = 0.9f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Blood_Fast");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", HoleSize);
				material.SetFloat("_Value2", HoleSmooth);
				material.SetFloat("_Value3", Color1);
				material.SetFloat("_Value4", Color2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Crystal")]
	public class CameraFilterPack_Vision_Crystal : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-10f, 10f)]
		public float Value = 1f;

		[Range(-1f, 1f)]
		public float X = 1f;

		[Range(-1f, 1f)]
		public float Y = 1f;

		[Range(-1f, 1f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Crystal");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", X);
				material.SetFloat("_Value3", Y);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Drost")]
	public class CameraFilterPack_Vision_Drost : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 0.4f)]
		public float Intensity = 0.4f;

		[Range(0f, 10f)]
		public float Speed = 1f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Drost");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Intensity);
				material.SetFloat("_Value2", Speed);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Hell_Blood")]
	public class CameraFilterPack_Vision_Hell_Blood : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Hole_Size = 0.57f;

		[Range(0f, 0.5f)]
		public float Hole_Smooth = 0.362f;

		[Range(-2f, 2f)]
		public float Hole_Speed = 0.85f;

		[Range(-10f, 10f)]
		public float Intensity = 0.24f;

		public Color ColorBlood = new Color(1f, 0f, 0f, 1f);

		[Range(-1f, 1f)]
		public float BloodAlternative1;

		[Range(-1f, 1f)]
		public float BloodAlternative2;

		[Range(-1f, 1f)]
		public float BloodAlternative3 = -1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Hell_Blood");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Hole_Size);
				material.SetFloat("_Value2", Hole_Smooth);
				material.SetFloat("_Value3", Hole_Speed * 15f);
				material.SetColor("ColorBlood", ColorBlood);
				material.SetFloat("_Value4", Intensity);
				material.SetFloat("BloodAlternative1", BloodAlternative1);
				material.SetFloat("BloodAlternative2", BloodAlternative2);
				material.SetFloat("BloodAlternative3", BloodAlternative3);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Plasma")]
	public class CameraFilterPack_Vision_Plasma : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(-2f, 2f)]
		public float Value = 0.6f;

		[Range(-2f, 2f)]
		public float Value2 = 0.2f;

		[Range(0f, 60f)]
		public float Intensity = 15f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Plasma");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Psycho")]
	public class CameraFilterPack_Vision_Psycho : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0.01f, 1f)]
		public float HoleSize = 0.6f;

		[Range(-1f, 1f)]
		public float HoleSmooth = 0.3f;

		[Range(-2f, 2f)]
		public float Color1 = 0.2f;

		[Range(-2f, 2f)]
		public float Color2 = 0.9f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Psycho");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", HoleSize);
				material.SetFloat("_Value2", HoleSmooth);
				material.SetFloat("_Value3", Color1);
				material.SetFloat("_Value4", Color2);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Rainbow")]
	public class CameraFilterPack_Vision_Rainbow : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 10f)]
		public float Speed = 1f;

		[Range(0f, 1f)]
		public float PosX = 0.5f;

		[Range(0f, 1f)]
		public float PosY = 0.5f;

		[Range(0f, 5f)]
		public float Colors = 0.5f;

		[Range(0f, 1f)]
		public float Vision = 0.5f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Rainbow");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Speed);
				material.SetFloat("_Value2", PosX);
				material.SetFloat("_Value3", PosY);
				material.SetFloat("_Value4", Colors);
				material.SetFloat("_Value5", Vision);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/SniperScore")]
	public class CameraFilterPack_Vision_SniperScore : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Fade = 1f;

		[Range(0f, 1f)]
		public float Size = 0.45f;

		[Range(0.01f, 0.4f)]
		public float Smooth = 0.045f;

		[Range(0f, 1f)]
		public float _Cible = 0.5f;

		[Range(0f, 1f)]
		public float _Distortion = 0.5f;

		[Range(0f, 1f)]
		public float _ExtraColor = 0.5f;

		[Range(0f, 1f)]
		public float _ExtraLight = 0.35f;

		public Color _Tint = new Color(0f, 0.6f, 0f, 0.25f);

		[Range(0f, 10f)]
		private float StretchX = 1f;

		[Range(0f, 10f)]
		private float StretchY = 1f;

		[Range(-1f, 1f)]
		public float _PosX;

		[Range(-1f, 1f)]
		public float _PosY;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_SniperScore");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_Fade", Fade);
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Size);
				material.SetFloat("_Value2", Smooth);
				material.SetFloat("_Value3", StretchX);
				material.SetFloat("_Value4", StretchY);
				material.SetFloat("_Cible", _Cible);
				material.SetFloat("_ExtraColor", _ExtraColor);
				material.SetFloat("_Distortion", _Distortion);
				material.SetFloat("_PosX", _PosX);
				material.SetFloat("_PosY", _PosY);
				material.SetColor("_Tint", _Tint);
				material.SetFloat("_ExtraLight", _ExtraLight);
				Vector2 vector = new Vector2(Screen.width, Screen.height);
				material.SetVector("_ScreenResolution", new Vector4(vector.x, vector.y, vector.y / vector.x, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Tunnel")]
	public class CameraFilterPack_Vision_Tunnel : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Value = 0.6f;

		[Range(0f, 1f)]
		public float Value2 = 0.4f;

		[Range(0f, 1f)]
		public float Intensity = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Tunnel");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Warp")]
	public class CameraFilterPack_Vision_Warp : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Value = 0.6f;

		[Range(0f, 1f)]
		public float Value2 = 0.6f;

		[Range(0f, 10f)]
		private float Value3 = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Warp");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Value3);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	[ExecuteInEditMode]
	[AddComponentMenu("Camera Filter Pack/Vision/Warp2")]
	public class CameraFilterPack_Vision_Warp2 : MonoBehaviour
	{
		public Shader SCShader;

		private float TimeX = 1f;

		private Material SCMaterial;

		[Range(0f, 1f)]
		public float Value = 0.5f;

		[Range(0f, 1f)]
		public float Value2 = 0.2f;

		[Range(-1f, 2f)]
		public float Intensity = 1f;

		[Range(0f, 10f)]
		private float Value4 = 1f;

		private Material material
		{
			get
			{
				if (SCMaterial == null)
				{
					SCMaterial = new Material(SCShader);
					SCMaterial.hideFlags = HideFlags.HideAndDontSave;
				}
				return SCMaterial;
			}
		}

		private void Start()
		{
			SCShader = Shader.Find("CameraFilterPack/Vision_Warp2");
			if (!SystemInfo.supportsImageEffects)
			{
				base.enabled = false;
			}
		}

		private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
		{
			if (SCShader != null)
			{
				TimeX += Time.deltaTime;
				if (TimeX > 100f)
				{
					TimeX = 0f;
				}
				material.SetFloat("_TimeX", TimeX);
				material.SetFloat("_Value", Value);
				material.SetFloat("_Value2", Value2);
				material.SetFloat("_Value3", Intensity);
				material.SetFloat("_Value4", Value4);
				material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
				Graphics.Blit(sourceTexture, destTexture, material);
			}
			else
			{
				Graphics.Blit(sourceTexture, destTexture);
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			if ((bool)SCMaterial)
			{
				UnityEngine.Object.DestroyImmediate(SCMaterial);
			}
		}
	}
	public class GameActions
	{
		public delegate void SimpleAction();
	}
	public class ButtonSound : MonoBehaviour
	{
		public string audioSourceContainerName = "SoundFX";

		public AudioClip sound;

		private AudioSource _audioSource;

		private void Start()
		{
			GameObject gameObject = GameObject.Find(audioSourceContainerName);
			if (gameObject != null)
			{
				_audioSource = gameObject.GetComponent<AudioSource>();
			}
		}

		public virtual void PlaySound()
		{
			if (_audioSource != null)
			{
				_audioSource.PlayOneShot(sound);
			}
		}

		public virtual void PlaySound(bool activated)
		{
			if (activated)
			{
				PlaySound();
			}
		}
	}
	public class ExitButton : MonoBehaviour
	{
		public virtual void Activate()
		{
			Application.Quit();
		}
	}
	public class LoadSceneButton : MonoBehaviour
	{
		public string sceneName;

		public virtual void OnClick()
		{
			SceneManager.LoadScene(sceneName);
		}
	}
	[ExecuteInEditMode]
	public class PlatformDependentActivator : MonoBehaviour
	{
		public GameObject standalone;

		public GameObject mobile;
	}
	[Serializable]
	[PostProcess(typeof(IL3DNFogPPPPSRenderer), PostProcessEvent.BeforeStack, "IL3DN/Fog", true)]
	public sealed class IL3DN_Fog_PP : PostProcessEffectSettings
	{
		[Range(0f, 100f)]
		[Tooltip("Density")]
		public FloatParameter _Density = new FloatParameter
		{
			value = 20f
		};

		[Tooltip("Near Color")]
		public ColorParameter _NearColor = new ColorParameter
		{
			value = new Color(1f, 0.203827f, 0f, 0f)
		};

		[Tooltip("Far Color")]
		public ColorParameter _FarColor = new ColorParameter
		{
			value = new Color(0f, 0.2739539f, 1f, 0f)
		};

		[Tooltip("Glow Color")]
		public ColorParameter _GlowColor = new ColorParameter
		{
			value = new Color(1f, 0.203827f, 0f, 0f)
		};

		[Tooltip("Exclude Skybox")]
		public BoolParameter _ExcludeSkybox = new BoolParameter
		{
			value = true
		};
	}
	public sealed class IL3DNFogPPPPSRenderer : PostProcessEffectRenderer<IL3DN_Fog_PP>
	{
		public override void Render(PostProcessRenderContext context)
		{
			PropertySheet propertySheet = context.propertySheets.Get(Shader.Find("IL3DN/FogPP"));
			propertySheet.properties.SetFloat("_Density", base.settings._Density);
			propertySheet.properties.SetColor("_NearColor", base.settings._NearColor);
			propertySheet.properties.SetColor("_FarColor", base.settings._FarColor);
			propertySheet.properties.SetColor("_GlowColor", base.settings._GlowColor);
			if ((bool)base.settings._ExcludeSkybox)
			{
				Shader.EnableKeyword("_EXCLUDESKYBOX_ON");
			}
			else
			{
				Shader.DisableKeyword("_EXCLUDESKYBOX_ON");
			}
			context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0);
		}
	}
	public class CausticDecal : MonoBehaviour
	{
		public float maxAngle = 90f;

		public float pushDistance = 0.009f;

		public LayerMask affectedLayers = -1;

		private void OnDrawGizmosSelected()
		{
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
		}

		public Bounds GetBounds()
		{
			Vector3 lossyScale = base.transform.lossyScale;
			Vector3 vector = -lossyScale / 2f;
			Vector3 vector2 = lossyScale / 2f;
			Vector3[] array = new Vector3[8]
			{
				new Vector3(vector.x, vector.y, vector.z),
				new Vector3(vector2.x, vector.y, vector.z),
				new Vector3(vector.x, vector2.y, vector.z),
				new Vector3(vector2.x, vector2.y, vector.z),
				new Vector3(vector.x, vector.y, vector2.z),
				new Vector3(vector2.x, vector.y, vector2.z),
				new Vector3(vector.x, vector2.y, vector2.z),
				new Vector3(vector2.x, vector2.y, vector2.z)
			};
			for (int i = 0; i < 8; i++)
			{
				array[i] = base.transform.TransformDirection(array[i]);
			}
			vector = (vector2 = array[0]);
			Vector3[] array2 = array;
			foreach (Vector3 rhs in array2)
			{
				vector = Vector3.Min(vector, rhs);
				vector2 = Vector3.Max(vector2, rhs);
			}
			return new Bounds(base.transform.position, vector2 - vector);
		}
	}
	public class BoatSimulator : MonoBehaviour
	{
		private Rigidbody rigid;

		private bool keyPressedW;

		private bool keyPressedA;

		private bool keyPressedS;

		private bool keyPressedD;

		private void Start()
		{
			rigid = GetComponent<Rigidbody>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.W))
			{
				keyPressedW = true;
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				keyPressedA = true;
			}
			if (Input.GetKeyDown(KeyCode.S))
			{
				keyPressedS = true;
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				keyPressedD = true;
			}
			if (Input.GetKeyUp(KeyCode.W))
			{
				keyPressedW = false;
			}
			if (Input.GetKeyUp(KeyCode.A))
			{
				keyPressedA = false;
			}
			if (Input.GetKeyUp(KeyCode.S))
			{
				keyPressedS = false;
			}
			if (Input.GetKeyUp(KeyCode.D))
			{
				keyPressedD = false;
			}
			if (keyPressedW)
			{
				rigid.AddForce(base.transform.right * 500f * Time.deltaTime);
			}
			if (keyPressedS)
			{
				rigid.AddForce(-base.transform.right * 500f * Time.deltaTime);
			}
			if (keyPressedD)
			{
				rigid.AddTorque(base.transform.up * 200f * Time.deltaTime);
			}
			if (keyPressedA)
			{
				rigid.AddTorque(-base.transform.up * 200f * Time.deltaTime);
			}
		}
	}
	public class CubeGenerator : MonoBehaviour
	{
		public GameObject cubes;

		private void Start()
		{
			InvokeRepeating("UpdateCube", 1f, 2f);
		}

		private void UpdateCube()
		{
			Vector3 position = base.transform.position;
			position.y += 10f;
			position.z -= 4f;
			position += UnityEngine.Random.insideUnitSphere * 7f;
			GameObject obj = UnityEngine.Object.Instantiate(cubes, position, Quaternion.Euler(UnityEngine.Random.Range(0, 360), UnityEngine.Random.Range(0, 360), UnityEngine.Random.Range(0, 360)));
			obj.AddComponent<Buoyancy>().Density = UnityEngine.Random.Range(700, 850);
			obj.AddComponent<Rigidbody>().mass = UnityEngine.Random.Range(100, 150);
			UnityEngine.Object.Destroy(obj, 30f);
		}
	}
	public class DemoGUIWater : MonoBehaviour
	{
		public float UpdateInterval = 0.5f;

		public int MaxScenes = 2;

		public bool IsMobileScene;

		public Light Sun;

		public GameObject SunTransform;

		public GameObject Boat;

		public GameObject water1;

		public GameObject water2;

		public float angle = 130f;

		private bool canUpdateTestMaterial;

		private GameObject cam;

		private GUIStyle guiStyleHeader = new GUIStyle();

		private Material currentWaterMaterial;

		private Material causticMaterial;

		private GameObject currentWater;

		private float transparent;

		private float fadeBlend;

		private float refl;

		private float refraction;

		private float waterWaveScaleXZ = 1f;

		private Vector4 waterDirection;

		private Vector4 causticDirection;

		private Vector4 foamDirection;

		private Vector4 ABDirection;

		private Vector4 CDDirection;

		private float direction = 1f;

		private Color reflectionColor;

		private Vector3 oldCausticScale;

		private float oldTextureScale;

		private float oldWaveScale;

		private GameObject caustic;

		private float startSunIntencity;

		private void Start()
		{
			guiStyleHeader.fontSize = 18;
			guiStyleHeader.normal.textColor = new Color(1f, 0f, 0f);
			UpdateCurrentWater();
		}

		private void UpdateCurrentWater()
		{
			if (Boat != null)
			{
				Boat.SetActive(value: false);
				Boat.SetActive(value: true);
			}
			startSunIntencity = Sun.intensity;
			currentWater = GameObject.Find("Water");
			currentWaterMaterial = currentWater.GetComponent<Renderer>().material;
			refl = currentWaterMaterial.GetColor("_ReflectionColor").r;
			if (!IsMobileScene)
			{
				transparent = currentWaterMaterial.GetFloat("_DepthTransperent");
			}
			if (!IsMobileScene)
			{
				fadeBlend = currentWaterMaterial.GetFloat("_FadeDepth");
			}
			refraction = currentWaterMaterial.GetFloat("_Distortion");
			oldTextureScale = currentWaterMaterial.GetFloat("_TexturesScale");
			oldWaveScale = currentWaterMaterial.GetFloat("_WaveScale");
			GameObject gameObject = GameObject.Find("InfiniteWaterMesh");
			if (gameObject != null)
			{
				gameObject.GetComponent<Renderer>().material = currentWaterMaterial;
			}
			GameObject gameObject2 = GameObject.Find("ProjectorCausticScale");
			if (gameObject2 != null)
			{
				oldCausticScale = gameObject2.transform.localScale;
			}
			caustic = GameObject.Find("Caustic");
			if (IsMobileScene)
			{
				caustic.SetActive(value: true);
			}
			if (!IsMobileScene)
			{
				causticMaterial = caustic.GetComponent<Projector>().material;
			}
			waterDirection = currentWaterMaterial.GetVector("_Direction");
			if (!IsMobileScene)
			{
				foamDirection = currentWaterMaterial.GetVector("_FoamDirection");
			}
			if (!IsMobileScene)
			{
				causticDirection = causticMaterial.GetVector("_CausticDirection");
			}
			ABDirection = currentWaterMaterial.GetVector("_GDirectionAB");
			CDDirection = currentWaterMaterial.GetVector("_GDirectionCD");
		}

		private void OnGUI()
		{
			if (IsMobileScene)
			{
				GUIMobile();
			}
			else
			{
				GUIPC();
			}
		}

		private void GUIMobile()
		{
			if (currentWaterMaterial == null)
			{
				return;
			}
			if (GUI.Button(new Rect(10f, 35f, 150f, 40f), "On/Off Ripples"))
			{
				caustic.SetActive(value: true);
				water1.SetActive(!water1.activeSelf);
				water2.SetActive(!water2.activeSelf);
				caustic = GameObject.Find("Caustic");
				if (IsMobileScene)
				{
					caustic.SetActive(value: true);
				}
			}
			if (GUI.Button(new Rect(10f, 190f, 150f, 40f), "On/Off caustic"))
			{
				caustic.SetActive(!caustic.activeSelf);
			}
			GUIStyle gUIStyle = new GUIStyle();
			gUIStyle.normal.textColor = new Color(1f, 1f, 1f);
			angle = GUI.HorizontalSlider(new Rect(10f, 102f, 120f, 15f), angle, 30f, 240f);
			GUI.Label(new Rect(140f, 100f, 30f, 30f), "Day Time", gUIStyle);
			float value = Mathf.Sin((angle - 60f) / 50f);
			Sun.intensity = Mathf.Clamp01(value) * startSunIntencity + 0.05f;
			SunTransform.transform.rotation = Quaternion.Euler(0f, 0f, angle);
			refl = GUI.HorizontalSlider(new Rect(10f, 122f, 120f, 15f), refl, 0f, 1f);
			reflectionColor = new Color(refl, refl, refl, 1f);
			GUI.Label(new Rect(140f, 120f, 30f, 30f), "Reflection", gUIStyle);
			currentWaterMaterial.SetColor("_ReflectionColor", reflectionColor);
			refraction = GUI.HorizontalSlider(new Rect(10f, 142f, 120f, 15f), refraction, 0f, 700f);
			GUI.Label(new Rect(140f, 140f, 30f, 30f), "Distortion", gUIStyle);
			currentWaterMaterial.SetFloat("_Distortion", refraction);
			waterWaveScaleXZ = GUI.HorizontalSlider(new Rect(10f, 162f, 120f, 15f), waterWaveScaleXZ, 0.3f, 3f);
			GUI.Label(new Rect(140f, 160f, 30f, 30f), "Scale", gUIStyle);
			currentWaterMaterial.SetFloat("_WaveScale", oldWaveScale * waterWaveScaleXZ);
			currentWaterMaterial.SetFloat("_TexturesScale", oldTextureScale * waterWaveScaleXZ);
		}

		private void GUIPC()
		{
			if (currentWaterMaterial == null)
			{
				return;
			}
			if (GUI.Button(new Rect(10f, 35f, 150f, 40f), "Change Scene "))
			{
				if (Application.loadedLevel == MaxScenes - 1)
				{
					Application.LoadLevel(0);
				}
				else
				{
					Application.LoadLevel(Application.loadedLevel + 1);
				}
				UpdateCurrentWater();
			}
			GUIStyle gUIStyle = new GUIStyle();
			gUIStyle.normal.textColor = new Color(1f, 1f, 1f);
			angle = GUI.HorizontalSlider(new Rect(10f, 102f, 120f, 15f), angle, 30f, 240f);
			GUI.Label(new Rect(140f, 100f, 30f, 30f), "Day Time", gUIStyle);
			float value = Mathf.Sin((angle - 60f) / 50f);
			Sun.intensity = Mathf.Clamp01(value) * startSunIntencity + 0.05f;
			SunTransform.transform.rotation = Quaternion.Euler(0f, 0f, angle);
			transparent = GUI.HorizontalSlider(new Rect(10f, 122f, 120f, 15f), transparent, 0f, 1f);
			GUI.Label(new Rect(140f, 120f, 30f, 30f), "Depth Transperent", gUIStyle);
			currentWaterMaterial.SetFloat("_DepthTransperent", transparent);
			fadeBlend = GUI.HorizontalSlider(new Rect(10f, 142f, 120f, 15f), fadeBlend, 0f, 1f);
			GUI.Label(new Rect(140f, 140f, 30f, 30f), "Fade Depth", gUIStyle);
			currentWaterMaterial.SetFloat("_FadeDepth", fadeBlend);
			refl = GUI.HorizontalSlider(new Rect(10f, 162f, 120f, 15f), refl, 0f, 1f);
			reflectionColor = new Color(refl, refl, refl, 1f);
			GUI.Label(new Rect(140f, 160f, 30f, 30f), "Reflection", gUIStyle);
			currentWaterMaterial.SetColor("_ReflectionColor", reflectionColor);
			refraction = GUI.HorizontalSlider(new Rect(10f, 182f, 120f, 15f), refraction, 0f, 700f);
			GUI.Label(new Rect(140f, 180f, 30f, 30f), "Distortion", gUIStyle);
			currentWaterMaterial.SetFloat("_Distortion", refraction);
			waterWaveScaleXZ = GUI.HorizontalSlider(new Rect(10f, 202f, 120f, 15f), waterWaveScaleXZ, 0.3f, 3f);
			GUI.Label(new Rect(140f, 200f, 30f, 30f), "Scale", gUIStyle);
			currentWaterMaterial.SetFloat("_WaveScale", oldWaveScale * waterWaveScaleXZ);
			currentWaterMaterial.SetFloat("_TexturesScale", oldTextureScale * waterWaveScaleXZ);
			GameObject gameObject = GameObject.Find("ProjectorCausticScale");
			Vector3 vector = oldCausticScale * waterWaveScaleXZ;
			if ((double)(gameObject.transform.localScale - vector).magnitude > 0.01)
			{
				gameObject.transform.localScale = vector;
				caustic.GetComponent<ProjectorMatrix>().UpdateMatrix();
			}
			direction = GUI.HorizontalSlider(new Rect(10f, 222f, 120f, 15f), direction, 1f, -1f);
			GUI.Label(new Rect(140f, 220f, 30f, 30f), "Direction", gUIStyle);
			currentWaterMaterial.SetVector("_Direction", waterDirection * direction);
			currentWaterMaterial.SetVector("_FoamDirection", foamDirection * direction);
			causticMaterial.SetVector("_CausticDirection", causticDirection * direction);
			currentWaterMaterial.SetVector("_GDirectionAB", ABDirection * direction);
			currentWaterMaterial.SetVector("_GDirectionCD", CDDirection * direction);
		}

		private void OnDestroy()
		{
			if (!IsMobileScene)
			{
				causticMaterial.SetVector("_CausticDirection", causticDirection);
			}
		}

		private void OnSetColorMain(Color color)
		{
			currentWaterMaterial.SetColor("_Color", color);
		}
	}
	public class FPS : MonoBehaviour
	{
		private readonly GUIStyle guiStyleHeader = new GUIStyle();

		private float timeleft;

		private float fps;

		private int frames;

		private void Awake()
		{
			guiStyleHeader.fontSize = 14;
			guiStyleHeader.normal.textColor = new Color(1f, 0f, 0f);
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
		}

		private void Update()
		{
			timeleft -= Time.deltaTime;
			frames++;
			if ((double)timeleft <= 0.0)
			{
				fps = frames;
				timeleft = 1f;
				frames = 0;
			}
		}
	}
	public class Buoyancy : MonoBehaviour
	{
		public float Density = 700f;

		public int SlicesPerAxis = 2;

		public bool IsConcave;

		public int VoxelsLimit = 16;

		public float WaveVelocity = 0.05f;

		private const float Dampfer = 0.1f;

		private const float WaterDensity = 1000f;

		private float voxelHalfHeight;

		private float localArchimedesForce;

		private List<Vector3> voxels;

		private bool isMeshCollider;

		private List<Vector3[]> forces;

		private WaterRipples waterRipples;

		private void Start()
		{
			forces = new List<Vector3[]>();
			Quaternion rotation = base.transform.rotation;
			Vector3 position = base.transform.position;
			base.transform.rotation = Quaternion.identity;
			base.transform.position = Vector3.zero;
			if (GetComponent<Collider>() == null)
			{
				base.gameObject.AddComponent<MeshCollider>();
				UnityEngine.Debug.LogWarning($"[Buoyancy.cs] Object \"{base.name}\" had no collider. MeshCollider has been added.");
			}
			isMeshCollider = GetComponent<MeshCollider>() != null;
			Bounds bounds = GetComponent<Collider>().bounds;
			if (bounds.size.x < bounds.size.y)
			{
				voxelHalfHeight = bounds.size.x;
			}
			else
			{
				voxelHalfHeight = bounds.size.y;
			}
			if (bounds.size.z < voxelHalfHeight)
			{
				voxelHalfHeight = bounds.size.z;
			}
			voxelHalfHeight /= 2 * SlicesPerAxis;
			if (GetComponent<Rigidbody>() == null)
			{
				base.gameObject.AddComponent<Rigidbody>();
				UnityEngine.Debug.LogWarning($"[Buoyancy.cs] Object \"{base.name}\" had no Rigidbody. Rigidbody has been added.");
			}
			GetComponent<Rigidbody>().centerOfMass = new Vector3(0f, (0f - bounds.extents.y) * 0f, 0f) + base.transform.InverseTransformPoint(bounds.center);
			voxels = SliceIntoVoxels(isMeshCollider && IsConcave);
			base.transform.rotation = rotation;
			base.transform.position = position;
			float num = GetComponent<Rigidbody>().mass / Density;
			WeldPoints(voxels, VoxelsLimit);
			float num2 = 1000f * Mathf.Abs(Physics.gravity.y) * num;
			localArchimedesForce = num2 / (float)voxels.Count;
		}

		private List<Vector3> SliceIntoVoxels(bool concave)
		{
			List<Vector3> list = new List<Vector3>(SlicesPerAxis * SlicesPerAxis * SlicesPerAxis);
			if (concave)
			{
				MeshCollider component = GetComponent<MeshCollider>();
				bool convex = component.convex;
				component.convex = false;
				Bounds bounds = GetComponent<Collider>().bounds;
				for (int i = 0; i < SlicesPerAxis; i++)
				{
					for (int j = 0; j < SlicesPerAxis; j++)
					{
						for (int k = 0; k < SlicesPerAxis; k++)
						{
							float x = bounds.min.x + bounds.size.x / (float)SlicesPerAxis * (0.5f + (float)i);
							float y = bounds.min.y + bounds.size.y / (float)SlicesPerAxis * (0.5f + (float)j);
							float z = bounds.min.z + bounds.size.z / (float)SlicesPerAxis * (0.5f + (float)k);
							Vector3 vector = base.transform.InverseTransformPoint(new Vector3(x, y, z));
							if (PointIsInsideMeshCollider(component, vector))
							{
								list.Add(vector);
							}
						}
					}
				}
				if (list.Count == 0)
				{
					list.Add(bounds.center);
				}
				component.convex = convex;
			}
			else
			{
				Bounds bounds2 = GetComponent<Collider>().bounds;
				for (int l = 0; l < SlicesPerAxis; l++)
				{
					for (int m = 0; m < SlicesPerAxis; m++)
					{
						for (int n = 0; n < SlicesPerAxis; n++)
						{
							float x2 = bounds2.min.x + bounds2.size.x / (float)SlicesPerAxis * (0.5f + (float)l);
							float y2 = bounds2.min.y + bounds2.size.y / (float)SlicesPerAxis * (0.5f + (float)m);
							float z2 = bounds2.min.z + bounds2.size.z / (float)SlicesPerAxis * (0.5f + (float)n);
							Vector3 item = base.transform.InverseTransformPoint(new Vector3(x2, y2, z2));
							list.Add(item);
						}
					}
				}
			}
			return list;
		}

		private static bool PointIsInsideMeshCollider(Collider c, Vector3 p)
		{
			Vector3[] array = new Vector3[6]
			{
				Vector3.up,
				Vector3.down,
				Vector3.left,
				Vector3.right,
				Vector3.forward,
				Vector3.back
			};
			foreach (Vector3 vector in array)
			{
				if (!c.Raycast(new Ray(p - vector * 1000f, vector), out var _, 1000f))
				{
					return false;
				}
			}
			return true;
		}

		private static void FindClosestPoints(IList<Vector3> list, out int firstIndex, out int secondIndex)
		{
			float num = float.MaxValue;
			float num2 = float.MinValue;
			firstIndex = 0;
			secondIndex = 1;
			for (int i = 0; i < list.Count - 1; i++)
			{
				for (int j = i + 1; j < list.Count; j++)
				{
					float num3 = Vector3.Distance(list[i], list[j]);
					if (num3 < num)
					{
						num = num3;
						firstIndex = i;
						secondIndex = j;
					}
					if (num3 > num2)
					{
						num2 = num3;
					}
				}
			}
		}

		private static void WeldPoints(IList<Vector3> list, int targetCount)
		{
			if (list.Count > 2 && targetCount >= 2)
			{
				while (list.Count > targetCount)
				{
					FindClosestPoints(list, out var firstIndex, out var secondIndex);
					Vector3 item = (list[firstIndex] + list[secondIndex]) * 0.5f;
					list.RemoveAt(secondIndex);
					list.RemoveAt(firstIndex);
					list.Add(item);
				}
			}
		}

		private Vector3 GetNormal(Vector3 a, Vector3 b, Vector3 c)
		{
			Vector3 lhs = b - a;
			Vector3 rhs = c - a;
			return Vector3.Cross(lhs, rhs).normalized;
		}

		private void FixedUpdate()
		{
			if (waterRipples == null)
			{
				return;
			}
			forces.Clear();
			int count = voxels.Count;
			Vector3[] array = new Vector3[count];
			for (int i = 0; i < count; i++)
			{
				Vector3 position = base.transform.TransformPoint(voxels[i]);
				array[i] = waterRipples.GetOffsetByPosition(position);
			}
			Vector3 normalized = (GetNormal(array[0], array[1], array[2]) * WaveVelocity + Vector3.up).normalized;
			for (int j = 0; j < count; j++)
			{
				Vector3 vector = base.transform.TransformPoint(voxels[j]);
				float y = array[j].y;
				if (vector.y - voxelHalfHeight < y)
				{
					float num = (y - vector.y) / (2f * voxelHalfHeight) + 0.5f;
					if (num > 1f)
					{
						num = 1f;
					}
					else if (num < 0f)
					{
						num = 0f;
					}
					Vector3 vector2 = -GetComponent<Rigidbody>().GetPointVelocity(vector) * 0.1f * GetComponent<Rigidbody>().mass + Mathf.Sqrt(num) * (normalized * localArchimedesForce);
					GetComponent<Rigidbody>().AddForceAtPosition(vector2, vector);
					forces.Add(new Vector3[2] { vector, vector2 });
				}
			}
		}

		private void OnDrawGizmos()
		{
			if (voxels == null || forces == null)
			{
				return;
			}
			Gizmos.color = Color.yellow;
			foreach (Vector3 voxel in voxels)
			{
				Gizmos.DrawCube(base.transform.TransformPoint(voxel), new Vector3(0.05f, 0.05f, 0.05f));
			}
			Gizmos.color = Color.cyan;
			foreach (Vector3[] force in forces)
			{
				Gizmos.DrawCube(force[0], new Vector3(0.05f, 0.05f, 0.05f));
				Gizmos.DrawLine(force[0], force[0] + force[1] / GetComponent<Rigidbody>().mass);
			}
		}

		private void OnTriggerEnter(Collider collidedObj)
		{
			WaterRipples component = collidedObj.GetComponent<WaterRipples>();
			if (component != null)
			{
				waterRipples = component;
			}
		}

		private void OnEnable()
		{
			waterRipples = null;
		}
	}
	[ExecuteInEditMode]
	public class DepthFix : MonoBehaviour
	{
		private void OnWillRenderObject()
		{
			Camera.current.depthTextureMode |= DepthTextureMode.Depth;
		}
	}
	public class MoveCameraToCharacter : MonoBehaviour
	{
		public GameObject Target;

		private void Update()
		{
			base.transform.position = Target.transform.position;
		}
	}
	public class MoveWaterToCamera : MonoBehaviour
	{
		public GameObject CurrenCamera;

		private void Update()
		{
			if (!(CurrenCamera == null))
			{
				Vector3 position = base.transform.position;
				position.x = CurrenCamera.transform.position.x;
				position.z = CurrenCamera.transform.position.z;
				base.transform.position = position;
				Quaternion rotation = CurrenCamera.transform.rotation;
				rotation.eulerAngles = new Vector3(rotation.eulerAngles.x, 0f, rotation.eulerAngles.z);
			}
		}
	}
	[ExecuteInEditMode]
	public class ProjectorMatrix : MonoBehaviour
	{
		public enum matrixName
		{
			_projectiveMatrWaves,
			_projectiveMatrCausticScale
		}

		public matrixName GlobalMatrixName;

		public Transform ProjectiveTranform;

		public bool UpdateOnStart;

		public bool CanUpdate = true;

		private Transform t;

		private void Start()
		{
			t = base.transform;
			if (UpdateOnStart)
			{
				UpdateMatrix();
			}
		}

		private void Update()
		{
			if (!UpdateOnStart)
			{
				UpdateMatrix();
			}
		}

		public void UpdateMatrix()
		{
			if (CanUpdate)
			{
				Shader.SetGlobalMatrix(GlobalMatrixName.ToString(), ProjectiveTranform.worldToLocalMatrix * t.localToWorldMatrix);
			}
		}
	}
	public class ReflectionCamera : MonoBehaviour
	{
		public LayerMask CullingMask = -17;

		public bool HDR;

		[Range(0.1f, 1f)]
		public float TextureScale = 1f;

		private RenderTexture reflectionTexture;

		private GameObject goCam;

		private Camera reflectionCamera;

		private Vector3 oldPos;

		private static float ClipPlaneOffset = 0.07f;

		private void UpdateCamera(Camera cam)
		{
			CheckCamera(cam);
			if (!(cam == null))
			{
				GL.invertCulling = true;
				Transform transform = base.transform;
				Vector3 eulerAngles = cam.transform.eulerAngles;
				reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
				reflectionCamera.transform.position = cam.transform.position;
				Vector3 position = transform.transform.position;
				position.y = transform.position.y;
				Vector3 up = transform.transform.up;
				float w = 0f - Vector3.Dot(up, position) - ClipPlaneOffset;
				Vector4 plane = new Vector4(up.x, up.y, up.z, w);
				Matrix4x4 zero = Matrix4x4.zero;
				zero = CalculateReflectionMatrix(zero, plane);
				oldPos = cam.transform.position;
				Vector3 position2 = zero.MultiplyPoint(oldPos);
				reflectionCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
				Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
				Matrix4x4 projectionMatrix = cam.projectionMatrix;
				projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
				reflectionCamera.projectionMatrix = projectionMatrix;
				reflectionCamera.transform.position = position2;
				Vector3 eulerAngles2 = cam.transform.eulerAngles;
				reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
				reflectionCamera.Render();
				GL.invertCulling = false;
			}
		}

		private void CheckCamera(Camera cam)
		{
			if (goCam == null)
			{
				reflectionTexture = new RenderTexture((int)((float)Screen.width * TextureScale), (int)((float)Screen.height * TextureScale), 16, RenderTextureFormat.Default);
				reflectionTexture.DiscardContents();
				goCam = new GameObject("Water Refl Camera");
				goCam.hideFlags = HideFlags.DontSave;
				goCam.transform.position = base.transform.position;
				goCam.transform.rotation = base.transform.rotation;
				reflectionCamera = goCam.AddComponent<Camera>();
				reflectionCamera.depth = cam.depth - 10f;
				reflectionCamera.renderingPath = cam.renderingPath;
				reflectionCamera.depthTextureMode = DepthTextureMode.None;
				reflectionCamera.cullingMask = CullingMask;
				reflectionCamera.allowHDR = HDR;
				reflectionCamera.useOcclusionCulling = false;
				reflectionCamera.enabled = false;
				reflectionCamera.targetTexture = reflectionTexture;
				Shader.SetGlobalTexture("_ReflectionTex", reflectionTexture);
			}
		}

		private static float Sgn(float a)
		{
			if (a > 0f)
			{
				return 1f;
			}
			if (a < 0f)
			{
				return -1f;
			}
			return 0f;
		}

		private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
		{
			Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
			Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
			projection[2] = vector.x - projection[3];
			projection[6] = vector.y - projection[7];
			projection[10] = vector.z - projection[11];
			projection[14] = vector.w - projection[15];
			return projection;
		}

		private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
		{
			reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
			reflectionMat.m01 = -2f * plane[0] * plane[1];
			reflectionMat.m02 = -2f * plane[0] * plane[2];
			reflectionMat.m03 = -2f * plane[3] * plane[0];
			reflectionMat.m10 = -2f * plane[1] * plane[0];
			reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
			reflectionMat.m12 = -2f * plane[1] * plane[2];
			reflectionMat.m13 = -2f * plane[3] * plane[1];
			reflectionMat.m20 = -2f * plane[2] * plane[0];
			reflectionMat.m21 = -2f * plane[2] * plane[1];
			reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
			reflectionMat.m23 = -2f * plane[3] * plane[2];
			reflectionMat.m30 = 0f;
			reflectionMat.m31 = 0f;
			reflectionMat.m32 = 0f;
			reflectionMat.m33 = 1f;
			return reflectionMat;
		}

		private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
		{
			Vector3 point = pos + normal * ClipPlaneOffset;
			Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
			Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
			Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
			return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
		}

		private void SafeDestroy<T>(T component) where T : UnityEngine.Object
		{
			if (!(component == null))
			{
				if (!Application.isPlaying)
				{
					UnityEngine.Object.DestroyImmediate(component);
				}
				else
				{
					UnityEngine.Object.Destroy(component);
				}
			}
		}

		private void ClearCamera()
		{
			if ((bool)goCam)
			{
				SafeDestroy(goCam);
				goCam = null;
			}
			if ((bool)reflectionTexture)
			{
				SafeDestroy(reflectionTexture);
				reflectionTexture = null;
			}
		}

		public void OnWillRenderObject()
		{
			UpdateCamera(Camera.main);
		}

		private void OnEnable()
		{
			Shader.EnableKeyword("cubeMap_off");
		}

		private void OnDisable()
		{
			ClearCamera();
			Shader.DisableKeyword("cubeMap_off");
		}
	}
	public class RippleCreator : MonoBehaviour
	{
		private class ReversedRipple
		{
			public Vector3 Position;

			public float Velocity;
		}

		public bool IsReversedRipple;

		public float RippleStrenght = 0.1f;

		public float MaxVelocity = 1.5f;

		public float RandomRipplesInterval;

		public float reversedRippleDelay = 0.2f;

		public GameObject SplashEffect;

		public GameObject SplashEffectMoved;

		public AudioSource SplashAudioSource;

		private int fadeInVelocityLimit = 10;

		private int fadeInVelocity = 1;

		private WaterRipples waterRipples;

		private Vector3 oldPos;

		private float currentVelocity;

		private Transform t;

		private Queue<ReversedRipple> reversedVelocityQueue;

		private float triggeredTime;

		private bool canUpdate;

		private float randomRipplesCurrentTime;

		private bool canInstantiateRandomRipple;

		private GameObject splashMovedInstance;

		private ParticleSystem splashParticleSystem;

		public float splashSizeMultiplier = 2f;

		private void Start()
		{
			t = base.transform;
			reversedVelocityQueue = new Queue<ReversedRipple>();
		}

		private void FixedUpdate()
		{
			if (waterRipples == null)
			{
				return;
			}
			if (RandomRipplesInterval > 0.0001f && Time.time - randomRipplesCurrentTime > RandomRipplesInterval)
			{
				randomRipplesCurrentTime = Time.time;
				canInstantiateRandomRipple = true;
			}
			if (canUpdate)
			{
				currentVelocity = (t.position - oldPos).magnitude / Time.fixedDeltaTime * RippleStrenght;
				if (currentVelocity > MaxVelocity)
				{
					currentVelocity = MaxVelocity;
				}
				if (IsReversedRipple)
				{
					currentVelocity = 0f - currentVelocity;
				}
				reversedVelocityQueue.Enqueue(new ReversedRipple
				{
					Position = t.position,
					Velocity = (0f - currentVelocity) / (float)fadeInVelocity
				});
				oldPos = t.position;
				waterRipples.CreateRippleByPosition(t.position, currentVelocity / (float)fadeInVelocity);
				if (canInstantiateRandomRipple)
				{
					waterRipples.CreateRippleByPosition(t.position, UnityEngine.Random.Range(currentVelocity / 5f, currentVelocity));
				}
				UpdateMovedSplash();
			}
			if (Time.time - triggeredTime > reversedRippleDelay)
			{
				ReversedRipple reversedRipple = reversedVelocityQueue.Dequeue();
				if (IsReversedRipple)
				{
					reversedRipple.Velocity = 0f - reversedRipple.Velocity;
				}
				waterRipples.CreateRippleByPosition(reversedRipple.Position, reversedRipple.Velocity);
				if (canInstantiateRandomRipple)
				{
					waterRipples.CreateRippleByPosition(reversedRipple.Position, UnityEngine.Random.Range(reversedRipple.Velocity / 5f, reversedRipple.Velocity));
				}
			}
			fadeInVelocity++;
			if (fadeInVelocity > fadeInVelocityLimit)
			{
				fadeInVelocity = 1;
			}
			if (canInstantiateRandomRipple)
			{
				canInstantiateRandomRipple = false;
			}
		}

		private void OnTriggerEnter(Collider collidedObj)
		{
			WaterRipples component = collidedObj.GetComponent<WaterRipples>();
			if (component != null)
			{
				waterRipples = component;
				canUpdate = true;
				reversedVelocityQueue.Clear();
				triggeredTime = Time.time;
				fadeInVelocity = 1;
				if (SplashAudioSource != null)
				{
					SplashAudioSource.Play();
				}
				if (SplashEffect != null)
				{
					Vector3 offsetByPosition = waterRipples.GetOffsetByPosition(t.position);
					offsetByPosition.x = t.position.x;
					offsetByPosition.z = t.position.z;
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(SplashEffect, offsetByPosition, default(Quaternion)), 2f);
				}
				UpdateMovedSplash();
			}
		}

		private void UpdateMovedSplash()
		{
			if (splashMovedInstance != null)
			{
				Vector3 offsetByPosition = waterRipples.GetOffsetByPosition(t.position);
				offsetByPosition.x = t.position.x;
				offsetByPosition.z = t.position.z;
				splashMovedInstance.transform.position = offsetByPosition;
				splashParticleSystem.startSize = currentVelocity * splashSizeMultiplier;
			}
			else if (SplashEffectMoved != null)
			{
				splashMovedInstance = UnityEngine.Object.Instantiate(SplashEffectMoved, t.position, default(Quaternion));
				splashMovedInstance.transform.parent = waterRipples.transform;
				Vector3 offsetByPosition2 = waterRipples.GetOffsetByPosition(t.position);
				offsetByPosition2.x = t.position.x;
				offsetByPosition2.z = t.position.z;
				splashMovedInstance.transform.position = offsetByPosition2;
				splashParticleSystem = splashMovedInstance.GetComponentInChildren<ParticleSystem>();
				splashParticleSystem.startSize = currentVelocity * splashSizeMultiplier;
			}
		}

		private void OnEnable()
		{
			waterRipples = null;
			canUpdate = false;
			if (splashMovedInstance != null)
			{
				UnityEngine.Object.Destroy(splashMovedInstance);
			}
		}

		private void OnDisable()
		{
			if (splashMovedInstance != null)
			{
				UnityEngine.Object.Destroy(splashMovedInstance);
			}
		}

		private void OnDestroy()
		{
			if (splashMovedInstance != null)
			{
				UnityEngine.Object.Destroy(splashMovedInstance);
			}
		}
	}
	public class TextureScale
	{
		public class ThreadData
		{
			public int start;

			public int end;

			public ThreadData(int s, int e)
			{
				start = s;
				end = e;
			}
		}

		private static Color[] texColors;

		private static Color[] newColors;

		private static int w;

		private static float ratioX;

		private static float ratioY;

		private static int w2;

		private static int finishCount;

		public static void Point(Texture2D tex, int newWidth, int newHeight)
		{
			ThreadedScale(tex, newWidth, newHeight, useBilinear: false);
		}

		public static void Bilinear(Texture2D tex, int newWidth, int newHeight)
		{
			ThreadedScale(tex, newWidth, newHeight, useBilinear: true);
		}

		private static void ThreadedScale(Texture2D tex, int newWidth, int newHeight, bool useBilinear)
		{
			texColors = tex.GetPixels();
			newColors = new Color[newWidth * newHeight];
			if (useBilinear)
			{
				ratioX = 1f / ((float)newWidth / (float)(tex.width - 1));
				ratioY = 1f / ((float)newHeight / (float)(tex.height - 1));
			}
			else
			{
				ratioX = (float)tex.width / (float)newWidth;
				ratioY = (float)tex.height / (float)newHeight;
			}
			w = tex.width;
			w2 = newWidth;
			ThreadData obj = new ThreadData(0, newHeight);
			if (useBilinear)
			{
				BilinearScale(obj);
			}
			else
			{
				PointScale(obj);
			}
			tex.Resize(newWidth, newHeight);
			tex.SetPixels(newColors);
			tex.Apply();
		}

		public static void BilinearScale(object obj)
		{
			ThreadData threadData = (ThreadData)obj;
			for (int i = threadData.start; i < threadData.end; i++)
			{
				int num = (int)Mathf.Floor((float)i * ratioY);
				int num2 = num * w;
				int num3 = (num + 1) * w;
				int num4 = i * w2;
				for (int j = 0; j < w2; j++)
				{
					int num5 = (int)Mathf.Floor((float)j * ratioX);
					float value = (float)j * ratioX - (float)num5;
					newColors[num4 + j] = ColorLerpUnclamped(ColorLerpUnclamped(texColors[num2 + num5], texColors[num2 + num5 + 1], value), ColorLerpUnclamped(texColors[num3 + num5], texColors[num3 + num5 + 1], value), (float)i * ratioY - (float)num);
				}
			}
			finishCount++;
		}

		public static void PointScale(object obj)
		{
			ThreadData threadData = (ThreadData)obj;
			for (int i = threadData.start; i < threadData.end; i++)
			{
				int num = (int)(ratioY * (float)i) * w;
				int num2 = i * w2;
				for (int j = 0; j < w2; j++)
				{
					newColors[num2 + j] = texColors[(int)((float)num + ratioX * (float)j)];
				}
			}
			finishCount++;
		}

		private static Color ColorLerpUnclamped(Color c1, Color c2, float value)
		{
			return new Color(c1.r + (c2.r - c1.r) * value, c1.g + (c2.g - c1.g) * value, c1.b + (c2.b - c1.b) * value, c1.a + (c2.a - c1.a) * value);
		}
	}
	public class Underwater : MonoBehaviour
	{
		public float UnderwaterLevel;

		public Color FogColor = new Color(0f, 0.4f, 0.7f, 1f);

		public float FogDensity = 0.04f;

		public FogMode FogMode = FogMode.Exponential;

		private bool defaultFog;

		private Color defaultFogColor;

		private float defaultFogDensity;

		private FogMode defaultFogMod;

		private Material defaultSkybox;

		private void Start()
		{
			defaultFog = RenderSettings.fog;
			defaultFogColor = RenderSettings.fogColor;
			defaultFogDensity = RenderSettings.fogDensity;
			defaultFogMod = RenderSettings.fogMode;
		}

		private void Update()
		{
			if (base.transform.position.y < UnderwaterLevel)
			{
				RenderSettings.fog = true;
				RenderSettings.fogColor = FogColor;
				RenderSettings.fogDensity = FogDensity;
				RenderSettings.fogMode = FogMode;
			}
			else
			{
				RenderSettings.fog = defaultFog;
				RenderSettings.fogColor = defaultFogColor;
				RenderSettings.fogDensity = defaultFogDensity;
				RenderSettings.fogMode = defaultFogMod;
				RenderSettings.fogStartDistance = -300f;
			}
		}
	}
	public class UnderwaterPostEffects : MonoBehaviour
	{
		public Color FogColor = new Color(29f / 85f, 38f / 51f, 73f / 85f, 1f);

		public float FogDensity = 0.05f;

		public bool UseSunShafts = true;

		public float ShuftsIntensity = 5f;

		public WFX_SunShafts.ShaftsScreenBlendMode SunShuftsScreenBlend;

		private Vector3 SunShaftTargetPosition = new Vector3(0f, 7f, 10f);

		private Camera cam;

		private WFX_SunShafts SunShafts;

		private void OnEnable()
		{
			cam = Camera.main;
			SunShafts = cam.gameObject.AddComponent<WFX_SunShafts>();
			SunShafts.sunShaftIntensity = ShuftsIntensity;
			GameObject gameObject = new GameObject("SunShaftTarget");
			SunShafts.sunTransform = gameObject.transform;
			gameObject.transform.parent = cam.transform;
			gameObject.transform.localPosition = SunShaftTargetPosition;
			SunShafts.screenBlendMode = SunShuftsScreenBlend;
			SunShafts.sunShaftsShader = Shader.Find("Hidden/SunShaftsComposite");
			SunShafts.simpleClearShader = Shader.Find("Hidden/SimpleClear");
			Underwater underwater = cam.gameObject.AddComponent<Underwater>();
			underwater.UnderwaterLevel = base.transform.position.y;
			underwater.FogColor = FogColor;
			underwater.FogDensity = FogDensity;
		}

		private void Update()
		{
			if (cam == null)
			{
				return;
			}
			if (cam.transform.position.y < base.transform.position.y)
			{
				if (!SunShafts.enabled)
				{
					SunShafts.enabled = true;
				}
			}
			else if (SunShafts.enabled)
			{
				SunShafts.enabled = false;
			}
		}
	}
	public class WFX_SunShafts : MonoBehaviour
	{
		public enum SunShaftsResolution
		{
			Low,
			Normal,
			High
		}

		public enum ShaftsScreenBlendMode
		{
			Screen,
			Add
		}

		public SunShaftsResolution resolution = SunShaftsResolution.Normal;

		public ShaftsScreenBlendMode screenBlendMode;

		public Transform sunTransform;

		public int radialBlurIterations = 2;

		public Color sunColor = Color.white;

		public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

		public float sunShaftBlurRadius = 2.5f;

		public float sunShaftIntensity = 1.15f;

		public float maxRadius = 0.75f;

		public bool useDepthTexture = true;

		public Shader sunShaftsShader;

		private Material sunShaftsMaterial;

		public Shader simpleClearShader;

		private Material simpleClearMaterial;

		private bool supportHDRTextures = true;

		private bool supportDX11;

		private bool isSupported = true;

		private List<Material> createdMaterials = new List<Material>();

		protected void NotSupported()
		{
			base.enabled = false;
			isSupported = false;
		}

		private bool CheckSupport(bool needDepth)
		{
			isSupported = true;
			supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
			supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
			if (!SystemInfo.supportsImageEffects)
			{
				NotSupported();
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				NotSupported();
				return false;
			}
			if (needDepth)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			return true;
		}

		protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				base.enabled = false;
				return null;
			}
			if (s.isSupported && (bool)m2Create && m2Create.shader == s)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				NotSupported();
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
				return null;
			}
			m2Create = new Material(s);
			createdMaterials.Add(m2Create);
			m2Create.hideFlags = HideFlags.DontSave;
			return m2Create;
		}

		protected void ReportAutoDisable()
		{
			UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
		}

		public bool CheckResources()
		{
			CheckSupport(useDepthTexture);
			sunShaftsShader = Shader.Find("Hidden/SunShaftsComposite");
			simpleClearShader = Shader.Find("Hidden/SimpleClear");
			sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
			simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (useDepthTexture)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			int num = 4;
			if (resolution == SunShaftsResolution.Normal)
			{
				num = 2;
			}
			else if (resolution == SunShaftsResolution.High)
			{
				num = 1;
			}
			Vector3 vector = Vector3.one * 0.5f;
			vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
			int width = source.width / num;
			int height = source.height / num;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
			if (!useDepthTexture)
			{
				RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
				GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
				sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
				Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
			else
			{
				Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
			}
			radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
			float num2 = sunShaftBlurRadius * 0.0013020834f;
			sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
			for (int i = 0; i < radialBlurIterations; i++)
			{
				RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				temporary = RenderTexture.GetTemporary(width, height, 0);
				Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
				RenderTexture.ReleaseTemporary(temporary3);
				num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
			}
			if (vector.z >= 0f)
			{
				sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
			}
			else
			{
				sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
			}
			sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
			Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	public class WaterRipples : MonoBehaviour
	{
		[Range(20f, 200f)]
		public int UpdateFPS = 30;

		public bool Multithreading = true;

		public int DisplacementResolution = 128;

		public float Damping = 0.005f;

		[Range(0.0001f, 2f)]
		public float Speed = 1.5f;

		public bool UseSmoothWaves;

		public bool UseProjectedWaves;

		public Texture2D CutOutTexture;

		private Transform t;

		private float textureColorMultiplier = 10f;

		private Texture2D displacementTexture;

		private Vector2[,] waveAcceleration;

		private Color[] col;

		private Vector3[] wavePoints;

		private Vector3 scaleBounds;

		private float inversedDamping;

		private float[] cutOutTextureGray;

		private bool cutOutTextureInitialized;

		private Thread thread;

		private bool canUpdate = true;

		private double threadDeltaTime;

		private DateTime oldDateTime;

		private Vector2 movedObjPos;

		private Vector2 projectorPosition;

		private Vector4 _GAmplitude;

		private Vector4 _GFrequency;

		private Vector4 _GSteepness;

		private Vector4 _GSpeed;

		private Vector4 _GDirectionAB;

		private Vector4 _GDirectionCD;

		private void OnEnable()
		{
			canUpdate = true;
			Shader.EnableKeyword("ripples_on");
			Renderer component = GetComponent<Renderer>();
			_GAmplitude = component.sharedMaterial.GetVector("_GAmplitude");
			_GFrequency = component.sharedMaterial.GetVector("_GFrequency");
			_GSteepness = component.sharedMaterial.GetVector("_GSteepness");
			_GSpeed = component.sharedMaterial.GetVector("_GSpeed");
			_GDirectionAB = component.sharedMaterial.GetVector("_GDirectionAB");
			_GDirectionCD = component.sharedMaterial.GetVector("_GDirectionCD");
			t = base.transform;
			scaleBounds = GetComponent<MeshRenderer>().bounds.size;
			InitializeRipple();
			if (Multithreading)
			{
				thread = new Thread(UpdateRipples);
				thread.Start();
			}
		}

		public Vector3 GetOffsetByPosition(Vector3 position)
		{
			Vector3 result = GerstnerOffset4(new Vector2(position.x, position.z), _GSteepness, _GAmplitude, _GFrequency, _GSpeed, _GDirectionAB, _GDirectionCD);
			result.y += GetTextureHeightByPosition(position.x, position.z);
			result.y += t.position.y;
			return result;
		}

		public void CreateRippleByPosition(Vector3 position, float velocity)
		{
			position.x += scaleBounds.x / 2f - t.position.x;
			position.z += scaleBounds.z / 2f - t.position.z;
			position.x /= scaleBounds.x;
			position.z /= scaleBounds.z;
			position.x *= DisplacementResolution;
			position.z *= DisplacementResolution;
			SetRippleTexture((int)position.x, (int)position.z, velocity);
		}

		private void InitializeRipple()
		{
			inversedDamping = 1f - Damping;
			displacementTexture = new Texture2D(DisplacementResolution, DisplacementResolution, TextureFormat.RGBA32, mipChain: false);
			displacementTexture.wrapMode = TextureWrapMode.Clamp;
			displacementTexture.filterMode = FilterMode.Bilinear;
			Shader.SetGlobalTexture("_WaterDisplacementTexture", displacementTexture);
			wavePoints = new Vector3[DisplacementResolution * DisplacementResolution];
			col = new Color[DisplacementResolution * DisplacementResolution];
			waveAcceleration = new Vector2[DisplacementResolution, DisplacementResolution];
			for (int i = 0; i < DisplacementResolution * DisplacementResolution; i++)
			{
				col[i] = new Color(0f, 0f, 0f);
				wavePoints[i] = new Vector3(0f, 0f);
			}
			for (int j = 0; j < DisplacementResolution; j++)
			{
				for (int k = 0; k < DisplacementResolution; k++)
				{
					waveAcceleration[j, k] = new Vector2(0f, 0f);
				}
			}
			if (CutOutTexture != null)
			{
				Color[] pixels = ScaleTexture(CutOutTexture, DisplacementResolution, DisplacementResolution).GetPixels();
				cutOutTextureGray = new float[DisplacementResolution * DisplacementResolution];
				for (int l = 0; l < pixels.Length; l++)
				{
					cutOutTextureGray[l] = pixels[l].r * 0.299f + pixels[l].g * 0.587f + pixels[l].b * 0.114f;
				}
				cutOutTextureInitialized = true;
			}
		}

		private Texture2D ScaleTexture(Texture2D source, int targetWidth, int targetHeight)
		{
			Texture2D texture2D = new Texture2D(source.width, source.height, TextureFormat.ARGB32, mipChain: false);
			Color[] pixels = source.GetPixels();
			texture2D.SetPixels(pixels);
			TextureScale.Bilinear(texture2D, targetWidth, targetHeight);
			texture2D.Apply();
			return texture2D;
		}

		private void UpdateRipples()
		{
			oldDateTime = DateTime.UtcNow;
			while (canUpdate)
			{
				threadDeltaTime = (DateTime.UtcNow - oldDateTime).TotalMilliseconds / 1000.0;
				oldDateTime = DateTime.UtcNow;
				int num = (int)((double)(1000f / (float)UpdateFPS) - threadDeltaTime);
				if (num > 0)
				{
					Thread.Sleep(num);
				}
				RippleTextureRecalculate();
			}
		}

		private void FixedUpdate()
		{
			if (!Multithreading)
			{
				RippleTextureRecalculate();
			}
			displacementTexture.SetPixels(col);
			displacementTexture.Apply(updateMipmaps: false);
		}

		private void Update()
		{
			movedObjPos = new Vector2(t.position.x, t.position.z);
		}

		private void UpdateProjector()
		{
			int num = (int)((float)DisplacementResolution * movedObjPos.x / scaleBounds.x - projectorPosition.x);
			int num2 = (int)((float)DisplacementResolution * movedObjPos.y / scaleBounds.z - projectorPosition.y);
			projectorPosition.x += num;
			projectorPosition.y += num2;
			if (num == 0 && num2 == 0)
			{
				return;
			}
			if (num >= 0 && num2 >= 0)
			{
				for (int i = 1; i < DisplacementResolution; i++)
				{
					for (int j = 0; j < DisplacementResolution; j++)
					{
						if (i + num2 > 0 && i + num2 < DisplacementResolution && j + num > 0 && j + num < DisplacementResolution)
						{
							waveAcceleration[j, i] = waveAcceleration[j + num, i + num2];
							wavePoints[j + i * DisplacementResolution] = wavePoints[j + num + (i + num2) * DisplacementResolution];
						}
					}
				}
			}
			if (num >= 0 && num2 < 0)
			{
				for (int num3 = DisplacementResolution - 1; num3 >= 0; num3--)
				{
					for (int k = 0; k < DisplacementResolution; k++)
					{
						if (num3 + num2 > 0 && num3 + num2 < DisplacementResolution && k + num > 0 && k + num < DisplacementResolution)
						{
							waveAcceleration[k, num3] = waveAcceleration[k + num, num3 + num2];
							wavePoints[k + num3 * DisplacementResolution] = wavePoints[k + num + (num3 + num2) * DisplacementResolution];
						}
					}
				}
			}
			if (num < 0 && num2 >= 0)
			{
				for (int l = 0; l < DisplacementResolution; l++)
				{
					for (int num4 = DisplacementResolution - 1; num4 >= 0; num4--)
					{
						if (l + num2 > 0 && l + num2 < DisplacementResolution && num4 + num > 0 && num4 + num < DisplacementResolution)
						{
							waveAcceleration[num4, l] = waveAcceleration[num4 + num, l + num2];
							wavePoints[num4 + l * DisplacementResolution] = wavePoints[num4 + num + (l + num2) * DisplacementResolution];
						}
					}
				}
			}
			if (num < 0 && num2 < 0)
			{
				for (int num5 = DisplacementResolution - 1; num5 >= 0; num5--)
				{
					for (int num6 = DisplacementResolution - 1; num6 >= 0; num6--)
					{
						if (num5 + num2 > 0 && num5 + num2 < DisplacementResolution && num6 + num > 0 && num6 + num < DisplacementResolution)
						{
							waveAcceleration[num6, num5] = waveAcceleration[num6 + num, num5 + num2];
							wavePoints[num6 + num5 * DisplacementResolution] = wavePoints[num6 + num + (num5 + num2) * DisplacementResolution];
						}
					}
				}
			}
			Vector2 zero = Vector2.zero;
			for (int m = 0; m < DisplacementResolution; m++)
			{
				waveAcceleration[0, m] = zero;
				wavePoints[m * DisplacementResolution] = zero;
				waveAcceleration[DisplacementResolution - 1, m] = zero;
				wavePoints[DisplacementResolution - 1 + m * DisplacementResolution] = zero;
				waveAcceleration[m, 0] = zero;
				wavePoints[m] = zero;
				waveAcceleration[m, DisplacementResolution - 1] = zero;
				wavePoints[DisplacementResolution - 1 + m] = zero;
			}
		}

		private void OnDestroy()
		{
			canUpdate = false;
		}

		private void OnDisable()
		{
			Shader.DisableKeyword("ripples_on");
			canUpdate = false;
		}

		private void RippleTextureRecalculate()
		{
			if (UseProjectedWaves)
			{
				UpdateProjector();
			}
			int num = wavePoints.Length;
			int num2 = DisplacementResolution + 1;
			int num3 = DisplacementResolution - 2;
			int num4 = num - (DisplacementResolution + 1);
			for (int i = 0; i < num; i++)
			{
				if (i >= num2 && i < num4 && i % DisplacementResolution > 0)
				{
					int num5 = i % DisplacementResolution;
					int num6 = i / DisplacementResolution;
					float num7 = (wavePoints[i - 1].y + wavePoints[i + 1].y + wavePoints[i - DisplacementResolution].y + wavePoints[i + DisplacementResolution].y) / 4f;
					waveAcceleration[num5, num6].y += num7 - waveAcceleration[num5, num6].x;
				}
			}
			float num8 = Speed;
			if (!Multithreading)
			{
				num8 *= Time.fixedDeltaTime * (float)UpdateFPS;
			}
			for (int j = 0; j < DisplacementResolution; j++)
			{
				for (int k = 0; k < DisplacementResolution; k++)
				{
					waveAcceleration[k, j].x += waveAcceleration[k, j].y * num8;
					if (cutOutTextureInitialized)
					{
						waveAcceleration[k, j].x *= cutOutTextureGray[k + j * DisplacementResolution];
					}
					waveAcceleration[k, j].y *= inversedDamping;
					waveAcceleration[k, j].x *= inversedDamping;
					wavePoints[k + j * DisplacementResolution].y = waveAcceleration[k, j].x;
					if (!UseSmoothWaves)
					{
						float num9 = waveAcceleration[k, j].x * textureColorMultiplier;
						if (num9 >= 0f)
						{
							col[k + j * DisplacementResolution].r = num9;
						}
						else
						{
							col[k + j * DisplacementResolution].g = 0f - num9;
						}
					}
				}
			}
			if (!UseSmoothWaves)
			{
				return;
			}
			for (int l = 2; l < num3; l++)
			{
				for (int m = 2; m < num3; m++)
				{
					float num9 = (wavePoints[m + l * DisplacementResolution - 2].y * 0.2f + wavePoints[m + l * DisplacementResolution - 1].y * 0.4f + wavePoints[m + l * DisplacementResolution].y * 0.6f + wavePoints[m + l * DisplacementResolution + 1].y * 0.4f + wavePoints[m + l * DisplacementResolution + 2].y * 0.2f) / 1.6f * textureColorMultiplier;
					if (num9 >= 0f)
					{
						col[m + l * DisplacementResolution].r = num9;
					}
					else
					{
						col[m + l * DisplacementResolution].g = 0f - num9;
					}
				}
			}
			for (int n = 2; n < num3; n++)
			{
				for (int num10 = 2; num10 < num3; num10++)
				{
					float num9 = (wavePoints[num10 + n * DisplacementResolution - 2].y * 0.2f + wavePoints[num10 + n * DisplacementResolution - 1].y * 0.4f + wavePoints[num10 + n * DisplacementResolution].y * 0.6f + wavePoints[num10 + n * DisplacementResolution + 1].y * 0.4f + wavePoints[num10 + n * DisplacementResolution + 2].y * 0.2f) / 1.6f * textureColorMultiplier;
					if (num9 >= 0f)
					{
						col[num10 + n * DisplacementResolution].r = num9;
					}
					else
					{
						col[num10 + n * DisplacementResolution].g = 0f - num9;
					}
				}
			}
		}

		private void SetRippleTexture(int x, int y, float strength)
		{
			strength /= 100f;
			if (x >= 2 && x < DisplacementResolution - 2 && y >= 2 && y < DisplacementResolution - 2)
			{
				waveAcceleration[x, y].y -= strength;
				waveAcceleration[x + 1, y].y -= strength * 0.8f;
				waveAcceleration[x - 1, y].y -= strength * 0.8f;
				waveAcceleration[x, y + 1].y -= strength * 0.8f;
				waveAcceleration[x, y - 1].y -= strength * 0.8f;
				waveAcceleration[x + 1, y + 1].y -= strength * 0.7f;
				waveAcceleration[x + 1, y - 1].y -= strength * 0.7f;
				waveAcceleration[x - 1, y + 1].y -= strength * 0.7f;
				waveAcceleration[x - 1, y - 1].y -= strength * 0.7f;
				if (x >= 3 && x < DisplacementResolution - 3 && y >= 3 && y < DisplacementResolution - 3)
				{
					waveAcceleration[x + 2, y].y -= strength * 0.5f;
					waveAcceleration[x - 2, y].y -= strength * 0.5f;
					waveAcceleration[x, y + 2].y -= strength * 0.5f;
					waveAcceleration[x, y - 2].y -= strength * 0.5f;
				}
			}
		}

		private float GetTextureHeightByPosition(float x, float y)
		{
			x /= scaleBounds.x;
			y /= scaleBounds.y;
			x *= (float)DisplacementResolution;
			y *= (float)DisplacementResolution;
			if (x >= (float)DisplacementResolution || y >= (float)DisplacementResolution || x < 0f || y < 0f)
			{
				return 0f;
			}
			return waveAcceleration[(int)x, (int)y].x * textureColorMultiplier;
		}

		private Vector3 GerstnerOffset4(Vector2 xzVtx, Vector4 _GSteepness, Vector4 _GAmplitude, Vector4 _GFrequency, Vector4 _GSpeed, Vector4 _GDirectionAB, Vector4 _GDirectionCD)
		{
			Vector3 result = default(Vector3);
			float num = _GSteepness.x * _GAmplitude.x;
			float num2 = _GSteepness.y * _GAmplitude.y;
			Vector4 vector = new Vector4(num * _GDirectionAB.x, num * _GDirectionAB.y, num2 * _GDirectionAB.z, num2 * _GDirectionAB.w);
			Vector4 vector2 = new Vector4(_GSteepness.z * _GAmplitude.z * _GDirectionCD.x, _GSteepness.z * _GAmplitude.z * _GDirectionCD.y, _GSteepness.w * _GAmplitude.w * _GDirectionCD.z, _GSteepness.w * _GAmplitude.w * _GDirectionCD.w);
			float num3 = Vector2.Dot(new Vector2(_GDirectionAB.x, _GDirectionAB.y), xzVtx);
			float num4 = Vector2.Dot(new Vector2(_GDirectionAB.z, _GDirectionAB.w), xzVtx);
			float num5 = Vector2.Dot(new Vector2(_GDirectionCD.x, _GDirectionCD.y), xzVtx);
			float num6 = Vector2.Dot(new Vector2(_GDirectionCD.z, _GDirectionCD.w), xzVtx);
			Vector4 vector3 = new Vector4(num3 * _GFrequency.x, num4 * _GFrequency.y, num5 * _GFrequency.z, num6 * _GFrequency.w);
			Vector4 vector4 = new Vector4(Time.time * _GSpeed.x % 6.2831f, Time.time * _GSpeed.y % 6.2831f, Time.time * _GSpeed.z % 6.2831f, Time.time * _GSpeed.w % 6.2831f);
			Vector4 a = new Vector4(Mathf.Cos(vector3.x + vector4.x), Mathf.Cos(vector3.y + vector4.y), Mathf.Cos(vector3.z + vector4.z), Mathf.Cos(vector3.w + vector4.w));
			Vector4 a2 = new Vector4(Mathf.Sin(vector3.x + vector4.x), Mathf.Sin(vector3.y + vector4.y), Mathf.Sin(vector3.z + vector4.z), Mathf.Sin(vector3.w + vector4.w));
			result.x = Vector4.Dot(a, new Vector4(vector.x, vector.z, vector2.x, vector2.z));
			result.z = Vector4.Dot(a, new Vector4(vector.y, vector.w, vector2.y, vector2.w));
			result.y = Vector4.Dot(a2, _GAmplitude);
			return result;
		}
	}
	[ExecuteInEditMode]
	public class Water_DistortionAndBloom : MonoBehaviour
	{
		[Range(0.05f, 1f)]
		[Tooltip("Camera render texture resolution")]
		public float RenderTextureResolutoinFactor = 0.5f;

		public LayerMask CullingMask = -17;

		private RenderTexture source;

		private RenderTexture depth;

		private RenderTexture destination;

		private int previuosFrameWidth;

		private int previuosFrameHeight;

		private float previousScale;

		private Camera addCamera;

		private GameObject tempGO;

		private bool HDRSupported;

		private const int kMaxIterations = 16;

		private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

		private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

		private GUIStyle guiStyleHeader = new GUIStyle();

		public static Material CheckShaderAndCreateMaterial(Shader s)
		{
			if (s == null || !s.isSupported)
			{
				return null;
			}
			return new Material(s)
			{
				hideFlags = HideFlags.DontSave
			};
		}

		private void OnDisable()
		{
			if (tempGO != null)
			{
				UnityEngine.Object.DestroyImmediate(tempGO);
			}
			Shader.DisableKeyword("DISTORT_OFF");
			Shader.DisableKeyword("_MOBILEDEPTH_ON");
		}

		private void Start()
		{
			InitializeRenderTarget();
		}

		private void LateUpdate()
		{
			if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
			{
				InitializeRenderTarget();
				previuosFrameWidth = Screen.width;
				previuosFrameHeight = Screen.height;
				previousScale = RenderTextureResolutoinFactor;
			}
			Shader.EnableKeyword("DISTORT_OFF");
			Shader.EnableKeyword("_MOBILEDEPTH_ON");
			GrabImage();
			Shader.SetGlobalTexture("_GrabTexture", source);
			Shader.SetGlobalTexture("_CameraDepthTexture", depth);
			Shader.SetGlobalFloat("_GrabTextureScale", RenderTextureResolutoinFactor);
			Shader.DisableKeyword("DISTORT_OFF");
		}

		private void InitializeRenderTarget()
		{
			int width = (int)((float)Screen.width * RenderTextureResolutoinFactor);
			int height = (int)((float)Screen.height * RenderTextureResolutoinFactor);
			HDRSupported = false;
			source = new RenderTexture(width, height, 0, RenderTextureFormat.RGB565);
			depth = new RenderTexture(width, height, 8, RenderTextureFormat.Depth);
		}

		private void GrabImage()
		{
			Camera camera = Camera.current;
			if (camera == null)
			{
				camera = Camera.main;
			}
			if (tempGO == null)
			{
				tempGO = new GameObject();
				tempGO.hideFlags = HideFlags.HideAndDontSave;
				addCamera = tempGO.AddComponent<Camera>();
				addCamera.enabled = false;
			}
			else
			{
				addCamera = tempGO.GetComponent<Camera>();
			}
			addCamera.CopyFrom(camera);
			addCamera.SetTargetBuffers(source.colorBuffer, depth.depthBuffer);
			addCamera.depth--;
			addCamera.cullingMask = CullingMask;
			addCamera.Render();
		}
	}
	public class Nl_DragObject : MonoBehaviour
	{
		public static Camera Cam;

		private Rigidbody rigidboy;

		private float distanceZ;

		private bool isTaken;

		private Vector3 offset;

		private Vector3 dir;

		private void Start()
		{
			rigidboy = base.gameObject.GetComponent<Rigidbody>();
		}

		private void Update()
		{
			if (isTaken)
			{
				if (Input.GetMouseButton(1))
				{
					Vector3 position = new Vector3(Input.mousePosition.x, Input.mousePosition.y, distanceZ);
					Vector3 vector = Cam.ScreenToWorldPoint(position);
					rigidboy.MovePosition(vector + offset);
				}
				else
				{
					rigidboy.useGravity = true;
					rigidboy.constraints = RigidbodyConstraints.None;
					isTaken = false;
				}
				if (Input.GetAxis("Horizontal") != 0f && Input.GetKey(KeyCode.LeftAlt))
				{
					base.transform.Rotate(Vector3.up * 100f * Time.deltaTime * Input.GetAxis("Horizontal"));
				}
				if (Input.GetAxis("Vertical") != 0f && Input.GetKey(KeyCode.LeftAlt))
				{
					base.transform.Rotate(Vector3.right * 100f * Time.deltaTime * Input.GetAxis("Vertical"));
				}
			}
		}

		private void OnMouseOver()
		{
			if (Input.GetKey(KeyCode.LeftAlt) && Input.GetMouseButtonDown(1))
			{
				isTaken = true;
				distanceZ = Vector3.Distance(Cam.transform.position, base.gameObject.transform.position);
				Vector3 position = new Vector3(Input.mousePosition.x, Input.mousePosition.y, distanceZ);
				Vector3 vector = Cam.ScreenToWorldPoint(position);
				offset = rigidboy.position - vector;
				rigidboy.velocity = Vector3.zero;
				rigidboy.useGravity = false;
				rigidboy.constraints = RigidbodyConstraints.FreezeRotation;
			}
		}
	}
	public sealed class SketchDemo : MonoBehaviour
	{
		[SerializeField]
		private bool guiShow = true;

		[SerializeField]
		private AudioClip musicClip;

		private Sketch sketch;

		private bool menuOpen;

		private const float guiMargen = 10f;

		private const float guiWidth = 200f;

		private float updateInterval = 0.5f;

		private float accum;

		private int frames;

		private float timeleft;

		private float fps;

		private GUIStyle menuStyle;

		private GUIStyle boxStyle;

		private AudioSource audioSource;

		private const float audioVolume = 0.25f;

		private readonly string[] modeStrings = new string[2] { "Screen", "Object" };

		private void OnEnable()
		{
			Camera[] array = UnityEngine.Object.FindObjectsOfType<Camera>();
			Camera camera = null;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].enabled)
				{
					camera = array[i];
					break;
				}
			}
			if (camera != null)
			{
				sketch = camera.gameObject.GetComponent<Sketch>();
				if (sketch == null)
				{
					sketch = camera.gameObject.AddComponent<Sketch>();
				}
				GameObject[] array2 = GameObject.FindGameObjectsWithTag("Movable");
				for (int j = 0; j < array2.Length; j++)
				{
					if (!array2[j].GetComponent<SketchObject>())
					{
						array2[j].AddComponent<SketchObject>();
					}
				}
				if (musicClip != null)
				{
					audioSource = base.gameObject.GetComponent<AudioSource>();
					if (audioSource == null)
					{
						audioSource = base.gameObject.AddComponent<AudioSource>();
					}
					audioSource.clip = musicClip;
					audioSource.loop = true;
					audioSource.volume = 0.25f;
					audioSource.Play();
				}
			}
			else
			{
				UnityEngine.Debug.LogWarning("No camera found.");
			}
			base.enabled = sketch != null;
		}

		private void Update()
		{
			timeleft -= Time.deltaTime;
			accum += Time.timeScale / Time.deltaTime;
			frames++;
			if (timeleft <= 0f)
			{
				fps = accum / (float)frames;
				timeleft = updateInterval;
				accum = 0f;
				frames = 0;
			}
			if (Input.GetKeyUp(KeyCode.F1))
			{
				guiShow = !guiShow;
			}
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				Application.Quit();
			}
		}

		private void OnGUI()
		{
			if (sketch == null)
			{
				return;
			}
			if (menuStyle == null)
			{
				menuStyle = new GUIStyle(GUI.skin.textArea);
				menuStyle.alignment = TextAnchor.MiddleCenter;
				menuStyle.fontSize = 14;
			}
			if (boxStyle == null)
			{
				boxStyle = new GUIStyle(GUI.skin.box);
				boxStyle.normal.background = MakeTex(2, 2, new Color(0.25f, 0.25f, 0.25f, 0.8f));
				boxStyle.focused.textColor = Color.red;
			}
			if (guiShow)
			{
				GUILayout.BeginHorizontal(boxStyle, GUILayout.Width(Screen.width));
				GUILayout.Space(10f);
				if (GUILayout.Button("MENU", menuStyle, GUILayout.Width(80f)))
				{
					menuOpen = !menuOpen;
				}
				GUILayout.FlexibleSpace();
				GUILayout.Label("SKETCH", menuStyle, GUILayout.Width(200f));
				GUILayout.FlexibleSpace();
				if (musicClip != null && GUILayout.Button("MUTE", menuStyle, GUILayout.Width(80f)))
				{
					audioSource.volume = ((audioSource.volume > 0f) ? 0f : 0.25f);
				}
				GUILayout.Space(10f);
				if (fps < 24f)
				{
					GUI.contentColor = Color.yellow;
				}
				else if (fps < 15f)
				{
					GUI.contentColor = Color.red;
				}
				else
				{
					GUI.contentColor = Color.green;
				}
				GUILayout.Label(fps.ToString("000"), menuStyle, GUILayout.Width(40f));
				GUI.contentColor = Color.white;
				GUILayout.Space(10f);
				GUILayout.EndHorizontal();
				if (menuOpen)
				{
					MenuGUI();
				}
			}
		}

		private void MenuGUI()
		{
			GUILayout.BeginVertical(boxStyle, GUILayout.Width(200f), GUILayout.ExpandHeight(expand: true));
			GUILayout.Space(10f);
			GUILayout.BeginVertical(boxStyle);
			sketch.Mode = (SketchModes)GUILayout.Toolbar((int)sketch.Mode, modeStrings);
			GUILayout.BeginHorizontal();
			GUILayout.Label(" Strength", GUILayout.Width(70f));
			sketch.Strength = GUILayout.HorizontalSlider(sketch.Strength, 0f, 1f);
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label(" Definition", GUILayout.Width(70f));
			sketch.Definition = GUILayout.HorizontalSlider(sketch.Definition, 0f, 1f);
			GUILayout.EndHorizontal();
			GUILayout.EndVertical();
			GUILayout.Space(10f);
			if (sketch.Mode == SketchModes.Screen)
			{
				GUILayout.BeginVertical(boxStyle);
				sketch.EnablePaper = GUILayout.Toggle(sketch.EnablePaper, " Paper");
				if (sketch.EnablePaper)
				{
					if (Application.isMobilePlatform || Application.platform == RuntimePlatform.WebGLPlayer)
					{
						GUILayout.BeginHorizontal();
						GUILayout.Label("  Count", GUILayout.Width(70f));
						sketch.CellCount = (int)GUILayout.HorizontalSlider(sketch.CellCount, 0f, 10f);
						GUILayout.EndHorizontal();
					}
					GUILayout.BeginHorizontal();
					GUILayout.Label("  Size", GUILayout.Width(70f));
					sketch.CellSize = GUILayout.HorizontalSlider(sketch.CellSize, 0f, 5f);
					GUILayout.EndHorizontal();
					GUILayout.BeginHorizontal();
					GUILayout.Label("  Intensity", GUILayout.Width(70f));
					sketch.CellIntensity = GUILayout.HorizontalSlider(sketch.CellIntensity, 0f, 10f);
					GUILayout.EndHorizontal();
				}
				GUILayout.EndVertical();
				GUILayout.Space(10f);
			}
			GUILayout.BeginVertical(boxStyle);
			GUILayout.BeginHorizontal();
			GUILayout.Label(" Saturation", GUILayout.Width(70f));
			sketch.Saturation = GUILayout.HorizontalSlider(sketch.Saturation, 0f, 1f);
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label(" Invert", GUILayout.Width(70f));
			sketch.InvertColor = GUILayout.Toggle(sketch.InvertColor, string.Empty);
			GUILayout.EndHorizontal();
			GUILayout.EndVertical();
			GUILayout.FlexibleSpace();
			GUILayout.BeginVertical(boxStyle);
			GUILayout.Label("TAB - Hide/Show gui.");
			GUILayout.BeginHorizontal(boxStyle);
			if (GUILayout.Button("Open Web"))
			{
				Application.OpenURL("http://www.ibuprogames.com/2019/11/10/sketch/");
			}
			if (GUILayout.Button("Reset all values"))
			{
				sketch.ResetDefaultValues();
				sketch.Intensity = 4;
				sketch.Definition = 1f;
				sketch.Saturation = 0f;
			}
			if (GUILayout.Button("Quit"))
			{
				Application.Quit();
			}
			GUILayout.EndHorizontal();
			GUILayout.Space(10f);
			GUILayout.Label("Music: bensound.com");
			GUILayout.EndVertical();
			GUILayout.EndVertical();
		}

		private Texture2D MakeTex(int width, int height, Color col)
		{
			Color[] array = new Color[width * height];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = col;
			}
			Texture2D texture2D = new Texture2D(width, height);
			texture2D.SetPixels(array);
			texture2D.Apply();
			return texture2D;
		}
	}
	public class PencilSketchPainterly : MonoBehaviour
	{
		[Range(0f, 1f)]
		public float blend = 1f;

		[Range(0.1f, 2f)]
		public float intensity = 1f;

		public bool grayScale;

		public bool noisePoint = true;

		[Range(0f, 1f)]
		public float magicColor = 0.2f;

		[Range(1f, 10f)]
		public float magicSensitivity = 5f;

		[Range(0.001f, 0.03f)]
		public float magicGradThresh = 0.01f;

		[Range(0f, 2f)]
		public float vignetting = 1f;

		private Shader shader;

		private Material mtrl;

		private Texture2D noise;

		private void Awake()
		{
			shader = Shader.Find("Hidden/PencilSketchPainterly");
			if (!shader.isSupported)
			{
				base.enabled = false;
				return;
			}
			mtrl = new Material(shader);
			noise = Resources.Load<Texture2D>("psp_noise");
		}

		private void OnRenderImage(RenderTexture src, RenderTexture dest)
		{
			if (mtrl == null || mtrl.shader == null || !mtrl.shader.isSupported)
			{
				base.enabled = false;
				return;
			}
			mtrl.SetFloat("_Blend", blend);
			mtrl.SetTexture("_SrcTex", src);
			mtrl.SetTexture("_NoiseTex", noise);
			mtrl.SetVector("_NoiseTexSize", new Vector4(1f / (float)noise.width, 1f / (float)noise.height, noise.width, noise.height));
			mtrl.SetFloat("_Intensity", intensity);
			mtrl.SetFloat("_Grayscale", grayScale ? 1 : 0);
			mtrl.SetFloat("_MagicColor", magicColor);
			mtrl.SetFloat("_MagicSensitivity", magicSensitivity);
			mtrl.SetFloat("_MagicGradThresh", magicGradThresh);
			mtrl.SetFloat("_Vignetting", vignetting);
			if (grayScale)
			{
				mtrl.EnableKeyword("GRAYSCALE");
			}
			else
			{
				mtrl.DisableKeyword("GRAYSCALE");
			}
			if (noisePoint)
			{
				mtrl.EnableKeyword("NOISE_POINT");
			}
			else
			{
				mtrl.DisableKeyword("NOISE_POINT");
			}
			Graphics.Blit(src, dest, mtrl, 0);
		}

		private void OnDestroy()
		{
			shader = null;
			if (mtrl != null)
			{
				UnityEngine.Object.DestroyImmediate(mtrl);
				mtrl = null;
			}
			if (noise != null)
			{
				Resources.UnloadAsset(noise);
				noise = null;
			}
		}
	}
	public class ExampleWheelController : MonoBehaviour
	{
		private static class Uniforms
		{
			internal static readonly int _MotionAmount = Shader.PropertyToID("_MotionAmount");
		}

		public float acceleration;

		public Renderer motionVectorRenderer;

		private Rigidbody m_Rigidbody;

		private void Start()
		{
			m_Rigidbody = GetComponent<Rigidbody>();
			m_Rigidbody.maxAngularVelocity = 100f;
		}

		private void Update()
		{
			if (Input.GetKey(KeyCode.UpArrow))
			{
				m_Rigidbody.AddRelativeTorque(new Vector3(-1f * acceleration, 0f, 0f), ForceMode.Acceleration);
			}
			else if (Input.GetKey(KeyCode.DownArrow))
			{
				m_Rigidbody.AddRelativeTorque(new Vector3(1f * acceleration, 0f, 0f), ForceMode.Acceleration);
			}
			float value = (0f - m_Rigidbody.angularVelocity.x) / 100f;
			if ((bool)motionVectorRenderer)
			{
				motionVectorRenderer.material.SetFloat(Uniforms._MotionAmount, Mathf.Clamp(value, -0.25f, 0.25f));
			}
		}
	}
	public class RunTimeCombineAndRelease : MonoBehaviour
	{
		public SimpleMeshCombine simpleMeshCombine;

		public float combineTime = 0.5f;

		public float releaseTime = 2f;

		public void Awake()
		{
			simpleMeshCombine = GetComponent<SimpleMeshCombine>();
		}

		public void Start()
		{
			if (simpleMeshCombine == null)
			{
				UnityEngine.Debug.Log("Couldn't find SMC, aborting");
				return;
			}
			Invoke("Combine", combineTime);
			Invoke("Release", releaseTime);
		}

		public void Combine()
		{
			simpleMeshCombine.CombineMeshes();
			UnityEngine.Debug.Log("Combined");
		}

		public void Release()
		{
			simpleMeshCombine.EnableRenderers(e: true);
			if (!(simpleMeshCombine.combined == null))
			{
				UnityEngine.Object.Destroy(simpleMeshCombine.combined);
				simpleMeshCombine.combinedGameOjects = null;
				UnityEngine.Debug.Log("Released");
			}
		}
	}
	[AddComponentMenu("Simple Mesh Combine")]
	public class SimpleMeshCombine : MonoBehaviour
	{
		public GameObject[] combinedGameOjects;

		public GameObject combined;

		public string meshName = "Combined_Meshes";

		public bool _canGenerateLightmapUV;

		public int vCount;

		public bool generateLightmapUV;

		public float lightmapScale = 1f;

		public GameObject copyTarget;

		public bool destroyOldColliders;

		public bool keepStructure = true;

		public Mesh autoOverwrite;

		public bool setStatic = true;

		public bool increaseVertexCount;

		public bool setMeshPivottoParentPivot;

		public void EnableRenderers(bool e)
		{
			for (int i = 0; i < combinedGameOjects.Length && !(combinedGameOjects[i] == null); i++)
			{
				Renderer component = combinedGameOjects[i].GetComponent<Renderer>();
				if (component != null)
				{
					component.enabled = e;
				}
			}
		}

		public MeshFilter[] FindEnabledMeshes()
		{
			MeshFilter[] array = null;
			int num = 0;
			array = base.transform.GetComponentsInChildren<MeshFilter>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].GetComponent<MeshRenderer>() != null && array[i].GetComponent<MeshRenderer>().enabled)
				{
					num++;
				}
			}
			MeshFilter[] array2 = new MeshFilter[num];
			num = 0;
			for (int j = 0; j < array.Length; j++)
			{
				if (array[j].GetComponent<MeshRenderer>() != null && array[j].GetComponent<MeshRenderer>().enabled)
				{
					array2[num] = array[j];
					num++;
				}
			}
			return array2;
		}

		public void ReleaseMeshes()
		{
			EnableRenderers(e: true);
			if (combined != null)
			{
				UnityEngine.Object.Destroy(combined);
			}
			combinedGameOjects = null;
			vCount = 0;
		}

		public void CombineMeshes()
		{
			Vector3 position = base.transform.position;
			if (setMeshPivottoParentPivot)
			{
				base.transform.position = Vector3.zero;
			}
			GameObject gameObject = new GameObject();
			gameObject.name = "_Combined Mesh [" + base.name + "]";
			gameObject.gameObject.AddComponent<MeshFilter>();
			gameObject.gameObject.AddComponent<MeshRenderer>();
			MeshFilter[] array = null;
			array = FindEnabledMeshes();
			ArrayList arrayList = new ArrayList();
			ArrayList arrayList2 = new ArrayList();
			combinedGameOjects = new GameObject[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				combinedGameOjects[i] = array[i].gameObject;
				MeshRenderer component = array[i].GetComponent<MeshRenderer>();
				array[i].transform.gameObject.GetComponent<Renderer>().enabled = false;
				if (array[i].sharedMesh == null)
				{
					break;
				}
				for (int j = 0; j < array[i].sharedMesh.subMeshCount; j++)
				{
					if (component == null)
					{
						break;
					}
					if (j < component.sharedMaterials.Length && j < array[i].sharedMesh.subMeshCount)
					{
						int num = Contains(arrayList, component.sharedMaterials[j]);
						if (num == -1)
						{
							arrayList.Add(component.sharedMaterials[j]);
							num = arrayList.Count - 1;
						}
						arrayList2.Add(new ArrayList());
						CombineInstance combineInstance = default(CombineInstance);
						combineInstance.transform = component.transform.localToWorldMatrix;
						combineInstance.mesh = array[i].sharedMesh;
						combineInstance.subMeshIndex = j;
						(arrayList2[num] as ArrayList).Add(combineInstance);
					}
				}
			}
			Mesh[] array2 = new Mesh[arrayList.Count];
			CombineInstance[] array3 = new CombineInstance[arrayList.Count];
			for (int k = 0; k < arrayList.Count; k++)
			{
				CombineInstance[] combine = (arrayList2[k] as ArrayList).ToArray(typeof(CombineInstance)) as CombineInstance[];
				array2[k] = new Mesh();
				if (increaseVertexCount)
				{
					array2[k].indexFormat = IndexFormat.UInt32;
				}
				array2[k].CombineMeshes(combine, mergeSubMeshes: true, useMatrices: true);
				array3[k] = default(CombineInstance);
				array3[k].mesh = array2[k];
				array3[k].subMeshIndex = 0;
			}
			Mesh mesh2 = (gameObject.GetComponent<MeshFilter>().sharedMesh = new Mesh());
			Mesh mesh3 = mesh2;
			if (increaseVertexCount)
			{
				mesh3.indexFormat = IndexFormat.UInt32;
			}
			mesh3.Clear();
			mesh3.CombineMeshes(array3, mergeSubMeshes: false, useMatrices: false);
			gameObject.GetComponent<MeshFilter>().sharedMesh = mesh3;
			Mesh[] array4 = array2;
			foreach (Mesh obj in array4)
			{
				obj.Clear();
				UnityEngine.Object.DestroyImmediate(obj);
			}
			MeshRenderer meshRenderer = gameObject.GetComponent<MeshFilter>().GetComponent<MeshRenderer>();
			if (meshRenderer == null)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			Material[] materials = arrayList.ToArray(typeof(Material)) as Material[];
			meshRenderer.materials = materials;
			combined = gameObject.gameObject;
			EnableRenderers(e: false);
			gameObject.transform.parent = base.transform;
			gameObject.GetComponent<MeshFilter>().sharedMesh.RecalculateBounds();
			vCount = gameObject.GetComponent<MeshFilter>().sharedMesh.vertexCount;
			if (setStatic)
			{
				combined.isStatic = true;
			}
			if (setMeshPivottoParentPivot)
			{
				base.transform.position = position;
			}
		}

		public int Contains(ArrayList l, Material n)
		{
			for (int i = 0; i < l.Count; i++)
			{
				if (l[i] as Material == n)
				{
					return i;
				}
			}
			return -1;
		}
	}
	public class SimpleMeshCombineMaster : MonoBehaviour
	{
		public bool generateLightmapUV;
	}
	public class AlphaButtonClickMask : MonoBehaviour, ICanvasRaycastFilter
	{
		protected Image _image;

		public void Start()
		{
			_image = GetComponent<Image>();
			Texture2D texture = _image.sprite.texture;
			bool flag = false;
			if (texture != null)
			{
				try
				{
					texture.GetPixels32();
				}
				catch (UnityException ex)
				{
					UnityEngine.Debug.LogError(ex.Message);
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				UnityEngine.Debug.LogError("This script need an Image with a readbale Texture2D to work.");
			}
		}

		public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			RectTransformUtility.ScreenPointToLocalPointInRectangle(_image.rectTransform, sp, eventCamera, out var localPoint);
			Vector2 pivot = _image.rectTransform.pivot;
			Vector2 vector = new Vector2(pivot.x + localPoint.x / _image.rectTransform.rect.width, pivot.y + localPoint.y / _image.rectTransform.rect.height);
			Vector2 vector2 = new Vector2(_image.sprite.rect.x + vector.x * _image.sprite.rect.width, _image.sprite.rect.y + vector.y * _image.sprite.rect.height);
			vector2.x /= _image.sprite.texture.width;
			vector2.y /= _image.sprite.texture.height;
			return _image.sprite.texture.GetPixelBilinear(vector2.x, vector2.y).a > 0.1f;
		}
	}
	public class EventSystemChecker : MonoBehaviour
	{
		private void Awake()
		{
			if (!UnityEngine.Object.FindObjectOfType<EventSystem>())
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>().forceModuleActive = true;
			}
		}
	}
	[ExecuteInEditMode]
	public class CheckForStandardAssets : MonoBehaviour
	{
		private void Awake()
		{
		}
	}
	public interface OnlineUser
	{
		string Name { get; }

		bool IsSignedIn { get; }
	}
	public interface OnlineAchievement
	{
		string Id { get; }

		string Name { get; }

		string Description { get; }

		bool IsUnlocked { get; }
	}
	public delegate void SignInEventHandler(object sender, OnlineUser user);
	public delegate void SignOutEventHandler(object sender, string name);
	public delegate void AchievementEventHandler(object sender, OnlineAchievement achievement);
	public interface OnlineInterface
	{
		OnlineUser CurrentUser { get; }

		event SignInEventHandler OnUserSignedIn;

		event SignOutEventHandler OnUserSignedOut;

		void Start();

		void SignInUser(bool silent);

		void SwitchUser();

		void SendEvent(string name);

		void GetAchievement(string id, AchievementEventHandler achievementRetrievedHandler);
	}
	public class XboxLiveDataUI
	{
		private OnlineInterface m_xblInterface;

		private GUIStyle m_guiStyle = new GUIStyle();

		private static DateTime m_lastButtonPress = DateTime.Now;

		private string m_logText = string.Empty;

		private List<string> m_logLines = new List<string>();

		public XboxLiveDataUI(OnlineInterface xblInterface)
		{
			m_xblInterface = xblInterface;
		}

		private void DrawTextWithShadow(float x, float y, float width, float height, string text)
		{
			m_guiStyle.fontSize = 14;
			m_guiStyle.normal.textColor = Color.black;
			GUI.Label(new Rect(x, y, height, height), text, m_guiStyle);
			m_guiStyle.normal.textColor = Color.white;
			GUI.Label(new Rect(x - 1f, y - 1f, width, height), text, m_guiStyle);
		}

		public void OnGUI()
		{
			bool flag = (DateTime.Now - m_lastButtonPress).TotalMilliseconds > 150.0;
			lock (m_logText)
			{
				DrawTextWithShadow(10f, 270f, 800f, 900f, m_logText);
			}
			if (GUI.Button(new Rect(10f, 180f, 150f, 30f), "[X] Send Event") || (Input.GetButtonDown("Fire3") && flag))
			{
				m_lastButtonPress = DateTime.Now;
				SendEvent();
			}
			if (GUI.Button(new Rect(10f, 220f, 150f, 30f), "[Y] Get Achievement") || (Input.GetButtonDown("Jump") && flag))
			{
				m_lastButtonPress = DateTime.Now;
				GetAchievement();
			}
		}

		private void SendEvent()
		{
			if (m_xblInterface.CurrentUser == null)
			{
				LogLine("A user is required to send an event. Please sign in a user first.");
				LogLine("");
				return;
			}
			try
			{
				m_xblInterface.SendEvent("EnemyDefeated");
				LogLine("EnemyDefeated event was fired.");
				LogLine("");
			}
			catch (Exception ex)
			{
				LogLine("SendEvent failed: " + ex.Message);
				LogLine("");
			}
		}

		private void GetAchievement()
		{
			if (m_xblInterface.CurrentUser == null)
			{
				LogLine("A user is required to send an event. Please sign in a user first.");
				LogLine("");
				return;
			}
			LogLine("Getting achievement...");
			LogLine("");
			try
			{
				m_xblInterface.GetAchievement("1", delegate(object sender, OnlineAchievement achievement)
				{
					if (achievement == null)
					{
						LogLine("GetAchievement failed");
						LogLine("");
					}
					else
					{
						LogLine($"Achievement: {achievement.Name} (ID: {achievement.Id})");
						LogLine($"Description: {achievement.Description}");
						LogLine($"IsUnlocked: {achievement.IsUnlocked}");
						LogLine("");
					}
				});
			}
			catch (Exception ex)
			{
				LogLine("GetAchievement failed: " + ex.Message);
				LogLine("");
			}
		}

		public void ClearLog()
		{
			lock (m_logText)
			{
				m_logLines.Clear();
			}
		}

		public void LogLine(string line)
		{
			lock (m_logText)
			{
				if (m_logLines.Count > 40)
				{
					m_logLines.RemoveAt(0);
				}
				m_logLines.Add(line);
				m_logText = string.Empty;
				foreach (string logLine in m_logLines)
				{
					m_logText += "\n";
					m_logText += logLine;
				}
				m_logText += "\n";
			}
		}
	}
	public class XboxLiveSignInUI
	{
		private OnlineInterface m_xblInterface;

		private OnlineUser m_user;

		private GUIStyle m_guiStyle = new GUIStyle();

		private static DateTime m_lastButtonPress = DateTime.Now;

		private string m_logText = string.Empty;

		private List<string> m_logLines = new List<string>();

		public XboxLiveSignInUI(OnlineInterface xblInterface)
		{
			m_xblInterface = xblInterface;
		}

		public void Start()
		{
			m_xblInterface.OnUserSignedIn += OnUserSignIn;
			m_xblInterface.OnUserSignedOut += OnUserSignOut;
			m_xblInterface.SignInUser(silent: true);
		}

		public void OnUserSignIn(object sender, OnlineUser user)
		{
			if (user != null)
			{
				m_user = user;
				LogLine("User signed in: " + m_user.Name);
			}
			else
			{
				LogLine("Error during sign in");
			}
		}

		public void OnUserSignOut(object sender, string name)
		{
			LogLine("User signed out: " + name);
			if (name == m_user.Name)
			{
				m_user = null;
			}
		}

		private void DrawTextWithShadow(float x, float y, float width, float height, string text)
		{
			m_guiStyle.fontSize = 14;
			m_guiStyle.normal.textColor = Color.black;
			GUI.Label(new Rect(x, y, height, height), text, m_guiStyle);
			m_guiStyle.normal.textColor = Color.white;
			GUI.Label(new Rect(x - 1f, y - 1f, width, height), text, m_guiStyle);
		}

		public void OnGUI()
		{
			bool flag = (DateTime.Now - m_lastButtonPress).TotalMilliseconds > 150.0;
			lock (m_logText)
			{
				DrawTextWithShadow(10f, 50f, 800f, 500f, m_logText);
			}
			if (GUI.Button(new Rect(10f, 10f, 100f, 30f), "[A] Sign-in") || (Input.GetButtonDown("Fire1") && flag))
			{
				m_lastButtonPress = DateTime.Now;
				SignIn();
			}
			if (GUI.Button(new Rect(120f, 10f, 120f, 30f), "[B] Change Users") || (Input.GetButtonDown("Fire2") && flag))
			{
				m_lastButtonPress = DateTime.Now;
				SwitchAccount();
			}
		}

		public void LogLine(string line)
		{
			lock (m_logText)
			{
				if (m_logLines.Count > 5)
				{
					m_logLines.RemoveAt(0);
				}
				m_logLines.Add(line);
				m_logText = string.Empty;
				foreach (string logLine in m_logLines)
				{
					m_logText += "\n";
					m_logText += logLine;
				}
			}
		}

		public void SignIn()
		{
			try
			{
				m_xblInterface.SignInUser(silent: false);
			}
			catch (Exception ex)
			{
				LogLine("SignIn failed: " + ex.ToString());
			}
		}

		public void SwitchAccount()
		{
			try
			{
				m_xblInterface.SwitchUser();
			}
			catch (Exception ex)
			{
				LogLine("SwitchAccount failed: " + ex.ToString());
			}
		}
	}
	public class OVXBoxLiveHandler : OVGenericSingleton<OVXBoxLiveHandler>
	{
		private void Start()
		{
		}

		private static OnlineInterface CreateXboxLiveInterface()
		{
			return null;
		}
	}
	public class OVXBoxSaveController : OVGenericSingleton<OVXBoxSaveController>
	{
	}
	public class AirplaneSound : MonoBehaviour
	{
		[SerializeField]
		private AudioSource sfx;

		[SerializeField]
		private Vector2 minMaxPitch;

		[SerializeField]
		private Vector2 minMaxVolume;

		private AeroplaneController aeroplaneController;

		private void Awake()
		{
			aeroplaneController = GetComponent<AeroplaneController>();
		}

		private void Update()
		{
			sfx.pitch = Mathf.Lerp(minMaxPitch.x, minMaxPitch.y, aeroplaneController.ForwardSpeed / aeroplaneController.MaxSpeed);
			sfx.volume = Mathf.Lerp(minMaxVolume.x, minMaxVolume.y, aeroplaneController.ForwardSpeed / aeroplaneController.MaxSpeed);
		}
	}
	[RequireComponent(typeof(SphereCollider))]
	public class EnemyMovement : MonoBehaviour
	{
		public enum MovementType
		{
			None,
			Random3d,
			WaypointsLooped,
			ToTarget,
			ToTargetContinuesly
		}

		public enum RotationType
		{
			None,
			LookAtTarget,
			LookAtMovementTarget
		}

		[SerializeField]
		private Animator animator;

		[SerializeField]
		private bool useHitAnimation;

		[SerializeField]
		private bool useAttackAnimation;

		[Space]
		[SerializeField]
		private NavMeshAgent agent;

		[SerializeField]
		private MovementType movementType;

		[SerializeField]
		private RotationType rotationType;

		[SerializeField]
		private float targetReachedDistance = 1f;

		[SerializeField]
		private float movementSpeed = 1f;

		[SerializeField]
		private float rotationSpeed = 1f;

		[SerializeField]
		private bool ignoreXRotation;

		[SerializeField]
		private bool keepSameDistanceToTarget;

		[SerializeField]
		private Vector3 randomDimension = Vector3.one;

		[SerializeField]
		private float increaseTriggerSize = 1f;

		[SerializeField]
		private bool keepTarget;

		[Header("BoomFish")]
		[SerializeField]
		private bool damagePlayerIfNear;

		[SerializeField]
		private float minDistance;

		[SerializeField]
		private float damageAmount;

		[Header("Portal & Highscore")]
		[Tooltip("Use for Portal and Highscore logic")]
		public float pointValue;

		private SphereCollider triggerCollider;

		[SerializeField]
		[HideInInspector]
		private Vector3 initialPosition;

		private Vector3 lastPosition;

		private Vector3 targetPosition;

		private MovementType initialMovement;

		private float initialDistanceToTarget;

		private int waypointIndex;

		private const string movementX = "MovementX";

		private const string movementY = "MovementY";

		private const string attackTrigger = "Attack";

		private const string hitTrigger = "Hit";

		private const string deathTrigger = "Dead";

		[Header("Runtime")]
		[SerializeField]
		private Transform[] _wayPoints;

		[SerializeField]
		private Transform _target;

		public Transform[] WayPoints
		{
			get
			{
				return _wayPoints;
			}
			set
			{
				_wayPoints = value;
			}
		}

		public Transform Target
		{
			get
			{
				return _target;
			}
			set
			{
				_target = value;
				OnTargetChange(value);
			}
		}

		public Transform AimTarget { get; private set; }

		public Bounds EnemySize { get; private set; }

		public MovementType Movement => movementType;

		public event Action<Transform, Transform> OnTargetChanged;

		public event Action<EnemyMovement> OnEnemyDestroyed;

		public static event Action<EnemyMovement> SOnEnemyDestroyed;

		public void HandleShoot()
		{
			if (useAttackAnimation && (bool)animator)
			{
				animator.SetTrigger("Attack");
			}
		}

		public void HandleDamage()
		{
			if (useHitAnimation && (bool)animator)
			{
				animator.SetTrigger("Hit");
			}
		}

		public void HandleDeath()
		{
			if ((bool)animator)
			{
				animator.SetTrigger("Dead");
			}
		}

		private void OnValidate()
		{
			initialPosition = base.transform.position;
		}

		private void Awake()
		{
			triggerCollider = GetComponent<SphereCollider>();
			initialPosition = base.transform.position;
			initialMovement = movementType;
			EnemySize = GetComponentInChildren<SkinnedMeshRenderer>().bounds;
			if ((bool)agent)
			{
				agent.speed = movementSpeed;
			}
			if ((bool)Target)
			{
				OnTargetChange(Target);
			}
		}

		private void Start()
		{
			if (movementType == MovementType.WaypointsLooped && WayPoints.Length == 0)
			{
				movementType = MovementType.None;
				UnityEngine.Debug.LogErrorFormat(base.gameObject, "{0} has no waypoints!\n", base.gameObject.name);
			}
			SetNewMovementTarget();
		}

		private void OnEnable()
		{
			if ((bool)agent)
			{
				agent.enabled = true;
			}
			triggerCollider.enabled = triggerCollider.radius > 0.01f;
		}

		private void OnDisable()
		{
			if ((bool)agent)
			{
				agent.enabled = false;
			}
			triggerCollider.enabled = false;
		}

		private void Update()
		{
			UpdateMovementTarget();
			UpdateRotation();
			UpdateMovement();
		}

		private void OnDestroy()
		{
			this.OnEnemyDestroyed?.Invoke(this);
			EnemyMovement.SOnEnemyDestroyed?.Invoke(this);
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Player")
			{
				Target = other.transform;
				triggerCollider.radius *= increaseTriggerSize;
				if (movementType == MovementType.Random3d)
				{
					movementType = MovementType.ToTarget;
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.tag == "Player")
			{
				if (!keepTarget)
				{
					Target = null;
				}
				triggerCollider.radius /= increaseTriggerSize;
				if (movementType == MovementType.ToTarget)
				{
					movementType = initialMovement;
				}
			}
		}

		private void OnTargetChange(Transform newTarget)
		{
			if (!(newTarget == null))
			{
				SmartTarget componentInChildren = newTarget.GetComponentInChildren<SmartTarget>(includeInactive: true);
				if ((bool)componentInChildren)
				{
					AimTarget = componentInChildren.transform;
				}
				initialDistanceToTarget = Vector3.Distance(base.transform.position, newTarget.position);
				this.OnTargetChanged?.Invoke(newTarget, AimTarget);
			}
		}

		private void UpdateMovementTarget()
		{
			if (movementType == MovementType.ToTargetContinuesly)
			{
				SetNewMovementTarget();
			}
			else if (IsTargetReached())
			{
				SetNewMovementTarget();
			}
		}

		private void SetNewMovementTarget()
		{
			if (movementType != 0 && ((movementType != MovementType.ToTarget && movementType != MovementType.ToTargetContinuesly) || !(Target == null)))
			{
				if (movementType == MovementType.ToTarget)
				{
					targetPosition = Target.position;
				}
				if (movementType == MovementType.ToTargetContinuesly)
				{
					targetPosition = Target.position;
				}
				if (movementType == MovementType.Random3d)
				{
					targetPosition = initialPosition + new Vector3(UnityEngine.Random.Range((0f - randomDimension.x) / 2f, randomDimension.x / 2f), UnityEngine.Random.Range((0f - randomDimension.y) / 2f, randomDimension.y / 2f), UnityEngine.Random.Range((0f - randomDimension.z) / 2f, randomDimension.z / 2f));
				}
				if (movementType == MovementType.WaypointsLooped)
				{
					targetPosition = WayPoints[waypointIndex].position;
				}
			}
		}

		private void UpdateRotation()
		{
			if (rotationType != 0)
			{
				if (rotationType == RotationType.LookAtTarget)
				{
					SmoothLookAt(Target ? Target.transform.position : targetPosition);
				}
				if (rotationType == RotationType.LookAtMovementTarget)
				{
					SmoothLookAt(targetPosition);
				}
			}
		}

		private void UpdateMovement()
		{
			if (movementType != 0)
			{
				if ((bool)agent)
				{
					agent.destination = targetPosition;
				}
				else
				{
					Vector3 normalized = (targetPosition - base.transform.position).normalized;
					base.transform.position += normalized * movementSpeed * Time.deltaTime;
				}
				if (damagePlayerIfNear && Target != null && Target.tag == "Player" && Vector3.Distance(base.transform.position, Target.position) < minDistance)
				{
					Target.GetComponentInParent<Health>().ReceiveDamage(damageAmount, Bullet.Effect.None, 0f);
					Health component = GetComponent<Health>();
					component.ReceiveDamage(component.CurrentHealth, Bullet.Effect.None, 0f);
				}
				if ((bool)animator)
				{
					UpdateAnimator();
				}
				lastPosition = base.transform.position;
			}
		}

		private void UpdateAnimator()
		{
			Vector3 vector = base.transform.position - lastPosition;
			vector = Quaternion.Inverse(base.transform.rotation) * vector;
			vector /= Time.deltaTime * movementSpeed;
			animator.SetFloat("MovementX", vector.x);
			animator.SetFloat("MovementY", vector.z);
		}

		private bool IsTargetReached()
		{
			if (Vector3.Distance(base.transform.position, targetPosition) < targetReachedDistance)
			{
				if (movementType == MovementType.WaypointsLooped)
				{
					waypointIndex = (waypointIndex + 1) % WayPoints.Length;
				}
				return true;
			}
			return false;
		}

		private void SmoothLookAt(Vector3 targetPosition)
		{
			if (ignoreXRotation)
			{
				targetPosition.y = base.transform.position.y;
			}
			Vector3 vector = targetPosition - base.transform.position;
			Quaternion b = Quaternion.LookRotation((vector == Vector3.zero) ? base.transform.forward : vector);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, rotationSpeed * Time.deltaTime);
		}

		private void OnDrawGizmosSelected()
		{
			if (movementType == MovementType.Random3d)
			{
				Gizmos.color = Color.cyan;
				Gizmos.DrawWireCube(initialPosition, randomDimension);
			}
		}
	}
	public class EnemyMovementOld : MonoBehaviour
	{
		public enum MovementType
		{
			None,
			Random3d,
			WaypointsLooped,
			ToTarget,
			ToTargetContinuesly
		}

		public enum RotationType
		{
			None,
			LookAtTarget,
			LookAtMovementTarget
		}

		[Header("General Settings")]
		[SerializeField]
		public bool active = true;

		[Header("General Movement Settings")]
		[SerializeField]
		public MovementType movementType;

		[SerializeField]
		public RotationType rotationType;

		[SerializeField]
		public GameObject target;

		[SerializeField]
		public float targetReachedDistance = 1f;

		[SerializeField]
		public float movementSpeed = 1f;

		[SerializeField]
		public float rotationSpeed = 1f;

		[SerializeField]
		public bool ignoreYForMovement;

		[SerializeField]
		public bool ignoreYForRotation;

		[Header("Random Settings")]
		[SerializeField]
		public Vector3 randomDimension;

		[Header("Waypoint Settings")]
		[SerializeField]
		public GameObject[] waypoints;

		[Header("To Target Settings")]
		[SerializeField]
		public bool keepSameDistanceToTarget;

		[Header("Attacks")]
		[SerializeField]
		public bool useAttack;

		[SerializeField]
		public float maxAttackDistance;

		[SerializeField]
		public float attackIntervall;

		[SerializeField]
		public GameObject aimTarget;

		[SerializeField]
		public GameObject bullet;

		[SerializeField]
		public GameObject bulletSpawnPoint;

		[Header("Animations")]
		[SerializeField]
		public Animator animator;

		[SerializeField]
		public bool useHitAnimation;

		[SerializeField]
		public string hitTrigger;

		[SerializeField]
		public bool useAttackAnimation;

		[SerializeField]
		public string attackTrigger;

		private int waypointIndex;

		private Vector3 initialPosition;

		private Vector3 movementTarget;

		private Vector3 distanceToTarget;

		private void Start()
		{
			initialPosition = base.transform.position;
			distanceToTarget = target.transform.position - base.transform.position;
			NewMovementTarget();
			if (useAttack)
			{
				InvokeRepeating("Shoot", attackIntervall + UnityEngine.Random.Range(0f, attackIntervall), attackIntervall);
			}
		}

		private void Update()
		{
			if (active)
			{
				Rotation();
				Movement();
			}
		}

		private void Rotation()
		{
			if (rotationType != 0)
			{
				if (rotationType == RotationType.LookAtTarget)
				{
					SmoothLookAt(target.transform.position);
				}
				if (rotationType == RotationType.LookAtMovementTarget)
				{
					SmoothLookAt(movementTarget);
				}
			}
		}

		private void Movement()
		{
			if (movementType != 0)
			{
				if (movementType == MovementType.ToTargetContinuesly)
				{
					NewMovementTarget();
				}
				else if (IsTargetReached())
				{
					NewMovementTarget();
				}
				base.transform.position = Vector3.Lerp(base.transform.position, movementTarget, movementSpeed * Time.deltaTime);
			}
		}

		private void Shoot()
		{
			if (active && !(Vector3.Distance(base.transform.position, aimTarget.transform.position) > maxAttackDistance) && IsAimTargetIsInFront())
			{
				if (useAttackAnimation)
				{
					animator.SetTrigger(attackTrigger);
				}
				bulletSpawnPoint.transform.LookAt(aimTarget.transform);
				UnityEngine.Object.Instantiate(bullet, bulletSpawnPoint.transform.position, bulletSpawnPoint.transform.rotation, null);
			}
		}

		public void Hit()
		{
			if (useHitAnimation)
			{
				animator.SetTrigger(hitTrigger);
			}
		}

		private void SmoothLookAt(Vector3 targetPosition)
		{
			if (ignoreYForRotation)
			{
				targetPosition.y = base.transform.position.y;
			}
			Quaternion b = Quaternion.LookRotation(targetPosition - base.transform.position);
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, rotationSpeed * Time.deltaTime);
		}

		private bool IsTargetReached()
		{
			if (Vector3.Distance(base.transform.position, movementTarget) < targetReachedDistance)
			{
				if (movementType == MovementType.WaypointsLooped)
				{
					waypointIndex++;
					if (waypointIndex > waypoints.Length - 1)
					{
						waypointIndex = 0;
					}
				}
				return true;
			}
			return false;
		}

		private bool IsAimTargetIsInFront()
		{
			if (Vector3.Dot(aimTarget.transform.position - base.transform.position, base.transform.forward) > 0f)
			{
				return true;
			}
			return false;
		}

		private void NewMovementTarget()
		{
			if (movementType != 0 && ((movementType != MovementType.ToTarget && movementType != MovementType.ToTargetContinuesly) || !(target == null)))
			{
				if (movementType == MovementType.ToTarget)
				{
					movementTarget = target.transform.position;
				}
				if (movementType == MovementType.ToTargetContinuesly)
				{
					movementTarget = target.transform.position;
				}
				if ((movementType == MovementType.ToTargetContinuesly || movementType == MovementType.ToTarget) && keepSameDistanceToTarget)
				{
					movementTarget += distanceToTarget;
				}
				if (movementType == MovementType.Random3d)
				{
					movementTarget = initialPosition + new Vector3(UnityEngine.Random.Range((0f - randomDimension.x) / 2f, randomDimension.x / 2f), UnityEngine.Random.Range((0f - randomDimension.y) / 2f, randomDimension.y / 2f), UnityEngine.Random.Range((0f - randomDimension.z) / 2f, randomDimension.z / 2f));
				}
				if (movementType == MovementType.WaypointsLooped)
				{
					movementTarget = waypoints[waypointIndex].transform.position;
				}
				if (ignoreYForMovement)
				{
					movementTarget.y = initialPosition.y;
				}
			}
		}
	}
	[RequireComponent(typeof(Collider))]
	public class EnemyPortal : MonoBehaviour
	{
		[SerializeField]
		private float gameOverPoints;

		[SerializeField]
		private AudioSource sfxOnEnter;

		public UnityEvent OnPortalPointsReached;

		[Header("Current Points:")]
		[SerializeField]
		[Info]
		private float _currentPoints;

		public float CurrentPoints
		{
			get
			{
				return _currentPoints;
			}
			private set
			{
				this.OnPointsUpdated?.Invoke(value);
				_currentPoints = value;
			}
		}

		public float GameOverPoints => gameOverPoints;

		public event Action<float> OnPointsUpdated;

		private void OnTriggerEnter(Collider other)
		{
			if ((bool)other.GetComponent<Hitbox>() && other.tag == "Enemy")
			{
				EnemyMovement componentInParent = other.GetComponentInParent<EnemyMovement>();
				CurrentPoints += componentInParent.pointValue;
				UnityEngine.Object.Destroy(componentInParent.gameObject);
				sfxOnEnter.Play();
				if (CurrentPoints >= gameOverPoints)
				{
					OnPortalPointsReached.Invoke();
				}
			}
		}
	}
	public class EnemySceneManager : MonoBehaviour
	{
		[Serializable]
		private class Wave
		{
			public EnemySpawner[] spawners;

			public float time;
		}

		[SerializeField]
		private Wave[] waves;

		[SerializeField]
		private int maxEnemyCountInScene;

		[ReadOnly]
		public int debugEnemyCount;

		private float time;

		private int wave = -1;

		private bool paused;

		private const float idleTime = 10f;

		public bool LastWaveReached => wave >= waves.Length - 1;

		private void Awake()
		{
			time = -10f;
			EnemySpawner.OnEnemyCountChange += HandleEnemyCountChange;
		}

		private void OnDestroy()
		{
			EnemySpawner.OnEnemyCountChange -= HandleEnemyCountChange;
		}

		private void Update()
		{
			debugEnemyCount = EnemySpawner.TotalEnemyCount;
			if (EnemySpawner.TotalEnemyCount >= maxEnemyCountInScene)
			{
				PauseSpawn();
				return;
			}
			if (this.wave + 1 >= waves.Length)
			{
				this.wave = waves.Length - 1;
				return;
			}
			time += Time.deltaTime;
			Wave wave = waves[this.wave + 1];
			if (time > wave.time)
			{
				this.wave++;
				UnityEngine.Debug.LogFormat("New Wave '{0}' spawned!\n{1}", this.wave, base.name);
				EnemySpawner[] spawners = wave.spawners;
				for (int i = 0; i < spawners.Length; i++)
				{
					spawners[i].Spawn();
				}
			}
		}

		private void HandleEnemyCountChange(int newCount)
		{
			if (newCount >= maxEnemyCountInScene)
			{
				PauseSpawn();
			}
			else if (newCount < maxEnemyCountInScene)
			{
				ContinueSpawn();
			}
		}

		private void PauseSpawn()
		{
			if (paused)
			{
				return;
			}
			Wave[] array = waves;
			for (int i = 0; i < array.Length; i++)
			{
				EnemySpawner[] spawners = array[i].spawners;
				for (int j = 0; j < spawners.Length; j++)
				{
					spawners[j].PauseSpawn();
				}
			}
			paused = true;
		}

		private void ContinueSpawn()
		{
			if (!paused)
			{
				EnemySpawner[] spawners = waves[wave].spawners;
				for (int i = 0; i < spawners.Length; i++)
				{
					spawners[i].ContinueSpawn();
				}
				paused = false;
			}
		}
	}
	[RequireComponent(typeof(EnemyMovement))]
	public class EnemyShooter : MonoBehaviour
	{
		public Bullet bulletPrefab;

		[SerializeField]
		private Transform[] spawnPoints;

		[SerializeField]
		[Tooltip("Check the white sphere to see the range of attack")]
		private float maxAttackDistance = 100f;

		[SerializeField]
		[Range(0.1f, 10f)]
		private float frequency = 1f;

		[SerializeField]
		[Range(0.1f, 10f)]
		private float reloadTime = 1f;

		[SerializeField]
		[Range(1f, 10f)]
		private int salvo = 1;

		[SerializeField]
		[Range(0f, 1f)]
		private float spreading;

		[SerializeField]
		private bool shootWithoutTarget;

		[SerializeField]
		private bool shootAtTarget;

		[SerializeField]
		private bool shootMultipleBulletsAtOnce;

		private EnemyMovement enemyMovement;

		private Transform currentTarget;

		private Hitbox[] hitboxes;

		private float time;

		private float salvoCount;

		private float distanceToPlayer;

		private int currentSpawnIdx;

		private bool playerNotInSight;

		private const float spreadingMultiplier = 0.1f;

		private void Awake()
		{
			enemyMovement = GetComponent<EnemyMovement>();
			hitboxes = GetComponentsInChildren<Hitbox>(includeInactive: true);
		}

		private void OnEnable()
		{
			enemyMovement.OnTargetChanged += HandleTargetChange;
		}

		private void OnDisable()
		{
			enemyMovement.OnTargetChanged -= HandleTargetChange;
		}

		private void Update()
		{
			if (!currentTarget && !shootWithoutTarget)
			{
				return;
			}
			distanceToPlayer = Vector3.Distance(currentTarget.position, base.transform.position);
			if ((bool)currentTarget && distanceToPlayer > maxAttackDistance)
			{
				return;
			}
			time += Time.deltaTime;
			if (!(time > 1f / frequency))
			{
				return;
			}
			if (!shootWithoutTarget && (bool)currentTarget)
			{
				Vector3 position = spawnPoints[0].position;
				if (Physics.Raycast(position, currentTarget.position - position, out var hitInfo, maxAttackDistance))
				{
					playerNotInSight = hitInfo.transform.tag != "Player" && hitInfo.transform.tag != "TakeOffPlatform";
					if (playerNotInSight)
					{
						return;
					}
				}
			}
			Shoot();
			salvoCount += 1f;
			time = ((salvoCount >= (float)salvo) ? (0f - reloadTime) : 0f);
		}

		private void HandleTargetChange(Transform target, Transform smartTarget)
		{
			currentTarget = (smartTarget ? smartTarget : target);
			time = 0f;
			salvoCount = 0f;
		}

		private void Shoot()
		{
			if (shootMultipleBulletsAtOnce)
			{
				Transform[] array = spawnPoints;
				foreach (Transform spawnPoint in array)
				{
					CreateBullet(spawnPoint);
				}
			}
			else
			{
				CreateBullet(spawnPoints[currentSpawnIdx]);
				currentSpawnIdx = (currentSpawnIdx + 1) % spawnPoints.Length;
			}
			enemyMovement.HandleShoot();
		}

		private void CreateBullet(Transform spawnPoint)
		{
			Vector3 forward = ((shootAtTarget && (bool)currentTarget) ? (currentTarget.position - spawnPoint.position) : spawnPoint.forward);
			forward += UnityEngine.Random.onUnitSphere * spreading * 0.1f;
			UnityEngine.Object.Instantiate(bulletPrefab, spawnPoint.position, Quaternion.LookRotation(forward)).Initialize(hitboxes);
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.color = ((playerNotInSight || distanceToPlayer > maxAttackDistance) ? Color.red : Color.green);
			if ((bool)currentTarget)
			{
				Gizmos.DrawLine(spawnPoints[0].position, currentTarget.position);
			}
			Gizmos.color = Color.white;
			Gizmos.DrawWireSphere(base.transform.position, maxAttackDistance);
		}
	}
	public class EnemySpawner : MonoBehaviour
	{
		public enum Difficulty
		{
			Easy,
			Medium,
			Hard
		}

		[SerializeField]
		private EnemyMovement enemyPrefab;

		[SerializeField]
		private Transform[] spawnPoints;

		[SerializeField]
		private Transform[] enemyWayPoints;

		[SerializeField]
		private Transform target;

		[SerializeField]
		private Material[] enemyMaterials = new Material[3];

		[Header("Spawn Options")]
		public Difficulty difficulty;

		[SerializeField]
		private float[] difficultyHealthValues = new float[3];

		[SerializeField]
		private Bullet[] difficultyBullets = new Bullet[3];

		[SerializeField]
		[Range(0.01f, 1f)]
		private float spawnFrequency;

		[SerializeField]
		private int waveSpawnCount;

		[SerializeField]
		private bool randomSpawnPoint;

		[SerializeField]
		private bool randomDifficulty;

		[SerializeField]
		private bool spawnOnAwake;

		private EnemyMovement[] enemiesOnSpawnPoint;

		private List<EnemyMovement> spawnedEnemies = new List<EnemyMovement>();

		private float time;

		private int currentIndex;

		private int waveSpawnedEnemies;

		private bool spawning;

		private static int _totalEnemyCount;

		public static int TotalEnemyCount
		{
			get
			{
				return _totalEnemyCount;
			}
			private set
			{
				EnemySpawner.OnEnemyCountChange?.Invoke(value);
				_totalEnemyCount = value;
			}
		}

		public static event Action<int> OnEnemyCountChange;

		public void Spawn()
		{
			if (spawning)
			{
				UnityEngine.Debug.LogWarningFormat(base.gameObject, "'{0}' is currently spawning!\n", base.name);
				waveSpawnedEnemies -= waveSpawnCount;
			}
			else
			{
				UnityEngine.Debug.Log("Spawn: " + base.name + "\n");
				spawning = true;
				waveSpawnedEnemies = 0;
			}
		}

		public void PauseSpawn()
		{
			if (spawning)
			{
				spawning = false;
				time = 0f;
			}
		}

		public void ContinueSpawn()
		{
			if (!spawning)
			{
				UnityEngine.Debug.Log("Continue: " + base.name + "\n");
				spawning = true;
			}
		}

		private void Awake()
		{
			if (waveSpawnCount <= 0)
			{
				UnityEngine.Debug.LogWarning("Wave Spawn Count is 0!\n" + base.name, base.gameObject);
			}
			enemiesOnSpawnPoint = new EnemyMovement[spawnPoints.Length];
			if (spawnOnAwake)
			{
				Spawn();
			}
		}

		private void Update()
		{
			if (!spawning)
			{
				return;
			}
			if (waveSpawnedEnemies >= waveSpawnCount)
			{
				spawning = false;
				return;
			}
			time += Time.deltaTime;
			if (!(time >= 1f / spawnFrequency))
			{
				return;
			}
			UpdateSpawntEnemies();
			if (enemiesOnSpawnPoint.All((EnemyMovement esp) => esp != null))
			{
				if (enemyPrefab.Movement == EnemyMovement.MovementType.None)
				{
					base.enabled = false;
				}
				return;
			}
			int num = spawnPoints.Length;
			currentIndex = GetSpawnPointIdx();
			while (enemiesOnSpawnPoint[currentIndex] != null)
			{
				if (num <= 0)
				{
					UnityEngine.Debug.LogWarning("Too many attempts. This shouldn't happen!\n" + base.name, base.gameObject);
					return;
				}
				currentIndex = GetSpawnPointIdx();
				num--;
			}
			Transform transform = spawnPoints[currentIndex];
			EnemyMovement newEnemy = UnityEngine.Object.Instantiate(enemyPrefab, transform.position, transform.rotation);
			SetupNewEnemy(newEnemy);
			waveSpawnedEnemies++;
			TotalEnemyCount++;
			time = 0f;
		}

		private void OnDestroy()
		{
			foreach (EnemyMovement spawnedEnemy in spawnedEnemies)
			{
				if (!(spawnedEnemy == null))
				{
					spawnedEnemy.OnEnemyDestroyed -= HandleEnemyDestroyed;
				}
			}
		}

		private int GetSpawnPointIdx()
		{
			if (randomSpawnPoint)
			{
				List<int> list = new List<int>();
				for (int i = 0; i < enemiesOnSpawnPoint.Length; i++)
				{
					if (enemiesOnSpawnPoint[i] == null)
					{
						list.Add(i);
					}
				}
				return list[UnityEngine.Random.Range(0, list.Count)];
			}
			return (currentIndex + 1) % spawnPoints.Length;
		}

		private void UpdateSpawntEnemies()
		{
			for (int i = 0; i < spawnPoints.Length; i++)
			{
				EnemyMovement enemyMovement = enemiesOnSpawnPoint[i];
				if (!(enemyMovement == null))
				{
					float magnitude = enemyMovement.EnemySize.size.magnitude;
					if (Vector3.Distance(spawnPoints[i].position, enemyMovement.transform.position) > magnitude)
					{
						enemiesOnSpawnPoint[i] = null;
					}
				}
			}
		}

		private void SetupNewEnemy(EnemyMovement newEnemy)
		{
			newEnemy.Target = target;
			newEnemy.WayPoints = enemyWayPoints;
			newEnemy.OnEnemyDestroyed += HandleEnemyDestroyed;
			difficulty = (randomDifficulty ? ((Difficulty)UnityEngine.Random.Range(0, 3)) : difficulty);
			Health component = newEnemy.GetComponent<Health>();
			float maxHealth = difficultyHealthValues[(int)difficulty];
			component.Initialize(maxHealth);
			EnemyShooter component2 = newEnemy.GetComponent<EnemyShooter>();
			if ((bool)component2)
			{
				component2.bulletPrefab = difficultyBullets[(int)difficulty];
			}
			enemiesOnSpawnPoint[currentIndex] = newEnemy;
			spawnedEnemies.Add(newEnemy);
			UnityEngine.Debug.LogFormat(base.gameObject, "'{0}' spawned '{1}' at {2}\n", base.name, newEnemy.name, spawnPoints[currentIndex]);
			if (enemyMaterials.Length != 0)
			{
				Renderer[] componentsInChildren = newEnemy.GetComponentsInChildren<Renderer>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].material = enemyMaterials[(int)difficulty];
				}
			}
		}

		private void HandleEnemyDestroyed(EnemyMovement destroyedEnemy)
		{
			if (!base.enabled && enemiesOnSpawnPoint.Any((EnemyMovement esp) => esp == destroyedEnemy || esp == null))
			{
				base.enabled = true;
			}
			spawnedEnemies.Remove(destroyedEnemy);
			TotalEnemyCount--;
		}
	}
	public class SmartTarget : MonoBehaviour
	{
		[SerializeField]
		public Rigidbody rb;

		[SerializeField]
		public float movementStrength = 1f;

		private void Update()
		{
			base.transform.position = rb.transform.position + rb.velocity * movementStrength / 100f;
		}
	}
	public class AeroLevelCompleteController : LevelCompleteController
	{
		protected const string lvlPref = "Level";

		protected const string modePref = "Mode";

		protected const string scorePref = "Score";

		private const int numberModes = 6;

		public override void HandleLevelComplete()
		{
			int num = SceneManager.GetActiveScene().buildIndex - 1;
			int @int = OVPlayerPrefs.GetInt("Level" + num + "Mode");
			bool[] array = (from s in Convert.ToString(@int, 2).PadLeft(6, '0')
				select s.Equals('1')).ToArray();
			int mode = (int)GameMode.CurrentGameMode.Mode;
			if (!array[mode])
			{
				array[mode] = true;
			}
			BitArray bitArray = new BitArray(array);
			int[] array2 = new int[1];
			bitArray.CopyTo(array2, 0);
			@int = array2[0];
			OVPlayerPrefs.SetInt("Level" + num + "Mode", @int);
			SaveHighScore(num);
			if (array.Count((bool m) => m) > 3)
			{
				OVPlayerPrefs.SetInt("Level" + (num + 1), 1);
				OVAchievement.Unlock(num.ToString() ?? "");
			}
			WTFGenericSingleton<AeroMenuController>.Instance.OpenGameOverMenu(won: true);
			OVPlayerPrefs.Save();
		}

		public void HandleLevelLost()
		{
			WTFGenericSingleton<AeroMenuController>.Instance.OpenGameOverMenu(won: false);
		}

		private void SaveHighScore(int level)
		{
			GameMode.WinCondition mode = GameMode.CurrentGameMode.Mode;
			string text = mode.ToString();
			string iD = "Level" + level + text + "Score";
			if (mode == GameMode.WinCondition.ScorePoints)
			{
				float currentTime = GameMode.CurrentGameMode.CurrentTime;
				if (OVPlayerPrefs.GetFloat(iD) > currentTime)
				{
					OVPlayerPrefs.SetFloat(iD, currentTime);
				}
			}
			else
			{
				int num = (int)(GameMode.CurrentGameMode.CurrentPoints * 100f);
				if (OVPlayerPrefs.GetInt(iD) < num)
				{
					OVPlayerPrefs.SetInt(iD, num);
				}
			}
			OVPlayerPrefs.Save();
		}
	}
	public class BossMode : GameMode
	{
		[SerializeField]
		private EnemyMovement bossEnemy;

		[SerializeField]
		private string bossName = "Big Boss";

		protected override string missionFormat => "Defeat: {0}!\nTime: {1}";

		public override WinCondition Mode => WinCondition.Boss;

		protected override void OnEnable()
		{
			base.OnEnable();
			bossEnemy.OnEnemyDestroyed += HandleBossDestroyed;
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			bossEnemy.OnEnemyDestroyed -= HandleBossDestroyed;
		}

		protected override void Update()
		{
			base.Update();
			string text = TimeSpan.FromSeconds(base.CurrentTime).ToString("mm\\:ss");
			MissionUpdate(bossName, text);
		}

		private void HandleBossDestroyed(EnemyMovement boss)
		{
			HandleLevelWon();
		}
	}
	public class GameMode : MonoBehaviour
	{
		public enum WinCondition
		{
			Survival,
			SpecialTargets,
			GatherObjects,
			ScorePoints,
			Boss,
			GateDefense
		}

		protected const string timeFormat = "mm\\:ss";

		private AeroLevelCompleteController completeController;

		public UnityEvent OnLevelWon;

		public UnityEvent OnLevelLost;

		private static GameMode _currentGameMode;

		public const int PointMultiplier = 100;

		private const float idleTime = 10f;

		protected virtual string missionFormat => "{0} {1} {2}";

		public virtual WinCondition Mode => (WinCondition)(-1);

		public float CurrentTime { get; protected set; }

		public float CurrentPoints { get; protected set; }

		public static GameMode CurrentGameMode
		{
			get
			{
				return _currentGameMode;
			}
			private set
			{
				UnityEngine.Debug.Log("GameMode: " + ((value == null) ? "NULL" : value.name) + "\n");
				_currentGameMode = value;
				GameMode.OnCurrentModeAssigned?.Invoke(value);
			}
		}

		public static event Action<GameMode> OnCurrentModeAssigned;

		public static event Action<string> OnMissionUpdated;

		protected virtual void OnEnable()
		{
			if (CurrentGameMode != this)
			{
				CurrentGameMode = this;
			}
			EnemyMovement.SOnEnemyDestroyed += HandleEnemyDestroyed;
		}

		protected virtual void OnDisable()
		{
			if (CurrentGameMode == this && CurrentGameMode != null)
			{
				CurrentGameMode = null;
			}
			EnemyMovement.SOnEnemyDestroyed -= HandleEnemyDestroyed;
		}

		private void Awake()
		{
			CurrentTime = -10f;
			completeController = UnityEngine.Object.FindObjectOfType<AeroLevelCompleteController>(includeInactive: true);
		}

		protected virtual void Update()
		{
			CurrentTime += Time.deltaTime;
		}

		public void SetLevelFinished(bool won)
		{
			if (won)
			{
				HandleLevelWon();
			}
			else
			{
				HandleLevelLost();
			}
		}

		protected virtual void HandleLevelWon()
		{
			UnityEngine.Debug.LogFormat("{0} Mode: Level Won!\n", CurrentGameMode);
			completeController.HandleLevelComplete();
			OnLevelWon.Invoke();
		}

		protected virtual void HandleLevelLost()
		{
			UnityEngine.Debug.LogFormat("{0} Mode: Level Lost!\n", CurrentGameMode);
			completeController.HandleLevelLost();
			OnLevelLost.Invoke();
		}

		protected virtual void HandleEnemyDestroyed(EnemyMovement enemy)
		{
			CurrentPoints += enemy.pointValue;
		}

		protected void MissionUpdate(params object[] args)
		{
			string obj = string.Format(missionFormat, args);
			GameMode.OnMissionUpdated?.Invoke(obj);
		}
	}
	public class GameModeSelector : MonoBehaviour
	{
		public static GameMode.WinCondition selectedMode;

		[SerializeField]
		private GameMode[] modes;

		private void Start()
		{
			GameMode[] array = modes;
			foreach (GameMode gameMode in array)
			{
				gameMode.gameObject.SetActive(gameMode.Mode == selectedMode);
			}
		}
	}
	public class GateDefenseMode : GameMode
	{
		[SerializeField]
		private EnemyPortal portal;

		[SerializeField]
		private float pointMultiplicator = 100f;

		private EnemySceneManager enemySceneManager;

		protected override string missionFormat => "Defend the Portal!\nEnemies went through {0}/{1}\nTime: {2}";

		public override WinCondition Mode => WinCondition.GateDefense;

		private void Awake()
		{
			enemySceneManager = GetComponent<EnemySceneManager>();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			portal.OnPointsUpdated += HandlePointsChanged;
			portal.OnPortalPointsReached.AddListener(HandlePortalPointsReached);
			EnemySpawner.OnEnemyCountChange += HandleEnemyCountChange;
			HandlePointsChanged(0f);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			portal.OnPointsUpdated -= HandlePointsChanged;
			portal.OnPortalPointsReached.RemoveListener(HandlePortalPointsReached);
			EnemySpawner.OnEnemyCountChange -= HandleEnemyCountChange;
		}

		private void HandlePointsChanged(float points)
		{
			string text = (points * pointMultiplicator).ToString();
			string text2 = (portal.GameOverPoints * pointMultiplicator).ToString();
			UnityEngine.Debug.LogError(portal.GameOverPoints * pointMultiplicator);
			string text3 = TimeSpan.FromSeconds(base.CurrentTime).ToString("mm\\:ss");
			MissionUpdate(text, text2, text3);
		}

		private void HandlePortalPointsReached()
		{
			HandleLevelLost();
		}

		private void HandleEnemyCountChange(int count)
		{
			if (enemySceneManager.LastWaveReached && count == 0)
			{
				HandleLevelWon();
			}
		}
	}
	public class GatherObjectsMode : GameMode
	{
		[SerializeField]
		private EpiPickupController pickupController;

		protected override string missionFormat => "Pick {0} from {1} items up.\nTime: {2}";

		public override WinCondition Mode => WinCondition.GatherObjects;

		protected override void OnEnable()
		{
			base.OnEnable();
			pickupController.OnPickUpCollected += HandlePickUpCollected;
			SetupPickUpRandom();
			MissionUpdate(pickupController.Collected, pickupController.stepByStepObjects.Length);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			pickupController.OnPickUpCollected -= HandlePickUpCollected;
		}

		private void SetupPickUpRandom()
		{
			System.Random random = new System.Random();
			IOrderedEnumerable<EpiPickup> source = from p in pickupController.GetComponentsInChildren<EpiPickup>()
				orderby random.Next()
				select p;
			pickupController.stepByStepObjects = source.Select((EpiPickup p) => p.gameObject).ToArray();
			pickupController.activateStepByStep = true;
			pickupController.firstObjects = 2;
		}

		private void HandlePickUpCollected()
		{
			if (pickupController.AllCollected)
			{
				HandleLevelWon();
			}
			string text = TimeSpan.FromSeconds(base.CurrentTime).ToString("mm\\:ss");
			MissionUpdate(pickupController.Collected, pickupController.stepByStepObjects.Length, text);
		}
	}
	public class ScorePointMode : GameMode
	{
		[SerializeField]
		private float maxPoints = 100f;

		protected override string missionFormat => "Defeat Enemies: {0} / {1} points earned.\nTime: {2}";

		public override WinCondition Mode => WinCondition.ScorePoints;

		protected override void OnEnable()
		{
			base.OnEnable();
			MissionUpdate(base.CurrentPoints, maxPoints);
		}

		protected override void HandleEnemyDestroyed(EnemyMovement enemy)
		{
			base.HandleEnemyDestroyed(enemy);
			if (base.CurrentPoints >= maxPoints)
			{
				HandleLevelWon();
			}
			string text = TimeSpan.FromSeconds(base.CurrentTime).ToString("mm\\:ss");
			MissionUpdate(base.CurrentPoints, maxPoints, text);
		}
	}
	public class SpecialTargetMode : GameMode
	{
		[SerializeField]
		private EnemyMovement[] targetEnemies;

		protected override string missionFormat => "Kill {0} from {1} special aliens.\nTime: {2}";

		public override WinCondition Mode => WinCondition.SpecialTargets;

		protected override void OnEnable()
		{
			base.OnEnable();
			EnemyMovement[] array = targetEnemies;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnEnemyDestroyed += HandleTargetDestroyed;
			}
			MissionUpdate(targetEnemies.Length, targetEnemies.Length);
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			EnemyMovement[] array = targetEnemies;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnEnemyDestroyed -= HandleTargetDestroyed;
			}
		}

		private void HandleTargetDestroyed(EnemyMovement enemy)
		{
			int num = targetEnemies.Where((EnemyMovement e) => e != null).Count();
			if (num == 0)
			{
				HandleLevelWon();
			}
			string text = TimeSpan.FromSeconds(base.CurrentTime).ToString("mm\\:ss");
			MissionUpdate(num, targetEnemies.Length, text);
		}
	}
	public class SurvivalMode : GameMode
	{
		[SerializeField]
		private float survivalTime = 300f;

		protected override string missionFormat => "Survive for {0} minutes. Points: {1}";

		public override WinCondition Mode => WinCondition.Survival;

		protected override void Update()
		{
			base.Update();
			if (base.CurrentTime > survivalTime)
			{
				HandleLevelWon();
			}
			string text = TimeSpan.FromSeconds(survivalTime - base.CurrentTime).ToString("mm\\:ss");
			MissionUpdate(text, base.CurrentPoints);
		}
	}
	public class AeroMenuController : WTFGenericSingleton<AeroMenuController>
	{
		public enum View
		{
			Main,
			Level,
			Mission,
			Option,
			Credits,
			Pause,
			GameOver,
			None
		}

		[Serializable]
		private class LevelInfo
		{
			public string name;

			public Sprite preview;
		}

		[SerializeField]
		private MenuCameraController cameraController;

		[SerializeField]
		private ClickableMeshController clickableMeshController;

		[Space]
		[SerializeField]
		private GameObject mainMenu;

		[SerializeField]
		private GameObject levelMenu;

		[SerializeField]
		private GameObject optionMenu;

		[SerializeField]
		private GameObject credits;

		[SerializeField]
		private GameObject pauseMenu;

		[SerializeField]
		private GameObject loadingScreen;

		[SerializeField]
		private GameOverScreen gameOverScreen;

		[Header("Level")]
		[SerializeField]
		private RectTransform levelGroup;

		[SerializeField]
		private RectTransform modeGroup;

		[SerializeField]
		private Text levelNameText;

		[SerializeField]
		private Image levelPreview;

		[SerializeField]
		private Text highScoreText;

		[SerializeField]
		private Text modesLeftText;

		[SerializeField]
		private Text modeInfoText;

		[SerializeField]
		private string[] modeInfos;

		[SerializeField]
		private LevelInfo[] levelInfos;

		[SerializeField]
		private Button startButton;

		[SerializeField]
		private Button portalModeButton;

		[SerializeField]
		private int[] portalScenes;

		[Header("In Game")]
		[SerializeField]
		private Text loadingInfoText;

		[SerializeField]
		private Button continueButton;

		[SerializeField]
		private Button retryButton;

		[Header("Options")]
		[SerializeField]
		private AudioMixer mixer;

		[SerializeField]
		private Slider volumeSlider;

		[SerializeField]
		private Slider musicSlider;

		[SerializeField]
		private Slider sfxSlider;

		[Space]
		[SerializeField]
		private Slider mouseSens;

		[SerializeField]
		private Toggle cameraInvert;

		[Space]
		[SerializeField]
		private Dropdown resolution;

		[SerializeField]
		private Dropdown quality;

		[SerializeField]
		[ReadOnly]
		private View currentView;

		private Button[] modeButtons;

		private int selectedLevel;

		private int selectedMode;

		private const string volumePrefs = "VOLUME";

		private const string musicPrefs = "MUSIC";

		private const string sfxPrefs = "SFX";

		private const string mousePrefs = "MOUSE";

		private const string invertPrefs = "INVERT";

		private const string resolutionPrefs = "RESOLUTION";

		private const string qualityPrefs = "QUALITY";

		protected const string lvlPref = "Level";

		protected const string modePref = "Mode";

		protected const string scorePref = "Score";

		private const string modesLeftFormat = "Complete {0} Missions to unlock next Level!";

		private const float volumeMultiplier = 20f;

		public View CurrentView => currentView;

		protected override void Awake()
		{
			base.Awake();
			SceneManager.sceneLoaded += OnSceneLoaded;
			modeButtons = modeGroup.GetComponentsInChildren<Button>(includeInactive: true);
			for (int i = 0; i < modeButtons.Length; i++)
			{
				int idx = i;
				modeButtons[i].onClick.AddListener(delegate
				{
					LoadModes(idx);
				});
			}
		}

		private void Update()
		{
			if (Input.GetButtonDown("Cancel"))
			{
				if (currentView == View.Mission)
				{
					OpenLevelMenu();
					modeGroup.gameObject.SetActive(value: false);
				}
				else if (currentView == View.Pause)
				{
					SetPause(pause: false);
				}
				else if (SceneManager.GetActiveScene().buildIndex == 1)
				{
					OpenMainMenu();
				}
				else
				{
					SetPause(pause: true);
				}
			}
		}

		private void OnDestroy()
		{
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}

		public void OpenMainMenu()
		{
			SetView(View.Main);
			cameraController.ShowMainLater();
			clickableMeshController.Close();
			EventSystem.current.SetSelectedGameObject(null);
			EventSystem.current.SetSelectedGameObject(EventSystem.current.firstSelectedGameObject);
		}

		public void OpenLevelMenu()
		{
			SetView(View.Level);
			cameraController.ShowLevel();
			clickableMeshController.Open(selectedLevel);
			modeGroup.gameObject.SetActive(value: false);
			levelGroup.gameObject.SetActive(value: false);
			modeInfoText.transform.parent.gameObject.SetActive(value: false);
		}

		public void OpenOptionMenu()
		{
			SetView(View.Option);
			LoadOptions();
			EventSystem.current.SetSelectedGameObject(null);
			EventSystem.current.SetSelectedGameObject(cameraInvert.gameObject);
		}

		public void OpenGameOverMenu(bool won)
		{
			SetView(View.GameOver);
			gameOverScreen.LevelWon(won);
			EventSystem.current.SetSelectedGameObject(null);
			EventSystem.current.SetSelectedGameObject(retryButton.gameObject);
			PlayerHUD playerHUD = UnityEngine.Object.FindObjectOfType<PlayerHUD>(includeInactive: true);
			if ((bool)playerHUD)
			{
				playerHUD.gameObject.SetActive(value: false);
			}
			PauseController pauseController = UnityEngine.Object.FindObjectOfType<PauseController>();
			if (pauseController != null)
			{
				pauseController.Pause_External();
			}
		}

		public void Retry()
		{
			SetView(View.None);
			SceneManager.LoadScene(SceneManager.GetActiveScene().name);
		}

		public void ShowCredits()
		{
			SetView(View.Credits);
		}

		private void SetView(View view)
		{
			mainMenu.SetActive(view == View.Main);
			levelMenu.SetActive(view == View.Level || view == View.Mission);
			optionMenu.SetActive(view == View.Option);
			credits.SetActive(view == View.Credits);
			pauseMenu.SetActive(view == View.Pause);
			gameOverScreen.gameObject.SetActive(view == View.GameOver);
			currentView = view;
		}

		private void ResetMenu()
		{
			selectedLevel = 0;
			selectedMode = 0;
			startButton.gameObject.SetActive(value: false);
			cameraController = UnityEngine.Object.FindObjectOfType<MenuCameraController>(includeInactive: true);
			clickableMeshController = UnityEngine.Object.FindObjectOfType<ClickableMeshController>(includeInactive: true);
			StartCoroutine(ShowMenuDelayed());
		}

		private IEnumerator ShowMenuDelayed()
		{
			yield return new WaitForSeconds(0.5f);
			if (currentView == View.Level)
			{
				OpenLevelMenu();
			}
			else if (currentView == View.Main)
			{
				OpenMainMenu();
			}
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			Time.timeScale = 1f;
			loadingScreen.SetActive(value: false);
			loadingInfoText.text = string.Empty;
			if (scene.buildIndex == 0)
			{
				ResetMenu();
			}
		}

		public void LoadMainMenu(int viewAfterLoad)
		{
			PlayerHUD playerHUD = UnityEngine.Object.FindObjectOfType<PlayerHUD>(includeInactive: true);
			if ((bool)playerHUD)
			{
				playerHUD.gameObject.SetActive(value: false);
			}
			SetView(View.None);
			currentView = (View)viewAfterLoad;
			LoadLevel(-1);
		}

		private void LoadLevel(int i)
		{
			loadingScreen.SetActive(value: true);
			Time.timeScale = 0f;
			StartCoroutine(LoadLevelDelayed(i));
		}

		public IEnumerator LoadLevelDelayed(int i)
		{
			yield return new WaitForSecondsRealtime(1f);
			SceneManager.LoadSceneAsync(i + 2, LoadSceneMode.Single);
		}

		public void SetPause(bool pause)
		{
			SetView(pause ? View.Pause : View.None);
			PlayerHUD playerHUD = UnityEngine.Object.FindObjectOfType<PlayerHUD>(includeInactive: true);
			if ((bool)playerHUD)
			{
				playerHUD.gameObject.SetActive(!pause);
			}
			PauseController pauseController = UnityEngine.Object.FindObjectOfType<PauseController>();
			if (pauseController != null)
			{
				if (pause)
				{
					pauseController.Pause_External();
				}
				else
				{
					pauseController.UnPause_External();
				}
			}
			if (pause)
			{
				EventSystem.current.SetSelectedGameObject(null);
				EventSystem.current.SetSelectedGameObject(continueButton.gameObject);
			}
		}

		public void Quit()
		{
			Application.Quit();
		}

		public void StartLevel()
		{
			LoadLevel(selectedLevel);
			GameModeSelector.selectedMode = (GameMode.WinCondition)selectedMode;
			SetView(View.None);
		}

		public void SelectLevel(int idx)
		{
			selectedLevel = idx;
			modeGroup.gameObject.SetActive(value: true);
			levelGroup.gameObject.SetActive(value: true);
			levelNameText.text = levelInfos[idx].name;
			levelPreview.sprite = levelInfos[idx].preview;
			portalModeButton.gameObject.SetActive(portalScenes.Contains(idx));
			EventSystem.current.SetSelectedGameObject(null);
			EventSystem.current.SetSelectedGameObject(modeButtons[0].gameObject);
			currentView = View.Mission;
			clickableMeshController.Close();
			int num = (from s in Convert.ToString(OVPlayerPrefs.GetInt("Level" + idx + "Mode"), 2).PadLeft(10, '0')
				select s.Equals('1')).ToArray().Count((bool m) => m);
			if (num > 3 && OVPlayerPrefs.GetInt("Level" + (idx + 1)) == 0)
			{
				OVPlayerPrefs.SetInt("Level" + (idx + 1), 1);
			}
			modesLeftText.text = $"Complete {Mathf.Max(0, 3 - num)} Missions to unlock next Level!";
		}

		private void LoadModes(int idx)
		{
			selectedMode = idx;
			GameMode.WinCondition winCondition = (GameMode.WinCondition)selectedMode;
			string text = winCondition.ToString();
			string iD = "Level" + selectedLevel + text + "Score";
			if (selectedMode == 3)
			{
				float @float = OVPlayerPrefs.GetFloat(iD);
				highScoreText.text = "Best Time: " + @float;
			}
			else
			{
				int @int = OVPlayerPrefs.GetInt(iD);
				highScoreText.text = "Highest Score: " + @int;
			}
			startButton.gameObject.SetActive(value: true);
			EventSystem.current.SetSelectedGameObject(null);
			EventSystem.current.SetSelectedGameObject(startButton.gameObject);
			modeInfoText.transform.parent.gameObject.SetActive(value: true);
			modeInfoText.text = modeInfos[idx];
			loadingInfoText.text = modeInfos[idx];
		}

		public void SetInvert(bool value)
		{
			OVPlayerPrefs.SetBool("INVERT", value);
		}

		public void SetMouseSens(float value)
		{
			OVPlayerPrefs.SetFloat("MOUSE", value);
		}

		public void SetVolume(float value)
		{
			OVPlayerPrefs.SetFloat("VOLUME", value);
			mixer.SetFloat("Volume", Mathf.Log10(value) * 20f);
		}

		public void SetMusic(float value)
		{
			OVPlayerPrefs.SetFloat("MUSIC", value);
			mixer.SetFloat("Music", Mathf.Log10(value) * 20f);
		}

		public void SetSfx(float value)
		{
			OVPlayerPrefs.SetFloat("SFX", value);
			mixer.SetFloat("Sfx", Mathf.Log10(value) * 20f);
		}

		public void ChangeResolution(int i)
		{
			Screen.SetResolution(Screen.resolutions[i].width, Screen.resolutions[i].height, fullscreen: true);
			OVPlayerPrefs.SetInt("RESOLUTION", i);
			OVPlayerPrefs.Save();
		}

		public void ChangeQuality(int i)
		{
			QualitySettings.SetQualityLevel(i);
			OVPlayerPrefs.SetInt("QUALITY", i);
			OVPlayerPrefs.Save();
		}

		private void LoadOptions()
		{
			volumeSlider.value = OVPlayerPrefs.GetFloat("VOLUME");
			musicSlider.value = OVPlayerPrefs.GetFloat("MUSIC");
			sfxSlider.value = OVPlayerPrefs.GetFloat("SFX");
			mouseSens.value = OVPlayerPrefs.GetFloat("MOUSE");
			cameraInvert.isOn = OVPlayerPrefs.GetBool("INVERT");
			GetResolutions();
			GetQualities();
			resolution.value = OVPlayerPrefs.GetInt("RESOLUTION");
			quality.value = OVPlayerPrefs.GetInt("QUALITY");
		}

		private void GetResolutions()
		{
			this.resolution.options.Clear();
			Resolution[] resolutions = Screen.resolutions;
			for (int i = 0; i < resolutions.Length; i++)
			{
				Resolution resolution = resolutions[i];
				this.resolution.options.Add(new Dropdown.OptionData(resolution.ToString()));
			}
		}

		private void GetQualities()
		{
			quality.options.Clear();
			string[] names = QualitySettings.names;
			foreach (string text in names)
			{
				quality.options.Add(new Dropdown.OptionData(text));
			}
		}
	}
	public class AeroMenuSfx : MonoBehaviour
	{
		[SerializeField]
		private AudioClip sfxOnClick;

		[SerializeField]
		private AudioClip sfxOnCancel;

		[SerializeField]
		private AudioClip sfxOnNavigation;

		[SerializeField]
		private Button[] buttons;

		[SerializeField]
		private Button[] backButtons;

		private AudioSource source;

		private float sfxTime;

		private void Awake()
		{
			source = GetComponent<AudioSource>();
			Button[] array = buttons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].onClick.AddListener(PlaySubmitSfx);
			}
			array = backButtons;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].onClick.AddListener(PlayCancelSfx);
			}
		}

		private void PlaySubmitSfx()
		{
			source.clip = sfxOnClick;
			source.Play();
		}

		private void PlayCancelSfx()
		{
			source.clip = sfxOnCancel;
			source.Play();
		}

		private void Update()
		{
			if (WTFGenericSingleton<AeroMenuController>.Instance.CurrentView != AeroMenuController.View.None)
			{
				sfxTime -= Time.deltaTime;
				if ((Mathf.Abs(Input.GetAxis("Horizontal")) > 0.3f || Math.Abs(Input.GetAxis("Vertical")) > 0.3f) && sfxTime <= 0f)
				{
					source.clip = sfxOnNavigation;
					source.Play();
					sfxTime = 0.5f;
				}
			}
		}
	}
	public class ClickableMesh : Selectable
	{
		[SerializeField]
		private HighlightEffect effect;

		public int index;

		private bool _selected;

		public bool Selected
		{
			get
			{
				return _selected;
			}
			set
			{
				effect.glow = (value ? 4 : 0);
				_selected = value;
			}
		}

		public bool Locked
		{
			get
			{
				return !base.interactable;
			}
			set
			{
				effect.overlay = (value ? 1 : 0);
				base.interactable = !value;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			Locked = false;
		}

		public void Click()
		{
			WTFGenericSingleton<AeroMenuController>.Instance.SelectLevel(index);
		}
	}
	public class ClickableMeshController : MonoBehaviour
	{
		[SerializeField]
		private ClickableMesh[] clickableMeshes;

		[SerializeField]
		private bool debugActivateAll;

		private Vector3 lastMousePosition;

		private bool navigationAxisPressed;

		private int currentClickableIdx;

		private ClickableMesh currentMouseSelected;

		private const float maxDistance = 300f;

		protected const string lvlPref = "Level";

		protected const string modePref = "Mode";

		protected const string scorePref = "Score";

		private void Awake()
		{
			for (int i = 0; i < clickableMeshes.Length; i++)
			{
				clickableMeshes[i].index = i;
			}
		}

		private void Update()
		{
			if (Input.mousePosition != lastMousePosition)
			{
				UpdateMouseInput();
				lastMousePosition = Input.mousePosition;
			}
			if ((bool)currentMouseSelected && currentMouseSelected.interactable)
			{
				SelectClickable(currentMouseSelected);
				if (Input.GetMouseButtonDown(0))
				{
					currentMouseSelected.Click();
				}
			}
			if (!navigationAxisPressed && (Input.GetAxis("Horizontal") > 0.3f || Input.GetAxis("Vertical") > 0.3f))
			{
				int num = Mathf.Clamp(currentClickableIdx + 1, 0, clickableMeshes.Length - 1);
				ClickableMesh clickableMesh = clickableMeshes[num];
				if (clickableMesh.Locked)
				{
					return;
				}
				SelectClickable(clickableMesh);
				navigationAxisPressed = true;
			}
			else if (!navigationAxisPressed && (Input.GetAxis("Horizontal") < -0.3f || Input.GetAxis("Vertical") < -0.3f))
			{
				int num2 = Mathf.Clamp(currentClickableIdx - 1, 0, clickableMeshes.Length - 1);
				SelectClickable(clickableMeshes[num2]);
				navigationAxisPressed = true;
			}
			else if (Input.GetAxis("Horizontal") < 0.3f && Input.GetAxis("Vertical") < 0.3f && Input.GetAxis("Horizontal") > -0.3f && Input.GetAxis("Vertical") > -0.3f)
			{
				navigationAxisPressed = false;
			}
			if (Input.GetButtonDown("Submit"))
			{
				clickableMeshes[currentClickableIdx].Click();
			}
		}

		public void Open(int selected)
		{
			base.enabled = true;
			ClickableMesh clickableMesh = clickableMeshes[selected];
			SelectClickable(clickableMesh);
			EventSystem.current.SetSelectedGameObject(clickableMesh.gameObject);
			if (!debugActivateAll)
			{
				for (int i = 1; i < clickableMeshes.Length; i++)
				{
					clickableMeshes[i].Locked = OVPlayerPrefs.GetInt("Level" + i) != 1;
				}
			}
		}

		public void Close()
		{
			SelectClickable(null);
			base.enabled = false;
		}

		private void UpdateMouseInput()
		{
			if (Physics.Raycast(MenuCameraController.currentCamera.ScreenPointToRay(Input.mousePosition), out var hitInfo, 300f) && hitInfo.collider.tag == "Clickable")
			{
				currentMouseSelected = hitInfo.collider.GetComponent<ClickableMesh>();
			}
		}

		private void SelectClickable(ClickableMesh clickable)
		{
			if ((bool)clickable)
			{
				EventSystem.current.SetSelectedGameObject(clickable.gameObject);
			}
			currentClickableIdx = Array.IndexOf(clickableMeshes, clickable);
			ClickableMesh[] array = clickableMeshes;
			foreach (ClickableMesh obj in array)
			{
				obj.Selected = obj == clickable;
			}
		}
	}
	public class GameOverScreen : MonoBehaviour
	{
		[SerializeField]
		private GameObject wonHeader;

		[SerializeField]
		private GameObject lostHeader;

		[SerializeField]
		private Text scoreText;

		public void LevelWon(bool won)
		{
			wonHeader.SetActive(won);
			lostHeader.SetActive(!won);
			scoreText.enabled = won;
			if (won)
			{
				GameMode currentGameMode = GameMode.CurrentGameMode;
				if (currentGameMode.Mode == GameMode.WinCondition.ScorePoints)
				{
					scoreText.text = "Time: " + currentGameMode.CurrentTime;
				}
				else
				{
					scoreText.text = "Points: " + currentGameMode.CurrentPoints;
				}
			}
		}
	}
	public class MenuCameraController : MonoBehaviour
	{
		public static Camera currentCamera;

		[SerializeField]
		private Camera mainCamera;

		[SerializeField]
		private Camera levelCamera;

		[SerializeField]
		private float delay = 1f;

		private Animator levelCameraAnimator;

		private Quaternion defaultMainRotation;

		private const string levelCameraTrigger = "Show";

		private Coroutine waitRoutine;

		private void Awake()
		{
			currentCamera = Camera.main;
			levelCameraAnimator = levelCamera.GetComponent<Animator>();
			defaultMainRotation = mainCamera.transform.rotation;
		}

		public void ShowMain()
		{
			mainCamera.enabled = true;
			levelCamera.enabled = false;
			currentCamera = mainCamera;
		}

		public void ShowMainLater()
		{
			levelCameraAnimator.SetBool("Show", value: false);
			if (waitRoutine == null)
			{
				waitRoutine = StartCoroutine(WaitToShowMain());
			}
		}

		public IEnumerator WaitToShowMain()
		{
			yield return new WaitForSeconds(delay);
			ShowMain();
		}

		public void ShowLevel()
		{
			if (waitRoutine != null)
			{
				StopCoroutine(waitRoutine);
			}
			waitRoutine = null;
			levelCameraAnimator.SetBool("Show", value: true);
			mainCamera.transform.rotation = defaultMainRotation;
			mainCamera.enabled = false;
			levelCamera.enabled = true;
			currentCamera = levelCamera;
		}
	}
	public abstract class APowerUpEffect : MonoBehaviour
	{
		public enum Type
		{
			NONE,
			Rocket,
			Explosion
		}

		public int count = 1;

		[SerializeField]
		protected AudioSource sfx;

		public abstract Type PowerUpType { get; }

		public abstract void Initialize(PlayerShooter playerShooter, Hitbox[] hitboxes);
	}
	public class Bullet : MonoBehaviour
	{
		public enum Effect
		{
			None,
			Slow,
			Speed,
			Invert
		}

		[Header("Movement")]
		public float speed;

		[Header("Damage")]
		public bool damageEnemies;

		public bool damagePlayer;

		public float dmg = 1f;

		public float despawn = 2f;

		[Header("Side Effects")]
		public Effect effectOnPlayer;

		private float effectTime = 1f;

		[Header("Effects")]
		public GameObject hitEffect;

		public GameObject missEffect;

		public AudioSource sfx;

		private Rigidbody rb;

		private Hitbox[] hitboxesToIgnore;

		private const float effectLifeTime = 3f;

		public void Initialize(Hitbox[] hitboxes)
		{
			hitboxesToIgnore = hitboxes;
		}

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
			rb.velocity = base.transform.forward * speed;
			UnityEngine.Object.Destroy(base.gameObject, despawn);
		}

		private void OnCollisionEnter(Collision collision)
		{
			HandleCollisionAndTrigger(collision.gameObject);
		}

		private void OnTriggerEnter(Collider other)
		{
			HandleCollisionAndTrigger(other.gameObject);
		}

		private void HandleCollisionAndTrigger(GameObject hittedObject)
		{
			Hitbox component = hittedObject.GetComponent<Hitbox>();
			if (component == null || hitboxesToIgnore.Contains(component))
			{
				return;
			}
			if ((damageEnemies && hittedObject.tag == "Enemy") || (damagePlayer && hittedObject.tag == "Player"))
			{
				if (component != null)
				{
					component.Hit(dmg, effectOnPlayer, effectTime);
					CreateEffectAndDestroy(hitEffect);
				}
			}
			else
			{
				CreateEffectAndDestroy(missEffect);
			}
			if (sfx != null && sfx.enabled && sfx.clip != null)
			{
				sfx.Play();
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void CreateEffectAndDestroy(GameObject effectPrefab)
		{
			if (!(effectPrefab == null))
			{
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(effectPrefab, base.transform.position, base.transform.rotation), 3f);
			}
		}
	}
	[RequireComponent(typeof(SphereCollider))]
	public class ExplosionPowerUp : APowerUpEffect
	{
		[SerializeField]
		private float duration = 3f;

		[SerializeField]
		private float maxRadius = 1500f;

		[SerializeField]
		private float damageAmount = 10f;

		[SerializeField]
		private bool followPlayer;

		[SerializeField]
		private GameObject visuals;

		[Header("Effect")]
		[SerializeField]
		private Bullet.Effect effect;

		[SerializeField]
		private float effectDuration;

		private SphereCollider sphereCollider;

		private Transform playerTransform;

		[SerializeField]
		private bool explosionStarted;

		private float initialRadius;

		private Vector3 initialScale;

		private float time;

		public override Type PowerUpType => Type.Explosion;

		private void Awake()
		{
			sphereCollider = GetComponent<SphereCollider>();
			initialRadius = sphereCollider.radius;
			initialScale = visuals.transform.localScale;
		}

		private void Update()
		{
			if (followPlayer)
			{
				base.transform.position = playerTransform.position;
			}
			if (explosionStarted)
			{
				time += Time.deltaTime;
				sphereCollider.radius = Mathf.Lerp(initialRadius, maxRadius, time / duration);
				visuals.transform.localScale = Vector3.Lerp(initialScale, initialScale * maxRadius, time / duration);
				if (time > duration)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Enemy")
			{
				Hitbox component = other.GetComponent<Hitbox>();
				if ((bool)component)
				{
					component.Hit(damageAmount, effect, effectDuration);
				}
			}
		}

		public override void Initialize(PlayerShooter playerShooter, Hitbox[] hitboxes)
		{
			explosionStarted = true;
			playerTransform = playerShooter.transform;
			sfx.Play();
		}
	}
	public class Health : MonoBehaviour
	{
		[SerializeField]
		private GameObject deathEffect;

		[SerializeField]
		private int _lifes = 1;

		[SerializeField]
		private float maxHealth;

		[SerializeField]
		private AudioSource damageSfx;

		[SerializeField]
		private AudioSource deathSfx;

		private EnemyMovement enemyMovement;

		private AeroplaneController aeroplaneController;

		private ObjectResetter reseter;

		private const float deathDuration = 0f;

		[SerializeField]
		[ReadOnly]
		private float _currentHealth;

		public float CurrentHealth
		{
			get
			{
				return _currentHealth;
			}
			private set
			{
				if (value != _currentHealth)
				{
					this.OnHealthChange?.Invoke(value);
					_currentHealth = value;
				}
			}
		}

		public int Lifes
		{
			get
			{
				return _lifes;
			}
			private set
			{
				if (value != _lifes)
				{
					this.OnLifeChange?.Invoke(value);
					_lifes = value;
				}
			}
		}

		public float MaxHealth => maxHealth;

		public event Action<float> OnHealthChange;

		public event Action<int> OnLifeChange;

		private void Awake()
		{
			enemyMovement = GetComponent<EnemyMovement>();
			aeroplaneController = GetComponent<AeroplaneController>();
			reseter = GetComponent<ObjectResetter>();
			CurrentHealth = maxHealth;
		}

		public void Initialize(float maxHealth)
		{
			this.maxHealth = maxHealth;
			CurrentHealth = maxHealth;
		}

		public void ReceiveDamage(float dmg, Bullet.Effect effect, float effectTime)
		{
			CurrentHealth -= dmg;
			if (damageSfx != null && Vector3.Distance(Camera.main.transform.position, base.transform.position) < damageSfx.maxDistance)
			{
				damageSfx.Play();
			}
			if (CurrentHealth <= 0f)
			{
				if (deathEffect != null)
				{
					UnityEngine.Object.Instantiate(deathEffect, base.transform.position, base.transform.rotation, null);
				}
				if ((bool)enemyMovement)
				{
					enemyMovement.HandleDeath();
				}
				Lifes--;
				if (Lifes <= 0)
				{
					if (deathSfx != null && Vector3.Distance(Camera.main.transform.position, base.transform.position) < deathSfx.maxDistance)
					{
						deathSfx.Play();
					}
					if ((bool)aeroplaneController)
					{
						GameMode.CurrentGameMode.SetLevelFinished(won: false);
					}
					else
					{
						UnityEngine.Object.Destroy(base.gameObject, 0f);
					}
					return;
				}
				CurrentHealth = maxHealth;
				if ((bool)reseter)
				{
					reseter.DelayedReset(0.5f);
				}
			}
			if ((bool)enemyMovement)
			{
				enemyMovement.HandleDamage();
			}
			else if ((bool)aeroplaneController)
			{
				switch (effect)
				{
				case Bullet.Effect.Slow:
				case Bullet.Effect.Speed:
					aeroplaneController.ModifySpeed(effect, effectTime);
					break;
				case Bullet.Effect.Invert:
					aeroplaneController.InvertControls(effectTime);
					break;
				}
			}
		}
	}
	public class Hitbox : MonoBehaviour
	{
		public Health health;

		public void Hit(float dmg, Bullet.Effect effect, float effectTime)
		{
			health.ReceiveDamage(dmg, effect, effectTime);
		}
	}
	public class PlayerHUD : MonoBehaviour
	{
		[SerializeField]
		private Text healthText;

		[SerializeField]
		private Image healthBar;

		[SerializeField]
		private Image[] lifeImages;

		[SerializeField]
		private Sprite[] powerUpImages;

		[SerializeField]
		private Image[] activePowerUpImages;

		[SerializeField]
		private Text powerUpCountText;

		[Space]
		[SerializeField]
		private Text missionText;

		private Health playerHealth;

		private PlayerShooter shooter;

		private GameMode currentGameMode;

		private const string healthTextFormat = "HP\n{0}/{1}";

		private void Awake()
		{
			playerHealth = base.transform.parent.GetComponentInChildren<Health>();
			shooter = base.transform.parent.GetComponentInChildren<PlayerShooter>();
		}

		private void OnEnable()
		{
			PowerUp.OnPowerUpCollected += HandlePowerUpCollected;
			GameMode.OnCurrentModeAssigned += HandleCurrentGameMode;
			GameMode.OnMissionUpdated += HandleMissionUpdated;
			shooter.OnPowerCountChange += HandlePowerUpCountChange;
			playerHealth.OnLifeChange += HandleLifeChange;
			playerHealth.OnHealthChange += HandleHealthChange;
			HandleLifeChange(playerHealth.Lifes);
			HandleHealthChange(playerHealth.CurrentHealth);
		}

		private void OnDisable()
		{
			PowerUp.OnPowerUpCollected -= HandlePowerUpCollected;
			GameMode.OnCurrentModeAssigned -= HandleCurrentGameMode;
			GameMode.OnMissionUpdated -= HandleMissionUpdated;
			shooter.OnPowerCountChange -= HandlePowerUpCountChange;
			playerHealth.OnLifeChange -= HandleLifeChange;
			playerHealth.OnHealthChange -= HandleHealthChange;
		}

		private void HandlePowerUpCollected(APowerUpEffect powerUp)
		{
			int powerUpType = (int)powerUp.PowerUpType;
			for (int i = 0; i < activePowerUpImages.Length; i++)
			{
				Image image = activePowerUpImages[i];
				if (i < powerUp.count)
				{
					image.enabled = true;
					image.sprite = powerUpImages[powerUpType];
				}
				else
				{
					image.enabled = false;
				}
			}
			powerUpCountText.text = powerUp.count.ToString();
		}

		private void HandlePowerUpCountChange(int count)
		{
			powerUpCountText.text = count.ToString();
			for (int i = 1; i < activePowerUpImages.Length; i++)
			{
				Image image = activePowerUpImages[i];
				if (i >= count)
				{
					image.enabled = false;
				}
			}
			if (count == 0)
			{
				activePowerUpImages[0].sprite = powerUpImages[0];
			}
		}

		private void HandleCurrentGameMode(GameMode gameMode)
		{
			currentGameMode = gameMode;
		}

		private void HandleMissionUpdated(string missionString)
		{
			missionText.text = $"{currentGameMode.Mode.ToString().ToUpper()}\n\n{missionString}";
		}

		private void HandleLifeChange(int life)
		{
			for (int i = 0; i < lifeImages.Length; i++)
			{
				lifeImages[i].gameObject.SetActive(i < life);
			}
		}

		private void HandleHealthChange(float health)
		{
			healthText.text = $"HP\n{health}/{playerHealth.MaxHealth}";
			float fillAmount = health / playerHealth.MaxHealth;
			healthBar.fillAmount = fillAmount;
		}
	}
	public class PlayerShooter : MonoBehaviour
	{
		[Header("Aiming")]
		public RectTransform crosshair;

		[Header("Shooting")]
		public Bullet bullet;

		public Bullet altBullet;

		public Transform[] spawnPoints;

		public Transform powerUpSpawnPoint;

		public float cooldown;

		public float altCooldown;

		public AudioSource shootSfx;

		public AudioSource altShootSfx;

		private Hitbox[] playerHitboxes;

		private bool shootAxisReady = true;

		private bool altShootAxisReady = true;

		private APowerUpEffect powerUpPrefab;

		private int powerUpCount;

		private bool powerUpReady;

		public event Action<int> OnPowerCountChange;

		private void Awake()
		{
			playerHitboxes = GetComponentsInChildren<Hitbox>(includeInactive: true);
			PowerUp.OnPowerUpCollected += HandlePowerUpCollected;
		}

		private void Update()
		{
			Vector3 vector = Camera.main.WorldToScreenPoint(base.transform.position + base.transform.forward * 100f);
			crosshair.anchoredPosition = vector;
			if (Input.GetAxis("Shoot") > 0.1f)
			{
				if (!shootSfx.isPlaying)
				{
					shootSfx.Play();
				}
				if (shootAxisReady)
				{
					ShootBullet(bullet, ref shootAxisReady, delegate
					{
						Invoke("ResetCooldown", cooldown);
					});
				}
			}
			else if (shootSfx.isPlaying)
			{
				shootSfx.Stop();
			}
			if (Input.GetAxis("AltShoot") > 0.1f)
			{
				if (!altShootSfx.isPlaying)
				{
					altShootSfx.Play();
				}
				if (altShootAxisReady)
				{
					ShootBullet(altBullet, ref altShootAxisReady, delegate
					{
						Invoke("AltResetCooldown", altCooldown);
					});
				}
			}
			else if (altShootSfx.isPlaying)
			{
				altShootSfx.Stop();
			}
			if (powerUpReady && Input.GetButton("PowerUp") && powerUpPrefab != null)
			{
				UsePowerUp();
			}
		}

		private void ShootBullet(Bullet prefab, ref bool shootReady, Action onShoot)
		{
			Transform[] array = spawnPoints;
			foreach (Transform transform in array)
			{
				UnityEngine.Object.Instantiate(prefab, transform.position, transform.rotation, null).Initialize(playerHitboxes);
			}
			shootReady = false;
			onShoot();
		}

		private void UsePowerUp()
		{
			UnityEngine.Object.Instantiate(powerUpPrefab, powerUpSpawnPoint.position, powerUpSpawnPoint.rotation).Initialize(this, playerHitboxes);
			powerUpCount--;
			powerUpReady = false;
			this.OnPowerCountChange?.Invoke(powerUpCount);
			if (powerUpCount == 0)
			{
				powerUpPrefab = null;
			}
			Invoke("ResetPowerUp", 1f);
		}

		private void ResetPowerUp()
		{
			powerUpReady = true;
		}

		private void ResetCooldown()
		{
			shootAxisReady = true;
		}

		private void AltResetCooldown()
		{
			altShootAxisReady = true;
		}

		private void HandlePowerUpCollected(APowerUpEffect powerUp)
		{
			powerUpPrefab = powerUp;
			powerUpCount = powerUp.count;
			powerUpReady = true;
		}
	}
	[RequireComponent(typeof(SphereCollider))]
	public class PowerUp : MonoBehaviour
	{
		[SerializeField]
		private float reappearanceDuration = 10f;

		[SerializeField]
		private GameObject visuals;

		[SerializeField]
		private APowerUpEffect powerUpPrefab;

		private bool collected;

		public static event Action<APowerUpEffect> OnPowerUpCollected;

		private void OnTriggerEnter(Collider other)
		{
			if (!collected && other.gameObject.tag == "Player")
			{
				PowerUp.OnPowerUpCollected?.Invoke(powerUpPrefab);
				collected = true;
				visuals.SetActive(value: false);
				UnityEngine.Debug.LogFormat("{0} Collected!\n", base.name);
				Invoke("Reappear", reappearanceDuration);
			}
		}

		private void Reappear()
		{
			collected = false;
			visuals.SetActive(value: true);
		}
	}
	[RequireComponent(typeof(Bullet))]
	public class RocketPowerUp : APowerUpEffect
	{
		[SerializeField]
		private float castSize = 1500f;

		private Bullet bullet;

		private Rigidbody rBody;

		private Transform target;

		private Vector2 viewportCenter = new Vector2(0.5f, 0.5f);

		public override Type PowerUpType => Type.Rocket;

		private void Awake()
		{
			bullet = GetComponent<Bullet>();
			rBody = GetComponent<Rigidbody>();
		}

		public override void Initialize(PlayerShooter playerShooter, Hitbox[] hitboxes)
		{
			bullet.Initialize(hitboxes);
			Vector3 center = playerShooter.transform.position + playerShooter.transform.forward * castSize / 2f;
			float num = float.PositiveInfinity;
			foreach (RaycastHit item in from hit in Physics.BoxCastAll(center, Vector3.one * castSize * 2f, playerShooter.transform.forward)
				where hit.collider.tag == "Enemy"
				select hit)
			{
				float num2 = Vector2.Distance(Camera.main.WorldToViewportPoint(item.transform.position), viewportCenter);
				if (num2 < num)
				{
					num = num2;
					target = item.collider.transform;
				}
			}
			if (target == null)
			{
				UnityEngine.Debug.Log("No Target found!\n");
			}
			sfx.Play();
		}

		private void Update()
		{
			base.transform.forward = rBody.velocity.normalized;
		}

		private void FixedUpdate()
		{
			if (!(target == null))
			{
				rBody.velocity = (target.position - base.transform.position).normalized * bullet.speed;
			}
		}
	}
	public class Playlist : MonoBehaviour
	{
		[SerializeField]
		private string playlistName;

		private void Start()
		{
			PlaylistController playlistController = UnityEngine.Object.FindObjectOfType<PlaylistController>();
			if ((bool)playlistController)
			{
				playlistController.ChangePlaylist(playlistName);
			}
		}
	}
	public class Deactivator : MonoBehaviour
	{
		private void Awake()
		{
			base.gameObject.SetActive(value: false);
		}
	}
	public class EpiPickup : MonoBehaviour
	{
		public EpiPickupController controller;

		public ParticleSystem particle;

		private bool used;

		public UnityEvent onCollect;

		public void OnTriggerEnter(Collider other)
		{
			if (!used && other.gameObject.tag == "Player")
			{
				if (controller.isActiveAndEnabled)
				{
					controller.PlayStory();
				}
				used = true;
				particle.Stop();
				onCollect.Invoke();
			}
		}
	}
	public class EpiPickupController : MonoBehaviour
	{
		public AudioClip[] audioClips;

		public string[] subTitles;

		public string[] subTitlesZh;

		public string[] subTitlesJa;

		public string[] subTitlesKo;

		public AudioSource audioSource;

		public Text subTitleText;

		public Animator subTitleAnimator;

		[Header("Step by Step Option")]
		public bool activateStepByStep;

		public GameObject[] stepByStepObjects;

		public int firstObjects = 1;

		public int Collected { get; private set; }

		public bool AllCollected => Collected >= stepByStepObjects.Length;

		public event Action OnPickUpCollected;

		public void Start()
		{
			Invoke("LateStart", 0.5f);
		}

		public void LateStart()
		{
			if (activateStepByStep)
			{
				for (int i = 0; i < stepByStepObjects.Length; i++)
				{
					stepByStepObjects[i].SetActive(i < firstObjects);
				}
			}
		}

		public void PlayStory()
		{
			if (Collected < audioClips.Length)
			{
				this.OnPickUpCollected?.Invoke();
				if (OVGenericSingleton<LanguageChanger>.Instance.language == LanguageChanger.Language.en)
				{
					audioSource.clip = audioClips[Collected];
					audioSource.Play();
				}
				if (subTitles.Length != 0)
				{
					subTitleText.text = GetLocalizedText(Collected);
					StartCoroutine(Fade(fadeIn: true, 0f));
					StartCoroutine(Fade(fadeIn: false, audioClips[Collected].length));
				}
				Collected++;
				if (activateStepByStep && stepByStepObjects.Length > Collected)
				{
					stepByStepObjects[Collected].SetActive(value: true);
				}
			}
		}

		private string GetLocalizedText(int idx)
		{
			return OVGenericSingleton<LanguageChanger>.Instance.language switch
			{
				LanguageChanger.Language.en => subTitles[idx], 
				LanguageChanger.Language.zh => subTitlesZh[idx], 
				LanguageChanger.Language.ja => subTitlesJa[idx], 
				LanguageChanger.Language.ko => subTitlesKo[idx], 
				_ => "lang_error", 
			};
		}

		public IEnumerator Fade(bool fadeIn, float delay)
		{
			yield return new WaitForSeconds(delay);
			subTitleAnimator.SetBool("FadeIn", fadeIn);
		}
	}
	public class PlayerTrigger : MonoBehaviour
	{
		[SerializeField]
		private TriggerBehaviour insideTrigger;

		[SerializeField]
		private TriggerBehaviour outsideTrigger;

		private bool insideTriggered;

		private bool outsideTriggered;

		public UnityEvent OnInsideEnter;

		public UnityEvent OnOutsideEnter;

		private void Awake()
		{
			insideTrigger.OnEnter += HandleInsideEntered;
			outsideTrigger.OnEnter += HandleOutsideEntered;
		}

		private void HandleInsideEntered(Collider other)
		{
			if (other.tag == "Player")
			{
				insideTriggered = true;
				if (outsideTriggered)
				{
					outsideTriggered = false;
					OnInsideEnter.Invoke();
				}
			}
		}

		private void HandleOutsideEntered(Collider other)
		{
			if (other.tag == "Player")
			{
				outsideTriggered = true;
				if (insideTriggered)
				{
					insideTriggered = false;
					OnOutsideEnter.Invoke();
				}
			}
		}
	}
	public class TriggerBehaviour : MonoBehaviour
	{
		public event Action<Collider> OnEnter;

		public event Action<Collider> OnExit;

		private void OnTriggerEnter(Collider other)
		{
			this.OnEnter?.Invoke(other);
		}

		private void OnTriggerExit(Collider other)
		{
			this.OnExit?.Invoke(other);
		}
	}
	public class VRBirdController : MonoBehaviour
	{
		public GameObject controllerL;

		public GameObject controllerR;

		public bool useRightController;

		public bool useLeftController;

		[HideInInspector]
		public float yawn;

		[HideInInspector]
		public float pitch;

		private void Start()
		{
		}

		private void Update()
		{
			if (useRightController)
			{
				useLeftController = false;
			}
			Vector3 localEulerAngles = controllerR.transform.localEulerAngles;
			if (localEulerAngles.x < 360f && localEulerAngles.x > 180f)
			{
				float num = localEulerAngles.x - 180f;
				pitch = -1f * (1f - num / 180f);
			}
			if (localEulerAngles.x < 180f && localEulerAngles.x > 0f)
			{
				pitch = localEulerAngles.x / 180f;
			}
			if (localEulerAngles.y < 360f && localEulerAngles.y > 180f)
			{
				float num2 = localEulerAngles.y - 180f;
				yawn = -1f * (1f - num2 / 180f);
			}
			if (localEulerAngles.y < 180f && localEulerAngles.y > 0f)
			{
				yawn = localEulerAngles.y / 180f;
			}
		}
	}
	public class WTFBoundRaycaster : MonoBehaviour
	{
		public GameObject player;

		public float distance;

		private ColorCorrectionCurves transition;

		private int state;

		private void Start()
		{
			transition = GetComponent<ColorCorrectionCurves>();
		}

		private void Update()
		{
			if (state == 0)
			{
				if (transition.saturation >= 1f)
				{
					state = 1;
				}
				return;
			}
			bool flag = false;
			if (Physics.Raycast(player.transform.position, player.transform.forward, out var hitInfo, distance) && hitInfo.transform.gameObject.GetComponent<WTFBoundsActivator>() != null)
			{
				flag = true;
			}
			if (Physics.Raycast(player.transform.position, player.transform.right, out hitInfo, distance) && hitInfo.transform.gameObject.GetComponent<WTFBoundsActivator>() != null)
			{
				flag = true;
			}
			if (Physics.Raycast(player.transform.position, -player.transform.right, out hitInfo, distance) && hitInfo.transform.gameObject.GetComponent<WTFBoundsActivator>() != null)
			{
				flag = true;
			}
			if (Physics.Raycast(player.transform.position, player.transform.up, out hitInfo, distance) && hitInfo.transform.gameObject.GetComponent<WTFBoundsActivator>() != null)
			{
				flag = true;
			}
			if (flag)
			{
				if (transition.saturation > 0f)
				{
					transition.saturation -= Time.deltaTime;
				}
			}
			else if (transition.saturation < 1f)
			{
				transition.saturation += Time.deltaTime;
			}
		}
	}
	public class WTFBoundsActivator : MonoBehaviour
	{
		private AeroplaneController controller;

		private void Start()
		{
			controller = UnityEngine.Object.FindObjectOfType<AeroplaneController>();
		}

		public void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Player")
			{
				controller.TurnAround(turn: true);
			}
		}

		public void OnTriggerExit(Collider other)
		{
			if (other.tag == "Player")
			{
				controller.TurnAround(turn: false);
			}
		}
	}
	public class WTFCloudEffectsActivator : MonoBehaviour
	{
		private ParticleSystem particle;

		private void Start()
		{
			particle = GameObject.Find("CloudParticle").GetComponent<ParticleSystem>();
		}

		public void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Player")
			{
				particle.Play();
			}
		}

		public void OnTriggerExit(Collider other)
		{
			if (other.tag == "Player")
			{
				particle.Stop();
			}
		}
	}
	public class WTFFixedHeightFollow : MonoBehaviour
	{
		public GameObject target;

		public float y;

		private void Update()
		{
			base.transform.position = new Vector3(target.transform.position.x, y, target.transform.position.z);
		}
	}
	public class WTFSceneChangeTimer : MonoBehaviour
	{
		public Animator animator;

		private void Start()
		{
			Invoke("FadeIn", 3f);
			Invoke("FadeOut", 8f);
			Invoke("Load", 14f);
		}

		public void Load()
		{
			WTFGenericSingleton<MenuController>.Instance.LoadLevel(0);
		}

		public void FadeIn()
		{
			animator.SetBool("FadeIn", value: true);
		}

		public void FadeOut()
		{
			animator.SetBool("FadeIn", value: false);
		}
	}
	public class WTFStartAnimator : MonoBehaviour
	{
		public float initialDelay = 10f;

		private UIEventsPublisher publisher;

		public bool testDuration;

		[Header("Start Text")]
		public bool fadeOutTextOnPlay;

		public Animator fadeOutAnimator;

		private void Start()
		{
			publisher = GetComponent<UIEventsPublisher>();
			Invoke("AutoStart", initialDelay);
		}

		private void AutoStart()
		{
			if (fadeOutTextOnPlay)
			{
				fadeOutAnimator.SetBool("FadeIn", value: false);
			}
			publisher.PublishPlay();
		}
	}
	public class WTFTextTrigger : MonoBehaviour
	{
		public bool onlyOnce;

		public CanvasGroup[] canvasGroups;

		public float showTime;

		public UnityEvent startEvent;

		public UnityEvent endEvent;

		private int index;

		private bool active = true;

		private void OnTriggerEnter(Collider other)
		{
			if (active && other.tag == "Player")
			{
				if (onlyOnce)
				{
					active = false;
				}
				UnityEngine.Debug.Log("Start Text");
				startEvent.Invoke();
				StartCoroutine(FadeInNext());
			}
		}

		private IEnumerator FadeInNext()
		{
			CanvasGroup[] array = canvasGroups;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].GetComponent<Animator>().SetBool("FadeIn", value: false);
			}
			canvasGroups[index].GetComponent<Animator>().SetBool("FadeIn", value: true);
			index++;
			yield return new WaitForSeconds(showTime);
			if (index >= canvasGroups.Length)
			{
				array = canvasGroups;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].GetComponent<Animator>().SetBool("FadeIn", value: false);
				}
				endEvent.Invoke();
			}
			else
			{
				UnityEngine.Debug.Log("Next Text");
				StartCoroutine(FadeInNext());
			}
		}

		public void FadeOutMaterial(Renderer r)
		{
			StartCoroutine(FadeOutMat(r));
		}

		public void FadeInMaterial(Renderer r)
		{
			StartCoroutine(FadeInMat(r));
		}

		public IEnumerator FadeOutMat(Renderer r)
		{
			float a = 1f;
			while (a > 0f)
			{
				a -= Time.timeScale * 0.002f;
				Material[] materials = r.materials;
				foreach (Material material in materials)
				{
					material.color = new Color(material.color.r, material.color.g, material.color.b, a);
				}
				yield return null;
			}
		}

		public IEnumerator FadeInMat(Renderer r)
		{
			float a = 0f;
			while (a < 1f)
			{
				a += Time.timeScale * 0.002f;
				Material[] materials = r.materials;
				foreach (Material material in materials)
				{
					material.color = new Color(material.color.r, material.color.g, material.color.b, a);
				}
				yield return null;
			}
		}
	}
	public class WTFUIInteractableActivator : MonoBehaviour
	{
		public string ID;

		public bool use2;

		public string ID2;

		public bool use3;

		public string ID3;

		private void OnEnable()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			if (OVPlayerPrefs.GetInt(ID) == 1)
			{
				GetComponent<Button>().interactable = true;
				SetChildren(base.gameObject, enabled: true);
			}
			else
			{
				GetComponent<Button>().interactable = false;
				SetChildren(base.gameObject, enabled: false);
			}
			if (use2 && OVPlayerPrefs.GetInt(ID2) == 1)
			{
				GetComponent<Button>().interactable = true;
				SetChildren(base.gameObject, enabled: true);
			}
			if (use3 && OVPlayerPrefs.GetInt(ID3) == 1)
			{
				GetComponent<Button>().interactable = true;
				SetChildren(base.gameObject, enabled: true);
			}
		}

		public void SetChildren(GameObject parentG, bool enabled)
		{
			foreach (Transform item in parentG.transform)
			{
				item.gameObject.SetActive(enabled);
			}
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}
	}
	public class WTFWaterEffectActivator : MonoBehaviour
	{
		private ParticleSystem particle;

		private void Start()
		{
			particle = GameObject.Find("WaterParticles").GetComponent<ParticleSystem>();
		}

		public void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Player")
			{
				particle.Play();
			}
		}

		public void OnTriggerExit(Collider other)
		{
			if (other.tag == "Player")
			{
				particle.Stop();
			}
		}
	}
	public class DeletePP : MonoBehaviour
	{
		private void Start()
		{
			OVPlayerPrefs.DeleteAll();
		}
	}
	public class EpiAutoSceneLoad : MonoBehaviour
	{
		public int sceneIndex = 1;

		private void Start()
		{
			SceneManager.LoadSceneAsync(sceneIndex);
		}
	}
	public class EpiConsoleCam : MonoBehaviour
	{
		[Header("Xbox")]
		public bool use_Xbox;

		public float viewDistance_Xbox;

		public Color fogColor_Xbox;

		[Header("Switch")]
		public bool use_Switch;

		public float viewDistance_Switch;

		public Color fogColor_Switch;

		[Header("PlayStation")]
		public bool use_PS;

		public float viewDistance_PS;

		public Color fogColor_PS;

		[Header("Atari VCS")]
		public bool use_Atari;

		public float viewDistance_Atari;

		public Color fogColor_Atari;

		private Camera cam;

		private bool use;

		private float viewDistance;

		private Color fogColor;

		private void Start()
		{
			cam = GetComponent<Camera>();
			if (use)
			{
				cam.farClipPlane = viewDistance;
				RenderSettings.fog = true;
				RenderSettings.fogMode = FogMode.Linear;
				RenderSettings.fogColor = fogColor;
				RenderSettings.fogStartDistance = 0f;
				RenderSettings.fogEndDistance = viewDistance - viewDistance / 4f;
			}
		}
	}
	[RequireComponent(typeof(Collider))]
	public class EpiPPFade : MonoBehaviour
	{
		public enum FadeState
		{
			None,
			In,
			Out
		}

		[Header("General Setup")]
		[Info]
		public string infoA = "Fades out the Post Processing Volume on trigger enter.";

		[Info]
		public string infoB = "It is supposed to be used to disable the global PP Volume.";

		public string actiationTag = "Player";

		public PostProcessVolume fadeOutVolume;

		public float fadeSpeed = 1f;

		[Header("Additional Options")]
		[Info]
		public string infoC = "Use this option to fade in the post processing simultaneously.";

		public bool useAdditionalFadeIn;

		public PostProcessVolume fadeInVolume;

		private FadeState fadeState;

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == actiationTag)
			{
				fadeState = FadeState.Out;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.tag == actiationTag)
			{
				fadeState = FadeState.In;
			}
		}

		private void Update()
		{
			if (fadeState == FadeState.None)
			{
				return;
			}
			if (fadeState == FadeState.In)
			{
				fadeOutVolume.weight += Time.deltaTime * fadeSpeed;
				if (useAdditionalFadeIn)
				{
					fadeInVolume.weight -= Time.deltaTime * fadeSpeed;
				}
				if (fadeOutVolume.weight >= 1f)
				{
					fadeOutVolume.weight = 1f;
					if (useAdditionalFadeIn)
					{
						fadeInVolume.weight = 0f;
					}
					fadeState = FadeState.None;
				}
			}
			if (fadeState != FadeState.Out)
			{
				return;
			}
			fadeOutVolume.weight -= Time.deltaTime * fadeSpeed;
			if (useAdditionalFadeIn)
			{
				fadeInVolume.weight += Time.deltaTime * fadeSpeed;
			}
			if (fadeOutVolume.weight <= 0f)
			{
				fadeOutVolume.weight = 0f;
				if (useAdditionalFadeIn)
				{
					fadeInVolume.weight = 1f;
				}
				fadeState = FadeState.None;
			}
		}
	}
	public class EpiTrigger : MonoBehaviour
	{
		[SerializeField]
		public UnityEvent onEnter;

		[SerializeField]
		public UnityEvent onExit;

		private void OnTriggerEnter(Collider other)
		{
			if (other.tag == "Player")
			{
				onEnter.Invoke();
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.tag == "Player")
			{
				onExit.Invoke();
			}
		}
	}
	public class GrapplingGun : MonoBehaviour
	{
		private LineRenderer lr;

		private Vector3 grapplePoint;

		public LayerMask whatIsGrappleable;

		public Transform gunTip;

		public Transform camera;

		public Transform player;

		public GameObject hook;

		private float maxDistance = 100f;

		private SpringJoint joint;

		private Vector3 currentGrapplePosition;

		private void Awake()
		{
			lr = GetComponent<LineRenderer>();
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				StartGrapple();
			}
			else if (Input.GetMouseButtonUp(0))
			{
				StopGrapple();
			}
		}

		private void LateUpdate()
		{
			DrawRope();
		}

		private void StartGrapple()
		{
			if (Physics.Raycast(camera.position, camera.forward, out var hitInfo, maxDistance, whatIsGrappleable))
			{
				grapplePoint = hitInfo.point;
				joint = player.gameObject.AddComponent<SpringJoint>();
				joint.autoConfigureConnectedAnchor = false;
				joint.connectedAnchor = grapplePoint;
				float num = Vector3.Distance(player.position, grapplePoint);
				joint.maxDistance = num * 0.8f;
				joint.minDistance = num * 0.25f;
				joint.spring = 4.5f;
				joint.damper = 7f;
				joint.massScale = 4.5f;
				lr.positionCount = 2;
				currentGrapplePosition = gunTip.position;
			}
		}

		private void StopGrapple()
		{
			hook.SetActive(value: true);
			hook.transform.position = gunTip.position;
			lr.positionCount = 0;
			UnityEngine.Object.Destroy(joint);
		}

		private void DrawRope()
		{
			if ((bool)joint)
			{
				currentGrapplePosition = Vector3.Lerp(currentGrapplePosition, grapplePoint, Time.deltaTime * 8f);
				hook.transform.position = currentGrapplePosition;
				lr.SetPosition(0, gunTip.position);
				lr.SetPosition(1, currentGrapplePosition);
			}
		}

		public bool IsGrappling()
		{
			return joint != null;
		}

		public Vector3 GetGrapplePoint()
		{
			return grapplePoint;
		}
	}
	public class GrapplingGunPlayerMovement : MonoBehaviour
	{
		public Transform playerCam;

		public Transform orientation;

		private Rigidbody rb;

		private float xRotation;

		private float sensitivity = 50f;

		private float sensMultiplier = 1f;

		public float moveSpeed = 4500f;

		public float maxSpeed = 20f;

		public bool grounded;

		public LayerMask whatIsGround;

		public float counterMovement = 0.175f;

		private float threshold = 0.01f;

		public float maxSlopeAngle = 35f;

		private Vector3 crouchScale = new Vector3(1f, 0.5f, 1f);

		private Vector3 playerScale;

		public float slideForce = 400f;

		public float slideCounterMovement = 0.2f;

		private bool readyToJump = true;

		private float jumpCooldown = 0.25f;

		public float jumpForce = 550f;

		private float x;

		private float y;

		private bool jumping;

		private bool sprinting;

		private bool crouching;

		private Vector3 normalVector = Vector3.up;

		private Vector3 wallNormalVector;

		private float desiredX;

		private bool cancellingGrounded;

		private void Awake()
		{
			rb = GetComponent<Rigidbody>();
		}

		private void Start()
		{
			playerScale = base.transform.localScale;
			Cursor.lockState = CursorLockMode.Locked;
			Cursor.visible = false;
		}

		private void FixedUpdate()
		{
			Movement();
		}

		private void Update()
		{
			MyInput();
			Look();
		}

		private void MyInput()
		{
			x = Input.GetAxisRaw("Horizontal");
			y = Input.GetAxisRaw("Vertical");
			jumping = Input.GetButton("Jump");
			crouching = Input.GetKey(KeyCode.LeftControl);
			if (Input.GetKeyDown(KeyCode.LeftControl))
			{
				StartCrouch();
			}
			if (Input.GetKeyUp(KeyCode.LeftControl))
			{
				StopCrouch();
			}
		}

		private void StartCrouch()
		{
			base.transform.localScale = crouchScale;
			base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y - 0.5f, base.transform.position.z);
			if (rb.velocity.magnitude > 0.5f && grounded)
			{
				rb.AddForce(orientation.transform.forward * slideForce);
			}
		}

		private void StopCrouch()
		{
			base.transform.localScale = playerScale;
			base.transform.position = new Vector3(base.transform.position.x, base.transform.position.y + 0.5f, base.transform.position.z);
		}

		private void Movement()
		{
			rb.AddForce(Vector3.down * Time.deltaTime * 10f);
			Vector2 mag = FindVelRelativeToLook();
			float num = mag.x;
			float num2 = mag.y;
			CounterMovement(x, y, mag);
			if (readyToJump && jumping)
			{
				Jump();
			}
			float num3 = maxSpeed;
			if (crouching && grounded && readyToJump)
			{
				rb.AddForce(Vector3.down * Time.deltaTime * 3000f);
				return;
			}
			if (x > 0f && num > num3)
			{
				x = 0f;
			}
			if (x < 0f && num < 0f - num3)
			{
				x = 0f;
			}
			if (y > 0f && num2 > num3)
			{
				y = 0f;
			}
			if (y < 0f && num2 < 0f - num3)
			{
				y = 0f;
			}
			float num4 = 1f;
			float num5 = 1f;
			if (!grounded)
			{
				num4 = 0.5f;
				num5 = 0.5f;
			}
			if (grounded && crouching)
			{
				num5 = 0f;
			}
			rb.AddForce(orientation.transform.forward * y * moveSpeed * Time.deltaTime * num4 * num5);
			rb.AddForce(orientation.transform.right * x * moveSpeed * Time.deltaTime * num4);
		}

		private void Jump()
		{
			if (grounded && readyToJump)
			{
				readyToJump = false;
				rb.AddForce(Vector2.up * jumpForce * 1.5f);
				rb.AddForce(normalVector * jumpForce * 0.5f);
				Vector3 velocity = rb.velocity;
				if (rb.velocity.y < 0.5f)
				{
					rb.velocity = new Vector3(velocity.x, 0f, velocity.z);
				}
				else if (rb.velocity.y > 0f)
				{
					rb.velocity = new Vector3(velocity.x, velocity.y / 2f, velocity.z);
				}
				Invoke("ResetJump", jumpCooldown);
			}
		}

		private void ResetJump()
		{
			readyToJump = true;
		}

		private void Look()
		{
			float num = Input.GetAxis("MouseX") * sensitivity * Time.fixedDeltaTime * sensMultiplier;
			float num2 = Input.GetAxis("MouseY") * sensitivity * Time.fixedDeltaTime * sensMultiplier;
			desiredX = playerCam.transform.localRotation.eulerAngles.y + num;
			xRotation -= num2;
			xRotation = Mathf.Clamp(xRotation, -90f, 90f);
			playerCam.transform.localRotation = Quaternion.Euler(xRotation, desiredX, 0f);
			orientation.transform.localRotation = Quaternion.Euler(0f, desiredX, 0f);
		}

		private void CounterMovement(float x, float y, Vector2 mag)
		{
			if (!grounded || jumping)
			{
				return;
			}
			if (crouching)
			{
				rb.AddForce(moveSpeed * Time.deltaTime * -rb.velocity.normalized * slideCounterMovement);
				return;
			}
			if ((Math.Abs(mag.x) > threshold && Math.Abs(x) < 0.05f) || (mag.x < 0f - threshold && x > 0f) || (mag.x > threshold && x < 0f))
			{
				rb.AddForce(moveSpeed * orientation.transform.right * Time.deltaTime * (0f - mag.x) * counterMovement);
			}
			if ((Math.Abs(mag.y) > threshold && Math.Abs(y) < 0.05f) || (mag.y < 0f - threshold && y > 0f) || (mag.y > threshold && y < 0f))
			{
				rb.AddForce(moveSpeed * orientation.transform.forward * Time.deltaTime * (0f - mag.y) * counterMovement);
			}
			if (Mathf.Sqrt(Mathf.Pow(rb.velocity.x, 2f) + Mathf.Pow(rb.velocity.z, 2f)) > maxSpeed)
			{
				float num = rb.velocity.y;
				Vector3 vector = rb.velocity.normalized * maxSpeed;
				rb.velocity = new Vector3(vector.x, num, vector.z);
			}
		}

		public Vector2 FindVelRelativeToLook()
		{
			float current = orientation.transform.eulerAngles.y;
			float target = Mathf.Atan2(rb.velocity.x, rb.velocity.z) * 57.29578f;
			float num = Mathf.DeltaAngle(current, target);
			float num2 = 90f - num;
			float magnitude = rb.velocity.magnitude;
			return new Vector2(y: magnitude * Mathf.Cos(num * ((float)Math.PI / 180f)), x: magnitude * Mathf.Cos(num2 * ((float)Math.PI / 180f)));
		}

		private bool IsFloor(Vector3 v)
		{
			return Vector3.Angle(Vector3.up, v) < maxSlopeAngle;
		}

		private void OnCollisionStay(Collision other)
		{
			int layer = other.gameObject.layer;
			if ((int)whatIsGround != ((int)whatIsGround | (1 << layer)))
			{
				return;
			}
			for (int i = 0; i < other.contactCount; i++)
			{
				Vector3 normal = other.contacts[i].normal;
				if (IsFloor(normal))
				{
					grounded = true;
					cancellingGrounded = false;
					normalVector = normal;
					CancelInvoke("StopGrounded");
				}
			}
			float num = 3f;
			if (!cancellingGrounded)
			{
				cancellingGrounded = true;
				Invoke("StopGrounded", Time.deltaTime * num);
			}
		}

		private void StopGrounded()
		{
			grounded = false;
		}
	}
	public class MoveCamera : MonoBehaviour
	{
		public Transform player;

		private void Update()
		{
			base.transform.position = player.transform.position;
		}
	}
	public class GGun : MonoBehaviour
	{
		private Quaternion originalrot;

		private Grapple_Base grapple;

		private void Start()
		{
			originalrot = base.transform.localRotation;
			grapple = GameObject.Find("Player").GetComponent<Grapple_Base>();
		}

		private void Update()
		{
			if (grapple.IsHookedToRigid && Vector3.Distance(base.transform.position, grapple.PivotPoint) > 2f)
			{
				base.transform.LookAt(GameObject.Find("DaHook").transform.position);
			}
			if (grapple.IsHooked && Vector3.Distance(base.transform.position, grapple.PivotPoint) > 2f)
			{
				base.transform.LookAt(grapple.PivotPoint);
			}
			else
			{
				base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, originalrot, 0.5f);
			}
		}
	}
	public class Grapple_Base : MonoBehaviour
	{
		public float MaxGrappleRange;

		public float CurrentRopeLength;

		public float TravelSpeed;

		public bool IsGrappling;

		public bool IsHooked;

		public bool FalseHook;

		public bool IsHookedToRigid;

		public Vector3 PivotPoint;

		public GameObject HookPrefab;

		private RaycastHit Hit;

		private SpringJoint PlayerSpring;

		private Move_Base PlayerMove;

		private Rigidbody PlayerRigid;

		private LineRenderer LR;

		private GameObject TheHook;

		public float GrapplingCooldown;

		public float CooldownTimer;

		public GameObject Pulling;

		public GameObject LineStart;

		public AudioSource Audio;

		public AudioClip ReelSound;

		public AudioClip LaunchSound;

		public AudioClip HitSuccess;

		public AudioClip HitFailure;

		public AudioSource WindSoundFX;

		private Vector3 CameraStandard;

		private bool Test69;

		public GameObject FakeHook;

		public bool ThirdPerson;

		public Text VelocityReadout;

		public GameObject SpeedFX;

		private void Start()
		{
			IsHooked = false;
			IsGrappling = false;
			PlayerMove = GetComponent<Move_Base>();
			PlayerRigid = GetComponent<Rigidbody>();
			Audio = GetComponent<AudioSource>();
			LR = GetComponent<LineRenderer>();
			LR.enabled = false;
			FakeHook.SetActive(value: true);
			CameraStandard = Camera.main.transform.localPosition;
			SpeedFX.GetComponent<ParticleSystem>().Stop();
			VelocityReadout = GameObject.Find("Vel_Read").GetComponent<Text>();
		}

		private void FixedUpdate()
		{
			ReelIn();
			ShootHook();
			PullPhysicsObjects();
		}

		private void LateUpdate()
		{
			if (PlayerRigid.velocity.magnitude > 35f)
			{
				PlayerRigid.velocity = PlayerRigid.velocity.normalized * 35f;
			}
			VelocityReadout.text = Mathf.Round(PlayerRigid.velocity.magnitude).ToString();
			DrawRope();
			if (Input.GetMouseButtonDown(1) && IsHookedToRigid)
			{
				Pulling.GetComponent<Rigidbody>().AddForce(-Camera.main.transform.forward * CurrentRopeLength / 1.5f, ForceMode.VelocityChange);
				UnHook();
			}
		}

		private void SoundFX()
		{
			if (TheHook != null && FalseHook && Vector3.Distance(TheHook.transform.position, Hit.point) < 10f)
			{
				Audio.clip = HitFailure;
				if (!Audio.isPlaying)
				{
					Audio.Play();
				}
			}
			if (IsHooked && PlayerRigid.velocity.magnitude < 20f && WindSoundFX.isPlaying)
			{
				WindSoundFX.Stop();
				WindSoundFX.enabled = false;
				SpeedFX.GetComponent<ParticleSystem>().Stop();
			}
			if (IsHooked && PlayerRigid.velocity.magnitude > 20f && !WindSoundFX.isPlaying)
			{
				WindSoundFX.enabled = true;
				SpeedFX.GetComponent<ParticleSystem>().Play();
				WindSoundFX.Play();
			}
			if (IsGrappling)
			{
				if (!Audio.isPlaying)
				{
					Audio.clip = ReelSound;
					Audio.Play();
				}
			}
			else if (!IsGrappling && !IsHooked && !IsHookedToRigid && !FalseHook)
			{
				Audio.Stop();
			}
		}

		private void Update()
		{
			SoundFX();
			if (Vector3.Distance(base.transform.position, Hit.point) < 5f && IsGrappling)
			{
				PlayerRigid.velocity = new Vector3(0f, 0f, 0f);
				PlayerRigid.AddForce(base.transform.up * 10f, ForceMode.Impulse);
				UnHook();
			}
			if (CooldownTimer < GrapplingCooldown)
			{
				CooldownTimer += 1f;
			}
			if (GameObject.Find("DaHook") != null)
			{
				TheHook = GameObject.Find("DaHook");
			}
			if ((Input.GetMouseButtonUp(1) && IsHooked) || (Input.GetMouseButtonUp(1) && IsHookedToRigid))
			{
				UnHook();
				PlayerRigid.velocity = new Vector3(0f, 0f, 0f);
			}
			if (TheHook != null)
			{
				_ = Hit.point;
				if ((Vector3.Distance(TheHook.transform.position, Hit.point) < 2f && IsHooked && !Test69) || (Vector3.Distance(TheHook.transform.position, Hit.point) < 2f && IsHookedToRigid && !Test69))
				{
					Audio.clip = HitSuccess;
					Audio.Play();
					Test69 = true;
				}
				if (Vector3.Distance(TheHook.transform.position, Hit.point) < 3f && FalseHook)
				{
					IsGrappling = false;
					IsHooked = false;
					FalseHook = false;
					LR.enabled = false;
					PlayerMove.CanPlayerMove = true;
					UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
				}
			}
			if (Input.GetMouseButtonDown(0) && GrapplingCooldown == CooldownTimer)
			{
				CheckForGrapple();
			}
			if (IsHooked || IsHookedToRigid)
			{
				if (Input.GetKeyDown(KeyCode.LeftShift))
				{
					PlayerRigid.velocity = new Vector3(0f, 0f, 0f);
					UnHook();
				}
				if (Input.GetKeyDown(KeyCode.Space))
				{
					UnHook();
					PlayerRigid.AddForce(base.transform.up * PlayerRigid.velocity.magnitude * 0.5f, ForceMode.Impulse);
					PlayerRigid.AddForce(base.transform.forward * PlayerRigid.velocity.magnitude * 0.5f, ForceMode.Impulse);
				}
			}
		}

		private void ReelIn()
		{
			if (IsHooked && Input.GetMouseButton(1))
			{
				PlayerRigid.useGravity = false;
				SpeedFX.GetComponent<ParticleSystem>().Play();
				base.transform.position = Vector3.Lerp(base.transform.position, Hit.point, TravelSpeed * Time.deltaTime / Vector3.Distance(base.transform.position, Hit.point));
				CurrentRopeLength = Vector3.Distance(base.transform.position, Hit.point);
				IsHooked = true;
				IsGrappling = true;
			}
		}

		private void HookedSettings()
		{
			if (base.gameObject.GetComponent<SpringJoint>() == null)
			{
				base.gameObject.AddComponent<SpringJoint>();
			}
			IsHooked = true;
			FalseHook = false;
			IsHookedToRigid = false;
			PlayerSpring = GetComponent<SpringJoint>();
			CurrentRopeLength = Vector3.Distance(base.transform.position, Hit.point);
			PivotPoint = Hit.point;
			PlayerSpring.autoConfigureConnectedAnchor = false;
			PlayerSpring.connectedAnchor = PivotPoint;
			PlayerSpring.maxDistance = CurrentRopeLength * 0.8f;
			PlayerSpring.minDistance = CurrentRopeLength * 0.25f;
			PlayerSpring.spring = 4.5f;
			PlayerSpring.damper = 7f;
			PlayerSpring.massScale = 4.5f;
		}

		private void ShootHook()
		{
			if (TheHook != null)
			{
				TheHook.transform.position = Vector3.Lerp(GameObject.Find("DaHook").transform.position, Hit.point, 0.1f);
				if (Vector3.Distance(TheHook.transform.position, Hit.point) > 2f)
				{
					TheHook.transform.RotateAround(TheHook.transform.position, TheHook.transform.forward, 69f);
				}
			}
		}

		private void UnHook()
		{
			FakeHook.SetActive(value: true);
			Test69 = false;
			UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
			IsGrappling = false;
			IsHooked = false;
			PlayerRigid.useGravity = true;
			UnityEngine.Object.Destroy(base.gameObject.GetComponent<SpringJoint>());
			PlayerSpring = null;
			CurrentRopeLength = 0f;
			LR.enabled = false;
			FalseHook = false;
			IsHookedToRigid = false;
			Camera.main.transform.SetParent(base.transform);
			Camera.main.transform.localPosition = CameraStandard;
			if (ThirdPerson)
			{
				Camera.main.transform.localRotation = new Quaternion(0f, 0f, 0f, 1f);
			}
			WindSoundFX.enabled = false;
			SpeedFX.GetComponent<ParticleSystem>().Stop();
			if (Pulling != null)
			{
				if (Pulling.GetComponent<SpringJoint>() != null)
				{
					UnityEngine.Object.Destroy(Pulling.GetComponent<SpringJoint>());
				}
				Pulling = null;
			}
		}

		private void DrawRope()
		{
			if (GameObject.Find("DaHook") != null)
			{
				LR.enabled = true;
				LR.SetPosition(0, LineStart.transform.position);
				LR.SetPosition(1, GameObject.Find("DaHook").transform.Find("RopeConnectionPoint").transform.position);
			}
			else
			{
				LR.enabled = false;
			}
		}

		private void PullPhysicsObjects()
		{
			if (IsHookedToRigid && Pulling != null)
			{
				if (Pulling.GetComponent<SpringJoint>() != null)
				{
					Pulling.GetComponent<SpringJoint>().connectedAnchor = base.transform.position;
				}
				if (TheHook != null && !Input.GetMouseButton(0))
				{
					TheHook.transform.position = Pulling.GetComponent<Collider>().ClosestPoint(TheHook.transform.position);
					TheHook.transform.RotateAround(TheHook.transform.position, TheHook.transform.forward, -69f);
				}
			}
		}

		private void CheckForGrapple()
		{
			if (!ThirdPerson)
			{
				if (!Physics.Raycast(Camera.main.transform.position, Camera.main.transform.forward, out Hit, MaxGrappleRange) || GrapplingCooldown != CooldownTimer)
				{
					return;
				}
				if (Hit.collider.tag == "CanGrapple" && Hit.collider.GetComponent<Rigidbody>() == null)
				{
					FakeHook.SetActive(value: false);
					Test69 = false;
					Audio.clip = LaunchSound;
					Audio.Play();
					HookedSettings();
					if (GameObject.Find("DaHook") != null)
					{
						UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
					}
					IsHookedToRigid = false;
					GameObject obj = UnityEngine.Object.Instantiate(HookPrefab);
					obj.transform.rotation = Quaternion.LookRotation(Camera.main.transform.forward);
					obj.name = "DaHook";
					obj.transform.position = base.transform.position;
					CooldownTimer = 0f;
					if (Pulling != null)
					{
						if (Pulling.GetComponent<SpringJoint>() != null)
						{
							UnityEngine.Object.Destroy(Pulling.GetComponent<SpringJoint>());
						}
						Pulling = null;
					}
				}
				else if (Hit.collider.tag != "CanGrapple")
				{
					FakeHook.SetActive(value: false);
					Test69 = false;
					IsHooked = false;
					IsHookedToRigid = false;
					if (GameObject.Find("DaHook") != null)
					{
						UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
					}
					if (base.gameObject.GetComponent<SpringJoint>() != null)
					{
						UnityEngine.Object.Destroy(base.gameObject.GetComponent<SpringJoint>());
					}
					Audio.clip = LaunchSound;
					Audio.Play();
					FalseHook = true;
					GameObject obj2 = UnityEngine.Object.Instantiate(HookPrefab);
					obj2.transform.rotation = Quaternion.LookRotation(Camera.main.transform.forward);
					obj2.name = "DaHook";
					obj2.transform.position = base.transform.position;
					CooldownTimer = 0f;
					if (Pulling != null)
					{
						if (Pulling.GetComponent<SpringJoint>() != null)
						{
							UnityEngine.Object.Destroy(Pulling.GetComponent<SpringJoint>());
						}
						Pulling = null;
					}
				}
				else if (Hit.collider.GetComponent<Rigidbody>() != null && Hit.collider.tag == "CanGrapple")
				{
					FakeHook.SetActive(value: false);
					Test69 = false;
					Audio.clip = LaunchSound;
					Audio.Play();
					if (GameObject.Find("DaHook") != null)
					{
						UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
					}
					if (base.gameObject.GetComponent<SpringJoint>() != null)
					{
						UnityEngine.Object.Destroy(base.gameObject.GetComponent<SpringJoint>());
					}
					IsHookedToRigid = true;
					IsHooked = false;
					FalseHook = false;
					GameObject obj3 = UnityEngine.Object.Instantiate(HookPrefab);
					obj3.transform.rotation = Quaternion.LookRotation(Camera.main.transform.forward);
					obj3.name = "DaHook";
					obj3.transform.position = base.transform.position;
					CooldownTimer = 0f;
					if (Hit.collider.gameObject.GetComponent<SpringJoint>() == null)
					{
						Hit.collider.gameObject.AddComponent<SpringJoint>();
					}
					CurrentRopeLength = Vector3.Distance(base.transform.position, Hit.point);
					SpringJoint component = Hit.collider.gameObject.GetComponent<SpringJoint>();
					component.autoConfigureConnectedAnchor = false;
					component.connectedAnchor = base.transform.position;
					component.maxDistance = CurrentRopeLength * 1.25f;
					component.minDistance = CurrentRopeLength * 0.25f;
					component.spring = 4.5f;
					component.damper = 7f;
					component.massScale = 4.5f;
					Pulling = Hit.collider.gameObject;
					Pulling.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
				}
			}
			else
			{
				if (!ThirdPerson || !Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out Hit, MaxGrappleRange) || GrapplingCooldown != CooldownTimer)
				{
					return;
				}
				if (Hit.collider.tag == "CanGrapple" && Hit.collider.GetComponent<Rigidbody>() == null)
				{
					FakeHook.SetActive(value: false);
					Test69 = false;
					Audio.clip = LaunchSound;
					Audio.Play();
					HookedSettings();
					if (GameObject.Find("DaHook") != null)
					{
						UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
					}
					IsHookedToRigid = false;
					GameObject obj4 = UnityEngine.Object.Instantiate(HookPrefab);
					obj4.transform.rotation = Quaternion.LookRotation(Camera.main.transform.forward);
					obj4.name = "DaHook";
					obj4.transform.position = base.transform.position;
					CooldownTimer = 0f;
					if (Pulling != null)
					{
						if (Pulling.GetComponent<SpringJoint>() != null)
						{
							UnityEngine.Object.Destroy(Pulling.GetComponent<SpringJoint>());
						}
						Pulling = null;
					}
				}
				else if (Hit.collider.tag != "CanGrapple")
				{
					FakeHook.SetActive(value: false);
					Test69 = false;
					IsHooked = false;
					IsHookedToRigid = false;
					if (GameObject.Find("DaHook") != null)
					{
						UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
					}
					if (base.gameObject.GetComponent<SpringJoint>() != null)
					{
						UnityEngine.Object.Destroy(base.gameObject.GetComponent<SpringJoint>());
					}
					Audio.clip = LaunchSound;
					Audio.Play();
					FalseHook = true;
					GameObject obj5 = UnityEngine.Object.Instantiate(HookPrefab);
					obj5.transform.rotation = Quaternion.LookRotation(Camera.main.transform.forward);
					obj5.name = "DaHook";
					obj5.transform.position = base.transform.position;
					CooldownTimer = 0f;
					if (Pulling != null)
					{
						if (Pulling.GetComponent<SpringJoint>() != null)
						{
							UnityEngine.Object.Destroy(Pulling.GetComponent<SpringJoint>());
						}
						Pulling = null;
					}
				}
				else if (Hit.collider.GetComponent<Rigidbody>() != null && Hit.collider.tag == "CanGrapple")
				{
					FakeHook.SetActive(value: false);
					Test69 = false;
					Audio.clip = LaunchSound;
					Audio.Play();
					if (GameObject.Find("DaHook") != null)
					{
						UnityEngine.Object.Destroy(GameObject.Find("DaHook"));
					}
					if (base.gameObject.GetComponent<SpringJoint>() != null)
					{
						UnityEngine.Object.Destroy(base.gameObject.GetComponent<SpringJoint>());
					}
					IsHookedToRigid = true;
					IsHooked = false;
					FalseHook = false;
					GameObject obj6 = UnityEngine.Object.Instantiate(HookPrefab);
					obj6.transform.rotation = Quaternion.LookRotation(Camera.main.transform.forward);
					obj6.name = "DaHook";
					obj6.transform.position = base.transform.position;
					CooldownTimer = 0f;
					if (Hit.collider.gameObject.GetComponent<SpringJoint>() == null)
					{
						Hit.collider.gameObject.AddComponent<SpringJoint>();
					}
					CurrentRopeLength = Vector3.Distance(base.transform.position, Hit.point);
					SpringJoint component2 = Hit.collider.gameObject.GetComponent<SpringJoint>();
					component2.autoConfigureConnectedAnchor = false;
					component2.connectedAnchor = base.transform.position;
					component2.maxDistance = CurrentRopeLength * 1.25f;
					component2.minDistance = CurrentRopeLength * 0.25f;
					component2.spring = 4.5f;
					component2.damper = 7f;
					component2.massScale = 4.5f;
					Pulling = Hit.collider.gameObject;
					Pulling.GetComponent<Rigidbody>().velocity = new Vector3(0f, 0f, 0f);
				}
			}
		}
	}
	public class Move_Base : MonoBehaviour
	{
		public float WalkSpeed;

		public float JumpMultiplier;

		public float GroundedRayDistance;

		public float Airtime;

		public bool CanPlayerMove = true;

		public bool Grounded;

		public Animator Anim;

		public bool ThirdPerson;

		private float MoveForward;

		private float MoveStrafe;

		private float RotX;

		private float RotY;

		private float HorizontalSensitivity = 3f;

		private float VerticalSensitivity = 1f;

		private Rigidbody PlayerRigid;

		private void Start()
		{
			PlayerRigid = GetComponent<Rigidbody>();
		}

		private void Update()
		{
			if (!ThirdPerson)
			{
				Rotate();
			}
			CheckIfGrounded();
		}

		private void Rotate()
		{
			RotX = Input.GetAxis("Mouse X") * HorizontalSensitivity;
			RotY = Input.GetAxis("Mouse Y") * VerticalSensitivity;
			base.transform.Rotate(0f, RotX, 0f);
			Camera.main.transform.Rotate(0f - RotY, 0f, 0f);
		}

		private void FixedUpdate()
		{
			if (CanPlayerMove)
			{
				Movement();
				if (Input.GetKeyDown(KeyCode.Space) && Grounded)
				{
					PlayerRigid.AddForce(0f, JumpMultiplier, 0f, ForceMode.Impulse);
				}
			}
		}

		private void Movement()
		{
			float axis = Input.GetAxis("Horizontal");
			float axis2 = Input.GetAxis("Vertical");
			Vector3 direction = new Vector3(axis, 0f, axis2) * WalkSpeed;
			Vector3 position = PlayerRigid.position + PlayerRigid.transform.TransformDirection(direction);
			PlayerRigid.MovePosition(position);
		}

		private void CheckIfGrounded()
		{
			if (Grounded && Airtime > 0f)
			{
				PlayerRigid.velocity = new Vector3(0f, 0f, 0f);
				Airtime = 0f;
			}
			if (Physics.Raycast(base.transform.position, -base.transform.up, GroundedRayDistance))
			{
				Grounded = true;
				return;
			}
			Grounded = false;
			Airtime += 1f;
		}
	}
	public class TP_Cam : MonoBehaviour
	{
		public Vector3 CameraStandard;

		public Transform CameraExpected;

		public float CameraSmoother = 2f;

		private Grapple_Base Grapple;

		public Image Cursor;

		private float RotX;

		private float RotY;

		private float HorizontalSensitivity = 3f;

		private float VerticalSensitivity = 1f;

		private float SmoothingFactor;

		private GameObject Player;

		private void Start()
		{
			CameraStandard = Camera.main.transform.localPosition;
			Grapple = GameObject.FindGameObjectWithTag("Player").GetComponent<Grapple_Base>();
			Player = GameObject.FindGameObjectWithTag("Player");
		}

		private void Rotate()
		{
			RotX = Input.GetAxis("Mouse X") * HorizontalSensitivity;
			RotY = Input.GetAxis("Mouse Y") * VerticalSensitivity;
			Player.transform.Rotate(0f, RotX, 0f);
			base.transform.Rotate(0f - RotY, 0f, 0f);
		}

		private void Update()
		{
			if (Cursor != null)
			{
				Cursor.rectTransform.position = Input.mousePosition;
			}
			if (!Grapple.IsGrappling)
			{
				Rotate();
			}
		}

		private void FixedUpdate()
		{
			if (Grapple.IsGrappling)
			{
				base.transform.SetParent(null);
				Vector3 position = Vector3.Lerp(Camera.main.transform.position, CameraExpected.position, SmoothingFactor * Time.deltaTime);
				Camera.main.transform.position = position;
				SmoothingFactor = CameraSmoother;
				base.transform.LookAt(Player.transform.position);
			}
		}
	}
	public class RotateGun : MonoBehaviour
	{
		public GrapplingGun grappling;

		private Quaternion desiredRotation;

		private float rotationSpeed = 5f;

		private void Update()
		{
			if (!grappling.IsGrappling())
			{
				desiredRotation = base.transform.parent.rotation;
			}
			else
			{
				desiredRotation = Quaternion.LookRotation(grappling.GetGrapplePoint() - base.transform.position);
			}
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, desiredRotation, Time.deltaTime * rotationSpeed);
		}
	}
	public class HideCursor : MonoBehaviour
	{
		private void Start()
		{
			Cursor.visible = false;
		}
	}
	public class LevelLoadTrigger : MonoBehaviour
	{
		[Header("Level ID")]
		public int ID;

		[Header("Respawn Settings")]
		public GameObject startingComponent;

		public Transform spawnPoint;

		private bool used;

		private void Start()
		{
			if (ID == OVPlayerPrefs.GetInt("LevelID"))
			{
				startingComponent.transform.position = spawnPoint.position;
				startingComponent.transform.rotation = spawnPoint.rotation;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!used && other.tag == "Player")
			{
				used = true;
				OVPlayerPrefs.SetInt("LevelID", ID);
				WTFGenericSingleton<MenuController>.Instance.LoadLevel(ID);
			}
		}
	}
	public class LoadNext_OnStart : MonoBehaviour
	{
		private void Start()
		{
			Invoke("Load", 1f);
		}

		public void Load()
		{
			SceneManager.LoadScene(1);
		}
	}
	public class MaterialCounter : MonoBehaviour
	{
		public Material selectedMaterial;

		public Material switchedMaterial;

		[Button(null, EButtonEnableMode.Always)]
		private void CountMaterials()
		{
			List<Material> list = new List<Material>();
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			foreach (Renderer renderer in array)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				foreach (Material material in sharedMaterials)
				{
					if (!list.Contains(material))
					{
						if (material == null)
						{
							UnityEngine.Debug.LogError(renderer.name + " has a null material!\n", renderer.gameObject);
						}
						else
						{
							list.Add(material);
						}
					}
				}
			}
			string text = string.Empty;
			foreach (Material item in list)
			{
				text = text + item.name + "\n";
			}
			UnityEngine.Debug.Log("Count:" + list.Count + "\n\n" + text);
		}

		[Button(null, EButtonEnableMode.Always)]
		private void SelectAllMeshesWithMaterial()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			foreach (Renderer renderer in array)
			{
				if (new List<Material>(renderer.sharedMaterials).Contains(selectedMaterial))
				{
					UnityEngine.Debug.Log(renderer.name + "\n", renderer.gameObject);
				}
			}
		}

		[Button(null, EButtonEnableMode.Always)]
		private void SwitchMaterials()
		{
			int num = 0;
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			foreach (Renderer renderer in array)
			{
				List<Material> list = new List<Material>(renderer.sharedMaterials);
				if (list.Contains(selectedMaterial))
				{
					int index = list.FindIndex(isMaterial);
					list[index] = switchedMaterial;
					renderer.sharedMaterials = list.ToArray();
					num++;
				}
			}
			UnityEngine.Debug.Log(num + " Renderer material switched!\n");
			bool isMaterial(Material material)
			{
				return material == selectedMaterial;
			}
		}

		[Button(null, EButtonEnableMode.Always)]
		private void SelectRendererWithMultipleMaterials()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			foreach (Renderer renderer in array)
			{
				if (renderer.sharedMaterials.Length > 1)
				{
					UnityEngine.Debug.Log(renderer.name + "\n", renderer.gameObject);
				}
			}
		}

		[Button(null, EButtonEnableMode.Always)]
		private void ForceSetToOneMaterial()
		{
			Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
			foreach (Renderer renderer in array)
			{
				if (renderer.sharedMaterials.Length > 1)
				{
					renderer.sharedMaterials = new Material[1] { renderer.sharedMaterials[0] };
				}
			}
		}
	}
	public class LanguageChanger : OVGenericSingleton<LanguageChanger>
	{
		public enum Language
		{
			en,
			zh,
			ja,
			ko
		}

		[SerializeField]
		private bool hasDefaultLanguage;

		[SerializeField]
		private Language defaultLanguage;

		private bool languageSelected;

		public Language language { get; private set; }

		private void Start()
		{
			if (hasDefaultLanguage)
			{
				ChooseLanguage((int)defaultLanguage);
			}
		}

		public void ChooseLanguage(int i)
		{
			if (i == 0)
			{
				LocalizationManager.CurrentLanguageCode = "en";
				language = Language.en;
			}
			if (i == 1)
			{
				LocalizationManager.CurrentLanguageCode = "zh";
				language = Language.zh;
			}
			if (i == 2)
			{
				LocalizationManager.CurrentLanguageCode = "ja";
				language = Language.ja;
			}
			if (i == 3)
			{
				LocalizationManager.CurrentLanguageCode = "ko";
				language = Language.ko;
			}
			languageSelected = true;
		}
	}
	public class PickupSpawner : MonoBehaviour
	{
		public GameObject spawnObject;

		public Collider spawnArea;

		public int spawnAmount;

		private List<Collider> level;

		private void Start()
		{
			spawnArea.gameObject.GetComponent<MeshRenderer>().enabled = false;
			level = new List<Collider>();
			Collider[] array = UnityEngine.Object.FindObjectsOfType<Collider>();
			foreach (Collider collider in array)
			{
				if (!collider.isTrigger)
				{
					level.Add(collider);
				}
			}
			for (int j = 0; j < spawnAmount; j++)
			{
				Vector3 position = CalculatePosition();
				GameObject gameObject = UnityEngine.Object.Instantiate(spawnObject, position, Quaternion.identity, null);
				gameObject.name = "Pickup" + j;
				gameObject.SetActive(value: true);
				CheckPosition(gameObject, 0);
			}
		}

		public void CheckPosition(GameObject g, int iteration)
		{
			if (iteration > 100)
			{
				UnityEngine.Debug.LogError("ERROR: 100 iterations didn't find a valid spawn point.");
				return;
			}
			foreach (Collider item in level)
			{
				if (g.GetComponent<Collider>().bounds.Intersects(item.bounds))
				{
					UnityEngine.Debug.Log("Intersection found at " + g.GetComponent<Collider>().bounds.center.ToString() + ". Objects: " + g.name + " and: " + item.gameObject.name + ". Recalculate position: " + iteration);
					g.transform.position = CalculatePosition();
					Physics.SyncTransforms();
					CheckPosition(g, iteration + 1);
					break;
				}
			}
		}

		private Vector3 CalculatePosition()
		{
			return spawnArea.bounds.center + new Vector3(UnityEngine.Random.Range(0f - spawnArea.bounds.extents.x, spawnArea.bounds.extents.x), UnityEngine.Random.Range(0f - spawnArea.bounds.extents.y, spawnArea.bounds.extents.y), UnityEngine.Random.Range(0f - spawnArea.bounds.extents.z, spawnArea.bounds.extents.z));
		}
	}
	public class ResetSavedLevel : MonoBehaviour
	{
		public void ResetNow()
		{
			OVPlayerPrefs.SetInt("LevelID");
		}
	}
	[DisallowMultipleComponent]
	public class SteamManager : MonoBehaviour
	{
		private static SteamManager s_instance;

		private static SteamManager Instance
		{
			get
			{
				if (s_instance == null)
				{
					return new GameObject("SteamManager").AddComponent<SteamManager>();
				}
				return s_instance;
			}
		}
	}
	public class SwitchBundleMenuInteractionsDelay : MonoBehaviour
	{
	}
	public class ChangeSprite : MonoBehaviour
	{
		public Sprite[] sprites;

		private Image image;

		private int index;

		private void Start()
		{
			image = GetComponent<Image>();
		}

		public void Begin()
		{
			CancelInvoke("Change");
			InvokeRepeating("Change", 2f, 1f);
		}

		public void Change()
		{
			index++;
			if (index >= sprites.Length)
			{
				index = 0;
			}
			image.sprite = sprites[index];
		}
	}
	public class OculusController : MonoBehaviour
	{
		public GameObject controllerL;

		public GameObject controllerR;

		public float heightDifefrence = 0.2f;

		public float rotationDifference = 0.2f;

		[HideInInspector]
		public float yawn;

		[HideInInspector]
		public float pitch;

		private bool lastInputFocus;

		private bool lastPresent;
	}
	public class OculusStarter : MonoBehaviour
	{
	}
	public class VRDynamicRes : MonoBehaviour
	{
		public float scaleFactor;

		public Camera cam;

		private void Start()
		{
		}

		public void Update()
		{
			ScalableBufferManager.ResizeBuffers(scaleFactor, scaleFactor);
		}
	}
	public class ViveButton : MonoBehaviour
	{
	}
	public class ViveController : MonoBehaviour
	{
		public GameObject controllerL;

		public GameObject controllerR;

		public float heightDifefrence = 0.2f;

		public float rotationDifference = 0.2f;

		[HideInInspector]
		public float yawn;

		[HideInInspector]
		public float pitch;
	}
	public class WTFPlayPrefUnlocker : MonoBehaviour
	{
		public string PPName;

		public bool disable;

		private void Start()
		{
			if (!disable && OVPlayerPrefs.GetInt(PPName) == 0)
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class WTFUnlockAchievement_OnStart : MonoBehaviour
	{
		public bool triggerAutomatically = true;

		public string ID;

		private void Start()
		{
			if (triggerAutomatically)
			{
				OVAchievement.Unlock(ID);
			}
		}

		public void Unlock()
		{
			OVAchievement.Unlock(ID);
		}
	}
	public class WTFUnlockOnLoad : MonoBehaviour
	{
		public bool test;

		public int[] finishedLevelIndexs;

		public Button[] unlockObjects;

		private void Start()
		{
			InvokeRepeating("Unlock", 1f, 1f);
		}

		private void OnEnable()
		{
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
		}

		private void OnDisable()
		{
		}

		public void Unlock()
		{
			for (int i = 0; i < finishedLevelIndexs.Length; i++)
			{
				if (OVPlayerPrefs.GetInt("Level" + finishedLevelIndexs[i]) == 0 && !test)
				{
					unlockObjects[i].interactable = false;
				}
				else
				{
					unlockObjects[i].interactable = true;
				}
			}
		}
	}
	public class OVGenericSingleton<T> : MonoBehaviour where T : Component
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<T>();
					if (instance == null)
					{
						instance = new GameObject
						{
							name = typeof(T).Name
						}.AddComponent<T>();
					}
				}
				return instance;
			}
		}

		public virtual void Awake()
		{
			if (instance == null)
			{
				instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class OVAchievementsController_PS : OVGenericSingleton<OVAchievementsController_PS>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievementController_SWITCH is called but SWITCH was not defined as scripting define symbol in the player settings.");
		}
	}
	public class OVAchievementsController_STEAM : OVGenericSingleton<OVAchievementsController_STEAM>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievement_PC is called but STEAM was not defined as scripting define symbol in the player settings.");
		}
	}
	public class OVAchievementsController_SWITCH : OVGenericSingleton<OVAchievementsController_SWITCH>
	{
		public void Unlock(string ID)
		{
			UnityEngine.Debug.Log("OVAchievementController_SWITCH is called but SWITCH was not defined as scripting define symbol in the player settings.");
		}
	}
	public class OVAchievementsController_XBOX : OVGenericSingleton<OVAchievementsController_XBOX>
	{
		private bool firstTime = true;

		private bool haveRequestedSignIn;

		private void Start()
		{
		}

		private bool SanityCheckApplicationSetup()
		{
			return true;
		}

		private void Update()
		{
		}

		public void Unlock(string ID)
		{
		}
	}
	public class OVAchievement
	{
		public static void Unlock(string ID)
		{
			OVGenericSingleton<OVAchievementsController_STEAM>.Instance.Unlock(ID);
		}
	}
	public class OVEnums : MonoBehaviour
	{
		public enum DataType_PP
		{
			Integer,
			Float,
			String
		}

		public enum KeyType
		{
			Primary,
			Secondary,
			Controller
		}

		public enum TriggerType
		{
			OnAwake,
			OnStart,
			OnEnable,
			OnTriggerEnter,
			OnTriggerExit,
			OnCollisionEnter,
			OnCollisionExit,
			OnDisable,
			OnDestroy,
			OnSceneLoaded,
			ViaScript,
			ViaTriggerActivator
		}

		public enum ConditionEvaluationType
		{
			AnyCondition,
			AllConditions
		}

		public enum CurrencyConditionType
		{
			CheckForAmount,
			CheckAndSpendAmount
		}

		public enum NoteType
		{
			Idea,
			Info,
			Note,
			Question,
			TodoList,
			Task
		}

		public enum VelocityCalulation
		{
			GetFromRigidBody,
			CalculateVelocity
		}

		public enum FadeState
		{
			FadedOut,
			FadedIn
		}

		public enum LoadingOptions
		{
			LoadSavedLevelName,
			LoadNewLevelName
		}

		public enum LabelIcon
		{
			Gray,
			Blue,
			Teal,
			Green,
			Yellow,
			Orange,
			Red,
			Purple,
			None
		}

		public enum Icon
		{
			CircleGray,
			CircleBlue,
			CircleTeal,
			CircleGreen,
			CircleYellow,
			CircleOrange,
			CircleRed,
			CirclePurple,
			DiamondGray,
			DiamondBlue,
			DiamondTeal,
			DiamondGreen,
			DiamondYellow,
			DiamondOrange,
			DiamondRed,
			DiamondPurple,
			None
		}

		public enum Layout
		{
			Axis,
			Cube,
			Sphere,
			Mesh
		}

		public enum Axis
		{
			X,
			Y,
			Z
		}
	}
	public class OVStrings : MonoBehaviour
	{
		public static string MAXWEAPONS = "MaxWeapons";

		public static string UNLOCKED_PREFIX = "Unlocked";

		public static string UNLOCKNOW_PREFIX = "UnlockNow";

		public static string FINISHED_PREFIX = "Finished";

		public static string CLUSTER_PREFIX = "Cluster";

		public static string CURRENCYAMOUNT_PREFIX = "CurrencyAmount";

		public static string NEXTLEVEL = "NextLevelID";

		public static string PERSISTVALUE_PREFIX = "PersistValues";

		public static string FLOATARRAY_PREFIX = "FloatArray";
	}
	public class OVDisableHDR : MonoBehaviour
	{
		[Header("Console Specific")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool ps;

		private void Awake()
		{
		}
	}
	public class OVPlatformDependance : MonoBehaviour
	{
		[Header("Enable for following Platforms")]
		public bool editor;

		public bool standalone;

		public bool mobile;

		public bool consoles;

		[Header("Console Specific")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool ps;

		private void Awake()
		{
			if (mobile)
			{
				base.gameObject.SetActive(value: true);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class OVPlatformDependantSpawner : MonoBehaviour
	{
		public bool spawnOnAwake = true;

		public GameObject[] pc;

		public GameObject[] xbox;

		public GameObject[] nintendoSwitch;

		public GameObject[] playstation;

		private void Awake()
		{
			Spawn();
		}

		public void Spawn()
		{
			GameObject[] array = pc;
			if (array.Length != 0)
			{
				GameObject[] array2 = array;
				foreach (GameObject gameObject in array2)
				{
					UnityEngine.Object.Instantiate(gameObject, null).name = gameObject.name;
				}
			}
			base.gameObject.SetActive(value: false);
		}
	}
	public class OVPSInitializer : OVGenericSingleton<OVPSInitializer>
	{
		private void Start()
		{
			OVPlayerPrefs.Initialize();
		}
	}
	[Serializable]
	public class OVSaveData
	{
		public Dictionary<string, int> SavedInt = new Dictionary<string, int>();

		public Dictionary<string, float> SavedFloat = new Dictionary<string, float>();

		public Dictionary<string, string> SavedString = new Dictionary<string, string>();

		public Dictionary<string, bool> SavedBool = new Dictionary<string, bool>();

		public Dictionary<string, Vector2> SavedVector2 = new Dictionary<string, Vector2>();

		public Dictionary<string, Vector3> SavedVector3 = new Dictionary<string, Vector3>();

		public Dictionary<string, Quaternion> SavedQuaternion = new Dictionary<string, Quaternion>();

		public Dictionary<string, Color> SavedColor = new Dictionary<string, Color>();
	}
	public static class SaveManager_SWITCH
	{
		private static string buildTitle = "ASCENDANCE";

		private static string dataPath = Application.persistentDataPath + "/SavesDir/";

		private static bool loadedData = false;

		private static bool initialized = false;

		public static OVSaveData data = new OVSaveData();

		public static bool HasKey(string key)
		{
			bool result = false;
			if (data.SavedFloat.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedInt.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedString.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedBool.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedVector2.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedVector3.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedQuaternion.ContainsKey(key))
			{
				result = true;
			}
			if (data.SavedColor.ContainsKey(key))
			{
				result = true;
			}
			return result;
		}

		public static void Initialize()
		{
		}

		public static void Unmount()
		{
		}

		public static int GetInt(string key, int defaultValue = 0)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			int value = defaultValue;
			if (!data.SavedInt.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetInt(key, defaultValue);
			}
			return value;
		}

		public static float GetFloat(string key, float defaultValue = 0f)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			float value = defaultValue;
			if (!data.SavedFloat.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetFloat(key, defaultValue);
			}
			return value;
		}

		public static string GetString(string key, string defaultValue = "")
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			string value = defaultValue;
			if (!data.SavedString.TryGetValue(key, out value))
			{
				value = PlayerPrefs.GetString(key, defaultValue);
			}
			return value;
		}

		public static bool GetBool(string key, bool defaultValue = false)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			bool value = defaultValue;
			data.SavedBool.TryGetValue(key, out value);
			return value;
		}

		public static Vector2 GetVector2(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Vector2 value = Vector2.zero;
			data.SavedVector2.TryGetValue(key, out value);
			return value;
		}

		public static Vector3 GetVector3(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Vector3 value = Vector3.zero;
			data.SavedVector3.TryGetValue(key, out value);
			return value;
		}

		public static Color GetColor(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Color value = Color.white;
			data.SavedColor.TryGetValue(key, out value);
			return value;
		}

		public static Quaternion GetQuaternion(string key)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!loadedData)
			{
				LoadData();
			}
			Quaternion value = Quaternion.identity;
			data.SavedQuaternion.TryGetValue(key, out value);
			return value;
		}

		public static void SetInt(string key, int setValue)
		{
			data.SavedInt[key] = setValue;
		}

		public static void SetFloat(string key, float setValue)
		{
			data.SavedFloat[key] = setValue;
		}

		public static void SetString(string key, string setValue)
		{
			data.SavedString[key] = setValue;
		}

		public static void SetBool(string key, bool setValue)
		{
			data.SavedBool[key] = setValue;
		}

		public static void SetVector2(string key, Vector2 setValue)
		{
			data.SavedVector2[key] = setValue;
		}

		public static void SetVector3(string key, Vector3 setValue)
		{
			data.SavedVector3[key] = setValue;
		}

		public static void SetQuaternion(string key, Quaternion setValue)
		{
			data.SavedQuaternion[key] = setValue;
		}

		public static void SetColor(string key, Color setValue)
		{
			data.SavedColor[key] = setValue;
		}

		public static void Save()
		{
		}

		public static void DeleteAll()
		{
			data.SavedInt.Clear();
			data.SavedFloat.Clear();
			data.SavedString.Clear();
			data.SavedBool.Clear();
			data.SavedVector2.Clear();
			data.SavedVector3.Clear();
			data.SavedQuaternion.Clear();
			data.SavedColor.Clear();
			Save();
		}

		public static bool LoadData()
		{
			loadedData = true;
			data.SavedInt.Clear();
			data.SavedFloat.Clear();
			data.SavedString.Clear();
			data.SavedBool.Clear();
			data.SavedVector2.Clear();
			data.SavedVector3.Clear();
			data.SavedQuaternion.Clear();
			data.SavedColor.Clear();
			UnityEngine.Debug.Log("Data Loaded");
			return true;
		}

		public static void DeleteKey(string keyToDel)
		{
			if (data.SavedInt.ContainsKey(keyToDel))
			{
				data.SavedInt.Remove(keyToDel);
			}
			if (data.SavedFloat.ContainsKey(keyToDel))
			{
				data.SavedFloat.Remove(keyToDel);
			}
			if (data.SavedString.ContainsKey(keyToDel))
			{
				data.SavedString.Remove(keyToDel);
			}
			if (data.SavedBool.ContainsKey(keyToDel))
			{
				data.SavedBool.Remove(keyToDel);
			}
			if (data.SavedVector2.ContainsKey(keyToDel))
			{
				data.SavedVector2.Remove(keyToDel);
			}
			if (data.SavedVector3.ContainsKey(keyToDel))
			{
				data.SavedVector3.Remove(keyToDel);
			}
			if (data.SavedQuaternion.ContainsKey(keyToDel))
			{
				data.SavedQuaternion.Remove(keyToDel);
			}
			if (data.SavedColor.ContainsKey(keyToDel))
			{
				data.SavedColor.Remove(keyToDel);
			}
		}
	}
	public class OVPlayerPrefs
	{
		private const string SaveFileName = "SavedGameData.txt";

		private const bool AutoSaveData = false;

		private static OVPlayerPrefsSaveFile _latestData;

		private const string String_Empty = "";

		public static void DeleteID(string ID)
		{
			GetSaveFile().DeleteID(ID);
			SaveSaveFile();
		}

		public static void DeleteAll()
		{
			WriteToSaveFile(JsonUtility.ToJson(new OVPlayerPrefsSaveFile()));
			_latestData = new OVPlayerPrefsSaveFile();
		}

		public static void Initialize()
		{
		}

		public static bool HasID(string ID)
		{
			return GetSaveFile().HasKey(ID);
		}

		public static void OverwriteLocalSaveFile(string data)
		{
			WriteToSaveFile(data);
			_latestData = null;
			UnityEngine.Debug.Log("File Saved and overwritten: " + GetSaveFileAsJson());
		}

		public static void Save()
		{
			SaveSaveFile();
		}

		public static void SetInt(string ID, int value = 0)
		{
			AddDataToSaveFile(ID, value);
		}

		public static void AddInt(string ID, int value = 0)
		{
			AddDataToSaveFile(ID, GetInt(ID) + value);
		}

		public static int GetInt(string ID, int defaultValue = 0)
		{
			return (int)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetFloat(string ID, float value = 0f)
		{
			AddDataToSaveFile(ID, value);
		}

		public static float GetFloat(string ID, float defaultValue = 0f)
		{
			return (float)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetString(string ID, string value = "")
		{
			AddDataToSaveFile(ID, value);
		}

		public static string GetString(string ID, string defaultValue = "")
		{
			return (string)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetBool(string ID, bool value = false)
		{
			AddDataToSaveFile(ID, value);
		}

		public static bool GetBool(string ID, bool defaultValue = false)
		{
			return (bool)GetDataFromSaveFile(ID, defaultValue);
		}

		public static void SetVector2(string ID, Vector2 vector)
		{
			SetFloatArray(ID, new float[2] { vector.x, vector.y });
		}

		public static Vector2 GetVector2(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 2);
			return new Vector2(floatArray[0], floatArray[1]);
		}

		public static void SetVector3(string ID, Vector3 vector)
		{
			SetFloatArray(ID, new float[3] { vector.x, vector.y, vector.z });
		}

		public static Vector3 GetVector3(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 3);
			return new Vector3(floatArray[0], floatArray[1], floatArray[2]);
		}

		public static void SetQuaternion(string ID, Quaternion vector)
		{
			SetFloatArray(ID, new float[4] { vector.x, vector.y, vector.z, vector.w });
		}

		public static Quaternion GetQuaternion(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 4);
			return new Quaternion(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
		}

		public static void SetColor(string ID, Color color)
		{
			SetFloatArray(ID, new float[4] { color.r, color.g, color.b, color.a });
		}

		public static Color GetColor(string ID)
		{
			float[] floatArray = GetFloatArray(ID, 4);
			return new Color(floatArray[0], floatArray[1], floatArray[2], floatArray[3]);
		}

		private static void AddDataToSaveFile(string ID, object value)
		{
			GetSaveFile().UpdateOrAddData(ID, value);
			SaveSaveFile();
		}

		private static void SaveSaveFile()
		{
			WriteToSaveFile(JsonUtility.ToJson(GetSaveFile()));
			SendSaveData();
		}

		private static void SendSaveData()
		{
		}

		private static void WriteToSaveFile(string data)
		{
			StreamWriter streamWriter = new StreamWriter(GetSaveFilePath());
			streamWriter.Write(data);
			streamWriter.Close();
		}

		public static string GetSaveFilePath()
		{
			return Path.Combine(Application.persistentDataPath, "SavedGameData.txt");
		}

		public static string GetSaveFileAsJson()
		{
			CheckSaveFileExists();
			return File.ReadAllText(GetSaveFilePath());
		}

		private static OVPlayerPrefsSaveFile GetSaveFile()
		{
			CheckSaveFileExists();
			if (_latestData == null)
			{
				_latestData = JsonUtility.FromJson<OVPlayerPrefsSaveFile>(File.ReadAllText(GetSaveFilePath()));
			}
			return _latestData;
		}

		private static object GetDataFromSaveFile(string ID, object defaultValue)
		{
			return GetSaveFile().GetValueFromKey(ID, defaultValue);
		}

		private static void SetFloatArray(string ID, float[] floatArray)
		{
			for (int i = 0; i < floatArray.Length; i++)
			{
				SetFloat(OVStrings.FLOATARRAY_PREFIX + ID + i, floatArray[i]);
			}
		}

		private static float[] GetFloatArray(string ID, int length)
		{
			float[] array = new float[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = GetFloat(OVStrings.FLOATARRAY_PREFIX + ID + i);
			}
			return array;
		}

		private static void CheckSaveFileExists()
		{
			if (!DoesSaveFileExist())
			{
				CreateNewSaveFile();
			}
		}

		private static bool DoesSaveFileExist()
		{
			return File.Exists(GetSaveFilePath());
		}

		private static void CreateNewSaveFile()
		{
			WriteToSaveFile(JsonUtility.ToJson(new OVPlayerPrefsSaveFile()));
		}
	}
	[Serializable]
	public class OVPlayerPrefsSaveFile
	{
		[Serializable]
		public class StringItem
		{
			public string Key;

			public string Value;

			public StringItem(string K, string V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class IntItem
		{
			public string Key;

			public int Value;

			public IntItem(string K, int V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class FloatItem
		{
			public string Key;

			public float Value;

			public FloatItem(string K, float V)
			{
				Key = K;
				Value = V;
			}
		}

		[Serializable]
		public class BoolItem
		{
			public string Key;

			public bool Value;

			public BoolItem(string K, bool V)
			{
				Key = K;
				Value = V;
			}
		}

		public StringItem[] StringData = new StringItem[0];

		public IntItem[] IntData = new IntItem[0];

		public FloatItem[] FloatData = new FloatItem[0];

		public BoolItem[] BoolData = new BoolItem[0];

		public object GetValueFromKey(string ID, object defaultValue)
		{
			if (defaultValue is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						return StringData[i].Value;
					}
				}
			}
			if (defaultValue is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						return IntData[j].Value;
					}
				}
			}
			if (defaultValue is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						return FloatData[k].Value;
					}
				}
			}
			if (defaultValue is bool)
			{
				for (int l = 0; l < BoolData.Length; l++)
				{
					if (BoolData[l].Key.Equals(ID))
					{
						return BoolData[l].Value;
					}
				}
			}
			return defaultValue;
		}

		public void UpdateOrAddData(string ID, object value)
		{
			if (HasKeyFromObject(ID, value))
			{
				SetValueForExistingKey(ID, value);
			}
			else
			{
				SetValueForNewKey(ID, value);
			}
		}

		private void SetValueForNewKey(string ID, object value)
		{
			if (value is string)
			{
				List<StringItem> list = StringData.ToList();
				list.Add(new StringItem(ID, (string)value));
				StringData = list.ToArray();
			}
			if (value is int)
			{
				List<IntItem> list2 = IntData.ToList();
				list2.Add(new IntItem(ID, (int)value));
				IntData = list2.ToArray();
			}
			if (value is float)
			{
				List<FloatItem> list3 = FloatData.ToList();
				list3.Add(new FloatItem(ID, (float)value));
				FloatData = list3.ToArray();
			}
			if (value is bool)
			{
				List<BoolItem> list4 = BoolData.ToList();
				list4.Add(new BoolItem(ID, (bool)value));
				BoolData = list4.ToArray();
			}
		}

		private void SetValueForExistingKey(string ID, object value)
		{
			if (value is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						StringData[i].Value = (string)value;
					}
				}
			}
			if (value is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						IntData[j].Value = (int)value;
					}
				}
			}
			if (value is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						FloatData[k].Value = (float)value;
					}
				}
			}
			if (!(value is bool))
			{
				return;
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					BoolData[l].Value = (bool)value;
				}
			}
		}

		public bool HasKeyFromObject(string ID, object value)
		{
			if (value is string)
			{
				for (int i = 0; i < StringData.Length; i++)
				{
					if (StringData[i].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is int)
			{
				for (int j = 0; j < IntData.Length; j++)
				{
					if (IntData[j].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is float)
			{
				for (int k = 0; k < FloatData.Length; k++)
				{
					if (FloatData[k].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			if (value is bool)
			{
				for (int l = 0; l < BoolData.Length; l++)
				{
					if (BoolData[l].Key.Equals(ID))
					{
						return true;
					}
				}
			}
			return false;
		}

		public void DeleteID(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					List<StringItem> list = StringData.ToList();
					list.RemoveAt(i);
					StringData = list.ToArray();
				}
			}
			for (int j = 0; j < IntData.Length; j++)
			{
				if (IntData[j].Key.Equals(ID))
				{
					List<IntItem> list2 = IntData.ToList();
					list2.RemoveAt(j);
					IntData = list2.ToArray();
				}
			}
			for (int k = 0; k < FloatData.Length; k++)
			{
				if (FloatData[k].Key.Equals(ID))
				{
					List<FloatItem> list3 = FloatData.ToList();
					list3.RemoveAt(k);
					FloatData = list3.ToArray();
				}
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					List<BoolItem> list4 = BoolData.ToList();
					list4.RemoveAt(l);
					BoolData = list4.ToArray();
				}
			}
		}

		public void DeleteString(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					List<StringItem> list = StringData.ToList();
					list.RemoveAt(i);
					StringData = list.ToArray();
				}
			}
		}

		public void DeleteInt(string ID)
		{
			for (int i = 0; i < IntData.Length; i++)
			{
				if (IntData[i].Key.Equals(ID))
				{
					List<IntItem> list = IntData.ToList();
					list.RemoveAt(i);
					IntData = list.ToArray();
				}
			}
		}

		public void DeleteFloat(string ID)
		{
			for (int i = 0; i < FloatData.Length; i++)
			{
				if (FloatData[i].Key.Equals(ID))
				{
					List<FloatItem> list = FloatData.ToList();
					list.RemoveAt(i);
					FloatData = list.ToArray();
				}
			}
		}

		public void DeleteBool(string ID)
		{
			for (int i = 0; i < BoolData.Length; i++)
			{
				if (BoolData[i].Key.Equals(ID))
				{
					List<BoolItem> list = BoolData.ToList();
					list.RemoveAt(i);
					BoolData = list.ToArray();
				}
			}
		}

		public bool HasKey(string ID)
		{
			for (int i = 0; i < StringData.Length; i++)
			{
				if (StringData[i].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int j = 0; j < IntData.Length; j++)
			{
				if (IntData[j].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int k = 0; k < FloatData.Length; k++)
			{
				if (FloatData[k].Key.Equals(ID))
				{
					return true;
				}
			}
			for (int l = 0; l < BoolData.Length; l++)
			{
				if (BoolData[l].Key.Equals(ID))
				{
					return true;
				}
			}
			return false;
		}
	}
	public class WTFContinuesRotation : MonoBehaviour
	{
		public enum Axis
		{
			forward,
			right,
			up,
			none
		}

		public Axis axis;

		public float speed;

		private void Update()
		{
			Vector3 vector = Vector3.zero;
			if (axis == Axis.forward)
			{
				vector = Vector3.forward;
			}
			if (axis == Axis.right)
			{
				vector = Vector3.right;
			}
			if (axis == Axis.up)
			{
				vector = Vector3.up;
			}
			base.transform.Rotate(vector * Time.unscaledDeltaTime * speed);
		}
	}
	public class WTFTextureAnimator : MonoBehaviour
	{
		[Header("General Setup")]
		public float framesPerSecond = 10f;

		[Header("Renderer Only Values")]
		public bool useRenderer;

		public Renderer targetRenderer;

		public Texture[] frames_Tex;

		[Header("Image Only Values")]
		public bool useImage;

		public Image image;

		public Sprite[] frames_Sprite;

		private void Update()
		{
			if (useRenderer)
			{
				int num = (int)(Time.time * framesPerSecond) % frames_Tex.Length;
				targetRenderer.material.mainTexture = frames_Tex[num];
			}
			if (useImage)
			{
				int num2 = (int)(Time.time * framesPerSecond) % frames_Sprite.Length;
				image.sprite = frames_Sprite[num2];
			}
		}
	}
	public class InfoAttribute : PropertyAttribute
	{
	}
	public class ReadOnlyAttribute : PropertyAttribute
	{
	}
	public class WTFGenericSingleton<T> : MonoBehaviour where T : Component
	{
		private static T instance;

		public static T Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<T>();
					if (instance == null)
					{
						instance = new GameObject
						{
							name = typeof(T).Name
						}.AddComponent<T>();
					}
				}
				return instance;
			}
		}

		protected virtual void Awake()
		{
			if (instance == null)
			{
				instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class WTFPlatformDependance : MonoBehaviour
	{
		[Header("Enable for following Platforms")]
		public bool editor;

		public bool standalone;

		public bool mobile;

		public bool consoles;

		[Header("Console Specific")]
		public bool xbox;

		public bool nintendoSwitch;

		public bool ps;

		private void Awake()
		{
			if (mobile)
			{
				base.gameObject.SetActive(value: true);
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class WTFPlatformDependantSpawner : MonoBehaviour
	{
		public bool spawnOnAwake = true;

		[Header("Main Spawns")]
		public GameObject[] pc;

		public GameObject[] xbox;

		public GameObject[] nintendoSwitch;

		public GameObject[] playstation;

		public GameObject[] uwp;

		[Header("Additional PC Spawns")]
		public GameObject[] oculus;

		public GameObject[] vive;

		private void Awake()
		{
			Spawn();
		}

		public void Spawn()
		{
			GameObject[] array = pc;
			if (array.Length != 0)
			{
				GameObject[] array2 = array;
				foreach (GameObject gameObject in array2)
				{
					UnityEngine.Object.Instantiate(gameObject, null).name = gameObject.name;
				}
			}
			base.gameObject.SetActive(value: false);
		}
	}
	public class MenuController : WTFGenericSingleton<MenuController>
	{
		public enum State
		{
			MainMenu,
			PauseMenu,
			NoMenu
		}

		public int menuSceneIndex = 1;

		private State state;

		[Header("Event System")]
		public EventSystem eventSystem;

		public Animator langMenuCanvas;

		public Animator loadingCanvas;

		public Animator mainMenuCanvas;

		public Animator pauseMenuCanvas;

		public GameObject firstMainMenuResponder;

		public GameObject firstPauseMenuResponder;

		[Header("Audio")]
		public AudioMixer mixer;

		public AudioSource hoverAudio;

		public AudioSource clickAudio;

		public Slider volumeSlider;

		public Slider sfxSlider;

		public Slider musicSlider;

		[Header("Resolution")]
		public Text resolutionText;

		public Text qualityText;

		private int currentResolution;

		private int currentQuality;

		[Header("Mouse Settings")]
		public Slider mouseSlider;

		public Toggle mouseInvertToggle;

		[Header("VR")]
		public GameObject vrCamera;

		[Space]
		private bool inMenu;

		private int savedLevel;

		private GameObject lastInteractable;

		private Material skxBoxMat;

		[SerializeField]
		[ReadOnly]
		private float defaultSkyboxExposure;

		private Coroutine fadeCoroutine;

		private const string exposureParameter = "_Exposure";

		private void OnValidate()
		{
			defaultSkyboxExposure = RenderSettings.skybox.GetFloat("_Exposure");
		}

		private void OnEnable()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}

		private void Start()
		{
			Load();
			if (Input.GetJoystickNames().Length != 0)
			{
				eventSystem.GetComponent<StandaloneInputModule>().forceModuleActive = true;
				eventSystem.SetSelectedGameObject(firstMainMenuResponder);
			}
			skxBoxMat = RenderSettings.skybox;
			if (defaultSkyboxExposure == 0f)
			{
				defaultSkyboxExposure = skxBoxMat.GetFloat("_Exposure");
			}
		}

		private void OnDestroy()
		{
			skxBoxMat.SetFloat("_Exposure", defaultSkyboxExposure);
		}

		private void Update()
		{
			if (eventSystem.currentSelectedGameObject != null)
			{
				lastInteractable = eventSystem.currentSelectedGameObject;
			}
			else if (inMenu || SceneManager.GetActiveScene().buildIndex == menuSceneIndex)
			{
				eventSystem.SetSelectedGameObject(lastInteractable);
			}
			if (SceneManager.GetActiveScene().buildIndex != menuSceneIndex && (pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f) || pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(1f)) && SceneManager.GetActiveScene().buildIndex != menuSceneIndex && (Input.GetButtonDown("Cancel") || Input.GetKeyDown(KeyCode.Escape) || Input.GetKeyDown(KeyCode.JoystickButton7) || Input.GetKeyDown(KeyCode.Joystick1Button7) || Input.GetKeyDown(KeyCode.JoystickButton2)))
			{
				Pause();
				Resume();
			}
		}

		private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
		{
			FadeOut(loadingCanvas);
			if (fadeCoroutine != null)
			{
				StopCoroutine(fadeCoroutine);
			}
			fadeCoroutine = StartCoroutine(FadeSkybox(0f, defaultSkyboxExposure));
			vrCamera.SetActive(value: false);
			Time.timeScale = 1f;
			if (SceneManager.GetActiveScene().Equals(SceneManager.GetSceneByBuildIndex(menuSceneIndex)))
			{
				state = State.MainMenu;
				FadeIn(langMenuCanvas);
				Select(firstMainMenuResponder);
			}
			else
			{
				state = State.NoMenu;
				inMenu = false;
			}
		}

		private IEnumerator FadeSkybox(float start, float end)
		{
			float time = 0f;
			Material skyboxMat = RenderSettings.skybox;
			while (time < 1f)
			{
				time += Time.unscaledDeltaTime;
				float value = Mathf.Lerp(start, end, time);
				skyboxMat.SetFloat("_Exposure", value);
				yield return null;
			}
		}

		public void Load()
		{
			if (OVPlayerPrefs.GetInt("LAUNCHEDBEFORE") == 1)
			{
				SetSlider(volumeSlider, OVPlayerPrefs.GetFloat("VOLUME"));
				SetSlider(musicSlider, OVPlayerPrefs.GetFloat("MUSIC"));
				SetSlider(sfxSlider, OVPlayerPrefs.GetFloat("SFX"));
				SetVolume(OVPlayerPrefs.GetFloat("VOLUME"));
				SetMusic(OVPlayerPrefs.GetFloat("MUSIC"));
				SetSfx(OVPlayerPrefs.GetFloat("SFX"));
				currentResolution = OVPlayerPrefs.GetInt("RESOLUTION");
				currentQuality = OVPlayerPrefs.GetInt("QUALITY");
				mouseSlider.value = OVPlayerPrefs.GetFloat("MOUSE");
				if (OVPlayerPrefs.GetInt("INVERT") == 1)
				{
					mouseInvertToggle.isOn = true;
				}
				else
				{
					mouseInvertToggle.isOn = false;
				}
			}
			else
			{
				OVPlayerPrefs.SetInt("LAUNCHEDBEFORE", 1);
				SetSlider(volumeSlider, 0f);
				SetSlider(musicSlider, 0f);
				SetSlider(sfxSlider, 0f);
				OVPlayerPrefs.SetInt("RESOLUTION", Screen.resolutions.Length - 1);
				currentResolution = Screen.resolutions.Length - 1;
				OVPlayerPrefs.SetInt("QUALITY", Screen.resolutions.Length - 1);
				currentQuality = Screen.resolutions.Length - 1;
				OVPlayerPrefs.SetFloat("MOUSE", mouseSlider.value);
				OVPlayerPrefs.SetInt("INVERT", 1);
				OVPlayerPrefs.Save();
			}
			if (currentResolution >= Screen.resolutions.Length)
			{
				currentResolution = Screen.resolutions.Length - 1;
			}
			ChangeResolution(0);
			if (currentQuality >= QualitySettings.names.Length)
			{
				currentQuality = QualitySettings.names.Length - 1;
			}
			ChangeQuality(0);
		}

		public void SetSlider(Slider slider, float value)
		{
			slider.value = value;
		}

		public void SetVolume(float value)
		{
			mixer.SetFloat("Volume", value);
			OVPlayerPrefs.SetFloat("VOLUME", value);
			OVPlayerPrefs.Save();
		}

		public void SetSfx(float value)
		{
			mixer.SetFloat("Sfx", value);
			OVPlayerPrefs.SetFloat("SFX", value);
			OVPlayerPrefs.Save();
		}

		public void SetMusic(float value)
		{
			mixer.SetFloat("Music", value);
			OVPlayerPrefs.SetFloat("MUSIC", value);
			OVPlayerPrefs.Save();
		}

		public void SetMouseSens(float value)
		{
			OVPlayerPrefs.SetFloat("MOUSE", value);
			OVPlayerPrefs.Save();
		}

		public void SetMouseInvert(bool value)
		{
			int value2 = 0;
			if (value)
			{
				value2 = 1;
			}
			OVPlayerPrefs.SetInt("INVERT", value2);
			OVPlayerPrefs.Save();
		}

		public void ChangeResolution(int i)
		{
			if (Screen.resolutions.Length == 0)
			{
				UnityEngine.Debug.Log("There are no screen resolutions defined\n");
				return;
			}
			currentResolution += i;
			if (currentResolution >= Screen.resolutions.Length)
			{
				currentResolution = 0;
			}
			else if (currentResolution < 0)
			{
				currentResolution = Screen.resolutions.Length - 1;
			}
			Screen.SetResolution(Screen.resolutions[currentResolution].width, Screen.resolutions[currentResolution].height, fullscreen: true);
			resolutionText.text = Screen.resolutions[currentResolution].ToString();
			OVPlayerPrefs.SetInt("RESOLUTION", currentResolution);
			OVPlayerPrefs.Save();
		}

		public void ChangeQuality(int i)
		{
			currentQuality += i;
			if (currentQuality >= QualitySettings.names.Length)
			{
				currentQuality = 0;
			}
			else if (currentQuality < 0)
			{
				currentQuality = QualitySettings.names.Length - 1;
			}
			QualitySettings.SetQualityLevel(currentQuality);
			qualityText.text = QualitySettings.names[currentQuality];
			OVPlayerPrefs.SetInt("QUALITY", currentQuality);
			OVPlayerPrefs.Save();
		}

		public void LoadLevel(int i)
		{
			FadeIn(loadingCanvas);
			if (fadeCoroutine != null)
			{
				StopCoroutine(fadeCoroutine);
			}
			fadeCoroutine = StartCoroutine(FadeSkybox(defaultSkyboxExposure, 0f));
			Time.timeScale = 0f;
			StartCoroutine(LoadLevelDelayed(i));
		}

		public IEnumerator LoadLevelDelayed(int i)
		{
			yield return new WaitForSecondsRealtime(1f);
			SceneManager.LoadScene(i + 1);
		}

		public void Quit(bool sure)
		{
			Application.Quit();
		}

		public void Resume()
		{
			if (!pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f))
			{
				inMenu = false;
				Unselect();
				state = State.NoMenu;
				FadeOut(pauseMenuCanvas);
				vrCamera.SetActive(value: false);
				PauseController pauseController = UnityEngine.Object.FindObjectOfType<PauseController>();
				if (pauseController != null)
				{
					pauseController.UnPause_External();
				}
			}
		}

		public void Pause()
		{
			if (!inMenu && pauseMenuCanvas.GetComponent<CanvasGroup>().alpha.Equals(0f))
			{
				inMenu = true;
				Select(firstPauseMenuResponder);
				state = State.PauseMenu;
				FadeIn(pauseMenuCanvas);
				vrCamera.SetActive(value: true);
				UnityEngine.Debug.Log("Publish Pause - MenuController");
				PauseController pauseController = UnityEngine.Object.FindObjectOfType<PauseController>();
				if (pauseController == null)
				{
					UnityEngine.Debug.Log("Pause Equals Null!");
				}
				if (pauseController != null)
				{
					pauseController.Pause_External();
				}
			}
		}

		private void StopKeyBlock(CanvasGroup canvasGroup)
		{
			canvasGroup.blocksRaycasts = false;
		}

		public void FadeIn(Animator animator)
		{
			animator.SetBool("FadeIn", value: true);
		}

		public void FadeOut(Animator animator)
		{
			animator.SetBool("FadeIn", value: false);
		}

		public void FadeInFirstMenu()
		{
			if (state == State.MainMenu)
			{
				FadeIn(mainMenuCanvas);
				Select(firstMainMenuResponder);
			}
			else
			{
				FadeIn(pauseMenuCanvas);
				Select(firstPauseMenuResponder);
			}
		}

		public void Unselect()
		{
			if (Input.GetJoystickNames().Length != 0)
			{
				BaseEventData eventData = new BaseEventData(eventSystem);
				if (eventSystem != null && eventSystem.currentSelectedGameObject != null && eventSystem.currentSelectedGameObject.GetComponent<Selectable>() != null)
				{
					eventSystem.currentSelectedGameObject.GetComponent<Selectable>().OnDeselect(eventData);
				}
			}
		}

		public void Select(GameObject g)
		{
			if (Input.GetJoystickNames().Length != 0)
			{
				Unselect();
				StartCoroutine(SelectDelayed(g));
			}
		}

		private IEnumerator SelectDelayed(GameObject g)
		{
			yield return new WaitForSeconds(0.05f);
			eventSystem.SetSelectedGameObject(g);
			BaseEventData eventData = new BaseEventData(eventSystem);
			g.GetComponent<Selectable>().OnSelect(eventData);
		}

		public void SetEventSystem(GameObject g)
		{
			eventSystem.SetSelectedGameObject(g);
		}

		public void PlayHoverSound()
		{
			if (!hoverAudio.isPlaying)
			{
				hoverAudio.Play();
			}
		}

		public void PlayClickSound()
		{
			if (!clickAudio.isPlaying)
			{
				clickAudio.Play();
			}
		}

		public void FadeOutAudio(AudioSource audio)
		{
			if (audio != null)
			{
				StartCoroutine(FadeOutAudioOverTime(audio));
			}
		}

		public IEnumerator FadeOutAudioOverTime(AudioSource audio)
		{
			while (audio.volume > 0f && audio != null)
			{
				audio.volume -= 0.025f;
				yield return null;
			}
		}

		public void SetInput(int i)
		{
			OVPlayerPrefs.SetInt("Input", i);
			OVPlayerPrefs.Save();
		}

		public void LoadSavedLevel()
		{
			LoadLevel(savedLevel);
		}
	}
	public class rendererRemover : MonoBehaviour
	{
		public int value = 2;

		[Button(null, EButtonEnableMode.Always)]
		public void RemoveRenderer()
		{
			MeshRenderer[] componentsInChildren = GetComponentsInChildren<MeshRenderer>();
			for (int i = 0; i < componentsInChildren.Length; i += value)
			{
				componentsInChildren[i].gameObject.SetActive(value: false);
			}
		}
	}
	[ExecuteInEditMode]
	public class setparent : MonoBehaviour
	{
		public Transform newParent;

		private void OnEnable()
		{
			if (newParent != null)
			{
				SetParent();
			}
		}

		[Button(null, EButtonEnableMode.Always)]
		public void SetParent()
		{
			base.transform.parent = newParent;
		}
	}
	namespace StylizedWaterShader
	{
		[RequireComponent(typeof(Camera))]
		[ExecuteInEditMode]
		public class EnableDepthBuffer : MonoBehaviour
		{
			private Camera cam;

			private void OnEnable()
			{
				Set();
			}

			private void OnDisable()
			{
				Unset();
			}

			public void Set()
			{
				if (!cam)
				{
					cam = GetComponent<Camera>();
				}
				cam.depthTextureMode |= DepthTextureMode.Depth;
			}

			public void Unset()
			{
				cam.depthTextureMode |= DepthTextureMode.None;
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(MeshRenderer))]
		[HelpURL("http://staggart.xyz/unity/stylized-water-shader/documentation/")]
		public class StylizedWater : MonoBehaviour
		{
			public string[] shaderNames;

			public int shaderIndex;

			public Shader shader;

			private Shader DesktopShader;

			private Shader MobileAdvancedShader;

			[Range(2000f, 4000f)]
			public int renderQueue;

			public bool enableVertexColors;

			public bool isUnlit;

			public bool enableGradient;

			public Gradient colorGradient;

			[ColorUsage(true, true)]
			public Color waterShallowColor;

			[Range(0f, 100f)]
			public float depth;

			[ColorUsage(true, true)]
			public Color waterColor;

			[ColorUsage(true, true)]
			public Color fresnelColor;

			public float fresnel;

			[ColorUsage(true, true)]
			public Color rimColor;

			[Range(-0.5f, 0.5f)]
			public float waveTint;

			public bool pixelate;

			[Range(0f, 1f)]
			public float transparency;

			[Range(0.01f, 1f)]
			public float glossiness;

			[Range(0f, 1f)]
			public float metallicness;

			[Range(0f, 3f)]
			public float edgeFade;

			public string[] tilingMethodNames;

			public float worldSpaceTiling;

			[Range(0f, 0.2f)]
			public float refractionAmount;

			public bool enableNormalMap = true;

			[Range(0f, 1f)]
			public float normalStrength;

			public bool enableMacroNormals;

			[Range(250f, 3000f)]
			public float macroNormalsDistance = 1000f;

			[Range(0f, 50f)]
			public float normalTiling;

			public int intersectionSolver;

			public string[] intersectionSolverNames;

			[Range(0f, 30f)]
			public float rimSize;

			[Range(0.1f, 30f)]
			public float rimFalloff;

			public float rimTiling;

			[Range(0f, 1f)]
			public float rimDistortion;

			public bool enableVCIntersection;

			public int foamSolver;

			public string[] foamSolverNames;

			[Range(-1f, 1f)]
			public float foamOpacity;

			public float foamTiling;

			[Range(0f, 1f)]
			public float foamSize;

			[Range(0f, 3f)]
			public float foamDistortion;

			[Range(0f, 1f)]
			public float foamSpeed;

			[Range(0f, 1f)]
			public float waveFoam;

			[Range(0f, 1f)]
			public float reflectionStrength = 1f;

			[Range(2f, 10f)]
			public float reflectionFresnel = 10f;

			public bool showReflection;

			[Range(0f, 0.2f)]
			public float reflectionRefraction;

			[Range(0.01f, 10f)]
			public float waveSpeed;

			[Range(0f, 1f)]
			public float waveStrength;

			[Range(-1f, 1f)]
			public Vector4 waveDirectionXZ;

			public bool enableSecondaryWaves;

			public Texture2D customIntersection;

			public Texture2D customNormal;

			public Texture2D customHeightmap;

			[Range(0.01f, 20f)]
			public float tessellation;

			public string[] intersectionStyleNames;

			public int intersectionStyle = 1;

			public string[] waveStyleNames;

			public int waveStyle;

			public string[] waveHeightmapNames;

			public int waveHeightmapStyle;

			public float waveSize;

			public bool useCustomIntersection;

			public bool useCustomNormals;

			public bool useCustomHeightmap;

			public Texture2D normals;

			public Texture2D shadermap;

			public Texture2D colorGradientTex;

			public bool useCompression;

			public static bool EnableReflections;

			private Camera reflectionCamera;

			private Camera refractCamera;

			public bool useReflection;

			public bool useRefractionCam;

			public bool enableReflectionBlur;

			[Range(1f, 15f)]
			public float reflectionBlurLength = 4f;

			[Range(1f, 4f)]
			public int reflectionBlurPasses = 4;

			private StylizedWaterBlur reflectionBlurRenderer;

			public string[] refractionSolverNames;

			public int refractionSolver;

			public string[] resolutionNames;

			public int reflectionRes = 1;

			public int refractRes = 2;

			public int reflectionTextureSize = 512;

			public int refractTextureSize = 1024;

			[Range(0f, 10f)]
			public float clipPlaneOffset = 1f;

			public LayerMask reflectLayers = -1;

			public LayerMask refractLayers = -1;

			private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

			private Dictionary<Camera, StylizedWaterBlur> m_BlurRenderers = new Dictionary<Camera, StylizedWaterBlur>();

			private Dictionary<Camera, Camera> m_RefractCameras = new Dictionary<Camera, Camera>();

			private RenderTexture m_ReflectionTexture;

			private RenderTexture m_RefractTexture;

			private int m_OldReflectionTextureSize;

			private int m_OldRefractTextureSize;

			private bool s_InsideRendering;

			public bool enableMaskRendering;

			private StylizedWaterRenderer swsRenderer;

			private StylizedWaterRenderer.RendererSettings swsRenderSettings;

			public int swsRendererTextureSize = 1024;

			public LayerMask swsMaskRenderLayers;

			public static LayerMask s_swsMaskRenderLayers;

			public Camera renderCam;

			public Vector4 targetMeshInfo;

			public int lightingMethod = 2;

			public string[] lightingMethodNames;

			public bool enableShadows;

			private StylizedWaterShadowCaster shadowRenderer;

			public Light shadowCaster;

			[NonSerialized]
			private MeshRenderer meshRenderer;

			public Material material;

			public bool isMobileAdvanced;

			public bool isMobilePlatform;

			public bool isMobileBasic;

			public string shaderName;

			public bool isWaterLayer;

			public bool hasShaderParams;

			public bool hasMaterial;

			public bool usingSinglePassRendering;

			[Header("Toggles")]
			public bool showLighting;

			public bool showColors = true;

			public bool showSurface;

			public bool showNormals;

			public bool showIntersection;

			public bool showHighlights;

			public bool showDepth;

			public bool showWaves;

			public bool showAdvanced;

			public bool hideMaterialInspector = true;

			public bool hideMeshRenderer = true;

			public bool realtimeEditing;

			public void OnEnable()
			{
				if (!meshRenderer)
				{
					meshRenderer = GetComponent<MeshRenderer>();
				}
				GetProperties();
				SetProperties();
			}

			public void Init()
			{
			}

			public void GetProperties()
			{
			}

			private void GetShaderProperties()
			{
				if (!material)
				{
					hasMaterial = false;
					return;
				}
				hasMaterial = true;
				renderQueue = material.renderQueue;
				GetShaderType();
				if (!material.IsKeywordEnabled("_LIGHTING_ON") && material.GetFloat("_Unlit") == 1f)
				{
					lightingMethod = 0;
				}
				else if (!material.IsKeywordEnabled("_LIGHTING_ON") && material.GetFloat("_Unlit") == 0f)
				{
					lightingMethod = 1;
				}
				else
				{
					lightingMethod = 2;
				}
				enableVertexColors = material.GetFloat("_ENABLE_VC") == 1f;
				shadermap = material.GetTexture("_Shadermap") as Texture2D;
				normals = material.GetTexture("_Normals") as Texture2D;
				waterColor = material.GetColor("_WaterColor");
				waterShallowColor = material.GetColor("_WaterShallowColor");
				depth = material.GetFloat("_Depth");
				waveTint = material.GetFloat("_Wavetint");
				rimColor = material.GetColor("_RimColor");
				worldSpaceTiling = material.GetFloat("_Worldspacetiling");
				transparency = material.GetFloat("_Transparency");
				edgeFade = material.GetFloat("_EdgeFade");
				glossiness = material.GetFloat("_Glossiness");
				metallicness = material.GetFloat("_Metallicness");
				normalStrength = material.GetFloat("_NormalStrength");
				normalTiling = material.GetFloat("_NormalTiling");
				foamOpacity = material.GetFloat("_FoamOpacity");
				foamSolver = (int)material.GetFloat("_UseIntersectionFoam");
				foamTiling = material.GetFloat("_FoamTiling");
				foamSize = material.GetFloat("_FoamSize");
				foamSpeed = material.GetFloat("_FoamSpeed");
				waveFoam = material.GetFloat("_WaveFoam");
				intersectionSolver = (int)material.GetFloat("_USE_VC_INTERSECTION");
				rimSize = material.GetFloat("_RimSize");
				rimFalloff = material.GetFloat("_Rimfalloff");
				rimTiling = material.GetFloat("_Rimtiling");
				waveSpeed = material.GetFloat("_Wavesspeed");
				waveDirectionXZ = material.GetVector("_WaveDirection");
				waveStrength = material.GetFloat("_WaveHeight");
				waveSize = material.GetFloat("_WaveSize");
				if (!isMobileBasic && !isMobileAdvanced)
				{
					enableShadows = material.GetFloat("_ENABLE_SHADOWS") == 1f;
					enableNormalMap = true;
					enableGradient = material.GetFloat("_ENABLE_GRADIENT") == 1f;
					fresnelColor = material.GetColor("_FresnelColor");
					fresnel = material.GetFloat("_Fresnelexponent");
					refractionAmount = material.GetFloat("_RefractionAmount");
					foamDistortion = material.GetFloat("_FoamDistortion");
					if (useReflection)
					{
						reflectionStrength = material.GetFloat("_ReflectionStrength");
					}
					reflectionFresnel = material.GetFloat("_ReflectionFresnel");
					reflectionRefraction = material.GetFloat("_ReflectionRefraction");
					rimDistortion = material.GetFloat("_RimDistortion");
					enableMacroNormals = material.IsKeywordEnabled("_MACRO_WAVES_ON");
					macroNormalsDistance = material.GetFloat("_MacroBlendDistance");
					enableSecondaryWaves = material.IsKeywordEnabled("_SECONDARY_WAVES_ON");
				}
				if (isMobileAdvanced)
				{
					enableNormalMap = material.IsKeywordEnabled("_NORMAL_MAP_ON");
					intersectionSolver = (int)material.GetFloat("_USE_VC_INTERSECTION");
					foamSolver = (material.IsKeywordEnabled("_USEINTERSECTIONFOAM_ON") ? 1 : 0);
				}
				hasShaderParams = true;
			}

			private void GetShaderType()
			{
			}

			private void SetShaderType()
			{
			}

			public void SetProperties()
			{
				if (enableMaskRendering)
				{
					if ((bool)renderCam)
					{
						renderCam.cullingMask = swsMaskRenderLayers.value;
						s_swsMaskRenderLayers = swsMaskRenderLayers;
					}
					else
					{
						EnableMaskRendering();
					}
				}
				else
				{
					DisableMaskRendering();
				}
				if (enableShadows && (bool)shadowCaster)
				{
					EnableShadowRendering();
				}
				else
				{
					DisableShadowRendering();
				}
				SetShaderProperties();
			}

			private void SetShaderProperties()
			{
				if (!material)
				{
					return;
				}
				SetShaderType();
				material.renderQueue = renderQueue;
				if ((bool)shadermap)
				{
					material.SetTexture("_Shadermap", shadermap);
				}
				if ((bool)normals)
				{
					material.SetTexture("_Normals", normals);
				}
				switch (lightingMethod)
				{
				case 0:
					material.DisableKeyword("_LIGHTING_ON");
					material.SetFloat("_Unlit", 1f);
					break;
				case 1:
					material.DisableKeyword("_LIGHTING_ON");
					material.SetFloat("_Unlit", 0f);
					break;
				case 2:
					material.EnableKeyword("_LIGHTING_ON");
					material.SetFloat("_Unlit", 0f);
					break;
				}
				material.SetColor("_WaterColor", waterColor);
				material.SetColor("_WaterShallowColor", waterShallowColor);
				material.SetFloat("_Depth", depth);
				material.SetColor("_RimColor", rimColor);
				material.SetFloat("_Wavetint", waveTint);
				material.SetFloat("_Transparency", transparency);
				material.SetFloat("_Glossiness", glossiness);
				material.SetFloat("_Metallicness", metallicness);
				material.SetFloat("_Worldspacetiling", worldSpaceTiling);
				material.SetFloat("_EdgeFade", edgeFade);
				material.SetFloat("_NormalStrength", normalStrength);
				material.SetFloat("_NormalTiling", normalTiling);
				material.SetFloat("_USE_VC_INTERSECTION", intersectionSolver);
				material.SetFloat("_RimSize", rimSize);
				material.SetFloat("_Rimfalloff", rimFalloff);
				material.SetFloat("_Rimtiling", rimTiling);
				material.SetFloat("_UseIntersectionFoam", foamSolver);
				material.SetFloat("_FoamOpacity", foamOpacity);
				material.SetFloat("_FoamSize", foamSize);
				material.SetFloat("_FoamTiling", foamTiling);
				material.SetFloat("_FoamSpeed", foamSpeed);
				material.SetFloat("_WaveFoam", waveFoam);
				material.SetFloat("_Wavesspeed", waveSpeed);
				material.SetVector("_WaveDirection", waveDirectionXZ);
				material.SetFloat("_WaveHeight", waveStrength);
				material.SetFloat("_WaveSize", waveSize);
				material.SetFloat("_ENABLE_VC", enableVertexColors ? 1 : 0);
				if (!isMobileBasic && !isMobileAdvanced)
				{
					material.SetFloat("_ENABLE_SHADOWS", enableShadows ? 1 : 0);
					material.SetFloat("_ENABLE_GRADIENT", enableGradient ? 1 : 0);
					material.SetTexture("_GradientTex", colorGradientTex);
					material.SetColor("_FresnelColor", fresnelColor);
					material.SetFloat("_Fresnelexponent", fresnel);
					useRefractionCam = refractionSolver == 1;
					if (!useRefractionCam)
					{
						DisableRefractionCam();
					}
					material.SetFloat("_RT_REFRACTION", refractionSolver);
					material.SetFloat("_RefractionAmount", refractionAmount);
					material.SetFloat("_RimDistortion", rimDistortion);
					if (usingSinglePassRendering)
					{
						useReflection = false;
						material.SetFloat("_ReflectionStrength", 0f);
					}
					else
					{
						material.SetFloat("_ReflectionStrength", reflectionStrength);
						material.SetFloat("_ReflectionFresnel", reflectionFresnel);
						material.SetFloat("_ReflectionRefraction", reflectionRefraction);
					}
					if ((bool)reflectionBlurRenderer)
					{
						reflectionBlurRenderer.length = reflectionBlurLength;
						reflectionBlurRenderer.passes = reflectionBlurPasses;
					}
					material.SetFloat("_UseIntersectionFoam", foamSolver);
					material.SetFloat("_FoamDistortion", foamDistortion);
					if (enableMacroNormals)
					{
						material.EnableKeyword("_MACRO_WAVES_ON");
					}
					else
					{
						material.DisableKeyword("_MACRO_WAVES_ON");
					}
					material.SetFloat("_MacroBlendDistance", macroNormalsDistance);
					if (enableSecondaryWaves)
					{
						material.EnableKeyword("_SECONDARY_WAVES_ON");
					}
					else
					{
						material.DisableKeyword("_SECONDARY_WAVES_ON");
					}
				}
				if (isMobileAdvanced)
				{
					if (enableNormalMap)
					{
						material.EnableKeyword("_NORMAL_MAP_ON");
					}
					else
					{
						material.DisableKeyword("_NORMAL_MAP_ON");
					}
					if (foamSolver == 1)
					{
						material.EnableKeyword("_USEINTERSECTIONFOAM_ON");
					}
					else
					{
						material.DisableKeyword("_USEINTERSECTIONFOAM_ON");
					}
				}
			}

			public void DisableReflectionCam()
			{
				if ((bool)m_ReflectionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
					m_ReflectionTexture = null;
				}
				foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
				{
					UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
				}
				m_ReflectionCameras.Clear();
				if (!useReflection)
				{
					material.SetFloat("_ReflectionStrength", 0f);
				}
			}

			public void DisableRefractionCam()
			{
				if ((bool)m_RefractTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractTexture);
					m_RefractTexture = null;
				}
				foreach (KeyValuePair<Camera, Camera> refractCamera in m_RefractCameras)
				{
					UnityEngine.Object.DestroyImmediate(refractCamera.Value.gameObject);
				}
				m_RefractCameras.Clear();
			}

			private void EnableMaskRendering()
			{
				if (enableMaskRendering)
				{
					swsRenderer = new StylizedWaterRenderer();
					swsRenderSettings = new StylizedWaterRenderer.RendererSettings
					{
						renderTexureSize = swsRendererTextureSize,
						renderLayer = swsMaskRenderLayers
					};
					if (!renderCam)
					{
						swsRenderer.SetupMaskRenderer(swsRenderSettings, meshRenderer, out renderCam, out targetMeshInfo);
					}
				}
			}

			private void DisableMaskRendering()
			{
				if (!enableMaskRendering)
				{
					Shader.SetGlobalTexture("_SWS_RENDERTEX", Texture2D.blackTexture);
					if ((bool)renderCam)
					{
						UnityEngine.Object.DestroyImmediate(renderCam.gameObject);
					}
				}
			}

			private void EnableShadowRendering()
			{
				if (shadowCaster.GetComponent<StylizedWaterShadowCaster>() == null)
				{
					shadowRenderer = shadowCaster.gameObject.AddComponent<StylizedWaterShadowCaster>();
				}
			}

			private void DisableShadowRendering()
			{
				if ((bool)shadowRenderer)
				{
					UnityEngine.Object.DestroyImmediate(shadowRenderer);
					return;
				}
				try
				{
					if ((bool)shadowCaster)
					{
						shadowRenderer = shadowCaster.GetComponent<StylizedWaterShadowCaster>();
					}
					if ((bool)shadowRenderer)
					{
						UnityEngine.Object.DestroyImmediate(shadowRenderer);
					}
				}
				catch (Exception)
				{
					throw;
				}
			}

			public void SetVegetationStudioWaterLevel()
			{
			}

			public void OnWillRenderObject()
			{
				if (!base.enabled || !material)
				{
					return;
				}
				Camera current = Camera.current;
				if (!current || s_InsideRendering)
				{
					return;
				}
				s_InsideRendering = true;
				CreateWaterObjects(current, out var camera, out var camera2);
				Vector3 position = base.transform.position;
				Vector3 up = base.transform.up;
				int pixelLightCount = QualitySettings.pixelLightCount;
				QualitySettings.pixelLightCount = 0;
				if (useReflection)
				{
					StylizedWaterUtilities.CameraUtils.CopyCameraSettings(current, camera);
					Vector4 vector = new Vector4(w: 0f - Vector3.Dot(up, position) - (clipPlaneOffset + 0.001f), x: up.x, y: up.y, z: up.z);
					Matrix4x4 reflectionMat = Matrix4x4.zero;
					StylizedWaterUtilities.CameraUtils.CalculateReflectionMatrix(ref reflectionMat, vector);
					Vector3 position2 = current.transform.position;
					Vector3 position3 = reflectionMat.MultiplyPoint(position2);
					camera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
					Vector4 clipPlane = StylizedWaterUtilities.CameraUtils.CameraSpacePlane(camera, position, up, 1f, clipPlaneOffset);
					camera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
					camera.cullingMask = -17 & reflectLayers.value;
					camera.targetTexture = m_ReflectionTexture;
					bool invertCulling = GL.invertCulling;
					GL.invertCulling = !invertCulling;
					camera.transform.position = position3;
					Vector3 eulerAngles = current.transform.eulerAngles;
					camera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
					if (Mathf.Abs(Vector3.Dot(vector, camera.transform.forward)) > 0f)
					{
						if (enableReflectionBlur && (bool)reflectionBlurRenderer)
						{
							reflectionBlurRenderer.Render();
						}
						camera.Render();
					}
					camera.transform.position = position2;
					GL.invertCulling = invertCulling;
					if (!enableReflectionBlur)
					{
						Shader.SetGlobalTexture("_ReflectionTex", m_ReflectionTexture);
					}
				}
				else
				{
					DisableReflectionCam();
				}
				if (useRefractionCam)
				{
					StylizedWaterUtilities.CameraUtils.CopyCameraSettings(current, camera2);
					camera2.worldToCameraMatrix = current.worldToCameraMatrix;
					Vector4 clipPlane2 = StylizedWaterUtilities.CameraUtils.CameraSpacePlane(camera2, position, up, -1f, clipPlaneOffset);
					camera2.projectionMatrix = current.CalculateObliqueMatrix(clipPlane2);
					camera2.cullingMask = -17 & refractLayers.value;
					camera2.targetTexture = m_RefractTexture;
					camera2.transform.position = current.transform.position;
					camera2.transform.rotation = current.transform.rotation;
					camera2.Render();
					material.SetTexture("_RefractionTex", m_RefractTexture);
				}
				QualitySettings.pixelLightCount = pixelLightCount;
				s_InsideRendering = false;
			}

			public void CreateReflectionTexture()
			{
				switch (reflectionRes)
				{
				case 0:
					reflectionTextureSize = 256;
					break;
				case 1:
					reflectionTextureSize = 512;
					break;
				case 2:
					reflectionTextureSize = 1024;
					break;
				}
				if (!m_ReflectionTexture || m_OldReflectionTextureSize != reflectionTextureSize)
				{
					m_ReflectionTexture = new RenderTexture(reflectionTextureSize, reflectionTextureSize, 16)
					{
						name = "__WaterReflection",
						isPowerOfTwo = true,
						hideFlags = HideFlags.None
					};
					m_OldReflectionTextureSize = reflectionTextureSize;
				}
			}

			public void CreateRefractionTexture()
			{
				if ((bool)m_RefractTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractTexture);
					m_RefractTexture = null;
				}
				if (!m_RefractTexture || m_OldRefractTextureSize != refractTextureSize)
				{
					switch (refractRes)
					{
					case 0:
						refractTextureSize = 256;
						break;
					case 1:
						refractTextureSize = 512;
						break;
					case 2:
						refractTextureSize = 1024;
						break;
					}
					m_RefractTexture = new RenderTexture(refractTextureSize, refractTextureSize, 16);
					m_RefractTexture.name = "__WaterRefraction";
					m_RefractTexture.isPowerOfTwo = true;
					m_RefractTexture.hideFlags = HideFlags.DontSave;
					m_OldRefractTextureSize = refractTextureSize;
				}
			}

			private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractCamera)
			{
				reflectionCamera = null;
				refractCamera = null;
				reflectionBlurRenderer = null;
				if (useReflection)
				{
					CreateReflectionTexture();
					m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
					if (!reflectionCamera)
					{
						GameObject gameObject = new GameObject("", typeof(Camera));
						gameObject.name = "Reflection Camera " + gameObject.GetInstanceID() + " for " + currentCamera.name;
						gameObject.hideFlags = HideFlags.HideAndDontSave;
						reflectionCamera = gameObject.GetComponent<Camera>();
						reflectionCamera.enabled = false;
						reflectionCamera.useOcclusionCulling = false;
						reflectionCamera.transform.position = base.transform.position;
						reflectionCamera.transform.rotation = base.transform.rotation;
						reflectionCamera.gameObject.AddComponent<FlareLayer>();
						m_ReflectionCameras[currentCamera] = reflectionCamera;
					}
					if ((bool)reflectionCamera && enableReflectionBlur)
					{
						m_BlurRenderers.TryGetValue(currentCamera, out reflectionBlurRenderer);
						if (!reflectionBlurRenderer)
						{
							reflectionBlurRenderer = reflectionCamera.gameObject.AddComponent<StylizedWaterBlur>();
						}
						m_BlurRenderers[currentCamera] = reflectionBlurRenderer;
					}
				}
				if (useRefractionCam)
				{
					CreateRefractionTexture();
					m_RefractCameras.TryGetValue(currentCamera, out refractCamera);
					if (!refractCamera)
					{
						GameObject gameObject2 = new GameObject("", typeof(Camera));
						gameObject2.name = "Refraction Camera " + gameObject2.GetInstanceID() + " for " + currentCamera.name;
						gameObject2.hideFlags = HideFlags.HideAndDontSave;
						refractCamera = gameObject2.GetComponent<Camera>();
						refractCamera.enabled = false;
						refractCamera.useOcclusionCulling = false;
						refractCamera.transform.position = base.transform.position;
						refractCamera.transform.rotation = base.transform.rotation;
						refractCamera.gameObject.AddComponent<FlareLayer>();
						m_RefractCameras[currentCamera] = refractCamera;
					}
				}
			}

			private void OnDisable()
			{
				DisableReflectionCam();
				DisableRefractionCam();
				DisableMaskRendering();
				if ((bool)shadowRenderer)
				{
					UnityEngine.Object.DestroyImmediate(shadowRenderer);
				}
			}

			private void OnDestroy()
			{
				DisableMaskRendering();
				DisableShadowRendering();
			}
		}
		[RequireComponent(typeof(Camera))]
		[ExecuteInEditMode]
		public class StylizedWaterBlur : MonoBehaviour
		{
			public Camera cam;

			public float length = 6f;

			public int passes = 4;

			private static Shader m_BlurRenderShader;

			private static Material m_BlurRenderMat;

			private CommandBuffer cmd;

			private static Shader BlurRenderShader
			{
				get
				{
					if (m_BlurRenderShader == null)
					{
						m_BlurRenderShader = Shader.Find("Hidden/SWS/Blur");
						return m_BlurRenderShader;
					}
					return m_BlurRenderShader;
				}
			}

			private static Material BlurRenderMat
			{
				get
				{
					if (m_BlurRenderMat == null)
					{
						m_BlurRenderMat = new Material(BlurRenderShader);
						m_BlurRenderMat.hideFlags = HideFlags.HideAndDontSave;
						return m_BlurRenderMat;
					}
					return m_BlurRenderMat;
				}
			}

			private void OnEnable()
			{
				if (!cam)
				{
					cam = GetComponent<Camera>();
				}
				Render();
			}

			private void OnDisable()
			{
				UnityEngine.Object.DestroyImmediate(BlurRenderMat);
				if (cmd != null)
				{
					cmd.Clear();
					cam.RemoveCommandBuffer(CameraEvent.AfterSkybox, cmd);
				}
			}

			public void Render()
			{
				if (!cam)
				{
					return;
				}
				if (cmd != null)
				{
					cam.RemoveCommandBuffer(CameraEvent.AfterSkybox, cmd);
				}
				cmd = new CommandBuffer();
				cmd.name = "Grab screen and blur";
				int num = Shader.PropertyToID("_BlurBuffer1");
				int num2 = Shader.PropertyToID("_BlurBuffer2");
				cmd.GetTemporaryRT(num, 0, 0, 0, FilterMode.Bilinear);
				cmd.GetTemporaryRT(num2, 0, 0, 0, FilterMode.Bilinear);
				cmd.Blit(BuiltinRenderTextureType.CurrentActive, num);
				for (int i = 0; i < passes; i++)
				{
					if (i > 4)
					{
						return;
					}
					cmd.SetGlobalFloat("BlurLength", length / (float)Screen.height);
					cmd.Blit(num, num2, BlurRenderMat);
					cmd.Blit(num2, num, BlurRenderMat);
				}
				cmd.SetGlobalTexture("_ReflectionTex", num);
				cam.AddCommandBuffer(CameraEvent.AfterSkybox, cmd);
				cmd.ReleaseTemporaryRT(num);
				cmd.ReleaseTemporaryRT(num2);
			}
		}
		public class StylizedWaterRenderer : UnityEngine.Object
		{
			public class RendererSettings
			{
				public LayerMask renderLayer;

				public int renderTexureSize = 1024;
			}

			private static bool debug;

			private RendererSettings settings;

			private GameObject targetObject;

			private Vector3 targetSize;

			private Vector3 targetCenterPosition;

			private RenderTexture _rt;

			private const int CLIP_PLANE_PADDING = 20;

			private static Material _intersectionMaskMat;

			private static Material _opacityMaskMat;

			private RenderTexture rt
			{
				get
				{
					if (_rt == null)
					{
						_rt = new RenderTexture(settings.renderTexureSize, settings.renderTexureSize, 0);
						_rt.hideFlags = HideFlags.DontSave;
					}
					return _rt;
				}
			}

			public static Material intersectionMaskMat
			{
				get
				{
					if (_intersectionMaskMat == null)
					{
						_intersectionMaskMat = new Material(Shader.Find("Legacy Shaders/Transparent/Diffuse"));
						_intersectionMaskMat.color = Color.red;
						_intersectionMaskMat.name = "SWS_IntersectionMask";
					}
					return _intersectionMaskMat;
				}
			}

			public static Material opacityMaskMat
			{
				get
				{
					if (_opacityMaskMat == null)
					{
						_opacityMaskMat = new Material(Shader.Find("Legacy Shaders/Transparent/Diffuse"));
						_opacityMaskMat.color = Color.green;
						_opacityMaskMat.name = "SWS_OpacityMask";
					}
					return _opacityMaskMat;
				}
			}

			public void SetupMaskRenderer(RendererSettings settings, MeshRenderer r, out Camera renderCam, out Vector4 targetMeshInfo)
			{
				this.settings = settings;
				targetObject = r.gameObject;
				targetMeshInfo = GetMeshInfo(r);
				renderCam = SetupRenderCam();
				RenderCamToTexture(renderCam);
			}

			private Vector4 GetMeshInfo(MeshRenderer r)
			{
				Bounds bounds = r.bounds;
				if (StylizedWaterUtilities.IsApproximatelyEqual(r.bounds.extents.x, r.bounds.extents.z) && debug)
				{
					UnityEngine.Debug.LogErrorFormat("[Stylized Water] Size of \"{0}\" is not uniform at {1}! Width and Length must be equal!", r.name, r.bounds.extents.x + "x" + r.bounds.extents.z);
				}
				targetSize = bounds.extents * 2f;
				targetCenterPosition = bounds.center;
				if (debug)
				{
					string[] obj = new string[5] { r.name, " : Size = ", null, null, null };
					Vector3 vector = targetSize;
					obj[2] = vector.ToString();
					obj[3] = " Center = ";
					vector = targetCenterPosition;
					obj[4] = vector.ToString();
					UnityEngine.Debug.Log(string.Concat(obj));
				}
				Vector4 vector2 = new Vector4(targetSize.x, targetSize.z, targetCenterPosition.x - targetSize.x / 2f, targetCenterPosition.z - targetSize.z / 2f);
				Shader.SetGlobalVector("_SWS_RENDERTEX_POS", vector2);
				return vector2;
			}

			private Camera SetupRenderCam()
			{
				Camera camera = new GameObject().AddComponent<Camera>();
				camera.name = "RenderCamera";
				camera.transform.parent = targetObject.transform;
				camera.transform.hideFlags = HideFlags.NotEditable;
				float num = settings.renderTexureSize;
				num /= (float)Screen.width;
				camera.rect = new Rect(0f, 0f, num, 1f);
				camera.orthographic = true;
				camera.orthographicSize = targetSize.x / 2f;
				camera.farClipPlane = targetSize.y + 40f;
				camera.useOcclusionCulling = false;
				camera.clearFlags = CameraClearFlags.Color;
				camera.backgroundColor = Color.black;
				camera.depth = -1f;
				camera.cullingMask = -17 & settings.renderLayer.value;
				camera.renderingPath = RenderingPath.Forward;
				float num2 = 0f;
				float x = targetCenterPosition.x;
				float y = targetCenterPosition.y - 20f;
				num2 = targetCenterPosition.z;
				camera.transform.position = new Vector3(x, y, num2);
				camera.transform.localEulerAngles = new Vector3(90f, 0f, 0f);
				return camera;
			}

			private RenderTexture RenderCamToTexture(Camera renderCam)
			{
				renderCam.targetTexture = rt;
				RenderTexture.active = rt;
				Shader.SetGlobalTexture("_SWS_RENDERTEX", rt);
				return rt;
			}
		}
		[RequireComponent(typeof(Light))]
		[ExecuteInEditMode]
		public class StylizedWaterShadowCaster : MonoBehaviour
		{
			private CommandBuffer cmd;

			public Light dirLight;

			private void OnEnable()
			{
				if (!dirLight)
				{
					dirLight = GetComponent<Light>();
				}
				if ((bool)dirLight && dirLight.GetCommandBuffers(LightEvent.AfterScreenspaceMask).Length < 1)
				{
					cmd = new CommandBuffer();
					cmd.name = "Water Shadow Mask";
					cmd.SetGlobalTexture("_ShadowMask", new RenderTargetIdentifier(BuiltinRenderTextureType.CurrentActive));
					dirLight.AddCommandBuffer(LightEvent.AfterScreenspaceMask, cmd);
				}
			}

			private void OnDisable()
			{
				if ((bool)dirLight)
				{
					dirLight.RemoveAllCommandBuffers();
				}
			}
		}
		public static class StylizedWaterUtilities
		{
			public static class CameraUtils
			{
				public static Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign, float clipPlaneOffset)
				{
					Vector3 point = pos + normal * clipPlaneOffset;
					Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
					Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
					Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
					return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
				}

				public static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
				{
					reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
					reflectionMat.m01 = -2f * plane[0] * plane[1];
					reflectionMat.m02 = -2f * plane[0] * plane[2];
					reflectionMat.m03 = -2f * plane[3] * plane[0];
					reflectionMat.m10 = -2f * plane[1] * plane[0];
					reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
					reflectionMat.m12 = -2f * plane[1] * plane[2];
					reflectionMat.m13 = -2f * plane[3] * plane[1];
					reflectionMat.m20 = -2f * plane[2] * plane[0];
					reflectionMat.m21 = -2f * plane[2] * plane[1];
					reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
					reflectionMat.m23 = -2f * plane[3] * plane[2];
					reflectionMat.m30 = 0f;
					reflectionMat.m31 = 0f;
					reflectionMat.m32 = 0f;
					reflectionMat.m33 = 1f;
				}

				public static void CopyCameraSettings(Camera src, Camera dest)
				{
					if (!(dest == null))
					{
						dest.clearFlags = src.clearFlags;
						dest.backgroundColor = src.backgroundColor;
						dest.farClipPlane = src.farClipPlane;
						dest.nearClipPlane = src.nearClipPlane;
						dest.fieldOfView = src.fieldOfView;
						dest.aspect = src.aspect;
						dest.orthographic = src.orthographic;
						dest.orthographicSize = src.orthographicSize;
						dest.renderingPath = src.renderingPath;
						dest.targetDisplay = src.targetDisplay;
					}
				}
			}

			public static bool DEBUG;

			public static string[] ComposeDropdown(Texture2D[] resource, string replaceFilter)
			{
				string[] array = new string[resource.Length + 1];
				for (int i = 0; i < resource.Length; i++)
				{
					if (resource[i] == null)
					{
						array[i] = "(Missing)";
					}
					else
					{
						array[i] = resource[i].name.Replace(replaceFilter, string.Empty);
					}
				}
				array[resource.Length] = "Custom...";
				return array;
			}

			public static bool IsApproximatelyEqual(float a, float b)
			{
				return Mathf.Abs(a - b) < 0.05f;
			}

			public static bool HasVertexColors(Mesh mesh)
			{
				Color[] colors = mesh.colors;
				bool result = false;
				Color[] array = colors;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] != Color.clear)
					{
						result = true;
						break;
					}
				}
				if (DEBUG)
				{
					UnityEngine.Debug.Log("Mesh: " + mesh.name + " has vertex colors: " + result);
				}
				return result;
			}
		}
		public class OrbitCamera : MonoBehaviour
		{
			[Header("Stylized Water Demo")]
			[Space]
			public Transform pivot;

			[Space]
			public bool enableMouse = true;

			public float idleRotationSpeed = 0.05f;

			private Transform cam;

			private float cameraRotSide;

			private float cameraRotUp;

			private float cameraRotSideCur;

			private float cameraRotUpCur;

			private float distance;

			private void Start()
			{
				cam = Camera.main.transform;
				cameraRotSide = base.transform.eulerAngles.y;
				cameraRotSideCur = base.transform.eulerAngles.y;
				cameraRotUp = base.transform.eulerAngles.x;
				cameraRotUpCur = base.transform.eulerAngles.x;
				distance = 0f - cam.localPosition.z;
			}

			private void Update()
			{
				if ((bool)pivot)
				{
					if (Input.GetMouseButton(0) && enableMouse)
					{
						cameraRotSide += Input.GetAxis("Mouse X") * 5f;
						cameraRotUp -= Input.GetAxis("Mouse Y") * 5f;
					}
					else
					{
						cameraRotSide += idleRotationSpeed;
					}
					cameraRotSideCur = Mathf.LerpAngle(cameraRotSideCur, cameraRotSide, Time.deltaTime * 5f);
					cameraRotUpCur = Mathf.Lerp(cameraRotUpCur, cameraRotUp, Time.deltaTime * 5f);
					if (Input.GetMouseButton(1) && enableMouse)
					{
						distance *= 1f - 0.1f * Input.GetAxis("Mouse Y");
					}
					if (enableMouse)
					{
						distance *= 1f - 1f * Input.GetAxis("Mouse ScrollWheel");
					}
					Vector3 position = pivot.position;
					base.transform.position = Vector3.Lerp(base.transform.position, position, Time.deltaTime);
					base.transform.rotation = Quaternion.Euler(cameraRotUpCur, cameraRotSideCur, 0f);
					float num = Mathf.Lerp(0f - cam.transform.localPosition.z, distance, Time.deltaTime * 5f);
					cam.localPosition = -Vector3.forward * num;
				}
			}
		}
	}
	namespace PrimitivePlus
	{
		public static class PrimitivePlusConstants
		{
			public const string PRIMITIVE_PLUS_RESOURCES = "Assets/PrimitivePlus/Resources/";

			public const string PRIMITIVE_PLUS_MATERIALS = "Materials/";

			public const string PRIMITIVE_PLUS_MESHES = "Meshes/";
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(MeshRenderer))]
		public class PrimitivePlusMaterial : MonoBehaviour
		{
			private MeshRenderer m_Renderer;

			private Material m_Material;

			private void Awake()
			{
				m_Renderer = GetComponent<MeshRenderer>();
			}

			private void OnDestroy()
			{
				m_Material = null;
				m_Renderer = null;
			}

			public void SetNewMaterial()
			{
				m_Material = new Material(m_Renderer.sharedMaterial);
				m_Renderer.sharedMaterial = m_Material;
				m_Material.name = "New Material";
			}

			public void SetSharedMaterial(Material material)
			{
				m_Material = material;
				m_Renderer.sharedMaterial = m_Material;
			}
		}
		public class PrimitivePlusMeshes
		{
			private static Mesh m_Circle2D;

			private static Mesh m_CircleHalf2D;

			private static Mesh m_Cone;

			private static Mesh m_ConeHalf;

			private static Mesh m_ConeHexagon;

			private static Mesh m_ConePentagon;

			private static Mesh m_Cross;

			private static Mesh m_Cross2D;

			private static Mesh m_Cube;

			private static Mesh m_CubeCorner;

			private static Mesh m_CubeCornerThin;

			private static Mesh m_CubeEdgeIn;

			private static Mesh m_CubeEdgeOut;

			private static Mesh m_CubeHollow;

			private static Mesh m_CubeHollowThin;

			private static Mesh m_CubeTube;

			private static Mesh m_Cylinder;

			private static Mesh m_CylinderHalf;

			private static Mesh m_CylinderTube;

			private static Mesh m_CylinderTubeThin;

			private static Mesh m_Diamond;

			private static Mesh m_DiamondThick;

			private static Mesh m_Heart;

			private static Mesh m_Heart2D;

			private static Mesh m_Hexagon2D;

			private static Mesh m_Icosphere;

			private static Mesh m_IcosphereSmall;

			private static Mesh m_Plane;

			private static Mesh m_PrismHexagon;

			private static Mesh m_PrismOctagon;

			private static Mesh m_PrismPentagon;

			private static Mesh m_PrismTriangle;

			private static Mesh m_Pyramid;

			private static Mesh m_PyramidCorner;

			private static Mesh m_PyramidTri;

			private static Mesh m_Rhombus2D;

			private static Mesh m_Sphere;

			private static Mesh m_SphereHalf;

			private static Mesh m_Star;

			private static Mesh m_Star2D;

			private static Mesh m_Torus;

			private static Mesh m_TorusHalf;

			private static Mesh m_Triangle2D;

			private static Mesh m_Wedge;

			public static Mesh GetMeshType(PrimitivePlusType type)
			{
				switch (type)
				{
				case PrimitivePlusType.Circle2D:
					if (!(m_Circle2D == null))
					{
						return m_Circle2D;
					}
					return Circle2D();
				case PrimitivePlusType.CircleHalf2D:
					if (!(m_CircleHalf2D == null))
					{
						return m_CircleHalf2D;
					}
					return CircleHalf2D();
				case PrimitivePlusType.Cone:
					if (!(m_Cone == null))
					{
						return m_Cone;
					}
					return Cone();
				case PrimitivePlusType.ConeHalf:
					if (!(m_ConeHalf == null))
					{
						return m_ConeHalf;
					}
					return ConeHalf();
				case PrimitivePlusType.ConeHexagon:
					if (!(m_ConeHexagon == null))
					{
						return m_ConeHexagon;
					}
					return ConeHexagon();
				case PrimitivePlusType.ConePentagon:
					if (!(m_ConePentagon == null))
					{
						return m_ConePentagon;
					}
					return ConePentagon();
				case PrimitivePlusType.Cross:
					if (!(m_Cross == null))
					{
						return m_Cross;
					}
					return Cross();
				case PrimitivePlusType.Cross2D:
					if (!(m_Cross2D == null))
					{
						return m_Cross2D;
					}
					return Cross2D();
				case PrimitivePlusType.Cube:
					if (!(m_Cube == null))
					{
						return m_Cube;
					}
					return Cube();
				case PrimitivePlusType.CubeCorner:
					if (!(m_CubeCorner == null))
					{
						return m_CubeCorner;
					}
					return CubeCorner();
				case PrimitivePlusType.CubeCornerThin:
					if (!(m_CubeCornerThin == null))
					{
						return m_CubeCornerThin;
					}
					return CubeCornerThin();
				case PrimitivePlusType.CubeEdgeIn:
					if (!(m_CubeEdgeIn == null))
					{
						return m_CubeEdgeIn;
					}
					return CubeEdgeIn();
				case PrimitivePlusType.CubeEdgeOut:
					if (!(m_CubeEdgeOut == null))
					{
						return m_CubeEdgeOut;
					}
					return CubeEdgeOut();
				case PrimitivePlusType.CubeHollow:
					if (!(m_CubeHollow == null))
					{
						return m_CubeHollow;
					}
					return CubeHollow();
				case PrimitivePlusType.CubeHollowThin:
					if (!(m_CubeHollowThin == null))
					{
						return m_CubeHollowThin;
					}
					return CubeHollowThin();
				case PrimitivePlusType.CubeTube:
					if (!(m_CubeTube == null))
					{
						return m_CubeTube;
					}
					return CubeTube();
				case PrimitivePlusType.Cylinder:
					if (!(m_Cylinder == null))
					{
						return m_Cylinder;
					}
					return Cylinder();
				case PrimitivePlusType.CylinderHalf:
					if (!(m_CylinderHalf == null))
					{
						return m_CylinderHalf;
					}
					return CylinderHalf();
				case PrimitivePlusType.CylinderTube:
					if (!(m_CylinderTube == null))
					{
						return m_CylinderTube;
					}
					return CylinderTube();
				case PrimitivePlusType.CylinderTubeThin:
					if (!(m_CylinderTubeThin == null))
					{
						return m_CylinderTubeThin;
					}
					return CylinderTubeThin();
				case PrimitivePlusType.Diamond:
					if (!(m_Diamond == null))
					{
						return m_Diamond;
					}
					return Diamond();
				case PrimitivePlusType.DiamondThick:
					if (!(m_DiamondThick == null))
					{
						return m_DiamondThick;
					}
					return DiamondThick();
				case PrimitivePlusType.Heart:
					if (!(m_Heart == null))
					{
						return m_Heart;
					}
					return Heart();
				case PrimitivePlusType.Heart2D:
					if (!(m_Heart2D == null))
					{
						return m_Heart2D;
					}
					return Heart2D();
				case PrimitivePlusType.Hexagon2D:
					if (!(m_Hexagon2D == null))
					{
						return m_Hexagon2D;
					}
					return Hexagon2D();
				case PrimitivePlusType.Icosphere:
					if (!(m_Icosphere == null))
					{
						return m_Icosphere;
					}
					return Icosphere();
				case PrimitivePlusType.IcosphereSmall:
					if (!(m_IcosphereSmall == null))
					{
						return m_IcosphereSmall;
					}
					return IcosphereSmall();
				case PrimitivePlusType.Plane:
					if (!(m_Plane == null))
					{
						return m_Plane;
					}
					return Plane();
				case PrimitivePlusType.PrismHexagon:
					if (!(m_PrismHexagon == null))
					{
						return m_PrismHexagon;
					}
					return PrismHexagon();
				case PrimitivePlusType.PrismOctagon:
					if (!(m_PrismOctagon == null))
					{
						return m_PrismOctagon;
					}
					return PrismOctagon();
				case PrimitivePlusType.PrismPentagon:
					if (!(m_PrismPentagon == null))
					{
						return m_PrismPentagon;
					}
					return PrismPentagon();
				case PrimitivePlusType.PrismTriangle:
					if (!(m_PrismTriangle == null))
					{
						return m_PrismTriangle;
					}
					return PrismTriangle();
				case PrimitivePlusType.Pyramid:
					if (!(m_Pyramid == null))
					{
						return m_Pyramid;
					}
					return Pyramid();
				case PrimitivePlusType.PyramidCorner:
					if (!(m_PyramidCorner == null))
					{
						return m_PyramidCorner;
					}
					return PyramidCorner();
				case PrimitivePlusType.PyramidTri:
					if (!(m_PyramidTri == null))
					{
						return m_PyramidTri;
					}
					return PyramidTri();
				case PrimitivePlusType.Rhombus2D:
					if (!(m_Rhombus2D == null))
					{
						return m_Rhombus2D;
					}
					return Rhombus2D();
				case PrimitivePlusType.Sphere:
					if (!(m_Sphere == null))
					{
						return m_Sphere;
					}
					return Sphere();
				case PrimitivePlusType.SphereHalf:
					if (!(m_SphereHalf == null))
					{
						return m_SphereHalf;
					}
					return SphereHalf();
				case PrimitivePlusType.Star:
					if (!(m_Star == null))
					{
						return m_Star;
					}
					return Star();
				case PrimitivePlusType.Star2D:
					if (!(m_Star2D == null))
					{
						return m_Star2D;
					}
					return Star2D();
				case PrimitivePlusType.Torus:
					if (!(m_Torus == null))
					{
						return m_Torus;
					}
					return Torus();
				case PrimitivePlusType.TorusHalf:
					if (!(m_TorusHalf == null))
					{
						return m_TorusHalf;
					}
					return TorusHalf();
				case PrimitivePlusType.Triangle2D:
					if (!(m_Triangle2D == null))
					{
						return m_Triangle2D;
					}
					return Triangle2D();
				case PrimitivePlusType.Wedge:
					if (!(m_Wedge == null))
					{
						return m_Wedge;
					}
					return Wedge();
				default:
					return null;
				}
			}

			private static Mesh Circle2D()
			{
				m_Circle2D = Resources.Load<Mesh>("Meshes/Circle2D");
				return m_Circle2D;
			}

			private static Mesh CircleHalf2D()
			{
				m_CircleHalf2D = Resources.Load<Mesh>("Meshes/CircleHalf2D");
				return m_CircleHalf2D;
			}

			private static Mesh Cone()
			{
				m_Cone = Resources.Load<Mesh>("Meshes/Cone");
				return m_Cone;
			}

			private static Mesh ConeHalf()
			{
				m_ConeHalf = Resources.Load<Mesh>("Meshes/ConeHalf");
				return m_ConeHalf;
			}

			private static Mesh ConeHexagon()
			{
				m_ConeHexagon = Resources.Load<Mesh>("Meshes/ConeHexagon");
				return m_ConeHexagon;
			}

			private static Mesh ConePentagon()
			{
				m_ConePentagon = Resources.Load<Mesh>("Meshes/ConePentagon");
				return m_ConePentagon;
			}

			private static Mesh Cross()
			{
				m_Cross = Resources.Load<Mesh>("Meshes/Cross");
				return m_Cross;
			}

			private static Mesh Cross2D()
			{
				m_Cross2D = Resources.Load<Mesh>("Meshes/Cross2D");
				return m_Cross2D;
			}

			private static Mesh Cube()
			{
				m_Cube = Resources.Load<Mesh>("Meshes/Cube");
				return m_Cube;
			}

			private static Mesh CubeCorner()
			{
				m_CubeCorner = Resources.Load<Mesh>("Meshes/CubeCorner");
				return m_CubeCorner;
			}

			private static Mesh CubeCornerThin()
			{
				m_CubeCornerThin = Resources.Load<Mesh>("Meshes/CubeCornerThin");
				return m_CubeCornerThin;
			}

			private static Mesh CubeEdgeIn()
			{
				m_CubeEdgeIn = Resources.Load<Mesh>("Meshes/CubeEdgeIn");
				return m_CubeEdgeIn;
			}

			private static Mesh CubeEdgeOut()
			{
				m_CubeEdgeOut = Resources.Load<Mesh>("Meshes/CubeEdgeOut");
				return m_CubeEdgeOut;
			}

			private static Mesh CubeHollow()
			{
				m_CubeHollow = Resources.Load<Mesh>("Meshes/CubeHollow");
				return m_CubeHollow;
			}

			private static Mesh CubeHollowThin()
			{
				m_CubeHollowThin = Resources.Load<Mesh>("Meshes/CubeHollowThin");
				return m_CubeHollowThin;
			}

			private static Mesh CubeTube()
			{
				m_CubeTube = Resources.Load<Mesh>("Meshes/CubeTube");
				return m_CubeTube;
			}

			private static Mesh Cylinder()
			{
				m_Cylinder = Resources.Load<Mesh>("Meshes/Cylinder");
				return m_Cylinder;
			}

			private static Mesh CylinderHalf()
			{
				m_CylinderHalf = Resources.Load<Mesh>("Meshes/CylinderHalf");
				return m_CylinderHalf;
			}

			private static Mesh CylinderTube()
			{
				m_CylinderTube = Resources.Load<Mesh>("Meshes/CylinderTube");
				return m_CylinderTube;
			}

			private static Mesh CylinderTubeThin()
			{
				m_CylinderTubeThin = Resources.Load<Mesh>("Meshes/CylinderTubeThin");
				return m_CylinderTubeThin;
			}

			private static Mesh Diamond()
			{
				m_Diamond = Resources.Load<Mesh>("Meshes/Diamond");
				return m_Diamond;
			}

			private static Mesh DiamondThick()
			{
				m_DiamondThick = Resources.Load<Mesh>("Meshes/DiamondThick");
				return m_DiamondThick;
			}

			private static Mesh Heart()
			{
				m_Heart = Resources.Load<Mesh>("Meshes/Heart");
				return m_Heart;
			}

			private static Mesh Heart2D()
			{
				m_Heart2D = Resources.Load<Mesh>("Meshes/Heart2D");
				return m_Heart2D;
			}

			private static Mesh Hexagon2D()
			{
				m_Hexagon2D = Resources.Load<Mesh>("Meshes/Hexagon2D");
				return m_Hexagon2D;
			}

			private static Mesh Icosphere()
			{
				m_Icosphere = Resources.Load<Mesh>("Meshes/Icosphere");
				return m_Icosphere;
			}

			private static Mesh IcosphereSmall()
			{
				m_IcosphereSmall = Resources.Load<Mesh>("Meshes/IcosphereSmall");
				return m_IcosphereSmall;
			}

			private static Mesh Plane()
			{
				m_Plane = Resources.Load<Mesh>("Meshes/Plane");
				return m_Plane;
			}

			private static Mesh PrismHexagon()
			{
				m_PrismHexagon = Resources.Load<Mesh>("Meshes/PrismHexagon");
				return m_PrismHexagon;
			}

			private static Mesh PrismOctagon()
			{
				m_PrismOctagon = Resources.Load<Mesh>("Meshes/PrismOctagon");
				return m_PrismOctagon;
			}

			private static Mesh PrismPentagon()
			{
				m_PrismPentagon = Resources.Load<Mesh>("Meshes/PrismPentagon");
				return m_PrismPentagon;
			}

			private static Mesh PrismTriangle()
			{
				m_PrismTriangle = Resources.Load<Mesh>("Meshes/PrismTriangle");
				return m_PrismTriangle;
			}

			private static Mesh Pyramid()
			{
				m_Pyramid = Resources.Load<Mesh>("Meshes/Pyramid");
				return m_Pyramid;
			}

			private static Mesh PyramidCorner()
			{
				m_PyramidCorner = Resources.Load<Mesh>("Meshes/PyramidCorner");
				return m_PyramidCorner;
			}

			private static Mesh PyramidTri()
			{
				m_PyramidTri = Resources.Load<Mesh>("Meshes/PyramidTri");
				return m_PyramidTri;
			}

			private static Mesh Rhombus2D()
			{
				m_Rhombus2D = Resources.Load<Mesh>("Meshes/Rhombus2D");
				return m_Rhombus2D;
			}

			private static Mesh Sphere()
			{
				m_Sphere = Resources.Load<Mesh>("Meshes/Sphere");
				return m_Sphere;
			}

			private static Mesh SphereHalf()
			{
				m_SphereHalf = Resources.Load<Mesh>("Meshes/SphereHalf");
				return m_SphereHalf;
			}

			private static Mesh Star()
			{
				m_Star = Resources.Load<Mesh>("Meshes/Star");
				return m_Star;
			}

			private static Mesh Star2D()
			{
				m_Star2D = Resources.Load<Mesh>("Meshes/Star2D");
				return m_Star2D;
			}

			private static Mesh Torus()
			{
				m_Torus = Resources.Load<Mesh>("Meshes/Torus");
				return m_Torus;
			}

			private static Mesh TorusHalf()
			{
				m_TorusHalf = Resources.Load<Mesh>("Meshes/TorusHalf");
				return m_TorusHalf;
			}

			private static Mesh Triangle2D()
			{
				m_Triangle2D = Resources.Load<Mesh>("Meshes/Triangle2D");
				return m_Triangle2D;
			}

			private static Mesh Wedge()
			{
				m_Wedge = Resources.Load<Mesh>("Meshes/Wedge");
				return m_Wedge;
			}

			private static Mesh GetMesh(Vector3[] vertices, Vector3[] normals, Vector2[] uv, int[] triangles)
			{
				Mesh mesh = new Mesh();
				mesh.vertices = vertices;
				mesh.normals = normals;
				mesh.uv = uv;
				mesh.triangles = triangles;
				mesh.RecalculateBounds();
				return mesh;
			}
		}
		public static class PrimitivePlusObject
		{
			public static GameObject CreatePrimitivePlus(PrimitivePlusType type)
			{
				string text = type.ToString();
				GameObject gameObject = new GameObject(text);
				MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
				meshFilter.sharedMesh = PrimitivePlusMeshes.GetMeshType(type);
				meshFilter.sharedMesh.name = text;
				Material sharedMaterial = new Material(Shader.Find("Diffuse"));
				gameObject.AddComponent<MeshRenderer>().sharedMaterial = sharedMaterial;
				switch (text)
				{
				case "Cube":
					gameObject.AddComponent<BoxCollider>();
					break;
				case "Sphere":
				case "Heart":
					gameObject.AddComponent<SphereCollider>();
					break;
				default:
					if (meshFilter.sharedMesh.triangles.Length / 3 < 255)
					{
						gameObject.AddComponent<MeshCollider>();
					}
					break;
				}
				gameObject.AddComponent<PrimitivePlusMaterial>();
				return gameObject;
			}
		}
		public enum PrimitivePlusType
		{
			Circle2D,
			CircleHalf2D,
			Cone,
			ConeHalf,
			ConeHexagon,
			ConePentagon,
			Cross,
			Cross2D,
			Cube,
			CubeCorner,
			CubeCornerThin,
			CubeEdgeIn,
			CubeEdgeOut,
			CubeHollow,
			CubeHollowThin,
			CubeTube,
			Cylinder,
			CylinderHalf,
			CylinderTube,
			CylinderTubeThin,
			Diamond,
			DiamondThick,
			Heart,
			Heart2D,
			Hexagon2D,
			Icosphere,
			IcosphereSmall,
			Plane,
			PrismHexagon,
			PrismOctagon,
			PrismPentagon,
			PrismTriangle,
			Pyramid,
			PyramidCorner,
			PyramidTri,
			Rhombus2D,
			Sphere,
			SphereHalf,
			Star,
			Star2D,
			Torus,
			TorusHalf,
			Triangle2D,
			Wedge
		}
	}
	namespace UnityEngine.PostProcessing
	{
		public sealed class GetSetAttribute : PropertyAttribute
		{
			public readonly string name;

			public bool dirty;

			public GetSetAttribute(string name)
			{
				this.name = name;
			}
		}
		public sealed class MinAttribute : PropertyAttribute
		{
			public readonly float min;

			public MinAttribute(float min)
			{
				this.min = min;
			}
		}
		public sealed class TrackballAttribute : PropertyAttribute
		{
			public readonly string method;

			public TrackballAttribute(string method)
			{
				this.method = method;
			}
		}
		public sealed class TrackballGroupAttribute : PropertyAttribute
		{
		}
		public sealed class AmbientOcclusionComponent : PostProcessingComponentCommandBuffer<AmbientOcclusionModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Intensity = Shader.PropertyToID("_Intensity");

				internal static readonly int _Radius = Shader.PropertyToID("_Radius");

				internal static readonly int _FogParams = Shader.PropertyToID("_FogParams");

				internal static readonly int _Downsample = Shader.PropertyToID("_Downsample");

				internal static readonly int _SampleCount = Shader.PropertyToID("_SampleCount");

				internal static readonly int _OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

				internal static readonly int _OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

				internal static readonly int _OcclusionTexture = Shader.PropertyToID("_OcclusionTexture");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
			}

			private enum OcclusionSource
			{
				DepthTexture,
				DepthNormalsTexture,
				GBuffer
			}

			private const string k_BlitShaderString = "Hidden/Post FX/Blit";

			private const string k_ShaderString = "Hidden/Post FX/Ambient Occlusion";

			private readonly RenderTargetIdentifier[] m_MRT = new RenderTargetIdentifier[2]
			{
				BuiltinRenderTextureType.GBuffer0,
				BuiltinRenderTextureType.CameraTarget
			};

			private OcclusionSource occlusionSource
			{
				get
				{
					if (context.isGBufferAvailable && !base.model.settings.forceForwardCompatibility)
					{
						return OcclusionSource.GBuffer;
					}
					if (base.model.settings.highPrecision && (!context.isGBufferAvailable || base.model.settings.forceForwardCompatibility))
					{
						return OcclusionSource.DepthTexture;
					}
					return OcclusionSource.DepthNormalsTexture;
				}
			}

			private bool ambientOnlySupported
			{
				get
				{
					if (context.isHdr && base.model.settings.ambientOnly && context.isGBufferAvailable)
					{
						return !base.model.settings.forceForwardCompatibility;
					}
					return false;
				}
			}

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.intensity > 0f)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				DepthTextureMode depthTextureMode = DepthTextureMode.None;
				if (occlusionSource == OcclusionSource.DepthTexture)
				{
					depthTextureMode |= DepthTextureMode.Depth;
				}
				if (occlusionSource != OcclusionSource.GBuffer)
				{
					depthTextureMode |= DepthTextureMode.DepthNormals;
				}
				return depthTextureMode;
			}

			public override string GetName()
			{
				return "Ambient Occlusion";
			}

			public override CameraEvent GetCameraEvent()
			{
				if (!ambientOnlySupported || context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
				{
					return CameraEvent.BeforeImageEffectsOpaque;
				}
				return CameraEvent.BeforeReflections;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				AmbientOcclusionModel.Settings settings = base.model.settings;
				Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
				Material material = context.materialFactory.Get("Hidden/Post FX/Ambient Occlusion");
				material.shaderKeywords = null;
				material.SetFloat(Uniforms._Intensity, settings.intensity);
				material.SetFloat(Uniforms._Radius, settings.radius);
				material.SetFloat(Uniforms._Downsample, settings.downsampling ? 0.5f : 1f);
				material.SetInt(Uniforms._SampleCount, (int)settings.sampleCount);
				if (!context.isGBufferAvailable && RenderSettings.fog)
				{
					material.SetVector(Uniforms._FogParams, new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance));
					switch (RenderSettings.fogMode)
					{
					case FogMode.Linear:
						material.EnableKeyword("FOG_LINEAR");
						break;
					case FogMode.Exponential:
						material.EnableKeyword("FOG_EXP");
						break;
					case FogMode.ExponentialSquared:
						material.EnableKeyword("FOG_EXP2");
						break;
					}
				}
				else
				{
					material.EnableKeyword("FOG_OFF");
				}
				int width = context.width;
				int height = context.height;
				int num = ((!settings.downsampling) ? 1 : 2);
				int occlusionTexture = Uniforms._OcclusionTexture1;
				cb.GetTemporaryRT(occlusionTexture, width / num, height / num, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.Blit(null, occlusionTexture, material, (int)occlusionSource);
				int occlusionTexture2 = Uniforms._OcclusionTexture2;
				cb.GetTemporaryRT(occlusionTexture2, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
				cb.Blit(occlusionTexture, occlusionTexture2, material, (occlusionSource == OcclusionSource.GBuffer) ? 4 : 3);
				cb.ReleaseTemporaryRT(occlusionTexture);
				occlusionTexture = Uniforms._OcclusionTexture;
				cb.GetTemporaryRT(occlusionTexture, width, height, 0, FilterMode.Bilinear, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture2);
				cb.Blit(occlusionTexture2, occlusionTexture, material, 5);
				cb.ReleaseTemporaryRT(occlusionTexture2);
				if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.AmbientOcclusion))
				{
					cb.SetGlobalTexture(Uniforms._MainTex, occlusionTexture);
					cb.Blit(occlusionTexture, BuiltinRenderTextureType.CameraTarget, material, 8);
					context.Interrupt();
				}
				else if (ambientOnlySupported)
				{
					cb.SetRenderTarget(m_MRT, BuiltinRenderTextureType.CameraTarget);
					cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 7);
				}
				else
				{
					RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
					int tempRT = Uniforms._TempRT;
					cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear, format);
					cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
					cb.SetGlobalTexture(Uniforms._MainTex, tempRT);
					cb.Blit(tempRT, BuiltinRenderTextureType.CameraTarget, material, 6);
					cb.ReleaseTemporaryRT(tempRT);
				}
				cb.ReleaseTemporaryRT(occlusionTexture);
			}
		}
		public sealed class BloomComponent : PostProcessingComponentRenderTexture<BloomModel>
		{
			private static class Uniforms
			{
				internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

				internal static readonly int _Threshold = Shader.PropertyToID("_Threshold");

				internal static readonly int _Curve = Shader.PropertyToID("_Curve");

				internal static readonly int _PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");

				internal static readonly int _SampleScale = Shader.PropertyToID("_SampleScale");

				internal static readonly int _BaseTex = Shader.PropertyToID("_BaseTex");

				internal static readonly int _BloomTex = Shader.PropertyToID("_BloomTex");

				internal static readonly int _Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

				internal static readonly int _Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

				internal static readonly int _Bloom_DirtIntensity = Shader.PropertyToID("_Bloom_DirtIntensity");
			}

			private const int k_MaxPyramidBlurLevel = 16;

			private readonly RenderTexture[] m_BlurBuffer1 = new RenderTexture[16];

			private readonly RenderTexture[] m_BlurBuffer2 = new RenderTexture[16];

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.bloom.intensity > 0f)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public void Prepare(RenderTexture source, Material uberMaterial, Texture autoExposure)
			{
				BloomModel.BloomSettings bloom = base.model.settings.bloom;
				BloomModel.LensDirtSettings lensDirt = base.model.settings.lensDirt;
				Material material = context.materialFactory.Get("Hidden/Post FX/Bloom");
				material.shaderKeywords = null;
				material.SetTexture(Uniforms._AutoExposure, autoExposure);
				int width = context.width / 2;
				int num = context.height / 2;
				RenderTextureFormat format = (Application.isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
				float num2 = Mathf.Log(num, 2f) + bloom.radius - 8f;
				int num3 = (int)num2;
				int num4 = Mathf.Clamp(num3, 1, 16);
				float thresholdLinear = bloom.thresholdLinear;
				material.SetFloat(Uniforms._Threshold, thresholdLinear);
				float num5 = thresholdLinear * bloom.softKnee + 1E-05f;
				material.SetVector(value: new Vector3(thresholdLinear - num5, num5 * 2f, 0.25f / num5), nameID: Uniforms._Curve);
				material.SetFloat(Uniforms._PrefilterOffs, bloom.antiFlicker ? (-0.5f) : 0f);
				float num6 = 0.5f + num2 - (float)num3;
				material.SetFloat(Uniforms._SampleScale, num6);
				if (bloom.antiFlicker)
				{
					material.EnableKeyword("ANTI_FLICKER");
				}
				RenderTexture renderTexture = context.renderTextureFactory.Get(width, num, 0, format);
				Graphics.Blit(source, renderTexture, material, 0);
				RenderTexture renderTexture2 = renderTexture;
				for (int i = 0; i < num4; i++)
				{
					m_BlurBuffer1[i] = context.renderTextureFactory.Get(renderTexture2.width / 2, renderTexture2.height / 2, 0, format);
					int pass = ((i == 0) ? 1 : 2);
					Graphics.Blit(renderTexture2, m_BlurBuffer1[i], material, pass);
					renderTexture2 = m_BlurBuffer1[i];
				}
				for (int num7 = num4 - 2; num7 >= 0; num7--)
				{
					RenderTexture renderTexture3 = m_BlurBuffer1[num7];
					material.SetTexture(Uniforms._BaseTex, renderTexture3);
					m_BlurBuffer2[num7] = context.renderTextureFactory.Get(renderTexture3.width, renderTexture3.height, 0, format);
					Graphics.Blit(renderTexture2, m_BlurBuffer2[num7], material, 3);
					renderTexture2 = m_BlurBuffer2[num7];
				}
				RenderTexture renderTexture4 = renderTexture2;
				for (int j = 0; j < 16; j++)
				{
					if (m_BlurBuffer1[j] != null)
					{
						context.renderTextureFactory.Release(m_BlurBuffer1[j]);
					}
					if (m_BlurBuffer2[j] != null && m_BlurBuffer2[j] != renderTexture4)
					{
						context.renderTextureFactory.Release(m_BlurBuffer2[j]);
					}
					m_BlurBuffer1[j] = null;
					m_BlurBuffer2[j] = null;
				}
				context.renderTextureFactory.Release(renderTexture);
				uberMaterial.SetTexture(Uniforms._BloomTex, renderTexture4);
				uberMaterial.SetVector(Uniforms._Bloom_Settings, new Vector2(num6, bloom.intensity));
				if (lensDirt.intensity > 0f && lensDirt.texture != null)
				{
					uberMaterial.SetTexture(Uniforms._Bloom_DirtTex, lensDirt.texture);
					uberMaterial.SetFloat(Uniforms._Bloom_DirtIntensity, lensDirt.intensity);
					uberMaterial.EnableKeyword("BLOOM_LENS_DIRT");
				}
				else
				{
					uberMaterial.EnableKeyword("BLOOM");
				}
			}
		}
		public sealed class BuiltinDebugViewsComponent : PostProcessingComponentCommandBuffer<BuiltinDebugViewsModel>
		{
			private static class Uniforms
			{
				internal static readonly int _DepthScale = Shader.PropertyToID("_DepthScale");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

				internal static readonly int _Opacity = Shader.PropertyToID("_Opacity");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _TempRT2 = Shader.PropertyToID("_TempRT2");

				internal static readonly int _Amplitude = Shader.PropertyToID("_Amplitude");

				internal static readonly int _Scale = Shader.PropertyToID("_Scale");
			}

			private enum Pass
			{
				Depth,
				Normals,
				MovecOpacity,
				MovecImaging,
				MovecArrows
			}

			private class ArrowArray
			{
				public Mesh mesh { get; private set; }

				public int columnCount { get; private set; }

				public int rowCount { get; private set; }

				public void BuildMesh(int columns, int rows)
				{
					Vector3[] array = new Vector3[6]
					{
						new Vector3(0f, 0f, 0f),
						new Vector3(0f, 1f, 0f),
						new Vector3(0f, 1f, 0f),
						new Vector3(-1f, 1f, 0f),
						new Vector3(0f, 1f, 0f),
						new Vector3(1f, 1f, 0f)
					};
					int num = 6 * columns * rows;
					List<Vector3> list = new List<Vector3>(num);
					List<Vector2> list2 = new List<Vector2>(num);
					for (int i = 0; i < rows; i++)
					{
						for (int j = 0; j < columns; j++)
						{
							Vector2 item = new Vector2((0.5f + (float)j) / (float)columns, (0.5f + (float)i) / (float)rows);
							for (int k = 0; k < 6; k++)
							{
								list.Add(array[k]);
								list2.Add(item);
							}
						}
					}
					int[] array2 = new int[num];
					for (int l = 0; l < num; l++)
					{
						array2[l] = l;
					}
					mesh = new Mesh
					{
						hideFlags = HideFlags.DontSave
					};
					mesh.SetVertices(list);
					mesh.SetUVs(0, list2);
					mesh.SetIndices(array2, MeshTopology.Lines, 0);
					mesh.UploadMeshData(markNoLongerReadable: true);
					columnCount = columns;
					rowCount = rows;
				}

				public void Release()
				{
					GraphicsUtils.Destroy(mesh);
					mesh = null;
				}
			}

			private const string k_ShaderString = "Hidden/Post FX/Builtin Debug Views";

			private ArrowArray m_Arrows;

			public override bool active
			{
				get
				{
					if (!base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Depth) && !base.model.IsModeActive(BuiltinDebugViewsModel.Mode.Normals))
					{
						return base.model.IsModeActive(BuiltinDebugViewsModel.Mode.MotionVectors);
					}
					return true;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				BuiltinDebugViewsModel.Mode mode = base.model.settings.mode;
				DepthTextureMode depthTextureMode = DepthTextureMode.None;
				switch (mode)
				{
				case BuiltinDebugViewsModel.Mode.Normals:
					depthTextureMode |= DepthTextureMode.DepthNormals;
					break;
				case BuiltinDebugViewsModel.Mode.MotionVectors:
					depthTextureMode |= DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
					break;
				case BuiltinDebugViewsModel.Mode.Depth:
					depthTextureMode |= DepthTextureMode.Depth;
					break;
				}
				return depthTextureMode;
			}

			public override CameraEvent GetCameraEvent()
			{
				if (base.model.settings.mode != BuiltinDebugViewsModel.Mode.MotionVectors)
				{
					return CameraEvent.BeforeImageEffectsOpaque;
				}
				return CameraEvent.BeforeImageEffects;
			}

			public override string GetName()
			{
				return "Builtin Debug Views";
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				BuiltinDebugViewsModel.Settings settings = base.model.settings;
				Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				material.shaderKeywords = null;
				if (context.isGBufferAvailable)
				{
					material.EnableKeyword("SOURCE_GBUFFER");
				}
				switch (settings.mode)
				{
				case BuiltinDebugViewsModel.Mode.Depth:
					DepthPass(cb);
					break;
				case BuiltinDebugViewsModel.Mode.Normals:
					DepthNormalsPass(cb);
					break;
				case BuiltinDebugViewsModel.Mode.MotionVectors:
					MotionVectorsPass(cb);
					break;
				}
				context.Interrupt();
			}

			private void DepthPass(CommandBuffer cb)
			{
				Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				BuiltinDebugViewsModel.DepthSettings depth = base.model.settings.depth;
				cb.SetGlobalFloat(Uniforms._DepthScale, 1f / depth.scale);
				cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 0);
			}

			private void DepthNormalsPass(CommandBuffer cb)
			{
				Material mat = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				cb.Blit(null, BuiltinRenderTextureType.CameraTarget, mat, 1);
			}

			private void MotionVectorsPass(CommandBuffer cb)
			{
				Material material = context.materialFactory.Get("Hidden/Post FX/Builtin Debug Views");
				BuiltinDebugViewsModel.MotionVectorsSettings motionVectors = base.model.settings.motionVectors;
				int num = Uniforms._TempRT;
				cb.GetTemporaryRT(num, context.width, context.height, 0, FilterMode.Bilinear);
				cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.sourceOpacity);
				cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, num, material, 2);
				if (motionVectors.motionImageOpacity > 0f && motionVectors.motionImageAmplitude > 0f)
				{
					int tempRT = Uniforms._TempRT2;
					cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Bilinear);
					cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionImageOpacity);
					cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionImageAmplitude);
					cb.SetGlobalTexture(Uniforms._MainTex, num);
					cb.Blit(num, tempRT, material, 3);
					cb.ReleaseTemporaryRT(num);
					num = tempRT;
				}
				if (motionVectors.motionVectorsOpacity > 0f && motionVectors.motionVectorsAmplitude > 0f)
				{
					PrepareArrows();
					float num2 = 1f / (float)motionVectors.motionVectorsResolution;
					float x = num2 * (float)context.height / (float)context.width;
					cb.SetGlobalVector(Uniforms._Scale, new Vector2(x, num2));
					cb.SetGlobalFloat(Uniforms._Opacity, motionVectors.motionVectorsOpacity);
					cb.SetGlobalFloat(Uniforms._Amplitude, motionVectors.motionVectorsAmplitude);
					cb.DrawMesh(m_Arrows.mesh, Matrix4x4.identity, material, 0, 4);
				}
				cb.SetGlobalTexture(Uniforms._MainTex, num);
				cb.Blit(num, BuiltinRenderTextureType.CameraTarget);
				cb.ReleaseTemporaryRT(num);
			}

			private void PrepareArrows()
			{
				int motionVectorsResolution = base.model.settings.motionVectors.motionVectorsResolution;
				int num = motionVectorsResolution * Screen.width / Screen.height;
				if (m_Arrows == null)
				{
					m_Arrows = new ArrowArray();
				}
				if (m_Arrows.columnCount != num || m_Arrows.rowCount != motionVectorsResolution)
				{
					m_Arrows.Release();
					m_Arrows.BuildMesh(num, motionVectorsResolution);
				}
			}

			public override void OnDisable()
			{
				if (m_Arrows != null)
				{
					m_Arrows.Release();
				}
				m_Arrows = null;
			}
		}
		public sealed class ChromaticAberrationComponent : PostProcessingComponentRenderTexture<ChromaticAberrationModel>
		{
			private static class Uniforms
			{
				internal static readonly int _ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

				internal static readonly int _ChromaticAberration_Spectrum = Shader.PropertyToID("_ChromaticAberration_Spectrum");
			}

			private Texture2D m_SpectrumLut;

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.intensity > 0f)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void OnDisable()
			{
				GraphicsUtils.Destroy(m_SpectrumLut);
				m_SpectrumLut = null;
			}

			public override void Prepare(Material uberMaterial)
			{
				ChromaticAberrationModel.Settings settings = base.model.settings;
				Texture2D texture2D = settings.spectralTexture;
				if (texture2D == null)
				{
					if (m_SpectrumLut == null)
					{
						m_SpectrumLut = new Texture2D(3, 1, TextureFormat.RGB24, mipChain: false)
						{
							name = "Chromatic Aberration Spectrum Lookup",
							filterMode = FilterMode.Bilinear,
							wrapMode = TextureWrapMode.Clamp,
							anisoLevel = 0,
							hideFlags = HideFlags.DontSave
						};
						Color[] pixels = new Color[3]
						{
							new Color(1f, 0f, 0f),
							new Color(0f, 1f, 0f),
							new Color(0f, 0f, 1f)
						};
						m_SpectrumLut.SetPixels(pixels);
						m_SpectrumLut.Apply();
					}
					texture2D = m_SpectrumLut;
				}
				uberMaterial.EnableKeyword("CHROMATIC_ABERRATION");
				uberMaterial.SetFloat(Uniforms._ChromaticAberration_Amount, settings.intensity * 0.03f);
				uberMaterial.SetTexture(Uniforms._ChromaticAberration_Spectrum, texture2D);
			}
		}
		public sealed class ColorGradingComponent : PostProcessingComponentRenderTexture<ColorGradingModel>
		{
			private static class Uniforms
			{
				internal static readonly int _LutParams = Shader.PropertyToID("_LutParams");

				internal static readonly int _NeutralTonemapperParams1 = Shader.PropertyToID("_NeutralTonemapperParams1");

				internal static readonly int _NeutralTonemapperParams2 = Shader.PropertyToID("_NeutralTonemapperParams2");

				internal static readonly int _HueShift = Shader.PropertyToID("_HueShift");

				internal static readonly int _Saturation = Shader.PropertyToID("_Saturation");

				internal static readonly int _Contrast = Shader.PropertyToID("_Contrast");

				internal static readonly int _Balance = Shader.PropertyToID("_Balance");

				internal static readonly int _Lift = Shader.PropertyToID("_Lift");

				internal static readonly int _InvGamma = Shader.PropertyToID("_InvGamma");

				internal static readonly int _Gain = Shader.PropertyToID("_Gain");

				internal static readonly int _Slope = Shader.PropertyToID("_Slope");

				internal static readonly int _Power = Shader.PropertyToID("_Power");

				internal static readonly int _Offset = Shader.PropertyToID("_Offset");

				internal static readonly int _ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

				internal static readonly int _ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

				internal static readonly int _ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

				internal static readonly int _Curves = Shader.PropertyToID("_Curves");

				internal static readonly int _LogLut = Shader.PropertyToID("_LogLut");

				internal static readonly int _LogLut_Params = Shader.PropertyToID("_LogLut_Params");

				internal static readonly int _ExposureEV = Shader.PropertyToID("_ExposureEV");
			}

			private const int k_InternalLogLutSize = 32;

			private const int k_CurvePrecision = 128;

			private const float k_CurveStep = 1f / 128f;

			private Texture2D m_GradingCurves;

			private Color[] m_pixels = new Color[256];

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			private float StandardIlluminantY(float x)
			{
				return 2.87f * x - 3f * x * x - 0.27509508f;
			}

			private Vector3 CIExyToLMS(float x, float y)
			{
				float num = 1f;
				float num2 = num * x / y;
				float num3 = num * (1f - x - y) / y;
				float x2 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
				float y2 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
				float z = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
				return new Vector3(x2, y2, z);
			}

			private Vector3 CalculateColorBalance(float temperature, float tint)
			{
				float num = temperature / 55f;
				float num2 = tint / 55f;
				float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
				float y = StandardIlluminantY(x) + num2 * 0.05f;
				Vector3 vector = new Vector3(0.949237f, 1.03542f, 1.08728f);
				Vector3 vector2 = CIExyToLMS(x, y);
				return new Vector3(vector.x / vector2.x, vector.y / vector2.y, vector.z / vector2.z);
			}

			private static Color NormalizeColor(Color c)
			{
				float num = (c.r + c.g + c.b) / 3f;
				if (Mathf.Approximately(num, 0f))
				{
					return new Color(1f, 1f, 1f, c.a);
				}
				Color result = default(Color);
				result.r = c.r / num;
				result.g = c.g / num;
				result.b = c.b / num;
				result.a = c.a;
				return result;
			}

			private static Vector3 ClampVector(Vector3 v, float min, float max)
			{
				return new Vector3(Mathf.Clamp(v.x, min, max), Mathf.Clamp(v.y, min, max), Mathf.Clamp(v.z, min, max));
			}

			public static Vector3 GetLiftValue(Color lift)
			{
				Color color = NormalizeColor(lift);
				float num = (color.r + color.g + color.b) / 3f;
				float x = (color.r - num) * 0.1f + lift.a;
				float y = (color.g - num) * 0.1f + lift.a;
				float z = (color.b - num) * 0.1f + lift.a;
				return ClampVector(new Vector3(x, y, z), -1f, 1f);
			}

			public static Vector3 GetGammaValue(Color gamma)
			{
				Color color = NormalizeColor(gamma);
				float num = (color.r + color.g + color.b) / 3f;
				gamma.a *= ((gamma.a < 0f) ? 0.8f : 5f);
				float b = Mathf.Pow(2f, (color.r - num) * 0.5f) + gamma.a;
				float b2 = Mathf.Pow(2f, (color.g - num) * 0.5f) + gamma.a;
				float b3 = Mathf.Pow(2f, (color.b - num) * 0.5f) + gamma.a;
				float x = 1f / Mathf.Max(0.01f, b);
				float y = 1f / Mathf.Max(0.01f, b2);
				float z = 1f / Mathf.Max(0.01f, b3);
				return ClampVector(new Vector3(x, y, z), 0f, 5f);
			}

			public static Vector3 GetGainValue(Color gain)
			{
				Color color = NormalizeColor(gain);
				float num = (color.r + color.g + color.b) / 3f;
				gain.a *= ((gain.a > 0f) ? 3f : 1f);
				float x = Mathf.Pow(2f, (color.r - num) * 0.5f) + gain.a;
				float y = Mathf.Pow(2f, (color.g - num) * 0.5f) + gain.a;
				float z = Mathf.Pow(2f, (color.b - num) * 0.5f) + gain.a;
				return ClampVector(new Vector3(x, y, z), 0f, 4f);
			}

			public static void CalculateLiftGammaGain(Color lift, Color gamma, Color gain, out Vector3 outLift, out Vector3 outGamma, out Vector3 outGain)
			{
				outLift = GetLiftValue(lift);
				outGamma = GetGammaValue(gamma);
				outGain = GetGainValue(gain);
			}

			public static Vector3 GetSlopeValue(Color slope)
			{
				Color color = NormalizeColor(slope);
				float num = (color.r + color.g + color.b) / 3f;
				slope.a *= 0.5f;
				float x = (color.r - num) * 0.1f + slope.a + 1f;
				float y = (color.g - num) * 0.1f + slope.a + 1f;
				float z = (color.b - num) * 0.1f + slope.a + 1f;
				return ClampVector(new Vector3(x, y, z), 0f, 2f);
			}

			public static Vector3 GetPowerValue(Color power)
			{
				Color color = NormalizeColor(power);
				float num = (color.r + color.g + color.b) / 3f;
				power.a *= 0.5f;
				float b = (color.r - num) * 0.1f + power.a + 1f;
				float b2 = (color.g - num) * 0.1f + power.a + 1f;
				float b3 = (color.b - num) * 0.1f + power.a + 1f;
				float x = 1f / Mathf.Max(0.01f, b);
				float y = 1f / Mathf.Max(0.01f, b2);
				float z = 1f / Mathf.Max(0.01f, b3);
				return ClampVector(new Vector3(x, y, z), 0.5f, 2.5f);
			}

			public static Vector3 GetOffsetValue(Color offset)
			{
				Color color = NormalizeColor(offset);
				float num = (color.r + color.g + color.b) / 3f;
				offset.a *= 0.5f;
				float x = (color.r - num) * 0.05f + offset.a;
				float y = (color.g - num) * 0.05f + offset.a;
				float z = (color.b - num) * 0.05f + offset.a;
				return ClampVector(new Vector3(x, y, z), -0.8f, 0.8f);
			}

			public static void CalculateSlopePowerOffset(Color slope, Color power, Color offset, out Vector3 outSlope, out Vector3 outPower, out Vector3 outOffset)
			{
				outSlope = GetSlopeValue(slope);
				outPower = GetPowerValue(power);
				outOffset = GetOffsetValue(offset);
			}

			private TextureFormat GetCurveFormat()
			{
				if (SystemInfo.SupportsTextureFormat(TextureFormat.RGBAHalf))
				{
					return TextureFormat.RGBAHalf;
				}
				return TextureFormat.RGBA32;
			}

			private Texture2D GetCurveTexture()
			{
				if (m_GradingCurves == null)
				{
					m_GradingCurves = new Texture2D(128, 2, GetCurveFormat(), mipChain: false, linear: true)
					{
						name = "Internal Curves Texture",
						hideFlags = HideFlags.DontSave,
						anisoLevel = 0,
						wrapMode = TextureWrapMode.Clamp,
						filterMode = FilterMode.Bilinear
					};
				}
				ColorGradingModel.CurvesSettings curves = base.model.settings.curves;
				curves.hueVShue.Cache();
				curves.hueVSsat.Cache();
				for (int i = 0; i < 128; i++)
				{
					float t = (float)i * (1f / 128f);
					float r = curves.hueVShue.Evaluate(t);
					float g = curves.hueVSsat.Evaluate(t);
					float b = curves.satVSsat.Evaluate(t);
					float a = curves.lumVSsat.Evaluate(t);
					m_pixels[i] = new Color(r, g, b, a);
					float a2 = curves.master.Evaluate(t);
					float r2 = curves.red.Evaluate(t);
					float g2 = curves.green.Evaluate(t);
					float b2 = curves.blue.Evaluate(t);
					m_pixels[i + 128] = new Color(r2, g2, b2, a2);
				}
				m_GradingCurves.SetPixels(m_pixels);
				m_GradingCurves.Apply(updateMipmaps: false, makeNoLongerReadable: false);
				return m_GradingCurves;
			}

			private bool IsLogLutValid(RenderTexture lut)
			{
				if (lut != null && lut.IsCreated())
				{
					return lut.height == 32;
				}
				return false;
			}

			private RenderTextureFormat GetLutFormat()
			{
				if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
				{
					return RenderTextureFormat.ARGBHalf;
				}
				return RenderTextureFormat.ARGB32;
			}

			private void GenerateLut()
			{
				ColorGradingModel.Settings settings = base.model.settings;
				if (!IsLogLutValid(base.model.bakedLut))
				{
					GraphicsUtils.Destroy(base.model.bakedLut);
					base.model.bakedLut = new RenderTexture(1024, 32, 0, GetLutFormat())
					{
						name = "Color Grading Log LUT",
						hideFlags = HideFlags.DontSave,
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Clamp,
						anisoLevel = 0
					};
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Lut Generator");
				material.SetVector(Uniforms._LutParams, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
				material.shaderKeywords = null;
				ColorGradingModel.TonemappingSettings tonemapping = settings.tonemapping;
				switch (tonemapping.tonemapper)
				{
				case ColorGradingModel.Tonemapper.Neutral:
				{
					material.EnableKeyword("TONEMAPPING_NEUTRAL");
					float num = tonemapping.neutralBlackIn * 20f + 1f;
					float num2 = tonemapping.neutralBlackOut * 10f + 1f;
					float num3 = tonemapping.neutralWhiteIn / 20f;
					float num4 = 1f - tonemapping.neutralWhiteOut / 20f;
					float t = num / num2;
					float t2 = num3 / num4;
					float y = Mathf.Max(0f, Mathf.LerpUnclamped(0.57f, 0.37f, t));
					float z = Mathf.LerpUnclamped(0.01f, 0.24f, t2);
					float w = Mathf.Max(0f, Mathf.LerpUnclamped(0.02f, 0.2f, t));
					material.SetVector(Uniforms._NeutralTonemapperParams1, new Vector4(0.2f, y, z, w));
					material.SetVector(Uniforms._NeutralTonemapperParams2, new Vector4(0.02f, 0.3f, tonemapping.neutralWhiteLevel, tonemapping.neutralWhiteClip / 10f));
					break;
				}
				case ColorGradingModel.Tonemapper.ACES:
					material.EnableKeyword("TONEMAPPING_FILMIC");
					break;
				}
				material.SetFloat(Uniforms._HueShift, settings.basic.hueShift / 360f);
				material.SetFloat(Uniforms._Saturation, settings.basic.saturation);
				material.SetFloat(Uniforms._Contrast, settings.basic.contrast);
				material.SetVector(Uniforms._Balance, CalculateColorBalance(settings.basic.temperature, settings.basic.tint));
				CalculateLiftGammaGain(settings.colorWheels.linear.lift, settings.colorWheels.linear.gamma, settings.colorWheels.linear.gain, out var outLift, out var outGamma, out var outGain);
				material.SetVector(Uniforms._Lift, outLift);
				material.SetVector(Uniforms._InvGamma, outGamma);
				material.SetVector(Uniforms._Gain, outGain);
				CalculateSlopePowerOffset(settings.colorWheels.log.slope, settings.colorWheels.log.power, settings.colorWheels.log.offset, out var outSlope, out var outPower, out var outOffset);
				material.SetVector(Uniforms._Slope, outSlope);
				material.SetVector(Uniforms._Power, outPower);
				material.SetVector(Uniforms._Offset, outOffset);
				material.SetVector(Uniforms._ChannelMixerRed, settings.channelMixer.red);
				material.SetVector(Uniforms._ChannelMixerGreen, settings.channelMixer.green);
				material.SetVector(Uniforms._ChannelMixerBlue, settings.channelMixer.blue);
				material.SetTexture(Uniforms._Curves, GetCurveTexture());
				Graphics.Blit(null, base.model.bakedLut, material, 0);
			}

			public override void Prepare(Material uberMaterial)
			{
				if (base.model.isDirty || !IsLogLutValid(base.model.bakedLut))
				{
					GenerateLut();
					base.model.isDirty = false;
				}
				uberMaterial.EnableKeyword(context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.PreGradingLog) ? "COLOR_GRADING_LOG_VIEW" : "COLOR_GRADING");
				RenderTexture bakedLut = base.model.bakedLut;
				uberMaterial.SetTexture(Uniforms._LogLut, bakedLut);
				uberMaterial.SetVector(Uniforms._LogLut_Params, new Vector3(1f / (float)bakedLut.width, 1f / (float)bakedLut.height, (float)bakedLut.height - 1f));
				float value = Mathf.Exp(base.model.settings.basic.postExposure * 0.6931472f);
				uberMaterial.SetFloat(Uniforms._ExposureEV, value);
			}

			public void OnGUI()
			{
				RenderTexture bakedLut = base.model.bakedLut;
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, bakedLut.width, bakedLut.height), bakedLut);
			}

			public override void OnDisable()
			{
				GraphicsUtils.Destroy(m_GradingCurves);
				GraphicsUtils.Destroy(base.model.bakedLut);
				m_GradingCurves = null;
				base.model.bakedLut = null;
			}
		}
		public sealed class DepthOfFieldComponent : PostProcessingComponentRenderTexture<DepthOfFieldModel>
		{
			private static class Uniforms
			{
				internal static readonly int _DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

				internal static readonly int _DepthOfFieldCoCTex = Shader.PropertyToID("_DepthOfFieldCoCTex");

				internal static readonly int _Distance = Shader.PropertyToID("_Distance");

				internal static readonly int _LensCoeff = Shader.PropertyToID("_LensCoeff");

				internal static readonly int _MaxCoC = Shader.PropertyToID("_MaxCoC");

				internal static readonly int _RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

				internal static readonly int _RcpAspect = Shader.PropertyToID("_RcpAspect");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _CoCTex = Shader.PropertyToID("_CoCTex");

				internal static readonly int _TaaParams = Shader.PropertyToID("_TaaParams");

				internal static readonly int _DepthOfFieldParams = Shader.PropertyToID("_DepthOfFieldParams");
			}

			private const string k_ShaderString = "Hidden/Post FX/Depth Of Field";

			private RenderTexture m_CoCHistory;

			private const float k_FilmHeight = 0.024f;

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}

			private float CalculateFocalLength()
			{
				DepthOfFieldModel.Settings settings = base.model.settings;
				if (!settings.useCameraFov)
				{
					return settings.focalLength / 1000f;
				}
				float num = context.camera.fieldOfView * ((float)Math.PI / 180f);
				return 0.012f / Mathf.Tan(0.5f * num);
			}

			private float CalculateMaxCoCRadius(int screenHeight)
			{
				float num = (float)base.model.settings.kernelSize * 4f + 6f;
				return Mathf.Min(0.05f, num / (float)screenHeight);
			}

			private bool CheckHistory(int width, int height)
			{
				if (m_CoCHistory != null && m_CoCHistory.IsCreated() && m_CoCHistory.width == width)
				{
					return m_CoCHistory.height == height;
				}
				return false;
			}

			private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
			{
				if (SystemInfo.SupportsRenderTextureFormat(primary))
				{
					return primary;
				}
				if (SystemInfo.SupportsRenderTextureFormat(secondary))
				{
					return secondary;
				}
				return RenderTextureFormat.Default;
			}

			public void Prepare(RenderTexture source, Material uberMaterial, bool antialiasCoC, Vector2 taaJitter, float taaBlending)
			{
				DepthOfFieldModel.Settings settings = base.model.settings;
				RenderTextureFormat format = RenderTextureFormat.DefaultHDR;
				RenderTextureFormat format2 = SelectFormat(RenderTextureFormat.R8, RenderTextureFormat.RHalf);
				float num = CalculateFocalLength();
				float num2 = Mathf.Max(settings.focusDistance, num);
				float num3 = (float)source.width / (float)source.height;
				float num4 = num * num / (settings.aperture * (num2 - num) * 0.024f * 2f);
				float num5 = CalculateMaxCoCRadius(source.height);
				Material material = context.materialFactory.Get("Hidden/Post FX/Depth Of Field");
				material.SetFloat(Uniforms._Distance, num2);
				material.SetFloat(Uniforms._LensCoeff, num4);
				material.SetFloat(Uniforms._MaxCoC, num5);
				material.SetFloat(Uniforms._RcpMaxCoC, 1f / num5);
				material.SetFloat(Uniforms._RcpAspect, 1f / num3);
				RenderTexture renderTexture = context.renderTextureFactory.Get(context.width, context.height, 0, format2, RenderTextureReadWrite.Linear);
				Graphics.Blit(null, renderTexture, material, 0);
				if (antialiasCoC)
				{
					material.SetTexture(Uniforms._CoCTex, renderTexture);
					float z = (CheckHistory(context.width, context.height) ? taaBlending : 0f);
					material.SetVector(Uniforms._TaaParams, new Vector3(taaJitter.x, taaJitter.y, z));
					RenderTexture temporary = RenderTexture.GetTemporary(context.width, context.height, 0, format2);
					Graphics.Blit(m_CoCHistory, temporary, material, 1);
					context.renderTextureFactory.Release(renderTexture);
					if (m_CoCHistory != null)
					{
						RenderTexture.ReleaseTemporary(m_CoCHistory);
					}
					renderTexture = (m_CoCHistory = temporary);
				}
				RenderTexture renderTexture2 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
				material.SetTexture(Uniforms._CoCTex, renderTexture);
				Graphics.Blit(source, renderTexture2, material, 2);
				RenderTexture renderTexture3 = context.renderTextureFactory.Get(context.width / 2, context.height / 2, 0, format);
				Graphics.Blit(renderTexture2, renderTexture3, material, (int)(3 + settings.kernelSize));
				Graphics.Blit(renderTexture3, renderTexture2, material, 7);
				uberMaterial.SetVector(Uniforms._DepthOfFieldParams, new Vector3(num2, num4, num5));
				if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.FocusPlane))
				{
					uberMaterial.EnableKeyword("DEPTH_OF_FIELD_COC_VIEW");
					context.Interrupt();
				}
				else
				{
					uberMaterial.SetTexture(Uniforms._DepthOfFieldTex, renderTexture2);
					uberMaterial.SetTexture(Uniforms._DepthOfFieldCoCTex, renderTexture);
					uberMaterial.EnableKeyword("DEPTH_OF_FIELD");
				}
				context.renderTextureFactory.Release(renderTexture3);
			}

			public override void OnDisable()
			{
				if (m_CoCHistory != null)
				{
					RenderTexture.ReleaseTemporary(m_CoCHistory);
				}
				m_CoCHistory = null;
			}
		}
		public sealed class DitheringComponent : PostProcessingComponentRenderTexture<DitheringModel>
		{
			private static class Uniforms
			{
				internal static readonly int _DitheringTex = Shader.PropertyToID("_DitheringTex");

				internal static readonly int _DitheringCoords = Shader.PropertyToID("_DitheringCoords");
			}

			private Texture2D[] noiseTextures;

			private int textureIndex;

			private const int k_TextureCount = 64;

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void OnDisable()
			{
				noiseTextures = null;
			}

			private void LoadNoiseTextures()
			{
				noiseTextures = new Texture2D[64];
				for (int i = 0; i < 64; i++)
				{
					noiseTextures[i] = Resources.Load<Texture2D>("Bluenoise64/LDR_LLL1_" + i);
				}
			}

			public override void Prepare(Material uberMaterial)
			{
				if (++textureIndex >= 64)
				{
					textureIndex = 0;
				}
				float value = Random.value;
				float value2 = Random.value;
				if (noiseTextures == null)
				{
					LoadNoiseTextures();
				}
				Texture2D texture2D = noiseTextures[textureIndex];
				uberMaterial.EnableKeyword("DITHERING");
				uberMaterial.SetTexture(Uniforms._DitheringTex, texture2D);
				uberMaterial.SetVector(Uniforms._DitheringCoords, new Vector4((float)context.width / (float)texture2D.width, (float)context.height / (float)texture2D.height, value, value2));
			}
		}
		public sealed class EyeAdaptationComponent : PostProcessingComponentRenderTexture<EyeAdaptationModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Params = Shader.PropertyToID("_Params");

				internal static readonly int _Speed = Shader.PropertyToID("_Speed");

				internal static readonly int _ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");

				internal static readonly int _ExposureCompensation = Shader.PropertyToID("_ExposureCompensation");

				internal static readonly int _AutoExposure = Shader.PropertyToID("_AutoExposure");

				internal static readonly int _DebugWidth = Shader.PropertyToID("_DebugWidth");
			}

			private ComputeShader m_EyeCompute;

			private ComputeBuffer m_HistogramBuffer;

			private readonly RenderTexture[] m_AutoExposurePool = new RenderTexture[2];

			private int m_AutoExposurePingPing;

			private RenderTexture m_CurrentAutoExposure;

			private RenderTexture m_DebugHistogram;

			private static uint[] s_EmptyHistogramBuffer;

			private bool m_FirstFrame = true;

			private const int k_HistogramBins = 64;

			private const int k_HistogramThreadX = 16;

			private const int k_HistogramThreadY = 16;

			public override bool active
			{
				get
				{
					if (base.model.enabled && SystemInfo.supportsComputeShaders)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public void ResetHistory()
			{
				m_FirstFrame = true;
			}

			public override void OnEnable()
			{
				m_FirstFrame = true;
			}

			public override void OnDisable()
			{
				RenderTexture[] autoExposurePool = m_AutoExposurePool;
				for (int i = 0; i < autoExposurePool.Length; i++)
				{
					GraphicsUtils.Destroy(autoExposurePool[i]);
				}
				if (m_HistogramBuffer != null)
				{
					m_HistogramBuffer.Release();
				}
				m_HistogramBuffer = null;
				if (m_DebugHistogram != null)
				{
					m_DebugHistogram.Release();
				}
				m_DebugHistogram = null;
			}

			private Vector4 GetHistogramScaleOffsetRes()
			{
				EyeAdaptationModel.Settings settings = base.model.settings;
				float num = settings.logMax - settings.logMin;
				float num2 = 1f / num;
				float y = (float)(-settings.logMin) * num2;
				return new Vector4(num2, y, Mathf.Floor((float)context.width / 2f), Mathf.Floor((float)context.height / 2f));
			}

			public Texture Prepare(RenderTexture source, Material uberMaterial)
			{
				EyeAdaptationModel.Settings settings = base.model.settings;
				if (m_EyeCompute == null)
				{
					m_EyeCompute = Resources.Load<ComputeShader>("Shaders/EyeHistogram");
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Eye Adaptation");
				material.shaderKeywords = null;
				if (m_HistogramBuffer == null)
				{
					m_HistogramBuffer = new ComputeBuffer(64, 4);
				}
				if (s_EmptyHistogramBuffer == null)
				{
					s_EmptyHistogramBuffer = new uint[64];
				}
				Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes();
				RenderTexture renderTexture = context.renderTextureFactory.Get((int)histogramScaleOffsetRes.z, (int)histogramScaleOffsetRes.w, 0, source.format);
				Graphics.Blit(source, renderTexture);
				if (m_AutoExposurePool[0] == null || !m_AutoExposurePool[0].IsCreated())
				{
					m_AutoExposurePool[0] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
				}
				if (m_AutoExposurePool[1] == null || !m_AutoExposurePool[1].IsCreated())
				{
					m_AutoExposurePool[1] = new RenderTexture(1, 1, 0, RenderTextureFormat.RFloat);
				}
				m_HistogramBuffer.SetData(s_EmptyHistogramBuffer);
				int kernelIndex = m_EyeCompute.FindKernel("KEyeHistogram");
				m_EyeCompute.SetBuffer(kernelIndex, "_Histogram", m_HistogramBuffer);
				m_EyeCompute.SetTexture(kernelIndex, "_Source", renderTexture);
				m_EyeCompute.SetVector("_ScaleOffsetRes", histogramScaleOffsetRes);
				m_EyeCompute.Dispatch(kernelIndex, Mathf.CeilToInt((float)renderTexture.width / 16f), Mathf.CeilToInt((float)renderTexture.height / 16f), 1);
				context.renderTextureFactory.Release(renderTexture);
				settings.highPercent = Mathf.Clamp(settings.highPercent, 1.01f, 99f);
				settings.lowPercent = Mathf.Clamp(settings.lowPercent, 1f, settings.highPercent - 0.01f);
				material.SetBuffer("_Histogram", m_HistogramBuffer);
				material.SetVector(Uniforms._Params, new Vector4(settings.lowPercent * 0.01f, settings.highPercent * 0.01f, Mathf.Exp(settings.minLuminance * 0.6931472f), Mathf.Exp(settings.maxLuminance * 0.6931472f)));
				material.SetVector(Uniforms._Speed, new Vector2(settings.speedDown, settings.speedUp));
				material.SetVector(Uniforms._ScaleOffsetRes, histogramScaleOffsetRes);
				material.SetFloat(Uniforms._ExposureCompensation, settings.keyValue);
				if (settings.dynamicKeyValue)
				{
					material.EnableKeyword("AUTO_KEY_VALUE");
				}
				if (m_FirstFrame || !Application.isPlaying)
				{
					m_CurrentAutoExposure = m_AutoExposurePool[0];
					Graphics.Blit(null, m_CurrentAutoExposure, material, 1);
					Graphics.Blit(m_AutoExposurePool[0], m_AutoExposurePool[1]);
				}
				else
				{
					int autoExposurePingPing = m_AutoExposurePingPing;
					RenderTexture source2 = m_AutoExposurePool[++autoExposurePingPing % 2];
					RenderTexture renderTexture2 = m_AutoExposurePool[++autoExposurePingPing % 2];
					Graphics.Blit(source2, renderTexture2, material, (int)settings.adaptationType);
					m_AutoExposurePingPing = ++autoExposurePingPing % 2;
					m_CurrentAutoExposure = renderTexture2;
				}
				if (context.profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
				{
					if (m_DebugHistogram == null || !m_DebugHistogram.IsCreated())
					{
						m_DebugHistogram = new RenderTexture(256, 128, 0, RenderTextureFormat.ARGB32)
						{
							filterMode = FilterMode.Point,
							wrapMode = TextureWrapMode.Clamp
						};
					}
					material.SetFloat(Uniforms._DebugWidth, m_DebugHistogram.width);
					Graphics.Blit(null, m_DebugHistogram, material, 2);
				}
				m_FirstFrame = false;
				return m_CurrentAutoExposure;
			}

			public void OnGUI()
			{
				if (!(m_DebugHistogram == null) && m_DebugHistogram.IsCreated())
				{
					GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, m_DebugHistogram.width, m_DebugHistogram.height), m_DebugHistogram);
				}
			}
		}
		public sealed class FogComponent : PostProcessingComponentCommandBuffer<FogModel>
		{
			private static class Uniforms
			{
				internal static readonly int _FogColor = Shader.PropertyToID("_FogColor");

				internal static readonly int _Density = Shader.PropertyToID("_Density");

				internal static readonly int _Start = Shader.PropertyToID("_Start");

				internal static readonly int _End = Shader.PropertyToID("_End");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");
			}

			private const string k_ShaderString = "Hidden/Post FX/Fog";

			public override bool active
			{
				get
				{
					if (base.model.enabled && context.isGBufferAvailable && RenderSettings.fog)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override string GetName()
			{
				return "Fog";
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}

			public override CameraEvent GetCameraEvent()
			{
				return CameraEvent.AfterImageEffectsOpaque;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				FogModel.Settings settings = base.model.settings;
				Material material = context.materialFactory.Get("Hidden/Post FX/Fog");
				material.shaderKeywords = null;
				Color value = (GraphicsUtils.isLinearColorSpace ? RenderSettings.fogColor.linear : RenderSettings.fogColor);
				material.SetColor(Uniforms._FogColor, value);
				material.SetFloat(Uniforms._Density, RenderSettings.fogDensity);
				material.SetFloat(Uniforms._Start, RenderSettings.fogStartDistance);
				material.SetFloat(Uniforms._End, RenderSettings.fogEndDistance);
				switch (RenderSettings.fogMode)
				{
				case FogMode.Linear:
					material.EnableKeyword("FOG_LINEAR");
					break;
				case FogMode.Exponential:
					material.EnableKeyword("FOG_EXP");
					break;
				case FogMode.ExponentialSquared:
					material.EnableKeyword("FOG_EXP2");
					break;
				}
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				cb.GetTemporaryRT(Uniforms._TempRT, context.width, context.height, 24, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, Uniforms._TempRT);
				cb.Blit(Uniforms._TempRT, BuiltinRenderTextureType.CameraTarget, material, settings.excludeSkybox ? 1 : 0);
				cb.ReleaseTemporaryRT(Uniforms._TempRT);
			}
		}
		public sealed class FxaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
		{
			private static class Uniforms
			{
				internal static readonly int _QualitySettings = Shader.PropertyToID("_QualitySettings");

				internal static readonly int _ConsoleSettings = Shader.PropertyToID("_ConsoleSettings");
			}

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Fxaa)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public void Render(RenderTexture source, RenderTexture destination)
			{
				AntialiasingModel.FxaaSettings fxaaSettings = base.model.settings.fxaaSettings;
				Material material = context.materialFactory.Get("Hidden/Post FX/FXAA");
				AntialiasingModel.FxaaQualitySettings fxaaQualitySettings = AntialiasingModel.FxaaQualitySettings.presets[(int)fxaaSettings.preset];
				AntialiasingModel.FxaaConsoleSettings fxaaConsoleSettings = AntialiasingModel.FxaaConsoleSettings.presets[(int)fxaaSettings.preset];
				material.SetVector(Uniforms._QualitySettings, new Vector3(fxaaQualitySettings.subpixelAliasingRemovalAmount, fxaaQualitySettings.edgeDetectionThreshold, fxaaQualitySettings.minimumRequiredLuminance));
				material.SetVector(Uniforms._ConsoleSettings, new Vector4(fxaaConsoleSettings.subpixelSpreadAmount, fxaaConsoleSettings.edgeSharpnessAmount, fxaaConsoleSettings.edgeDetectionThreshold, fxaaConsoleSettings.minimumRequiredLuminance));
				Graphics.Blit(source, destination, material, 0);
			}
		}
		public sealed class GrainComponent : PostProcessingComponentRenderTexture<GrainModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

				internal static readonly int _Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

				internal static readonly int _GrainTex = Shader.PropertyToID("_GrainTex");

				internal static readonly int _Phase = Shader.PropertyToID("_Phase");
			}

			private RenderTexture m_GrainLookupRT;

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.intensity > 0f && SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void OnDisable()
			{
				GraphicsUtils.Destroy(m_GrainLookupRT);
				m_GrainLookupRT = null;
			}

			public override void Prepare(Material uberMaterial)
			{
				GrainModel.Settings settings = base.model.settings;
				uberMaterial.EnableKeyword("GRAIN");
				float realtimeSinceStartup = Time.realtimeSinceStartup;
				float value = Random.value;
				float value2 = Random.value;
				if (m_GrainLookupRT == null || !m_GrainLookupRT.IsCreated())
				{
					GraphicsUtils.Destroy(m_GrainLookupRT);
					m_GrainLookupRT = new RenderTexture(192, 192, 0, RenderTextureFormat.ARGBHalf)
					{
						filterMode = FilterMode.Bilinear,
						wrapMode = TextureWrapMode.Repeat,
						anisoLevel = 0,
						name = "Grain Lookup Texture"
					};
					m_GrainLookupRT.Create();
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Grain Generator");
				material.SetFloat(Uniforms._Phase, realtimeSinceStartup / 20f);
				Graphics.Blit(null, m_GrainLookupRT, material, settings.colored ? 1 : 0);
				uberMaterial.SetTexture(Uniforms._GrainTex, m_GrainLookupRT);
				uberMaterial.SetVector(Uniforms._Grain_Params1, new Vector2(settings.luminanceContribution, settings.intensity * 20f));
				uberMaterial.SetVector(Uniforms._Grain_Params2, new Vector4((float)context.width / (float)m_GrainLookupRT.width / settings.size, (float)context.height / (float)m_GrainLookupRT.height / settings.size, value, value2));
			}
		}
		public sealed class MotionBlurComponent : PostProcessingComponentCommandBuffer<MotionBlurModel>
		{
			private static class Uniforms
			{
				internal static readonly int _VelocityScale = Shader.PropertyToID("_VelocityScale");

				internal static readonly int _MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

				internal static readonly int _RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

				internal static readonly int _VelocityTex = Shader.PropertyToID("_VelocityTex");

				internal static readonly int _MainTex = Shader.PropertyToID("_MainTex");

				internal static readonly int _Tile2RT = Shader.PropertyToID("_Tile2RT");

				internal static readonly int _Tile4RT = Shader.PropertyToID("_Tile4RT");

				internal static readonly int _Tile8RT = Shader.PropertyToID("_Tile8RT");

				internal static readonly int _TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

				internal static readonly int _TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

				internal static readonly int _TileVRT = Shader.PropertyToID("_TileVRT");

				internal static readonly int _NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

				internal static readonly int _LoopCount = Shader.PropertyToID("_LoopCount");

				internal static readonly int _TempRT = Shader.PropertyToID("_TempRT");

				internal static readonly int _History1LumaTex = Shader.PropertyToID("_History1LumaTex");

				internal static readonly int _History2LumaTex = Shader.PropertyToID("_History2LumaTex");

				internal static readonly int _History3LumaTex = Shader.PropertyToID("_History3LumaTex");

				internal static readonly int _History4LumaTex = Shader.PropertyToID("_History4LumaTex");

				internal static readonly int _History1ChromaTex = Shader.PropertyToID("_History1ChromaTex");

				internal static readonly int _History2ChromaTex = Shader.PropertyToID("_History2ChromaTex");

				internal static readonly int _History3ChromaTex = Shader.PropertyToID("_History3ChromaTex");

				internal static readonly int _History4ChromaTex = Shader.PropertyToID("_History4ChromaTex");

				internal static readonly int _History1Weight = Shader.PropertyToID("_History1Weight");

				internal static readonly int _History2Weight = Shader.PropertyToID("_History2Weight");

				internal static readonly int _History3Weight = Shader.PropertyToID("_History3Weight");

				internal static readonly int _History4Weight = Shader.PropertyToID("_History4Weight");
			}

			private enum Pass
			{
				VelocitySetup,
				TileMax1,
				TileMax2,
				TileMaxV,
				NeighborMax,
				Reconstruction,
				FrameCompression,
				FrameBlendingChroma,
				FrameBlendingRaw
			}

			public class ReconstructionFilter
			{
				private RenderTextureFormat m_VectorRTFormat = RenderTextureFormat.RGHalf;

				private RenderTextureFormat m_PackedRTFormat = RenderTextureFormat.ARGB2101010;

				public ReconstructionFilter()
				{
					CheckTextureFormatSupport();
				}

				private void CheckTextureFormatSupport()
				{
					if (!SystemInfo.SupportsRenderTextureFormat(m_PackedRTFormat))
					{
						m_PackedRTFormat = RenderTextureFormat.ARGB32;
					}
				}

				public bool IsSupported()
				{
					return SystemInfo.supportsMotionVectors;
				}

				public void ProcessImage(PostProcessingContext context, CommandBuffer cb, ref MotionBlurModel.Settings settings, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
				{
					int num = (int)(5f * (float)context.height / 100f);
					int num2 = ((num - 1) / 8 + 1) * 8;
					float value = settings.shutterAngle / 360f;
					cb.SetGlobalFloat(Uniforms._VelocityScale, value);
					cb.SetGlobalFloat(Uniforms._MaxBlurRadius, num);
					cb.SetGlobalFloat(Uniforms._RcpMaxBlurRadius, 1f / (float)num);
					int velocityTex = Uniforms._VelocityTex;
					cb.GetTemporaryRT(velocityTex, context.width, context.height, 0, FilterMode.Point, m_PackedRTFormat, RenderTextureReadWrite.Linear);
					cb.Blit(null, velocityTex, material, 0);
					int tile2RT = Uniforms._Tile2RT;
					cb.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, velocityTex);
					cb.Blit(velocityTex, tile2RT, material, 1);
					int tile4RT = Uniforms._Tile4RT;
					cb.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tile2RT);
					cb.Blit(tile2RT, tile4RT, material, 2);
					cb.ReleaseTemporaryRT(tile2RT);
					int tile8RT = Uniforms._Tile8RT;
					cb.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tile4RT);
					cb.Blit(tile4RT, tile8RT, material, 2);
					cb.ReleaseTemporaryRT(tile4RT);
					Vector2 vector = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
					cb.SetGlobalVector(Uniforms._TileMaxOffs, vector);
					cb.SetGlobalFloat(Uniforms._TileMaxLoop, (int)((float)num2 / 8f));
					int tileVRT = Uniforms._TileVRT;
					cb.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tile8RT);
					cb.Blit(tile8RT, tileVRT, material, 3);
					cb.ReleaseTemporaryRT(tile8RT);
					int neighborMaxTex = Uniforms._NeighborMaxTex;
					int width = context.width / num2;
					int height = context.height / num2;
					cb.GetTemporaryRT(neighborMaxTex, width, height, 0, FilterMode.Point, m_VectorRTFormat, RenderTextureReadWrite.Linear);
					cb.SetGlobalTexture(Uniforms._MainTex, tileVRT);
					cb.Blit(tileVRT, neighborMaxTex, material, 4);
					cb.ReleaseTemporaryRT(tileVRT);
					cb.SetGlobalFloat(Uniforms._LoopCount, Mathf.Clamp(settings.sampleCount / 2, 1, 64));
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, destination, material, 5);
					cb.ReleaseTemporaryRT(velocityTex);
					cb.ReleaseTemporaryRT(neighborMaxTex);
				}
			}

			public class FrameBlendingFilter
			{
				private struct Frame
				{
					public RenderTexture lumaTexture;

					public RenderTexture chromaTexture;

					private float m_Time;

					private RenderTargetIdentifier[] m_MRT;

					public float CalculateWeight(float strength, float currentTime)
					{
						if (Mathf.Approximately(m_Time, 0f))
						{
							return 0f;
						}
						float num = Mathf.Lerp(80f, 16f, strength);
						return Mathf.Exp((m_Time - currentTime) * num);
					}

					public void Release()
					{
						if (lumaTexture != null)
						{
							RenderTexture.ReleaseTemporary(lumaTexture);
						}
						if (chromaTexture != null)
						{
							RenderTexture.ReleaseTemporary(chromaTexture);
						}
						lumaTexture = null;
						chromaTexture = null;
					}

					public void MakeRecord(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
					{
						Release();
						lumaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
						chromaTexture = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.R8, RenderTextureReadWrite.Linear);
						lumaTexture.filterMode = FilterMode.Point;
						chromaTexture.filterMode = FilterMode.Point;
						if (m_MRT == null)
						{
							m_MRT = new RenderTargetIdentifier[2];
						}
						m_MRT[0] = lumaTexture;
						m_MRT[1] = chromaTexture;
						cb.SetGlobalTexture(Uniforms._MainTex, source);
						cb.SetRenderTarget(m_MRT, lumaTexture);
						cb.DrawMesh(GraphicsUtils.quad, Matrix4x4.identity, material, 0, 6);
						m_Time = Time.time;
					}

					public void MakeRecordRaw(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, RenderTextureFormat format)
					{
						Release();
						lumaTexture = RenderTexture.GetTemporary(width, height, 0, format);
						lumaTexture.filterMode = FilterMode.Point;
						cb.SetGlobalTexture(Uniforms._MainTex, source);
						cb.Blit(source, lumaTexture);
						m_Time = Time.time;
					}
				}

				private bool m_UseCompression;

				private RenderTextureFormat m_RawTextureFormat;

				private Frame[] m_FrameList;

				private int m_LastFrameCount;

				public FrameBlendingFilter()
				{
					m_UseCompression = CheckSupportCompression();
					m_RawTextureFormat = GetPreferredRenderTextureFormat();
					m_FrameList = new Frame[4];
				}

				public void Dispose()
				{
					Frame[] frameList = m_FrameList;
					foreach (Frame frame in frameList)
					{
						frame.Release();
					}
				}

				public void PushFrame(CommandBuffer cb, RenderTargetIdentifier source, int width, int height, Material material)
				{
					int frameCount = Time.frameCount;
					if (frameCount != m_LastFrameCount)
					{
						int num = frameCount % m_FrameList.Length;
						if (m_UseCompression)
						{
							m_FrameList[num].MakeRecord(cb, source, width, height, material);
						}
						else
						{
							m_FrameList[num].MakeRecordRaw(cb, source, width, height, m_RawTextureFormat);
						}
						m_LastFrameCount = frameCount;
					}
				}

				public void BlendFrames(CommandBuffer cb, float strength, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material)
				{
					float time = Time.time;
					Frame frameRelative = GetFrameRelative(-1);
					Frame frameRelative2 = GetFrameRelative(-2);
					Frame frameRelative3 = GetFrameRelative(-3);
					Frame frameRelative4 = GetFrameRelative(-4);
					cb.SetGlobalTexture(Uniforms._History1LumaTex, frameRelative.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History2LumaTex, frameRelative2.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History3LumaTex, frameRelative3.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History4LumaTex, frameRelative4.lumaTexture);
					cb.SetGlobalTexture(Uniforms._History1ChromaTex, frameRelative.chromaTexture);
					cb.SetGlobalTexture(Uniforms._History2ChromaTex, frameRelative2.chromaTexture);
					cb.SetGlobalTexture(Uniforms._History3ChromaTex, frameRelative3.chromaTexture);
					cb.SetGlobalTexture(Uniforms._History4ChromaTex, frameRelative4.chromaTexture);
					cb.SetGlobalFloat(Uniforms._History1Weight, frameRelative.CalculateWeight(strength, time));
					cb.SetGlobalFloat(Uniforms._History2Weight, frameRelative2.CalculateWeight(strength, time));
					cb.SetGlobalFloat(Uniforms._History3Weight, frameRelative3.CalculateWeight(strength, time));
					cb.SetGlobalFloat(Uniforms._History4Weight, frameRelative4.CalculateWeight(strength, time));
					cb.SetGlobalTexture(Uniforms._MainTex, source);
					cb.Blit(source, destination, material, m_UseCompression ? 7 : 8);
				}

				private static bool CheckSupportCompression()
				{
					if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.R8))
					{
						return SystemInfo.supportedRenderTargetCount > 1;
					}
					return false;
				}

				private static RenderTextureFormat GetPreferredRenderTextureFormat()
				{
					RenderTextureFormat[] array = new RenderTextureFormat[3]
					{
						RenderTextureFormat.RGB565,
						RenderTextureFormat.ARGB1555,
						RenderTextureFormat.ARGB4444
					};
					foreach (RenderTextureFormat renderTextureFormat in array)
					{
						if (SystemInfo.SupportsRenderTextureFormat(renderTextureFormat))
						{
							return renderTextureFormat;
						}
					}
					return RenderTextureFormat.Default;
				}

				private Frame GetFrameRelative(int offset)
				{
					int num = (Time.frameCount + m_FrameList.Length + offset) % m_FrameList.Length;
					return m_FrameList[num];
				}
			}

			private ReconstructionFilter m_ReconstructionFilter;

			private FrameBlendingFilter m_FrameBlendingFilter;

			private bool m_FirstFrame = true;

			public ReconstructionFilter reconstructionFilter
			{
				get
				{
					if (m_ReconstructionFilter == null)
					{
						m_ReconstructionFilter = new ReconstructionFilter();
					}
					return m_ReconstructionFilter;
				}
			}

			public FrameBlendingFilter frameBlendingFilter
			{
				get
				{
					if (m_FrameBlendingFilter == null)
					{
						m_FrameBlendingFilter = new FrameBlendingFilter();
					}
					return m_FrameBlendingFilter;
				}
			}

			public override bool active
			{
				get
				{
					MotionBlurModel.Settings settings = base.model.settings;
					if (base.model.enabled && ((settings.shutterAngle > 0f && reconstructionFilter.IsSupported()) || settings.frameBlending > 0f) && SystemInfo.graphicsDeviceType != GraphicsDeviceType.OpenGLES2)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override string GetName()
			{
				return "Motion Blur";
			}

			public void ResetHistory()
			{
				if (m_FrameBlendingFilter != null)
				{
					m_FrameBlendingFilter.Dispose();
				}
				m_FrameBlendingFilter = null;
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
			}

			public override CameraEvent GetCameraEvent()
			{
				return CameraEvent.BeforeImageEffects;
			}

			public override void OnEnable()
			{
				m_FirstFrame = true;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				if (m_FirstFrame)
				{
					m_FirstFrame = false;
					return;
				}
				Material material = context.materialFactory.Get("Hidden/Post FX/Motion Blur");
				Material mat = context.materialFactory.Get("Hidden/Post FX/Blit");
				MotionBlurModel.Settings settings = base.model.settings;
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
				int tempRT = Uniforms._TempRT;
				cb.GetTemporaryRT(tempRT, context.width, context.height, 0, FilterMode.Point, format);
				if (settings.shutterAngle > 0f && settings.frameBlending > 0f)
				{
					reconstructionFilter.ProcessImage(context, cb, ref settings, BuiltinRenderTextureType.CameraTarget, tempRT, material);
					frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
					frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
				}
				else if (settings.shutterAngle > 0f)
				{
					cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
					cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
					reconstructionFilter.ProcessImage(context, cb, ref settings, tempRT, BuiltinRenderTextureType.CameraTarget, material);
				}
				else if (settings.frameBlending > 0f)
				{
					cb.SetGlobalTexture(Uniforms._MainTex, BuiltinRenderTextureType.CameraTarget);
					cb.Blit(BuiltinRenderTextureType.CameraTarget, tempRT, mat, 0);
					frameBlendingFilter.BlendFrames(cb, settings.frameBlending, tempRT, BuiltinRenderTextureType.CameraTarget, material);
					frameBlendingFilter.PushFrame(cb, tempRT, context.width, context.height, material);
				}
				cb.ReleaseTemporaryRT(tempRT);
			}

			public override void OnDisable()
			{
				if (m_FrameBlendingFilter != null)
				{
					m_FrameBlendingFilter.Dispose();
				}
			}
		}
		public sealed class ScreenSpaceReflectionComponent : PostProcessingComponentCommandBuffer<ScreenSpaceReflectionModel>
		{
			private static class Uniforms
			{
				internal static readonly int _RayStepSize = Shader.PropertyToID("_RayStepSize");

				internal static readonly int _AdditiveReflection = Shader.PropertyToID("_AdditiveReflection");

				internal static readonly int _BilateralUpsampling = Shader.PropertyToID("_BilateralUpsampling");

				internal static readonly int _TreatBackfaceHitAsMiss = Shader.PropertyToID("_TreatBackfaceHitAsMiss");

				internal static readonly int _AllowBackwardsRays = Shader.PropertyToID("_AllowBackwardsRays");

				internal static readonly int _TraceBehindObjects = Shader.PropertyToID("_TraceBehindObjects");

				internal static readonly int _MaxSteps = Shader.PropertyToID("_MaxSteps");

				internal static readonly int _FullResolutionFiltering = Shader.PropertyToID("_FullResolutionFiltering");

				internal static readonly int _HalfResolution = Shader.PropertyToID("_HalfResolution");

				internal static readonly int _HighlightSuppression = Shader.PropertyToID("_HighlightSuppression");

				internal static readonly int _PixelsPerMeterAtOneMeter = Shader.PropertyToID("_PixelsPerMeterAtOneMeter");

				internal static readonly int _ScreenEdgeFading = Shader.PropertyToID("_ScreenEdgeFading");

				internal static readonly int _ReflectionBlur = Shader.PropertyToID("_ReflectionBlur");

				internal static readonly int _MaxRayTraceDistance = Shader.PropertyToID("_MaxRayTraceDistance");

				internal static readonly int _FadeDistance = Shader.PropertyToID("_FadeDistance");

				internal static readonly int _LayerThickness = Shader.PropertyToID("_LayerThickness");

				internal static readonly int _SSRMultiplier = Shader.PropertyToID("_SSRMultiplier");

				internal static readonly int _FresnelFade = Shader.PropertyToID("_FresnelFade");

				internal static readonly int _FresnelFadePower = Shader.PropertyToID("_FresnelFadePower");

				internal static readonly int _ReflectionBufferSize = Shader.PropertyToID("_ReflectionBufferSize");

				internal static readonly int _ScreenSize = Shader.PropertyToID("_ScreenSize");

				internal static readonly int _InvScreenSize = Shader.PropertyToID("_InvScreenSize");

				internal static readonly int _ProjInfo = Shader.PropertyToID("_ProjInfo");

				internal static readonly int _CameraClipInfo = Shader.PropertyToID("_CameraClipInfo");

				internal static readonly int _ProjectToPixelMatrix = Shader.PropertyToID("_ProjectToPixelMatrix");

				internal static readonly int _WorldToCameraMatrix = Shader.PropertyToID("_WorldToCameraMatrix");

				internal static readonly int _CameraToWorldMatrix = Shader.PropertyToID("_CameraToWorldMatrix");

				internal static readonly int _Axis = Shader.PropertyToID("_Axis");

				internal static readonly int _CurrentMipLevel = Shader.PropertyToID("_CurrentMipLevel");

				internal static readonly int _NormalAndRoughnessTexture = Shader.PropertyToID("_NormalAndRoughnessTexture");

				internal static readonly int _HitPointTexture = Shader.PropertyToID("_HitPointTexture");

				internal static readonly int _BlurTexture = Shader.PropertyToID("_BlurTexture");

				internal static readonly int _FilteredReflections = Shader.PropertyToID("_FilteredReflections");

				internal static readonly int _FinalReflectionTexture = Shader.PropertyToID("_FinalReflectionTexture");

				internal static readonly int _TempTexture = Shader.PropertyToID("_TempTexture");
			}

			private enum PassIndex
			{
				RayTraceStep,
				CompositeFinal,
				Blur,
				CompositeSSR,
				MinMipGeneration,
				HitPointToReflections,
				BilateralKeyPack,
				BlitDepthAsCSZ,
				PoissonBlur
			}

			private bool k_HighlightSuppression;

			private bool k_TraceBehindObjects = true;

			private bool k_TreatBackfaceHitAsMiss;

			private bool k_BilateralUpsample = true;

			private readonly int[] m_ReflectionTextures = new int[5];

			public override bool active
			{
				get
				{
					if (base.model.enabled && context.isGBufferAvailable)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth;
			}

			public override void OnEnable()
			{
				m_ReflectionTextures[0] = Shader.PropertyToID("_ReflectionTexture0");
				m_ReflectionTextures[1] = Shader.PropertyToID("_ReflectionTexture1");
				m_ReflectionTextures[2] = Shader.PropertyToID("_ReflectionTexture2");
				m_ReflectionTextures[3] = Shader.PropertyToID("_ReflectionTexture3");
				m_ReflectionTextures[4] = Shader.PropertyToID("_ReflectionTexture4");
			}

			public override string GetName()
			{
				return "Screen Space Reflection";
			}

			public override CameraEvent GetCameraEvent()
			{
				return CameraEvent.AfterFinalPass;
			}

			public override void PopulateCommandBuffer(CommandBuffer cb)
			{
				ScreenSpaceReflectionModel.Settings settings = base.model.settings;
				Camera camera = context.camera;
				int num = ((settings.reflection.reflectionQuality == ScreenSpaceReflectionModel.SSRResolution.High) ? 1 : 2);
				int num2 = context.width / num;
				int num3 = context.height / num;
				float num4 = context.width;
				float num5 = context.height;
				float num6 = num4 / 2f;
				float num7 = num5 / 2f;
				Material material = context.materialFactory.Get("Hidden/Post FX/Screen Space Reflection");
				material.SetInt(Uniforms._RayStepSize, settings.reflection.stepSize);
				material.SetInt(Uniforms._AdditiveReflection, (settings.reflection.blendType == ScreenSpaceReflectionModel.SSRReflectionBlendType.Additive) ? 1 : 0);
				material.SetInt(Uniforms._BilateralUpsampling, k_BilateralUpsample ? 1 : 0);
				material.SetInt(Uniforms._TreatBackfaceHitAsMiss, k_TreatBackfaceHitAsMiss ? 1 : 0);
				material.SetInt(Uniforms._AllowBackwardsRays, settings.reflection.reflectBackfaces ? 1 : 0);
				material.SetInt(Uniforms._TraceBehindObjects, k_TraceBehindObjects ? 1 : 0);
				material.SetInt(Uniforms._MaxSteps, settings.reflection.iterationCount);
				material.SetInt(Uniforms._FullResolutionFiltering, 0);
				material.SetInt(Uniforms._HalfResolution, (settings.reflection.reflectionQuality != 0) ? 1 : 0);
				material.SetInt(Uniforms._HighlightSuppression, k_HighlightSuppression ? 1 : 0);
				float value = num4 / (-2f * Mathf.Tan(camera.fieldOfView / 180f * (float)Math.PI * 0.5f));
				material.SetFloat(Uniforms._PixelsPerMeterAtOneMeter, value);
				material.SetFloat(Uniforms._ScreenEdgeFading, settings.screenEdgeMask.intensity);
				material.SetFloat(Uniforms._ReflectionBlur, settings.reflection.reflectionBlur);
				material.SetFloat(Uniforms._MaxRayTraceDistance, settings.reflection.maxDistance);
				material.SetFloat(Uniforms._FadeDistance, settings.intensity.fadeDistance);
				material.SetFloat(Uniforms._LayerThickness, settings.reflection.widthModifier);
				material.SetFloat(Uniforms._SSRMultiplier, settings.intensity.reflectionMultiplier);
				material.SetFloat(Uniforms._FresnelFade, settings.intensity.fresnelFade);
				material.SetFloat(Uniforms._FresnelFadePower, settings.intensity.fresnelFadePower);
				Matrix4x4 projectionMatrix = camera.projectionMatrix;
				Vector4 value2 = new Vector4(-2f / (num4 * projectionMatrix[0]), -2f / (num5 * projectionMatrix[5]), (1f - projectionMatrix[2]) / projectionMatrix[0], (1f + projectionMatrix[6]) / projectionMatrix[5]);
				Vector3 vector = (float.IsPositiveInfinity(camera.farClipPlane) ? new Vector3(camera.nearClipPlane, -1f, 1f) : new Vector3(camera.nearClipPlane * camera.farClipPlane, camera.nearClipPlane - camera.farClipPlane, camera.farClipPlane));
				material.SetVector(Uniforms._ReflectionBufferSize, new Vector2(num2, num3));
				material.SetVector(Uniforms._ScreenSize, new Vector2(num4, num5));
				material.SetVector(Uniforms._InvScreenSize, new Vector2(1f / num4, 1f / num5));
				material.SetVector(Uniforms._ProjInfo, value2);
				material.SetVector(Uniforms._CameraClipInfo, vector);
				Matrix4x4 matrix4x = default(Matrix4x4);
				matrix4x.SetRow(0, new Vector4(num6, 0f, 0f, num6));
				matrix4x.SetRow(1, new Vector4(0f, num7, 0f, num7));
				matrix4x.SetRow(2, new Vector4(0f, 0f, 1f, 0f));
				matrix4x.SetRow(3, new Vector4(0f, 0f, 0f, 1f));
				Matrix4x4 value3 = matrix4x * projectionMatrix;
				material.SetMatrix(Uniforms._ProjectToPixelMatrix, value3);
				material.SetMatrix(Uniforms._WorldToCameraMatrix, camera.worldToCameraMatrix);
				material.SetMatrix(Uniforms._CameraToWorldMatrix, camera.worldToCameraMatrix.inverse);
				RenderTextureFormat format = (context.isHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.ARGB32);
				int normalAndRoughnessTexture = Uniforms._NormalAndRoughnessTexture;
				int hitPointTexture = Uniforms._HitPointTexture;
				int blurTexture = Uniforms._BlurTexture;
				int filteredReflections = Uniforms._FilteredReflections;
				int finalReflectionTexture = Uniforms._FinalReflectionTexture;
				int tempTexture = Uniforms._TempTexture;
				cb.GetTemporaryRT(normalAndRoughnessTexture, -1, -1, 0, FilterMode.Point, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				cb.GetTemporaryRT(hitPointTexture, num2, num3, 0, FilterMode.Bilinear, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
				for (int i = 0; i < 5; i++)
				{
					cb.GetTemporaryRT(m_ReflectionTextures[i], num2 >> i, num3 >> i, 0, FilterMode.Bilinear, format);
				}
				cb.GetTemporaryRT(filteredReflections, num2, num3, 0, (!k_BilateralUpsample) ? FilterMode.Bilinear : FilterMode.Point, format);
				cb.GetTemporaryRT(finalReflectionTexture, num2, num3, 0, FilterMode.Point, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, normalAndRoughnessTexture, material, 6);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, hitPointTexture, material, 0);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, filteredReflections, material, 5);
				cb.Blit(filteredReflections, m_ReflectionTextures[0], material, 8);
				for (int j = 1; j < 5; j++)
				{
					int num8 = m_ReflectionTextures[j - 1];
					int num9 = j;
					cb.GetTemporaryRT(blurTexture, num2 >> num9, num3 >> num9, 0, FilterMode.Bilinear, format);
					cb.SetGlobalVector(Uniforms._Axis, new Vector4(1f, 0f, 0f, 0f));
					cb.SetGlobalFloat(Uniforms._CurrentMipLevel, (float)j - 1f);
					cb.Blit(num8, blurTexture, material, 2);
					cb.SetGlobalVector(Uniforms._Axis, new Vector4(0f, 1f, 0f, 0f));
					num8 = m_ReflectionTextures[j];
					cb.Blit(blurTexture, num8, material, 2);
					cb.ReleaseTemporaryRT(blurTexture);
				}
				cb.Blit(m_ReflectionTextures[0], finalReflectionTexture, material, 3);
				cb.GetTemporaryRT(tempTexture, camera.pixelWidth, camera.pixelHeight, 0, FilterMode.Bilinear, format);
				cb.Blit(BuiltinRenderTextureType.CameraTarget, tempTexture, material, 1);
				cb.Blit(tempTexture, BuiltinRenderTextureType.CameraTarget);
				cb.ReleaseTemporaryRT(tempTexture);
			}
		}
		public sealed class TaaComponent : PostProcessingComponentRenderTexture<AntialiasingModel>
		{
			private static class Uniforms
			{
				internal static int _Jitter = Shader.PropertyToID("_Jitter");

				internal static int _SharpenParameters = Shader.PropertyToID("_SharpenParameters");

				internal static int _FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

				internal static int _HistoryTex = Shader.PropertyToID("_HistoryTex");

				internal static int _MainTex = Shader.PropertyToID("_MainTex");
			}

			private const string k_ShaderString = "Hidden/Post FX/Temporal Anti-aliasing";

			private const int k_SampleCount = 8;

			private readonly RenderBuffer[] m_MRT = new RenderBuffer[2];

			private int m_SampleIndex;

			private bool m_ResetHistory = true;

			private RenderTexture m_HistoryTexture;

			public override bool active
			{
				get
				{
					if (base.model.enabled && base.model.settings.method == AntialiasingModel.Method.Taa && SystemInfo.supportsMotionVectors && SystemInfo.supportedRenderTargetCount >= 2)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public Vector2 jitterVector { get; private set; }

			public override DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.Depth | DepthTextureMode.MotionVectors;
			}

			public void ResetHistory()
			{
				m_ResetHistory = true;
			}

			public void SetProjectionMatrix(Func<Vector2, Matrix4x4> jitteredFunc)
			{
				AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
				Vector2 vector = GenerateRandomOffset();
				vector *= taaSettings.jitterSpread;
				context.camera.nonJitteredProjectionMatrix = context.camera.projectionMatrix;
				if (jitteredFunc != null)
				{
					context.camera.projectionMatrix = jitteredFunc(vector);
				}
				else
				{
					context.camera.projectionMatrix = (context.camera.orthographic ? GetOrthographicProjectionMatrix(vector) : GetPerspectiveProjectionMatrix(vector));
				}
				context.camera.useJitteredProjectionMatrixForTransparentRendering = false;
				vector.x /= context.width;
				vector.y /= context.height;
				context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing").SetVector(Uniforms._Jitter, vector);
				jitterVector = vector;
			}

			public void Render(RenderTexture source, RenderTexture destination)
			{
				Material material = context.materialFactory.Get("Hidden/Post FX/Temporal Anti-aliasing");
				material.shaderKeywords = null;
				AntialiasingModel.TaaSettings taaSettings = base.model.settings.taaSettings;
				if (m_ResetHistory || m_HistoryTexture == null || m_HistoryTexture.width != source.width || m_HistoryTexture.height != source.height)
				{
					if ((bool)m_HistoryTexture)
					{
						RenderTexture.ReleaseTemporary(m_HistoryTexture);
					}
					m_HistoryTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
					m_HistoryTexture.name = "TAA History";
					Graphics.Blit(source, m_HistoryTexture, material, 2);
				}
				material.SetVector(Uniforms._SharpenParameters, new Vector4(taaSettings.sharpen, 0f, 0f, 0f));
				material.SetVector(Uniforms._FinalBlendParameters, new Vector4(taaSettings.stationaryBlending, taaSettings.motionBlending, 6000f, 0f));
				material.SetTexture(Uniforms._MainTex, source);
				material.SetTexture(Uniforms._HistoryTex, m_HistoryTexture);
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				temporary.name = "TAA History";
				m_MRT[0] = destination.colorBuffer;
				m_MRT[1] = temporary.colorBuffer;
				Graphics.SetRenderTarget(m_MRT, source.depthBuffer);
				GraphicsUtils.Blit(material, context.camera.orthographic ? 1 : 0);
				RenderTexture.ReleaseTemporary(m_HistoryTexture);
				m_HistoryTexture = temporary;
				m_ResetHistory = false;
			}

			private float GetHaltonValue(int index, int radix)
			{
				float num = 0f;
				float num2 = 1f / (float)radix;
				while (index > 0)
				{
					num += (float)(index % radix) * num2;
					index /= radix;
					num2 /= (float)radix;
				}
				return num;
			}

			private Vector2 GenerateRandomOffset()
			{
				Vector2 result = new Vector2(GetHaltonValue(m_SampleIndex & 0x3FF, 2), GetHaltonValue(m_SampleIndex & 0x3FF, 3));
				if (++m_SampleIndex >= 8)
				{
					m_SampleIndex = 0;
				}
				return result;
			}

			private Matrix4x4 GetPerspectiveProjectionMatrix(Vector2 offset)
			{
				float num = Mathf.Tan((float)Math.PI / 360f * context.camera.fieldOfView);
				float num2 = num * context.camera.aspect;
				offset.x *= num2 / (0.5f * (float)context.width);
				offset.y *= num / (0.5f * (float)context.height);
				float num3 = (offset.x - num2) * context.camera.nearClipPlane;
				float num4 = (offset.x + num2) * context.camera.nearClipPlane;
				float num5 = (offset.y + num) * context.camera.nearClipPlane;
				float num6 = (offset.y - num) * context.camera.nearClipPlane;
				Matrix4x4 result = default(Matrix4x4);
				result[0, 0] = 2f * context.camera.nearClipPlane / (num4 - num3);
				result[0, 1] = 0f;
				result[0, 2] = (num4 + num3) / (num4 - num3);
				result[0, 3] = 0f;
				result[1, 0] = 0f;
				result[1, 1] = 2f * context.camera.nearClipPlane / (num5 - num6);
				result[1, 2] = (num5 + num6) / (num5 - num6);
				result[1, 3] = 0f;
				result[2, 0] = 0f;
				result[2, 1] = 0f;
				result[2, 2] = (0f - (context.camera.farClipPlane + context.camera.nearClipPlane)) / (context.camera.farClipPlane - context.camera.nearClipPlane);
				result[2, 3] = (0f - 2f * context.camera.farClipPlane * context.camera.nearClipPlane) / (context.camera.farClipPlane - context.camera.nearClipPlane);
				result[3, 0] = 0f;
				result[3, 1] = 0f;
				result[3, 2] = -1f;
				result[3, 3] = 0f;
				return result;
			}

			private Matrix4x4 GetOrthographicProjectionMatrix(Vector2 offset)
			{
				float orthographicSize = context.camera.orthographicSize;
				float num = orthographicSize * context.camera.aspect;
				offset.x *= num / (0.5f * (float)context.width);
				offset.y *= orthographicSize / (0.5f * (float)context.height);
				float left = offset.x - num;
				float right = offset.x + num;
				float top = offset.y + orthographicSize;
				float bottom = offset.y - orthographicSize;
				return Matrix4x4.Ortho(left, right, bottom, top, context.camera.nearClipPlane, context.camera.farClipPlane);
			}

			public override void OnDisable()
			{
				if (m_HistoryTexture != null)
				{
					RenderTexture.ReleaseTemporary(m_HistoryTexture);
				}
				m_HistoryTexture = null;
				m_SampleIndex = 0;
				ResetHistory();
			}
		}
		public sealed class UserLutComponent : PostProcessingComponentRenderTexture<UserLutModel>
		{
			private static class Uniforms
			{
				internal static readonly int _UserLut = Shader.PropertyToID("_UserLut");

				internal static readonly int _UserLut_Params = Shader.PropertyToID("_UserLut_Params");
			}

			public override bool active
			{
				get
				{
					UserLutModel.Settings settings = base.model.settings;
					if (base.model.enabled && settings.lut != null && settings.contribution > 0f && settings.lut.height == (int)Mathf.Sqrt(settings.lut.width))
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void Prepare(Material uberMaterial)
			{
				UserLutModel.Settings settings = base.model.settings;
				uberMaterial.EnableKeyword("USER_LUT");
				uberMaterial.SetTexture(Uniforms._UserLut, settings.lut);
				uberMaterial.SetVector(Uniforms._UserLut_Params, new Vector4(1f / (float)settings.lut.width, 1f / (float)settings.lut.height, (float)settings.lut.height - 1f, settings.contribution));
			}

			public void OnGUI()
			{
				UserLutModel.Settings settings = base.model.settings;
				GUI.DrawTexture(new Rect(context.viewport.x * (float)Screen.width + 8f, 8f, settings.lut.width, settings.lut.height), settings.lut);
			}
		}
		public sealed class VignetteComponent : PostProcessingComponentRenderTexture<VignetteModel>
		{
			private static class Uniforms
			{
				internal static readonly int _Vignette_Color = Shader.PropertyToID("_Vignette_Color");

				internal static readonly int _Vignette_Center = Shader.PropertyToID("_Vignette_Center");

				internal static readonly int _Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

				internal static readonly int _Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

				internal static readonly int _Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");
			}

			public override bool active
			{
				get
				{
					if (base.model.enabled)
					{
						return !context.interrupted;
					}
					return false;
				}
			}

			public override void Prepare(Material uberMaterial)
			{
				VignetteModel.Settings settings = base.model.settings;
				uberMaterial.SetColor(Uniforms._Vignette_Color, settings.color);
				if (settings.mode == VignetteModel.Mode.Classic)
				{
					uberMaterial.SetVector(Uniforms._Vignette_Center, settings.center);
					uberMaterial.EnableKeyword("VIGNETTE_CLASSIC");
					float z = (1f - settings.roundness) * 6f + settings.roundness;
					uberMaterial.SetVector(Uniforms._Vignette_Settings, new Vector4(settings.intensity * 3f, settings.smoothness * 5f, z, settings.rounded ? 1f : 0f));
				}
				else if (settings.mode == VignetteModel.Mode.Masked && settings.mask != null && settings.opacity > 0f)
				{
					uberMaterial.EnableKeyword("VIGNETTE_MASKED");
					uberMaterial.SetTexture(Uniforms._Vignette_Mask, settings.mask);
					uberMaterial.SetFloat(Uniforms._Vignette_Opacity, settings.opacity);
				}
			}
		}
		[Serializable]
		public class AmbientOcclusionModel : PostProcessingModel
		{
			public enum SampleCount
			{
				Lowest = 3,
				Low = 6,
				Medium = 10,
				High = 16
			}

			[Serializable]
			public struct Settings
			{
				[Range(0f, 4f)]
				[Tooltip("Degree of darkness produced by the effect.")]
				public float intensity;

				[Min(0.0001f)]
				[Tooltip("Radius of sample points, which affects extent of darkened areas.")]
				public float radius;

				[Tooltip("Number of sample points, which affects quality and performance.")]
				public SampleCount sampleCount;

				[Tooltip("Halves the resolution of the effect to increase performance at the cost of visual quality.")]
				public bool downsampling;

				[Tooltip("Forces compatibility with Forward rendered objects when working with the Deferred rendering path.")]
				public bool forceForwardCompatibility;

				[Tooltip("Enables the ambient-only mode in that the effect only affects ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering.")]
				public bool ambientOnly;

				[Tooltip("Toggles the use of a higher precision depth texture with the forward rendering path (may impact performances). Has no effect with the deferred rendering path.")]
				public bool highPrecision;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.intensity = 1f;
						result.radius = 0.3f;
						result.sampleCount = SampleCount.Medium;
						result.downsampling = true;
						result.forceForwardCompatibility = false;
						result.ambientOnly = false;
						result.highPrecision = false;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class AntialiasingModel : PostProcessingModel
		{
			public enum Method
			{
				Fxaa,
				Taa
			}

			public enum FxaaPreset
			{
				ExtremePerformance,
				Performance,
				Default,
				Quality,
				ExtremeQuality
			}

			[Serializable]
			public struct FxaaQualitySettings
			{
				[Tooltip("The amount of desired sub-pixel aliasing removal. Effects the sharpeness of the output.")]
				[Range(0f, 1f)]
				public float subpixelAliasingRemovalAmount;

				[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
				[Range(0.063f, 0.333f)]
				public float edgeDetectionThreshold;

				[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
				[Range(0f, 0.0833f)]
				public float minimumRequiredLuminance;

				public static FxaaQualitySettings[] presets = new FxaaQualitySettings[5]
				{
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 0f,
						edgeDetectionThreshold = 0.333f,
						minimumRequiredLuminance = 0.0833f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 0.25f,
						edgeDetectionThreshold = 0.25f,
						minimumRequiredLuminance = 0.0833f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 0.75f,
						edgeDetectionThreshold = 0.166f,
						minimumRequiredLuminance = 0.0833f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 1f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.0625f
					},
					new FxaaQualitySettings
					{
						subpixelAliasingRemovalAmount = 1f,
						edgeDetectionThreshold = 0.063f,
						minimumRequiredLuminance = 0.0312f
					}
				};
			}

			[Serializable]
			public struct FxaaConsoleSettings
			{
				[Tooltip("The amount of spread applied to the sampling coordinates while sampling for subpixel information.")]
				[Range(0.33f, 0.5f)]
				public float subpixelSpreadAmount;

				[Tooltip("This value dictates how sharp the edges in the image are kept; a higher value implies sharper edges.")]
				[Range(2f, 8f)]
				public float edgeSharpnessAmount;

				[Tooltip("The minimum amount of local contrast required to qualify a region as containing an edge.")]
				[Range(0.125f, 0.25f)]
				public float edgeDetectionThreshold;

				[Tooltip("Local contrast adaptation value to disallow the algorithm from executing on the darker regions.")]
				[Range(0.04f, 0.06f)]
				public float minimumRequiredLuminance;

				public static FxaaConsoleSettings[] presets = new FxaaConsoleSettings[5]
				{
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.33f,
						edgeSharpnessAmount = 8f,
						edgeDetectionThreshold = 0.25f,
						minimumRequiredLuminance = 0.06f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.33f,
						edgeSharpnessAmount = 8f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.06f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.5f,
						edgeSharpnessAmount = 8f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.05f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.5f,
						edgeSharpnessAmount = 4f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.04f
					},
					new FxaaConsoleSettings
					{
						subpixelSpreadAmount = 0.5f,
						edgeSharpnessAmount = 2f,
						edgeDetectionThreshold = 0.125f,
						minimumRequiredLuminance = 0.04f
					}
				};
			}

			[Serializable]
			public struct FxaaSettings
			{
				public FxaaPreset preset;

				public static FxaaSettings defaultSettings
				{
					get
					{
						FxaaSettings result = default(FxaaSettings);
						result.preset = FxaaPreset.Default;
						return result;
					}
				}
			}

			[Serializable]
			public struct TaaSettings
			{
				[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable but blurrier output.")]
				[Range(0.1f, 1f)]
				public float jitterSpread;

				[Tooltip("Controls the amount of sharpening applied to the color buffer.")]
				[Range(0f, 3f)]
				public float sharpen;

				[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
				[Range(0f, 0.99f)]
				public float stationaryBlending;

				[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
				[Range(0f, 0.99f)]
				public float motionBlending;

				public static TaaSettings defaultSettings
				{
					get
					{
						TaaSettings result = default(TaaSettings);
						result.jitterSpread = 0.75f;
						result.sharpen = 0.3f;
						result.stationaryBlending = 0.95f;
						result.motionBlending = 0.85f;
						return result;
					}
				}
			}

			[Serializable]
			public struct Settings
			{
				public Method method;

				public FxaaSettings fxaaSettings;

				public TaaSettings taaSettings;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.method = Method.Fxaa;
						result.fxaaSettings = FxaaSettings.defaultSettings;
						result.taaSettings = TaaSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class BloomModel : PostProcessingModel
		{
			[Serializable]
			public struct BloomSettings
			{
				[Min(0f)]
				[Tooltip("Strength of the bloom filter.")]
				public float intensity;

				[Min(0f)]
				[Tooltip("Filters out pixels under this level of brightness.")]
				public float threshold;

				[Range(0f, 1f)]
				[Tooltip("Makes transition between under/over-threshold gradual (0 = hard threshold, 1 = soft threshold).")]
				public float softKnee;

				[Range(1f, 7f)]
				[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
				public float radius;

				[Tooltip("Reduces flashing noise with an additional filter.")]
				public bool antiFlicker;

				public float thresholdLinear
				{
					get
					{
						return Mathf.GammaToLinearSpace(threshold);
					}
					set
					{
						threshold = Mathf.LinearToGammaSpace(value);
					}
				}

				public static BloomSettings defaultSettings
				{
					get
					{
						BloomSettings result = default(BloomSettings);
						result.intensity = 0.5f;
						result.threshold = 1.1f;
						result.softKnee = 0.5f;
						result.radius = 4f;
						result.antiFlicker = false;
						return result;
					}
				}
			}

			[Serializable]
			public struct LensDirtSettings
			{
				[Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
				public Texture texture;

				[Min(0f)]
				[Tooltip("Amount of lens dirtiness.")]
				public float intensity;

				public static LensDirtSettings defaultSettings
				{
					get
					{
						LensDirtSettings result = default(LensDirtSettings);
						result.texture = null;
						result.intensity = 3f;
						return result;
					}
				}
			}

			[Serializable]
			public struct Settings
			{
				public BloomSettings bloom;

				public LensDirtSettings lensDirt;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.bloom = BloomSettings.defaultSettings;
						result.lensDirt = LensDirtSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class BuiltinDebugViewsModel : PostProcessingModel
		{
			[Serializable]
			public struct DepthSettings
			{
				[Range(0f, 1f)]
				[Tooltip("Scales the camera far plane before displaying the depth map.")]
				public float scale;

				public static DepthSettings defaultSettings
				{
					get
					{
						DepthSettings result = default(DepthSettings);
						result.scale = 1f;
						return result;
					}
				}
			}

			[Serializable]
			public struct MotionVectorsSettings
			{
				[Range(0f, 1f)]
				[Tooltip("Opacity of the source render.")]
				public float sourceOpacity;

				[Range(0f, 1f)]
				[Tooltip("Opacity of the per-pixel motion vector colors.")]
				public float motionImageOpacity;

				[Min(0f)]
				[Tooltip("Because motion vectors are mainly very small vectors, you can use this setting to make them more visible.")]
				public float motionImageAmplitude;

				[Range(0f, 1f)]
				[Tooltip("Opacity for the motion vector arrows.")]
				public float motionVectorsOpacity;

				[Range(8f, 64f)]
				[Tooltip("The arrow density on screen.")]
				public int motionVectorsResolution;

				[Min(0f)]
				[Tooltip("Tweaks the arrows length.")]
				public float motionVectorsAmplitude;

				public static MotionVectorsSettings defaultSettings
				{
					get
					{
						MotionVectorsSettings result = default(MotionVectorsSettings);
						result.sourceOpacity = 1f;
						result.motionImageOpacity = 0f;
						result.motionImageAmplitude = 16f;
						result.motionVectorsOpacity = 1f;
						result.motionVectorsResolution = 24;
						result.motionVectorsAmplitude = 64f;
						return result;
					}
				}
			}

			public enum Mode
			{
				None,
				Depth,
				Normals,
				MotionVectors,
				AmbientOcclusion,
				EyeAdaptation,
				FocusPlane,
				PreGradingLog,
				LogLut,
				UserLut
			}

			[Serializable]
			public struct Settings
			{
				public Mode mode;

				public DepthSettings depth;

				public MotionVectorsSettings motionVectors;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.mode = Mode.None;
						result.depth = DepthSettings.defaultSettings;
						result.motionVectors = MotionVectorsSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public bool willInterrupt
			{
				get
				{
					if (!IsModeActive(Mode.None) && !IsModeActive(Mode.EyeAdaptation) && !IsModeActive(Mode.PreGradingLog) && !IsModeActive(Mode.LogLut))
					{
						return !IsModeActive(Mode.UserLut);
					}
					return false;
				}
			}

			public override void Reset()
			{
				settings = Settings.defaultSettings;
			}

			public bool IsModeActive(Mode mode)
			{
				return m_Settings.mode == mode;
			}
		}
		[Serializable]
		public class ChromaticAberrationModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Shift the hue of chromatic aberrations.")]
				public Texture2D spectralTexture;

				[Range(0f, 1f)]
				[Tooltip("Amount of tangential distortion.")]
				public float intensity;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.spectralTexture = null;
						result.intensity = 0.1f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class ColorGradingModel : PostProcessingModel
		{
			public enum Tonemapper
			{
				None,
				ACES,
				Neutral
			}

			[Serializable]
			public struct TonemappingSettings
			{
				[Tooltip("Tonemapping algorithm to use at the end of the color grading process. Use \"Neutral\" if you need a customizable tonemapper or \"Filmic\" to give a standard filmic look to your scenes.")]
				public Tonemapper tonemapper;

				[Range(-0.1f, 0.1f)]
				public float neutralBlackIn;

				[Range(1f, 20f)]
				public float neutralWhiteIn;

				[Range(-0.09f, 0.1f)]
				public float neutralBlackOut;

				[Range(1f, 19f)]
				public float neutralWhiteOut;

				[Range(0.1f, 20f)]
				public float neutralWhiteLevel;

				[Range(1f, 10f)]
				public float neutralWhiteClip;

				public static TonemappingSettings defaultSettings
				{
					get
					{
						TonemappingSettings result = default(TonemappingSettings);
						result.tonemapper = Tonemapper.Neutral;
						result.neutralBlackIn = 0.02f;
						result.neutralWhiteIn = 10f;
						result.neutralBlackOut = 0f;
						result.neutralWhiteOut = 10f;
						result.neutralWhiteLevel = 5.3f;
						result.neutralWhiteClip = 10f;
						return result;
					}
				}
			}

			[Serializable]
			public struct BasicSettings
			{
				[Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
				public float postExposure;

				[Range(-100f, 100f)]
				[Tooltip("Sets the white balance to a custom color temperature.")]
				public float temperature;

				[Range(-100f, 100f)]
				[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
				public float tint;

				[Range(-180f, 180f)]
				[Tooltip("Shift the hue of all colors.")]
				public float hueShift;

				[Range(0f, 2f)]
				[Tooltip("Pushes the intensity of all colors.")]
				public float saturation;

				[Range(0f, 2f)]
				[Tooltip("Expands or shrinks the overall range of tonal values.")]
				public float contrast;

				public static BasicSettings defaultSettings
				{
					get
					{
						BasicSettings result = default(BasicSettings);
						result.postExposure = 0f;
						result.temperature = 0f;
						result.tint = 0f;
						result.hueShift = 0f;
						result.saturation = 1f;
						result.contrast = 1f;
						return result;
					}
				}
			}

			[Serializable]
			public struct ChannelMixerSettings
			{
				public Vector3 red;

				public Vector3 green;

				public Vector3 blue;

				[HideInInspector]
				public int currentEditingChannel;

				public static ChannelMixerSettings defaultSettings
				{
					get
					{
						ChannelMixerSettings result = default(ChannelMixerSettings);
						result.red = new Vector3(1f, 0f, 0f);
						result.green = new Vector3(0f, 1f, 0f);
						result.blue = new Vector3(0f, 0f, 1f);
						result.currentEditingChannel = 0;
						return result;
					}
				}
			}

			[Serializable]
			public struct LogWheelsSettings
			{
				[Trackball("GetSlopeValue")]
				public Color slope;

				[Trackball("GetPowerValue")]
				public Color power;

				[Trackball("GetOffsetValue")]
				public Color offset;

				public static LogWheelsSettings defaultSettings
				{
					get
					{
						LogWheelsSettings result = default(LogWheelsSettings);
						result.slope = Color.clear;
						result.power = Color.clear;
						result.offset = Color.clear;
						return result;
					}
				}
			}

			[Serializable]
			public struct LinearWheelsSettings
			{
				[Trackball("GetLiftValue")]
				public Color lift;

				[Trackball("GetGammaValue")]
				public Color gamma;

				[Trackball("GetGainValue")]
				public Color gain;

				public static LinearWheelsSettings defaultSettings
				{
					get
					{
						LinearWheelsSettings result = default(LinearWheelsSettings);
						result.lift = Color.clear;
						result.gamma = Color.clear;
						result.gain = Color.clear;
						return result;
					}
				}
			}

			public enum ColorWheelMode
			{
				Linear,
				Log
			}

			[Serializable]
			public struct ColorWheelsSettings
			{
				public ColorWheelMode mode;

				[TrackballGroup]
				public LogWheelsSettings log;

				[TrackballGroup]
				public LinearWheelsSettings linear;

				public static ColorWheelsSettings defaultSettings
				{
					get
					{
						ColorWheelsSettings result = default(ColorWheelsSettings);
						result.mode = ColorWheelMode.Log;
						result.log = LogWheelsSettings.defaultSettings;
						result.linear = LinearWheelsSettings.defaultSettings;
						return result;
					}
				}
			}

			[Serializable]
			public struct CurvesSettings
			{
				public ColorGradingCurve master;

				public ColorGradingCurve red;

				public ColorGradingCurve green;

				public ColorGradingCurve blue;

				public ColorGradingCurve hueVShue;

				public ColorGradingCurve hueVSsat;

				public ColorGradingCurve satVSsat;

				public ColorGradingCurve lumVSsat;

				[HideInInspector]
				public int e_CurrentEditingCurve;

				[HideInInspector]
				public bool e_CurveY;

				[HideInInspector]
				public bool e_CurveR;

				[HideInInspector]
				public bool e_CurveG;

				[HideInInspector]
				public bool e_CurveB;

				public static CurvesSettings defaultSettings
				{
					get
					{
						CurvesSettings result = default(CurvesSettings);
						result.master = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.red = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.green = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.blue = new ColorGradingCurve(new AnimationCurve(new Keyframe(0f, 0f, 1f, 1f), new Keyframe(1f, 1f, 1f, 1f)), 0f, loop: false, new Vector2(0f, 1f));
						result.hueVShue = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
						result.hueVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f));
						result.satVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
						result.lumVSsat = new ColorGradingCurve(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f));
						result.e_CurrentEditingCurve = 0;
						result.e_CurveY = true;
						result.e_CurveR = false;
						result.e_CurveG = false;
						result.e_CurveB = false;
						return result;
					}
				}
			}

			[Serializable]
			public struct Settings
			{
				public TonemappingSettings tonemapping;

				public BasicSettings basic;

				public ChannelMixerSettings channelMixer;

				public ColorWheelsSettings colorWheels;

				public CurvesSettings curves;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.tonemapping = TonemappingSettings.defaultSettings;
						result.basic = BasicSettings.defaultSettings;
						result.channelMixer = ChannelMixerSettings.defaultSettings;
						result.colorWheels = ColorWheelsSettings.defaultSettings;
						result.curves = CurvesSettings.defaultSettings;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
					OnValidate();
				}
			}

			public bool isDirty { get; internal set; }

			public RenderTexture bakedLut { get; internal set; }

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
				OnValidate();
			}

			public override void OnValidate()
			{
				isDirty = true;
			}
		}
		[Serializable]
		public class DepthOfFieldModel : PostProcessingModel
		{
			public enum KernelSize
			{
				Small,
				Medium,
				Large,
				VeryLarge
			}

			[Serializable]
			public struct Settings
			{
				[Min(0.1f)]
				[Tooltip("Distance to the point of focus.")]
				public float focusDistance;

				[Range(0.05f, 32f)]
				[Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
				public float aperture;

				[Range(1f, 300f)]
				[Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
				public float focalLength;

				[Tooltip("Calculate the focal length automatically from the field-of-view value set on the camera. Using this setting isn't recommended.")]
				public bool useCameraFov;

				[Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects the performance (the larger the kernel is, the longer the GPU time is required).")]
				public KernelSize kernelSize;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.focusDistance = 10f;
						result.aperture = 5.6f;
						result.focalLength = 50f;
						result.useCameraFov = false;
						result.kernelSize = KernelSize.Medium;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class DitheringModel : PostProcessingModel
		{
			[Serializable]
			[StructLayout(LayoutKind.Sequential, Size = 1)]
			public struct Settings
			{
				public static Settings defaultSettings => default(Settings);
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class EyeAdaptationModel : PostProcessingModel
		{
			public enum EyeAdaptationType
			{
				Progressive,
				Fixed
			}

			[Serializable]
			public struct Settings
			{
				[Range(1f, 99f)]
				[Tooltip("Filters the dark part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
				public float lowPercent;

				[Range(1f, 99f)]
				[Tooltip("Filters the bright part of the histogram when computing the average luminance to avoid very dark pixels from contributing to the auto exposure. Unit is in percent.")]
				public float highPercent;

				[Tooltip("Minimum average luminance to consider for auto exposure (in EV).")]
				public float minLuminance;

				[Tooltip("Maximum average luminance to consider for auto exposure (in EV).")]
				public float maxLuminance;

				[Min(0f)]
				[Tooltip("Exposure bias. Use this to offset the global exposure of the scene.")]
				public float keyValue;

				[Tooltip("Set this to true to let Unity handle the key value automatically based on average luminance.")]
				public bool dynamicKeyValue;

				[Tooltip("Use \"Progressive\" if you want the auto exposure to be animated. Use \"Fixed\" otherwise.")]
				public EyeAdaptationType adaptationType;

				[Min(0f)]
				[Tooltip("Adaptation speed from a dark to a light environment.")]
				public float speedUp;

				[Min(0f)]
				[Tooltip("Adaptation speed from a light to a dark environment.")]
				public float speedDown;

				[Range(-16f, -1f)]
				[Tooltip("Lower bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
				public int logMin;

				[Range(1f, 16f)]
				[Tooltip("Upper bound for the brightness range of the generated histogram (in EV). The bigger the spread between min & max, the lower the precision will be.")]
				public int logMax;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.lowPercent = 45f;
						result.highPercent = 95f;
						result.minLuminance = -5f;
						result.maxLuminance = 1f;
						result.keyValue = 0.25f;
						result.dynamicKeyValue = true;
						result.adaptationType = EyeAdaptationType.Progressive;
						result.speedUp = 2f;
						result.speedDown = 1f;
						result.logMin = -8;
						result.logMax = 4;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class FogModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Should the fog affect the skybox?")]
				public bool excludeSkybox;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.excludeSkybox = true;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class GrainModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Enable the use of colored grain.")]
				public bool colored;

				[Range(0f, 1f)]
				[Tooltip("Grain strength. Higher means more visible grain.")]
				public float intensity;

				[Range(0.3f, 3f)]
				[Tooltip("Grain particle size.")]
				public float size;

				[Range(0f, 1f)]
				[Tooltip("Controls the noisiness response curve based on scene luminance. Lower values mean less noise in dark areas.")]
				public float luminanceContribution;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.colored = true;
						result.intensity = 0.5f;
						result.size = 1f;
						result.luminanceContribution = 0.8f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class MotionBlurModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Range(0f, 360f)]
				[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
				public float shutterAngle;

				[Range(4f, 32f)]
				[Tooltip("The amount of sample points, which affects quality and performances.")]
				public int sampleCount;

				[Range(0f, 1f)]
				[Tooltip("The strength of multiple frame blending. The opacity of preceding frames are determined from this coefficient and time differences.")]
				public float frameBlending;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.shutterAngle = 270f;
						result.sampleCount = 10;
						result.frameBlending = 0f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class ScreenSpaceReflectionModel : PostProcessingModel
		{
			public enum SSRResolution
			{
				High = 0,
				Low = 2
			}

			public enum SSRReflectionBlendType
			{
				PhysicallyBased,
				Additive
			}

			[Serializable]
			public struct IntensitySettings
			{
				[Tooltip("Nonphysical multiplier for the SSR reflections. 1.0 is physically based.")]
				[Range(0f, 2f)]
				public float reflectionMultiplier;

				[Tooltip("How far away from the maxDistance to begin fading SSR.")]
				[Range(0f, 1000f)]
				public float fadeDistance;

				[Tooltip("Amplify Fresnel fade out. Increase if floor reflections look good close to the surface and bad farther 'under' the floor.")]
				[Range(0f, 1f)]
				public float fresnelFade;

				[Tooltip("Higher values correspond to a faster Fresnel fade as the reflection changes from the grazing angle.")]
				[Range(0.1f, 10f)]
				public float fresnelFadePower;
			}

			[Serializable]
			public struct ReflectionSettings
			{
				[Tooltip("How the reflections are blended into the render.")]
				public SSRReflectionBlendType blendType;

				[Tooltip("Half resolution SSRR is much faster, but less accurate.")]
				public SSRResolution reflectionQuality;

				[Tooltip("Maximum reflection distance in world units.")]
				[Range(0.1f, 300f)]
				public float maxDistance;

				[Tooltip("Max raytracing length.")]
				[Range(16f, 1024f)]
				public int iterationCount;

				[Tooltip("Log base 2 of ray tracing coarse step size. Higher traces farther, lower gives better quality silhouettes.")]
				[Range(1f, 16f)]
				public int stepSize;

				[Tooltip("Typical thickness of columns, walls, furniture, and other objects that reflection rays might pass behind.")]
				[Range(0.01f, 10f)]
				public float widthModifier;

				[Tooltip("Blurriness of reflections.")]
				[Range(0.1f, 8f)]
				public float reflectionBlur;

				[Tooltip("Disable for a performance gain in scenes where most glossy objects are horizontal, like floors, water, and tables. Leave on for scenes with glossy vertical objects.")]
				public bool reflectBackfaces;
			}

			[Serializable]
			public struct ScreenEdgeMask
			{
				[Tooltip("Higher = fade out SSRR near the edge of the screen so that reflections don't pop under camera motion.")]
				[Range(0f, 1f)]
				public float intensity;
			}

			[Serializable]
			public struct Settings
			{
				public ReflectionSettings reflection;

				public IntensitySettings intensity;

				public ScreenEdgeMask screenEdgeMask;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.reflection = new ReflectionSettings
						{
							blendType = SSRReflectionBlendType.PhysicallyBased,
							reflectionQuality = SSRResolution.Low,
							maxDistance = 100f,
							iterationCount = 256,
							stepSize = 3,
							widthModifier = 0.5f,
							reflectionBlur = 1f,
							reflectBackfaces = false
						};
						result.intensity = new IntensitySettings
						{
							reflectionMultiplier = 1f,
							fadeDistance = 100f,
							fresnelFade = 1f,
							fresnelFadePower = 1f
						};
						result.screenEdgeMask = new ScreenEdgeMask
						{
							intensity = 0.03f
						};
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class UserLutModel : PostProcessingModel
		{
			[Serializable]
			public struct Settings
			{
				[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
				public Texture2D lut;

				[Range(0f, 1f)]
				[Tooltip("Blending factor.")]
				public float contribution;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.lut = null;
						result.contribution = 1f;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[Serializable]
		public class VignetteModel : PostProcessingModel
		{
			public enum Mode
			{
				Classic,
				Masked
			}

			[Serializable]
			public struct Settings
			{
				[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
				public Mode mode;

				[ColorUsage(false)]
				[Tooltip("Vignette color. Use the alpha channel for transparency.")]
				public Color color;

				[Tooltip("Sets the vignette center point (screen center is [0.5,0.5]).")]
				public Vector2 center;

				[Range(0f, 1f)]
				[Tooltip("Amount of vignetting on screen.")]
				public float intensity;

				[Range(0.01f, 1f)]
				[Tooltip("Smoothness of the vignette borders.")]
				public float smoothness;

				[Range(0f, 1f)]
				[Tooltip("Lower values will make a square-ish vignette.")]
				public float roundness;

				[Tooltip("A black and white mask to use as a vignette.")]
				public Texture mask;

				[Range(0f, 1f)]
				[Tooltip("Mask opacity.")]
				public float opacity;

				[Tooltip("Should the vignette be perfectly round or be dependent on the current aspect ratio?")]
				public bool rounded;

				public static Settings defaultSettings
				{
					get
					{
						Settings result = default(Settings);
						result.mode = Mode.Classic;
						result.color = new Color(0f, 0f, 0f, 1f);
						result.center = new Vector2(0.5f, 0.5f);
						result.intensity = 0.45f;
						result.smoothness = 0.2f;
						result.roundness = 1f;
						result.mask = null;
						result.opacity = 1f;
						result.rounded = false;
						return result;
					}
				}
			}

			[SerializeField]
			private Settings m_Settings = Settings.defaultSettings;

			public Settings settings
			{
				get
				{
					return m_Settings;
				}
				set
				{
					m_Settings = value;
				}
			}

			public override void Reset()
			{
				m_Settings = Settings.defaultSettings;
			}
		}
		[ImageEffectAllowedInSceneView]
		[RequireComponent(typeof(Camera))]
		[DisallowMultipleComponent]
		[ExecuteInEditMode]
		[AddComponentMenu("Effects/Post-Processing Behaviour", -1)]
		public class PostProcessingBehaviour : MonoBehaviour
		{
			public PostProcessingProfile profile;

			public Func<Vector2, Matrix4x4> jitteredMatrixFunc;

			private Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>> m_CommandBuffers;

			private List<PostProcessingComponentBase> m_Components;

			private Dictionary<PostProcessingComponentBase, bool> m_ComponentStates;

			private MaterialFactory m_MaterialFactory;

			private RenderTextureFactory m_RenderTextureFactory;

			private PostProcessingContext m_Context;

			private Camera m_Camera;

			private PostProcessingProfile m_PreviousProfile;

			private bool m_RenderingInSceneView;

			private BuiltinDebugViewsComponent m_DebugViews;

			private AmbientOcclusionComponent m_AmbientOcclusion;

			private ScreenSpaceReflectionComponent m_ScreenSpaceReflection;

			private FogComponent m_FogComponent;

			private MotionBlurComponent m_MotionBlur;

			private TaaComponent m_Taa;

			private EyeAdaptationComponent m_EyeAdaptation;

			private DepthOfFieldComponent m_DepthOfField;

			private BloomComponent m_Bloom;

			private ChromaticAberrationComponent m_ChromaticAberration;

			private ColorGradingComponent m_ColorGrading;

			private UserLutComponent m_UserLut;

			private GrainComponent m_Grain;

			private VignetteComponent m_Vignette;

			private DitheringComponent m_Dithering;

			private FxaaComponent m_Fxaa;

			private List<PostProcessingComponentBase> m_ComponentsToEnable = new List<PostProcessingComponentBase>();

			private List<PostProcessingComponentBase> m_ComponentsToDisable = new List<PostProcessingComponentBase>();

			private void OnEnable()
			{
				m_CommandBuffers = new Dictionary<Type, KeyValuePair<CameraEvent, CommandBuffer>>();
				m_MaterialFactory = new MaterialFactory();
				m_RenderTextureFactory = new RenderTextureFactory();
				m_Context = new PostProcessingContext();
				m_Components = new List<PostProcessingComponentBase>();
				m_DebugViews = AddComponent(new BuiltinDebugViewsComponent());
				m_AmbientOcclusion = AddComponent(new AmbientOcclusionComponent());
				m_ScreenSpaceReflection = AddComponent(new ScreenSpaceReflectionComponent());
				m_FogComponent = AddComponent(new FogComponent());
				m_MotionBlur = AddComponent(new MotionBlurComponent());
				m_Taa = AddComponent(new TaaComponent());
				m_EyeAdaptation = AddComponent(new EyeAdaptationComponent());
				m_DepthOfField = AddComponent(new DepthOfFieldComponent());
				m_Bloom = AddComponent(new BloomComponent());
				m_ChromaticAberration = AddComponent(new ChromaticAberrationComponent());
				m_ColorGrading = AddComponent(new ColorGradingComponent());
				m_UserLut = AddComponent(new UserLutComponent());
				m_Grain = AddComponent(new GrainComponent());
				m_Vignette = AddComponent(new VignetteComponent());
				m_Dithering = AddComponent(new DitheringComponent());
				m_Fxaa = AddComponent(new FxaaComponent());
				m_ComponentStates = new Dictionary<PostProcessingComponentBase, bool>();
				foreach (PostProcessingComponentBase component in m_Components)
				{
					m_ComponentStates.Add(component, value: false);
				}
				base.useGUILayout = false;
			}

			private void OnPreCull()
			{
				m_Camera = GetComponent<Camera>();
				if (profile == null || m_Camera == null)
				{
					return;
				}
				PostProcessingContext postProcessingContext = m_Context.Reset();
				postProcessingContext.profile = profile;
				postProcessingContext.renderTextureFactory = m_RenderTextureFactory;
				postProcessingContext.materialFactory = m_MaterialFactory;
				postProcessingContext.camera = m_Camera;
				m_DebugViews.Init(postProcessingContext, profile.debugViews);
				m_AmbientOcclusion.Init(postProcessingContext, profile.ambientOcclusion);
				m_ScreenSpaceReflection.Init(postProcessingContext, profile.screenSpaceReflection);
				m_FogComponent.Init(postProcessingContext, profile.fog);
				m_MotionBlur.Init(postProcessingContext, profile.motionBlur);
				m_Taa.Init(postProcessingContext, profile.antialiasing);
				m_EyeAdaptation.Init(postProcessingContext, profile.eyeAdaptation);
				m_DepthOfField.Init(postProcessingContext, profile.depthOfField);
				m_Bloom.Init(postProcessingContext, profile.bloom);
				m_ChromaticAberration.Init(postProcessingContext, profile.chromaticAberration);
				m_ColorGrading.Init(postProcessingContext, profile.colorGrading);
				m_UserLut.Init(postProcessingContext, profile.userLut);
				m_Grain.Init(postProcessingContext, profile.grain);
				m_Vignette.Init(postProcessingContext, profile.vignette);
				m_Dithering.Init(postProcessingContext, profile.dithering);
				m_Fxaa.Init(postProcessingContext, profile.antialiasing);
				if (m_PreviousProfile != profile)
				{
					DisableComponents();
					m_PreviousProfile = profile;
				}
				CheckObservers();
				DepthTextureMode depthTextureMode = postProcessingContext.camera.depthTextureMode;
				foreach (PostProcessingComponentBase component in m_Components)
				{
					if (component.active)
					{
						depthTextureMode |= component.GetCameraFlags();
					}
				}
				postProcessingContext.camera.depthTextureMode = depthTextureMode;
				if (!m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
				{
					m_Taa.SetProjectionMatrix(jitteredMatrixFunc);
				}
			}

			private void OnPreRender()
			{
				if (!(profile == null))
				{
					TryExecuteCommandBuffer(m_DebugViews);
					TryExecuteCommandBuffer(m_AmbientOcclusion);
					TryExecuteCommandBuffer(m_ScreenSpaceReflection);
					TryExecuteCommandBuffer(m_FogComponent);
					if (!m_RenderingInSceneView)
					{
						TryExecuteCommandBuffer(m_MotionBlur);
					}
				}
			}

			private void OnPostRender()
			{
				if (!(profile == null) && !(m_Camera == null) && !m_RenderingInSceneView && m_Taa.active && !profile.debugViews.willInterrupt)
				{
					m_Context.camera.ResetProjectionMatrix();
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (profile == null || m_Camera == null)
				{
					Graphics.Blit(source, destination);
					return;
				}
				bool flag = false;
				bool active = m_Fxaa.active;
				bool flag2 = m_Taa.active && !m_RenderingInSceneView;
				bool num = m_DepthOfField.active && !m_RenderingInSceneView;
				Material material = m_MaterialFactory.Get("Hidden/Post FX/Uber Shader");
				material.shaderKeywords = null;
				RenderTexture renderTexture = source;
				if (flag2)
				{
					RenderTexture renderTexture2 = m_RenderTextureFactory.Get(renderTexture);
					m_Taa.Render(renderTexture, renderTexture2);
					renderTexture = renderTexture2;
				}
				Texture texture = GraphicsUtils.whiteTexture;
				if (m_EyeAdaptation.active)
				{
					flag = true;
					texture = m_EyeAdaptation.Prepare(renderTexture, material);
				}
				material.SetTexture("_AutoExposure", texture);
				if (num)
				{
					flag = true;
					m_DepthOfField.Prepare(renderTexture, material, flag2, m_Taa.jitterVector, m_Taa.model.settings.taaSettings.motionBlending);
				}
				if (m_Bloom.active)
				{
					flag = true;
					m_Bloom.Prepare(renderTexture, material, texture);
				}
				flag |= TryPrepareUberImageEffect(m_ChromaticAberration, material);
				flag |= TryPrepareUberImageEffect(m_ColorGrading, material);
				flag |= TryPrepareUberImageEffect(m_Vignette, material);
				flag |= TryPrepareUberImageEffect(m_UserLut, material);
				Material material2 = (active ? m_MaterialFactory.Get("Hidden/Post FX/FXAA") : null);
				if (active)
				{
					material2.shaderKeywords = null;
					TryPrepareUberImageEffect(m_Grain, material2);
					TryPrepareUberImageEffect(m_Dithering, material2);
					if (flag)
					{
						RenderTexture renderTexture3 = m_RenderTextureFactory.Get(renderTexture);
						Graphics.Blit(renderTexture, renderTexture3, material, 0);
						renderTexture = renderTexture3;
					}
					m_Fxaa.Render(renderTexture, destination);
				}
				else
				{
					flag |= TryPrepareUberImageEffect(m_Grain, material);
					flag |= TryPrepareUberImageEffect(m_Dithering, material);
					if (flag)
					{
						if (!GraphicsUtils.isLinearColorSpace)
						{
							material.EnableKeyword("UNITY_COLORSPACE_GAMMA");
						}
						Graphics.Blit(renderTexture, destination, material, 0);
					}
				}
				if (!flag && !active)
				{
					Graphics.Blit(renderTexture, destination);
				}
				m_RenderTextureFactory.ReleaseAll();
			}

			private void OnGUI()
			{
				if (Event.current.type == EventType.Repaint && !(profile == null) && !(m_Camera == null))
				{
					if (m_EyeAdaptation.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.EyeAdaptation))
					{
						m_EyeAdaptation.OnGUI();
					}
					else if (m_ColorGrading.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.LogLut))
					{
						m_ColorGrading.OnGUI();
					}
					else if (m_UserLut.active && profile.debugViews.IsModeActive(BuiltinDebugViewsModel.Mode.UserLut))
					{
						m_UserLut.OnGUI();
					}
				}
			}

			private void OnDisable()
			{
				foreach (KeyValuePair<CameraEvent, CommandBuffer> value in m_CommandBuffers.Values)
				{
					m_Camera.RemoveCommandBuffer(value.Key, value.Value);
					value.Value.Dispose();
				}
				m_CommandBuffers.Clear();
				if (profile != null)
				{
					DisableComponents();
				}
				m_Components.Clear();
				m_MaterialFactory.Dispose();
				m_RenderTextureFactory.Dispose();
				GraphicsUtils.Dispose();
			}

			public void ResetTemporalEffects()
			{
				m_Taa.ResetHistory();
				m_MotionBlur.ResetHistory();
				m_EyeAdaptation.ResetHistory();
			}

			private void CheckObservers()
			{
				foreach (KeyValuePair<PostProcessingComponentBase, bool> componentState in m_ComponentStates)
				{
					PostProcessingComponentBase key = componentState.Key;
					bool flag = key.GetModel().enabled;
					if (flag != componentState.Value)
					{
						if (flag)
						{
							m_ComponentsToEnable.Add(key);
						}
						else
						{
							m_ComponentsToDisable.Add(key);
						}
					}
				}
				for (int i = 0; i < m_ComponentsToDisable.Count; i++)
				{
					PostProcessingComponentBase postProcessingComponentBase = m_ComponentsToDisable[i];
					m_ComponentStates[postProcessingComponentBase] = false;
					postProcessingComponentBase.OnDisable();
				}
				for (int j = 0; j < m_ComponentsToEnable.Count; j++)
				{
					PostProcessingComponentBase postProcessingComponentBase2 = m_ComponentsToEnable[j];
					m_ComponentStates[postProcessingComponentBase2] = true;
					postProcessingComponentBase2.OnEnable();
				}
				m_ComponentsToDisable.Clear();
				m_ComponentsToEnable.Clear();
			}

			private void DisableComponents()
			{
				foreach (PostProcessingComponentBase component in m_Components)
				{
					PostProcessingModel model = component.GetModel();
					if (model != null && model.enabled)
					{
						component.OnDisable();
					}
				}
			}

			private CommandBuffer AddCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
			{
				CommandBuffer value = new CommandBuffer
				{
					name = name
				};
				KeyValuePair<CameraEvent, CommandBuffer> value2 = new KeyValuePair<CameraEvent, CommandBuffer>(evt, value);
				m_CommandBuffers.Add(typeof(T), value2);
				m_Camera.AddCommandBuffer(evt, value2.Value);
				return value2.Value;
			}

			private void RemoveCommandBuffer<T>() where T : PostProcessingModel
			{
				Type typeFromHandle = typeof(T);
				if (m_CommandBuffers.TryGetValue(typeFromHandle, out var value))
				{
					m_Camera.RemoveCommandBuffer(value.Key, value.Value);
					m_CommandBuffers.Remove(typeFromHandle);
					value.Value.Dispose();
				}
			}

			private CommandBuffer GetCommandBuffer<T>(CameraEvent evt, string name) where T : PostProcessingModel
			{
				if (!m_CommandBuffers.TryGetValue(typeof(T), out var value))
				{
					return AddCommandBuffer<T>(evt, name);
				}
				if (value.Key != evt)
				{
					RemoveCommandBuffer<T>();
					return AddCommandBuffer<T>(evt, name);
				}
				return value.Value;
			}

			private void TryExecuteCommandBuffer<T>(PostProcessingComponentCommandBuffer<T> component) where T : PostProcessingModel
			{
				if (component.active)
				{
					CommandBuffer commandBuffer = GetCommandBuffer<T>(component.GetCameraEvent(), component.GetName());
					commandBuffer.Clear();
					component.PopulateCommandBuffer(commandBuffer);
				}
				else
				{
					RemoveCommandBuffer<T>();
				}
			}

			private bool TryPrepareUberImageEffect<T>(PostProcessingComponentRenderTexture<T> component, Material material) where T : PostProcessingModel
			{
				if (!component.active)
				{
					return false;
				}
				component.Prepare(material);
				return true;
			}

			private T AddComponent<T>(T component) where T : PostProcessingComponentBase
			{
				m_Components.Add(component);
				return component;
			}
		}
		public abstract class PostProcessingComponentBase
		{
			public PostProcessingContext context;

			public abstract bool active { get; }

			public virtual DepthTextureMode GetCameraFlags()
			{
				return DepthTextureMode.None;
			}

			public virtual void OnEnable()
			{
			}

			public virtual void OnDisable()
			{
			}

			public abstract PostProcessingModel GetModel();
		}
		public abstract class PostProcessingComponent<T> : PostProcessingComponentBase where T : PostProcessingModel
		{
			public T model { get; internal set; }

			public virtual void Init(PostProcessingContext pcontext, T pmodel)
			{
				context = pcontext;
				model = pmodel;
			}

			public override PostProcessingModel GetModel()
			{
				return model;
			}
		}
		public abstract class PostProcessingComponentCommandBuffer<T> : PostProcessingComponent<T> where T : PostProcessingModel
		{
			public abstract CameraEvent GetCameraEvent();

			public abstract string GetName();

			public abstract void PopulateCommandBuffer(CommandBuffer cb);
		}
		public abstract class PostProcessingComponentRenderTexture<T> : PostProcessingComponent<T> where T : PostProcessingModel
		{
			public virtual void Prepare(Material material)
			{
			}
		}
		public class PostProcessingContext
		{
			public PostProcessingProfile profile;

			public Camera camera;

			public MaterialFactory materialFactory;

			public RenderTextureFactory renderTextureFactory;

			public bool interrupted { get; private set; }

			public bool isGBufferAvailable => camera.actualRenderingPath == RenderingPath.DeferredShading;

			public bool isHdr => camera.allowHDR;

			public int width => camera.pixelWidth;

			public int height => camera.pixelHeight;

			public Rect viewport => camera.rect;

			public void Interrupt()
			{
				interrupted = true;
			}

			public PostProcessingContext Reset()
			{
				profile = null;
				camera = null;
				materialFactory = null;
				renderTextureFactory = null;
				interrupted = false;
				return this;
			}
		}
		[Serializable]
		public abstract class PostProcessingModel
		{
			[SerializeField]
			[GetSet("enabled")]
			private bool m_Enabled;

			public bool enabled
			{
				get
				{
					return m_Enabled;
				}
				set
				{
					m_Enabled = value;
					if (value)
					{
						OnValidate();
					}
				}
			}

			public abstract void Reset();

			public virtual void OnValidate()
			{
			}
		}
		public class PostProcessingProfile : ScriptableObject
		{
			public BuiltinDebugViewsModel debugViews = new BuiltinDebugViewsModel();

			public FogModel fog = new FogModel();

			public AntialiasingModel antialiasing = new AntialiasingModel();

			public AmbientOcclusionModel ambientOcclusion = new AmbientOcclusionModel();

			public ScreenSpaceReflectionModel screenSpaceReflection = new ScreenSpaceReflectionModel();

			public DepthOfFieldModel depthOfField = new DepthOfFieldModel();

			public MotionBlurModel motionBlur = new MotionBlurModel();

			public EyeAdaptationModel eyeAdaptation = new EyeAdaptationModel();

			public BloomModel bloom = new BloomModel();

			public ColorGradingModel colorGrading = new ColorGradingModel();

			public UserLutModel userLut = new UserLutModel();

			public ChromaticAberrationModel chromaticAberration = new ChromaticAberrationModel();

			public GrainModel grain = new GrainModel();

			public VignetteModel vignette = new VignetteModel();

			public DitheringModel dithering = new DitheringModel();
		}
		[Serializable]
		public sealed class ColorGradingCurve
		{
			public AnimationCurve curve;

			[SerializeField]
			private bool m_Loop;

			[SerializeField]
			private float m_ZeroValue;

			[SerializeField]
			private float m_Range;

			private AnimationCurve m_InternalLoopingCurve;

			public ColorGradingCurve(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
			{
				this.curve = curve;
				m_ZeroValue = zeroValue;
				m_Loop = loop;
				m_Range = bounds.magnitude;
			}

			public void Cache()
			{
				if (!m_Loop)
				{
					return;
				}
				int length = curve.length;
				if (length >= 2)
				{
					if (m_InternalLoopingCurve == null)
					{
						m_InternalLoopingCurve = new AnimationCurve();
					}
					Keyframe key = curve[length - 1];
					key.time -= m_Range;
					Keyframe key2 = curve[0];
					key2.time += m_Range;
					m_InternalLoopingCurve.keys = curve.keys;
					m_InternalLoopingCurve.AddKey(key);
					m_InternalLoopingCurve.AddKey(key2);
				}
			}

			public float Evaluate(float t)
			{
				if (curve.length == 0)
				{
					return m_ZeroValue;
				}
				if (!m_Loop || curve.length == 1)
				{
					return curve.Evaluate(t);
				}
				return m_InternalLoopingCurve.Evaluate(t);
			}
		}
		public static class GraphicsUtils
		{
			private static Texture2D s_WhiteTexture;

			private static Mesh s_Quad;

			public static bool isLinearColorSpace => QualitySettings.activeColorSpace == ColorSpace.Linear;

			public static bool supportsDX11
			{
				get
				{
					if (SystemInfo.graphicsShaderLevel >= 50)
					{
						return SystemInfo.supportsComputeShaders;
					}
					return false;
				}
			}

			public static Texture2D whiteTexture
			{
				get
				{
					if (s_WhiteTexture != null)
					{
						return s_WhiteTexture;
					}
					s_WhiteTexture = new Texture2D(1, 1, TextureFormat.ARGB32, mipChain: false);
					s_WhiteTexture.SetPixel(0, 0, new Color(1f, 1f, 1f, 1f));
					s_WhiteTexture.Apply();
					return s_WhiteTexture;
				}
			}

			public static Mesh quad
			{
				get
				{
					if (s_Quad != null)
					{
						return s_Quad;
					}
					Vector3[] vertices = new Vector3[4]
					{
						new Vector3(-1f, -1f, 0f),
						new Vector3(1f, 1f, 0f),
						new Vector3(1f, -1f, 0f),
						new Vector3(-1f, 1f, 0f)
					};
					Vector2[] uv = new Vector2[4]
					{
						new Vector2(0f, 0f),
						new Vector2(1f, 1f),
						new Vector2(1f, 0f),
						new Vector2(0f, 1f)
					};
					int[] triangles = new int[6] { 0, 1, 2, 1, 0, 3 };
					s_Quad = new Mesh
					{
						vertices = vertices,
						uv = uv,
						triangles = triangles
					};
					s_Quad.RecalculateNormals();
					s_Quad.RecalculateBounds();
					return s_Quad;
				}
			}

			public static void Blit(Material material, int pass)
			{
				GL.PushMatrix();
				GL.LoadOrtho();
				material.SetPass(pass);
				GL.Begin(5);
				GL.TexCoord2(0f, 0f);
				GL.Vertex3(0f, 0f, 0.1f);
				GL.TexCoord2(1f, 0f);
				GL.Vertex3(1f, 0f, 0.1f);
				GL.TexCoord2(0f, 1f);
				GL.Vertex3(0f, 1f, 0.1f);
				GL.TexCoord2(1f, 1f);
				GL.Vertex3(1f, 1f, 0.1f);
				GL.End();
				GL.PopMatrix();
			}

			public static void ClearAndBlit(Texture source, RenderTexture destination, Material material, int pass, bool clearColor = true, bool clearDepth = false)
			{
				RenderTexture active = RenderTexture.active;
				RenderTexture.active = destination;
				GL.Clear(clearDepth: false, clearColor, Color.clear);
				GL.PushMatrix();
				GL.LoadOrtho();
				material.SetTexture("_MainTex", source);
				material.SetPass(pass);
				GL.Begin(5);
				GL.TexCoord2(0f, 0f);
				GL.Vertex3(0f, 0f, 0.1f);
				GL.TexCoord2(1f, 0f);
				GL.Vertex3(1f, 0f, 0.1f);
				GL.TexCoord2(0f, 1f);
				GL.Vertex3(0f, 1f, 0.1f);
				GL.TexCoord2(1f, 1f);
				GL.Vertex3(1f, 1f, 0.1f);
				GL.End();
				GL.PopMatrix();
				RenderTexture.active = active;
			}

			public static void Destroy(Object obj)
			{
				if (obj != null)
				{
					Object.Destroy(obj);
				}
			}

			public static void Dispose()
			{
				Destroy(s_Quad);
			}
		}
		public sealed class MaterialFactory : IDisposable
		{
			private Dictionary<string, Material> m_Materials;

			public MaterialFactory()
			{
				m_Materials = new Dictionary<string, Material>();
			}

			public Material Get(string shaderName)
			{
				if (!m_Materials.TryGetValue(shaderName, out var value))
				{
					Shader shader = Shader.Find(shaderName);
					if (shader == null)
					{
						throw new ArgumentException($"Shader not found ({shaderName})");
					}
					value = new Material(shader)
					{
						name = string.Format("PostFX - {0}", shaderName.Substring(shaderName.LastIndexOf("/") + 1)),
						hideFlags = HideFlags.DontSave
					};
					m_Materials.Add(shaderName, value);
				}
				return value;
			}

			public void Dispose()
			{
				Dictionary<string, Material>.Enumerator enumerator = m_Materials.GetEnumerator();
				while (enumerator.MoveNext())
				{
					GraphicsUtils.Destroy(enumerator.Current.Value);
				}
				m_Materials.Clear();
			}
		}
		public sealed class RenderTextureFactory : IDisposable
		{
			private HashSet<RenderTexture> m_TemporaryRTs;

			public RenderTextureFactory()
			{
				m_TemporaryRTs = new HashSet<RenderTexture>();
			}

			public RenderTexture Get(RenderTexture baseRenderTexture)
			{
				return Get(baseRenderTexture.width, baseRenderTexture.height, baseRenderTexture.depth, baseRenderTexture.format, (!baseRenderTexture.sRGB) ? RenderTextureReadWrite.Linear : RenderTextureReadWrite.sRGB, baseRenderTexture.filterMode, baseRenderTexture.wrapMode);
			}

			public RenderTexture Get(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, RenderTextureReadWrite rw = RenderTextureReadWrite.Default, FilterMode filterMode = FilterMode.Bilinear, TextureWrapMode wrapMode = TextureWrapMode.Clamp, string name = "FactoryTempTexture")
			{
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format, rw);
				temporary.filterMode = filterMode;
				temporary.wrapMode = wrapMode;
				temporary.name = name;
				m_TemporaryRTs.Add(temporary);
				return temporary;
			}

			public void Release(RenderTexture rt)
			{
				if (!(rt == null))
				{
					if (!m_TemporaryRTs.Contains(rt))
					{
						throw new ArgumentException($"Attempting to remove a RenderTexture that was not allocated: {rt}");
					}
					m_TemporaryRTs.Remove(rt);
					RenderTexture.ReleaseTemporary(rt);
				}
			}

			public void ReleaseAll()
			{
				HashSet<RenderTexture>.Enumerator enumerator = m_TemporaryRTs.GetEnumerator();
				while (enumerator.MoveNext())
				{
					RenderTexture.ReleaseTemporary(enumerator.Current);
				}
				m_TemporaryRTs.Clear();
			}

			public void Dispose()
			{
				ReleaseAll();
			}
		}
	}
	namespace IL3DN
	{
		public class IL3DN_ChangeWalkingSound : MonoBehaviour
		{
			public AudioClip[] footStepsOverride;

			public AudioClip jumpSound;

			public AudioClip landSound;
		}
		[Serializable]
		public class ColorProperty
		{
			public Color color;

			public string name;

			public ColorProperty(Color color, string name)
			{
				this.color = color;
				this.name = name;
			}
		}
		[Serializable]
		public class MaterialColors
		{
			public List<ColorProperty> colors;

			public MaterialColors(Material material)
			{
				colors = new List<ColorProperty>();
			}
		}
		[Serializable]
		public class MultipleColorProperties
		{
			public Material meterial;

			public List<MaterialColors> properties;

			public int selectedProperty;

			public MultipleColorProperties(Material material)
			{
				meterial = material;
				properties = new List<MaterialColors>();
				properties.Add(new MaterialColors(material));
			}
		}
		public class IL3DN_ColorManagerEffects : MonoBehaviour
		{
			public List<MultipleColorProperties> materials = new List<MultipleColorProperties>();
		}
		[Serializable]
		public class ShaderProperties
		{
			public Color color;

			public Texture2D mainTex;

			public ShaderProperties(Color color, Texture2D mainTex)
			{
				this.color = color;
				this.mainTex = mainTex;
			}
		}
		[Serializable]
		public class MaterialProperties
		{
			public Material meterial;

			public List<ShaderProperties> properties;

			public int selectedProperty;

			public MaterialProperties(Material material)
			{
				meterial = material;
				properties = new List<ShaderProperties>();
			}
		}
		public class IL3DN_ColorManagerTextures : MonoBehaviour
		{
			public List<MaterialProperties> materials = new List<MaterialProperties>();
		}
		[ExecuteInEditMode]
		[ImageEffectAllowedInSceneView]
		public class IL3DN_Fog : MonoBehaviour
		{
			public Material material;

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture src, RenderTexture dest)
			{
				Graphics.Blit(src, dest, material);
			}
		}
		public class IL3DN_PlayRandomSound : MonoBehaviour
		{
			public AudioSource audioSource;

			public AudioClip[] sounds;

			public float minDelay;

			public float maxDelay;

			private float currentTime;

			private float playTime;

			private AudioClip currentSound;

			private void Start()
			{
				SetupSound();
			}

			private void SetupSound()
			{
				currentSound = sounds[UnityEngine.Random.Range(0, sounds.Length)];
				playTime = UnityEngine.Random.Range(minDelay, maxDelay);
				currentTime = 0f;
			}

			private void Update()
			{
				currentTime += Time.deltaTime;
				if (currentTime > playTime)
				{
					SetupSound();
					audioSource.PlayOneShot(currentSound);
				}
			}
		}
		[RequireComponent(typeof(CharacterController))]
		[RequireComponent(typeof(AudioSource))]
		public class IL3DN_SimpleFPSController : MonoBehaviour
		{
			[SerializeField]
			private bool m_IsWalking;

			[SerializeField]
			private float m_WalkSpeed = 2f;

			[SerializeField]
			private float m_RunSpeed = 5f;

			[SerializeField]
			[Range(0f, 1f)]
			private float m_RunstepLenghten = 0.7f;

			[SerializeField]
			private float m_JumpSpeed = 5f;

			[SerializeField]
			private float m_StickToGroundForce = 10f;

			[SerializeField]
			private float m_GravityMultiplier = 2f;

			[SerializeField]
			private IL3DN_SimpleMouseLook m_MouseLook;

			[SerializeField]
			private float m_StepInterval = 2f;

			[SerializeField]
			private AudioClip[] m_FootstepSounds;

			[SerializeField]
			private AudioClip m_JumpSound;

			[SerializeField]
			private AudioClip m_LandSound;

			private Camera m_Camera;

			private bool m_Jump;

			private float m_YRotation;

			private Vector2 m_Input;

			private Vector3 m_MoveDir = Vector3.zero;

			private CharacterController m_CharacterController;

			private CollisionFlags m_CollisionFlags;

			private bool m_PreviouslyGrounded;

			private float m_StepCycle;

			private float m_NextStep;

			private bool m_Jumping;

			private AudioSource m_AudioSource;

			private AudioClip[] footStepsOverride;

			private AudioClip jumpSoundOverride;

			private AudioClip landSoundOverride;

			private bool isInSpecialSurface;

			private void Start()
			{
				m_CharacterController = GetComponent<CharacterController>();
				m_Camera = Camera.main;
				m_StepCycle = 0f;
				m_NextStep = m_StepCycle / 2f;
				m_Jumping = false;
				m_AudioSource = GetComponent<AudioSource>();
				m_MouseLook.Init(base.transform, m_Camera.transform);
			}

			private void Update()
			{
				RotateView();
				if (!m_Jump)
				{
					m_Jump = Input.GetButtonDown("Jump");
				}
				if (!m_PreviouslyGrounded && m_CharacterController.isGrounded)
				{
					PlayLandingSound();
					m_MoveDir.y = 0f;
					m_Jumping = false;
				}
				if (!m_CharacterController.isGrounded && !m_Jumping && m_PreviouslyGrounded)
				{
					m_MoveDir.y = 0f;
				}
				m_PreviouslyGrounded = m_CharacterController.isGrounded;
			}

			private void PlayLandingSound()
			{
				if (isInSpecialSurface)
				{
					m_AudioSource.clip = landSoundOverride;
				}
				else
				{
					m_AudioSource.clip = m_LandSound;
				}
				m_AudioSource.Play();
				m_NextStep = m_StepCycle + 0.5f;
			}

			private void FixedUpdate()
			{
				GetInput(out var speed);
				Vector3 vector = base.transform.forward * m_Input.y + base.transform.right * m_Input.x;
				Physics.SphereCast(base.transform.position, m_CharacterController.radius, Vector3.down, out var hitInfo, m_CharacterController.height / 2f, -1, QueryTriggerInteraction.Ignore);
				vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
				m_MoveDir.x = vector.x * speed;
				m_MoveDir.z = vector.z * speed;
				if (m_CharacterController.isGrounded)
				{
					m_MoveDir.y = 0f - m_StickToGroundForce;
					if (m_Jump)
					{
						m_MoveDir.y = m_JumpSpeed;
						PlayJumpSound();
						m_Jump = false;
						m_Jumping = true;
					}
				}
				else
				{
					m_MoveDir += Physics.gravity * m_GravityMultiplier * Time.fixedDeltaTime;
				}
				m_CollisionFlags = m_CharacterController.Move(m_MoveDir * Time.fixedDeltaTime);
				ProgressStepCycle(speed);
				m_MouseLook.UpdateCursorLock();
			}

			private void PlayJumpSound()
			{
				if (isInSpecialSurface)
				{
					m_AudioSource.clip = jumpSoundOverride;
				}
				else
				{
					m_AudioSource.clip = m_JumpSound;
				}
				m_AudioSource.Play();
			}

			private void ProgressStepCycle(float speed)
			{
				if (m_CharacterController.velocity.sqrMagnitude > 0f && (m_Input.x != 0f || m_Input.y != 0f))
				{
					m_StepCycle += (m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten)) * Time.fixedDeltaTime;
				}
				if (m_StepCycle > m_NextStep)
				{
					m_NextStep = m_StepCycle + m_StepInterval;
					PlayFootStepAudio();
				}
			}

			private void PlayFootStepAudio()
			{
				if (!m_CharacterController.isGrounded)
				{
					return;
				}
				if (!isInSpecialSurface)
				{
					int num = UnityEngine.Random.Range(1, m_FootstepSounds.Length);
					m_AudioSource.clip = m_FootstepSounds[num];
					m_AudioSource.PlayOneShot(m_AudioSource.clip);
					m_FootstepSounds[num] = m_FootstepSounds[0];
					m_FootstepSounds[0] = m_AudioSource.clip;
					return;
				}
				int num2 = UnityEngine.Random.Range(1, footStepsOverride.Length);
				if (num2 >= footStepsOverride.Length)
				{
					num2 = 0;
				}
				m_AudioSource.clip = footStepsOverride[num2];
				m_AudioSource.PlayOneShot(m_AudioSource.clip);
				footStepsOverride[num2] = footStepsOverride[0];
				footStepsOverride[0] = m_AudioSource.clip;
			}

			private void GetInput(out float speed)
			{
				float axis = Input.GetAxis("Horizontal");
				float axis2 = Input.GetAxis("Vertical");
				_ = m_IsWalking;
				speed = (m_IsWalking ? m_WalkSpeed : m_RunSpeed);
				m_Input = new Vector2(axis, axis2);
				if (m_Input.sqrMagnitude > 1f)
				{
					m_Input.Normalize();
				}
			}

			private void RotateView()
			{
				m_MouseLook.LookRotation(base.transform, m_Camera.transform);
			}

			private void OnControllerColliderHit(ControllerColliderHit hit)
			{
				Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
				if (m_CollisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
				{
					attachedRigidbody.AddForceAtPosition(m_CharacterController.velocity * 0.1f, hit.point, ForceMode.Impulse);
				}
			}

			private void OnTriggerEnter(Collider other)
			{
				IL3DN_ChangeWalkingSound component = other.GetComponent<IL3DN_ChangeWalkingSound>();
				if (component != null)
				{
					footStepsOverride = component.footStepsOverride;
					jumpSoundOverride = component.jumpSound;
					landSoundOverride = component.landSound;
					isInSpecialSurface = true;
				}
			}

			private void OnTriggerExit(Collider other)
			{
				isInSpecialSurface = false;
			}
		}
		[Serializable]
		public class IL3DN_SimpleMouseLook
		{
			public float XSensitivity = 2f;

			public float YSensitivity = 2f;

			public bool clampVerticalRotation = true;

			public float MinimumX = -90f;

			public float MaximumX = 90f;

			public bool smooth;

			public float smoothTime = 5f;

			public bool lockCursor = true;

			private Quaternion m_CharacterTargetRot;

			private Quaternion m_CameraTargetRot;

			private bool m_cursorIsLocked = true;

			public void Init(Transform character, Transform camera)
			{
				m_CharacterTargetRot = character.localRotation;
				m_CameraTargetRot = camera.localRotation;
			}

			public void LookRotation(Transform character, Transform camera)
			{
				float y = Input.GetAxis("Mouse X") * XSensitivity;
				float num = Input.GetAxis("Mouse Y") * YSensitivity;
				m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
				m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
				if (clampVerticalRotation)
				{
					m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
				}
				if (smooth)
				{
					character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
					camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
				}
				else
				{
					character.localRotation = m_CharacterTargetRot;
					camera.localRotation = m_CameraTargetRot;
				}
				UpdateCursorLock();
			}

			public void SetCursorLock(bool value)
			{
				lockCursor = value;
				if (!lockCursor)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}

			public void UpdateCursorLock()
			{
				if (lockCursor)
				{
					InternalLockUpdate();
				}
			}

			private void InternalLockUpdate()
			{
				if (Input.GetKeyUp(KeyCode.Escape))
				{
					m_cursorIsLocked = false;
				}
				else if (Input.GetMouseButtonUp(0))
				{
					m_cursorIsLocked = true;
				}
				if (m_cursorIsLocked)
				{
					Cursor.lockState = CursorLockMode.Locked;
					Cursor.visible = false;
				}
				else if (!m_cursorIsLocked)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}

			private Quaternion ClampRotationAroundXAxis(Quaternion q)
			{
				q.x /= q.w;
				q.y /= q.w;
				q.z /= q.w;
				q.w = 1f;
				float value = 114.59156f * Mathf.Atan(q.x);
				value = Mathf.Clamp(value, MinimumX, MaximumX);
				q.x = Mathf.Tan((float)Math.PI / 360f * value);
				return q;
			}
		}
		[ExecuteInEditMode]
		public class IL3DN_Wind : MonoBehaviour
		{
			public bool Wiggle = true;

			public bool Wind = true;

			[Range(0f, 1f)]
			public float WindStrenght = 1f;

			[Range(0f, 10f)]
			public float WindSpeed = 10f;

			[Range(0f, 1f)]
			public float WindTurbulence = 0.3f;

			[Range(0f, 1f)]
			public float LeavesWiggle = 0.01f;

			[Range(0f, 1f)]
			public float GrassWiggle = 0.1f;

			private float WindGizmo = 0.5f;

			private void Update()
			{
				if (Wiggle)
				{
					Shader.EnableKeyword("_WIGGLE_ON");
				}
				else
				{
					Shader.DisableKeyword("_WIGGLE_ON");
				}
				if (Wind)
				{
					Shader.EnableKeyword("_WIND_ON");
				}
				else
				{
					Shader.DisableKeyword("_WIND_ON");
				}
				Shader.SetGlobalVector("WindDirection", base.transform.rotation * Vector3.back);
				Shader.SetGlobalFloat("WindStrenghtFloat", WindStrenght);
				Shader.SetGlobalFloat("WindSpeedFloat", WindSpeed);
				Shader.SetGlobalFloat("WindTurbulenceFloat", WindTurbulence);
				Shader.SetGlobalFloat("LeavesWiggleFloat", LeavesWiggle);
				Shader.SetGlobalFloat("GrassWiggleFloat", GrassWiggle);
			}

			private void OnDrawGizmos()
			{
				_ = (base.transform.position + base.transform.forward).normalized;
				Gizmos.color = Color.green;
				Vector3 up = base.transform.up;
				Vector3 right = base.transform.right;
				Vector3 vector = base.transform.position + base.transform.forward * (WindGizmo * 10f);
				Gizmos.DrawLine(base.transform.position, vector);
				float windGizmo = WindGizmo;
				Vector3 vector2 = base.transform.forward * WindGizmo;
				Gizmos.DrawLine(vector, vector - vector2 + up * windGizmo);
				Gizmos.DrawLine(vector, vector - vector2 - up * windGizmo);
				Gizmos.DrawLine(vector, vector - vector2 + right * windGizmo);
				Gizmos.DrawLine(vector, vector - vector2 - right * windGizmo);
				Gizmos.DrawLine(vector - vector2 - right * windGizmo, vector - vector2 + up * windGizmo);
				Gizmos.DrawLine(vector - vector2 + up * windGizmo, vector - vector2 + right * windGizmo);
				Gizmos.DrawLine(vector - vector2 + right * windGizmo, vector - vector2 - up * windGizmo);
				Gizmos.DrawLine(vector - vector2 - up * windGizmo, vector - vector2 - right * windGizmo);
			}
		}
	}
	namespace FlightKit
	{
		public enum AdShowResult
		{
			Finished,
			Skipped,
			Failed
		}
		public abstract class AbstractAdsProvider : MonoBehaviour
		{
			public virtual void ShowRewardedAd(Action<AdShowResult> resultCallback)
			{
			}
		}
		public class UnityAdsProvider : AbstractAdsProvider
		{
			public override void ShowRewardedAd(Action<AdShowResult> resultCallback)
			{
			}
		}
		public class AirplaneTrails : MonoBehaviour
		{
			public GameObject[] trailsContainer;

			public virtual void ActivateTrails()
			{
				UnityEngine.Debug.Log("Active");
				if (trailsContainer == null)
				{
					return;
				}
				UnityEngine.Debug.Log("Not Zero");
				GameObject[] array = trailsContainer;
				foreach (GameObject gameObject in array)
				{
					UnityEngine.Debug.Log("Found Trail");
					if (gameObject != null)
					{
						gameObject.SetActive(value: true);
					}
				}
			}

			public virtual void DeactivateTrails()
			{
				if (trailsContainer == null)
				{
					return;
				}
				GameObject[] array = trailsContainer;
				foreach (GameObject gameObject in array)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(value: false);
					}
				}
			}

			public virtual void ClearTrails()
			{
				if (trailsContainer == null)
				{
					return;
				}
				GameObject[] array = trailsContainer;
				foreach (GameObject gameObject in array)
				{
					if (gameObject != null)
					{
						TrailRenderer[] components = gameObject.GetComponents<TrailRenderer>();
						for (int j = 0; j < components.Length; j++)
						{
							components[j].Clear();
						}
					}
				}
			}
		}
		[RequireComponent(typeof(AeroplaneController))]
		public class AirplaneUserControl : MonoBehaviour
		{
			[Header("The following limits are for mobile controls.")]
			[Tooltip("Maximum allowed roll angle on mobile.")]
			public float maxRollAngle = 80f;

			[Tooltip("Maximum allowed pitch angle on mobile.")]
			public float maxPitchAngle = 80f;

			private AeroplaneController _airplane;

			private void Awake()
			{
				_airplane = GetComponent<AeroplaneController>();
			}

			private IEnumerator Start()
			{
				float aerodynamicEffect = _airplane.AerodynamicEffect;
				_airplane.AerodynamicEffect = 0f;
				yield return new WaitForSeconds(3f);
				_airplane.AerodynamicEffect = aerodynamicEffect;
			}

			private void FixedUpdate()
			{
				float num = (ControlsPrefs.IsMouseEnabled ? CrossPlatformInputManager.GetAxis("Mouse Y") : 0f);
				float num2 = (ControlsPrefs.IsMouseEnabled ? CrossPlatformInputManager.GetAxis("Mouse X") : 0f);
				float num3 = (ControlsPrefs.IsRollEnabled ? (CrossPlatformInputManager.GetAxis("Roll") + num2) : 0f);
				float pitch = (ControlsPrefs.IsInversePitch ? (-1f) : 1f) * CrossPlatformInputManager.GetAxis("Pitch") + num;
				float axis = CrossPlatformInputManager.GetAxis("Yaw");
				bool button = CrossPlatformInputManager.GetButton("Brakes");
				float throttle = ((!button) ? 1 : (-1));
				num3 = CrossPlatformInputManager.GetAxis("Roll");
				AdjustInputForMobileControls(ref num3, ref pitch, ref throttle);
				_airplane.Move(num3, pitch, axis, throttle, button);
			}

			private void AdjustInputForMobileControls(ref float roll, ref float pitch, ref float throttle)
			{
				float num = roll * maxRollAngle * ((float)Math.PI / 180f);
				float num2 = pitch * maxPitchAngle * ((float)Math.PI / 180f);
				roll = Mathf.Clamp(num - _airplane.RollAngle, -1f, 1f);
				pitch = Mathf.Clamp(num2 - _airplane.PitchAngle, -1f, 1f);
				float num3 = throttle * 0.5f + 0.5f;
				throttle = Mathf.Clamp(num3 - _airplane.Throttle, -1f, 1f);
			}
		}
		public class CrashController : MonoBehaviour
		{
			public float crashImpulse = 10f;

			public float hitImpulse = 5f;

			[Space]
			public AudioClip crash;

			public AudioClip hit;

			private AudioSource _soundSource;

			private void Start()
			{
				_soundSource = GetComponent<AudioSource>();
			}

			public void OnCollisionEnter(Collision collision)
			{
				float magnitude = collision.impulse.magnitude;
				if (!collision.gameObject.CompareTag(Tags.TakeOffPlatform) && magnitude > hitImpulse)
				{
					RegisterHit();
				}
				if (magnitude > crashImpulse)
				{
					RegisterCrash();
				}
			}

			private void RegisterHit()
			{
				if (_soundSource != null && _soundSource.isActiveAndEnabled)
				{
					_soundSource.PlayOneShot(crash);
				}
				StartCoroutine(CollisionCameraAnimation());
			}

			private void RegisterCrash()
			{
				if (_soundSource != null)
				{
					_soundSource.PlayOneShot(hit);
				}
				AirplaneTrails component = GetComponent<AirplaneTrails>();
				component.DeactivateTrails();
				component.ClearTrails();
				ObjectResetter component2 = GetComponent<ObjectResetter>();
				if (component2 != null)
				{
					component2.DelayedReset(0.4f);
				}
			}

			private IEnumerator CollisionCameraAnimation()
			{
				NoiseAndScratches cameraFx = UnityEngine.Object.FindObjectOfType<NoiseAndScratches>();
				if (cameraFx != null)
				{
					cameraFx.enabled = true;
					yield return new WaitForSeconds(1f);
					cameraFx.enabled = false;
				}
			}
		}
		public class FOVController : MonoBehaviour
		{
			public float maxFovChangeFactor = 1.2f;

			private GameObject _airplane;

			private Camera _mainCamera;

			private Rigidbody _airplaneRigidBody;

			private float _baseFov;

			private float _maxFovIncrease;

			private float _maxSpeedSqr;

			private void Start()
			{
				AirplaneUserControl airplaneUserControl = UnityEngine.Object.FindObjectOfType<AirplaneUserControl>();
				if (airplaneUserControl == null)
				{
					UnityEngine.Debug.LogError("FLIGHT KIT StartLevelSequence: an AeroplaneUserControl component is missing in the scene");
					return;
				}
				_airplane = airplaneUserControl.gameObject;
				_mainCamera = Camera.main;
				_baseFov = _mainCamera.fieldOfView;
				_maxFovIncrease = _baseFov * (maxFovChangeFactor - 1f);
				_airplaneRigidBody = _airplane.GetComponent<Rigidbody>();
				_maxSpeedSqr = _airplane.GetComponent<AeroplaneController>().MaxSpeed;
				_maxSpeedSqr *= _maxSpeedSqr;
			}

			private void FixedUpdate()
			{
			}
		}
		public class LevelBroundsTracker : MonoBehaviour
		{
			public string levelBoundsTag;

			private int _currentSensorsCount;

			private AudioSource _soundSource;

			private float _defaultBloomIntensity;

			private float _defaultBloomThreshold;

			public AudioClip resetSound;

			private void Start()
			{
				_soundSource = GetComponent<AudioSource>();
				BloomOptimized bloomOptimized = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				if (bloomOptimized != null)
				{
					_defaultBloomIntensity = bloomOptimized.intensity;
					_defaultBloomThreshold = bloomOptimized.threshold;
				}
			}

			private void OnTriggerEnter(Collider collider)
			{
				if (collider.gameObject.CompareTag(levelBoundsTag))
				{
					_currentSensorsCount++;
				}
			}

			private void OnTriggerExit(Collider collider)
			{
				if (collider.gameObject.CompareTag(levelBoundsTag))
				{
					_currentSensorsCount--;
					if (_currentSensorsCount <= 0)
					{
						RegisterAbandonedLevel();
					}
				}
			}

			private void RegisterAbandonedLevel()
			{
				if (_soundSource != null && resetSound != null)
				{
					_soundSource.PlayOneShot(resetSound);
				}
				AirplaneTrails component = GetComponent<AirplaneTrails>();
				component.DeactivateTrails();
				component.ClearTrails();
				StartCoroutine(FadeOutCoroutine());
			}

			private IEnumerator FadeOutCoroutine()
			{
				BloomOptimized bloom = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				if (bloom == null)
				{
					ResetAirplane();
					yield break;
				}
				float targetIntensity2 = 2.5f;
				WaitForEndOfFrame wait = new WaitForEndOfFrame();
				float tween2 = 1f;
				while ((double)tween2 > 0.1)
				{
					bloom.intensity = Mathf.Lerp(bloom.intensity, targetIntensity2, 1.5f * Time.deltaTime);
					bloom.threshold = Mathf.Lerp(bloom.threshold, 0f, 1.5f * Time.deltaTime);
					tween2 = Mathf.Lerp(tween2, 0f, 1.5f * Time.deltaTime);
					yield return wait;
				}
				ResetAirplane();
				targetIntensity2 = _defaultBloomIntensity;
				tween2 = 1f;
				while ((double)tween2 > 0.1)
				{
					bloom.intensity = Mathf.Lerp(bloom.intensity, targetIntensity2, 2f * Time.deltaTime);
					bloom.threshold = Mathf.Lerp(bloom.threshold, 0f, 2f * Time.deltaTime);
					tween2 = Mathf.Lerp(tween2, 0f, 3f * Time.deltaTime);
					yield return wait;
				}
				bloom.intensity = _defaultBloomIntensity;
				bloom.threshold = _defaultBloomThreshold;
			}

			private void ResetAirplane()
			{
				ObjectResetter component = GetComponent<ObjectResetter>();
				if (component != null)
				{
					component.DelayedReset(0f);
				}
			}
		}
		[RequireComponent(typeof(AeroplaneController))]
		public class SimplePropellerAnimator : MonoBehaviour
		{
			public Transform propellerModel;

			public float maxRpm = 2000f;

			public bool rotateAroundX;

			private AeroplaneController _airplane;

			private const float RPM_TO_DPS = 60f;

			private Renderer _propellerModelRenderer;

			private void Awake()
			{
				_airplane = GetComponent<AeroplaneController>();
			}

			private void Update()
			{
				if ((bool)_airplane && (bool)propellerModel)
				{
					float num = maxRpm * _airplane.Throttle * Time.deltaTime * 60f;
					if (rotateAroundX)
					{
						propellerModel.Rotate(num, 0f, 0f);
					}
					else
					{
						propellerModel.Rotate(0f, num, 0f);
					}
				}
			}
		}
		public class TakeOffPublisher : MonoBehaviour
		{
			private const float MIN_LANDING_DURATION = 1f;

			private const float MIN_TIME_BETWEEN_LANDINGS = 10f;

			private float _collisionEnterTime = -1f;

			public static event GameActions.SimpleAction OnTakeOffEvent;

			private void OnCollisionEnter(Collision collision)
			{
				if ((Time.time - _collisionEnterTime > 10f || _collisionEnterTime < 0f) && collision.gameObject.CompareTag(Tags.TakeOffPlatform))
				{
					_collisionEnterTime = Time.time;
				}
			}

			private void OnCollisionExit(Collision collision)
			{
				if (Time.time - _collisionEnterTime > 1f && collision.gameObject.CompareTag(Tags.TakeOffPlatform) && TakeOffPublisher.OnTakeOffEvent != null)
				{
					TakeOffPublisher.OnTakeOffEvent();
				}
			}
		}
		public class TiltInputCalibration : MonoBehaviour
		{
			public TiltInput calibrationTarget;

			public GameObject calibrationPopup;

			public float delayAfterStartPlay = 8f;

			private void OnEnable()
			{
				UIEventsPublisher.OnPlayEvent += CalibrateDelayed;
				PauseController.OnUnPauseEvent += Calibrate;
			}

			private void OnDisable()
			{
				UIEventsPublisher.OnPlayEvent -= CalibrateDelayed;
				PauseController.OnUnPauseEvent -= Calibrate;
			}

			public virtual void CalibrateDelayed()
			{
				if (ControlsPrefs.IsTiltEnabled)
				{
					StartCoroutine(CalibrateCoroutine(delayAfterStartPlay));
				}
			}

			public virtual void Calibrate()
			{
				if (ControlsPrefs.IsTiltEnabled)
				{
					StartCoroutine(CalibrateCoroutine());
				}
			}

			private IEnumerator CalibrateCoroutine(float delay = 0f)
			{
				if (delay > 0f)
				{
					yield return new WaitForSeconds(delay);
				}
				if (calibrationPopup != null)
				{
					calibrationPopup.SetActive(value: true);
				}
				yield return new WaitForSeconds(3f);
				if (calibrationTarget == null)
				{
					yield break;
				}
				float b = 0f;
				if (Input.acceleration != Vector3.zero)
				{
					switch (calibrationTarget.tiltAroundAxis)
					{
					case TiltInput.AxisOptions.ForwardAxis:
						b = Mathf.Atan2(Input.acceleration.x, 0f - Input.acceleration.y) * 57.29578f;
						break;
					case TiltInput.AxisOptions.SidewaysAxis:
						b = Mathf.Atan2(Input.acceleration.z, 0f - Input.acceleration.y) * 57.29578f;
						break;
					}
				}
				b = Mathf.Min(180f, b);
				b = Mathf.Max(-180f, b);
				calibrationTarget.centreAngleOffset = 0f - b;
				if (calibrationPopup != null)
				{
					calibrationPopup.SetActive(value: false);
				}
			}
		}
		public class BoidMaster : MonoBehaviour
		{
			public GameObject boidPrefab;

			public int spawnCount = 10;

			public float spawnRadius = 100f;

			public float neighborDistance = 10f;

			public float speed = 10f;

			public float speedVariation = 1f;

			public float rotationCoefficient = 5f;

			public LayerMask searchLayer;

			private void Start()
			{
				for (int i = 0; i < spawnCount; i++)
				{
					Spawn();
				}
			}

			public GameObject Spawn()
			{
				return Spawn(base.transform.position + UnityEngine.Random.insideUnitSphere * spawnRadius);
			}

			public GameObject Spawn(Vector3 position)
			{
				Quaternion rotation = Quaternion.Slerp(base.transform.rotation, UnityEngine.Random.rotation, 0.25f);
				GameObject gameObject = UnityEngine.Object.Instantiate(boidPrefab, position, rotation);
				gameObject.GetComponent<BoidUnit>().master = this;
				if (base.transform.parent != null)
				{
					gameObject.transform.parent = base.transform.parent;
				}
				return gameObject;
			}
		}
		public class BoidUnit : MonoBehaviour
		{
			public BoidMaster master;

			private void Update()
			{
				Vector3 position = base.transform.position;
				Quaternion rotation = base.transform.rotation;
				Vector3 zero = Vector3.zero;
				Vector3 forward = master.transform.forward;
				Vector3 position2 = master.transform.position;
				Collider[] array = Physics.OverlapSphere(position, master.neighborDistance, master.searchLayer);
				Collider[] array2 = array;
				foreach (Collider collider in array2)
				{
					if (!(collider.gameObject == base.gameObject))
					{
						Transform transform = collider.transform;
						zero += GetSeparationVector(transform);
						forward += transform.forward;
						position2 += transform.position;
					}
				}
				float num = 1f / (float)array.Length;
				forward *= num;
				position2 *= num;
				position2 = (position2 - position).normalized;
				Vector3 vector = zero + forward + position2;
				Quaternion quaternion = Quaternion.FromToRotation(Vector3.forward, vector.normalized);
				if (quaternion != rotation)
				{
					float t = Mathf.Exp((0f - master.rotationCoefficient) * Time.deltaTime);
					base.transform.rotation = Quaternion.Slerp(quaternion, rotation, t);
				}
				float num2 = Mathf.PerlinNoise(Time.time, UnityEngine.Random.value * 10f) * 2f - 1f;
				float num3 = master.speed * (1f + num2 * master.speedVariation);
				base.transform.position = position + base.transform.forward * num3 * Time.deltaTime;
			}

			private Vector3 GetSeparationVector(Transform target)
			{
				Vector3 vector = base.transform.position - target.transform.position;
				float magnitude = vector.magnitude;
				float num = Mathf.Clamp01(1f - magnitude / master.neighborDistance);
				return vector * (num / magnitude);
			}
		}
		public static class Tags
		{
			public static string TakeOffPlatform = "TakeOffPlatform";

			public static string Player = "Player";
		}
		public class ActivateOnTakeOff : MonoBehaviour
		{
			public float delay;

			public GameObject[] objectsToActivate;

			public GameObject[] objectsToDeactivate;

			private void OnEnable()
			{
				TakeOffPublisher.OnTakeOffEvent += OnTakeOff;
			}

			private void OnDisable()
			{
				TakeOffPublisher.OnTakeOffEvent -= OnTakeOff;
			}

			private void OnTakeOff()
			{
				Invoke("OnTakeOffCore", delay);
			}

			private void OnTakeOffCore()
			{
				GameObject[] array = objectsToActivate;
				foreach (GameObject gameObject in array)
				{
					if (gameObject != null)
					{
						gameObject.SetActive(value: true);
					}
				}
				array = objectsToDeactivate;
				foreach (GameObject gameObject2 in array)
				{
					if (gameObject2 != null)
					{
						gameObject2.SetActive(value: false);
					}
				}
			}
		}
		public class ControlsPrefs
		{
			private static bool _isRollEnabled;

			private static bool _isMouseEnabled;

			private static bool _isTiltEnabled;

			private static bool _isInversePitch;

			private static string PREF_KEY_ROLL_ENABLED;

			private static string PREF_KEY_MOUSE_ENABLED;

			private static string PREF_KEY_TILT_ENABLED;

			private static string PREF_KEY_INVERSE_PITCH;

			public static bool IsRollEnabled
			{
				get
				{
					return _isRollEnabled;
				}
				set
				{
					_isRollEnabled = value;
					OVPlayerPrefs.SetInt(PREF_KEY_ROLL_ENABLED, value ? 1 : 0);
					OVPlayerPrefs.Save();
				}
			}

			public static bool IsMouseEnabled
			{
				get
				{
					return _isMouseEnabled;
				}
				set
				{
					_isMouseEnabled = value;
					OVPlayerPrefs.SetInt(PREF_KEY_MOUSE_ENABLED, value ? 1 : 0);
					OVPlayerPrefs.Save();
				}
			}

			public static bool IsTiltEnabled
			{
				get
				{
					return _isTiltEnabled;
				}
				set
				{
					_isTiltEnabled = value;
					OVPlayerPrefs.SetInt(PREF_KEY_TILT_ENABLED, value ? 1 : 0);
					OVPlayerPrefs.Save();
					if (value)
					{
						if (ControlsPrefs.OnTiltEnabledEvent != null)
						{
							ControlsPrefs.OnTiltEnabledEvent();
						}
					}
					else if (ControlsPrefs.OnTiltDisabledEvent != null)
					{
						ControlsPrefs.OnTiltDisabledEvent();
					}
				}
			}

			public static bool IsInversePitch
			{
				get
				{
					return _isInversePitch;
				}
				set
				{
					_isInversePitch = value;
					OVPlayerPrefs.SetInt(PREF_KEY_INVERSE_PITCH, value ? 1 : 0);
					OVPlayerPrefs.Save();
				}
			}

			public static event GameActions.SimpleAction OnTiltEnabledEvent;

			public static event GameActions.SimpleAction OnTiltDisabledEvent;

			static ControlsPrefs()
			{
				PREF_KEY_ROLL_ENABLED = "FlightControls_RollEnabled";
				PREF_KEY_MOUSE_ENABLED = "FlightControls_MouseEnabled";
				PREF_KEY_TILT_ENABLED = "FlightControls_TiltEnabled";
				PREF_KEY_INVERSE_PITCH = "FlightControls_InversePitch";
				if (!OVPlayerPrefs.HasID(PREF_KEY_ROLL_ENABLED))
				{
					IsRollEnabled = true;
					IsMouseEnabled = false;
					IsTiltEnabled = true;
					IsInversePitch = false;
				}
				else
				{
					IsRollEnabled = OVPlayerPrefs.GetInt(PREF_KEY_ROLL_ENABLED) == 1;
					IsMouseEnabled = OVPlayerPrefs.GetInt(PREF_KEY_MOUSE_ENABLED) == 1;
					IsTiltEnabled = OVPlayerPrefs.GetInt(PREF_KEY_TILT_ENABLED) == 1;
					IsInversePitch = OVPlayerPrefs.GetInt(PREF_KEY_INVERSE_PITCH) == 1;
				}
			}
		}
		public class FuelController : MonoBehaviour
		{
			public const float LOW_FUEL_PERCENT = 0.25f;

			[Tooltip("How fast the fuel is used. Higher number - harder gameplay.")]
			public float consumptionRate = 1f;

			[Tooltip("How much fuel is added by each pickup. Higher number - easier gameplay.")]
			public float pickupFuelAmount = 0.25f;

			[Tooltip("Amount of fuel user receives on reviving.")]
			public float reviveFuelAmount = 0.5f;

			private bool _isConsuming;

			private bool _lowFuelRegistered;

			public float fuelAmount { get; protected set; }

			public static event GameActions.SimpleAction OnFuelLowEvent;

			public static event GameActions.SimpleAction OnFuelEmptyEvent;

			private void Start()
			{
				fuelAmount = 1f;
			}

			private void OnEnable()
			{
				PickupSphere.OnCollectEvent += HandlePickupCollected;
				TakeOffPublisher.OnTakeOffEvent += HandleTakeOff;
				RevivePermissionProvider.OnReviveGranted += HandleRevive;
			}

			private void OnDisable()
			{
				PickupSphere.OnCollectEvent -= HandlePickupCollected;
				TakeOffPublisher.OnTakeOffEvent -= HandleTakeOff;
				RevivePermissionProvider.OnReviveGranted -= HandleRevive;
			}

			private void HandlePickupCollected()
			{
				fuelAmount += pickupFuelAmount;
				if (fuelAmount >= 0.25f)
				{
					_lowFuelRegistered = false;
				}
			}

			private void HandleTakeOff()
			{
				_isConsuming = true;
			}

			private void HandleRevive()
			{
				_isConsuming = true;
				fuelAmount = reviveFuelAmount;
				if (fuelAmount > 0.25f)
				{
					_lowFuelRegistered = false;
				}
				base.gameObject.SetActive(value: true);
			}

			private void Update()
			{
				if (_isConsuming)
				{
					fuelAmount -= consumptionRate * Time.deltaTime * 0.01f;
					if (!_lowFuelRegistered && fuelAmount < 0.25f)
					{
						_lowFuelRegistered = true;
						if (FuelController.OnFuelLowEvent != null)
						{
							FuelController.OnFuelLowEvent();
						}
					}
				}
				if (fuelAmount <= 0f && _isConsuming && FuelController.OnFuelEmptyEvent != null)
				{
					_isConsuming = false;
					FuelController.OnFuelEmptyEvent();
				}
			}
		}
		public class GameProgressTracker : MonoBehaviour
		{
			public Text pickupsCurrentText;

			public Text pickupsTotalText;

			public Image pickupIconImage;

			private int _numPickupsCollected;

			private int _numPickupsTotal;

			public bool overrideTotalPickupNumber;

			public int newTotalPicupNumber = 10;

			private void Start()
			{
				if (pickupsCurrentText == null)
				{
					GameObject gameObject = GameObject.Find("PickupsCurrent");
					if (gameObject != null)
					{
						pickupsCurrentText = gameObject.GetComponent<Text>();
					}
				}
				if (pickupsTotalText == null)
				{
					GameObject gameObject2 = GameObject.Find("PickupsTotal");
					if (gameObject2 != null)
					{
						pickupsTotalText = gameObject2.GetComponent<Text>();
					}
				}
				if (pickupIconImage == null)
				{
					GameObject gameObject3 = GameObject.Find("PickupIcon");
					if (gameObject3 != null)
					{
						pickupIconImage = gameObject3.GetComponent<Image>();
					}
				}
				PickupSphere[] array = UnityEngine.Object.FindObjectsOfType<PickupSphere>();
				if (overrideTotalPickupNumber)
				{
					_numPickupsTotal = newTotalPicupNumber;
				}
				else
				{
					_numPickupsTotal = array.Length;
				}
				if (pickupsTotalText != null)
				{
					pickupsTotalText.text = _numPickupsTotal.ToString();
				}
				PickupSphere.OnCollectEvent += RegisterPickup;
			}

			private void OnDestroy()
			{
				PickupSphere.OnCollectEvent -= RegisterPickup;
			}

			private void RegisterPickup()
			{
				if (_numPickupsCollected == 0)
				{
					ShowPickupCounter();
				}
				_numPickupsCollected++;
				if (pickupsCurrentText != null)
				{
					pickupsCurrentText.text = _numPickupsCollected.ToString();
				}
				if (_numPickupsCollected >= _numPickupsTotal)
				{
					RegisterLevelComplete();
				}
			}

			public virtual void RegisterLevelComplete()
			{
				FuelController fuelController = UnityEngine.Object.FindObjectOfType<FuelController>();
				if (fuelController != null)
				{
					fuelController.enabled = false;
				}
				StartCoroutine(FadeOutCoroutine());
			}

			private IEnumerator FadeOutCoroutine()
			{
				BloomOptimized bloom = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				float targetIntensity = 2.3f;
				float targetThreshold = 0.4f;
				MusicController musicController = UnityEngine.Object.FindObjectOfType<MusicController>();
				bool tweenMusic = musicController != null && musicController.gameplay != null;
				WaitForEndOfFrame wait = new WaitForEndOfFrame();
				float tween = 1f;
				float tweenSpeed = 0.5f;
				float realtimeSinceStartup = Time.realtimeSinceStartup;
				float lastTime = realtimeSinceStartup;
				float fixedDeltaTime = Time.fixedDeltaTime;
				while ((double)tween > 0.1)
				{
					float num = Time.realtimeSinceStartup - lastTime;
					lastTime = Time.realtimeSinceStartup;
					if (bloom != null)
					{
						bloom.intensity = Mathf.Lerp(bloom.intensity, targetIntensity, tweenSpeed * num);
						bloom.threshold = Mathf.Lerp(bloom.threshold, targetThreshold, tweenSpeed * num);
					}
					if (tweenMusic)
					{
						musicController.gameplay.volume = Mathf.Lerp(musicController.gameplay.volume, 0f, tweenSpeed * num);
					}
					Time.timeScale = Mathf.Lerp(Time.timeScale, 0f, tweenSpeed * num);
					Time.fixedDeltaTime = fixedDeltaTime * Time.timeScale;
					tween = Mathf.Lerp(tween, 0f, tweenSpeed * num);
					yield return wait;
				}
				Time.timeScale = 1f;
				Time.fixedDeltaTime = fixedDeltaTime;
				LevelCompleteController levelCompleteController = UnityEngine.Object.FindObjectOfType<LevelCompleteController>();
				if (levelCompleteController != null)
				{
					levelCompleteController.HandleLevelComplete();
				}
			}

			private void ShowPickupCounter()
			{
				if (pickupIconImage != null)
				{
					pickupIconImage.enabled = true;
					pickupIconImage.canvasRenderer.SetAlpha(0f);
					pickupIconImage.CrossFadeAlpha(1f, 5f, ignoreTimeScale: false);
				}
				if (pickupsCurrentText != null)
				{
					pickupsCurrentText.enabled = true;
					pickupsCurrentText.canvasRenderer.SetAlpha(0f);
					pickupsCurrentText.CrossFadeAlpha(1f, 5f, ignoreTimeScale: false);
				}
				if (pickupsTotalText != null)
				{
					pickupsTotalText.enabled = true;
					pickupsTotalText.canvasRenderer.SetAlpha(0f);
					pickupsTotalText.CrossFadeAlpha(1f, 5f, ignoreTimeScale: false);
				}
			}
		}
		public class LevelCompleteController : MonoBehaviour
		{
			[Tooltip("Whether we should restart current scene or load the next one on level completion.")]
			public bool restartCurrentScene;

			public bool gotoFirstScene;

			public bool gotoLastScene;

			public virtual void HandleLevelComplete()
			{
				if (gotoLastScene)
				{
					OVAchievement.Unlock((SceneManager.GetActiveScene().buildIndex - 1).ToString() ?? "");
					SceneManager.LoadScene(SceneManager.sceneCountInBuildSettings - 1);
					return;
				}
				if (restartCurrentScene)
				{
					SceneManager.LoadScene(SceneManager.GetActiveScene().name);
					return;
				}
				if (gotoFirstScene)
				{
					WTFGenericSingleton<MenuController>.Instance.LoadLevel(0);
					return;
				}
				OVPlayerPrefs.SetInt("Level" + (SceneManager.GetActiveScene().buildIndex - 1), 1);
				OVAchievement.Unlock((SceneManager.GetActiveScene().buildIndex - 1).ToString() ?? "");
				int num = SceneManager.GetActiveScene().buildIndex + 1;
				if (num < SceneManager.sceneCountInBuildSettings - 1)
				{
					WTFGenericSingleton<MenuController>.Instance.LoadLevel(num - 1);
				}
				else
				{
					WTFGenericSingleton<MenuController>.Instance.LoadLevel(0);
				}
			}

			public void Update()
			{
				if (Input.GetKey(KeyCode.G) && Input.GetKey(KeyCode.O))
				{
					HandleLevelComplete();
				}
			}
		}
		public class LevelFailController : MonoBehaviour
		{
			[Tooltip("If true, level fail menu will be shown. Otherwise, scene will be restarted.")]
			public bool showLevelFailMenu = true;

			[Tooltip("Game over screen.")]
			public CanvasGroup levelFailMenu;

			private float _defaultBloomIntensity;

			private float _defaultBloomThreshold;

			private void OnEnable()
			{
				FuelController.OnFuelEmptyEvent += HandleLevelFailed;
				RevivePermissionProvider.OnReviveGranted += HandleReviveGranted;
			}

			private void OnDisable()
			{
				FuelController.OnFuelEmptyEvent -= HandleLevelFailed;
				RevivePermissionProvider.OnReviveGranted -= HandleReviveGranted;
			}

			private void Start()
			{
				BloomOptimized bloomOptimized = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				if (bloomOptimized != null)
				{
					_defaultBloomIntensity = bloomOptimized.intensity;
					_defaultBloomThreshold = bloomOptimized.threshold;
				}
			}

			public virtual void HandleLevelFailed()
			{
				if (showLevelFailMenu)
				{
					StartCoroutine(FadeOutCoroutine());
					return;
				}
				Time.timeScale = 1f;
				SceneManager.LoadScene(SceneManager.GetActiveScene().name);
			}

			private IEnumerator FadeOutCoroutine()
			{
				yield return new WaitForSeconds(1f);
				BloomOptimized bloom = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				if (bloom == null)
				{
					Time.timeScale = 0f;
					if (levelFailMenu != null)
					{
						levelFailMenu.gameObject.SetActive(value: true);
					}
					yield break;
				}
				float targetIntensity = 2.2f;
				float targetThreshold = 0.3f;
				WaitForEndOfFrame wait = new WaitForEndOfFrame();
				float tween = 1f;
				if (levelFailMenu != null)
				{
					levelFailMenu.alpha = 0f;
					levelFailMenu.gameObject.SetActive(value: true);
				}
				float prevTime = Time.realtimeSinceStartup;
				while ((double)tween > 0.1)
				{
					float num = Time.realtimeSinceStartup - prevTime;
					prevTime = Time.realtimeSinceStartup;
					bloom.intensity = Mathf.Lerp(bloom.intensity, targetIntensity, 1.5f * num);
					bloom.threshold = Mathf.Lerp(bloom.threshold, targetThreshold, 1.5f * num);
					tween = (Time.timeScale = Mathf.Lerp(tween, 0f, 1.5f * num));
					Time.fixedDeltaTime = tween * 0.02f;
					if (levelFailMenu != null)
					{
						levelFailMenu.alpha = 1f - tween;
					}
					yield return wait;
				}
				if (levelFailMenu != null)
				{
					levelFailMenu.alpha = 1f;
				}
				Time.timeScale = 0f;
				Time.fixedDeltaTime = 0.02f;
			}

			private void HandleReviveGranted()
			{
				Time.timeScale = 1f;
				levelFailMenu.gameObject.SetActive(value: false);
				StartCoroutine(TweenIn());
			}

			private IEnumerator TweenIn()
			{
				BloomOptimized bloom = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				if (!(bloom == null))
				{
					WaitForEndOfFrame wait = new WaitForEndOfFrame();
					float targetIntensity = _defaultBloomIntensity;
					float tween = 1f;
					while ((double)tween > 0.1)
					{
						bloom.intensity = Mathf.Lerp(bloom.intensity, targetIntensity, 2f * Time.deltaTime);
						bloom.threshold = Mathf.Lerp(bloom.threshold, 0f, 2f * Time.deltaTime);
						tween = Mathf.Lerp(tween, 0f, 3f * Time.deltaTime);
						yield return wait;
					}
					bloom.intensity = _defaultBloomIntensity;
					bloom.threshold = _defaultBloomThreshold;
				}
			}
		}
		public class MusicController : MonoBehaviour
		{
			public AudioSource menu;

			public AudioSource gameplay;

			public bool playOnStart = true;

			public bool changeMusicOnTakeOff = true;

			public float menuMusicFadeOutSpeed = 1f;

			private float _initMenuVolume;

			private void Awake()
			{
				if (menu != null && base.enabled)
				{
					_initMenuVolume = menu.volume;
					if (playOnStart)
					{
						menu.Play();
					}
				}
			}

			private void OnEnable()
			{
				if (changeMusicOnTakeOff)
				{
					UIEventsPublisher.OnPlayEvent += OnPlayClicked;
					TakeOffPublisher.OnTakeOffEvent += StartGameplay;
				}
				RevivePermissionProvider.OnReviveRequested += HandleReviveRequest;
				RevivePermissionProvider.OnReviveGranted += HandleRevive;
			}

			private void OnDisable()
			{
				UIEventsPublisher.OnPlayEvent -= OnPlayClicked;
				TakeOffPublisher.OnTakeOffEvent -= StartGameplay;
				RevivePermissionProvider.OnReviveRequested -= HandleReviveRequest;
				RevivePermissionProvider.OnReviveGranted -= HandleRevive;
			}

			public virtual void Pause()
			{
				if ((bool)menu && menu.isPlaying)
				{
					menu.Pause();
				}
				if ((bool)gameplay && gameplay.isPlaying)
				{
					gameplay.Pause();
				}
			}

			public virtual void UnPause()
			{
				if ((bool)menu && !menu.isPlaying)
				{
					menu.UnPause();
				}
				if ((bool)gameplay && !gameplay.isPlaying)
				{
					gameplay.UnPause();
				}
			}

			private void OnPlayClicked()
			{
				StartCoroutine(FadeOutMenu());
			}

			private IEnumerator FadeOutMenu()
			{
				float tweenStartTime = Time.realtimeSinceStartup;
				WaitForEndOfFrame wait = new WaitForEndOfFrame();
				float tweenOutProgress = 1f;
				while (tweenOutProgress > 0.01f)
				{
					tweenOutProgress = Mathf.SmoothStep(1f, 0f, (Time.realtimeSinceStartup - tweenStartTime) * 0.1f * menuMusicFadeOutSpeed);
					menu.volume = _initMenuVolume * tweenOutProgress;
					yield return wait;
				}
				menu.Stop();
				menu.volume = _initMenuVolume;
			}

			private IEnumerator FadeOutGameplay()
			{
				float initVolume = gameplay.volume;
				float tweenStartTime = Time.realtimeSinceStartup;
				WaitForEndOfFrame wait = new WaitForEndOfFrame();
				float tweenOutProgress = 1f;
				while (tweenOutProgress > 0.01f)
				{
					tweenOutProgress = Mathf.SmoothStep(1f, 0f, (Time.realtimeSinceStartup - tweenStartTime) * 0.5f);
					gameplay.volume = initVolume * tweenOutProgress;
					yield return wait;
				}
				gameplay.Pause();
				gameplay.volume = initVolume;
			}

			private void StartGameplay()
			{
				Invoke("StartGameplayCore", 0.5f);
			}

			private void StartGameplayCore()
			{
				if ((bool)gameplay && !gameplay.isPlaying)
				{
					gameplay.Play();
				}
			}

			private void HandleReviveRequest()
			{
				if (gameplay != null)
				{
					StartCoroutine(FadeOutGameplay());
				}
			}

			private void HandleRevive()
			{
				if (gameplay != null)
				{
					StopAllCoroutines();
					StartGameplayCore();
				}
			}
		}
		public class PickupSphere : MonoBehaviour
		{
			public delegate void OnCollectAction();

			public static bool growingEnabled;

			public float growthSpeed = 0.1f;

			public float maxScale = 40f;

			public bool enableGrow;

			public float ringRotationSpeed = 150f;

			public GameObject ring1;

			public GameObject ring2;

			public GameObject sphere;

			public bool useAsPositionCheckpoint = true;

			[Range(0.1f, 72f)]
			public float updateFreq = 10f;

			private float time;

			private bool _activated;

			private BloomOptimized _bloom;

			private float _bloomInitValue;

			private bool _isTweeningOut;

			private bool _isDestroyed;

			public static event OnCollectAction OnCollectEvent;

			private void Start()
			{
				_bloom = UnityEngine.Object.FindObjectOfType<BloomOptimized>();
				if (_bloom != null)
				{
					_bloomInitValue = _bloom.intensity;
				}
			}

			private void Update()
			{
				if (_isDestroyed)
				{
					return;
				}
				if (_isTweeningOut)
				{
					base.transform.localScale = Vector3.Lerp(base.transform.localScale, Vector3.zero, 5f * Time.deltaTime);
					if (_bloom != null)
					{
						_bloom.intensity = Mathf.Lerp(_bloom.intensity, _bloomInitValue, 5f * Time.deltaTime);
					}
				}
				float deltaTime = Time.deltaTime;
				time += deltaTime;
				if (!(time < 1f / updateFreq))
				{
					time = 0f;
					ring1.transform.Rotate(Vector3.right, ringRotationSpeed * Time.deltaTime);
					ring2.transform.Rotate(Vector3.up, ringRotationSpeed * Time.deltaTime);
					if (enableGrow && growingEnabled && base.transform.localScale.x < maxScale)
					{
						base.transform.localScale += Vector3.one * growthSpeed * Time.deltaTime;
					}
				}
			}

			private void OnTriggerEnter(Collider collider)
			{
				if (_activated || !collider.gameObject.CompareTag(Tags.Player))
				{
					return;
				}
				_activated = true;
				if (useAsPositionCheckpoint)
				{
					ObjectResetter component = collider.transform.parent.transform.parent.GetComponent<ObjectResetter>();
					if (component != null)
					{
						component.SetResetterPosition(base.transform);
					}
				}
				if (PickupSphere.OnCollectEvent != null)
				{
					PickupSphere.OnCollectEvent();
				}
				AudioSource componentInParent = GetComponentInParent<AudioSource>();
				if (componentInParent != null)
				{
					componentInParent.Play();
				}
				_isTweeningOut = true;
				if (_bloom != null)
				{
					_bloom.intensity = 0.5f;
				}
				BoidMaster componentInParent2 = GetComponentInParent<BoidMaster>();
				if (componentInParent2 != null)
				{
					componentInParent2.neighborDistance = 250f;
				}
				Invoke("DestroyNow", 1f);
			}

			public void TweenBloom(float value)
			{
				_bloom.intensity = value;
			}

			private void DestroyNow()
			{
				_bloom.intensity = _bloomInitValue;
				UnityEngine.Object.Destroy(sphere);
				UnityEngine.Object.Destroy(ring1);
				UnityEngine.Object.Destroy(ring2);
				_isDestroyed = true;
			}
		}
		public class SaturationController : MonoBehaviour
		{
			private ColorCorrectionCurves _colorCorrectionFx;

			private float _saturationTweenStartTime;

			private void Start()
			{
				_colorCorrectionFx = UnityEngine.Object.FindObjectOfType<ColorCorrectionCurves>();
				if ((bool)_colorCorrectionFx)
				{
					TakeOffPublisher.OnTakeOffEvent += OnTakeOff;
				}
			}

			private void OnDisable()
			{
				TakeOffPublisher.OnTakeOffEvent -= OnTakeOff;
			}

			private void OnTakeOff()
			{
				StartCoroutine(OnTakeOffCore());
			}

			private IEnumerator OnTakeOffCore()
			{
				yield return new WaitForSeconds(0.5f);
				_saturationTweenStartTime = Time.time;
				WaitForEndOfFrame wait = new WaitForEndOfFrame();
				while (_colorCorrectionFx.saturation < 0.99f)
				{
					float num = Time.time - _saturationTweenStartTime;
					_colorCorrectionFx.saturation = Mathf.SmoothStep(0f, 1f, num * 1.2f);
					yield return wait;
				}
				_colorCorrectionFx.saturation = 1f;
			}
		}
		public class SfxController : MonoBehaviour
		{
			[Tooltip("2D audio source to play sound effects on.")]
			public AudioSource audioSource;

			[Space]
			[Tooltip("The sound that is played when user's fuel gets low, but not completely gone yet.")]
			public AudioClip lowFuelSound;

			[Tooltip("The sound that is played when a level is failed.")]
			public AudioClip levelFailSound;

			[Tooltip("The sound that is played when user is revived after failing.")]
			public AudioClip userRevivedSound;

			private void OnEnable()
			{
				if (audioSource == null)
				{
					base.enabled = false;
					return;
				}
				FuelController.OnFuelLowEvent += HandleFuelLow;
				FuelController.OnFuelEmptyEvent += HandleFuelEmpty;
				RevivePermissionProvider.OnReviveGranted += HandleRevive;
			}

			private void OnDisable()
			{
				FuelController.OnFuelLowEvent -= HandleFuelLow;
				FuelController.OnFuelEmptyEvent -= HandleFuelEmpty;
				RevivePermissionProvider.OnReviveGranted -= HandleRevive;
			}

			private void HandleFuelLow()
			{
				if (lowFuelSound != null)
				{
					audioSource.PlayOneShot(lowFuelSound);
				}
			}

			private void HandleFuelEmpty()
			{
				if (levelFailSound != null)
				{
					audioSource.PlayOneShot(levelFailSound);
				}
			}

			private void HandleRevive()
			{
				if (userRevivedSound != null)
				{
					audioSource.PlayOneShot(userRevivedSound);
				}
			}
		}
		public class StartLevelController : MonoBehaviour
		{
			public bool playOnStart;

			public bool enablePickupGrowingOnStart = true;

			[Space]
			public Vector3 cameraPivotFinalPosition = new Vector3(0f, 10f, -15f);

			private GameObject _airplane;

			private AutoCam _autoCam;

			private float _turnSpeed;

			private GameObject _pivot;

			private Vector3 _initPivotPos;

			private bool _isTweeningIn;

			private float _tweenInProgress;

			private float _tweenInStartTime;

			public bool levelStarted { get; private set; }

			private void Start()
			{
				_autoCam = UnityEngine.Object.FindObjectOfType<AutoCam>();
				_pivot = GameObject.Find("Pivot");
				AirplaneUserControl airplaneUserControl = UnityEngine.Object.FindObjectOfType<AirplaneUserControl>();
				if (airplaneUserControl == null)
				{
					UnityEngine.Debug.LogWarning("FLIGHT KIT StartLevelSequence: an AeroplaneUserControl component is missing in the scene");
					base.enabled = false;
					return;
				}
				_airplane = airplaneUserControl.gameObject;
				if (_autoCam == null)
				{
					UnityEngine.Debug.LogWarning("Can't find AutoCam component in the scene.");
					base.enabled = false;
					return;
				}
				_turnSpeed = _autoCam.TurnSpeed;
				_autoCam.TurnSpeed = 0f;
				if (playOnStart)
				{
					StartLevel();
					UIEventsPublisher uIEventsPublisher = UnityEngine.Object.FindObjectOfType<UIEventsPublisher>();
					if (uIEventsPublisher != null)
					{
						uIEventsPublisher.PublishPlay();
					}
				}
				else
				{
					UIEventsPublisher.OnPlayEvent += StartLevel;
				}
			}

			private void OnDeactivate()
			{
				UIEventsPublisher.OnPlayEvent -= StartLevel;
			}

			private void Update()
			{
				if (_isTweeningIn)
				{
					_tweenInProgress = Mathf.SmoothStep(0f, 1f, (Time.time - _tweenInStartTime) * 0.14f);
					_autoCam.TurnSpeed = _tweenInProgress * _turnSpeed;
					_pivot.transform.localPosition = Vector3.Lerp(_initPivotPos, cameraPivotFinalPosition, _tweenInProgress);
					if (_tweenInProgress > 0.99f)
					{
						_isTweeningIn = false;
						_autoCam.TurnSpeed = _turnSpeed;
						_pivot.transform.localPosition = cameraPivotFinalPosition;
					}
				}
			}

			public virtual void StartLevel()
			{
				if (this != null)
				{
					StartCoroutine(StartLevelCoroutine());
				}
			}

			private IEnumerator StartLevelCoroutine()
			{
				levelStarted = true;
				PauseController pauseController = UnityEngine.Object.FindObjectOfType<PauseController>();
				if ((bool)pauseController)
				{
					pauseController.enabled = true;
				}
				yield return new WaitForSeconds((!playOnStart) ? 3 : 0);
				MenuFadeInController menuFadeInController = UnityEngine.Object.FindObjectOfType<MenuFadeInController>();
				if (menuFadeInController != null)
				{
					GameObject mainMenu = menuFadeInController.mainMenu;
					if (mainMenu != null)
					{
						mainMenu.SetActive(value: false);
					}
				}
				_initPivotPos = _pivot.transform.localPosition;
				_isTweeningIn = true;
				_tweenInStartTime = Time.time;
				_autoCam.enabled = true;
				yield return new WaitForSeconds((!playOnStart) ? 2 : 0);
				MonoBehaviour component = _airplane.GetComponent<AirplaneUserControl>();
				if (component == null)
				{
					UnityEngine.Debug.LogError("Can't find AirplaneUserControl component on the airplane.");
					yield break;
				}
				component.enabled = true;
				yield return new WaitForSeconds((!playOnStart) ? 2 : 0);
				if (enablePickupGrowingOnStart)
				{
					PickupSphere.growingEnabled = true;
				}
			}
		}
		[RequireComponent(typeof(CrossFadeCanvasGroups))]
		public class BackButton : MonoBehaviour
		{
			public CanvasGroup mainMenu;

			public CanvasGroup pauseMenu;

			private CrossFadeCanvasGroups crossFade;

			private StartLevelController startLevelController;

			private void Start()
			{
				crossFade = GetComponent<CrossFadeCanvasGroups>();
				startLevelController = UnityEngine.Object.FindObjectOfType<StartLevelController>();
				crossFade.toGroup = mainMenu;
			}

			public virtual void Activate()
			{
				if (startLevelController != null)
				{
					crossFade.toGroup = (startLevelController.levelStarted ? pauseMenu : mainMenu);
				}
				crossFade.Activate();
			}
		}
		public class ControlsSetting : MonoBehaviour
		{
			[Header("Standalone controls UI (Leave empty if not targeting standalone):")]
			public Toggle classicControls;

			public Toggle mouseControls;

			public Toggle casualControls;

			[Space]
			public Toggle inversePitchStandalone;

			[Header("Mobile controls UI (Leave empty if not targeting mobile):")]
			public Toggle touchControls;

			public Toggle tiltControls;

			[Space]
			public Toggle inversePitchMobile;

			private void Start()
			{
				if (ControlsPrefs.IsMouseEnabled)
				{
					if ((bool)mouseControls)
					{
						mouseControls.isOn = true;
					}
				}
				else if (ControlsPrefs.IsRollEnabled)
				{
					if ((bool)classicControls)
					{
						classicControls.isOn = true;
					}
				}
				else if ((bool)casualControls)
				{
					casualControls.isOn = true;
				}
				if ((bool)inversePitchStandalone)
				{
					inversePitchStandalone.isOn = ControlsPrefs.IsInversePitch;
				}
				if (ControlsPrefs.IsTiltEnabled)
				{
					if ((bool)tiltControls)
					{
						tiltControls.isOn = true;
					}
				}
				else if ((bool)touchControls)
				{
					touchControls.isOn = true;
				}
				if ((bool)inversePitchMobile)
				{
					inversePitchMobile.isOn = ControlsPrefs.IsInversePitch;
				}
			}

			public virtual void OnRollEnabledChanged(bool activated)
			{
				ControlsPrefs.IsRollEnabled = activated;
			}

			public virtual void OnMouseEnabledChanged(bool activated)
			{
				ControlsPrefs.IsMouseEnabled = activated;
				if (activated)
				{
					ControlsPrefs.IsRollEnabled = true;
				}
			}

			public virtual void OnInversePitchChanged(bool activated)
			{
				ControlsPrefs.IsInversePitch = activated;
			}

			public virtual void OnTiltEnabledChanged(bool activated)
			{
				ControlsPrefs.IsTiltEnabled = activated;
			}
		}
		public class CrossFadeCanvasGroups : MonoBehaviour
		{
			public CanvasGroup fromGroup;

			public CanvasGroup toGroup;

			public float speed = 1f;

			public virtual void Activate()
			{
				toGroup.gameObject.SetActive(value: true);
				toGroup.alpha = 0f;
				toGroup.interactable = true;
				fromGroup.interactable = false;
				StartCoroutine(Fader.FadeAlpha(fromGroup, fadeIn: false, speed, delegate
				{
					fromGroup.gameObject.SetActive(value: false);
				}));
				StartCoroutine(Fader.FadeAlpha(toGroup, fadeIn: true, speed));
			}
		}
		[RequireComponent(typeof(Image))]
		public class FadeInOnStart : MonoBehaviour
		{
			public bool listenToPlayEvent = true;

			public float duration = 1f;

			private void Start()
			{
				if (listenToPlayEvent)
				{
					UIEventsPublisher.OnPlayEvent += FadeIn;
				}
			}

			private void OnDestroy()
			{
				UIEventsPublisher.OnPlayEvent -= FadeIn;
			}

			public virtual void FadeIn()
			{
				Image component = GetComponent<Image>();
				if (component != null)
				{
					component.canvasRenderer.SetAlpha(0f);
					component.enabled = true;
					component.CrossFadeAlpha(1f, duration, ignoreTimeScale: false);
				}
			}
		}
		public class Fader : MonoBehaviour
		{
			public static void FadeAlpha(MonoBehaviour container, CanvasGroup group, bool fadeIn, float speed, Action onComplete = null)
			{
				if (group.gameObject.activeSelf)
				{
					container.StartCoroutine(FadeAlpha(group, fadeIn, speed, onComplete));
				}
			}

			public static IEnumerator FadeAlpha(CanvasGroup group, bool fadeIn, float speed, Action onComplete = null)
			{
				float timeLast = Time.realtimeSinceStartup;
				while ((fadeIn && group.alpha < 1f) || (!fadeIn && group.alpha > 0f))
				{
					float realtimeSinceStartup = Time.realtimeSinceStartup;
					group.alpha += (float)(fadeIn ? 1 : (-1)) * speed * (realtimeSinceStartup - timeLast);
					timeLast = realtimeSinceStartup;
					yield return null;
				}
				onComplete?.Invoke();
			}
		}
		[RequireComponent(typeof(CanvasGroup))]
		public class FuelProgressBarCircle : MonoBehaviour
		{
			public Image barFuelFull;

			public Image barFuelLow;

			[Tooltip("Normalized value where full fuel bar starts to disappear.")]
			[Space]
			public float blendStart = 0.5f;

			[Tooltip("Normalized value where full fuel bar is no longer visible at all.")]
			public float blendEnd = 0.2f;

			[Tooltip("Instead of changing fill amount of the bar, the script will change the scale.")]
			[Space]
			public bool decreaseByScaling;

			protected FuelController _fuelController;

			protected CanvasGroup _canvasGroup;

			protected bool _blinking;

			private float _blinkStartTime;

			private bool _isBlinking;

			private void Start()
			{
				_fuelController = UnityEngine.Object.FindObjectOfType<FuelController>();
				if (_fuelController == null)
				{
					UnityEngine.Debug.LogError("FuelController not found.");
					base.enabled = false;
				}
				else
				{
					_canvasGroup = GetComponent<CanvasGroup>();
					_canvasGroup.alpha = 0f;
				}
			}

			private void OnEnable()
			{
				TakeOffPublisher.OnTakeOffEvent += FadeIn;
				PauseController.OnPauseEvent += FadeOut;
				PauseController.OnUnPauseEvent += FadeIn;
				RevivePermissionProvider.OnReviveGranted += FadeIn;
				FuelController.OnFuelEmptyEvent += FadeOut;
			}

			private void OnDisable()
			{
				TakeOffPublisher.OnTakeOffEvent -= FadeIn;
				PauseController.OnPauseEvent -= FadeOut;
				PauseController.OnUnPauseEvent -= FadeIn;
				RevivePermissionProvider.OnReviveGranted -= FadeIn;
				FuelController.OnFuelEmptyEvent -= FadeOut;
			}

			private void FadeIn()
			{
				Fader.FadeAlpha(this, _canvasGroup, fadeIn: true, 1f);
			}

			private void FadeOut()
			{
				Fader.FadeAlpha(this, _canvasGroup, fadeIn: false, 1f);
			}

			private void Update()
			{
				if (decreaseByScaling)
				{
					Vector3 localScale = new Vector3(_fuelController.fuelAmount, _fuelController.fuelAmount, 1f);
					barFuelFull.rectTransform.localScale = localScale;
					barFuelLow.rectTransform.localScale = localScale;
				}
				else
				{
					barFuelFull.fillAmount = _fuelController.fuelAmount;
					barFuelLow.fillAmount = barFuelFull.fillAmount;
				}
				if (_fuelController.fuelAmount < blendStart)
				{
					float a = (_fuelController.fuelAmount - blendEnd) / (blendStart - blendEnd);
					barFuelFull.color = new Color(1f, 1f, 1f, a);
				}
				if (_fuelController.fuelAmount < 0.25f)
				{
					if (!_isBlinking)
					{
						_blinkStartTime = Time.time;
					}
					_isBlinking = true;
					_canvasGroup.alpha = Mathf.Clamp01(Mathf.Cos((Time.time - _blinkStartTime) * 10f) * 0.5f + 0.5f + 0.25f);
				}
				else
				{
					if (_isBlinking)
					{
						_canvasGroup.alpha = 1f;
					}
					_isBlinking = false;
				}
			}
		}
		[RequireComponent(typeof(CanvasGroup))]
		public class FuelProgressBarDial : MonoBehaviour
		{
			public Image barFuelFull;

			public Image barFuelLow;

			public Image dialHand;

			[Tooltip("Normalized value where full fuel bar starts to disappear.")]
			[Space]
			public float blendStart = 0.5f;

			[Tooltip("Normalized value where full fuel bar is no longer visible at all.")]
			public float blendEnd = 0.2f;

			protected FuelController _fuelController;

			protected CanvasGroup _canvasGroup;

			private float _blinkStartTime;

			private bool _isBlinking;

			private void Start()
			{
				_fuelController = UnityEngine.Object.FindObjectOfType<FuelController>();
				if (_fuelController == null)
				{
					UnityEngine.Debug.LogError("FuelController not found.");
					base.enabled = false;
				}
				else
				{
					_canvasGroup = GetComponent<CanvasGroup>();
					_canvasGroup.alpha = 0f;
				}
			}

			private void OnEnable()
			{
				TakeOffPublisher.OnTakeOffEvent += FadeIn;
				PauseController.OnPauseEvent += FadeOut;
				PauseController.OnUnPauseEvent += FadeIn;
				RevivePermissionProvider.OnReviveGranted += FadeIn;
				FuelController.OnFuelEmptyEvent += FadeOut;
			}

			private void OnDisable()
			{
				TakeOffPublisher.OnTakeOffEvent -= FadeIn;
				PauseController.OnPauseEvent -= FadeOut;
				PauseController.OnUnPauseEvent -= FadeIn;
				RevivePermissionProvider.OnReviveGranted -= FadeIn;
				FuelController.OnFuelEmptyEvent -= FadeOut;
			}

			private void FadeIn()
			{
				Fader.FadeAlpha(this, _canvasGroup, fadeIn: true, 1f);
			}

			private void FadeOut()
			{
				Fader.FadeAlpha(this, _canvasGroup, fadeIn: false, 1f);
			}

			private void Update()
			{
				float angle = (0f - _fuelController.fuelAmount) * 180f + 90f;
				dialHand.rectTransform.rotation = Quaternion.AngleAxis(angle, Vector3.forward);
				if (_fuelController.fuelAmount < blendStart)
				{
					barFuelFull.color = new Color(1f, 1f, 1f, (_fuelController.fuelAmount - blendEnd) / (blendStart - blendEnd));
				}
				if (_fuelController.fuelAmount < 0.25f)
				{
					if (Time.timeScale > 0f)
					{
						if (!_isBlinking)
						{
							_blinkStartTime = Time.time;
						}
						_isBlinking = true;
						_canvasGroup.alpha = Mathf.Clamp01(Mathf.Cos((Time.time - _blinkStartTime) * 10f) * 0.5f + 0.5f + 0.25f);
					}
				}
				else
				{
					if (_isBlinking)
					{
						_canvasGroup.alpha = 1f;
					}
					_isBlinking = false;
				}
			}
		}
		[RequireComponent(typeof(Slider))]
		public class FuelProgressBarRect : MonoBehaviour
		{
			public Image barFuelFull;

			public Image barFuelLow;

			[Tooltip("Normalized value where full fuel bar starts to disappear.")]
			[Space]
			public float blendStart = 0.5f;

			[Tooltip("Normalized value where full fuel bar is no longer visible at all.")]
			public float blendEnd = 0.2f;

			private Slider _slider;

			protected FuelController _fuelController;

			protected CanvasGroup _canvasGroup;

			private float _blinkStartTime;

			private bool _isBlinking;

			private void Start()
			{
				_fuelController = UnityEngine.Object.FindObjectOfType<FuelController>();
				if (_fuelController == null)
				{
					UnityEngine.Debug.LogError("FuelController not found.");
					base.enabled = false;
				}
				else
				{
					_canvasGroup = GetComponent<CanvasGroup>();
					_canvasGroup.alpha = 0f;
					_slider = GetComponent<Slider>();
				}
			}

			private void OnEnable()
			{
				TakeOffPublisher.OnTakeOffEvent += FadeIn;
				PauseController.OnPauseEvent += FadeOut;
				PauseController.OnUnPauseEvent += FadeIn;
				RevivePermissionProvider.OnReviveGranted += FadeIn;
				FuelController.OnFuelEmptyEvent += FadeOut;
			}

			private void OnDisable()
			{
				TakeOffPublisher.OnTakeOffEvent -= FadeIn;
				PauseController.OnPauseEvent -= FadeOut;
				PauseController.OnUnPauseEvent -= FadeIn;
				RevivePermissionProvider.OnReviveGranted -= FadeIn;
				FuelController.OnFuelEmptyEvent -= FadeOut;
			}

			private void FadeIn()
			{
				Fader.FadeAlpha(this, _canvasGroup, fadeIn: true, 1f);
			}

			private void FadeOut()
			{
				Fader.FadeAlpha(this, _canvasGroup, fadeIn: false, 1f);
			}

			private void Update()
			{
				_slider.value = _fuelController.fuelAmount;
				if (_fuelController.fuelAmount < 0.25f)
				{
					if (Time.timeScale > 0f)
					{
						if (!_isBlinking)
						{
							_blinkStartTime = Time.time;
						}
						_isBlinking = true;
						_canvasGroup.alpha = Mathf.Clamp01(Mathf.Cos((Time.time - _blinkStartTime) * 10f) * 0.5f + 0.5f + 0.25f);
					}
				}
				else
				{
					if (_isBlinking)
					{
						_canvasGroup.alpha = 1f;
					}
					_isBlinking = false;
				}
			}

			public virtual void HandleSliderValueChanged()
			{
				barFuelLow.rectTransform.anchorMax = barFuelFull.rectTransform.anchorMax;
				if (_slider.value < blendStart)
				{
					barFuelFull.color = new Color(1f, 1f, 1f, (_slider.value - blendEnd) / (blendStart - blendEnd));
				}
			}
		}
		[RequireComponent(typeof(Button))]
		public class KeyButton : MonoBehaviour
		{
			public string[] axis;

			public KeyCode[] keys;

			public Button button { get; private set; }

			private void Awake()
			{
				button = GetComponent<Button>();
			}

			private void Update()
			{
				if (!button.interactable)
				{
					return;
				}
				bool flag = false;
				string[] array = axis;
				for (int i = 0; i < array.Length; i++)
				{
					if (CrossPlatformInputManager.GetButtonDown(array[i]))
					{
						flag = true;
						break;
					}
				}
				KeyCode[] array2 = keys;
				for (int i = 0; i < array2.Length; i++)
				{
					if (Input.GetKeyDown(array2[i]))
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					button.onClick.Invoke();
				}
			}
		}
		public class MenuFadeInController : MonoBehaviour
		{
			public GameObject mainMenu;

			[Space]
			public CanvasGroup playButton;

			public CanvasGroup controlsButton;

			public Image gameLogoImage;

			public Image instructionsImage;

			private IEnumerator Start()
			{
				if (mainMenu == null)
				{
					mainMenu = GameObject.Find("MainMenu");
					if (mainMenu == null)
					{
						UnityEngine.Debug.LogError("Can't find MainMenu object in the scene.");
						yield break;
					}
				}
				mainMenu.SetActive(value: true);
				if ((bool)gameLogoImage)
				{
					gameLogoImage.enabled = false;
				}
				if ((bool)playButton)
				{
					playButton.interactable = false;
					playButton.alpha = 0f;
				}
				if ((bool)controlsButton)
				{
					controlsButton.interactable = false;
					controlsButton.alpha = 0f;
				}
				if ((bool)instructionsImage)
				{
					instructionsImage.enabled = false;
				}
				yield return new WaitForSeconds(3f);
				if ((bool)gameLogoImage)
				{
					gameLogoImage.enabled = true;
					gameLogoImage.canvasRenderer.SetAlpha(0f);
					gameLogoImage.CrossFadeAlpha(1f, 3f, ignoreTimeScale: false);
					yield return new WaitForSeconds(2f);
				}
				if ((bool)playButton)
				{
					Fader.FadeAlpha(this, playButton, fadeIn: true, 0.7f);
					playButton.interactable = true;
					yield return new WaitForSeconds(0.5f);
				}
				if ((bool)controlsButton)
				{
					Fader.FadeAlpha(this, controlsButton, fadeIn: true, 0.7f);
					controlsButton.interactable = true;
					yield return new WaitForSeconds(0.5f);
				}
				if ((bool)instructionsImage)
				{
					instructionsImage.enabled = true;
					instructionsImage.canvasRenderer.SetAlpha(0f);
					instructionsImage.CrossFadeAlpha(1f, 2.5f, ignoreTimeScale: false);
					yield return new WaitForSeconds(2f);
				}
			}
		}
		public class MenuFadeOutController : MonoBehaviour
		{
			public CanvasGroup playButton;

			public CanvasGroup controlsButton;

			public Image gameLogoImage;

			public Image instructionsImage;

			private void Start()
			{
				UIEventsPublisher.OnPlayEvent += FadeOut;
			}

			private void OnDeactivate()
			{
				UIEventsPublisher.OnPlayEvent -= FadeOut;
			}

			public virtual void FadeOut()
			{
				if ((bool)playButton)
				{
					playButton.interactable = false;
				}
				if ((bool)controlsButton)
				{
					controlsButton.interactable = false;
				}
				if ((bool)gameLogoImage)
				{
					gameLogoImage.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
				}
				if ((bool)playButton)
				{
					Fader.FadeAlpha(this, playButton, fadeIn: false, 0.35f);
				}
				if ((bool)controlsButton)
				{
					Fader.FadeAlpha(this, controlsButton, fadeIn: false, 1.5f);
				}
				if ((bool)instructionsImage)
				{
					instructionsImage.CrossFadeAlpha(0f, 2f, ignoreTimeScale: false);
				}
			}
		}
		public class MobileInputDependentContent : MonoBehaviour
		{
			private enum InputMode
			{
				StandaloneInput,
				MobileInput
			}

			[SerializeField]
			private InputMode _inputMode;

			[SerializeField]
			private GameObject[] _content = new GameObject[0];

			[SerializeField]
			private MonoBehaviour[] _monoBehaviours = new MonoBehaviour[0];

			[SerializeField]
			private bool _childrenOfThisObject;

			private void OnEnable()
			{
				CheckEnableContent();
			}

			private void CheckEnableContent()
			{
				if (_inputMode == InputMode.MobileInput)
				{
					EnableContent(enabled: true);
				}
				else
				{
					EnableContent(enabled: false);
				}
			}

			private void EnableContent(bool enabled)
			{
				if (_content.Length != 0)
				{
					GameObject[] content = _content;
					foreach (GameObject gameObject in content)
					{
						if (gameObject != null)
						{
							gameObject.SetActive(enabled);
						}
					}
				}
				if (_childrenOfThisObject)
				{
					foreach (Transform item in base.transform)
					{
						item.gameObject.SetActive(enabled);
					}
				}
				if (_monoBehaviours.Length != 0)
				{
					MonoBehaviour[] monoBehaviours = _monoBehaviours;
					for (int i = 0; i < monoBehaviours.Length; i++)
					{
						monoBehaviours[i].enabled = enabled;
					}
				}
			}
		}
		public class MobileInputUIActivator : MonoBehaviour
		{
			public GameObject[] tiltUIElements;

			public GameObject[] touchUIElements;

			private bool _isTiltUiMode;

			private void Start()
			{
				ControlsPrefs.OnTiltEnabledEvent += HandleTiltEnabled;
				ControlsPrefs.OnTiltDisabledEvent += HandleTiltDisabled;
				if (ControlsPrefs.IsTiltEnabled)
				{
					HandleTiltEnabled();
				}
				else
				{
					HandleTiltDisabled();
				}
				UIEventsPublisher.OnPlayEvent += UpdateUI;
			}

			private void OnDisable()
			{
				ControlsPrefs.OnTiltEnabledEvent -= HandleTiltEnabled;
				ControlsPrefs.OnTiltDisabledEvent -= HandleTiltDisabled;
				UIEventsPublisher.OnPlayEvent -= UpdateUI;
			}

			private void HandleTiltEnabled()
			{
				_isTiltUiMode = true;
				UpdateUI();
			}

			private void HandleTiltDisabled()
			{
				_isTiltUiMode = false;
				UpdateUI();
			}

			private void UpdateUI()
			{
				if (_isTiltUiMode)
				{
					GameObject[] array = touchUIElements;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: false);
					}
					array = tiltUIElements;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: true);
					}
				}
				else
				{
					GameObject[] array = tiltUIElements;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: false);
					}
					array = touchUIElements;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].SetActive(value: true);
					}
				}
			}
		}
		public class PauseButton : MonoBehaviour
		{
			[Header("Finds PauseController and calls Pause on click/touch.")]
			public bool active = true;

			public virtual void OnClick()
			{
				if (active)
				{
					PauseController pauseController = UnityEngine.Object.FindObjectOfType<PauseController>();
					if (pauseController != null)
					{
						pauseController.Pause();
					}
				}
			}
		}
		public class PauseController : MonoBehaviour
		{
			public delegate void OnPauseAction();

			public delegate void OnUnPauseAction();

			public bool disabled = true;

			public GameObject pausePanelObject;

			private bool _paused;

			private MusicController _musicController;

			public static event OnPauseAction OnPauseEvent;

			public static event OnUnPauseAction OnUnPauseEvent;

			private void Start()
			{
				_musicController = UnityEngine.Object.FindObjectOfType<MusicController>();
			}

			private void Update()
			{
				if (disabled || (!CrossPlatformInputManager.GetButtonDown("Cancel") && !Input.GetKeyDown(KeyCode.Escape)))
				{
					return;
				}
				if (!_paused)
				{
					if (!pausePanelObject.activeSelf)
					{
						Pause();
					}
				}
				else if (pausePanelObject.activeSelf)
				{
					Unpause();
				}
			}

			public virtual void Pause()
			{
				if (!_paused && Time.timeScale != 0f)
				{
					_paused = true;
					Time.timeScale = 0f;
					pausePanelObject.SetActive(value: true);
					if ((bool)_musicController)
					{
						_musicController.Pause();
					}
					PublishPause();
				}
			}

			public virtual void Unpause()
			{
				_paused = false;
				Time.timeScale = 1f;
				pausePanelObject.SetActive(value: false);
				if ((bool)_musicController)
				{
					_musicController.UnPause();
				}
				PublishUnPause();
			}

			public virtual void PublishPause()
			{
				if (PauseController.OnPauseEvent != null)
				{
					PauseController.OnPauseEvent();
				}
			}

			public virtual void PublishUnPause()
			{
				if (PauseController.OnUnPauseEvent != null)
				{
					PauseController.OnUnPauseEvent();
				}
			}

			public void Pause_External()
			{
				UnityEngine.Debug.Log("Publish Pause");
				_paused = true;
				Time.timeScale = 0f;
				pausePanelObject.SetActive(value: true);
				if ((bool)_musicController)
				{
					_musicController.Pause();
				}
				PublishPause();
			}

			public void UnPause_External()
			{
				UnityEngine.Debug.Log("Publish Unpause");
				_paused = false;
				Time.timeScale = 1f;
				pausePanelObject.SetActive(value: false);
				if ((bool)_musicController)
				{
					_musicController.UnPause();
				}
				PublishUnPause();
			}
		}
		public class RestartLevelButton : MonoBehaviour
		{
			public virtual void Restart()
			{
				Time.timeScale = 1f;
				SceneManager.LoadScene(SceneManager.GetActiveScene().name);
			}
		}
		public class RevivePermissionProvider : MonoBehaviour
		{
			[Tooltip("Skip all conditions and revive the user one they request it.")]
			public bool bypassAdsProvider;

			[Tooltip("Implementation of Ads Provider that will show ads, e.g. UnityAdsManager.")]
			public AbstractAdsProvider adsProvider;

			public static event GameActions.SimpleAction OnReviveRequested;

			public static event GameActions.SimpleAction OnReviveGranted;

			private void OnEnable()
			{
				OnReviveRequested += HandleReviveRequested;
			}

			private void OnDisable()
			{
				OnReviveRequested -= HandleReviveRequested;
			}

			public virtual void RequestRevive()
			{
				if (RevivePermissionProvider.OnReviveRequested != null)
				{
					RevivePermissionProvider.OnReviveRequested();
				}
			}

			public virtual void GrantRevive()
			{
				if (RevivePermissionProvider.OnReviveGranted != null)
				{
					RevivePermissionProvider.OnReviveGranted();
				}
			}

			protected virtual void HandleReviveRequested()
			{
				if (bypassAdsProvider || adsProvider == null)
				{
					StartCoroutine(ReviveNextFrame());
				}
				else
				{
					adsProvider.ShowRewardedAd(HandleShowResult);
				}
			}

			protected void HandleShowResult(AdShowResult result)
			{
				switch (result)
				{
				case AdShowResult.Finished:
					UnityEngine.Debug.Log("The ad was successfully shown.");
					GrantRevive();
					break;
				case AdShowResult.Skipped:
					UnityEngine.Debug.Log("The ad was skipped before reaching the end.");
					break;
				case AdShowResult.Failed:
					UnityEngine.Debug.LogError("The ad failed to be shown.");
					break;
				}
			}

			private IEnumerator ReviveNextFrame()
			{
				yield return new WaitForEndOfFrame();
				GrantRevive();
			}
		}
		public class SoundButton : MonoBehaviour
		{
			public virtual void TurnOff()
			{
				AudioListener.volume = 0f;
			}

			public virtual void TurnOn()
			{
				AudioListener.volume = 1f;
			}
		}
		public class UIEventsPublisher : MonoBehaviour
		{
			public static event GameActions.SimpleAction OnPlayEvent;

			public virtual void PublishPlay()
			{
				if (UIEventsPublisher.OnPlayEvent != null)
				{
					UIEventsPublisher.OnPlayEvent();
				}
			}
		}
		public class AirplaneTouchControl : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
		{
			public enum AxisOption
			{
				Both,
				OnlyHorizontal,
				OnlyVertical
			}

			public AxisOption axesToUse;

			public string horizontalAxisName = "Horizontal";

			public string verticalAxisName = "Vertical";

			public float Xsensitivity = 1f;

			public float Ysensitivity = 1f;

			[Header("Virtual joystick base to indicate steering center.")]
			public Image baseImage;

			[Header("Virtual joystick handle to indicate steering direction.")]
			public Image handleImage;

			[Header("How far can the handle move from the center of the base image.")]
			public float maxHandleDistance = 100f;

			private Vector3 m_StartPos;

			private Vector2 m_PreviousDelta;

			private Vector3 m_JoytickOutput;

			private bool m_UseX;

			private bool m_UseY;

			private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

			private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

			private bool m_Dragging;

			private int m_Id = -1;

			private Vector3 m_Center;

			private void OnEnable()
			{
				CreateVirtualAxes();
			}

			private void CreateVirtualAxes()
			{
				m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
				m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
				if (m_UseX)
				{
					m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
				}
			}

			private void UpdateVirtualAxes(Vector3 value)
			{
				if (m_UseX)
				{
					m_HorizontalVirtualAxis.Update(value.x);
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis.Update(value.y);
				}
			}

			private void Update()
			{
				if (m_Dragging && m_Dragging)
				{
					Vector3 vector = Input.touches[m_Id].position;
					Vector3 value = vector - m_Center;
					float num = Mathf.Min(value.magnitude / (maxHandleDistance + 0.01f), 1f);
					value.Normalize();
					value *= num;
					value.x *= Xsensitivity;
					value.y *= -1f * Ysensitivity;
					UpdateVirtualAxes(value);
					Vector3 localPosition = vector - m_Center;
					if (localPosition.magnitude > maxHandleDistance)
					{
						localPosition = localPosition.normalized * maxHandleDistance;
					}
					handleImage.transform.localPosition = localPosition;
				}
			}

			public void OnPointerDown(PointerEventData data)
			{
				m_Dragging = true;
				m_Id = data.pointerId;
				if (baseImage != null)
				{
					baseImage.enabled = true;
					baseImage.transform.position = data.position;
					handleImage.enabled = true;
					handleImage.transform.position = baseImage.transform.position;
				}
				m_Center = data.position;
			}

			public void OnPointerUp(PointerEventData data)
			{
				m_Dragging = false;
				m_Id = -1;
				UpdateVirtualAxes(Vector3.zero);
				if (baseImage != null)
				{
					baseImage.enabled = false;
					handleImage.enabled = false;
				}
			}

			private void OnDisable()
			{
				if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
				{
					CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
				}
				if (CrossPlatformInputManager.AxisExists(verticalAxisName))
				{
					CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
				}
			}
		}
	}
	namespace Colr
	{
		public class ScreenColorTransition : MonoBehaviour
		{
			public Color color;

			public bool fadeIn;

			[Range(0f, 10f)]
			public float duration = 1f;

			private Material material;

			private float alpha;

			private float delta;

			public void BeginFadeIn(float time, Color color)
			{
				this.color = color;
				BeginFadeIn(time);
			}

			private void Awake()
			{
				Shader shader = Shader.Find("Hidden/ScreenColorTransition");
				if (shader == null)
				{
					base.enabled = false;
					return;
				}
				material = new Material(shader);
				if (material == null)
				{
					base.enabled = false;
				}
				else if (fadeIn)
				{
					alpha = 1f;
					delta = -1f / duration;
				}
				else
				{
					alpha = 0f;
					base.enabled = false;
				}
			}

			private void Update()
			{
				alpha = Mathf.Clamp01(alpha + delta * Time.deltaTime);
				if (alpha == 0f)
				{
					base.enabled = false;
				}
			}

			public void BeginFadeOut()
			{
				delta = 1f / duration;
				base.enabled = true;
			}

			public void BeginFadeOut(float duration)
			{
				delta = 1f / duration;
				base.enabled = true;
			}

			public void BeginFadeOut(float time, Color color)
			{
				this.color = color;
				BeginFadeOut(time);
			}

			public void BeginFadeIn()
			{
				delta = -1f / duration;
				base.enabled = true;
			}

			public void BeginFadeIn(float duration)
			{
				delta = -1f / duration;
				base.enabled = true;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				material.color = color;
				material.SetFloat("_Alpha", alpha);
				Graphics.Blit(source, destination, material);
			}
		}
	}
	namespace Colorful
	{
		public sealed class MinAttribute : PropertyAttribute
		{
			public readonly float Min;

			public MinAttribute(float min)
			{
				Min = min;
			}
		}
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("")]
		public class BaseEffect : MonoBehaviour
		{
			public Shader Shader;

			protected Material m_Material;

			public Shader ShaderSafe
			{
				get
				{
					if (Shader == null)
					{
						Shader = Shader.Find(GetShaderName());
					}
					return Shader;
				}
			}

			public Material Material
			{
				get
				{
					if (m_Material == null)
					{
						m_Material = new Material(ShaderSafe);
						m_Material.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_Material;
				}
			}

			protected virtual void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					UnityEngine.Debug.LogWarning("Image effects aren't supported on this device");
					base.enabled = false;
				}
				else if (!ShaderSafe || !Shader.isSupported)
				{
					UnityEngine.Debug.LogWarning("The shader is null or unsupported on this device");
					base.enabled = false;
				}
			}

			protected virtual void OnDisable()
			{
				if ((bool)m_Material)
				{
					UnityEngine.Object.DestroyImmediate(m_Material);
				}
				m_Material = null;
			}

			public void Apply(Texture source, RenderTexture destination)
			{
				if (source is RenderTexture)
				{
					OnRenderImage(source as RenderTexture, destination);
					return;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
				Graphics.Blit(source, temporary);
				OnRenderImage(temporary, destination);
				RenderTexture.ReleaseTemporary(temporary);
			}

			protected virtual void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
			}

			protected virtual string GetShaderName()
			{
				return "null";
			}
		}
		public static class CLib
		{
			public const float PI_2 = (float)Math.PI / 2f;

			public const float PI2 = (float)Math.PI * 2f;

			public static float Frac(float f)
			{
				return f - Mathf.Floor(f);
			}

			public static bool IsLinearColorSpace()
			{
				return QualitySettings.activeColorSpace == ColorSpace.Linear;
			}

			public static bool Approximately(float source, float about, float range = 0.0001f)
			{
				return Mathf.Abs(source - about) < range;
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/analog-tv.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Analog TV")]
		public class AnalogTV : BaseEffect
		{
			[Tooltip("Automatically animate the Phase value.")]
			public bool AutomaticPhase = true;

			[Tooltip("Current noise phase. Consider this a seed value.")]
			public float Phase = 0.5f;

			[Tooltip("Convert the original render to black & white.")]
			public bool ConvertToGrayscale;

			[Range(0f, 1f)]
			[Tooltip("Noise brightness. Will impact the scanlines visibility.")]
			public float NoiseIntensity = 0.5f;

			[Range(0f, 10f)]
			[Tooltip("Scanline brightness. Depends on the NoiseIntensity value.")]
			public float ScanlinesIntensity = 2f;

			[Range(0f, 4096f)]
			[Tooltip("The number of scanlines to draw.")]
			public int ScanlinesCount = 768;

			[Tooltip("Scanline offset. Gives a cool screen scanning effect when animated.")]
			public float ScanlinesOffset;

			[Tooltip("Uses vertical scanlines.")]
			public bool VerticalScanlines;

			[Range(-2f, 2f)]
			[Tooltip("Spherical distortion factor.")]
			public float Distortion = 0.2f;

			[Range(-2f, 2f)]
			[Tooltip("Cubic distortion factor.")]
			public float CubicDistortion = 0.6f;

			[Range(0.01f, 2f)]
			[Tooltip("Helps avoid screen streching on borders when working with heavy distortions.")]
			public float Scale = 0.8f;

			protected virtual void Update()
			{
				if (AutomaticPhase)
				{
					if (Phase > 1000f)
					{
						Phase = 10f;
					}
					Phase += Time.deltaTime * 0.25f;
				}
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params1", new Vector4(NoiseIntensity, ScanlinesIntensity, ScanlinesCount, ScanlinesOffset));
				base.Material.SetVector("_Params2", new Vector4(Phase, Distortion, CubicDistortion, Scale));
				int num = (VerticalScanlines ? 2 : 0);
				num += (ConvertToGrayscale ? 1 : 0);
				Graphics.Blit(source, destination, base.Material, num);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Analog TV";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/blur-effects/bilateral-gaussian-blur.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Blur Effects/Bilateral Gaussian Blur")]
		public class BilateralGaussianBlur : BaseEffect
		{
			[Range(0f, 10f)]
			[Tooltip("Add more passes to get a smoother blur. Beware that each pass will slow down the effect.")]
			public int Passes = 1;

			[Range(0.04f, 1f)]
			[Tooltip("Adjusts the blur \"sharpness\" around edges")]
			public float Threshold = 0.05f;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void Start()
			{
				base.Start();
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetFloat("_Threshold", Threshold / 10000f);
				if (Passes == 0 || Amount == 0f)
				{
					Graphics.Blit(source, destination);
				}
				else if (Amount < 1f)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
					if (Passes == 1)
					{
						OnePassBlur(source, temporary);
					}
					else
					{
						MultiPassBlur(source, temporary);
					}
					base.Material.SetTexture("_Blurred", temporary);
					base.Material.SetFloat("_Amount", Amount);
					Graphics.Blit(source, destination, base.Material, 1);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else if (Passes == 1)
				{
					OnePassBlur(source, destination);
				}
				else
				{
					MultiPassBlur(source, destination);
				}
			}

			protected virtual void OnePassBlur(RenderTexture source, RenderTexture destination)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				base.Material.SetVector("_Direction", new Vector2(1f / (float)source.width, 0f));
				Graphics.Blit(source, temporary, base.Material, 0);
				base.Material.SetVector("_Direction", new Vector2(0f, 1f / (float)source.height));
				Graphics.Blit(temporary, destination, base.Material, 0);
				RenderTexture.ReleaseTemporary(temporary);
			}

			protected virtual void MultiPassBlur(RenderTexture source, RenderTexture destination)
			{
				Vector2 vector = new Vector2(1f / (float)source.width, 0f);
				Vector2 vector2 = new Vector2(0f, 1f / (float)source.height);
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
				base.Material.SetVector("_Direction", vector);
				Graphics.Blit(source, temporary, base.Material, 0);
				base.Material.SetVector("_Direction", vector2);
				Graphics.Blit(temporary, temporary2, base.Material, 0);
				temporary.DiscardContents();
				for (int i = 1; i < Passes; i++)
				{
					base.Material.SetVector("_Direction", vector);
					Graphics.Blit(temporary2, temporary, base.Material, 0);
					temporary2.DiscardContents();
					base.Material.SetVector("_Direction", vector2);
					Graphics.Blit(temporary, temporary2, base.Material, 0);
					temporary.DiscardContents();
				}
				Graphics.Blit(temporary2, destination);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Bilateral Gaussian Blur";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/bleach-bypass.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Bleach Bypass")]
		public class BleachBypass : BaseEffect
		{
			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Bleach Bypass";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/blend.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/Blend")]
		public class Blend : BaseEffect
		{
			public enum BlendingMode
			{
				Darken = 0,
				Multiply = 1,
				ColorBurn = 2,
				LinearBurn = 3,
				DarkerColor = 4,
				Lighten = 6,
				Screen = 7,
				ColorDodge = 8,
				LinearDodge = 9,
				LighterColor = 10,
				Overlay = 12,
				SoftLight = 13,
				HardLight = 14,
				VividLight = 15,
				LinearLight = 16,
				PinLight = 17,
				HardMix = 18,
				Difference = 20,
				Exclusion = 21,
				Subtract = 22,
				Divide = 23
			}

			[Tooltip("The Texture2D, RenderTexture or MovieTexture to blend.")]
			public Texture Texture;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			[Tooltip("Blending mode.")]
			public BlendingMode Mode;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Texture == null || Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetTexture("_OverlayTex", Texture);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Blend";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/brightness-contrast-gamma.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Brightness, Contrast, Gamma")]
		public class BrightnessContrastGamma : BaseEffect
		{
			[Range(-100f, 100f)]
			[Tooltip("Moving the slider to the right increases tonal values and expands highlights, to the left decreases values and expands shadows.")]
			public float Brightness;

			[Range(-100f, 100f)]
			[Tooltip("Expands or shrinks the overall range of tonal values.")]
			public float Contrast;

			public Vector3 ContrastCoeff = new Vector3(0.5f, 0.5f, 0.5f);

			[Range(0.1f, 9.9f)]
			[Tooltip("Simple power function.")]
			public float Gamma = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Brightness == 0f && Contrast == 0f && Gamma == 1f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_BCG", new Vector4((Brightness + 100f) * 0.01f, (Contrast + 100f) * 0.01f, 1f / Gamma));
				base.Material.SetVector("_Coeffs", ContrastCoeff);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Brightness Contrast Gamma";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/channel-clamper.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Channel Clamper")]
		public class ChannelClamper : BaseEffect
		{
			public Vector2 Red = new Vector2(0f, 1f);

			public Vector2 Green = new Vector2(0f, 1f);

			public Vector2 Blue = new Vector2(0f, 1f);

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_RedClamp", Red);
				base.Material.SetVector("_GreenClamp", Green);
				base.Material.SetVector("_BlueClamp", Blue);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Channel Clamper";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/channel-mixer.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Channel Mixer")]
		public class ChannelMixer : BaseEffect
		{
			public Vector3 Red = new Vector3(100f, 0f, 0f);

			public Vector3 Green = new Vector3(0f, 100f, 0f);

			public Vector3 Blue = new Vector3(0f, 0f, 100f);

			public Vector3 Constant = new Vector3(0f, 0f, 0f);

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Red", new Vector4(Red.x * 0.01f, Green.x * 0.01f, Blue.x * 0.01f));
				base.Material.SetVector("_Green", new Vector4(Red.y * 0.01f, Green.y * 0.01f, Blue.y * 0.01f));
				base.Material.SetVector("_Blue", new Vector4(Red.z * 0.01f, Green.z * 0.01f, Blue.z * 0.01f));
				base.Material.SetVector("_Constant", new Vector4(Constant.x * 0.01f, Constant.y * 0.01f, Constant.z * 0.01f));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Channel Mixer";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/channel-swapper.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Channel Swapper")]
		public class ChannelSwapper : BaseEffect
		{
			public enum Channel
			{
				Red,
				Green,
				Blue
			}

			[Tooltip("Source channel to use for the output red channel.")]
			public Channel RedSource;

			[Tooltip("Source channel to use for the output green channel.")]
			public Channel GreenSource = Channel.Green;

			[Tooltip("Source channel to use for the output blue channel.")]
			public Channel BlueSource = Channel.Blue;

			private static Vector4[] m_Channels = new Vector4[3]
			{
				new Vector4(1f, 0f, 0f, 0f),
				new Vector4(0f, 1f, 0f, 0f),
				new Vector4(0f, 0f, 1f, 0f)
			};

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Red", m_Channels[(int)RedSource]);
				base.Material.SetVector("_Green", m_Channels[(int)GreenSource]);
				base.Material.SetVector("_Blue", m_Channels[(int)BlueSource]);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Channel Swapper";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/chromatic-aberration.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Chromatic Aberration")]
		public class ChromaticAberration : BaseEffect
		{
			[Range(0.9f, 1.1f)]
			[Tooltip("Indice of refraction for the red channel.")]
			public float RedRefraction = 1f;

			[Range(0.9f, 1.1f)]
			[Tooltip("Indice of refraction for the green channel.")]
			public float GreenRefraction = 1.005f;

			[Range(0.9f, 1.1f)]
			[Tooltip("Indice of refraction for the blue channel.")]
			public float BlueRefraction = 1.01f;

			[Tooltip("Enable this option if you need the effect to keep the alpha channel from the original render (some effects like Glow will need it). Disable it otherwise for better performances.")]
			public bool PreserveAlpha;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Refraction", new Vector3(RedRefraction, GreenRefraction, BlueRefraction));
				Graphics.Blit(source, destination, base.Material, PreserveAlpha ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Chromatic Aberration";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/comic-book.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/Comic Book")]
		public class ComicBook : BaseEffect
		{
			[Tooltip("Strip orientation in radians.")]
			public float StripAngle = 0.6f;

			[Min(0f)]
			[Tooltip("Amount of strips to draw.")]
			public float StripDensity = 180f;

			[Range(0f, 1f)]
			[Tooltip("Thickness of the inner strip fill.")]
			public float StripThickness = 0.5f;

			public Vector2 StripLimits = new Vector2(0.25f, 0.4f);

			[ColorUsage(false)]
			public Color StripInnerColor = new Color(0.3f, 0.3f, 0.3f);

			[ColorUsage(false)]
			public Color StripOuterColor = new Color(0.8f, 0.8f, 0.8f);

			[ColorUsage(false)]
			public Color FillColor = new Color(0.1f, 0.1f, 0.1f);

			[ColorUsage(false)]
			public Color BackgroundColor = Color.white;

			[Tooltip("Toggle edge detection (slower).")]
			public bool EdgeDetection;

			[Min(0.01f)]
			[Tooltip("Edge detection threshold. Use lower values for more visible edges.")]
			public float EdgeThreshold = 5f;

			[ColorUsage(false)]
			public Color EdgeColor = Color.black;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_StripParams", new Vector4(Mathf.Cos(StripAngle), Mathf.Sin(StripAngle), StripLimits.x, StripLimits.y));
				base.Material.SetVector("_StripParams2", new Vector3(StripDensity * 10f, StripThickness, Amount));
				base.Material.SetColor("_StripInnerColor", StripInnerColor);
				base.Material.SetColor("_StripOuterColor", StripOuterColor);
				base.Material.SetColor("_FillColor", FillColor);
				base.Material.SetColor("_BackgroundColor", BackgroundColor);
				if (EdgeDetection)
				{
					base.Material.SetFloat("_EdgeThreshold", 1f / (EdgeThreshold * 100f));
					base.Material.SetColor("_EdgeColor", EdgeColor);
					Graphics.Blit(source, destination, base.Material, 1);
				}
				else
				{
					Graphics.Blit(source, destination, base.Material, 0);
				}
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Comic Book";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/contrast-gain.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Contrast Gain")]
		public class ContrastGain : BaseEffect
		{
			[Range(0.001f, 2f)]
			[Tooltip("Steepness of the contrast curve. 1 is linear, no contrast change.")]
			public float Gain = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetFloat("_Gain", Gain);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Contrast Gain";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/contrast-vignette.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Contrast Vignette")]
		public class ContrastVignette : BaseEffect
		{
			[Tooltip("Center point.")]
			public Vector2 Center = new Vector2(0.5f, 0.5f);

			[Range(-100f, 100f)]
			[Tooltip("Smoothness of the vignette effect.")]
			public float Sharpness = 32f;

			[Range(0f, 100f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float Darkness = 28f;

			[Range(0f, 200f)]
			[Tooltip("Expands or shrinks the overall range of tonal values in the vignette area.")]
			public float Contrast = 20f;

			public Vector3 ContrastCoeff = new Vector3(0.5f, 0.5f, 0.5f);

			[Range(0f, 200f)]
			[Tooltip("Blends the contrast change toward the edges of the vignette effect.")]
			public float EdgeBlending;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params", new Vector4(Sharpness * 0.01f, Darkness * 0.02f, Contrast * 0.01f, EdgeBlending * 0.01f));
				base.Material.SetVector("_Coeffs", ContrastCoeff);
				base.Material.SetVector("_Center", Center);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Contrast Vignette";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/convolution-3x3.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/Convolution Matrix 3x3")]
		public class Convolution3x3 : BaseEffect
		{
			public Vector3 KernelTop = Vector3.zero;

			public Vector3 KernelMiddle = Vector3.up;

			public Vector3 KernelBottom = Vector3.zero;

			[Tooltip("Used to normalize the kernel.")]
			public float Divisor = 1f;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_PSize", new Vector2(1f / (float)source.width, 1f / (float)source.height));
				base.Material.SetVector("_KernelT", KernelTop / Divisor);
				base.Material.SetVector("_KernelM", KernelMiddle / Divisor);
				base.Material.SetVector("_KernelB", KernelBottom / Divisor);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Convolution 3x3";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/cross-stitch.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/Cross Stitch")]
		public class CrossStitch : BaseEffect
		{
			[Range(1f, 128f)]
			[Tooltip("Works best with power of two values.")]
			public int Size = 8;

			[Range(0f, 10f)]
			[Tooltip("Brightness adjustment. Cross-stitching tends to lower the overall brightness, use this to compensate.")]
			public float Brightness = 1.5f;

			[Tooltip("Inverts the cross-stiching pattern.")]
			public bool Invert;

			[Tooltip("Should the original render be pixelized ?")]
			public bool Pixelize = true;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetInt("_StitchSize", Size);
				base.Material.SetFloat("_Brightness", Brightness);
				int num = (Invert ? 1 : 0);
				if (Pixelize)
				{
					num += 2;
					base.Material.SetFloat("_Scale", (float)source.width / (float)Size);
					base.Material.SetFloat("_Ratio", (float)source.width / (float)source.height);
				}
				Graphics.Blit(source, destination, base.Material, num);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Cross Stitch";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/blur-effects/directional-blur.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Blur Effects/Directional Blur")]
		public class DirectionalBlur : BaseEffect
		{
			public enum QualityPreset
			{
				Low = 2,
				Medium = 4,
				High = 6,
				Custom = 7
			}

			[Tooltip("Quality preset. Higher means better quality but slower processing.")]
			public QualityPreset Quality = QualityPreset.Medium;

			[Range(1f, 16f)]
			[Tooltip("Sample count. Higher means better quality but slower processing.")]
			public int Samples = 5;

			[Range(0f, 5f)]
			[Tooltip("Blur strength (distance).")]
			public float Strength = 1f;

			[Tooltip("Blur direction in radians.")]
			public float Angle;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				int num = ((Quality == QualityPreset.Custom) ? Samples : ((int)Quality));
				float x = Mathf.Sin(Angle) * Strength * 0.05f / (float)num;
				float y = Mathf.Cos(Angle) * Strength * 0.05f / (float)num;
				base.Material.SetVector("_Params", new Vector3(x, y, num));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/DirectionalBlur";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/dithering.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/Dithering")]
		public class Dithering : BaseEffect
		{
			[Tooltip("Show the original picture under the dithering pass.")]
			public bool ShowOriginal;

			[Tooltip("Convert the original render to black & white.")]
			public bool ConvertToGrayscale;

			[Range(0f, 1f)]
			[Tooltip("Amount of red to contribute to the luminosity.")]
			public float RedLuminance = 0.299f;

			[Range(0f, 1f)]
			[Tooltip("Amount of green to contribute to the luminosity.")]
			public float GreenLuminance = 0.587f;

			[Range(0f, 1f)]
			[Tooltip("Amount of blue to contribute to the luminosity.")]
			public float BlueLuminance = 0.114f;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected Texture2D m_DitherPattern;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (m_DitherPattern == null)
				{
					m_DitherPattern = Resources.Load<Texture2D>("Misc/DitherPattern");
				}
				base.Material.SetTexture("_Pattern", m_DitherPattern);
				base.Material.SetVector("_Params", new Vector4(RedLuminance, GreenLuminance, BlueLuminance, Amount));
				int num = (ShowOriginal ? 4 : 0);
				num += (ConvertToGrayscale ? 2 : 0);
				num += (CLib.IsLinearColorSpace() ? 1 : 0);
				Graphics.Blit(source, destination, base.Material, num);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Dithering";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/double-vision.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Double Vision")]
		public class DoubleVision : BaseEffect
		{
			[Tooltip("Diploplia strength.")]
			public Vector2 Displace = new Vector2(0.7f, 0f);

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f || Displace == Vector2.zero)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Displace", new Vector2(Displace.x / (float)source.width, Displace.y / (float)source.height));
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Double Vision";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/dynamic-lookup.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Dynamic Lookup")]
		public class DynamicLookup : BaseEffect
		{
			[ColorUsage(false)]
			public Color White = new Color(1f, 1f, 1f);

			[ColorUsage(false)]
			public Color Black = new Color(0f, 0f, 0f);

			[ColorUsage(false)]
			public Color Red = new Color(1f, 0f, 0f);

			[ColorUsage(false)]
			public Color Green = new Color(0f, 1f, 0f);

			[ColorUsage(false)]
			public Color Blue = new Color(0f, 0f, 1f);

			[ColorUsage(false)]
			public Color Yellow = new Color(1f, 1f, 0f);

			[ColorUsage(false)]
			public Color Magenta = new Color(1f, 0f, 1f);

			[ColorUsage(false)]
			public Color Cyan = new Color(0f, 1f, 1f);

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetColor("_White", White);
				base.Material.SetColor("_Black", Black);
				base.Material.SetColor("_Red", Red);
				base.Material.SetColor("_Green", Green);
				base.Material.SetColor("_Blue", Blue);
				base.Material.SetColor("_Yellow", Yellow);
				base.Material.SetColor("_Magenta", Magenta);
				base.Material.SetColor("_Cyan", Cyan);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material, CLib.IsLinearColorSpace() ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/DynamicLookup";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/fast-vignette.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Fast Vignette")]
		public class FastVignette : BaseEffect
		{
			public enum ColorMode
			{
				Classic,
				Desaturate,
				Colored
			}

			[Tooltip("Vignette type.")]
			public ColorMode Mode;

			[ColorUsage(false)]
			[Tooltip("The color to use in the vignette area.")]
			public Color Color = Color.red;

			[Tooltip("Center point.")]
			public Vector2 Center = new Vector2(0.5f, 0.5f);

			[Range(-100f, 100f)]
			[Tooltip("Smoothness of the vignette effect.")]
			public float Sharpness = 10f;

			[Range(0f, 100f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float Darkness = 30f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params", new Vector4(Center.x, Center.y, Sharpness * 0.01f, Darkness * 0.02f));
				base.Material.SetColor("_Color", Color);
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Fast Vignette";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/frost.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Frost")]
		public class Frost : BaseEffect
		{
			[Range(0f, 16f)]
			[Tooltip("Frosting strength.")]
			public float Scale = 1.2f;

			[Range(-100f, 100f)]
			[Tooltip("Smoothness of the vignette effect.")]
			public float Sharpness = 40f;

			[Range(0f, 100f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float Darkness = 35f;

			[Tooltip("Should the effect be applied like a vignette ?")]
			public bool EnableVignette = true;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Scale <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetFloat("_Scale", Scale);
				if (EnableVignette)
				{
					base.Material.SetFloat("_Sharpness", Sharpness * 0.01f);
					base.Material.SetFloat("_Darkness", Darkness * 0.02f);
				}
				Graphics.Blit(source, destination, base.Material, EnableVignette ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Frost";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/blur-effects/gaussian-blur.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Blur Effects/Gaussian Blur")]
		public class GaussianBlur : BaseEffect
		{
			[Range(0f, 10f)]
			[Tooltip("Amount of blurring pass to apply.")]
			public int Passes = 1;

			[Range(1f, 16f)]
			[Tooltip("Downscales the result for faster processing or heavier blur.")]
			public float Downscaling = 1f;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Passes == 0 || Amount == 0f)
				{
					Graphics.Blit(source, destination);
				}
				else if (Amount < 1f)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
					if (Passes == 1)
					{
						OnePassBlur(source, temporary);
					}
					else
					{
						MultiPassBlur(source, temporary);
					}
					base.Material.SetTexture("_Blurred", temporary);
					base.Material.SetFloat("_Amount", Amount);
					Graphics.Blit(source, destination, base.Material, 1);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else if (Passes == 1)
				{
					OnePassBlur(source, destination);
				}
				else
				{
					MultiPassBlur(source, destination);
				}
			}

			protected virtual void OnePassBlur(RenderTexture source, RenderTexture destination)
			{
				int num = Mathf.FloorToInt((float)source.width / Downscaling);
				int num2 = Mathf.FloorToInt((float)source.height / Downscaling);
				RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, source.format);
				base.Material.SetVector("_Direction", new Vector2(1f / (float)num, 0f));
				Graphics.Blit(source, temporary, base.Material, 0);
				base.Material.SetVector("_Direction", new Vector2(0f, 1f / (float)num2));
				Graphics.Blit(temporary, destination, base.Material, 0);
				RenderTexture.ReleaseTemporary(temporary);
			}

			protected virtual void MultiPassBlur(RenderTexture source, RenderTexture destination)
			{
				int num = Mathf.FloorToInt((float)source.width / Downscaling);
				int num2 = Mathf.FloorToInt((float)source.height / Downscaling);
				Vector2 vector = new Vector2(1f / (float)num, 0f);
				Vector2 vector2 = new Vector2(0f, 1f / (float)num2);
				RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, source.format);
				RenderTexture temporary2 = RenderTexture.GetTemporary(num, num2, 0, source.format);
				base.Material.SetVector("_Direction", vector);
				Graphics.Blit(source, temporary, base.Material, 0);
				base.Material.SetVector("_Direction", vector2);
				Graphics.Blit(temporary, temporary2, base.Material, 0);
				temporary.DiscardContents();
				for (int i = 1; i < Passes; i++)
				{
					base.Material.SetVector("_Direction", vector);
					Graphics.Blit(temporary2, temporary, base.Material, 0);
					temporary2.DiscardContents();
					base.Material.SetVector("_Direction", vector2);
					Graphics.Blit(temporary, temporary2, base.Material, 0);
					temporary.DiscardContents();
				}
				Graphics.Blit(temporary2, destination);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Gaussian Blur";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/glitch.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Glitch")]
		public class Glitch : BaseEffect
		{
			public enum GlitchingMode
			{
				Interferences,
				Tearing,
				Complete
			}

			[Serializable]
			public class InterferenceSettings
			{
				public float Speed = 10f;

				public float Density = 8f;

				public float MaxDisplacement = 2f;
			}

			[Serializable]
			public class TearingSettings
			{
				public float Speed = 1f;

				[Range(0f, 1f)]
				public float Intensity = 0.25f;

				[Range(0f, 0.5f)]
				public float MaxDisplacement = 0.05f;

				public bool AllowFlipping;

				public bool YuvColorBleeding = true;

				[Range(-2f, 2f)]
				public float YuvOffset = 0.5f;
			}

			[Tooltip("Automatically activate/deactivate the effect randomly.")]
			public bool RandomActivation;

			public Vector2 RandomEvery = new Vector2(1f, 2f);

			public Vector2 RandomDuration = new Vector2(1f, 2f);

			[Tooltip("Glitch type.")]
			public GlitchingMode Mode;

			public InterferenceSettings SettingsInterferences = new InterferenceSettings();

			public TearingSettings SettingsTearing = new TearingSettings();

			protected bool m_Activated = true;

			protected float m_EveryTimer;

			protected float m_EveryTimerEnd;

			protected float m_DurationTimer;

			protected float m_DurationTimerEnd;

			public bool IsActive => m_Activated;

			protected override void Start()
			{
				base.Start();
				m_DurationTimerEnd = UnityEngine.Random.Range(RandomDuration.x, RandomDuration.y);
			}

			protected virtual void Update()
			{
				if (!RandomActivation)
				{
					return;
				}
				if (m_Activated)
				{
					m_DurationTimer += Time.deltaTime;
					if (m_DurationTimer >= m_DurationTimerEnd)
					{
						m_DurationTimer = 0f;
						m_Activated = false;
						m_EveryTimerEnd = UnityEngine.Random.Range(RandomEvery.x, RandomEvery.y);
					}
				}
				else
				{
					m_EveryTimer += Time.deltaTime;
					if (m_EveryTimer >= m_EveryTimerEnd)
					{
						m_EveryTimer = 0f;
						m_Activated = true;
						m_DurationTimerEnd = UnityEngine.Random.Range(RandomDuration.x, RandomDuration.y);
					}
				}
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!m_Activated)
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (Mode == GlitchingMode.Interferences)
				{
					DoInterferences(source, destination, SettingsInterferences);
					return;
				}
				if (Mode == GlitchingMode.Tearing)
				{
					DoTearing(source, destination, SettingsTearing);
					return;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.width, 0, RenderTextureFormat.ARGB32);
				DoTearing(source, temporary, SettingsTearing);
				DoInterferences(temporary, destination, SettingsInterferences);
				temporary.Release();
			}

			protected virtual void DoInterferences(RenderTexture source, RenderTexture destination, InterferenceSettings settings)
			{
				base.Material.SetVector("_Params", new Vector3(settings.Speed, settings.Density, settings.MaxDisplacement));
				Graphics.Blit(source, destination, base.Material, 0);
			}

			protected virtual void DoTearing(RenderTexture source, RenderTexture destination, TearingSettings settings)
			{
				base.Material.SetVector("_Params", new Vector4(settings.Speed, settings.Intensity, settings.MaxDisplacement, settings.YuvOffset));
				int pass = 1;
				if (settings.AllowFlipping && settings.YuvColorBleeding)
				{
					pass = 4;
				}
				else if (settings.AllowFlipping)
				{
					pass = 2;
				}
				else if (settings.YuvColorBleeding)
				{
					pass = 3;
				}
				Graphics.Blit(source, destination, base.Material, pass);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Glitch";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/gradient-ramp.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Gradient Ramp")]
		public class GradientRamp : BaseEffect
		{
			[Tooltip("Texture used to remap the pixels luminosity.")]
			public Texture RampTexture;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (RampTexture == null || Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetTexture("_RampTex", RampTexture);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Gradient Ramp";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/gradient-ramp-dynamic.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Gradient Ramp (Dynamic)")]
		public class GradientRampDynamic : BaseEffect
		{
			[Tooltip("Gradient used to remap the pixels luminosity.")]
			public Gradient Ramp;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected Texture2D m_RampTexture;

			protected override void Start()
			{
				base.Start();
				if (Ramp != null)
				{
					UpdateGradientCache();
				}
			}

			protected virtual void Reset()
			{
				Ramp = new Gradient();
				Ramp.colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.black, 0f),
					new GradientColorKey(Color.white, 1f)
				};
				Ramp.alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(1f, 0f),
					new GradientAlphaKey(1f, 1f)
				};
				UpdateGradientCache();
			}

			public void UpdateGradientCache()
			{
				if (m_RampTexture == null)
				{
					m_RampTexture = new Texture2D(256, 1, TextureFormat.RGB24, mipChain: false);
					m_RampTexture.filterMode = FilterMode.Bilinear;
					m_RampTexture.wrapMode = TextureWrapMode.Clamp;
					m_RampTexture.hideFlags = HideFlags.HideAndDontSave;
				}
				Color[] array = new Color[256];
				for (int i = 0; i < 256; i++)
				{
					array[i] = Ramp.Evaluate((float)i / 255f);
				}
				m_RampTexture.SetPixels(array);
				m_RampTexture.Apply();
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Ramp == null || Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetTexture("_RampTex", m_RampTexture);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Gradient Ramp";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/blur-effects/grainy-blur.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Blur Effects/Grainy Blur")]
		public class GrainyBlur : BaseEffect
		{
			[Min(0f)]
			[Tooltip("Blur radius.")]
			public float Radius = 32f;

			[Range(1f, 32f)]
			[Tooltip("Sample count. Higher means better quality but slower processing.")]
			public int Samples = 16;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (CLib.Approximately(Radius, 0f, 0.001f))
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Params", new Vector2(Radius, Samples));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/GrainyBlur";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/grayscale.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Grayscale")]
		public class Grayscale : BaseEffect
		{
			[Range(0f, 1f)]
			[Tooltip("Amount of red to contribute to the luminosity.")]
			public float RedLuminance = 0.299f;

			[Range(0f, 1f)]
			[Tooltip("Amount of green to contribute to the luminosity.")]
			public float GreenLuminance = 0.587f;

			[Range(0f, 1f)]
			[Tooltip("Amount of blue to contribute to the luminosity.")]
			public float BlueLuminance = 0.114f;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Params", new Vector4(RedLuminance, GreenLuminance, BlueLuminance, Amount));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Grayscale";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/halftone.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/Halftone")]
		public class Halftone : BaseEffect
		{
			[Min(0f)]
			[Tooltip("Global haltfoning scale.")]
			public float Scale = 12f;

			[Min(0f)]
			[Tooltip("Individual dot size.")]
			public float DotSize = 1.35f;

			[Tooltip("Rotates the dot placement according to the Center point.")]
			public float Angle = 1.2f;

			[Range(0f, 1f)]
			[Tooltip("Dots antialiasing")]
			public float Smoothness = 0.08f;

			[Tooltip("Center point to use for the rotation.")]
			public Vector2 Center = new Vector2(0.5f, 0.5f);

			[Tooltip("Turns the effect black & white.")]
			public bool Desaturate;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Center", new Vector2(Center.x * (float)source.width, Center.y * (float)source.height));
				base.Material.SetVector("_Params", new Vector3(Scale, DotSize, Smoothness));
				Matrix4x4 value = default(Matrix4x4);
				value.SetRow(0, CMYKRot(Angle + (float)Math.PI / 12f));
				value.SetRow(1, CMYKRot(Angle + 1.3089969f));
				value.SetRow(2, CMYKRot(Angle));
				value.SetRow(3, CMYKRot(Angle + (float)Math.PI / 4f));
				base.Material.SetMatrix("_MatRot", value);
				Graphics.Blit(source, destination, base.Material, Desaturate ? 1 : 0);
			}

			private Vector4 CMYKRot(float angle)
			{
				float num = Mathf.Cos(angle);
				float num2 = Mathf.Sin(angle);
				return new Vector4(num, 0f - num2, num2, num);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Halftone";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/utilities/histogram.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Utilities/Histogram")]
		public class Histogram : MonoBehaviour
		{
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/hue-focus.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Hue Focus")]
		public class HueFocus : BaseEffect
		{
			[Range(0f, 360f)]
			[Tooltip("Center hue.")]
			public float Hue;

			[Range(1f, 180f)]
			[Tooltip("Hue range to focus on.")]
			public float Range = 30f;

			[Range(0f, 1f)]
			[Tooltip("Makes the colored pixels more vibrant.")]
			public float Boost = 0.5f;

			[Range(0f, 1f)]
			[Tooltip("Blending Factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				float num = Hue / 360f;
				float num2 = Range / 180f;
				base.Material.SetVector("_Range", new Vector2(num - num2, num + num2));
				base.Material.SetVector("_Params", new Vector3(num, Boost + 1f, Amount));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Hue Focus";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/hue-saturation-value.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Hue, Saturation, Value")]
		public class HueSaturationValue : BaseEffect
		{
			[Range(-180f, 180f)]
			public float MasterHue;

			[Range(-100f, 100f)]
			public float MasterSaturation;

			[Range(-100f, 100f)]
			public float MasterValue;

			[Range(-180f, 180f)]
			public float RedsHue;

			[Range(-100f, 100f)]
			public float RedsSaturation;

			[Range(-100f, 100f)]
			public float RedsValue;

			[Range(-180f, 180f)]
			public float YellowsHue;

			[Range(-100f, 100f)]
			public float YellowsSaturation;

			[Range(-100f, 100f)]
			public float YellowsValue;

			[Range(-180f, 180f)]
			public float GreensHue;

			[Range(-100f, 100f)]
			public float GreensSaturation;

			[Range(-100f, 100f)]
			public float GreensValue;

			[Range(-180f, 180f)]
			public float CyansHue;

			[Range(-100f, 100f)]
			public float CyansSaturation;

			[Range(-100f, 100f)]
			public float CyansValue;

			[Range(-180f, 180f)]
			public float BluesHue;

			[Range(-100f, 100f)]
			public float BluesSaturation;

			[Range(-100f, 100f)]
			public float BluesValue;

			[Range(-180f, 180f)]
			public float MagentasHue;

			[Range(-100f, 100f)]
			public float MagentasSaturation;

			[Range(-100f, 100f)]
			public float MagentasValue;

			public bool AdvancedMode;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Master", new Vector3(MasterHue / 360f, (MasterSaturation + 100f) * 0.01f, (MasterValue + 100f) * 0.01f));
				if (AdvancedMode)
				{
					base.Material.SetVector("_Reds", new Vector3(RedsHue / 360f, (RedsSaturation + 100f) * 0.01f, (RedsValue + 100f) * 0.01f));
					base.Material.SetVector("_Yellows", new Vector3(YellowsHue / 360f, (YellowsSaturation + 100f) * 0.01f, (YellowsValue + 100f) * 0.01f));
					base.Material.SetVector("_Greens", new Vector3(GreensHue / 360f, (GreensSaturation + 100f) * 0.01f, (GreensValue + 100f) * 0.01f));
					base.Material.SetVector("_Cyans", new Vector3(CyansHue / 360f, (CyansSaturation + 100f) * 0.01f, (CyansValue + 100f) * 0.01f));
					base.Material.SetVector("_Blues", new Vector3(BluesHue / 360f, (BluesSaturation + 100f) * 0.01f, (BluesValue + 100f) * 0.01f));
					base.Material.SetVector("_Magentas", new Vector3(MagentasHue / 360f, (MagentasSaturation + 100f) * 0.01f, (MagentasValue + 100f) * 0.01f));
					Graphics.Blit(source, destination, base.Material, 1);
				}
				else
				{
					Graphics.Blit(source, destination, base.Material, 0);
				}
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Hue Saturation Value";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/kuwahara.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/Kuwahara")]
		public class Kuwahara : BaseEffect
		{
			[Range(1f, 6f)]
			[Tooltip("Larger radius will give a more abstract look but will lower performances.")]
			public int Radius = 3;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				Radius = Mathf.Clamp(Radius, 1, 6);
				base.Material.SetVector("_PSize", new Vector2(1f / (float)source.width, 1f / (float)source.height));
				Graphics.Blit(source, destination, base.Material, Radius - 1);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Kuwahara";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/led.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/LED")]
		public class Led : BaseEffect
		{
			public enum SizeMode
			{
				ResolutionIndependent,
				PixelPerfect
			}

			[Range(1f, 255f)]
			[Tooltip("Scale of an individual LED. Depends on the Mode used.")]
			public float Scale = 80f;

			[Range(0f, 10f)]
			[Tooltip("LED brightness booster.")]
			public float Brightness = 1f;

			[Range(1f, 3f)]
			[Tooltip("LED shape, from softer to harsher.")]
			public float Shape = 1.5f;

			[Tooltip("Turn this on to automatically compute the aspect ratio needed for squared LED.")]
			public bool AutomaticRatio = true;

			[Tooltip("Custom aspect ratio.")]
			public float Ratio = 1f;

			[Tooltip("Used for the Scale field.")]
			public SizeMode Mode;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				float x = Scale;
				if (Mode == SizeMode.PixelPerfect)
				{
					x = (float)source.width / Scale;
				}
				base.Material.SetVector("_Params", new Vector4(x, AutomaticRatio ? ((float)source.width / (float)source.height) : Ratio, Brightness, Shape));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Led";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/blur-effects/lens-distortion-blur.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Blur Effects/Lens Distortion Blur")]
		public class LensDistortionBlur : BaseEffect
		{
			public enum QualityPreset
			{
				Low = 4,
				Medium = 8,
				High = 12,
				Custom = 13
			}

			[Tooltip("Quality preset. Higher means better quality but slower processing.")]
			public QualityPreset Quality = QualityPreset.Medium;

			[Range(2f, 32f)]
			[Tooltip("Sample count. Higher means better quality but slower processing.")]
			public int Samples = 10;

			[Range(-2f, 2f)]
			[Tooltip("Spherical distortion factor.")]
			public float Distortion = 0.2f;

			[Range(-2f, 2f)]
			[Tooltip("Cubic distortion factor.")]
			public float CubicDistortion = 0.6f;

			[Range(0.01f, 2f)]
			[Tooltip("Helps avoid screen streching on borders when working with heavy distortions.")]
			public float Scale = 0.8f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				int num = ((Quality == QualityPreset.Custom) ? Samples : ((int)Quality));
				base.Material.SetVector("_Params", new Vector4(num, Distortion / (float)num, CubicDistortion / (float)num, Scale));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/LensDistortionBlur";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/letterbox.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Letterbox")]
		public class Letterbox : BaseEffect
		{
			[Min(0f)]
			[Tooltip("Crop the screen to the given aspect ratio.")]
			public float Aspect = 2.3333333f;

			[Tooltip("Letter/Pillar box color. Alpha is transparency.")]
			public Color FillColor = Color.black;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				float num = source.width;
				float num2 = source.height;
				float num3 = num / num2;
				float num4 = 0f;
				int pass = 0;
				base.Material.SetColor("_FillColor", FillColor);
				if (num3 < Aspect)
				{
					num4 = (num2 - num / Aspect) * 0.5f / num2;
				}
				else
				{
					if (!(num3 > Aspect))
					{
						Graphics.Blit(source, destination);
						return;
					}
					num4 = (num - num2 * Aspect) * 0.5f / num;
					pass = 1;
				}
				base.Material.SetVector("_Offsets", new Vector2(num4, 1f - num4));
				Graphics.Blit(source, destination, base.Material, pass);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Letterbox";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/levels.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Levels")]
		public class Levels : BaseEffect
		{
			public enum ColorMode
			{
				Monochrome,
				RGB
			}

			public ColorMode Mode;

			public Vector3 InputL = new Vector3(0f, 255f, 1f);

			public Vector3 InputR = new Vector3(0f, 255f, 1f);

			public Vector3 InputG = new Vector3(0f, 255f, 1f);

			public Vector3 InputB = new Vector3(0f, 255f, 1f);

			public Vector2 OutputL = new Vector2(0f, 255f);

			public Vector2 OutputR = new Vector2(0f, 255f);

			public Vector2 OutputG = new Vector2(0f, 255f);

			public Vector2 OutputB = new Vector2(0f, 255f);

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Mode == ColorMode.Monochrome)
				{
					base.Material.SetVector("_InputMin", new Vector4(InputL.x / 255f, InputL.x / 255f, InputL.x / 255f, 1f));
					base.Material.SetVector("_InputMax", new Vector4(InputL.y / 255f, InputL.y / 255f, InputL.y / 255f, 1f));
					base.Material.SetVector("_InputGamma", new Vector4(InputL.z, InputL.z, InputL.z, 1f));
					base.Material.SetVector("_OutputMin", new Vector4(OutputL.x / 255f, OutputL.x / 255f, OutputL.x / 255f, 1f));
					base.Material.SetVector("_OutputMax", new Vector4(OutputL.y / 255f, OutputL.y / 255f, OutputL.y / 255f, 1f));
				}
				else
				{
					base.Material.SetVector("_InputMin", new Vector4(InputR.x / 255f, InputG.x / 255f, InputB.x / 255f, 1f));
					base.Material.SetVector("_InputMax", new Vector4(InputR.y / 255f, InputG.y / 255f, InputB.y / 255f, 1f));
					base.Material.SetVector("_InputGamma", new Vector4(InputR.z, InputG.z, InputB.z, 1f));
					base.Material.SetVector("_OutputMin", new Vector4(OutputR.x / 255f, OutputG.x / 255f, OutputB.x / 255f, 1f));
					base.Material.SetVector("_OutputMax", new Vector4(OutputR.y / 255f, OutputG.y / 255f, OutputB.y / 255f, 1f));
				}
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Levels";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/lofi-palette.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/LoFi Palette")]
		public class LoFiPalette : LookupFilter3D
		{
			public enum Preset
			{
				None = 0,
				AmstradCPC = 2,
				CGA = 3,
				Commodore64 = 4,
				CommodorePlus = 5,
				EGA = 6,
				GameBoy = 7,
				MacOS16 = 8,
				MacOS256 = 9,
				MasterSystem = 10,
				RiscOS16 = 11,
				Teletex = 12,
				Windows16 = 13,
				Windows256 = 14,
				ZXSpectrum = 15,
				Andrae = 17,
				Anodomani = 18,
				Crayolo = 19,
				DB16 = 20,
				DB32 = 21,
				DJinn = 22,
				DrazileA = 23,
				DrazileB = 24,
				DrazileC = 25,
				Eggy = 26,
				FinlalA = 27,
				FinlalB = 28,
				Hapiel = 29,
				PavanzA = 30,
				PavanzB = 31,
				Peyton = 32,
				SpeedyCube = 33
			}

			public Preset Palette;

			[Tooltip("Pixelize the display.")]
			public bool Pixelize = true;

			[Tooltip("The display height in pixels.")]
			public float PixelSize = 128f;

			protected Preset m_CurrentPreset;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Palette != m_CurrentPreset)
				{
					m_CurrentPreset = Palette;
					if (Palette == Preset.None)
					{
						LookupTexture = null;
					}
					else
					{
						LookupTexture = Resources.Load<Texture2D>("LoFiPalettes/" + Palette);
					}
				}
				if (LookupTexture == null || Amount <= 0f)
				{
					Graphics.Blit(source, destination);
				}
				else if (m_Use2DLut || ForceCompatibility)
				{
					RenderLut2D(source, destination);
				}
				else
				{
					RenderLut3D(source, destination);
				}
			}

			protected override void RenderLut2D(RenderTexture source, RenderTexture destination)
			{
				float num = Mathf.Sqrt(LookupTexture.width);
				base.Material.SetTexture("_LookupTex", LookupTexture);
				base.Material.SetVector("_Params1", new Vector3(1f / (float)LookupTexture.width, 1f / (float)LookupTexture.height, num - 1f));
				base.Material.SetVector("_Params2", new Vector2(Amount, PixelSize));
				int pass = (Pixelize ? 6 : 4) + (CLib.IsLinearColorSpace() ? 1 : 0);
				Graphics.Blit(source, destination, base.Material, pass);
			}

			protected override void RenderLut3D(RenderTexture source, RenderTexture destination)
			{
				if (LookupTexture.name != m_BaseTextureName)
				{
					ConvertBaseTexture();
				}
				if (m_Lut3D == null)
				{
					SetIdentityLut();
				}
				m_Lut3D.filterMode = FilterMode.Point;
				base.Material.SetTexture("_LookupTex", m_Lut3D);
				float num = m_Lut3D.width;
				base.Material.SetVector("_Params", new Vector4((num - 1f) / (1f * num), 1f / (2f * num), Amount, PixelSize));
				int pass = (Pixelize ? 2 : 0) + (CLib.IsLinearColorSpace() ? 1 : 0);
				Graphics.Blit(source, destination, base.Material, pass);
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/lookup-filter.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Lookup Filter (Deprecated)")]
		public class LookupFilter : BaseEffect
		{
			[Tooltip("The lookup texture to apply. Read the documentation to learn how to create one.")]
			public Texture LookupTexture;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (LookupTexture == null || Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetTexture("_LookupTex", LookupTexture);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material, CLib.IsLinearColorSpace() ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Lookup Filter (Deprecated)";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/lookup-filter-3d.html")]
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Colorful FX/Color Correction/Lookup Filter 3D")]
		public class LookupFilter3D : MonoBehaviour
		{
			[Tooltip("The lookup texture to apply. Read the documentation to learn how to create one.")]
			public Texture2D LookupTexture;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			[Tooltip("The effect will automatically detect the correct shader to use for the device but you can force it to only use the compatibility shader.")]
			public bool ForceCompatibility;

			protected Texture3D m_Lut3D;

			protected string m_BaseTextureName;

			protected bool m_Use2DLut;

			public Shader Shader2D;

			public Shader Shader3D;

			protected Material m_Material2D;

			protected Material m_Material3D;

			public Shader Shader2DSafe
			{
				get
				{
					if (Shader2D == null)
					{
						Shader2D = Shader.Find("Hidden/Colorful/Lookup Filter 2D");
					}
					return Shader2D;
				}
			}

			public Shader Shader3DSafe
			{
				get
				{
					if (Shader3D == null)
					{
						Shader3D = Shader.Find("Hidden/Colorful/Lookup Filter 3D");
					}
					return Shader3D;
				}
			}

			public Material Material
			{
				get
				{
					if (m_Use2DLut || ForceCompatibility)
					{
						if (m_Material2D == null)
						{
							m_Material2D = new Material(Shader2DSafe);
							m_Material2D.hideFlags = HideFlags.HideAndDontSave;
						}
						return m_Material2D;
					}
					if (m_Material3D == null)
					{
						m_Material3D = new Material(Shader3DSafe);
						m_Material3D.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_Material3D;
				}
			}

			protected virtual void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					UnityEngine.Debug.LogWarning("Image effects aren't supported on this device");
					base.enabled = false;
					return;
				}
				if (!SystemInfo.supports3DTextures)
				{
					m_Use2DLut = true;
				}
				if (!Shader2DSafe || !Shader2D.isSupported)
				{
					UnityEngine.Debug.LogWarning("The shader is null or unsupported on this device");
					base.enabled = false;
				}
				else if (!m_Use2DLut && !ForceCompatibility && (!Shader3DSafe || !Shader3D.isSupported))
				{
					m_Use2DLut = true;
				}
			}

			protected virtual void OnDisable()
			{
				if ((bool)m_Material2D)
				{
					UnityEngine.Object.DestroyImmediate(m_Material2D);
				}
				if ((bool)m_Material3D)
				{
					UnityEngine.Object.DestroyImmediate(m_Material3D);
				}
				if ((bool)m_Lut3D)
				{
					UnityEngine.Object.DestroyImmediate(m_Lut3D);
				}
				m_BaseTextureName = "";
			}

			protected virtual void Reset()
			{
				m_BaseTextureName = "";
			}

			protected void SetIdentityLut()
			{
				int num = 16;
				Color[] array = new Color[num * num * num];
				float num2 = 1f / (1f * (float)num - 1f);
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
						}
					}
				}
				if ((bool)m_Lut3D)
				{
					UnityEngine.Object.DestroyImmediate(m_Lut3D);
				}
				m_Lut3D = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				m_Lut3D.hideFlags = HideFlags.HideAndDontSave;
				m_Lut3D.SetPixels(array);
				m_Lut3D.Apply();
				m_BaseTextureName = "";
			}

			public bool ValidDimensions(Texture2D tex2D)
			{
				if (tex2D == null || tex2D.height != Mathf.FloorToInt(Mathf.Sqrt(tex2D.width)))
				{
					return false;
				}
				return true;
			}

			protected void ConvertBaseTexture()
			{
				if (!ValidDimensions(LookupTexture))
				{
					UnityEngine.Debug.LogWarning("The given 2D texture " + LookupTexture.name + " cannot be used as a 3D LUT. Pick another texture or adjust dimension to e.g. 256x16.");
					return;
				}
				m_BaseTextureName = LookupTexture.name;
				int height = LookupTexture.height;
				Color[] pixels = LookupTexture.GetPixels();
				Color[] array = new Color[pixels.Length];
				for (int i = 0; i < height; i++)
				{
					for (int j = 0; j < height; j++)
					{
						for (int k = 0; k < height; k++)
						{
							int num = height - j - 1;
							array[i + j * height + k * height * height] = pixels[k * height + i + num * height * height];
						}
					}
				}
				if ((bool)m_Lut3D)
				{
					UnityEngine.Object.DestroyImmediate(m_Lut3D);
				}
				m_Lut3D = new Texture3D(height, height, height, TextureFormat.ARGB32, mipChain: false);
				m_Lut3D.hideFlags = HideFlags.HideAndDontSave;
				m_Lut3D.wrapMode = TextureWrapMode.Clamp;
				m_Lut3D.SetPixels(array);
				m_Lut3D.Apply();
			}

			public void Apply(Texture source, RenderTexture destination)
			{
				if (source is RenderTexture)
				{
					OnRenderImage(source as RenderTexture, destination);
					return;
				}
				RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
				Graphics.Blit(source, temporary);
				OnRenderImage(temporary, destination);
				RenderTexture.ReleaseTemporary(temporary);
			}

			protected virtual void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (LookupTexture == null || Amount <= 0f)
				{
					Graphics.Blit(source, destination);
				}
				else if (m_Use2DLut || ForceCompatibility)
				{
					RenderLut2D(source, destination);
				}
				else
				{
					RenderLut3D(source, destination);
				}
			}

			protected virtual void RenderLut2D(RenderTexture source, RenderTexture destination)
			{
				float num = Mathf.Sqrt(LookupTexture.width);
				Material.SetTexture("_LookupTex", LookupTexture);
				Material.SetVector("_Params1", new Vector3(1f / (float)LookupTexture.width, 1f / (float)LookupTexture.height, num - 1f));
				Material.SetVector("_Params2", new Vector2(Amount, 0f));
				Graphics.Blit(source, destination, Material, CLib.IsLinearColorSpace() ? 1 : 0);
			}

			protected virtual void RenderLut3D(RenderTexture source, RenderTexture destination)
			{
				if (LookupTexture.name != m_BaseTextureName)
				{
					ConvertBaseTexture();
				}
				if (m_Lut3D == null)
				{
					SetIdentityLut();
				}
				Material.SetTexture("_LookupTex", m_Lut3D);
				float num = m_Lut3D.width;
				Material.SetVector("_Params", new Vector3((num - 1f) / (1f * num), 1f / (2f * num), Amount));
				Graphics.Blit(source, destination, Material, CLib.IsLinearColorSpace() ? 1 : 0);
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/negative.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Negative")]
		public class Negative : BaseEffect
		{
			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material, CLib.IsLinearColorSpace() ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Negative";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/noise.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/Noise")]
		public class Noise : BaseEffect
		{
			public enum ColorMode
			{
				Monochrome,
				RGB
			}

			[Tooltip("Black & white or colored noise.")]
			public ColorMode Mode;

			[Tooltip("Automatically increment the seed to animate the noise.")]
			public bool Animate = true;

			[Tooltip("A number used to initialize the noise generator.")]
			public float Seed = 0.5f;

			[Range(0f, 1f)]
			[Tooltip("Strength used to apply the noise. 0 means no noise at all, 1 is full noise.")]
			public float Strength = 0.12f;

			[Range(0f, 1f)]
			[Tooltip("Reduce the noise visibility in luminous areas.")]
			public float LumContribution;

			protected virtual void Update()
			{
				if (Animate)
				{
					if (Seed > 1000f)
					{
						Seed = 0.5f;
					}
					Seed += Time.deltaTime * 0.25f;
				}
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params", new Vector3(Seed, Strength, LumContribution));
				int num = ((Mode != 0) ? 1 : 0);
				num += ((LumContribution > 0f) ? 2 : 0);
				Graphics.Blit(source, destination, base.Material, num);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Noise";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/photo-filter.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Photo Filter")]
		public class PhotoFilter : BaseEffect
		{
			[ColorUsage(false)]
			[Tooltip("Lens filter color.")]
			public Color Color = new Color(1f, 0.5f, 0.2f, 1f);

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Density = 0.35f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Density <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetColor("_RGB", Color);
				base.Material.SetFloat("_Density", Density);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Photo Filter";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/pixel-matrix.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/Pixel Matrix")]
		public class PixelMatrix : BaseEffect
		{
			[Min(3f)]
			[Tooltip("Tile size. Works best with multiples of 3.")]
			public int Size = 9;

			[Range(0f, 10f)]
			[Tooltip("Tile brightness booster.")]
			public float Brightness = 1.4f;

			[Tooltip("Show / hide black borders on every tile.")]
			public bool BlackBorder = true;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params", new Vector4(Size, Mathf.Floor((float)Size / 3f), (float)Size - Mathf.Floor((float)Size / 3f), Brightness));
				Graphics.Blit(source, destination, base.Material, BlackBorder ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/PixelMatrix";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/pixelate.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/Pixelate")]
		public class Pixelate : BaseEffect
		{
			public enum SizeMode
			{
				ResolutionIndependent,
				PixelPerfect
			}

			[Range(1f, 1024f)]
			[Tooltip("Scale of an individual pixel. Depends on the Mode used.")]
			public float Scale = 80f;

			[Tooltip("Turn this on to automatically compute the aspect ratio needed for squared pixels.")]
			public bool AutomaticRatio = true;

			[Tooltip("Custom aspect ratio.")]
			public float Ratio = 1f;

			[Tooltip("Used for the Scale field.")]
			public SizeMode Mode;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				float x = Scale;
				if (Mode == SizeMode.PixelPerfect)
				{
					x = (float)source.width / Scale;
				}
				base.Material.SetVector("_Params", new Vector2(x, AutomaticRatio ? ((float)source.width / (float)source.height) : Ratio));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Pixelate";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/posterize.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Posterize")]
		public class Posterize : BaseEffect
		{
			[Range(2f, 255f)]
			[Tooltip("Number of tonal levels (brightness values) for each channel.")]
			public int Levels = 16;

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			[Tooltip("Only affects luminosity. Use this if you don't want any hue shifting or color changes.")]
			public bool LuminosityOnly;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params", new Vector2(Levels, Amount));
				Graphics.Blit(source, destination, base.Material, LuminosityOnly ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Posterize";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/rgb-split.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/RGB Split")]
		public class RGBSplit : BaseEffect
		{
			[Tooltip("RGB shifting amount.")]
			public float Amount;

			[Tooltip("Shift direction in radians.")]
			public float Angle;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount == 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Params", new Vector3(Amount * 0.001f, Mathf.Sin(Angle), Mathf.Cos(Angle)));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/RGB Split";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/blur-effects/radial-blur.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Blur Effects/Radial Blur")]
		public class RadialBlur : BaseEffect
		{
			public enum QualityPreset
			{
				Low = 4,
				Medium = 8,
				High = 12,
				Custom = 13
			}

			[Range(0f, 1f)]
			[Tooltip("Blur strength.")]
			public float Strength = 0.1f;

			[Range(2f, 32f)]
			[Tooltip("Sample count. Higher means better quality but slower processing.")]
			public int Samples = 10;

			[Tooltip("Focus point.")]
			public Vector2 Center = new Vector2(0.5f, 0.5f);

			[Tooltip("Quality preset. Higher means better quality but slower processing.")]
			public QualityPreset Quality = QualityPreset.Medium;

			[Range(-100f, 100f)]
			[Tooltip("Smoothness of the vignette effect.")]
			public float Sharpness = 40f;

			[Range(0f, 100f)]
			[Tooltip("Amount of vignetting on screen.")]
			public float Darkness = 35f;

			[Tooltip("Should the effect be applied like a vignette ?")]
			public bool EnableVignette = true;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Strength <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				int num = ((Quality == QualityPreset.Custom) ? Samples : ((int)Quality));
				base.Material.SetVector("_Center", Center);
				base.Material.SetVector("_Params", new Vector4(Strength, num, Sharpness * 0.01f, Darkness * 0.02f));
				Graphics.Blit(source, destination, base.Material, EnableVignette ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Radial Blur";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/s-curve-contrast.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/S-Curve Contrast")]
		public class SCurveContrast : BaseEffect
		{
			public float RedSteepness = 1f;

			public float RedGamma = 1f;

			public float GreenSteepness = 1f;

			public float GreenGamma = 1f;

			public float BlueSteepness = 1f;

			public float BlueGamma = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Red", new Vector2(RedSteepness, RedGamma));
				base.Material.SetVector("_Green", new Vector2(GreenSteepness, GreenGamma));
				base.Material.SetVector("_Blue", new Vector2(BlueSteepness, BlueGamma));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/SCurveContrast";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/shadows-midtones-highlights.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Shadows, Midtones, Highlights")]
		public class ShadowsMidtonesHighlights : BaseEffect
		{
			public enum ColorMode
			{
				LiftGammaGain,
				OffsetGammaSlope
			}

			[Tooltip("Color mode. The difference between these two modes is the way shadows are handled.")]
			public ColorMode Mode;

			[Tooltip("Adds density or darkness, raises or lowers the shadow levels with its alpha value and offset the color balance in the dark regions with the hue point.")]
			public Color Shadows = new Color(1f, 1f, 1f, 0.5f);

			[Tooltip("Shifts the middle tones to be brighter or darker. For instance, to make your render more warm, just move the midtone color toward the yellow/red range. The more saturated the color is, the warmer the render becomes.")]
			public Color Midtones = new Color(1f, 1f, 1f, 0.5f);

			[Tooltip("Brightens and tints the entire render but mostly affects the highlights.")]
			public Color Highlights = new Color(1f, 1f, 1f, 0.5f);

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 1f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Shadows", Shadows * (Shadows.a * 2f));
				float num = 1f + (1f - (Midtones.r * 0.299f + Midtones.g * 0.587f + Midtones.b * 0.114f));
				base.Material.SetVector("_Midtones", Midtones * num * (Midtones.a * 2f));
				num = 1f + (1f - (Highlights.r * 0.299f + Highlights.g * 0.587f + Highlights.b * 0.114f));
				base.Material.SetVector("_Highlights", Highlights * num * (Highlights.a * 2f));
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Shadows Midtones Highlights";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/other-effects/sharpen.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Other Effects/Sharpen")]
		public class Sharpen : BaseEffect
		{
			public enum Algorithm
			{
				TypeA,
				TypeB
			}

			[Tooltip("Sharpening algorithm to use.")]
			public Algorithm Mode = Algorithm.TypeB;

			[Range(0f, 5f)]
			[Tooltip("Sharpening Strength.")]
			public float Strength = 0.6f;

			[Range(0f, 1f)]
			[Tooltip("Limits the amount of sharpening a pixel will receive.")]
			public float Clamp = 0.05f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Strength == 0f || Clamp == 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Params", new Vector4(Strength, Clamp, 1f / (float)source.width, 1f / (float)source.height));
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Sharpen";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/smart-saturation.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Smart Saturation")]
		public class SmartSaturation : BaseEffect
		{
			[Range(0f, 2f)]
			[Tooltip("Saturation boost. Default: 1 (no boost).")]
			public float Boost = 1f;

			public AnimationCurve Curve;

			private Texture2D _CurveTexture;

			protected Texture2D m_CurveTexture
			{
				get
				{
					if (_CurveTexture == null)
					{
						UpdateCurve();
					}
					return _CurveTexture;
				}
			}

			protected virtual void Reset()
			{
				Curve = new AnimationCurve(new Keyframe(0f, 0.5f, 0f, 0f), new Keyframe(1f, 0.5f, 0f, 0f));
			}

			protected virtual void OnEnable()
			{
				if (Curve == null)
				{
					Reset();
				}
			}

			protected override void OnDisable()
			{
				base.OnDisable();
				if (_CurveTexture != null)
				{
					UnityEngine.Object.DestroyImmediate(_CurveTexture);
				}
			}

			public virtual void UpdateCurve()
			{
				if (_CurveTexture == null)
				{
					_CurveTexture = new Texture2D(256, 1, TextureFormat.Alpha8, mipChain: false);
					_CurveTexture.name = "Saturation Curve Texture";
					_CurveTexture.wrapMode = TextureWrapMode.Clamp;
					_CurveTexture.anisoLevel = 0;
					_CurveTexture.filterMode = FilterMode.Bilinear;
					_CurveTexture.hideFlags = HideFlags.DontSave;
				}
				Color[] pixels = _CurveTexture.GetPixels();
				for (int i = 0; i < 256; i++)
				{
					float num = Mathf.Clamp01(Curve.Evaluate((float)i / 255f));
					pixels[i] = new Color(num, num, num, num);
				}
				_CurveTexture.SetPixels(pixels);
				_CurveTexture.Apply();
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetTexture("_Curve", m_CurveTexture);
				base.Material.SetFloat("_Boost", Boost);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Smart Saturation";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/artistic-effects/strokes.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Artistic Effects/Strokes")]
		public class Strokes : BaseEffect
		{
			public enum ColorMode
			{
				BlackAndWhite,
				WhiteAndBlack,
				ColorAndWhite,
				ColorAndBlack,
				WhiteAndColor,
				BlackAndColor
			}

			public ColorMode Mode;

			[Range(0f, 0.04f)]
			[Tooltip("Stroke rotation, or wave pattern amplitude.")]
			public float Amplitude = 0.025f;

			[Range(0f, 20f)]
			[Tooltip("Wave pattern frequency (higher means more waves).")]
			public float Frequency = 10f;

			[Range(4f, 12f)]
			[Tooltip("Global scaling.")]
			public float Scaling = 7.5f;

			[Range(0.1f, 0.5f)]
			[Tooltip("Stroke maximum thickness.")]
			public float MaxThickness = 0.2f;

			[Range(0f, 1f)]
			[Tooltip("Contribution threshold (higher means more continous strokes).")]
			public float Threshold = 0.7f;

			[Range(-0.3f, 0.3f)]
			[Tooltip("Stroke pressure.")]
			public float Harshness;

			[Range(0f, 1f)]
			[Tooltip("Amount of red to contribute to the strokes.")]
			public float RedLuminance = 0.299f;

			[Range(0f, 1f)]
			[Tooltip("Amount of green to contribute to the strokes.")]
			public float GreenLuminance = 0.587f;

			[Range(0f, 1f)]
			[Tooltip("Amount of blue to contribute to the strokes.")]
			public float BlueLuminance = 0.114f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				float num = Scaling / (float)source.height;
				base.Material.SetVector("_Params1", new Vector4(Amplitude, Frequency, num, MaxThickness * num));
				base.Material.SetVector("_Params2", new Vector3(RedLuminance, GreenLuminance, BlueLuminance));
				base.Material.SetVector("_Params3", new Vector2(Threshold, Harshness));
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Strokes";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/tv-vignette.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/TV Vignette")]
		public class TVVignette : BaseEffect
		{
			[Min(0f)]
			public float Size = 25f;

			[Range(0f, 1f)]
			public float Offset = 0.2f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Offset >= 1f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Params", new Vector2(Size, Offset));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/TV Vignette";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/technicolor.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Technicolor")]
		public class Technicolor : BaseEffect
		{
			[Range(0f, 8f)]
			public float Exposure = 4f;

			public Vector3 Balance = new Vector3(0.25f, 0.25f, 0.25f);

			[Range(0f, 1f)]
			[Tooltip("Blending factor.")]
			public float Amount = 0.5f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetFloat("_Exposure", 8f - Exposure);
				base.Material.SetVector("_Balance", Vector3.one - Balance);
				base.Material.SetFloat("_Amount", Amount);
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Technicolor";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/threshold.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Threshold")]
		public class Threshold : BaseEffect
		{
			[Range(1f, 255f)]
			[Tooltip("Luminosity threshold.")]
			public float Value = 128f;

			[Range(0f, 128f)]
			[Tooltip("Aomunt of randomization.")]
			public float NoiseRange = 24f;

			[Tooltip("Adds some randomization to the threshold value.")]
			public bool UseNoise;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetFloat("_Threshold", Value / 255f);
				base.Material.SetFloat("_Range", NoiseRange / 255f);
				Graphics.Blit(source, destination, base.Material, UseNoise ? 1 : 0);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Threshold";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/vibrance.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Vibrance")]
		public class Vibrance : BaseEffect
		{
			[Range(-100f, 100f)]
			[Tooltip("Adjusts the saturation so that clipping is minimized as colors approach full saturation.")]
			public float Amount;

			[Range(-5f, 5f)]
			public float RedChannel = 1f;

			[Range(-5f, 5f)]
			public float GreenChannel = 1f;

			[Range(-5f, 5f)]
			public float BlueChannel = 1f;

			public bool AdvancedMode;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Amount <= 0f)
				{
					Graphics.Blit(source, destination);
				}
				else if (AdvancedMode)
				{
					base.Material.SetFloat("_Amount", Amount * 0.01f);
					base.Material.SetVector("_Channels", new Vector3(RedChannel, GreenChannel, BlueChannel));
					Graphics.Blit(source, destination, base.Material, 1);
				}
				else
				{
					base.Material.SetFloat("_Amount", Amount * 0.02f);
					Graphics.Blit(source, destination, base.Material, 0);
				}
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Vibrance";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/vintage.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Vintage (Deprecated)")]
		public class Vintage : LookupFilter
		{
			public enum InstragramFilter
			{
				None,
				F1977,
				Aden,
				Amaro,
				Brannan,
				Crema,
				Earlybird,
				Hefe,
				Hudson,
				Inkwell,
				Juno,
				Kelvin,
				Lark,
				LoFi,
				Ludwig,
				Mayfair,
				Nashville,
				Perpetua,
				Reyes,
				Rise,
				Sierra,
				Slumber,
				Sutro,
				Toaster,
				Valencia,
				Walden,
				Willow,
				XProII
			}

			public InstragramFilter Filter;

			protected InstragramFilter m_CurrentFilter;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Filter != m_CurrentFilter)
				{
					m_CurrentFilter = Filter;
					if (Filter == InstragramFilter.None)
					{
						LookupTexture = null;
					}
					else
					{
						LookupTexture = Resources.Load<Texture2D>("Instagram/" + Filter);
					}
				}
				base.OnRenderImage(source, destination);
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/vintage-fast.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/Vintage")]
		public class VintageFast : LookupFilter3D
		{
			public Vintage.InstragramFilter Filter;

			protected Vintage.InstragramFilter m_CurrentFilter;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (Filter != m_CurrentFilter)
				{
					m_CurrentFilter = Filter;
					if (Filter == Vintage.InstragramFilter.None)
					{
						LookupTexture = null;
					}
					else
					{
						LookupTexture = Resources.Load<Texture2D>("InstagramFast/" + Filter);
					}
				}
				base.OnRenderImage(source, destination);
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/wave-distortion.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Wave Distortion")]
		public class WaveDistortion : BaseEffect
		{
			[Range(0f, 1f)]
			[Tooltip("Wave amplitude.")]
			public float Amplitude = 0.6f;

			[Tooltip("Amount of waves.")]
			public float Waves = 5f;

			[Range(0f, 5f)]
			[Tooltip("Amount of color shifting.")]
			public float ColorGlitch = 0.35f;

			[Tooltip("Distortion state. Think of it as a bell curve going from 0 to 1, with 0.5 being the highest point.")]
			public float Phase = 0.35f;

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				float num = CLib.Frac(Phase);
				if (num == 0f)
				{
					Graphics.Blit(source, destination);
					return;
				}
				base.Material.SetVector("_Params", new Vector4(Amplitude, Waves, ColorGlitch, num));
				Graphics.Blit(source, destination, base.Material);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Wave Distortion";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/color-correction/white-balance.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Color Correction/White Balance")]
		public class WhiteBalance : BaseEffect
		{
			public enum BalanceMode
			{
				Simple,
				Complex
			}

			[ColorUsage(false)]
			[Tooltip("Reference white point or midtone value.")]
			public Color White = new Color(0.5f, 0.5f, 0.5f);

			[Tooltip("Algorithm used.")]
			public BalanceMode Mode = BalanceMode.Complex;

			protected virtual void Reset()
			{
				White = (CLib.IsLinearColorSpace() ? new Color((float)Math.PI * 59f / 254f, (float)Math.PI * 59f / 254f, (float)Math.PI * 59f / 254f) : new Color(0.5f, 0.5f, 0.5f));
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetColor("_White", White);
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/White Balance";
			}
		}
		[HelpURL("http://www.thomashourdel.com/colorful/doc/camera-effects/wiggle.html")]
		[ExecuteInEditMode]
		[AddComponentMenu("Colorful FX/Camera Effects/Wiggle")]
		public class Wiggle : BaseEffect
		{
			public enum Algorithm
			{
				Simple,
				Complex
			}

			[Tooltip("Animation type. Complex is slower but looks more natural.")]
			public Algorithm Mode = Algorithm.Complex;

			public float Timer;

			[Tooltip("Wave animation speed.")]
			public float Speed = 1f;

			[Tooltip("Wave frequency (higher means more waves).")]
			public float Frequency = 12f;

			[Tooltip("Wave amplitude (higher means bigger waves).")]
			public float Amplitude = 0.01f;

			[Tooltip("Automatically animate this effect at runtime.")]
			public bool AutomaticTimer = true;

			protected virtual void Update()
			{
				if (AutomaticTimer)
				{
					if (Timer > 1000f)
					{
						Timer -= 1000f;
					}
					Timer += Speed * Time.deltaTime;
				}
			}

			protected override void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.Material.SetVector("_Params", new Vector3(Frequency, Amplitude, Timer * ((Mode == Algorithm.Complex) ? 0.1f : 1f)));
				Graphics.Blit(source, destination, base.Material, (int)Mode);
			}

			protected override string GetShaderName()
			{
				return "Hidden/Colorful/Wiggle";
			}
		}
	}
	namespace SaveData
	{
		public class AutoSaveProcess
		{
			public delegate void ErrorHandler(uint errorCode);

			private enum SaveState
			{
				Begin,
				SaveFiles,
				WriteIcon,
				WriteParams,
				Unmount,
				HandleError,
				LoadFiles,
				Exit
			}

			public static IEnumerator StartAutoSaveProcess(int userId, Dialogs.NewItem newItem, DirName autoSaveDirName, ulong newSaveDataBlocks, SaveDataParams saveDataParams, FileOps.FileOperationRequest fileRequest, FileOps.FileOperationResponse fileResponse, bool backup, ErrorHandler errHandler)
			{
				SaveState currentState = SaveState.Begin;
				Mounting.MountResponse mountResponse = new Mounting.MountResponse();
				Mounting.MountPoint mp = null;
				int errorCode = 0;
				while (true)
				{
					switch (currentState)
					{
					case SaveState.Begin:
					{
						Mounting.MountModeFlags flags = Mounting.MountModeFlags.ReadWrite | Mounting.MountModeFlags.Create2;
						errorCode = MountSaveData(userId, newSaveDataBlocks, mountResponse, autoSaveDirName, flags);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (mountResponse.Locked)
						{
							yield return null;
						}
						if (mountResponse.IsErrorCode)
						{
							errorCode = mountResponse.ReturnCodeValue;
							currentState = SaveState.HandleError;
						}
						else
						{
							mp = mountResponse.MountPoint;
							currentState = SaveState.SaveFiles;
						}
						break;
					}
					case SaveState.SaveFiles:
					{
						fileRequest.MountPointName = mp.PathName;
						fileRequest.Async = true;
						fileRequest.UserId = userId;
						errorCode = FileOps.CustomFileOp(fileRequest, fileResponse);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (fileResponse.Locked)
						{
							yield return null;
						}
						EmptyResponse iconResponse3 = new EmptyResponse();
						errorCode = WriteIcon(userId, iconResponse3, mp, newItem);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						EmptyResponse paramsResponse = new EmptyResponse();
						errorCode = WriteParams(userId, paramsResponse, mp, saveDataParams);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (iconResponse3.Locked || paramsResponse.Locked)
						{
							yield return null;
						}
						currentState = SaveState.WriteIcon;
						break;
					}
					case SaveState.WriteIcon:
					{
						EmptyResponse iconResponse3 = new EmptyResponse();
						errorCode = WriteIcon(userId, iconResponse3, mp, newItem);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (iconResponse3.Locked)
						{
							yield return null;
						}
						currentState = SaveState.WriteParams;
						break;
					}
					case SaveState.WriteParams:
					{
						EmptyResponse iconResponse3 = new EmptyResponse();
						errorCode = WriteParams(userId, iconResponse3, mp, saveDataParams);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (iconResponse3.Locked)
						{
							yield return null;
						}
						currentState = SaveState.Unmount;
						break;
					}
					case SaveState.Unmount:
					{
						EmptyResponse iconResponse3 = new EmptyResponse();
						errorCode = UnmountSaveData(userId, iconResponse3, mp, backup);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (iconResponse3.Locked)
						{
							yield return null;
						}
						currentState = SaveState.Exit;
						break;
					}
					case SaveState.HandleError:
						if (mp != null)
						{
							EmptyResponse unmountResponse = new EmptyResponse();
							UnmountSaveData(userId, unmountResponse, mp, backup);
						}
						errHandler?.Invoke((uint)errorCode);
						currentState = SaveState.Exit;
						break;
					case SaveState.Exit:
						yield break;
					}
					yield return null;
				}
			}

			public static IEnumerator StartAutoSaveLoadProcess(int userId, DirName dirName, FileOps.FileOperationRequest fileRequest, FileOps.FileOperationResponse fileResponse, ErrorHandler errHandler)
			{
				SaveState currentState = SaveState.Begin;
				Mounting.MountResponse mountResponse = new Mounting.MountResponse();
				Mounting.MountPoint mp = null;
				int errorCode = 0;
				while (true)
				{
					switch (currentState)
					{
					case SaveState.Begin:
					{
						Mounting.MountModeFlags flags = Mounting.MountModeFlags.ReadOnly;
						errorCode = MountSaveData(userId, 0uL, mountResponse, dirName, flags);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (mountResponse.Locked)
						{
							yield return null;
						}
						if (mountResponse.IsErrorCode)
						{
							errorCode = mountResponse.ReturnCodeValue;
							currentState = SaveState.HandleError;
						}
						else
						{
							mp = mountResponse.MountPoint;
							currentState = SaveState.LoadFiles;
						}
						break;
					}
					case SaveState.LoadFiles:
						fileRequest.MountPointName = mp.PathName;
						fileRequest.Async = true;
						fileRequest.UserId = userId;
						errorCode = FileOps.CustomFileOp(fileRequest, fileResponse);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (fileResponse.Locked)
						{
							yield return null;
						}
						currentState = SaveState.Unmount;
						break;
					case SaveState.Unmount:
					{
						EmptyResponse unmountResponse = new EmptyResponse();
						errorCode = UnmountSaveData(userId, unmountResponse, mp, backup: false);
						if (errorCode < 0)
						{
							currentState = SaveState.HandleError;
							break;
						}
						while (unmountResponse.Locked)
						{
							yield return null;
						}
						currentState = SaveState.Exit;
						break;
					}
					case SaveState.HandleError:
						if (mp != null)
						{
							EmptyResponse unmountResponse2 = new EmptyResponse();
							UnmountSaveData(userId, unmountResponse2, mp, backup: false);
						}
						errHandler?.Invoke((uint)errorCode);
						currentState = SaveState.Exit;
						break;
					case SaveState.Exit:
						yield break;
					}
					yield return null;
				}
			}

			internal static int MountSaveData(int userId, ulong blocks, Mounting.MountResponse mountResponse, DirName dirName, Mounting.MountModeFlags flags)
			{
				int result = -2135425010;
				try
				{
					Mounting.MountRequest obj = new Mounting.MountRequest
					{
						UserId = userId,
						IgnoreCallback = true,
						DirName = dirName,
						MountMode = flags
					};
					if (blocks < 96)
					{
						blocks = 96uL;
					}
					obj.Blocks = blocks;
					Mounting.Mount(obj, mountResponse);
					result = 0;
				}
				catch
				{
					if (mountResponse.ReturnCodeValue < 0)
					{
						result = mountResponse.ReturnCodeValue;
					}
				}
				return result;
			}

			internal static int UnmountSaveData(int userId, EmptyResponse unmountResponse, Mounting.MountPoint mp, bool backup)
			{
				int result = -2135425010;
				try
				{
					Mounting.Unmount(new Mounting.UnmountRequest
					{
						UserId = userId,
						MountPointName = mp.PathName,
						Backup = backup,
						IgnoreCallback = true
					}, unmountResponse);
					result = 0;
				}
				catch
				{
					if (unmountResponse.ReturnCodeValue < 0)
					{
						result = unmountResponse.ReturnCodeValue;
					}
				}
				return result;
			}

			internal static int WriteIcon(int userId, EmptyResponse iconResponse, Mounting.MountPoint mp, Dialogs.NewItem newItem)
			{
				int result = -2135425010;
				try
				{
					Mounting.SaveIconRequest saveIconRequest = new Mounting.SaveIconRequest();
					if (mp == null)
					{
						return result;
					}
					saveIconRequest.UserId = userId;
					saveIconRequest.MountPointName = mp.PathName;
					saveIconRequest.RawPNG = newItem.RawPNG;
					saveIconRequest.IconPath = newItem.IconPath;
					saveIconRequest.IgnoreCallback = true;
					Mounting.SaveIcon(saveIconRequest, iconResponse);
					result = 0;
				}
				catch
				{
					if (iconResponse.ReturnCodeValue < 0)
					{
						result = iconResponse.ReturnCodeValue;
					}
				}
				return result;
			}

			internal static int WriteParams(int userId, EmptyResponse paramsResponse, Mounting.MountPoint mp, SaveDataParams saveDataParams)
			{
				int result = -2135425010;
				try
				{
					Mounting.SetMountParamsRequest setMountParamsRequest = new Mounting.SetMountParamsRequest();
					if (mp == null)
					{
						return result;
					}
					setMountParamsRequest.UserId = userId;
					setMountParamsRequest.MountPointName = mp.PathName;
					setMountParamsRequest.IgnoreCallback = true;
					setMountParamsRequest.Params = saveDataParams;
					Mounting.SetMountParams(setMountParamsRequest, paramsResponse);
					result = 0;
				}
				catch
				{
					if (paramsResponse.ReturnCodeValue < 0)
					{
						result = paramsResponse.ReturnCodeValue;
					}
				}
				return result;
			}
		}
	}
	namespace I2.Loc
	{
		public class CallbackNotification : MonoBehaviour
		{
			public void OnModifyLocalization()
			{
				if (!string.IsNullOrEmpty(Localize.MainTranslation))
				{
					string translation = LocalizationManager.GetTranslation("Color/Red");
					Localize.MainTranslation = Localize.MainTranslation.Replace("{PLAYER_COLOR}", translation);
				}
			}
		}
		public class Example_ChangeLanguage : MonoBehaviour
		{
			public void SetLanguage_English()
			{
				SetLanguage("English");
			}

			public void SetLanguage_French()
			{
				SetLanguage("French");
			}

			public void SetLanguage_Spanish()
			{
				SetLanguage("Spanish");
			}

			public void SetLanguage(string LangName)
			{
				if (LocalizationManager.HasLanguage(LangName))
				{
					LocalizationManager.CurrentLanguage = LangName;
				}
			}
		}
		public class Example_LocalizedString : MonoBehaviour
		{
			public LocalizedString _MyLocalizedString;

			public string _NormalString;

			[TermsPopup("")]
			public string _StringWithTermPopup;

			public void Start()
			{
				UnityEngine.Debug.Log(_MyLocalizedString);
				UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_NormalString));
				UnityEngine.Debug.Log(LocalizationManager.GetTranslation(_StringWithTermPopup));
				UnityEngine.Debug.Log((string)(LocalizedString)"Term2");
				UnityEngine.Debug.Log(_MyLocalizedString);
				UnityEngine.Debug.Log((LocalizedString)"Term3");
				LocalizedString localizedString = "Term3";
				localizedString.mRTL_IgnoreArabicFix = true;
				UnityEngine.Debug.Log(localizedString);
				LocalizedString localizedString2 = "Term3";
				localizedString2.mRTL_ConvertNumbers = true;
				localizedString2.mRTL_MaxLineLength = 20;
				UnityEngine.Debug.Log(localizedString2);
				UnityEngine.Debug.Log(localizedString2);
			}
		}
		public class GlobalParametersExample : RegisterGlobalParameters
		{
			public override string GetParameterValue(string ParamName)
			{
				if (ParamName == "WINNER")
				{
					return "Javier";
				}
				if (ParamName == "NUM PLAYERS")
				{
					return 5.ToString();
				}
				return null;
			}
		}
		public class RealTimeTranslation : MonoBehaviour
		{
			private string OriginalText = "This is an example showing how to use the google translator to translate chat messages within the game.\nIt also supports multiline translations.";

			private string TranslatedText = string.Empty;

			private bool IsTranslating;

			public void OnGUI()
			{
				GUILayout.Label("Translate:");
				OriginalText = GUILayout.TextArea(OriginalText, GUILayout.Width(Screen.width));
				GUILayout.Space(10f);
				GUILayout.BeginHorizontal();
				if (GUILayout.Button("English -> Espaol", GUILayout.Height(100f)))
				{
					StartTranslating("en", "es");
				}
				if (GUILayout.Button("Espaol -> English", GUILayout.Height(100f)))
				{
					StartTranslating("es", "en");
				}
				GUILayout.EndHorizontal();
				GUILayout.Space(10f);
				GUILayout.BeginHorizontal();
				GUILayout.TextArea("Multiple Translation with 1 call:\n'This is an example' -> en,zh\n'Hola' -> en");
				if (GUILayout.Button("Multi Translate", GUILayout.ExpandHeight(expand: true)))
				{
					ExampleMultiTranslations_Async();
				}
				GUILayout.EndHorizontal();
				GUILayout.TextArea(TranslatedText, GUILayout.Width(Screen.width));
				GUILayout.Space(10f);
				if (IsTranslating)
				{
					GUILayout.Label("Contacting Google....");
				}
			}

			public void StartTranslating(string fromCode, string toCode)
			{
				IsTranslating = true;
				GoogleTranslation.Translate(OriginalText, fromCode, toCode, OnTranslationReady);
			}

			private void OnTranslationReady(string Translation, string errorMsg)
			{
				IsTranslating = false;
				if (errorMsg != null)
				{
					UnityEngine.Debug.LogError(errorMsg);
				}
				else
				{
					TranslatedText = Translation;
				}
			}

			public void ExampleMultiTranslations_Blocking()
			{
				Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
				GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
				GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
				GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
				if (GoogleTranslation.ForceTranslate(dictionary))
				{
					UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "en", dictionary));
					UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "zh", dictionary));
					UnityEngine.Debug.Log(GoogleTranslation.GetQueryResult("This is an example", "", dictionary));
					UnityEngine.Debug.Log(dictionary["Hola"].Results[0]);
				}
			}

			public void ExampleMultiTranslations_Async()
			{
				IsTranslating = true;
				Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>();
				GoogleTranslation.AddQuery("This is an example", "en", "es", dictionary);
				GoogleTranslation.AddQuery("This is an example", "auto", "zh", dictionary);
				GoogleTranslation.AddQuery("Hola", "es", "en", dictionary);
				GoogleTranslation.Translate(dictionary, OnMultitranslationReady);
			}

			private void OnMultitranslationReady(Dictionary<string, TranslationQuery> dict, string errorMsg)
			{
				if (!string.IsNullOrEmpty(errorMsg))
				{
					UnityEngine.Debug.LogError(errorMsg);
					return;
				}
				IsTranslating = false;
				TranslatedText = "";
				TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "es", dict) + "\n";
				TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "zh", dict) + "\n";
				TranslatedText = TranslatedText + GoogleTranslation.GetQueryResult("This is an example", "", dict) + "\n";
				TranslatedText += dict["Hola"].Results[0];
			}

			public bool IsWaitingForTranslation()
			{
				return IsTranslating;
			}

			public string GetTranslatedText()
			{
				return TranslatedText;
			}

			public void SetOriginalText(string text)
			{
				OriginalText = text;
			}
		}
		public class RegisterBundlesManager : MonoBehaviour, IResourceManager_Bundles
		{
			public void OnEnable()
			{
				if (!ResourceManager.pInstance.mBundleManagers.Contains(this))
				{
					ResourceManager.pInstance.mBundleManagers.Add(this);
				}
			}

			public void OnDisable()
			{
				ResourceManager.pInstance.mBundleManagers.Remove(this);
			}

			public virtual UnityEngine.Object LoadFromBundle(string path, Type assetType)
			{
				return null;
			}
		}
		public class ToggleLanguage : MonoBehaviour
		{
			private void Start()
			{
				Invoke("test", 3f);
			}

			private void test()
			{
				List<string> allLanguages = LocalizationManager.GetAllLanguages();
				int num = allLanguages.IndexOf(LocalizationManager.CurrentLanguage);
				if (num < 0)
				{
					num = 0;
				}
				else
				{
					num = (num + 1) % allLanguages.Count;
				}
				Invoke("test", 3f);
			}
		}
		public static class PersistentStorage
		{
			public enum eFileType
			{
				Raw,
				Persistent,
				Temporal,
				Streaming
			}

			private static I2CustomPersistentStorage mStorage;

			public static void SetSetting_String(string key, string value)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				mStorage.SetSetting_String(key, value);
			}

			public static string GetSetting_String(string key, string defaultValue)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.GetSetting_String(key, defaultValue);
			}

			public static void DeleteSetting(string key)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				mStorage.DeleteSetting(key);
			}

			public static bool HasSetting(string key)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.HasSetting(key);
			}

			public static void ForceSaveSettings()
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				mStorage.ForceSaveSettings();
			}

			public static bool CanAccessFiles()
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.CanAccessFiles();
			}

			public static bool SaveFile(eFileType fileType, string fileName, string data, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.SaveFile(fileType, fileName, data, logExceptions);
			}

			public static string LoadFile(eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.LoadFile(fileType, fileName, logExceptions);
			}

			public static bool DeleteFile(eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.DeleteFile(fileType, fileName, logExceptions);
			}

			public static bool HasFile(eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (mStorage == null)
				{
					mStorage = new I2CustomPersistentStorage();
				}
				return mStorage.HasFile(fileType, fileName, logExceptions);
			}
		}
		public abstract class I2BasePersistentStorage
		{
			public virtual void SetSetting_String(string key, string value)
			{
				try
				{
					int length = value.Length;
					int num = 8000;
					if (length <= num)
					{
						PlayerPrefs.SetString(key, value);
						return;
					}
					int num2 = Mathf.CeilToInt((float)length / (float)num);
					for (int i = 0; i < num2; i++)
					{
						int num3 = num * i;
						PlayerPrefs.SetString($"[I2split]{i}{key}", value.Substring(num3, Mathf.Min(num, length - num3)));
					}
					PlayerPrefs.SetString(key, "[$I2#@div$]" + num2);
				}
				catch (Exception)
				{
					UnityEngine.Debug.LogError("Error saving PlayerPrefs " + key);
				}
			}

			public virtual string GetSetting_String(string key, string defaultValue)
			{
				try
				{
					string text = PlayerPrefs.GetString(key, defaultValue);
					if (!string.IsNullOrEmpty(text) && text.StartsWith("[I2split]", StringComparison.Ordinal))
					{
						int num = int.Parse(text.Substring("[I2split]".Length), CultureInfo.InvariantCulture);
						text = "";
						for (int i = 0; i < num; i++)
						{
							text += PlayerPrefs.GetString($"[I2split]{i}{key}", "");
						}
					}
					return text;
				}
				catch (Exception)
				{
					UnityEngine.Debug.LogError("Error loading PlayerPrefs " + key);
					return defaultValue;
				}
			}

			public virtual void DeleteSetting(string key)
			{
				try
				{
					string @string = PlayerPrefs.GetString(key, null);
					if (!string.IsNullOrEmpty(@string) && @string.StartsWith("[I2split]", StringComparison.Ordinal))
					{
						int num = int.Parse(@string.Substring("[I2split]".Length), CultureInfo.InvariantCulture);
						for (int i = 0; i < num; i++)
						{
							PlayerPrefs.DeleteKey($"[I2split]{i}{key}");
						}
					}
					PlayerPrefs.DeleteKey(key);
				}
				catch (Exception)
				{
					UnityEngine.Debug.LogError("Error deleting PlayerPrefs " + key);
				}
			}

			public virtual void ForceSaveSettings()
			{
				PlayerPrefs.Save();
			}

			public virtual bool HasSetting(string key)
			{
				return PlayerPrefs.HasKey(key);
			}

			public virtual bool CanAccessFiles()
			{
				return true;
			}

			private string UpdateFilename(PersistentStorage.eFileType fileType, string fileName)
			{
				switch (fileType)
				{
				case PersistentStorage.eFileType.Persistent:
					fileName = Application.persistentDataPath + "/" + fileName;
					break;
				case PersistentStorage.eFileType.Temporal:
					fileName = Application.temporaryCachePath + "/" + fileName;
					break;
				case PersistentStorage.eFileType.Streaming:
					fileName = Application.streamingAssetsPath + "/" + fileName;
					break;
				}
				return fileName;
			}

			public virtual bool SaveFile(PersistentStorage.eFileType fileType, string fileName, string data, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return false;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					File.WriteAllText(fileName, data, Encoding.UTF8);
					return true;
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error saving file '" + fileName + "'\n" + ex);
					}
					return false;
				}
			}

			public virtual string LoadFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return null;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					return File.ReadAllText(fileName, Encoding.UTF8);
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error loading file '" + fileName + "'\n" + ex);
					}
					return null;
				}
			}

			public virtual bool DeleteFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return false;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					File.Delete(fileName);
					return true;
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error deleting file '" + fileName + "'\n" + ex);
					}
					return false;
				}
			}

			public virtual bool HasFile(PersistentStorage.eFileType fileType, string fileName, bool logExceptions = true)
			{
				if (!CanAccessFiles())
				{
					return false;
				}
				try
				{
					fileName = UpdateFilename(fileType, fileName);
					return File.Exists(fileName);
				}
				catch (Exception ex)
				{
					if (logExceptions)
					{
						UnityEngine.Debug.LogError("Error requesting file '" + fileName + "'\n" + ex);
					}
					return false;
				}
			}
		}
		public class I2CustomPersistentStorage : I2BasePersistentStorage
		{
		}
		public class BaseSpecializationManager
		{
			public string[] mSpecializations;

			public Dictionary<string, string> mSpecializationsFallbacks;

			public virtual void InitializeSpecializations()
			{
				mSpecializations = new string[12]
				{
					"Any", "PC", "Touch", "Controller", "VR", "XBox", "PS4", "OculusVR", "ViveVR", "GearVR",
					"Android", "IOS"
				};
				mSpecializationsFallbacks = new Dictionary<string, string>(StringComparer.Ordinal)
				{
					{ "XBox", "Controller" },
					{ "PS4", "Controller" },
					{ "OculusVR", "VR" },
					{ "ViveVR", "VR" },
					{ "GearVR", "VR" },
					{ "Android", "Touch" },
					{ "IOS", "Touch" }
				};
			}

			public virtual string GetCurrentSpecialization()
			{
				if (mSpecializations == null)
				{
					InitializeSpecializations();
				}
				return "Android";
			}

			public virtual string GetFallbackSpecialization(string specialization)
			{
				if (mSpecializationsFallbacks == null)
				{
					InitializeSpecializations();
				}
				if (mSpecializationsFallbacks.TryGetValue(specialization, out var value))
				{
					return value;
				}
				return "Any";
			}
		}
		public class SpecializationManager : BaseSpecializationManager
		{
			public static SpecializationManager Singleton = new SpecializationManager();

			private SpecializationManager()
			{
				InitializeSpecializations();
			}

			public static string GetSpecializedText(string text, string specialization = null)
			{
				int num = text.IndexOf("[i2s_", StringComparison.Ordinal);
				if (num < 0)
				{
					return text;
				}
				if (string.IsNullOrEmpty(specialization))
				{
					specialization = Singleton.GetCurrentSpecialization();
				}
				while (!string.IsNullOrEmpty(specialization) && specialization != "Any")
				{
					string text2 = "[i2s_" + specialization + "]";
					int num2 = text.IndexOf(text2, StringComparison.Ordinal);
					if (num2 < 0)
					{
						specialization = Singleton.GetFallbackSpecialization(specialization);
						continue;
					}
					num2 += text2.Length;
					int num3 = text.IndexOf("[i2s_", num2, StringComparison.Ordinal);
					if (num3 < 0)
					{
						num3 = text.Length;
					}
					return text.Substring(num2, num3 - num2);
				}
				return text.Substring(0, num);
			}

			public static string SetSpecializedText(string text, string newText, string specialization)
			{
				if (string.IsNullOrEmpty(specialization))
				{
					specialization = "Any";
				}
				if ((text == null || !text.Contains("[i2s_")) && specialization == "Any")
				{
					return newText;
				}
				Dictionary<string, string> specializations = GetSpecializations(text);
				specializations[specialization] = newText;
				return SetSpecializedText(specializations);
			}

			public static string SetSpecializedText(Dictionary<string, string> specializations)
			{
				if (!specializations.TryGetValue("Any", out var value))
				{
					value = string.Empty;
				}
				foreach (KeyValuePair<string, string> specialization in specializations)
				{
					if (specialization.Key != "Any" && !string.IsNullOrEmpty(specialization.Value))
					{
						value = value + "[i2s_" + specialization.Key + "]" + specialization.Value;
					}
				}
				return value;
			}

			public static Dictionary<string, string> GetSpecializations(string text, Dictionary<string, string> buffer = null)
			{
				if (buffer == null)
				{
					buffer = new Dictionary<string, string>(StringComparer.Ordinal);
				}
				else
				{
					buffer.Clear();
				}
				if (text == null)
				{
					buffer["Any"] = "";
					return buffer;
				}
				int num = 0;
				int num2 = text.IndexOf("[i2s_", StringComparison.Ordinal);
				if (num2 < 0)
				{
					num2 = text.Length;
				}
				buffer["Any"] = text.Substring(0, num2);
				for (num = num2; num < text.Length; num = num2)
				{
					num += "[i2s_".Length;
					int num3 = text.IndexOf(']', num);
					if (num3 < 0)
					{
						break;
					}
					string key = text.Substring(num, num3 - num);
					num = num3 + 1;
					num2 = text.IndexOf("[i2s_", num, StringComparison.Ordinal);
					if (num2 < 0)
					{
						num2 = text.Length;
					}
					string value = text.Substring(num, num2 - num);
					buffer[key] = value;
				}
				return buffer;
			}

			public static void AppendSpecializations(string text, List<string> list = null)
			{
				if (text == null)
				{
					return;
				}
				if (list == null)
				{
					list = new List<string>();
				}
				if (!list.Contains("Any"))
				{
					list.Add("Any");
				}
				int num = 0;
				while (num < text.Length)
				{
					num = text.IndexOf("[i2s_", num, StringComparison.Ordinal);
					if (num >= 0)
					{
						num += "[i2s_".Length;
						int num2 = text.IndexOf(']', num);
						if (num2 >= 0)
						{
							string item = text.Substring(num, num2 - num);
							if (!list.Contains(item))
							{
								list.Add(item);
							}
							continue;
						}
						break;
					}
					break;
				}
			}
		}
		[Serializable]
		public class EventCallback
		{
			public MonoBehaviour Target;

			public string MethodName = string.Empty;

			public void Execute(UnityEngine.Object Sender = null)
			{
				if (HasCallback() && Application.isPlaying)
				{
					Target.gameObject.SendMessage(MethodName, Sender, SendMessageOptions.DontRequireReceiver);
				}
			}

			public bool HasCallback()
			{
				if (Target != null)
				{
					return !string.IsNullOrEmpty(MethodName);
				}
				return false;
			}
		}
		public enum ePluralType
		{
			Zero,
			One,
			Two,
			Few,
			Many,
			Plural
		}
		public static class GoogleLanguages
		{
			public struct LanguageCodeDef
			{
				public string Code;

				public string GoogleCode;

				public bool HasJoinedWords;

				public int PluralRule;
			}

			public static Dictionary<string, LanguageCodeDef> mLanguageDef = new Dictionary<string, LanguageCodeDef>(StringComparer.Ordinal)
			{
				{
					"Abkhazian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ab",
						GoogleCode = "-"
					}
				},
				{
					"Afar",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "aa",
						GoogleCode = "-"
					}
				},
				{
					"Afrikaans",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "af"
					}
				},
				{
					"Akan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ak",
						GoogleCode = "-"
					}
				},
				{
					"Albanian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sq"
					}
				},
				{
					"Amharic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "am"
					}
				},
				{
					"Arabic",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar"
					}
				},
				{
					"Arabic/Algeria",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-DZ",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Bahrain",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-BH",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Egypt",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-EG",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Iraq",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-IQ",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Jordan",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-JO",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Kuwait",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-KW",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Lebanon",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-LB",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Libya",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-LY",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Morocco",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-MA",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Oman",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-OM",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Qatar",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-QA",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Saudi Arabia",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-SA",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Syria",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-SY",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Tunisia",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-TN",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/U.A.E.",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-AE",
						GoogleCode = "ar"
					}
				},
				{
					"Arabic/Yemen",
					new LanguageCodeDef
					{
						PluralRule = 11,
						Code = "ar-YE",
						GoogleCode = "ar"
					}
				},
				{
					"Aragonese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "an",
						GoogleCode = "-"
					}
				},
				{
					"Armenian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hy"
					}
				},
				{
					"Assamese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "as",
						GoogleCode = "-"
					}
				},
				{
					"Avaric",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "av",
						GoogleCode = "-"
					}
				},
				{
					"Avestan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ae",
						GoogleCode = "-"
					}
				},
				{
					"Aymara",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ay",
						GoogleCode = "-"
					}
				},
				{
					"Azerbaijani",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "az"
					}
				},
				{
					"Bambara",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bm",
						GoogleCode = "-"
					}
				},
				{
					"Bashkir",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ba",
						GoogleCode = "-"
					}
				},
				{
					"Basque",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "eu"
					}
				},
				{
					"Basque/Spain",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "eu-ES",
						GoogleCode = "eu"
					}
				},
				{
					"Belarusian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "be"
					}
				},
				{
					"Bengali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bn"
					}
				},
				{
					"Bihari",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bh",
						GoogleCode = "-"
					}
				},
				{
					"Bislama",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bi",
						GoogleCode = "-"
					}
				},
				{
					"Bosnian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "bs"
					}
				},
				{
					"Breton",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "br",
						GoogleCode = "-"
					}
				},
				{
					"Bulgariaa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bg"
					}
				},
				{
					"Burmese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "my"
					}
				},
				{
					"Catalan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ca"
					}
				},
				{
					"Chamorro",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ch",
						GoogleCode = "-"
					}
				},
				{
					"Chechen",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ce",
						GoogleCode = "-"
					}
				},
				{
					"Chichewa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ny"
					}
				},
				{
					"Chinese",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Hong Kong",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-HK",
						GoogleCode = "zh-TW",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Macau",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-MO",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/PRC",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-CN",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Simplified",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-CN",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Singapore",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-SG",
						GoogleCode = "zh-CN",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Taiwan",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-TW",
						GoogleCode = "zh-TW",
						HasJoinedWords = true
					}
				},
				{
					"Chinese/Traditional",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "zh-TW",
						GoogleCode = "zh-TW",
						HasJoinedWords = true
					}
				},
				{
					"Chuvash",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "cv",
						GoogleCode = "-"
					}
				},
				{
					"Cornish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kw",
						GoogleCode = "-"
					}
				},
				{
					"Corsican",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "co"
					}
				},
				{
					"Cree",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "cr",
						GoogleCode = "-"
					}
				},
				{
					"Croatian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "hr"
					}
				},
				{
					"Croatian/Bosnia and Herzegovina",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "hr-BA",
						GoogleCode = "hr"
					}
				},
				{
					"Czech",
					new LanguageCodeDef
					{
						PluralRule = 7,
						Code = "cs"
					}
				},
				{
					"Danish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "da"
					}
				},
				{
					"Divehi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "dv",
						GoogleCode = "-"
					}
				},
				{
					"Dutch",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nl"
					}
				},
				{
					"Dutch/Belgium",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nl-BE",
						GoogleCode = "nl"
					}
				},
				{
					"Dutch/Netherlands",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nl-NL",
						GoogleCode = "nl"
					}
				},
				{
					"Dzongkha",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "dz",
						GoogleCode = "-"
					}
				},
				{
					"English",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en"
					}
				},
				{
					"English/Australia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-AU",
						GoogleCode = "en"
					}
				},
				{
					"English/Belize",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-BZ",
						GoogleCode = "en"
					}
				},
				{
					"English/Canada",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-CA",
						GoogleCode = "en"
					}
				},
				{
					"English/Caribbean",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-CB",
						GoogleCode = "en"
					}
				},
				{
					"English/Ireland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-IE",
						GoogleCode = "en"
					}
				},
				{
					"English/Jamaica",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-JM",
						GoogleCode = "en"
					}
				},
				{
					"English/New Zealand",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-NZ",
						GoogleCode = "en"
					}
				},
				{
					"English/Republic of the Philippines",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-PH",
						GoogleCode = "en"
					}
				},
				{
					"English/South Africa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-ZA",
						GoogleCode = "en"
					}
				},
				{
					"English/Trinidad",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-TT",
						GoogleCode = "en"
					}
				},
				{
					"English/United Kingdom",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-GB",
						GoogleCode = "en"
					}
				},
				{
					"English/United States",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-US",
						GoogleCode = "en"
					}
				},
				{
					"English/Zimbabwe",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "en-ZW",
						GoogleCode = "en"
					}
				},
				{
					"Esperanto",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "eo"
					}
				},
				{
					"Estonian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "et"
					}
				},
				{
					"Ewe",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ee",
						GoogleCode = "-"
					}
				},
				{
					"Faeroese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fo",
						GoogleCode = "-"
					}
				},
				{
					"Fijian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fj",
						GoogleCode = "-"
					}
				},
				{
					"Finnish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fi"
					}
				},
				{
					"French",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr"
					}
				},
				{
					"French/Belgium",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-BE",
						GoogleCode = "fr"
					}
				},
				{
					"French/Canada",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-CA",
						GoogleCode = "fr"
					}
				},
				{
					"French/France",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-FR",
						GoogleCode = "fr"
					}
				},
				{
					"French/Luxembourg",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-LU",
						GoogleCode = "fr"
					}
				},
				{
					"French/Principality of Monaco",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-MC",
						GoogleCode = "fr"
					}
				},
				{
					"French/Switzerland",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "fr-CH",
						GoogleCode = "fr"
					}
				},
				{
					"Fulah",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ff",
						GoogleCode = "-"
					}
				},
				{
					"Galician",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gl"
					}
				},
				{
					"Galician/Spain",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gl-ES",
						GoogleCode = "gl"
					}
				},
				{
					"Georgian",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ka"
					}
				},
				{
					"German",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de"
					}
				},
				{
					"German/Austria",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-AT",
						GoogleCode = "de"
					}
				},
				{
					"German/Germany",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-DE",
						GoogleCode = "de"
					}
				},
				{
					"German/Liechtenstein",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-LI",
						GoogleCode = "de"
					}
				},
				{
					"German/Luxembourg",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-LU",
						GoogleCode = "de"
					}
				},
				{
					"German/Switzerland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "de-CH",
						GoogleCode = "de"
					}
				},
				{
					"Greek",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "el"
					}
				},
				{
					"Guaran",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gn",
						GoogleCode = "-"
					}
				},
				{
					"Gujarati",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gu"
					}
				},
				{
					"Haitian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ht"
					}
				},
				{
					"Hausa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ha"
					}
				},
				{
					"Hebrew",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "he",
						GoogleCode = "iw"
					}
				},
				{
					"Herero",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hz",
						GoogleCode = "-"
					}
				},
				{
					"Hindi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hi"
					}
				},
				{
					"Hiri Motu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ho",
						GoogleCode = "-"
					}
				},
				{
					"Hungarian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "hu"
					}
				},
				{
					"Interlingua",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ia",
						GoogleCode = "-"
					}
				},
				{
					"Indonesian",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "id"
					}
				},
				{
					"Interlingue",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ie",
						GoogleCode = "-"
					}
				},
				{
					"Irish",
					new LanguageCodeDef
					{
						PluralRule = 10,
						Code = "ga"
					}
				},
				{
					"Igbo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ig"
					}
				},
				{
					"Inupiaq",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ik",
						GoogleCode = "-"
					}
				},
				{
					"Ido",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "io",
						GoogleCode = "-"
					}
				},
				{
					"Icelandic",
					new LanguageCodeDef
					{
						PluralRule = 14,
						Code = "is"
					}
				},
				{
					"Italian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "it"
					}
				},
				{
					"Italian/Italy",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "it-IT",
						GoogleCode = "it"
					}
				},
				{
					"Italian/Switzerland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "it-CH",
						GoogleCode = "it"
					}
				},
				{
					"Inuktitut",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "iu",
						GoogleCode = "-"
					}
				},
				{
					"Japanese",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ja",
						HasJoinedWords = true
					}
				},
				{
					"Javanese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "jv"
					}
				},
				{
					"Kalaallisut",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kl",
						GoogleCode = "-"
					}
				},
				{
					"Kannada",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kn"
					}
				},
				{
					"Kanuri",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kr",
						GoogleCode = "-"
					}
				},
				{
					"Kashmiri",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ks",
						GoogleCode = "-"
					}
				},
				{
					"Kazakh",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kk"
					}
				},
				{
					"Central Khmer",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "km"
					}
				},
				{
					"Kikuyu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ki",
						GoogleCode = "-"
					}
				},
				{
					"Kinyarwanda",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "rw",
						GoogleCode = "-"
					}
				},
				{
					"Kirghiz",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ky"
					}
				},
				{
					"Komi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kv",
						GoogleCode = "-"
					}
				},
				{
					"Kongo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kg",
						GoogleCode = "-"
					}
				},
				{
					"Korean",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ko"
					}
				},
				{
					"Kurdish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ku"
					}
				},
				{
					"Kuanyama",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "kj",
						GoogleCode = "-"
					}
				},
				{
					"Latin",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "la"
					}
				},
				{
					"Luxembourgish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lb"
					}
				},
				{
					"Ganda",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lg",
						GoogleCode = "-"
					}
				},
				{
					"Limburgan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "li",
						GoogleCode = "-"
					}
				},
				{
					"Lingala",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ln",
						GoogleCode = "-"
					}
				},
				{
					"Lao",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lo"
					}
				},
				{
					"Latvian",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "lv"
					}
				},
				{
					"Luba-Katanga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "lu",
						GoogleCode = "-"
					}
				},
				{
					"Lithuanian",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "lt"
					}
				},
				{
					"Manx",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gv",
						GoogleCode = "-"
					}
				},
				{
					"Macedonian",
					new LanguageCodeDef
					{
						PluralRule = 13,
						Code = "mk"
					}
				},
				{
					"Malagasy",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mg"
					}
				},
				{
					"Malay",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ms"
					}
				},
				{
					"Malay/Brunei Darussalam",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ms-BN",
						GoogleCode = "ms"
					}
				},
				{
					"Malay/Malaysia",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "ms-MY",
						GoogleCode = "ms"
					}
				},
				{
					"Malayalam",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ml"
					}
				},
				{
					"Maltese",
					new LanguageCodeDef
					{
						PluralRule = 12,
						Code = "mt"
					}
				},
				{
					"Maori",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "mi"
					}
				},
				{
					"Marathi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mr"
					}
				},
				{
					"Marshallese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mh",
						GoogleCode = "-"
					}
				},
				{
					"Mongolian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "mn"
					}
				},
				{
					"Nauru",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "na",
						GoogleCode = "-"
					}
				},
				{
					"Navajo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nv",
						GoogleCode = "-"
					}
				},
				{
					"North Ndebele",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nd",
						GoogleCode = "-"
					}
				},
				{
					"Nepali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ne"
					}
				},
				{
					"Ndonga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ng",
						GoogleCode = "-"
					}
				},
				{
					"Northern Sotho",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ns",
						GoogleCode = "st"
					}
				},
				{
					"Norwegian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nb",
						GoogleCode = "no"
					}
				},
				{
					"Norwegian/Nynorsk",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nn",
						GoogleCode = "no"
					}
				},
				{
					"Sichuan Yi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ii",
						GoogleCode = "-"
					}
				},
				{
					"South Ndebele",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "nr",
						GoogleCode = "-"
					}
				},
				{
					"Occitan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "oc",
						GoogleCode = "-"
					}
				},
				{
					"Ojibwa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "oj",
						GoogleCode = "-"
					}
				},
				{
					"Church\u00a0Slavic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "cu",
						GoogleCode = "-"
					}
				},
				{
					"Oromo",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "om",
						GoogleCode = "-"
					}
				},
				{
					"Oriya",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "or",
						GoogleCode = "-"
					}
				},
				{
					"Ossetian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "os",
						GoogleCode = "-"
					}
				},
				{
					"Pali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pi",
						GoogleCode = "-"
					}
				},
				{
					"Pashto",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ps"
					}
				},
				{
					"Persian",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "fa"
					}
				},
				{
					"Polish",
					new LanguageCodeDef
					{
						PluralRule = 8,
						Code = "pl"
					}
				},
				{
					"Portuguese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pt"
					}
				},
				{
					"Portuguese/Brazil",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "pt-BR",
						GoogleCode = "pt"
					}
				},
				{
					"Portuguese/Portugal",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pt-PT",
						GoogleCode = "pt"
					}
				},
				{
					"Punjabi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "pa"
					}
				},
				{
					"Quechua",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu",
						GoogleCode = "-"
					}
				},
				{
					"Quechua/Bolivia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu-BO",
						GoogleCode = "-"
					}
				},
				{
					"Quechua/Ecuador",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu-EC",
						GoogleCode = "-"
					}
				},
				{
					"Quechua/Peru",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "qu-PE",
						GoogleCode = "-"
					}
				},
				{
					"Rhaeto-Romanic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "rm",
						GoogleCode = "ro"
					}
				},
				{
					"Romanian",
					new LanguageCodeDef
					{
						PluralRule = 4,
						Code = "ro"
					}
				},
				{
					"Rundi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "rn",
						GoogleCode = "-"
					}
				},
				{
					"Russian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "ru"
					}
				},
				{
					"Russian/Republic of Moldova",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "ru-MO",
						GoogleCode = "ru"
					}
				},
				{
					"Sanskrit",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sa",
						GoogleCode = "-"
					}
				},
				{
					"Sardinian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sc",
						GoogleCode = "-"
					}
				},
				{
					"Sindhi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sd"
					}
				},
				{
					"Northern Sami",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "se",
						GoogleCode = "-"
					}
				},
				{
					"Samoan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sm"
					}
				},
				{
					"Sango",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sg",
						GoogleCode = "-"
					}
				},
				{
					"Serbian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "sr"
					}
				},
				{
					"Serbian/Bosnia and Herzegovina",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "sr-BA",
						GoogleCode = "sr"
					}
				},
				{
					"Serbian/Serbia and Montenegro",
					new LanguageCodeDef
					{
						PluralRule = 5,
						Code = "sr-SP",
						GoogleCode = "sr"
					}
				},
				{
					"Scottish Gaelic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "gd"
					}
				},
				{
					"Shona",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sn"
					}
				},
				{
					"Sinhala",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "si"
					}
				},
				{
					"Slovak",
					new LanguageCodeDef
					{
						PluralRule = 7,
						Code = "sk"
					}
				},
				{
					"Slovenian",
					new LanguageCodeDef
					{
						PluralRule = 9,
						Code = "sl"
					}
				},
				{
					"Somali",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "so"
					}
				},
				{
					"Southern Sotho",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "st"
					}
				},
				{
					"Spanish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es"
					}
				},
				{
					"Spanish/Argentina",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-AR",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Bolivia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-BO",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Castilian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-ES",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Chile",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-CL",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Colombia",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-CO",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Costa Rica",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-CR",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Dominican Republic",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-DO",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Ecuador",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-EC",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/El Salvador",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-SV",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Guatemala",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-GT",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Honduras",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-HN",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Mexico",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-MX",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Nicaragua",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-NI",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Panama",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PA",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Paraguay",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PY",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Peru",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PE",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Puerto Rico",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-PR",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Spain",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-ES",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Uruguay",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-UY",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Venezuela",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-VE",
						GoogleCode = "es"
					}
				},
				{
					"Spanish/Latin Americas",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "es-US",
						GoogleCode = "es"
					}
				},
				{
					"Sundanese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "su"
					}
				},
				{
					"Swahili",
					new LanguageCodeDef
					{
						Code = "sw"
					}
				},
				{
					"Swati",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ss",
						GoogleCode = "-"
					}
				},
				{
					"Swedish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sv"
					}
				},
				{
					"Swedish/Finland",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sv-FI",
						GoogleCode = "sv"
					}
				},
				{
					"Swedish/Sweden",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "sv-SE",
						GoogleCode = "sv"
					}
				},
				{
					"Tamil",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ta"
					}
				},
				{
					"Tatar",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "tt",
						GoogleCode = "-"
					}
				},
				{
					"Telugu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "te"
					}
				},
				{
					"Tajik",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tg"
					}
				},
				{
					"Thai",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "th",
						HasJoinedWords = true
					}
				},
				{
					"Tigrinya",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ti",
						GoogleCode = "-"
					}
				},
				{
					"Tibetan",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "bo",
						GoogleCode = "-"
					}
				},
				{
					"Turkmen",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tk",
						GoogleCode = "-"
					}
				},
				{
					"Tagalog",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tl"
					}
				},
				{
					"Tswana",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tn",
						GoogleCode = "-"
					}
				},
				{
					"Tonga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "to",
						GoogleCode = "-"
					}
				},
				{
					"Turkish",
					new LanguageCodeDef
					{
						PluralRule = 0,
						Code = "tr"
					}
				},
				{
					"Tsonga",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ts",
						GoogleCode = "-"
					}
				},
				{
					"Twi",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "tw",
						GoogleCode = "-"
					}
				},
				{
					"Tahitian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ty",
						GoogleCode = "-"
					}
				},
				{
					"Uighur",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ug",
						GoogleCode = "-"
					}
				},
				{
					"Ukrainian",
					new LanguageCodeDef
					{
						PluralRule = 6,
						Code = "uk"
					}
				},
				{
					"Urdu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ur"
					}
				},
				{
					"Uzbek",
					new LanguageCodeDef
					{
						PluralRule = 2,
						Code = "uz"
					}
				},
				{
					"Venda",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "ve",
						GoogleCode = "-"
					}
				},
				{
					"Vietnamese",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "vi"
					}
				},
				{
					"Volapk",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "vo",
						GoogleCode = "-"
					}
				},
				{
					"Walloon",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "wa",
						GoogleCode = "-"
					}
				},
				{
					"Welsh",
					new LanguageCodeDef
					{
						PluralRule = 16,
						Code = "cy"
					}
				},
				{
					"Wolof",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "wo",
						GoogleCode = "-"
					}
				},
				{
					"Frisian",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "fy"
					}
				},
				{
					"Xhosa",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "xh"
					}
				},
				{
					"Yiddish",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "yi"
					}
				},
				{
					"Yoruba",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "yo"
					}
				},
				{
					"Zhuang",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "za",
						GoogleCode = "-"
					}
				},
				{
					"Zulu",
					new LanguageCodeDef
					{
						PluralRule = 1,
						Code = "zu"
					}
				}
			};

			public static string GetLanguageCode(string Filter, bool ShowWarnings = false)
			{
				if (string.IsNullOrEmpty(Filter))
				{
					return string.Empty;
				}
				string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (LanguageMatchesFilter(item.Key, filters))
					{
						return item.Value.Code;
					}
				}
				if (ShowWarnings)
				{
					UnityEngine.Debug.Log("Language '" + Filter + "' not recognized. Please, add the language code to GoogleTranslation.cs");
				}
				return string.Empty;
			}

			public static List<string> GetLanguagesForDropdown(string Filter, string CodesToExclude)
			{
				string[] filters = Filter.ToLowerInvariant().Split(" /(),".ToCharArray());
				List<string> list = new List<string>();
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (string.IsNullOrEmpty(Filter) || LanguageMatchesFilter(item.Key, filters))
					{
						string text = string.Concat("[" + item.Value.Code + "]");
						if (!CodesToExclude.Contains(text))
						{
							list.Add(item.Key + " " + text);
						}
					}
				}
				for (int num = list.Count - 2; num >= 0; num--)
				{
					string text2 = list[num].Substring(0, list[num].IndexOf(" ["));
					if (list[num + 1].StartsWith(text2, StringComparison.Ordinal))
					{
						list[num] = text2 + "/" + list[num];
						list.Insert(num + 1, text2 + "/");
					}
				}
				return list;
			}

			private static bool LanguageMatchesFilter(string Language, string[] Filters)
			{
				Language = Language.ToLowerInvariant();
				int i = 0;
				for (int num = Filters.Length; i < num; i++)
				{
					if (Filters[i] != "")
					{
						if (!Language.Contains(Filters[i].ToLower()))
						{
							return false;
						}
						Language = Language.Remove(Language.IndexOf(Filters[i], StringComparison.Ordinal), Filters[i].Length);
					}
				}
				return true;
			}

			public static string GetFormatedLanguageName(string Language)
			{
				string empty = string.Empty;
				int num = Language.IndexOf(" [", StringComparison.Ordinal);
				if (num > 0)
				{
					Language = Language.Substring(0, num);
				}
				num = Language.IndexOf('/');
				if (num > 0)
				{
					empty = Language.Substring(0, num);
					if (Language == empty + "/" + empty)
					{
						return empty;
					}
					Language = Language.Replace("/", " (") + ")";
				}
				return Language;
			}

			public static string GetCodedLanguage(string Language, string code)
			{
				string languageCode = GetLanguageCode(Language);
				if (string.Compare(code, languageCode, StringComparison.OrdinalIgnoreCase) == 0)
				{
					return Language;
				}
				return Language + " [" + code + "]";
			}

			public static void UnPackCodeFromLanguageName(string CodedLanguage, out string Language, out string code)
			{
				if (string.IsNullOrEmpty(CodedLanguage))
				{
					Language = string.Empty;
					code = string.Empty;
					return;
				}
				int num = CodedLanguage.IndexOf("[", StringComparison.Ordinal);
				if (num < 0)
				{
					Language = CodedLanguage;
					code = GetLanguageCode(Language);
				}
				else
				{
					Language = CodedLanguage.Substring(0, num).Trim();
					code = CodedLanguage.Substring(num + 1, CodedLanguage.IndexOf("]", num, StringComparison.Ordinal) - num - 1);
				}
			}

			public static string GetGoogleLanguageCode(string InternationalCode)
			{
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (InternationalCode == item.Value.Code)
					{
						if (item.Value.GoogleCode == "-")
						{
							return null;
						}
						return (!string.IsNullOrEmpty(item.Value.GoogleCode)) ? item.Value.GoogleCode : InternationalCode;
					}
				}
				return InternationalCode;
			}

			public static string GetLanguageName(string code, bool useParenthesesForRegion = false, bool allowDiscardRegion = true)
			{
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (!(code == item.Value.Code))
					{
						continue;
					}
					string text = item.Key;
					if (useParenthesesForRegion)
					{
						int num = text.IndexOf('/');
						if (num > 0)
						{
							text = text.Substring(0, num) + " (" + text.Substring(num + 1) + ")";
						}
					}
					return text;
				}
				if (allowDiscardRegion)
				{
					int num2 = code.IndexOf("-", StringComparison.Ordinal);
					if (num2 > 0)
					{
						return GetLanguageName(code.Substring(0, num2), useParenthesesForRegion, allowDiscardRegion: false);
					}
				}
				return null;
			}

			public static List<string> GetAllInternationalCodes()
			{
				HashSet<string> hashSet = new HashSet<string>(StringComparer.Ordinal);
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					hashSet.Add(item.Value.Code);
				}
				return new List<string>(hashSet);
			}

			public static bool LanguageCode_HasJoinedWord(string languageCode)
			{
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (languageCode == item.Value.GoogleCode || languageCode == item.Value.Code)
					{
						return item.Value.HasJoinedWords;
					}
				}
				return false;
			}

			private static int GetPluralRule(string langCode)
			{
				if (langCode.Length > 2)
				{
					langCode = langCode.Substring(0, 2);
				}
				langCode = langCode.ToLower();
				foreach (KeyValuePair<string, LanguageCodeDef> item in mLanguageDef)
				{
					if (item.Value.Code == langCode)
					{
						return item.Value.PluralRule;
					}
				}
				return 0;
			}

			public static bool LanguageHasPluralType(string langCode, string pluralType)
			{
				switch (pluralType)
				{
				case "Plural":
				case "Zero":
				case "One":
					return true;
				default:
					switch (GetPluralRule(langCode))
					{
					case 3:
						if (!(pluralType == "Two"))
						{
							return pluralType == "Few";
						}
						return true;
					case 4:
					case 5:
					case 6:
					case 7:
					case 8:
						return pluralType == "Few";
					case 9:
						if (!(pluralType == "Two"))
						{
							return pluralType == "Few";
						}
						return true;
					case 10:
					case 11:
					case 15:
					case 16:
						if (!(pluralType == "Two") && !(pluralType == "Few"))
						{
							return pluralType == "Many";
						}
						return true;
					case 12:
						if (!(pluralType == "Few"))
						{
							return pluralType == "Many";
						}
						return true;
					case 13:
						return pluralType == "Two";
					default:
						return false;
					}
				}
			}

			public static ePluralType GetPluralType(string langCode, int n)
			{
				switch (n)
				{
				case 0:
					return ePluralType.Zero;
				case 1:
					return ePluralType.One;
				default:
					switch (GetPluralRule(langCode))
					{
					case 0:
						return ePluralType.Plural;
					case 1:
						if (n != 1)
						{
							return ePluralType.Plural;
						}
						return ePluralType.One;
					case 2:
						if (n > 1)
						{
							return ePluralType.Plural;
						}
						return ePluralType.One;
					case 3:
						switch (n)
						{
						default:
							if (!inRange(n, 3, 10) && !inRange(n, 13, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						case 2:
						case 12:
							return ePluralType.Two;
						case 1:
						case 11:
							return ePluralType.One;
						}
					case 4:
						if (n != 1)
						{
							if (!inRange(n % 100, 1, 19))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 5:
						if (n % 10 != 1 || n % 100 == 11)
						{
							if (n % 10 < 2 || (n % 100 >= 10 && n % 100 < 20))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 6:
						if (n % 10 != 1 || n % 100 == 11)
						{
							if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 7:
						if (n != 1)
						{
							if (!inRange(n, 2, 4))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 8:
						if (n != 1)
						{
							if (!inRange(n % 10, 2, 4) || inRange(n % 100, 12, 14))
							{
								return ePluralType.Plural;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 9:
						if (n % 100 != 1)
						{
							if (n % 100 != 2)
							{
								if (!inRange(n % 100, 3, 4))
								{
									return ePluralType.Plural;
								}
								return ePluralType.Few;
							}
							return ePluralType.Two;
						}
						return ePluralType.One;
					case 10:
						switch (n)
						{
						default:
							if (!inRange(n, 3, 6))
							{
								if (!inRange(n, 7, 10))
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						case 2:
							return ePluralType.Two;
						case 1:
							return ePluralType.One;
						}
					case 11:
						switch (n)
						{
						default:
							if (!inRange(n % 100, 3, 10))
							{
								if (n % 100 < 11)
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						case 2:
							return ePluralType.Two;
						case 1:
							return ePluralType.One;
						case 0:
							return ePluralType.Zero;
						}
					case 12:
						if (n != 1)
						{
							if (!inRange(n % 100, 1, 10))
							{
								if (!inRange(n % 100, 11, 19))
								{
									return ePluralType.Plural;
								}
								return ePluralType.Many;
							}
							return ePluralType.Few;
						}
						return ePluralType.One;
					case 13:
						if (n % 10 != 1)
						{
							if (n % 10 != 2)
							{
								return ePluralType.Plural;
							}
							return ePluralType.Two;
						}
						return ePluralType.One;
					case 14:
						if (n % 10 != 1 || n % 100 == 11)
						{
							return ePluralType.Plural;
						}
						return ePluralType.One;
					case 15:
						if (n % 10 != 1 || n % 100 == 11 || n % 100 == 71 || n % 100 == 91)
						{
							if (n % 10 != 2 || n % 100 == 12 || n % 100 == 72 || n % 100 == 92)
							{
								if ((n % 10 != 3 && n % 10 != 4 && n % 10 != 9) || n % 100 == 13 || n % 100 == 14 || n % 100 == 19 || n % 100 == 73 || n % 100 == 74 || n % 100 == 79 || n % 100 == 93 || n % 100 == 94 || n % 100 == 99)
								{
									if (n % 1000000 != 0)
									{
										return ePluralType.Plural;
									}
									return ePluralType.Many;
								}
								return ePluralType.Few;
							}
							return ePluralType.Two;
						}
						return ePluralType.One;
					case 16:
						return n switch
						{
							6 => ePluralType.Many, 
							3 => ePluralType.Few, 
							2 => ePluralType.Two, 
							1 => ePluralType.One, 
							0 => ePluralType.Zero, 
							_ => ePluralType.Plural, 
						};
					default:
						return ePluralType.Plural;
					}
				}
			}

			public static int GetPluralTestNumber(string langCode, ePluralType pluralType)
			{
				switch (pluralType)
				{
				case ePluralType.Zero:
					return 0;
				case ePluralType.One:
					return 1;
				case ePluralType.Few:
					return 3;
				case ePluralType.Many:
					switch (GetPluralRule(langCode))
					{
					case 10:
						return 8;
					case 11:
					case 12:
						return 13;
					case 15:
						return 1000000;
					default:
						return 6;
					}
				default:
					return 936;
				}
			}

			private static bool inRange(int amount, int min, int max)
			{
				if (amount >= min)
				{
					return amount <= max;
				}
				return false;
			}
		}
		public static class GoogleTranslation
		{
			public delegate void fnOnTranslated(string Translation, string Error);

			public delegate void fnOnTranslationReady(Dictionary<string, TranslationQuery> dict, string error);

			private static List<UnityWebRequest> mCurrentTranslations = new List<UnityWebRequest>();

			private static List<TranslationJob> mTranslationJobs = new List<TranslationJob>();

			public static bool CanTranslate()
			{
				if (LocalizationManager.Sources.Count > 0)
				{
					return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL());
				}
				return false;
			}

			public static void Translate(string text, string LanguageCodeFrom, string LanguageCodeTo, fnOnTranslated OnTranslationReady)
			{
				LocalizationManager.InitializeIfNeeded();
				if (!CanTranslate())
				{
					OnTranslationReady(null, "WebService is not set correctly or needs to be reinstalled");
					return;
				}
				if (LanguageCodeTo == LanguageCodeFrom)
				{
					OnTranslationReady(text, null);
					return;
				}
				Dictionary<string, TranslationQuery> queries = new Dictionary<string, TranslationQuery>(StringComparer.Ordinal);
				if (string.IsNullOrEmpty(LanguageCodeTo))
				{
					OnTranslationReady(string.Empty, null);
					return;
				}
				CreateQueries(text, LanguageCodeFrom, LanguageCodeTo, queries);
				Translate(queries, delegate(Dictionary<string, TranslationQuery> results, string error)
				{
					if (!string.IsNullOrEmpty(error) || results.Count == 0)
					{
						OnTranslationReady(null, error);
					}
					else
					{
						string translation = RebuildTranslation(text, queries, LanguageCodeTo);
						OnTranslationReady(translation, null);
					}
				});
			}

			public static string ForceTranslate(string text, string LanguageCodeFrom, string LanguageCodeTo)
			{
				Dictionary<string, TranslationQuery> dictionary = new Dictionary<string, TranslationQuery>(StringComparer.Ordinal);
				AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dictionary);
				TranslationJob_Main translationJob_Main = new TranslationJob_Main(dictionary, null);
				while (true)
				{
					switch (translationJob_Main.GetState())
					{
					case TranslationJob.eJobState.Running:
						break;
					case TranslationJob.eJobState.Failed:
						return null;
					default:
						return GetQueryResult(text, "", dictionary);
					}
				}
			}

			public static void Translate(Dictionary<string, TranslationQuery> requests, fnOnTranslationReady OnTranslationReady, bool usePOST = true)
			{
				AddTranslationJob(new TranslationJob_Main(requests, OnTranslationReady));
			}

			public static bool ForceTranslate(Dictionary<string, TranslationQuery> requests, bool usePOST = true)
			{
				TranslationJob_Main translationJob_Main = new TranslationJob_Main(requests, null);
				while (true)
				{
					switch (translationJob_Main.GetState())
					{
					case TranslationJob.eJobState.Running:
						break;
					case TranslationJob.eJobState.Failed:
						return false;
					default:
						return true;
					}
				}
			}

			public static List<string> ConvertTranslationRequest(Dictionary<string, TranslationQuery> requests, bool encodeGET)
			{
				List<string> list = new List<string>();
				StringBuilder stringBuilder = new StringBuilder();
				foreach (KeyValuePair<string, TranslationQuery> request in requests)
				{
					TranslationQuery value = request.Value;
					if (stringBuilder.Length > 0)
					{
						stringBuilder.Append("<I2Loc>");
					}
					stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.LanguageCode));
					stringBuilder.Append(":");
					for (int i = 0; i < value.TargetLanguagesCode.Length; i++)
					{
						if (i != 0)
						{
							stringBuilder.Append(",");
						}
						stringBuilder.Append(GoogleLanguages.GetGoogleLanguageCode(value.TargetLanguagesCode[i]));
					}
					stringBuilder.Append("=");
					string text = ((TitleCase(value.Text) == value.Text) ? value.Text.ToLowerInvariant() : value.Text);
					if (!encodeGET)
					{
						stringBuilder.Append(text);
						continue;
					}
					stringBuilder.Append(Uri.EscapeDataString(text));
					if (stringBuilder.Length > 4000)
					{
						list.Add(stringBuilder.ToString());
						stringBuilder.Length = 0;
					}
				}
				list.Add(stringBuilder.ToString());
				return list;
			}

			private static void AddTranslationJob(TranslationJob job)
			{
				mTranslationJobs.Add(job);
				if (mTranslationJobs.Count == 1)
				{
					CoroutineManager.Start(WaitForTranslations());
				}
			}

			private static IEnumerator WaitForTranslations()
			{
				while (mTranslationJobs.Count > 0)
				{
					TranslationJob[] array = mTranslationJobs.ToArray();
					foreach (TranslationJob translationJob in array)
					{
						if (translationJob.GetState() != 0)
						{
							mTranslationJobs.Remove(translationJob);
						}
					}
					yield return null;
				}
			}

			public static string ParseTranslationResult(string html, Dictionary<string, TranslationQuery> requests)
			{
				if (html.StartsWith("<!DOCTYPE html>") || html.StartsWith("<HTML>"))
				{
					if (html.Contains("The script completed but did not return anything"))
					{
						return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
					}
					if (html.Contains("Service invoked too many times in a short time"))
					{
						return "";
					}
					return "There was a problem contacting the WebService. Please try again later\n" + html;
				}
				string[] array = html.Split(new string[1] { "<I2Loc>" }, StringSplitOptions.None);
				string[] separator = new string[1] { "<i2>" };
				int num = 0;
				string[] array2 = requests.Keys.ToArray();
				foreach (string text in array2)
				{
					TranslationQuery value = FindQueryFromOrigText(text, requests);
					string text2 = array[num++];
					if (value.Tags != null)
					{
						for (int num2 = value.Tags.Length - 1; num2 >= 0; num2--)
						{
							text2 = text2.Replace(GetGoogleNoTranslateTag(num2), value.Tags[num2]);
						}
					}
					value.Results = text2.Split(separator, StringSplitOptions.None);
					if (TitleCase(text) == text)
					{
						for (int j = 0; j < value.Results.Length; j++)
						{
							value.Results[j] = TitleCase(value.Results[j]);
						}
					}
					requests[value.OrigText] = value;
				}
				return null;
			}

			public static bool IsTranslating()
			{
				if (mCurrentTranslations.Count <= 0)
				{
					return mTranslationJobs.Count > 0;
				}
				return true;
			}

			public static void CancelCurrentGoogleTranslations()
			{
				mCurrentTranslations.Clear();
				foreach (TranslationJob mTranslationJob in mTranslationJobs)
				{
					mTranslationJob.Dispose();
				}
				mTranslationJobs.Clear();
			}

			public static void CreateQueries(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (!text.Contains("[i2s_"))
				{
					CreateQueries_Plurals(text, LanguageCodeFrom, LanguageCodeTo, dict);
					return;
				}
				foreach (KeyValuePair<string, string> specialization in SpecializationManager.GetSpecializations(text))
				{
					CreateQueries_Plurals(specialization.Value, LanguageCodeFrom, LanguageCodeTo, dict);
				}
			}

			private static void CreateQueries_Plurals(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				bool flag = text.Contains("{[#");
				bool flag2 = text.Contains("[i2p_");
				if (!HasParameters(text) || (!flag && !flag2))
				{
					AddQuery(text, LanguageCodeFrom, LanguageCodeTo, dict);
					return;
				}
				bool forceTag = flag;
				for (ePluralType ePluralType2 = ePluralType.Zero; ePluralType2 <= ePluralType.Plural; ePluralType2++)
				{
					string pluralType = ePluralType2.ToString();
					if (GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, pluralType))
					{
						string text2 = GetPluralText(text, pluralType);
						int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
						string pluralParameter = GetPluralParameter(text2, forceTag);
						if (!string.IsNullOrEmpty(pluralParameter))
						{
							text2 = text2.Replace(pluralParameter, pluralTestNumber.ToString());
						}
						AddQuery(text2, LanguageCodeFrom, LanguageCodeTo, dict);
					}
				}
			}

			public static void AddQuery(string text, string LanguageCodeFrom, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (string.IsNullOrEmpty(text))
				{
					return;
				}
				if (!dict.ContainsKey(text))
				{
					TranslationQuery translationQuery = default(TranslationQuery);
					translationQuery.OrigText = text;
					translationQuery.LanguageCode = LanguageCodeFrom;
					translationQuery.TargetLanguagesCode = new string[1] { LanguageCodeTo };
					TranslationQuery query = translationQuery;
					query.Text = text;
					ParseNonTranslatableElements(ref query);
					dict[text] = query;
				}
				else
				{
					TranslationQuery value = dict[text];
					if (Array.IndexOf(value.TargetLanguagesCode, LanguageCodeTo) < 0)
					{
						value.TargetLanguagesCode = value.TargetLanguagesCode.Concat(new string[1] { LanguageCodeTo }).Distinct().ToArray();
					}
					dict[text] = value;
				}
			}

			private static string GetTranslation(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (!dict.ContainsKey(text))
				{
					return null;
				}
				TranslationQuery translationQuery = dict[text];
				int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
				if (num < 0)
				{
					return "";
				}
				if (translationQuery.Results == null)
				{
					return "";
				}
				return translationQuery.Results[num];
			}

			private static TranslationQuery FindQueryFromOrigText(string origText, Dictionary<string, TranslationQuery> dict)
			{
				foreach (KeyValuePair<string, TranslationQuery> item in dict)
				{
					if (item.Value.OrigText == origText)
					{
						return item.Value;
					}
				}
				return default(TranslationQuery);
			}

			public static bool HasParameters(string text)
			{
				int num = text.IndexOf("{[", StringComparison.Ordinal);
				if (num < 0)
				{
					return false;
				}
				return text.IndexOf("]}", num, StringComparison.Ordinal) > 0;
			}

			public static string GetPluralParameter(string text, bool forceTag)
			{
				int num = text.IndexOf("{[#", StringComparison.Ordinal);
				if (num < 0)
				{
					if (forceTag)
					{
						return null;
					}
					num = text.IndexOf("{[", StringComparison.Ordinal);
				}
				if (num < 0)
				{
					return null;
				}
				int num2 = text.IndexOf("]}", num + 2, StringComparison.Ordinal);
				if (num2 < 0)
				{
					return null;
				}
				return text.Substring(num, num2 - num + 2);
			}

			public static string GetPluralText(string text, string pluralType)
			{
				pluralType = "[i2p_" + pluralType + "]";
				int num = text.IndexOf(pluralType, StringComparison.Ordinal);
				if (num >= 0)
				{
					num += pluralType.Length;
					int num2 = text.IndexOf("[i2p_", num, StringComparison.Ordinal);
					if (num2 < 0)
					{
						num2 = text.Length;
					}
					return text.Substring(num, num2 - num);
				}
				num = text.IndexOf("[i2p_", StringComparison.Ordinal);
				if (num < 0)
				{
					return text;
				}
				if (num > 0)
				{
					return text.Substring(0, num);
				}
				num = text.IndexOf("]", StringComparison.Ordinal);
				if (num < 0)
				{
					return text;
				}
				num++;
				int num3 = text.IndexOf("[i2p_", num, StringComparison.Ordinal);
				if (num3 < 0)
				{
					num3 = text.Length;
				}
				return text.Substring(num, num3 - num);
			}

			private static int FindClosingTag(string tag, MatchCollection matches, int startIndex)
			{
				int i = startIndex;
				for (int count = matches.Count; i < count; i++)
				{
					string captureMatch = I2Utils.GetCaptureMatch(matches[i]);
					if (captureMatch[0] == '/' && tag.StartsWith(captureMatch.Substring(1), StringComparison.Ordinal))
					{
						return i;
					}
				}
				return -1;
			}

			private static string GetGoogleNoTranslateTag(int tagNumber)
			{
				if (tagNumber < 70)
				{
					return "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++".Substring(0, tagNumber + 1);
				}
				string text = "";
				for (int i = -1; i < tagNumber; i++)
				{
					text += "+";
				}
				return text;
			}

			private static void ParseNonTranslatableElements(ref TranslationQuery query)
			{
				MatchCollection matchCollection = Regex.Matches(query.Text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>");
				if (matchCollection == null || matchCollection.Count == 0)
				{
					return;
				}
				string text = query.Text;
				List<string> list = new List<string>();
				int i = 0;
				for (int count = matchCollection.Count; i < count; i++)
				{
					string captureMatch = I2Utils.GetCaptureMatch(matchCollection[i]);
					int num = FindClosingTag(captureMatch, matchCollection, i);
					if (num < 0)
					{
						string text2 = matchCollection[i].ToString();
						if (text2.StartsWith("{[", StringComparison.Ordinal) && text2.EndsWith("]}", StringComparison.Ordinal))
						{
							text = text.Replace(text2, GetGoogleNoTranslateTag(list.Count) + " ");
							list.Add(text2);
						}
					}
					else if (captureMatch == "i2nt")
					{
						string text3 = query.Text.Substring(matchCollection[i].Index, matchCollection[num].Index - matchCollection[i].Index + matchCollection[num].Length);
						text = text.Replace(text3, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text3);
					}
					else
					{
						string text4 = matchCollection[i].ToString();
						text = text.Replace(text4, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text4);
						string text5 = matchCollection[num].ToString();
						text = text.Replace(text5, GetGoogleNoTranslateTag(list.Count) + " ");
						list.Add(text5);
					}
				}
				query.Text = text;
				query.Tags = list.ToArray();
			}

			public static string GetQueryResult(string text, string LanguageCodeTo, Dictionary<string, TranslationQuery> dict)
			{
				if (!dict.ContainsKey(text))
				{
					return null;
				}
				TranslationQuery translationQuery = dict[text];
				if (translationQuery.Results == null || translationQuery.Results.Length < 0)
				{
					return null;
				}
				if (string.IsNullOrEmpty(LanguageCodeTo))
				{
					return translationQuery.Results[0];
				}
				int num = Array.IndexOf(translationQuery.TargetLanguagesCode, LanguageCodeTo);
				if (num < 0)
				{
					return null;
				}
				return translationQuery.Results[num];
			}

			public static string RebuildTranslation(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
			{
				if (!text.Contains("[i2s_"))
				{
					return RebuildTranslation_Plural(text, dict, LanguageCodeTo);
				}
				Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
				Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.Ordinal);
				foreach (KeyValuePair<string, string> item in specializations)
				{
					dictionary[item.Key] = RebuildTranslation_Plural(item.Value, dict, LanguageCodeTo);
				}
				return SpecializationManager.SetSpecializedText(dictionary);
			}

			private static string RebuildTranslation_Plural(string text, Dictionary<string, TranslationQuery> dict, string LanguageCodeTo)
			{
				bool flag = text.Contains("{[#");
				bool flag2 = text.Contains("[i2p_");
				if (!HasParameters(text) || (!flag && !flag2))
				{
					return GetTranslation(text, LanguageCodeTo, dict);
				}
				StringBuilder stringBuilder = new StringBuilder();
				string text2 = null;
				bool forceTag = flag;
				for (ePluralType ePluralType2 = ePluralType.Plural; ePluralType2 >= ePluralType.Zero; ePluralType2--)
				{
					string text3 = ePluralType2.ToString();
					if (!GoogleLanguages.LanguageHasPluralType(LanguageCodeTo, text3))
					{
						continue;
					}
					string text4 = GetPluralText(text, text3);
					int pluralTestNumber = GoogleLanguages.GetPluralTestNumber(LanguageCodeTo, ePluralType2);
					string pluralParameter = GetPluralParameter(text4, forceTag);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text4 = text4.Replace(pluralParameter, pluralTestNumber.ToString());
					}
					string text5 = GetTranslation(text4, LanguageCodeTo, dict);
					if (!string.IsNullOrEmpty(pluralParameter))
					{
						text5 = text5.Replace(pluralTestNumber.ToString(), pluralParameter);
					}
					if (ePluralType2 == ePluralType.Plural)
					{
						text2 = text5;
					}
					else
					{
						if (text5 == text2)
						{
							continue;
						}
						stringBuilder.AppendFormat("[i2p_{0}]", text3);
					}
					stringBuilder.Append(text5);
				}
				return stringBuilder.ToString();
			}

			public static string UppercaseFirst(string s)
			{
				if (string.IsNullOrEmpty(s))
				{
					return string.Empty;
				}
				char[] array = s.ToLower().ToCharArray();
				array[0] = char.ToUpper(array[0]);
				return new string(array);
			}

			public static string TitleCase(string s)
			{
				if (string.IsNullOrEmpty(s))
				{
					return string.Empty;
				}
				return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s);
			}
		}
		public struct TranslationQuery
		{
			public string OrigText;

			public string Text;

			public string LanguageCode;

			public string[] TargetLanguagesCode;

			public string[] Results;

			public string[] Tags;
		}
		public class TranslationJob : IDisposable
		{
			public enum eJobState
			{
				Running,
				Succeeded,
				Failed
			}

			public eJobState mJobState;

			public virtual eJobState GetState()
			{
				return mJobState;
			}

			public virtual void Dispose()
			{
			}
		}
		public class TranslationJob_WWW : TranslationJob
		{
			public UnityWebRequest www;

			public override void Dispose()
			{
				if (www != null)
				{
					www.Dispose();
				}
				www = null;
			}
		}
		public class TranslationJob_GET : TranslationJob_WWW
		{
			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			private List<string> mQueries;

			public string mErrorMessage;

			public TranslationJob_GET(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				mQueries = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: true);
				GetState();
			}

			private void ExecuteNextQuery()
			{
				if (mQueries.Count == 0)
				{
					mJobState = eJobState.Succeeded;
					return;
				}
				int index = mQueries.Count - 1;
				string text = mQueries[index];
				mQueries.RemoveAt(index);
				string uri = LocalizationManager.GetWebServiceURL() + "?action=Translate&list=" + text;
				www = UnityWebRequest.Get(uri);
				I2Utils.SendWebRequest(www);
			}

			public override eJobState GetState()
			{
				if (www != null && www.isDone)
				{
					ProcessResult(www.downloadHandler.data, www.error);
					www.Dispose();
					www = null;
				}
				if (www == null)
				{
					ExecuteNextQuery();
				}
				return mJobState;
			}

			public void ProcessResult(byte[] bytes, string errorMsg)
			{
				if (string.IsNullOrEmpty(errorMsg))
				{
					errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
					if (string.IsNullOrEmpty(errorMsg))
					{
						if (_OnTranslationReady != null)
						{
							_OnTranslationReady(_requests, null);
						}
						return;
					}
				}
				mJobState = eJobState.Failed;
				mErrorMessage = errorMsg;
			}
		}
		public class TranslationJob_Main : TranslationJob
		{
			private TranslationJob_WEB mWeb;

			private TranslationJob_POST mPost;

			private TranslationJob_GET mGet;

			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			public string mErrorMessage;

			public TranslationJob_Main(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				mPost = new TranslationJob_POST(requests, OnTranslationReady);
			}

			public override eJobState GetState()
			{
				if (mWeb != null)
				{
					switch (mWeb.GetState())
					{
					case eJobState.Running:
						return eJobState.Running;
					case eJobState.Succeeded:
						mJobState = eJobState.Succeeded;
						break;
					case eJobState.Failed:
						mWeb.Dispose();
						mWeb = null;
						mPost = new TranslationJob_POST(_requests, _OnTranslationReady);
						break;
					}
				}
				if (mPost != null)
				{
					switch (mPost.GetState())
					{
					case eJobState.Running:
						return eJobState.Running;
					case eJobState.Succeeded:
						mJobState = eJobState.Succeeded;
						break;
					case eJobState.Failed:
						mPost.Dispose();
						mPost = null;
						mGet = new TranslationJob_GET(_requests, _OnTranslationReady);
						break;
					}
				}
				if (mGet != null)
				{
					switch (mGet.GetState())
					{
					case eJobState.Running:
						return eJobState.Running;
					case eJobState.Succeeded:
						mJobState = eJobState.Succeeded;
						break;
					case eJobState.Failed:
						mErrorMessage = mGet.mErrorMessage;
						if (_OnTranslationReady != null)
						{
							_OnTranslationReady(_requests, mErrorMessage);
						}
						mGet.Dispose();
						mGet = null;
						break;
					}
				}
				return mJobState;
			}

			public override void Dispose()
			{
				if (mPost != null)
				{
					mPost.Dispose();
				}
				if (mGet != null)
				{
					mGet.Dispose();
				}
				mPost = null;
				mGet = null;
			}
		}
		public class TranslationJob_POST : TranslationJob_WWW
		{
			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			public TranslationJob_POST(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				List<string> list = GoogleTranslation.ConvertTranslationRequest(requests, encodeGET: false);
				WWWForm wWWForm = new WWWForm();
				wWWForm.AddField("action", "Translate");
				wWWForm.AddField("list", list[0]);
				www = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(), wWWForm);
				I2Utils.SendWebRequest(www);
			}

			public override eJobState GetState()
			{
				if (www != null && www.isDone)
				{
					ProcessResult(www.downloadHandler.data, www.error);
					www.Dispose();
					www = null;
				}
				return mJobState;
			}

			public void ProcessResult(byte[] bytes, string errorMsg)
			{
				if (!string.IsNullOrEmpty(errorMsg))
				{
					mJobState = eJobState.Failed;
					return;
				}
				errorMsg = GoogleTranslation.ParseTranslationResult(Encoding.UTF8.GetString(bytes, 0, bytes.Length), _requests);
				if (_OnTranslationReady != null)
				{
					_OnTranslationReady(_requests, errorMsg);
				}
				mJobState = eJobState.Succeeded;
			}
		}
		public class TranslationJob_WEB : TranslationJob_WWW
		{
			private Dictionary<string, TranslationQuery> _requests;

			private GoogleTranslation.fnOnTranslationReady _OnTranslationReady;

			public string mErrorMessage;

			private string mCurrentBatch_ToLanguageCode;

			private string mCurrentBatch_FromLanguageCode;

			private List<string> mCurrentBatch_Text;

			private List<KeyValuePair<string, string>> mQueries;

			public TranslationJob_WEB(Dictionary<string, TranslationQuery> requests, GoogleTranslation.fnOnTranslationReady OnTranslationReady)
			{
				_requests = requests;
				_OnTranslationReady = OnTranslationReady;
				FindAllQueries();
				ExecuteNextBatch();
			}

			private void FindAllQueries()
			{
				mQueries = new List<KeyValuePair<string, string>>();
				foreach (KeyValuePair<string, TranslationQuery> request in _requests)
				{
					string[] targetLanguagesCode = request.Value.TargetLanguagesCode;
					foreach (string text in targetLanguagesCode)
					{
						mQueries.Add(new KeyValuePair<string, string>(request.Value.OrigText, request.Value.LanguageCode + ":" + text));
					}
				}
				mQueries.Sort((KeyValuePair<string, string> a, KeyValuePair<string, string> b) => a.Value.CompareTo(b.Value));
			}

			private void ExecuteNextBatch()
			{
				if (mQueries.Count == 0)
				{
					mJobState = eJobState.Succeeded;
					return;
				}
				mCurrentBatch_Text = new List<string>();
				string text = null;
				int num = 200;
				StringBuilder stringBuilder = new StringBuilder();
				int i;
				for (i = 0; i < mQueries.Count; i++)
				{
					string key = mQueries[i].Key;
					string value = mQueries[i].Value;
					if (text == null || value == text)
					{
						if (i != 0)
						{
							stringBuilder.Append("|||");
						}
						stringBuilder.Append(key);
						mCurrentBatch_Text.Add(key);
						text = value;
					}
					if (stringBuilder.Length > num)
					{
						break;
					}
				}
				mQueries.RemoveRange(0, i);
				string[] array = text.Split(':');
				mCurrentBatch_FromLanguageCode = array[0];
				mCurrentBatch_ToLanguageCode = array[1];
				string text2 = $"http://www.google.com/translate_t?hl=en&vi=c&ie=UTF8&oe=UTF8&submit=Translate&langpair={mCurrentBatch_FromLanguageCode}|{mCurrentBatch_ToLanguageCode}&text={Uri.EscapeUriString(stringBuilder.ToString())}";
				UnityEngine.Debug.Log(text2);
				www = UnityWebRequest.Get(text2);
				I2Utils.SendWebRequest(www);
			}

			public override eJobState GetState()
			{
				if (www != null && www.isDone)
				{
					ProcessResult(www.downloadHandler.data, www.error);
					www.Dispose();
					www = null;
				}
				if (www == null)
				{
					ExecuteNextBatch();
				}
				return mJobState;
			}

			public void ProcessResult(byte[] bytes, string errorMsg)
			{
				if (string.IsNullOrEmpty(errorMsg))
				{
					string @string = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
					UnityEngine.Debug.Log(ParseTranslationResult(@string, "aab"));
					if (string.IsNullOrEmpty(errorMsg))
					{
						if (_OnTranslationReady != null)
						{
							_OnTranslationReady(_requests, null);
						}
						return;
					}
				}
				mJobState = eJobState.Failed;
				mErrorMessage = errorMsg;
			}

			private string ParseTranslationResult(string html, string OriginalText)
			{
				try
				{
					int num = html.IndexOf("TRANSLATED_TEXT='", StringComparison.Ordinal) + "TRANSLATED_TEXT='".Length;
					int num2 = html.IndexOf("';var", num, StringComparison.Ordinal);
					string input = html.Substring(num, num2 - num);
					input = Regex.Replace(input, "\\\\x([a-fA-F0-9]{2})", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value, NumberStyles.HexNumber)));
					input = Regex.Replace(input, "&#(\\d+);", (Match match) => char.ConvertFromUtf32(int.Parse(match.Groups[1].Value)));
					input = input.Replace("<br>", "\n");
					if (OriginalText.ToUpper() == OriginalText)
					{
						input = input.ToUpper();
					}
					else if (GoogleTranslation.UppercaseFirst(OriginalText) == OriginalText)
					{
						input = GoogleTranslation.UppercaseFirst(input);
					}
					else if (GoogleTranslation.TitleCase(OriginalText) == OriginalText)
					{
						input = GoogleTranslation.TitleCase(input);
					}
					return input;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError(ex.Message);
					return string.Empty;
				}
			}
		}
		public enum eLanguageDataFlags
		{
			DISABLED = 1,
			KEEP_LOADED = 2,
			NOT_LOADED = 4
		}
		[Serializable]
		public class LanguageData
		{
			public string Name;

			public string Code;

			public byte Flags;

			[NonSerialized]
			public bool Compressed;

			public bool IsEnabled()
			{
				return (Flags & 1) == 0;
			}

			public void SetEnabled(bool bEnabled)
			{
				if (bEnabled)
				{
					Flags = (byte)(Flags & 0xFFFFFFFEu);
				}
				else
				{
					Flags |= 1;
				}
			}

			public bool IsLoaded()
			{
				return (Flags & 4) == 0;
			}

			public bool CanBeUnloaded()
			{
				return (Flags & 2) == 0;
			}

			public void SetLoaded(bool loaded)
			{
				if (loaded)
				{
					Flags = (byte)(Flags & 0xFFFFFFFBu);
				}
				else
				{
					Flags |= 4;
				}
			}

			public void SetCanBeUnLoaded(bool allowUnloading)
			{
				if (allowUnloading)
				{
					Flags = (byte)(Flags & 0xFFFFFFFDu);
				}
				else
				{
					Flags |= 2;
				}
			}
		}
		[AddComponentMenu("I2/Localization/Source")]
		[ExecuteInEditMode]
		public class LanguageSource : MonoBehaviour, ISerializationCallbackReceiver, ILanguageSource
		{
			public delegate void fnOnSourceUpdated(LanguageSourceData source, bool ReceivedNewData, string errorMsg);

			public LanguageSourceData mSource = new LanguageSourceData();

			public int version;

			public bool NeverDestroy;

			public bool UserAgreesToHaveItOnTheScene;

			public bool UserAgreesToHaveItInsideThePluginsFolder;

			public bool GoogleLiveSyncIsUptoDate = true;

			public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

			public string Google_WebServiceURL;

			public string Google_SpreadsheetKey;

			public string Google_SpreadsheetName;

			public string Google_LastUpdatedVersion;

			public LanguageSourceData.eGoogleUpdateFrequency GoogleUpdateFrequency = LanguageSourceData.eGoogleUpdateFrequency.Weekly;

			public float GoogleUpdateDelay = 5f;

			public List<LanguageData> mLanguages = new List<LanguageData>();

			public bool IgnoreDeviceLanguage;

			public LanguageSourceData.eAllowUnloadLanguages _AllowUnloadingLanguages;

			public List<TermData> mTerms = new List<TermData>();

			public bool CaseInsensitiveTerms;

			public LanguageSourceData.MissingTranslationAction OnMissingTranslation = LanguageSourceData.MissingTranslationAction.Fallback;

			public string mTerm_AppName;

			public LanguageSourceData SourceData
			{
				get
				{
					return mSource;
				}
				set
				{
					mSource = value;
				}
			}

			public event fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

			private void Awake()
			{
				mSource.owner = this;
				mSource.Awake();
			}

			private void OnDestroy()
			{
				NeverDestroy = false;
				if (!NeverDestroy)
				{
					mSource.OnDestroy();
				}
			}

			public string GetSourceName()
			{
				string text = base.gameObject.name;
				Transform parent = base.transform.parent;
				while ((bool)parent)
				{
					text = parent.name + "_" + text;
					parent = parent.parent;
				}
				return text;
			}

			public void OnBeforeSerialize()
			{
				version = 1;
			}

			public void OnAfterDeserialize()
			{
				if (version != 0 && mSource != null)
				{
					return;
				}
				mSource = new LanguageSourceData();
				mSource.owner = this;
				mSource.UserAgreesToHaveItOnTheScene = UserAgreesToHaveItOnTheScene;
				mSource.UserAgreesToHaveItInsideThePluginsFolder = UserAgreesToHaveItInsideThePluginsFolder;
				mSource.IgnoreDeviceLanguage = IgnoreDeviceLanguage;
				mSource._AllowUnloadingLanguages = _AllowUnloadingLanguages;
				mSource.CaseInsensitiveTerms = CaseInsensitiveTerms;
				mSource.OnMissingTranslation = OnMissingTranslation;
				mSource.mTerm_AppName = mTerm_AppName;
				mSource.GoogleLiveSyncIsUptoDate = GoogleLiveSyncIsUptoDate;
				mSource.Google_WebServiceURL = Google_WebServiceURL;
				mSource.Google_SpreadsheetKey = Google_SpreadsheetKey;
				mSource.Google_SpreadsheetName = Google_SpreadsheetName;
				mSource.Google_LastUpdatedVersion = Google_LastUpdatedVersion;
				mSource.GoogleUpdateFrequency = GoogleUpdateFrequency;
				mSource.GoogleUpdateDelay = GoogleUpdateDelay;
				mSource.Event_OnSourceUpdateFromGoogle += this.Event_OnSourceUpdateFromGoogle;
				if (mLanguages != null && mLanguages.Count > 0)
				{
					mSource.mLanguages.Clear();
					mSource.mLanguages.AddRange(mLanguages);
					mLanguages.Clear();
				}
				if (Assets != null && Assets.Count > 0)
				{
					mSource.Assets.Clear();
					mSource.Assets.AddRange(Assets);
					Assets.Clear();
				}
				if (mTerms != null && mTerms.Count > 0)
				{
					mSource.mTerms.Clear();
					for (int i = 0; i < mTerms.Count; i++)
					{
						mSource.mTerms.Add(mTerms[i]);
					}
					mTerms.Clear();
				}
				version = 1;
				this.Event_OnSourceUpdateFromGoogle = null;
			}
		}
		[CreateAssetMenu(fileName = "I2Languages", menuName = "I2 Localization/LanguageSource", order = 1)]
		public class LanguageSourceAsset : ScriptableObject, ILanguageSource
		{
			public LanguageSourceData mSource = new LanguageSourceData();

			public LanguageSourceData SourceData
			{
				get
				{
					return mSource;
				}
				set
				{
					mSource = value;
				}
			}
		}
		public interface ILanguageSource
		{
			LanguageSourceData SourceData { get; set; }
		}
		[Serializable]
		[ExecuteInEditMode]
		public class LanguageSourceData
		{
			public enum MissingTranslationAction
			{
				Empty,
				Fallback,
				ShowWarning,
				ShowTerm
			}

			public enum eAllowUnloadLanguages
			{
				Never,
				OnlyInDevice,
				EditorAndDevice
			}

			public enum eGoogleUpdateFrequency
			{
				Always,
				Never,
				Daily,
				Weekly,
				Monthly,
				OnlyOnce,
				EveryOtherDay
			}

			public enum eGoogleUpdateSynchronization
			{
				Manual,
				OnSceneLoaded,
				AsSoonAsDownloaded
			}

			[NonSerialized]
			public ILanguageSource owner;

			public bool UserAgreesToHaveItOnTheScene;

			public bool UserAgreesToHaveItInsideThePluginsFolder;

			public bool GoogleLiveSyncIsUptoDate = true;

			[NonSerialized]
			public bool mIsGlobalSource;

			public List<TermData> mTerms = new List<TermData>();

			public bool CaseInsensitiveTerms;

			[NonSerialized]
			public Dictionary<string, TermData> mDictionary = new Dictionary<string, TermData>(StringComparer.Ordinal);

			public MissingTranslationAction OnMissingTranslation = MissingTranslationAction.Fallback;

			public string mTerm_AppName;

			public List<LanguageData> mLanguages = new List<LanguageData>();

			public bool IgnoreDeviceLanguage;

			public eAllowUnloadLanguages _AllowUnloadingLanguages;

			public string Google_WebServiceURL;

			public string Google_SpreadsheetKey;

			public string Google_SpreadsheetName;

			public string Google_LastUpdatedVersion;

			public eGoogleUpdateFrequency GoogleUpdateFrequency = eGoogleUpdateFrequency.Weekly;

			public eGoogleUpdateFrequency GoogleInEditorCheckFrequency = eGoogleUpdateFrequency.Daily;

			public eGoogleUpdateSynchronization GoogleUpdateSynchronization = eGoogleUpdateSynchronization.OnSceneLoaded;

			public float GoogleUpdateDelay;

			public List<UnityEngine.Object> Assets = new List<UnityEngine.Object>();

			[NonSerialized]
			public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

			private string mDelayedGoogleData;

			public static string EmptyCategory = "Default";

			public static char[] CategorySeparators = "/\\".ToCharArray();

			public UnityEngine.Object ownerObject => owner as UnityEngine.Object;

			public event LanguageSource.fnOnSourceUpdated Event_OnSourceUpdateFromGoogle;

			public void Awake()
			{
				LocalizationManager.AddSource(this);
				UpdateDictionary();
				UpdateAssetDictionary();
				LocalizationManager.LocalizeAll(Force: true);
			}

			public void OnDestroy()
			{
				LocalizationManager.RemoveSource(this);
			}

			public bool IsEqualTo(LanguageSourceData Source)
			{
				if (Source.mLanguages.Count != mLanguages.Count)
				{
					return false;
				}
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if (Source.GetLanguageIndex(mLanguages[i].Name) < 0)
					{
						return false;
					}
				}
				if (Source.mTerms.Count != mTerms.Count)
				{
					return false;
				}
				for (int j = 0; j < mTerms.Count; j++)
				{
					if (Source.GetTermData(mTerms[j].Term) == null)
					{
						return false;
					}
				}
				return true;
			}

			internal bool ManagerHasASimilarSource()
			{
				int i = 0;
				for (int count = LocalizationManager.Sources.Count; i < count; i++)
				{
					LanguageSourceData languageSourceData = LocalizationManager.Sources[i];
					if (languageSourceData != null && languageSourceData.IsEqualTo(this) && languageSourceData != this)
					{
						return true;
					}
				}
				return false;
			}

			public void ClearAllData()
			{
				mTerms.Clear();
				mLanguages.Clear();
				mDictionary.Clear();
				mAssetDictionary.Clear();
			}

			public bool IsGlobalSource()
			{
				return mIsGlobalSource;
			}

			public void Editor_SetDirty()
			{
			}

			public void UpdateAssetDictionary()
			{
				Assets.RemoveAll((UnityEngine.Object x) => x == null);
				mAssetDictionary = Assets.Distinct().GroupBy((UnityEngine.Object o) => o.name, StringComparer.Ordinal).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First(), StringComparer.Ordinal);
			}

			public UnityEngine.Object FindAsset(string Name)
			{
				if (Assets != null)
				{
					if (mAssetDictionary == null || mAssetDictionary.Count != Assets.Count)
					{
						UpdateAssetDictionary();
					}
					if (mAssetDictionary.TryGetValue(Name, out var value))
					{
						return value;
					}
				}
				return null;
			}

			public bool HasAsset(UnityEngine.Object Obj)
			{
				return Assets.Contains(Obj);
			}

			public void AddAsset(UnityEngine.Object Obj)
			{
				if (!Assets.Contains(Obj))
				{
					Assets.Add(Obj);
					UpdateAssetDictionary();
				}
			}

			private string Export_Language_to_Cache(int langIndex, bool fillTermWithFallback)
			{
				if (!mLanguages[langIndex].IsLoaded())
				{
					return null;
				}
				StringBuilder stringBuilder = new StringBuilder();
				for (int i = 0; i < mTerms.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append("[i2t]");
					}
					TermData termData = mTerms[i];
					stringBuilder.Append(termData.Term);
					stringBuilder.Append("=");
					string Translation = termData.Languages[langIndex];
					if (OnMissingTranslation == MissingTranslationAction.Fallback && string.IsNullOrEmpty(Translation) && TryGetFallbackTranslation(termData, out Translation, langIndex, null, skipDisabled: true))
					{
						stringBuilder.Append("[i2fb]");
						if (fillTermWithFallback)
						{
							termData.Languages[langIndex] = Translation;
						}
					}
					if (!string.IsNullOrEmpty(Translation))
					{
						stringBuilder.Append(Translation);
					}
				}
				return stringBuilder.ToString();
			}

			public string Export_I2CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("Key[*]Type[*]Desc");
				foreach (LanguageData mLanguage in mLanguages)
				{
					stringBuilder.Append("[*]");
					if (!mLanguage.IsEnabled())
					{
						stringBuilder.Append('$');
					}
					stringBuilder.Append(GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code));
				}
				stringBuilder.Append("[ln]");
				mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
				int count = mLanguages.Count;
				bool flag = true;
				foreach (TermData mTerm in mTerms)
				{
					string term;
					if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
					{
						term = mTerm.Term;
					}
					else
					{
						if (!mTerm.Term.StartsWith(Category + "/", StringComparison.Ordinal) || !(Category != mTerm.Term))
						{
							continue;
						}
						term = mTerm.Term.Substring(Category.Length + 1);
					}
					if (!flag)
					{
						stringBuilder.Append("[ln]");
					}
					flag = false;
					if (!specializationsAsRows)
					{
						AppendI2Term(stringBuilder, count, term, mTerm, Separator, null);
						continue;
					}
					List<string> allSpecializations = mTerm.GetAllSpecializations();
					for (int i = 0; i < allSpecializations.Count; i++)
					{
						if (i != 0)
						{
							stringBuilder.Append("[ln]");
						}
						string forceSpecialization = allSpecializations[i];
						AppendI2Term(stringBuilder, count, term, mTerm, Separator, forceSpecialization);
					}
				}
				return stringBuilder.ToString();
			}

			private static void AppendI2Term(StringBuilder Builder, int nLanguages, string Term, TermData termData, char Separator, string forceSpecialization)
			{
				AppendI2Text(Builder, Term);
				if (!string.IsNullOrEmpty(forceSpecialization) && forceSpecialization != "Any")
				{
					Builder.Append("[");
					Builder.Append(forceSpecialization);
					Builder.Append("]");
				}
				Builder.Append("[*]");
				Builder.Append(termData.TermType.ToString());
				Builder.Append("[*]");
				Builder.Append(termData.Description);
				for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
				{
					Builder.Append("[*]");
					string text = termData.Languages[i];
					if (!string.IsNullOrEmpty(forceSpecialization))
					{
						text = termData.GetTranslation(i, forceSpecialization);
					}
					AppendI2Text(Builder, text);
				}
			}

			private static void AppendI2Text(StringBuilder Builder, string text)
			{
				if (!string.IsNullOrEmpty(text))
				{
					if (text.StartsWith("'", StringComparison.Ordinal) || text.StartsWith("=", StringComparison.Ordinal))
					{
						Builder.Append('\'');
					}
					Builder.Append(text);
				}
			}

			public string Export_CSV(string Category, char Separator = ',', bool specializationsAsRows = true)
			{
				StringBuilder stringBuilder = new StringBuilder();
				int count = mLanguages.Count;
				stringBuilder.AppendFormat("Key{0}Type{0}Desc", Separator);
				foreach (LanguageData mLanguage in mLanguages)
				{
					stringBuilder.Append(Separator);
					if (!mLanguage.IsEnabled())
					{
						stringBuilder.Append('$');
					}
					AppendString(stringBuilder, GoogleLanguages.GetCodedLanguage(mLanguage.Name, mLanguage.Code), Separator);
				}
				stringBuilder.Append("\n");
				mTerms.Sort((TermData a, TermData b) => string.CompareOrdinal(a.Term, b.Term));
				foreach (TermData mTerm in mTerms)
				{
					string term;
					if (string.IsNullOrEmpty(Category) || (Category == EmptyCategory && mTerm.Term.IndexOfAny(CategorySeparators) < 0))
					{
						term = mTerm.Term;
					}
					else
					{
						if (!mTerm.Term.StartsWith(Category + "/", StringComparison.Ordinal) || !(Category != mTerm.Term))
						{
							continue;
						}
						term = mTerm.Term.Substring(Category.Length + 1);
					}
					if (specializationsAsRows)
					{
						foreach (string allSpecialization in mTerm.GetAllSpecializations())
						{
							AppendTerm(stringBuilder, count, term, mTerm, allSpecialization, Separator);
						}
					}
					else
					{
						AppendTerm(stringBuilder, count, term, mTerm, null, Separator);
					}
				}
				return stringBuilder.ToString();
			}

			private static void AppendTerm(StringBuilder Builder, int nLanguages, string Term, TermData termData, string specialization, char Separator)
			{
				AppendString(Builder, Term, Separator);
				if (!string.IsNullOrEmpty(specialization) && specialization != "Any")
				{
					Builder.AppendFormat("[{0}]", specialization);
				}
				Builder.Append(Separator);
				Builder.Append(termData.TermType.ToString());
				Builder.Append(Separator);
				AppendString(Builder, termData.Description, Separator);
				for (int i = 0; i < Mathf.Min(nLanguages, termData.Languages.Length); i++)
				{
					Builder.Append(Separator);
					string text = termData.Languages[i];
					if (!string.IsNullOrEmpty(specialization))
					{
						text = termData.GetTranslation(i, specialization);
					}
					AppendTranslation(Builder, text, Separator, null);
				}
				Builder.Append("\n");
			}

			private static void AppendString(StringBuilder Builder, string Text, char Separator)
			{
				if (!string.IsNullOrEmpty(Text))
				{
					Text = Text.Replace("\\n", "\n");
					if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
					{
						Text = Text.Replace("\"", "\"\"");
						Builder.AppendFormat("\"{0}\"", Text);
					}
					else
					{
						Builder.Append(Text);
					}
				}
			}

			private static void AppendTranslation(StringBuilder Builder, string Text, char Separator, string tags)
			{
				if (!string.IsNullOrEmpty(Text))
				{
					Text = Text.Replace("\\n", "\n");
					if (Text.IndexOfAny((Separator + "\n\"").ToCharArray()) >= 0)
					{
						Text = Text.Replace("\"", "\"\"");
						Builder.AppendFormat("\"{0}{1}\"", tags, Text);
					}
					else
					{
						Builder.Append(tags);
						Builder.Append(Text);
					}
				}
			}

			public UnityWebRequest Export_Google_CreateWWWcall(eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
			{
				string value = Export_Google_CreateData();
				WWWForm wWWForm = new WWWForm();
				wWWForm.AddField("key", Google_SpreadsheetKey);
				wWWForm.AddField("action", "SetLanguageSource");
				wWWForm.AddField("data", value);
				wWWForm.AddField("updateMode", UpdateMode.ToString());
				UnityWebRequest unityWebRequest = UnityWebRequest.Post(LocalizationManager.GetWebServiceURL(this), wWWForm);
				I2Utils.SendWebRequest(unityWebRequest);
				return unityWebRequest;
			}

			private string Export_Google_CreateData()
			{
				List<string> categories = GetCategories(OnlyMainCategory: true);
				StringBuilder stringBuilder = new StringBuilder();
				bool flag = true;
				foreach (string item in categories)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						stringBuilder.Append("<I2Loc>");
					}
					bool specializationsAsRows = true;
					string value = Export_I2CSV(item, ',', specializationsAsRows);
					stringBuilder.Append(item);
					stringBuilder.Append("<I2Loc>");
					stringBuilder.Append(value);
				}
				return stringBuilder.ToString();
			}

			public string Import_CSV(string Category, string CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace, char Separator = ',')
			{
				List<string[]> cSV = LocalizationReader.ReadCSV(CSVstring, Separator);
				return Import_CSV(Category, cSV, UpdateMode);
			}

			public string Import_I2CSV(string Category, string I2CSVstring, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
			{
				List<string[]> cSV = LocalizationReader.ReadI2CSV(I2CSVstring);
				return Import_CSV(Category, cSV, UpdateMode);
			}

			public string Import_CSV(string Category, List<string[]> CSV, eSpreadsheetUpdateMode UpdateMode = eSpreadsheetUpdateMode.Replace)
			{
				string[] array = CSV[0];
				int num = 1;
				int num2 = -1;
				int num3 = -1;
				string[] texts = new string[1] { "Key" };
				string[] texts2 = new string[1] { "Type" };
				string[] texts3 = new string[2] { "Desc", "Description" };
				if (array.Length > 1 && ArrayContains(array[0], texts))
				{
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						ClearAllData();
					}
					if (array.Length > 2)
					{
						if (ArrayContains(array[1], texts2))
						{
							num2 = 1;
							num = 2;
						}
						if (ArrayContains(array[1], texts3))
						{
							num3 = 1;
							num = 2;
						}
					}
					if (array.Length > 3)
					{
						if (ArrayContains(array[2], texts2))
						{
							num2 = 2;
							num = 3;
						}
						if (ArrayContains(array[2], texts3))
						{
							num3 = 2;
							num = 3;
						}
					}
					int num4 = Mathf.Max(array.Length - num, 0);
					int[] array2 = new int[num4];
					for (int i = 0; i < num4; i++)
					{
						if (string.IsNullOrEmpty(array[i + num]))
						{
							array2[i] = -1;
							continue;
						}
						string text = array[i + num];
						bool flag = true;
						if (text.StartsWith("$", StringComparison.Ordinal))
						{
							flag = false;
							text = text.Substring(1);
						}
						GoogleLanguages.UnPackCodeFromLanguageName(text, out var Language, out var code);
						int num5 = -1;
						num5 = (string.IsNullOrEmpty(code) ? GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled: false) : GetLanguageIndexFromCode(code));
						if (num5 < 0)
						{
							LanguageData languageData = new LanguageData();
							languageData.Name = Language;
							languageData.Code = code;
							languageData.Flags = (byte)(0u | ((!flag) ? 1u : 0u));
							mLanguages.Add(languageData);
							num5 = mLanguages.Count - 1;
						}
						array2[i] = num5;
					}
					num4 = mLanguages.Count;
					int j = 0;
					for (int count = mTerms.Count; j < count; j++)
					{
						TermData termData = mTerms[j];
						if (termData.Languages.Length < num4)
						{
							Array.Resize(ref termData.Languages, num4);
							Array.Resize(ref termData.Flags, num4);
						}
					}
					int k = 1;
					for (int count2 = CSV.Count; k < count2; k++)
					{
						array = CSV[k];
						string Term = (string.IsNullOrEmpty(Category) ? array[0] : (Category + "/" + array[0]));
						string text2 = null;
						if (Term.EndsWith("]", StringComparison.Ordinal))
						{
							int num6 = Term.LastIndexOf('[');
							if (num6 > 0)
							{
								text2 = Term.Substring(num6 + 1, Term.Length - num6 - 2);
								if (text2 == "touch")
								{
									text2 = "Touch";
								}
								Term = Term.Remove(num6);
							}
						}
						ValidateFullTerm(ref Term);
						if (string.IsNullOrEmpty(Term))
						{
							continue;
						}
						TermData termData2 = GetTermData(Term);
						if (termData2 == null)
						{
							termData2 = new TermData();
							termData2.Term = Term;
							termData2.Languages = new string[mLanguages.Count];
							termData2.Flags = new byte[mLanguages.Count];
							for (int l = 0; l < mLanguages.Count; l++)
							{
								termData2.Languages[l] = string.Empty;
							}
							mTerms.Add(termData2);
							mDictionary.Add(Term, termData2);
						}
						else if (UpdateMode == eSpreadsheetUpdateMode.AddNewTerms)
						{
							continue;
						}
						if (num2 > 0)
						{
							termData2.TermType = GetTermType(array[num2]);
						}
						if (num3 > 0)
						{
							termData2.Description = array[num3];
						}
						for (int m = 0; m < array2.Length && m < array.Length - num; m++)
						{
							if (string.IsNullOrEmpty(array[m + num]))
							{
								continue;
							}
							int num7 = array2[m];
							if (num7 >= 0)
							{
								string text3 = array[m + num];
								if (text3 == "-")
								{
									text3 = string.Empty;
								}
								else if (text3 == "")
								{
									text3 = null;
								}
								termData2.SetTranslation(num7, text3, text2);
							}
						}
					}
					if (Application.isPlaying)
					{
						SaveLanguages(HasUnloadedLanguages());
					}
					return string.Empty;
				}
				return "Bad Spreadsheet Format.\nFirst columns should be 'Key', 'Type' and 'Desc'";
			}

			private bool ArrayContains(string MainText, params string[] texts)
			{
				int i = 0;
				for (int num = texts.Length; i < num; i++)
				{
					if (MainText.IndexOf(texts[i], StringComparison.OrdinalIgnoreCase) >= 0)
					{
						return true;
					}
				}
				return false;
			}

			public static eTermType GetTermType(string type)
			{
				int i = 0;
				for (int num = 10; i <= num; i++)
				{
					eTermType eTermType2 = (eTermType)i;
					if (string.Equals(eTermType2.ToString(), type, StringComparison.OrdinalIgnoreCase))
					{
						return (eTermType)i;
					}
				}
				return eTermType.Text;
			}

			private void Import_Language_from_Cache(int langIndex, string langData, bool useFallback, bool onlyCurrentSpecialization)
			{
				int num = 0;
				while (num < langData.Length)
				{
					int num2 = langData.IndexOf("[i2t]", num, StringComparison.Ordinal);
					if (num2 < 0)
					{
						num2 = langData.Length;
					}
					int num3 = langData.IndexOf("=", num, StringComparison.Ordinal);
					if (num3 >= num2)
					{
						break;
					}
					string term = langData.Substring(num, num3 - num);
					num = num3 + 1;
					TermData termData = GetTermData(term);
					if (termData != null)
					{
						string text = null;
						if (num != num2)
						{
							text = langData.Substring(num, num2 - num);
							if (text.StartsWith("[i2fb]", StringComparison.Ordinal))
							{
								text = (useFallback ? text.Substring(6) : null);
							}
							if (onlyCurrentSpecialization && text != null)
							{
								text = SpecializationManager.GetSpecializedText(text);
							}
						}
						termData.Languages[langIndex] = text;
					}
					num = num2 + 5;
				}
			}

			public static void FreeUnusedLanguages()
			{
				LanguageSourceData languageSourceData = LocalizationManager.Sources[0];
				int languageIndex = languageSourceData.GetLanguageIndex(LocalizationManager.CurrentLanguage);
				for (int i = 0; i < languageSourceData.mTerms.Count; i++)
				{
					TermData termData = languageSourceData.mTerms[i];
					for (int j = 0; j < termData.Languages.Length; j++)
					{
						if (j != languageIndex)
						{
							termData.Languages[j] = null;
						}
					}
				}
			}

			public void Import_Google_FromCache()
			{
				if (GoogleUpdateFrequency == eGoogleUpdateFrequency.Never || !I2Utils.IsPlaying())
				{
					return;
				}
				string sourcePlayerPrefName = GetSourcePlayerPrefName();
				string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
				if (string.IsNullOrEmpty(text))
				{
					return;
				}
				if (text.StartsWith("[i2e]", StringComparison.Ordinal))
				{
					text = StringObfucator.Decode(text.Substring(5, text.Length - 5));
				}
				bool flag = false;
				string text2 = Google_LastUpdatedVersion;
				if (PersistentStorage.HasSetting("I2SourceVersion_" + sourcePlayerPrefName))
				{
					text2 = PersistentStorage.GetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, Google_LastUpdatedVersion);
					flag = IsNewerVersion(Google_LastUpdatedVersion, text2);
				}
				if (!flag)
				{
					PersistentStorage.DeleteFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", logExceptions: false);
					PersistentStorage.DeleteSetting("I2SourceVersion_" + sourcePlayerPrefName);
					return;
				}
				if (text2.Length > 19)
				{
					text2 = string.Empty;
				}
				Google_LastUpdatedVersion = text2;
				Import_Google_Result(text, eSpreadsheetUpdateMode.Replace);
			}

			private bool IsNewerVersion(string currentVersion, string newVersion)
			{
				if (string.IsNullOrEmpty(newVersion))
				{
					return false;
				}
				if (string.IsNullOrEmpty(currentVersion))
				{
					return true;
				}
				if (!long.TryParse(newVersion, out var result) || !long.TryParse(currentVersion, out var result2))
				{
					return true;
				}
				return result > result2;
			}

			public void Import_Google(bool ForceUpdate, bool justCheck)
			{
				if ((!ForceUpdate && GoogleUpdateFrequency == eGoogleUpdateFrequency.Never) || !I2Utils.IsPlaying())
				{
					return;
				}
				eGoogleUpdateFrequency googleUpdateFrequency = GoogleUpdateFrequency;
				string sourcePlayerPrefName = GetSourcePlayerPrefName();
				if (!ForceUpdate && googleUpdateFrequency != 0)
				{
					string setting_String = PersistentStorage.GetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, "");
					try
					{
						if (DateTime.TryParse(setting_String, out var result))
						{
							double totalDays = (DateTime.Now - result).TotalDays;
							switch (googleUpdateFrequency)
							{
							case eGoogleUpdateFrequency.Daily:
								if (totalDays < 1.0)
								{
									return;
								}
								break;
							case eGoogleUpdateFrequency.Weekly:
								if (totalDays < 8.0)
								{
									return;
								}
								break;
							case eGoogleUpdateFrequency.Monthly:
								if (totalDays < 31.0)
								{
									return;
								}
								break;
							case eGoogleUpdateFrequency.OnlyOnce:
								return;
							case eGoogleUpdateFrequency.EveryOtherDay:
								if (totalDays < 2.0)
								{
									return;
								}
								break;
							}
						}
					}
					catch (Exception)
					{
					}
				}
				PersistentStorage.SetSetting_String("LastGoogleUpdate_" + sourcePlayerPrefName, DateTime.Now.ToString());
				CoroutineManager.Start(Import_Google_Coroutine(ForceUpdate, justCheck));
			}

			private string GetSourcePlayerPrefName()
			{
				if (owner == null)
				{
					return null;
				}
				string text = (owner as UnityEngine.Object).name;
				if (!string.IsNullOrEmpty(Google_SpreadsheetKey))
				{
					text += Google_SpreadsheetKey;
				}
				if (Array.IndexOf(LocalizationManager.GlobalSources, (owner as UnityEngine.Object).name) >= 0)
				{
					return text;
				}
				return SceneManager.GetActiveScene().name + "_" + text;
			}

			private IEnumerator Import_Google_Coroutine(bool forceUpdate, bool JustCheck)
			{
				UnityWebRequest www = Import_Google_CreateWWWcall(forceUpdate, JustCheck);
				if (www == null)
				{
					yield break;
				}
				while (!www.isDone)
				{
					yield return null;
				}
				if (string.IsNullOrEmpty(www.error))
				{
					byte[] data = www.downloadHandler.data;
					string @string = Encoding.UTF8.GetString(data, 0, data.Length);
					bool flag = string.IsNullOrEmpty(@string) || @string == "\"\"";
					if (JustCheck)
					{
						if (!flag)
						{
							UnityEngine.Debug.LogWarning("Spreadsheet is not up-to-date and Google Live Synchronization is enabled\nWhen playing in the device the Spreadsheet will be downloaded and translations may not behave as what you see in the editor.\nTo fix this, Import or Export replace to Google");
							GoogleLiveSyncIsUptoDate = false;
						}
						yield break;
					}
					if (!flag)
					{
						mDelayedGoogleData = @string;
						switch (GoogleUpdateSynchronization)
						{
						case eGoogleUpdateSynchronization.AsSoonAsDownloaded:
							ApplyDownloadedDataFromGoogle();
							break;
						case eGoogleUpdateSynchronization.OnSceneLoaded:
							SceneManager.sceneLoaded += ApplyDownloadedDataOnSceneLoaded;
							break;
						}
						yield break;
					}
				}
				if (this.Event_OnSourceUpdateFromGoogle != null)
				{
					this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, www.error);
				}
				UnityEngine.Debug.Log("Language Source was up-to-date with Google Spreadsheet");
			}

			private void ApplyDownloadedDataOnSceneLoaded(Scene scene, LoadSceneMode mode)
			{
				SceneManager.sceneLoaded -= ApplyDownloadedDataOnSceneLoaded;
				ApplyDownloadedDataFromGoogle();
			}

			public void ApplyDownloadedDataFromGoogle()
			{
				if (string.IsNullOrEmpty(mDelayedGoogleData))
				{
					return;
				}
				if (string.IsNullOrEmpty(Import_Google_Result(mDelayedGoogleData, eSpreadsheetUpdateMode.Replace, saveInPlayerPrefs: true)))
				{
					if (this.Event_OnSourceUpdateFromGoogle != null)
					{
						this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: true, "");
					}
					LocalizationManager.LocalizeAll(Force: true);
					UnityEngine.Debug.Log("Done Google Sync");
				}
				else
				{
					if (this.Event_OnSourceUpdateFromGoogle != null)
					{
						this.Event_OnSourceUpdateFromGoogle(this, ReceivedNewData: false, "");
					}
					UnityEngine.Debug.Log("Done Google Sync: source was up-to-date");
				}
			}

			public UnityWebRequest Import_Google_CreateWWWcall(bool ForceUpdate, bool justCheck)
			{
				if (!HasGoogleSpreadsheet())
				{
					return null;
				}
				string text = PersistentStorage.GetSetting_String("I2SourceVersion_" + GetSourcePlayerPrefName(), Google_LastUpdatedVersion);
				if (text.Length > 19)
				{
					text = string.Empty;
				}
				if (IsNewerVersion(text, Google_LastUpdatedVersion))
				{
					Google_LastUpdatedVersion = text;
				}
				UnityWebRequest unityWebRequest = UnityWebRequest.Get(string.Format("{0}?key={1}&action=GetLanguageSource&version={2}", LocalizationManager.GetWebServiceURL(this), Google_SpreadsheetKey, ForceUpdate ? "0" : Google_LastUpdatedVersion));
				I2Utils.SendWebRequest(unityWebRequest);
				return unityWebRequest;
			}

			public bool HasGoogleSpreadsheet()
			{
				if (!string.IsNullOrEmpty(Google_WebServiceURL) && !string.IsNullOrEmpty(Google_SpreadsheetKey))
				{
					return !string.IsNullOrEmpty(LocalizationManager.GetWebServiceURL(this));
				}
				return false;
			}

			public string Import_Google_Result(string JsonString, eSpreadsheetUpdateMode UpdateMode, bool saveInPlayerPrefs = false)
			{
				try
				{
					string empty = string.Empty;
					if (string.IsNullOrEmpty(JsonString) || JsonString == "\"\"")
					{
						return empty;
					}
					int num = JsonString.IndexOf("version=", StringComparison.Ordinal);
					int num2 = JsonString.IndexOf("script_version=", StringComparison.Ordinal);
					if (num < 0 || num2 < 0)
					{
						return "Invalid Response from Google, Most likely the WebService needs to be updated";
					}
					num += "version=".Length;
					num2 += "script_version=".Length;
					string text = JsonString.Substring(num, JsonString.IndexOf(",", num, StringComparison.Ordinal) - num);
					int num3 = int.Parse(JsonString.Substring(num2, JsonString.IndexOf(",", num2, StringComparison.Ordinal) - num2));
					if (text.Length > 19)
					{
						text = string.Empty;
					}
					if (num3 != LocalizationManager.GetRequiredWebServiceVersion())
					{
						return "The current Google WebService is not supported.\nPlease, delete the WebService from the Google Drive and Install the latest version.";
					}
					if (saveInPlayerPrefs && !IsNewerVersion(Google_LastUpdatedVersion, text))
					{
						return "LanguageSource is up-to-date";
					}
					if (saveInPlayerPrefs)
					{
						string sourcePlayerPrefName = GetSourcePlayerPrefName();
						PersistentStorage.SaveFile(PersistentStorage.eFileType.Persistent, "I2Source_" + sourcePlayerPrefName + ".loc", "[i2e]" + StringObfucator.Encode(JsonString));
						PersistentStorage.SetSetting_String("I2SourceVersion_" + sourcePlayerPrefName, text);
						PersistentStorage.ForceSaveSettings();
					}
					Google_LastUpdatedVersion = text;
					if (UpdateMode == eSpreadsheetUpdateMode.Replace)
					{
						ClearAllData();
					}
					int num4 = JsonString.IndexOf("[i2category]", StringComparison.Ordinal);
					while (num4 > 0)
					{
						num4 += "[i2category]".Length;
						int num5 = JsonString.IndexOf("[/i2category]", num4, StringComparison.Ordinal);
						string category = JsonString.Substring(num4, num5 - num4);
						num5 += "[/i2category]".Length;
						int num6 = JsonString.IndexOf("[/i2csv]", num5, StringComparison.Ordinal);
						string i2CSVstring = JsonString.Substring(num5, num6 - num5);
						num4 = JsonString.IndexOf("[i2category]", num6, StringComparison.Ordinal);
						Import_I2CSV(category, i2CSVstring, UpdateMode);
						if (UpdateMode == eSpreadsheetUpdateMode.Replace)
						{
							UpdateMode = eSpreadsheetUpdateMode.Merge;
						}
					}
					GoogleLiveSyncIsUptoDate = true;
					if (I2Utils.IsPlaying())
					{
						SaveLanguages(unloadAll: true);
					}
					if (!string.IsNullOrEmpty(empty))
					{
						Editor_SetDirty();
					}
					return empty;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogWarning(ex);
					return ex.ToString();
				}
			}

			public int GetLanguageIndex(string language, bool AllowDiscartingRegion = true, bool SkipDisabled = true)
			{
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if ((!SkipDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Name, language, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return i;
					}
				}
				if (AllowDiscartingRegion)
				{
					int num = -1;
					int num2 = 0;
					int j = 0;
					for (int count2 = mLanguages.Count; j < count2; j++)
					{
						if (!SkipDisabled || mLanguages[j].IsEnabled())
						{
							int commonWordInLanguageNames = GetCommonWordInLanguageNames(mLanguages[j].Name, language);
							if (commonWordInLanguageNames > num2)
							{
								num2 = commonWordInLanguageNames;
								num = j;
							}
						}
					}
					if (num >= 0)
					{
						return num;
					}
				}
				return -1;
			}

			public LanguageData GetLanguageData(string language, bool AllowDiscartingRegion = true)
			{
				int languageIndex = GetLanguageIndex(language, AllowDiscartingRegion, SkipDisabled: false);
				if (languageIndex >= 0)
				{
					return mLanguages[languageIndex];
				}
				return null;
			}

			public bool IsCurrentLanguage(int languageIndex)
			{
				return LocalizationManager.CurrentLanguage == mLanguages[languageIndex].Name;
			}

			public int GetLanguageIndexFromCode(string Code, bool exactMatch = true, bool ignoreDisabled = false)
			{
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if ((!ignoreDisabled || mLanguages[i].IsEnabled()) && string.Compare(mLanguages[i].Code, Code, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return i;
					}
				}
				if (!exactMatch)
				{
					int j = 0;
					for (int count2 = mLanguages.Count; j < count2; j++)
					{
						if ((!ignoreDisabled || mLanguages[j].IsEnabled()) && string.Compare(mLanguages[j].Code, 0, Code, 0, 2, StringComparison.OrdinalIgnoreCase) == 0)
						{
							return j;
						}
					}
				}
				return -1;
			}

			public static int GetCommonWordInLanguageNames(string Language1, string Language2)
			{
				if (string.IsNullOrEmpty(Language1) || string.IsNullOrEmpty(Language2))
				{
					return 0;
				}
				char[] separator = "( )-/\\".ToCharArray();
				string[] array = Language1.ToLower().Split(separator);
				string[] array2 = Language2.ToLower().Split(separator);
				int num = 0;
				string[] array3 = array;
				foreach (string value in array3)
				{
					if (!string.IsNullOrEmpty(value) && array2.Contains(value))
					{
						num++;
					}
				}
				array3 = array2;
				foreach (string value2 in array3)
				{
					if (!string.IsNullOrEmpty(value2) && array.Contains(value2))
					{
						num++;
					}
				}
				return num;
			}

			public static bool AreTheSameLanguage(string Language1, string Language2)
			{
				Language1 = GetLanguageWithoutRegion(Language1);
				Language2 = GetLanguageWithoutRegion(Language2);
				return string.Compare(Language1, Language2, StringComparison.OrdinalIgnoreCase) == 0;
			}

			public static string GetLanguageWithoutRegion(string Language)
			{
				int num = Language.IndexOfAny("(/\\[,{".ToCharArray());
				if (num < 0)
				{
					return Language;
				}
				return Language.Substring(0, num).Trim();
			}

			public void AddLanguage(string LanguageName)
			{
				AddLanguage(LanguageName, GoogleLanguages.GetLanguageCode(LanguageName));
			}

			public void AddLanguage(string LanguageName, string LanguageCode)
			{
				if (GetLanguageIndex(LanguageName, AllowDiscartingRegion: false) < 0)
				{
					LanguageData languageData = new LanguageData();
					languageData.Name = LanguageName;
					languageData.Code = LanguageCode;
					mLanguages.Add(languageData);
					int count = mLanguages.Count;
					int i = 0;
					for (int count2 = mTerms.Count; i < count2; i++)
					{
						Array.Resize(ref mTerms[i].Languages, count);
						Array.Resize(ref mTerms[i].Flags, count);
					}
					Editor_SetDirty();
				}
			}

			public void RemoveLanguage(string LanguageName)
			{
				int languageIndex = GetLanguageIndex(LanguageName, AllowDiscartingRegion: false, SkipDisabled: false);
				if (languageIndex < 0)
				{
					return;
				}
				int count = mLanguages.Count;
				int i = 0;
				for (int count2 = mTerms.Count; i < count2; i++)
				{
					for (int j = languageIndex + 1; j < count; j++)
					{
						mTerms[i].Languages[j - 1] = mTerms[i].Languages[j];
						mTerms[i].Flags[j - 1] = mTerms[i].Flags[j];
					}
					Array.Resize(ref mTerms[i].Languages, count - 1);
					Array.Resize(ref mTerms[i].Flags, count - 1);
				}
				mLanguages.RemoveAt(languageIndex);
				Editor_SetDirty();
			}

			public List<string> GetLanguages(bool skipDisabled = true)
			{
				List<string> list = new List<string>();
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if (!skipDisabled || mLanguages[i].IsEnabled())
					{
						list.Add(mLanguages[i].Name);
					}
				}
				return list;
			}

			public List<string> GetLanguagesCode(bool allowRegions = true, bool skipDisabled = true)
			{
				List<string> list = new List<string>();
				int i = 0;
				for (int count = mLanguages.Count; i < count; i++)
				{
					if (!skipDisabled || mLanguages[i].IsEnabled())
					{
						string text = mLanguages[i].Code;
						if (!allowRegions && text != null && text.Length > 2)
						{
							text = text.Substring(0, 2);
						}
						if (!string.IsNullOrEmpty(text) && !list.Contains(text))
						{
							list.Add(text);
						}
					}
				}
				return list;
			}

			public bool IsLanguageEnabled(string Language)
			{
				int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false);
				if (languageIndex >= 0)
				{
					return mLanguages[languageIndex].IsEnabled();
				}
				return false;
			}

			public void EnableLanguage(string Language, bool bEnabled)
			{
				int languageIndex = GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled: false);
				if (languageIndex >= 0)
				{
					mLanguages[languageIndex].SetEnabled(bEnabled);
				}
			}

			public bool AllowUnloadingLanguages()
			{
				return _AllowUnloadingLanguages != eAllowUnloadLanguages.Never;
			}

			private string GetSavedLanguageFileName(int languageIndex)
			{
				if (languageIndex < 0)
				{
					return null;
				}
				return "LangSource_" + GetSourcePlayerPrefName() + "_" + mLanguages[languageIndex].Name + ".loc";
			}

			public void LoadLanguage(int languageIndex, bool UnloadOtherLanguages, bool useFallback, bool onlyCurrentSpecialization, bool forceLoad)
			{
				if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
				{
					return;
				}
				if (languageIndex >= 0 && (forceLoad || !mLanguages[languageIndex].IsLoaded()))
				{
					string savedLanguageFileName = GetSavedLanguageFileName(languageIndex);
					string text = PersistentStorage.LoadFile(PersistentStorage.eFileType.Temporal, savedLanguageFileName, logExceptions: false);
					if (!string.IsNullOrEmpty(text))
					{
						Import_Language_from_Cache(languageIndex, text, useFallback, onlyCurrentSpecialization);
						mLanguages[languageIndex].SetLoaded(loaded: true);
					}
				}
				if (!UnloadOtherLanguages || !I2Utils.IsPlaying())
				{
					return;
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (i != languageIndex)
					{
						UnloadLanguage(i);
					}
				}
			}

			public void LoadAllLanguages(bool forceLoad = false)
			{
				for (int i = 0; i < mLanguages.Count; i++)
				{
					LoadLanguage(i, UnloadOtherLanguages: false, useFallback: false, onlyCurrentSpecialization: false, forceLoad);
				}
			}

			public void UnloadLanguage(int languageIndex)
			{
				if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles() || !I2Utils.IsPlaying() || !mLanguages[languageIndex].IsLoaded() || !mLanguages[languageIndex].CanBeUnloaded() || IsCurrentLanguage(languageIndex) || !PersistentStorage.HasFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(languageIndex)))
				{
					return;
				}
				foreach (TermData mTerm in mTerms)
				{
					mTerm.Languages[languageIndex] = null;
				}
				mLanguages[languageIndex].SetLoaded(loaded: false);
			}

			public void SaveLanguages(bool unloadAll, PersistentStorage.eFileType fileLocation = PersistentStorage.eFileType.Temporal)
			{
				if (!AllowUnloadingLanguages() || !PersistentStorage.CanAccessFiles())
				{
					return;
				}
				for (int i = 0; i < mLanguages.Count; i++)
				{
					string text = Export_Language_to_Cache(i, IsCurrentLanguage(i));
					if (!string.IsNullOrEmpty(text))
					{
						PersistentStorage.SaveFile(PersistentStorage.eFileType.Temporal, GetSavedLanguageFileName(i), text);
					}
				}
				if (!unloadAll)
				{
					return;
				}
				for (int j = 0; j < mLanguages.Count; j++)
				{
					if (unloadAll && !IsCurrentLanguage(j))
					{
						UnloadLanguage(j);
					}
				}
			}

			public bool HasUnloadedLanguages()
			{
				for (int i = 0; i < mLanguages.Count; i++)
				{
					if (!mLanguages[i].IsLoaded())
					{
						return true;
					}
				}
				return false;
			}

			public List<string> GetCategories(bool OnlyMainCategory = false, List<string> Categories = null)
			{
				if (Categories == null)
				{
					Categories = new List<string>();
				}
				foreach (TermData mTerm in mTerms)
				{
					string categoryFromFullTerm = GetCategoryFromFullTerm(mTerm.Term, OnlyMainCategory);
					if (!Categories.Contains(categoryFromFullTerm))
					{
						Categories.Add(categoryFromFullTerm);
					}
				}
				Categories.Sort();
				return Categories;
			}

			public static string GetKeyFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
			{
				int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
				if (num >= 0)
				{
					return FullTerm.Substring(num + 1);
				}
				return FullTerm;
			}

			public static string GetCategoryFromFullTerm(string FullTerm, bool OnlyMainCategory = false)
			{
				int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
				if (num >= 0)
				{
					return FullTerm.Substring(0, num);
				}
				return EmptyCategory;
			}

			public static void DeserializeFullTerm(string FullTerm, out string Key, out string Category, bool OnlyMainCategory = false)
			{
				int num = (OnlyMainCategory ? FullTerm.IndexOfAny(CategorySeparators) : FullTerm.LastIndexOfAny(CategorySeparators));
				if (num < 0)
				{
					Category = EmptyCategory;
					Key = FullTerm;
				}
				else
				{
					Category = FullTerm.Substring(0, num);
					Key = FullTerm.Substring(num + 1);
				}
			}

			public void UpdateDictionary(bool force = false)
			{
				if (force || mDictionary == null || mDictionary.Count != mTerms.Count)
				{
					StringComparer stringComparer = (CaseInsensitiveTerms ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
					if (mDictionary.Comparer != stringComparer)
					{
						mDictionary = new Dictionary<string, TermData>(stringComparer);
					}
					else
					{
						mDictionary.Clear();
					}
					int i = 0;
					for (int count = mTerms.Count; i < count; i++)
					{
						TermData termData = mTerms[i];
						ValidateFullTerm(ref termData.Term);
						mDictionary[termData.Term] = mTerms[i];
						mTerms[i].Validate();
					}
					if (I2Utils.IsPlaying())
					{
						SaveLanguages(unloadAll: true);
					}
				}
			}

			public string GetTranslation(string term, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
			{
				TryGetTranslation(term, out var Translation, overrideLanguage, overrideSpecialization, skipDisabled, allowCategoryMistmatch);
				return Translation;
			}

			public bool TryGetTranslation(string term, out string Translation, string overrideLanguage = null, string overrideSpecialization = null, bool skipDisabled = false, bool allowCategoryMistmatch = false)
			{
				int languageIndex = GetLanguageIndex((overrideLanguage == null) ? LocalizationManager.CurrentLanguage : overrideLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
				if (languageIndex >= 0 && (!skipDisabled || mLanguages[languageIndex].IsEnabled()))
				{
					TermData termData = GetTermData(term, allowCategoryMistmatch);
					if (termData != null)
					{
						Translation = termData.GetTranslation(languageIndex, overrideSpecialization, editMode: true);
						if (Translation == "---")
						{
							Translation = string.Empty;
							return true;
						}
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
						Translation = null;
					}
					if (OnMissingTranslation == MissingTranslationAction.ShowWarning)
					{
						Translation = "<!-Missing Translation [" + term + "]-!>";
						return false;
					}
					if (OnMissingTranslation == MissingTranslationAction.Fallback && termData != null)
					{
						return TryGetFallbackTranslation(termData, out Translation, languageIndex, overrideSpecialization, skipDisabled);
					}
					if (OnMissingTranslation == MissingTranslationAction.Empty)
					{
						Translation = string.Empty;
						return false;
					}
					if (OnMissingTranslation == MissingTranslationAction.ShowTerm)
					{
						Translation = term;
						return false;
					}
				}
				Translation = null;
				return false;
			}

			private bool TryGetFallbackTranslation(TermData termData, out string Translation, int langIndex, string overrideSpecialization = null, bool skipDisabled = false)
			{
				string text = mLanguages[langIndex].Code;
				if (!string.IsNullOrEmpty(text))
				{
					if (text.Contains('-'))
					{
						text = text.Substring(0, text.IndexOf('-'));
					}
					for (int i = 0; i < mLanguages.Count; i++)
					{
						if (i != langIndex && mLanguages[i].Code.StartsWith(text, StringComparison.Ordinal) && (!skipDisabled || mLanguages[i].IsEnabled()))
						{
							Translation = termData.GetTranslation(i, overrideSpecialization, editMode: true);
							if (!string.IsNullOrEmpty(Translation))
							{
								return true;
							}
						}
					}
				}
				for (int j = 0; j < mLanguages.Count; j++)
				{
					if (j != langIndex && (!skipDisabled || mLanguages[j].IsEnabled()) && (text == null || !mLanguages[j].Code.StartsWith(text, StringComparison.Ordinal)))
					{
						Translation = termData.GetTranslation(j, overrideSpecialization, editMode: true);
						if (!string.IsNullOrEmpty(Translation))
						{
							return true;
						}
					}
				}
				Translation = null;
				return false;
			}

			public TermData AddTerm(string term)
			{
				return AddTerm(term, eTermType.Text);
			}

			public TermData GetTermData(string term, bool allowCategoryMistmatch = false)
			{
				if (string.IsNullOrEmpty(term))
				{
					return null;
				}
				if (mDictionary.Count == 0)
				{
					UpdateDictionary();
				}
				if (mDictionary.TryGetValue(term, out var value))
				{
					return value;
				}
				TermData termData = null;
				if (allowCategoryMistmatch)
				{
					string keyFromFullTerm = GetKeyFromFullTerm(term);
					foreach (KeyValuePair<string, TermData> item in mDictionary)
					{
						if (item.Value.IsTerm(keyFromFullTerm, allowCategoryMistmatch: true))
						{
							if (termData != null)
							{
								return null;
							}
							termData = item.Value;
						}
					}
				}
				return termData;
			}

			public bool ContainsTerm(string term)
			{
				return GetTermData(term) != null;
			}

			public List<string> GetTermsList(string Category = null)
			{
				if (mDictionary.Count != mTerms.Count)
				{
					UpdateDictionary();
				}
				if (string.IsNullOrEmpty(Category))
				{
					return new List<string>(mDictionary.Keys);
				}
				List<string> list = new List<string>();
				for (int i = 0; i < mTerms.Count; i++)
				{
					TermData termData = mTerms[i];
					if (GetCategoryFromFullTerm(termData.Term) == Category)
					{
						list.Add(termData.Term);
					}
				}
				return list;
			}

			public TermData AddTerm(string NewTerm, eTermType termType, bool SaveSource = true)
			{
				ValidateFullTerm(ref NewTerm);
				NewTerm = NewTerm.Trim();
				if (mLanguages.Count == 0)
				{
					AddLanguage("English", "en");
				}
				TermData termData = GetTermData(NewTerm);
				if (termData == null)
				{
					termData = new TermData();
					termData.Term = NewTerm;
					termData.TermType = termType;
					termData.Languages = new string[mLanguages.Count];
					termData.Flags = new byte[mLanguages.Count];
					mTerms.Add(termData);
					mDictionary.Add(NewTerm, termData);
				}
				return termData;
			}

			public void RemoveTerm(string term)
			{
				int i = 0;
				for (int count = mTerms.Count; i < count; i++)
				{
					if (mTerms[i].Term == term)
					{
						mTerms.RemoveAt(i);
						mDictionary.Remove(term);
						break;
					}
				}
			}

			public static void ValidateFullTerm(ref string Term)
			{
				Term = Term.Replace('\\', '/');
				Term = Term.Trim();
				if (Term.StartsWith(EmptyCategory, StringComparison.Ordinal) && Term.Length > EmptyCategory.Length && Term[EmptyCategory.Length] == '/')
				{
					Term = Term.Substring(EmptyCategory.Length + 1);
				}
				Term = I2Utils.GetValidTermName(Term, allowCategory: true);
			}
		}
		public enum eSpreadsheetUpdateMode
		{
			None,
			Replace,
			Merge,
			AddNewTerms
		}
		public class LocalizationReader
		{
			public static Dictionary<string, string> ReadTextAsset(TextAsset asset)
			{
				StringReader stringReader = new StringReader(Encoding.UTF8.GetString(asset.bytes, 0, asset.bytes.Length).Replace("\r\n", "\n").Replace("\r", "\n"));
				Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.Ordinal);
				string line;
				while ((line = stringReader.ReadLine()) != null)
				{
					if (TextAsset_ReadLine(line, out var key, out var value, out var _, out var _, out var _) && !string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(value))
					{
						dictionary[key] = value;
					}
				}
				return dictionary;
			}

			public static bool TextAsset_ReadLine(string line, out string key, out string value, out string category, out string comment, out string termType)
			{
				key = string.Empty;
				category = string.Empty;
				comment = string.Empty;
				termType = string.Empty;
				value = string.Empty;
				int num = line.LastIndexOf("//", StringComparison.Ordinal);
				if (num >= 0)
				{
					comment = line.Substring(num + 2).Trim();
					comment = DecodeString(comment);
					line = line.Substring(0, num);
				}
				int num2 = line.IndexOf("=", StringComparison.Ordinal);
				if (num2 < 0)
				{
					return false;
				}
				key = line.Substring(0, num2).Trim();
				value = line.Substring(num2 + 1).Trim();
				value = value.Replace("\r\n", "\n").Replace("\n", "\\n");
				value = DecodeString(value);
				if (key.Length > 2 && key[0] == '[')
				{
					int num3 = key.IndexOf(']');
					if (num3 >= 0)
					{
						termType = key.Substring(1, num3 - 1);
						key = key.Substring(num3 + 1);
					}
				}
				ValidateFullTerm(ref key);
				return true;
			}

			public static string ReadCSVfile(string Path, Encoding encoding)
			{
				string text = string.Empty;
				using (StreamReader streamReader = new StreamReader(Path, encoding))
				{
					text = streamReader.ReadToEnd();
				}
				text = text.Replace("\r\n", "\n");
				return text.Replace("\r", "\n");
			}

			public static List<string[]> ReadCSV(string Text, char Separator = ',')
			{
				int iStart = 0;
				List<string[]> list = new List<string[]>();
				while (iStart < Text.Length)
				{
					string[] array = ParseCSVline(Text, ref iStart, Separator);
					if (array == null)
					{
						break;
					}
					list.Add(array);
				}
				return list;
			}

			private static string[] ParseCSVline(string Line, ref int iStart, char Separator)
			{
				List<string> list = new List<string>();
				int length = Line.Length;
				int iWordStart = iStart;
				bool flag = false;
				while (iStart < length)
				{
					char c = Line[iStart];
					if (flag)
					{
						if (c == '"')
						{
							if (iStart + 1 >= length || Line[iStart + 1] != '"')
							{
								flag = false;
							}
							else if (iStart + 2 < length && Line[iStart + 2] == '"')
							{
								flag = false;
								iStart += 2;
							}
							else
							{
								iStart++;
							}
						}
					}
					else if (c == '\n' || c == Separator)
					{
						AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
						if (c == '\n')
						{
							iStart++;
							break;
						}
					}
					else if (c == '"')
					{
						flag = true;
					}
					iStart++;
				}
				if (iStart > iWordStart)
				{
					AddCSVtoken(ref list, ref Line, iStart, ref iWordStart);
				}
				return list.ToArray();
			}

			private static void AddCSVtoken(ref List<string> list, ref string Line, int iEnd, ref int iWordStart)
			{
				string text = Line.Substring(iWordStart, iEnd - iWordStart);
				iWordStart = iEnd + 1;
				text = text.Replace("\"\"", "\"");
				if (text.Length > 1 && text[0] == '"' && text[text.Length - 1] == '"')
				{
					text = text.Substring(1, text.Length - 2);
				}
				list.Add(text);
			}

			public static List<string[]> ReadI2CSV(string Text)
			{
				string[] separator = new string[1] { "[*]" };
				string[] separator2 = new string[1] { "[ln]" };
				List<string[]> list = new List<string[]>();
				string[] array = Text.Split(separator2, StringSplitOptions.None);
				foreach (string text in array)
				{
					list.Add(text.Split(separator, StringSplitOptions.None));
				}
				return list;
			}

			public static void ValidateFullTerm(ref string Term)
			{
				Term = Term.Replace('\\', '/');
				int num = Term.IndexOf('/');
				if (num >= 0)
				{
					int startIndex;
					while ((startIndex = Term.LastIndexOf('/')) != num)
					{
						Term = Term.Remove(startIndex, 1);
					}
				}
			}

			public static string EncodeString(string str)
			{
				if (string.IsNullOrEmpty(str))
				{
					return string.Empty;
				}
				return str.Replace("\r\n", "<\\n>").Replace("\r", "<\\n>").Replace("\n", "<\\n>");
			}

			public static string DecodeString(string str)
			{
				if (string.IsNullOrEmpty(str))
				{
					return string.Empty;
				}
				return str.Replace("<\\n>", "\r\n");
			}
		}
		[AddComponentMenu("I2/Localization/I2 Localize")]
		public class Localize : MonoBehaviour
		{
			public enum TermModification
			{
				DontModify,
				ToUpper,
				ToLower,
				ToUpperFirst,
				ToTitle
			}

			public string mTerm = string.Empty;

			public string mTermSecondary = string.Empty;

			[NonSerialized]
			public string FinalTerm;

			[NonSerialized]
			public string FinalSecondaryTerm;

			public TermModification PrimaryTermModifier;

			public TermModification SecondaryTermModifier;

			public string TermPrefix;

			public string TermSuffix;

			public bool LocalizeOnAwake = true;

			private string LastLocalizedLanguage;

			public bool IgnoreRTL;

			public int MaxCharactersInRTL;

			public bool IgnoreNumbersInRTL = true;

			public bool CorrectAlignmentForRTL = true;

			public bool AddSpacesToJoinedLanguages;

			public bool AllowLocalizedParameters = true;

			public bool AllowParameters = true;

			public List<UnityEngine.Object> TranslatedObjects = new List<UnityEngine.Object>();

			[NonSerialized]
			public Dictionary<string, UnityEngine.Object> mAssetDictionary = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

			public UnityEvent LocalizeEvent = new UnityEvent();

			public static string MainTranslation;

			public static string SecondaryTranslation;

			public static string CallBackTerm;

			public static string CallBackSecondaryTerm;

			public static Localize CurrentLocalizeComponent;

			public bool AlwaysForceLocalize;

			[SerializeField]
			public EventCallback LocalizeCallBack = new EventCallback();

			public bool mGUI_ShowReferences;

			public bool mGUI_ShowTems = true;

			public bool mGUI_ShowCallback;

			public ILocalizeTarget mLocalizeTarget;

			public string mLocalizeTargetName;

			public string Term
			{
				get
				{
					return mTerm;
				}
				set
				{
					SetTerm(value);
				}
			}

			public string SecondaryTerm
			{
				get
				{
					return mTermSecondary;
				}
				set
				{
					SetTerm(null, value);
				}
			}

			private void Awake()
			{
				UpdateAssetDictionary();
				FindTarget();
				if (LocalizeOnAwake)
				{
					OnLocalize();
				}
			}

			private void OnEnable()
			{
				OnLocalize();
			}

			public bool HasCallback()
			{
				if (LocalizeCallBack.HasCallback())
				{
					return true;
				}
				return LocalizeEvent.GetPersistentEventCount() > 0;
			}

			public void OnLocalize(bool Force = false)
			{
				if ((!Force && (!base.enabled || base.gameObject == null || !base.gameObject.activeInHierarchy)) || string.IsNullOrEmpty(LocalizationManager.CurrentLanguage) || (!AlwaysForceLocalize && !Force && !HasCallback() && LastLocalizedLanguage == LocalizationManager.CurrentLanguage))
				{
					return;
				}
				LastLocalizedLanguage = LocalizationManager.CurrentLanguage;
				if (string.IsNullOrEmpty(FinalTerm) || string.IsNullOrEmpty(FinalSecondaryTerm))
				{
					GetFinalTerms(out FinalTerm, out FinalSecondaryTerm);
				}
				bool flag = I2Utils.IsPlaying() && HasCallback();
				if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(FinalSecondaryTerm))
				{
					return;
				}
				CallBackTerm = FinalTerm;
				CallBackSecondaryTerm = FinalSecondaryTerm;
				MainTranslation = ((string.IsNullOrEmpty(FinalTerm) || FinalTerm == "-") ? null : LocalizationManager.GetTranslation(FinalTerm, FixForRTL: false));
				SecondaryTranslation = ((string.IsNullOrEmpty(FinalSecondaryTerm) || FinalSecondaryTerm == "-") ? null : LocalizationManager.GetTranslation(FinalSecondaryTerm, FixForRTL: false));
				if (!flag && string.IsNullOrEmpty(FinalTerm) && string.IsNullOrEmpty(SecondaryTranslation))
				{
					return;
				}
				CurrentLocalizeComponent = this;
				LocalizeCallBack.Execute(this);
				LocalizeEvent.Invoke();
				if (AllowParameters)
				{
					LocalizationManager.ApplyLocalizationParams(ref MainTranslation, base.gameObject, AllowLocalizedParameters);
				}
				if (!FindTarget())
				{
					return;
				}
				bool flag2 = LocalizationManager.IsRight2Left && !IgnoreRTL;
				if (MainTranslation != null)
				{
					switch (PrimaryTermModifier)
					{
					case TermModification.ToUpper:
						MainTranslation = MainTranslation.ToUpper();
						break;
					case TermModification.ToLower:
						MainTranslation = MainTranslation.ToLower();
						break;
					case TermModification.ToUpperFirst:
						MainTranslation = GoogleTranslation.UppercaseFirst(MainTranslation);
						break;
					case TermModification.ToTitle:
						MainTranslation = GoogleTranslation.TitleCase(MainTranslation);
						break;
					}
					if (!string.IsNullOrEmpty(TermPrefix))
					{
						MainTranslation = (flag2 ? (MainTranslation + TermPrefix) : (TermPrefix + MainTranslation));
					}
					if (!string.IsNullOrEmpty(TermSuffix))
					{
						MainTranslation = (flag2 ? (TermSuffix + MainTranslation) : (MainTranslation + TermSuffix));
					}
					if (AddSpacesToJoinedLanguages && LocalizationManager.HasJoinedWords && !string.IsNullOrEmpty(MainTranslation))
					{
						StringBuilder stringBuilder = new StringBuilder();
						stringBuilder.Append(MainTranslation[0]);
						int i = 1;
						for (int length = MainTranslation.Length; i < length; i++)
						{
							stringBuilder.Append(' ');
							stringBuilder.Append(MainTranslation[i]);
						}
						MainTranslation = stringBuilder.ToString();
					}
					if (flag2 && mLocalizeTarget.AllowMainTermToBeRTL() && !string.IsNullOrEmpty(MainTranslation))
					{
						MainTranslation = LocalizationManager.ApplyRTLfix(MainTranslation, MaxCharactersInRTL, IgnoreNumbersInRTL);
					}
				}
				if (SecondaryTranslation != null)
				{
					switch (SecondaryTermModifier)
					{
					case TermModification.ToUpper:
						SecondaryTranslation = SecondaryTranslation.ToUpper();
						break;
					case TermModification.ToLower:
						SecondaryTranslation = SecondaryTranslation.ToLower();
						break;
					case TermModification.ToUpperFirst:
						SecondaryTranslation = GoogleTranslation.UppercaseFirst(SecondaryTranslation);
						break;
					case TermModification.ToTitle:
						SecondaryTranslation = GoogleTranslation.TitleCase(SecondaryTranslation);
						break;
					}
					if (flag2 && mLocalizeTarget.AllowSecondTermToBeRTL() && !string.IsNullOrEmpty(SecondaryTranslation))
					{
						SecondaryTranslation = LocalizationManager.ApplyRTLfix(SecondaryTranslation);
					}
				}
				if (LocalizationManager.HighlightLocalizedTargets)
				{
					MainTranslation = "LOC:" + FinalTerm;
				}
				mLocalizeTarget.DoLocalize(this, MainTranslation, SecondaryTranslation);
				CurrentLocalizeComponent = null;
			}

			public bool FindTarget()
			{
				if (mLocalizeTarget != null && mLocalizeTarget.IsValid(this))
				{
					return true;
				}
				if (mLocalizeTarget != null)
				{
					UnityEngine.Object.DestroyImmediate(mLocalizeTarget);
					mLocalizeTarget = null;
					mLocalizeTargetName = null;
				}
				if (!string.IsNullOrEmpty(mLocalizeTargetName))
				{
					foreach (ILocalizeTargetDescriptor mLocalizeTarget in LocalizationManager.mLocalizeTargets)
					{
						if (mLocalizeTargetName == mLocalizeTarget.GetTargetType().ToString())
						{
							if (mLocalizeTarget.CanLocalize(this))
							{
								this.mLocalizeTarget = mLocalizeTarget.CreateTarget(this);
							}
							if (this.mLocalizeTarget != null)
							{
								return true;
							}
						}
					}
				}
				foreach (ILocalizeTargetDescriptor mLocalizeTarget2 in LocalizationManager.mLocalizeTargets)
				{
					if (mLocalizeTarget2.CanLocalize(this))
					{
						this.mLocalizeTarget = mLocalizeTarget2.CreateTarget(this);
						mLocalizeTargetName = mLocalizeTarget2.GetTargetType().ToString();
						if (this.mLocalizeTarget != null)
						{
							return true;
						}
					}
				}
				return false;
			}

			public void GetFinalTerms(out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = string.Empty;
				secondaryTerm = string.Empty;
				if (FindTarget())
				{
					if (mLocalizeTarget != null)
					{
						mLocalizeTarget.GetFinalTerms(this, mTerm, mTermSecondary, out primaryTerm, out secondaryTerm);
						primaryTerm = I2Utils.GetValidTermName(primaryTerm);
					}
					if (!string.IsNullOrEmpty(mTerm))
					{
						primaryTerm = mTerm;
					}
					if (!string.IsNullOrEmpty(mTermSecondary))
					{
						secondaryTerm = mTermSecondary;
					}
					if (primaryTerm != null)
					{
						primaryTerm = primaryTerm.Trim();
					}
					if (secondaryTerm != null)
					{
						secondaryTerm = secondaryTerm.Trim();
					}
				}
			}

			public string GetMainTargetsText()
			{
				string primaryTerm = null;
				string secondaryTerm = null;
				if (mLocalizeTarget != null)
				{
					mLocalizeTarget.GetFinalTerms(this, null, null, out primaryTerm, out secondaryTerm);
				}
				if (!string.IsNullOrEmpty(primaryTerm))
				{
					return primaryTerm;
				}
				return mTerm;
			}

			public void SetFinalTerms(string Main, string Secondary, out string primaryTerm, out string secondaryTerm, bool RemoveNonASCII)
			{
				primaryTerm = (RemoveNonASCII ? I2Utils.GetValidTermName(Main) : Main);
				secondaryTerm = Secondary;
			}

			public void SetTerm(string primary)
			{
				if (!string.IsNullOrEmpty(primary))
				{
					FinalTerm = (mTerm = primary);
				}
				OnLocalize(Force: true);
			}

			public void SetTerm(string primary, string secondary)
			{
				if (!string.IsNullOrEmpty(primary))
				{
					FinalTerm = (mTerm = primary);
				}
				FinalSecondaryTerm = (mTermSecondary = secondary);
				OnLocalize(Force: true);
			}

			internal T GetSecondaryTranslatedObj<T>(ref string mainTranslation, ref string secondaryTranslation) where T : UnityEngine.Object
			{
				DeserializeTranslation(mainTranslation, out var value, out var secondary);
				T val = null;
				if (!string.IsNullOrEmpty(secondary))
				{
					val = GetObject<T>(secondary);
					if (val != null)
					{
						mainTranslation = value;
						secondaryTranslation = secondary;
					}
				}
				if (val == null)
				{
					val = GetObject<T>(secondaryTranslation);
				}
				return val;
			}

			public void UpdateAssetDictionary()
			{
				TranslatedObjects.RemoveAll((UnityEngine.Object x) => x == null);
				mAssetDictionary = (from o in TranslatedObjects.Distinct()
					group o by o.name).ToDictionary((IGrouping<string, UnityEngine.Object> g) => g.Key, (IGrouping<string, UnityEngine.Object> g) => g.First());
			}

			internal T GetObject<T>(string Translation) where T : UnityEngine.Object
			{
				if (string.IsNullOrEmpty(Translation))
				{
					return null;
				}
				return GetTranslatedObject<T>(Translation);
			}

			private T GetTranslatedObject<T>(string Translation) where T : UnityEngine.Object
			{
				return FindTranslatedObject<T>(Translation);
			}

			private void DeserializeTranslation(string translation, out string value, out string secondary)
			{
				if (!string.IsNullOrEmpty(translation) && translation.Length > 1 && translation[0] == '[')
				{
					int num = translation.IndexOf(']');
					if (num > 0)
					{
						secondary = translation.Substring(1, num - 1);
						value = translation.Substring(num + 1);
						return;
					}
				}
				value = translation;
				secondary = string.Empty;
			}

			public T FindTranslatedObject<T>(string value) where T : UnityEngine.Object
			{
				if (string.IsNullOrEmpty(value))
				{
					return null;
				}
				if (mAssetDictionary == null || mAssetDictionary.Count != TranslatedObjects.Count)
				{
					UpdateAssetDictionary();
				}
				foreach (KeyValuePair<string, UnityEngine.Object> item in mAssetDictionary)
				{
					if (item.Value is T && value.EndsWith(item.Key, StringComparison.OrdinalIgnoreCase) && string.Compare(value, item.Key, StringComparison.OrdinalIgnoreCase) == 0)
					{
						return (T)item.Value;
					}
				}
				T val = LocalizationManager.FindAsset(value) as T;
				if ((bool)val)
				{
					return val;
				}
				return ResourceManager.pInstance.GetAsset<T>(value);
			}

			public bool HasTranslatedObject(UnityEngine.Object Obj)
			{
				if (TranslatedObjects.Contains(Obj))
				{
					return true;
				}
				return ResourceManager.pInstance.HasAsset(Obj);
			}

			public void AddTranslatedObject(UnityEngine.Object Obj)
			{
				if (!TranslatedObjects.Contains(Obj))
				{
					TranslatedObjects.Add(Obj);
					UpdateAssetDictionary();
				}
			}

			public void SetGlobalLanguage(string Language)
			{
				LocalizationManager.CurrentLanguage = Language;
			}
		}
		[AddComponentMenu("I2/Localization/Localize Dropdown")]
		public class LocalizeDropdown : MonoBehaviour
		{
			public List<string> _Terms = new List<string>();

			public void Start()
			{
				LocalizationManager.OnLocalizeEvent += OnLocalize;
				OnLocalize();
			}

			public void OnDestroy()
			{
				LocalizationManager.OnLocalizeEvent -= OnLocalize;
			}

			private void OnEnable()
			{
				if (_Terms.Count == 0)
				{
					FillValues();
				}
				OnLocalize();
			}

			public void OnLocalize()
			{
				if (base.enabled && !(base.gameObject == null) && base.gameObject.activeInHierarchy && !string.IsNullOrEmpty(LocalizationManager.CurrentLanguage))
				{
					UpdateLocalization();
				}
			}

			private void FillValues()
			{
				Dropdown component = GetComponent<Dropdown>();
				if (component == null && I2Utils.IsPlaying())
				{
					FillValuesTMPro();
					return;
				}
				foreach (Dropdown.OptionData option in component.options)
				{
					_Terms.Add(option.text);
				}
			}

			public void UpdateLocalization()
			{
				Dropdown component = GetComponent<Dropdown>();
				if (component == null)
				{
					UpdateLocalizationTMPro();
					return;
				}
				component.options.Clear();
				foreach (string term in _Terms)
				{
					string translation = LocalizationManager.GetTranslation(term);
					component.options.Add(new Dropdown.OptionData(translation));
				}
				component.RefreshShownValue();
			}

			public void UpdateLocalizationTMPro()
			{
				TMP_Dropdown component = GetComponent<TMP_Dropdown>();
				if (component == null)
				{
					return;
				}
				component.options.Clear();
				foreach (string term in _Terms)
				{
					string translation = LocalizationManager.GetTranslation(term);
					component.options.Add(new TMP_Dropdown.OptionData(translation));
				}
				component.RefreshShownValue();
			}

			private void FillValuesTMPro()
			{
				TMP_Dropdown component = GetComponent<TMP_Dropdown>();
				if (component == null)
				{
					return;
				}
				foreach (TMP_Dropdown.OptionData option in component.options)
				{
					_Terms.Add(option.text);
				}
			}
		}
		public static class LocalizationManager
		{
			public delegate bool FnCustomApplyLocalizationParams(ref string translation, _GetParam getParam, bool allowLocalizedParameters);

			public delegate object _GetParam(string param);

			public delegate void OnLocalizeCallback();

			private static string mCurrentLanguage;

			private static string mLanguageCode;

			private static CultureInfo mCurrentCulture;

			private static bool mChangeCultureInfo;

			public static bool IsRight2Left;

			public static bool HasJoinedWords;

			public static List<ILocalizationParamsManager> ParamManagers = new List<ILocalizationParamsManager>();

			public static FnCustomApplyLocalizationParams CustomApplyLocalizationParams;

			private static string[] LanguagesRTL = new string[21]
			{
				"ar-DZ", "ar", "ar-BH", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA",
				"ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-AE", "ar-YE", "fa", "he", "ur",
				"ji"
			};

			public static List<LanguageSourceData> Sources = new List<LanguageSourceData>();

			public static string[] GlobalSources = new string[1] { "I2Languages" };

			public static Func<LanguageSourceData, bool> Callback_AllowSyncFromGoogle = null;

			private static string mCurrentDeviceLanguage;

			public static List<ILocalizeTargetDescriptor> mLocalizeTargets = new List<ILocalizeTargetDescriptor>();

			private static bool mLocalizeIsScheduled;

			private static bool mLocalizeIsScheduledWithForcedValue;

			public static bool HighlightLocalizedTargets = false;

			public static string CurrentLanguage
			{
				get
				{
					InitializeIfNeeded();
					return mCurrentLanguage;
				}
				set
				{
					InitializeIfNeeded();
					string supportedLanguage = GetSupportedLanguage(value);
					if (!string.IsNullOrEmpty(supportedLanguage) && mCurrentLanguage != supportedLanguage)
					{
						SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage));
					}
				}
			}

			public static string CurrentLanguageCode
			{
				get
				{
					InitializeIfNeeded();
					return mLanguageCode;
				}
				set
				{
					InitializeIfNeeded();
					if (mLanguageCode != value)
					{
						string languageFromCode = GetLanguageFromCode(value);
						if (!string.IsNullOrEmpty(languageFromCode))
						{
							SetLanguageAndCode(languageFromCode, value);
						}
					}
				}
			}

			public static string CurrentRegion
			{
				get
				{
					string currentLanguage = CurrentLanguage;
					int num = currentLanguage.IndexOfAny("/\\".ToCharArray());
					if (num > 0)
					{
						return currentLanguage.Substring(num + 1);
					}
					num = currentLanguage.IndexOfAny("[(".ToCharArray());
					int num2 = currentLanguage.LastIndexOfAny("])".ToCharArray());
					if (num > 0 && num != num2)
					{
						return currentLanguage.Substring(num + 1, num2 - num - 1);
					}
					return string.Empty;
				}
				set
				{
					string text = CurrentLanguage;
					int num = text.IndexOfAny("/\\".ToCharArray());
					if (num > 0)
					{
						CurrentLanguage = text.Substring(num + 1) + value;
						return;
					}
					num = text.IndexOfAny("[(".ToCharArray());
					int num2 = text.LastIndexOfAny("])".ToCharArray());
					if (num > 0 && num != num2)
					{
						text = text.Substring(num);
					}
					CurrentLanguage = text + "(" + value + ")";
				}
			}

			public static string CurrentRegionCode
			{
				get
				{
					string currentLanguageCode = CurrentLanguageCode;
					int num = currentLanguageCode.IndexOfAny(" -_/\\".ToCharArray());
					if (num >= 0)
					{
						return currentLanguageCode.Substring(num + 1);
					}
					return string.Empty;
				}
				set
				{
					string text = CurrentLanguageCode;
					int num = text.IndexOfAny(" -_/\\".ToCharArray());
					if (num > 0)
					{
						text = text.Substring(0, num);
					}
					CurrentLanguageCode = text + "-" + value;
				}
			}

			public static CultureInfo CurrentCulture => mCurrentCulture;

			public static event OnLocalizeCallback OnLocalizeEvent;

			public static void InitializeIfNeeded()
			{
				if (string.IsNullOrEmpty(mCurrentLanguage) || Sources.Count == 0)
				{
					AutoLoadGlobalParamManagers();
					UpdateSources();
					SelectStartupLanguage();
				}
			}

			public static string GetVersion()
			{
				return "2.8.17 f1";
			}

			public static int GetRequiredWebServiceVersion()
			{
				return 5;
			}

			public static string GetWebServiceURL(LanguageSourceData source = null)
			{
				if (source != null && !string.IsNullOrEmpty(source.Google_WebServiceURL))
				{
					return source.Google_WebServiceURL;
				}
				InitializeIfNeeded();
				for (int i = 0; i < Sources.Count; i++)
				{
					if (Sources[i] != null && !string.IsNullOrEmpty(Sources[i].Google_WebServiceURL))
					{
						return Sources[i].Google_WebServiceURL;
					}
				}
				return string.Empty;
			}

			public static void SetLanguageAndCode(string LanguageName, string LanguageCode, bool RememberLanguage = true, bool Force = false)
			{
				if (mCurrentLanguage != LanguageName || mLanguageCode != LanguageCode || Force)
				{
					if (RememberLanguage)
					{
						PersistentStorage.SetSetting_String("I2 Language", LanguageName);
					}
					mCurrentLanguage = LanguageName;
					mLanguageCode = LanguageCode;
					mCurrentCulture = CreateCultureForCode(LanguageCode);
					if (mChangeCultureInfo)
					{
						SetCurrentCultureInfo();
					}
					IsRight2Left = IsRTL(mLanguageCode);
					HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
					LocalizeAll(Force);
				}
			}

			private static CultureInfo CreateCultureForCode(string code)
			{
				try
				{
					return CultureInfo.CreateSpecificCulture(code);
				}
				catch (Exception)
				{
					return CultureInfo.InvariantCulture;
				}
			}

			public static void EnableChangingCultureInfo(bool bEnable)
			{
				if (!mChangeCultureInfo && bEnable)
				{
					SetCurrentCultureInfo();
				}
				mChangeCultureInfo = bEnable;
			}

			private static void SetCurrentCultureInfo()
			{
				Thread.CurrentThread.CurrentCulture = mCurrentCulture;
			}

			private static void SelectStartupLanguage()
			{
				if (Sources.Count == 0)
				{
					return;
				}
				string setting_String = PersistentStorage.GetSetting_String("I2 Language", string.Empty);
				string currentDeviceLanguage = GetCurrentDeviceLanguage();
				if (!string.IsNullOrEmpty(setting_String) && HasLanguage(setting_String, AllowDiscartingRegion: true, Initialize: false))
				{
					SetLanguageAndCode(setting_String, GetLanguageCode(setting_String));
					return;
				}
				if (!Sources[0].IgnoreDeviceLanguage)
				{
					string supportedLanguage = GetSupportedLanguage(currentDeviceLanguage, ignoreDisabled: true);
					if (!string.IsNullOrEmpty(supportedLanguage))
					{
						SetLanguageAndCode(supportedLanguage, GetLanguageCode(supportedLanguage), RememberLanguage: false);
						return;
					}
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].mLanguages.Count <= 0)
					{
						continue;
					}
					for (int j = 0; j < Sources[i].mLanguages.Count; j++)
					{
						if (Sources[i].mLanguages[j].IsEnabled())
						{
							SetLanguageAndCode(Sources[i].mLanguages[j].Name, Sources[i].mLanguages[j].Code, RememberLanguage: false);
							return;
						}
					}
				}
			}

			public static bool HasLanguage(string Language, bool AllowDiscartingRegion = true, bool Initialize = true, bool SkipDisabled = true)
			{
				if (Initialize)
				{
					InitializeIfNeeded();
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].GetLanguageIndex(Language, AllowDiscartingRegion: false, SkipDisabled) >= 0)
					{
						return true;
					}
				}
				if (AllowDiscartingRegion)
				{
					int j = 0;
					for (int count2 = Sources.Count; j < count2; j++)
					{
						if (Sources[j].GetLanguageIndex(Language, AllowDiscartingRegion: true, SkipDisabled) >= 0)
						{
							return true;
						}
					}
				}
				return false;
			}

			public static string GetSupportedLanguage(string Language, bool ignoreDisabled = false)
			{
				string languageCode = GoogleLanguages.GetLanguageCode(Language);
				if (!string.IsNullOrEmpty(languageCode))
				{
					int i = 0;
					for (int count = Sources.Count; i < count; i++)
					{
						int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: true, ignoreDisabled);
						if (languageIndexFromCode >= 0)
						{
							return Sources[i].mLanguages[languageIndexFromCode].Name;
						}
					}
					int j = 0;
					for (int count2 = Sources.Count; j < count2; j++)
					{
						int languageIndexFromCode2 = Sources[j].GetLanguageIndexFromCode(languageCode, exactMatch: false, ignoreDisabled);
						if (languageIndexFromCode2 >= 0)
						{
							return Sources[j].mLanguages[languageIndexFromCode2].Name;
						}
					}
				}
				int k = 0;
				for (int count3 = Sources.Count; k < count3; k++)
				{
					int languageIndex = Sources[k].GetLanguageIndex(Language, AllowDiscartingRegion: false, ignoreDisabled);
					if (languageIndex >= 0)
					{
						return Sources[k].mLanguages[languageIndex].Name;
					}
				}
				int l = 0;
				for (int count4 = Sources.Count; l < count4; l++)
				{
					int languageIndex2 = Sources[l].GetLanguageIndex(Language, AllowDiscartingRegion: true, ignoreDisabled);
					if (languageIndex2 >= 0)
					{
						return Sources[l].mLanguages[languageIndex2].Name;
					}
				}
				return string.Empty;
			}

			public static string GetLanguageCode(string Language)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndex = Sources[i].GetLanguageIndex(Language);
					if (languageIndex >= 0)
					{
						return Sources[i].mLanguages[languageIndex].Code;
					}
				}
				return string.Empty;
			}

			public static string GetLanguageFromCode(string Code, bool exactMatch = true)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(Code, exactMatch);
					if (languageIndexFromCode >= 0)
					{
						return Sources[i].mLanguages[languageIndexFromCode].Name;
					}
				}
				return string.Empty;
			}

			public static List<string> GetAllLanguages(bool SkipDisabled = true)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				List<string> Languages = new List<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Languages.AddRange(from x in Sources[i].GetLanguages(SkipDisabled)
						where !Languages.Contains(x)
						select x);
				}
				return Languages;
			}

			public static List<string> GetAllLanguagesCode(bool allowRegions = true, bool SkipDisabled = true)
			{
				List<string> Languages = new List<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Languages.AddRange(from x in Sources[i].GetLanguagesCode(allowRegions, SkipDisabled)
						where !Languages.Contains(x)
						select x);
				}
				return Languages;
			}

			public static bool IsLanguageEnabled(string Language)
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (!Sources[i].IsLanguageEnabled(Language))
					{
						return false;
					}
				}
				return true;
			}

			private static void LoadCurrentLanguage()
			{
				for (int i = 0; i < Sources.Count; i++)
				{
					int languageIndex = Sources[i].GetLanguageIndex(mCurrentLanguage, AllowDiscartingRegion: true, SkipDisabled: false);
					Sources[i].LoadLanguage(languageIndex, UnloadOtherLanguages: true, useFallback: true, onlyCurrentSpecialization: true, forceLoad: false);
				}
			}

			public static void PreviewLanguage(string NewLanguage)
			{
				mCurrentLanguage = NewLanguage;
				mLanguageCode = GetLanguageCode(mCurrentLanguage);
				IsRight2Left = IsRTL(mLanguageCode);
				HasJoinedWords = GoogleLanguages.LanguageCode_HasJoinedWord(mLanguageCode);
			}

			public static void AutoLoadGlobalParamManagers()
			{
				LocalizationParamsManager[] array = UnityEngine.Object.FindObjectsOfType<LocalizationParamsManager>();
				foreach (LocalizationParamsManager localizationParamsManager in array)
				{
					if (localizationParamsManager._IsGlobalManager && !ParamManagers.Contains(localizationParamsManager))
					{
						UnityEngine.Debug.Log(localizationParamsManager);
						ParamManagers.Add(localizationParamsManager);
					}
				}
			}

			public static void ApplyLocalizationParams(ref string translation, bool allowLocalizedParameters = true)
			{
				ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, null), allowLocalizedParameters);
			}

			public static void ApplyLocalizationParams(ref string translation, GameObject root, bool allowLocalizedParameters = true)
			{
				ApplyLocalizationParams(ref translation, (string p) => GetLocalizationParam(p, root), allowLocalizedParameters);
			}

			public static void ApplyLocalizationParams(ref string translation, Dictionary<string, object> parameters, bool allowLocalizedParameters = true)
			{
				ApplyLocalizationParams(ref translation, delegate(string p)
				{
					object value = null;
					return parameters.TryGetValue(p, out value) ? value : null;
				}, allowLocalizedParameters);
			}

			public static void ApplyLocalizationParams(ref string translation, _GetParam getParam, bool allowLocalizedParameters = true)
			{
				if (translation == null || (CustomApplyLocalizationParams != null && CustomApplyLocalizationParams(ref translation, getParam, allowLocalizedParameters)))
				{
					return;
				}
				string text = null;
				int num = 0;
				int length = translation.Length;
				int num2 = 0;
				while (num2 >= 0 && num2 < translation.Length)
				{
					int num3 = translation.IndexOf("{[", num2, StringComparison.Ordinal);
					if (num3 < 0)
					{
						break;
					}
					int num4 = translation.IndexOf("]}", num3, StringComparison.Ordinal);
					if (num4 < 0)
					{
						break;
					}
					int num5 = translation.IndexOf("{[", num3 + 1, StringComparison.Ordinal);
					if (num5 > 0 && num5 < num4)
					{
						num2 = num5;
						continue;
					}
					int num6 = ((translation[num3 + 2] == '#') ? 3 : 2);
					string param = translation.Substring(num3 + num6, num4 - num3 - num6);
					string text2 = (string)getParam(param);
					if (text2 != null)
					{
						if (allowLocalizedParameters)
						{
							LanguageSourceData source;
							TermData termData = GetTermData(text2, out source);
							if (termData != null)
							{
								int languageIndex = source.GetLanguageIndex(CurrentLanguage);
								if (languageIndex >= 0)
								{
									text2 = termData.GetTranslation(languageIndex);
								}
							}
						}
						string oldValue = translation.Substring(num3, num4 - num3 + 2);
						translation = translation.Replace(oldValue, text2);
						int result = 0;
						if (int.TryParse(text2, out result))
						{
							text = GoogleLanguages.GetPluralType(CurrentLanguageCode, result).ToString();
						}
						num2 = num3 + text2.Length;
					}
					else
					{
						num2 = num4 + 2;
					}
				}
				if (text != null)
				{
					string text3 = "[i2p_" + text + "]";
					num = translation.IndexOf(text3, StringComparison.OrdinalIgnoreCase);
					num = ((num >= 0) ? (num + text3.Length) : 0);
					length = translation.IndexOf("[i2p_", num + 1, StringComparison.OrdinalIgnoreCase);
					if (length < 0)
					{
						length = translation.Length;
					}
					translation = translation.Substring(num, length - num);
				}
			}

			internal static string GetLocalizationParam(string ParamName, GameObject root)
			{
				string text = null;
				if ((bool)root)
				{
					MonoBehaviour[] components = root.GetComponents<MonoBehaviour>();
					int i = 0;
					for (int num = components.Length; i < num; i++)
					{
						if (components[i] is ILocalizationParamsManager localizationParamsManager && components[i].enabled)
						{
							text = localizationParamsManager.GetParameterValue(ParamName);
							if (text != null)
							{
								return text;
							}
						}
					}
				}
				int j = 0;
				for (int count = ParamManagers.Count; j < count; j++)
				{
					text = ParamManagers[j].GetParameterValue(ParamName);
					if (text != null)
					{
						return text;
					}
				}
				return null;
			}

			private static string GetPluralType(MatchCollection matches, string langCode, _GetParam getParam)
			{
				int i = 0;
				for (int count = matches.Count; i < count; i++)
				{
					Match match = matches[i];
					string value = match.Groups[match.Groups.Count - 1].Value;
					string text = (string)getParam(value);
					if (text != null)
					{
						int result = 0;
						if (int.TryParse(text, out result))
						{
							return GoogleLanguages.GetPluralType(langCode, result).ToString();
						}
					}
				}
				return null;
			}

			public static string ApplyRTLfix(string line)
			{
				return ApplyRTLfix(line, 0, ignoreNumbers: true);
			}

			public static string ApplyRTLfix(string line, int maxCharacters, bool ignoreNumbers)
			{
				if (string.IsNullOrEmpty(line))
				{
					return line;
				}
				char c = line[0];
				if (c == '!' || c == '.' || c == '?')
				{
					line = line.Substring(1) + c;
				}
				int tagStart = -1;
				int num = 0;
				int num2 = 40000;
				num = 0;
				List<string> list = new List<string>();
				while (I2Utils.FindNextTag(line, num, out tagStart, out num))
				{
					string text = "@@" + (char)(num2 + list.Count) + "@@";
					list.Add(line.Substring(tagStart, num - tagStart + 1));
					line = line.Substring(0, tagStart) + text + line.Substring(num + 1);
					num = tagStart + 5;
				}
				line = line.Replace("\r\n", "\n");
				line = I2Utils.SplitLine(line, maxCharacters);
				line = RTLFixer.Fix(line, showTashkeel: true, !ignoreNumbers);
				for (int i = 0; i < list.Count; i++)
				{
					int length = line.Length;
					for (int j = 0; j < length - 4; j++)
					{
						if (line[j] == '@' && line[j + 1] == '@' && line[j + 2] >= num2 && line[j + 3] == '@' && line[j + 4] == '@')
						{
							int num3 = line[j + 2] - num2;
							num3 = ((num3 % 2 != 0) ? (num3 - 1) : (num3 + 1));
							if (num3 >= list.Count)
							{
								num3 = list.Count - 1;
							}
							line = line.Substring(0, j) + list[num3] + line.Substring(j + 5);
							break;
						}
					}
				}
				return line;
			}

			public static string FixRTL_IfNeeded(string text, int maxCharacters = 0, bool ignoreNumber = false)
			{
				if (IsRight2Left)
				{
					return ApplyRTLfix(text, maxCharacters, ignoreNumber);
				}
				return text;
			}

			public static bool IsRTL(string Code)
			{
				return Array.IndexOf(LanguagesRTL, Code) >= 0;
			}

			public static bool UpdateSources()
			{
				UnregisterDeletededSources();
				RegisterSourceInResources();
				RegisterSceneSources();
				return Sources.Count > 0;
			}

			private static void UnregisterDeletededSources()
			{
				for (int num = Sources.Count - 1; num >= 0; num--)
				{
					if (Sources[num] == null)
					{
						RemoveSource(Sources[num]);
					}
				}
			}

			private static void RegisterSceneSources()
			{
				LanguageSource[] array = (LanguageSource[])Resources.FindObjectsOfTypeAll(typeof(LanguageSource));
				foreach (LanguageSource languageSource in array)
				{
					if (!Sources.Contains(languageSource.mSource))
					{
						if (languageSource.mSource.owner == null)
						{
							languageSource.mSource.owner = languageSource;
						}
						AddSource(languageSource.mSource);
					}
				}
			}

			private static void RegisterSourceInResources()
			{
				string[] globalSources = GlobalSources;
				foreach (string name in globalSources)
				{
					LanguageSourceAsset asset = ResourceManager.pInstance.GetAsset<LanguageSourceAsset>(name);
					if ((bool)asset && !Sources.Contains(asset.mSource))
					{
						if (!asset.mSource.mIsGlobalSource)
						{
							asset.mSource.mIsGlobalSource = true;
						}
						asset.mSource.owner = asset;
						AddSource(asset.mSource);
					}
				}
			}

			private static bool AllowSyncFromGoogle(LanguageSourceData Source)
			{
				if (Callback_AllowSyncFromGoogle == null)
				{
					return true;
				}
				return Callback_AllowSyncFromGoogle(Source);
			}

			internal static void AddSource(LanguageSourceData Source)
			{
				if (Sources.Contains(Source))
				{
					return;
				}
				Sources.Add(Source);
				if (Source.HasGoogleSpreadsheet() && Source.GoogleUpdateFrequency != LanguageSourceData.eGoogleUpdateFrequency.Never && AllowSyncFromGoogle(Source))
				{
					Source.Import_Google_FromCache();
					bool justCheck = false;
					if (Source.GoogleUpdateDelay > 0f)
					{
						CoroutineManager.Start(Delayed_Import_Google(Source, Source.GoogleUpdateDelay, justCheck));
					}
					else
					{
						Source.Import_Google(ForceUpdate: false, justCheck);
					}
				}
				for (int i = 0; i < Source.mLanguages.Count; i++)
				{
					Source.mLanguages[i].SetLoaded(loaded: true);
				}
				if (Source.mDictionary.Count == 0)
				{
					Source.UpdateDictionary(force: true);
				}
			}

			private static IEnumerator Delayed_Import_Google(LanguageSourceData source, float delay, bool justCheck)
			{
				yield return new WaitForSeconds(delay);
				source?.Import_Google(ForceUpdate: false, justCheck);
			}

			internal static void RemoveSource(LanguageSourceData Source)
			{
				Sources.Remove(Source);
			}

			public static bool IsGlobalSource(string SourceName)
			{
				return Array.IndexOf(GlobalSources, SourceName) >= 0;
			}

			public static LanguageSourceData GetSourceContaining(string term, bool fallbackToFirst = true)
			{
				if (!string.IsNullOrEmpty(term))
				{
					int i = 0;
					for (int count = Sources.Count; i < count; i++)
					{
						if (Sources[i].GetTermData(term) != null)
						{
							return Sources[i];
						}
					}
				}
				if (!fallbackToFirst || Sources.Count <= 0)
				{
					return null;
				}
				return Sources[0];
			}

			public static UnityEngine.Object FindAsset(string value)
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					UnityEngine.Object @object = Sources[i].FindAsset(value);
					if ((bool)@object)
					{
						return @object;
					}
				}
				return null;
			}

			public static void ApplyDownloadedDataFromGoogle()
			{
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Sources[i].ApplyDownloadedDataFromGoogle();
				}
			}

			public static string GetCurrentDeviceLanguage(bool force = false)
			{
				if (force || string.IsNullOrEmpty(mCurrentDeviceLanguage))
				{
					DetectDeviceLanguage();
				}
				return mCurrentDeviceLanguage;
			}

			private static void DetectDeviceLanguage()
			{
				try
				{
					mCurrentDeviceLanguage = new AndroidJavaClass("java/util/Locale").CallStatic<AndroidJavaObject>("getDefault", Array.Empty<object>()).Call<string>("toString", Array.Empty<object>());
					if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
					{
						mCurrentDeviceLanguage = mCurrentDeviceLanguage.Replace('_', '-');
						mCurrentDeviceLanguage = GoogleLanguages.GetLanguageName(mCurrentDeviceLanguage, useParenthesesForRegion: true);
						if (!string.IsNullOrEmpty(mCurrentDeviceLanguage))
						{
							return;
						}
					}
				}
				catch (Exception)
				{
				}
				mCurrentDeviceLanguage = Application.systemLanguage.ToString();
				if (mCurrentDeviceLanguage == "ChineseSimplified")
				{
					mCurrentDeviceLanguage = "Chinese (Simplified)";
				}
				if (mCurrentDeviceLanguage == "ChineseTraditional")
				{
					mCurrentDeviceLanguage = "Chinese (Traditional)";
				}
			}

			public static void RegisterTarget(ILocalizeTargetDescriptor desc)
			{
				if (mLocalizeTargets.FindIndex((ILocalizeTargetDescriptor x) => x.Name == desc.Name) != -1)
				{
					return;
				}
				for (int i = 0; i < mLocalizeTargets.Count; i++)
				{
					if (mLocalizeTargets[i].Priority > desc.Priority)
					{
						mLocalizeTargets.Insert(i, desc);
						return;
					}
				}
				mLocalizeTargets.Add(desc);
			}

			public static string GetTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null, bool allowLocalizedParameters = true)
			{
				string Translation = null;
				TryGetTranslation(Term, out Translation, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage, allowLocalizedParameters);
				return Translation;
			}

			public static string GetTermTranslation(string Term, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null, bool allowLocalizedParameters = true)
			{
				return GetTranslation(Term, FixForRTL, maxLineLengthForRTL, ignoreRTLnumbers, applyParameters, localParametersRoot, overrideLanguage, allowLocalizedParameters);
			}

			public static bool TryGetTranslation(string Term, out string Translation, bool FixForRTL = true, int maxLineLengthForRTL = 0, bool ignoreRTLnumbers = true, bool applyParameters = false, GameObject localParametersRoot = null, string overrideLanguage = null, bool allowLocalizedParameters = true)
			{
				Translation = null;
				if (string.IsNullOrEmpty(Term))
				{
					return false;
				}
				InitializeIfNeeded();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					if (Sources[i].TryGetTranslation(Term, out Translation, overrideLanguage))
					{
						if (applyParameters)
						{
							ApplyLocalizationParams(ref Translation, localParametersRoot, allowLocalizedParameters);
						}
						if (IsRight2Left && FixForRTL)
						{
							Translation = ApplyRTLfix(Translation, maxLineLengthForRTL, ignoreRTLnumbers);
						}
						return true;
					}
				}
				return false;
			}

			public static T GetTranslatedObject<T>(string AssetName, Localize optionalLocComp = null) where T : UnityEngine.Object
			{
				if (optionalLocComp != null)
				{
					return optionalLocComp.FindTranslatedObject<T>(AssetName);
				}
				T val = FindAsset(AssetName) as T;
				if ((bool)val)
				{
					return val;
				}
				return ResourceManager.pInstance.GetAsset<T>(AssetName);
			}

			public static T GetTranslatedObjectByTermName<T>(string Term, Localize optionalLocComp = null) where T : UnityEngine.Object
			{
				return GetTranslatedObject<T>(GetTranslation(Term, FixForRTL: false));
			}

			public static string GetAppName(string languageCode)
			{
				if (!string.IsNullOrEmpty(languageCode))
				{
					for (int i = 0; i < Sources.Count; i++)
					{
						if (string.IsNullOrEmpty(Sources[i].mTerm_AppName))
						{
							continue;
						}
						int languageIndexFromCode = Sources[i].GetLanguageIndexFromCode(languageCode, exactMatch: false);
						if (languageIndexFromCode < 0)
						{
							continue;
						}
						TermData termData = Sources[i].GetTermData(Sources[i].mTerm_AppName);
						if (termData != null)
						{
							string translation = termData.GetTranslation(languageIndexFromCode);
							if (!string.IsNullOrEmpty(translation))
							{
								return translation;
							}
						}
					}
				}
				return Application.productName;
			}

			public static void LocalizeAll(bool Force = false)
			{
				LoadCurrentLanguage();
				if (!Application.isPlaying)
				{
					DoLocalizeAll(Force);
					return;
				}
				mLocalizeIsScheduledWithForcedValue |= Force;
				if (!mLocalizeIsScheduled)
				{
					CoroutineManager.Start(Coroutine_LocalizeAll());
				}
			}

			private static IEnumerator Coroutine_LocalizeAll()
			{
				mLocalizeIsScheduled = true;
				yield return null;
				mLocalizeIsScheduled = false;
				bool force = mLocalizeIsScheduledWithForcedValue;
				mLocalizeIsScheduledWithForcedValue = false;
				DoLocalizeAll(force);
			}

			private static void DoLocalizeAll(bool Force = false)
			{
				Localize[] array = (Localize[])Resources.FindObjectsOfTypeAll(typeof(Localize));
				int i = 0;
				for (int num = array.Length; i < num; i++)
				{
					array[i].OnLocalize(Force);
				}
				if (LocalizationManager.OnLocalizeEvent != null)
				{
					LocalizationManager.OnLocalizeEvent();
				}
			}

			public static List<string> GetCategories()
			{
				List<string> list = new List<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					Sources[i].GetCategories(OnlyMainCategory: false, list);
				}
				return list;
			}

			public static List<string> GetTermsList(string Category = null)
			{
				if (Sources.Count == 0)
				{
					UpdateSources();
				}
				if (Sources.Count == 1)
				{
					return Sources[0].GetTermsList(Category);
				}
				HashSet<string> hashSet = new HashSet<string>();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					hashSet.UnionWith(Sources[i].GetTermsList(Category));
				}
				return new List<string>(hashSet);
			}

			public static TermData GetTermData(string term)
			{
				InitializeIfNeeded();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					TermData termData = Sources[i].GetTermData(term);
					if (termData != null)
					{
						return termData;
					}
				}
				return null;
			}

			public static TermData GetTermData(string term, out LanguageSourceData source)
			{
				InitializeIfNeeded();
				int i = 0;
				for (int count = Sources.Count; i < count; i++)
				{
					TermData termData = Sources[i].GetTermData(term);
					if (termData != null)
					{
						source = Sources[i];
						return termData;
					}
				}
				source = null;
				return null;
			}
		}
		public abstract class ILocalizeTarget : ScriptableObject
		{
			public abstract bool IsValid(Localize cmp);

			public abstract void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm);

			public abstract void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation);

			public abstract bool CanUseSecondaryTerm();

			public abstract bool AllowMainTermToBeRTL();

			public abstract bool AllowSecondTermToBeRTL();

			public abstract eTermType GetPrimaryTermType(Localize cmp);

			public abstract eTermType GetSecondaryTermType(Localize cmp);
		}
		public abstract class LocalizeTarget<T> : ILocalizeTarget where T : UnityEngine.Object
		{
			public T mTarget;

			public override bool IsValid(Localize cmp)
			{
				if (mTarget != null)
				{
					Component component = mTarget as Component;
					if (component != null && component.gameObject != cmp.gameObject)
					{
						mTarget = null;
					}
				}
				if (mTarget == null)
				{
					mTarget = cmp.GetComponent<T>();
				}
				return mTarget != null;
			}
		}
		public abstract class ILocalizeTargetDescriptor
		{
			public string Name;

			public int Priority;

			public abstract bool CanLocalize(Localize cmp);

			public abstract ILocalizeTarget CreateTarget(Localize cmp);

			public abstract Type GetTargetType();
		}
		public abstract class LocalizeTargetDesc<T> : ILocalizeTargetDescriptor where T : ILocalizeTarget
		{
			public override ILocalizeTarget CreateTarget(Localize cmp)
			{
				return ScriptableObject.CreateInstance<T>();
			}

			public override Type GetTargetType()
			{
				return typeof(T);
			}
		}
		public class LocalizeTargetDesc_Type<T, G> : LocalizeTargetDesc<G> where T : UnityEngine.Object where G : LocalizeTarget<T>
		{
			public override bool CanLocalize(Localize cmp)
			{
				return cmp.GetComponent<T>() != null;
			}

			public override ILocalizeTarget CreateTarget(Localize cmp)
			{
				T component = cmp.GetComponent<T>();
				if (component == null)
				{
					return null;
				}
				G val = ScriptableObject.CreateInstance<G>();
				val.mTarget = component;
				return val;
			}
		}
		public class LocalizeTarget_TextMeshPro_Label : LocalizeTarget<TextMeshPro>
		{
			private TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

			private TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

			private bool mAlignmentWasRTL;

			private bool mInitializeAlignment = true;

			static LocalizeTarget_TextMeshPro_Label()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshPro, LocalizeTarget_TextMeshPro_Label>
				{
					Name = "TextMeshPro Label",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Font;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null)
				{
					SetFont(mTarget, secondaryTranslatedObj);
				}
				else
				{
					Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
					if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
					{
						if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
						{
							secondaryTranslatedObj = GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
							if (secondaryTranslatedObj != null)
							{
								SetFont(mTarget, secondaryTranslatedObj);
							}
						}
						SetMaterial(mTarget, secondaryTranslatedObj2);
					}
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
					InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
				}
				else
				{
					InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
					if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
					{
						mAlignment_LTR = alignLTR;
						mAlignment_RTL = alignRTL;
					}
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				}
				if (mainTranslation != null && mTarget.text != mainTranslation)
				{
					if (cmp.CorrectAlignmentForRTL)
					{
						mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					}
					mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
					if (LocalizationManager.IsRight2Left)
					{
						mainTranslation = I2Utils.ReverseText(mainTranslation);
					}
					mTarget.text = mainTranslation;
				}
			}

			internal static TMP_FontAsset GetTMPFontFromMaterial(Localize cmp, string matName)
			{
				string text = " .\\/-[]()";
				int num = matName.Length - 1;
				while (num > 0)
				{
					while (num > 0 && text.IndexOf(matName[num]) >= 0)
					{
						num--;
					}
					if (num <= 0)
					{
						break;
					}
					string translation = matName.Substring(0, num + 1);
					TMP_FontAsset @object = cmp.GetObject<TMP_FontAsset>(translation);
					if (@object != null)
					{
						return @object;
					}
					while (num > 0 && text.IndexOf(matName[num]) < 0)
					{
						num--;
					}
				}
				return null;
			}

			internal static void InitAlignment_TMPro(bool isRTL, TextAlignmentOptions alignment, out TextAlignmentOptions alignLTR, out TextAlignmentOptions alignRTL)
			{
				alignLTR = (alignRTL = alignment);
				if (isRTL)
				{
					switch (alignment)
					{
					case TextAlignmentOptions.TopRight:
						alignLTR = TextAlignmentOptions.TopLeft;
						break;
					case TextAlignmentOptions.Right:
						alignLTR = TextAlignmentOptions.Left;
						break;
					case TextAlignmentOptions.BottomRight:
						alignLTR = TextAlignmentOptions.BottomLeft;
						break;
					case TextAlignmentOptions.BaselineRight:
						alignLTR = TextAlignmentOptions.BaselineLeft;
						break;
					case TextAlignmentOptions.MidlineRight:
						alignLTR = TextAlignmentOptions.MidlineLeft;
						break;
					case TextAlignmentOptions.CaplineRight:
						alignLTR = TextAlignmentOptions.CaplineLeft;
						break;
					case TextAlignmentOptions.TopLeft:
						alignLTR = TextAlignmentOptions.TopRight;
						break;
					case TextAlignmentOptions.Left:
						alignLTR = TextAlignmentOptions.Right;
						break;
					case TextAlignmentOptions.BottomLeft:
						alignLTR = TextAlignmentOptions.BottomRight;
						break;
					case TextAlignmentOptions.BaselineLeft:
						alignLTR = TextAlignmentOptions.BaselineRight;
						break;
					case TextAlignmentOptions.MidlineLeft:
						alignLTR = TextAlignmentOptions.MidlineRight;
						break;
					case TextAlignmentOptions.CaplineLeft:
						alignLTR = TextAlignmentOptions.CaplineRight;
						break;
					}
				}
				else
				{
					switch (alignment)
					{
					case TextAlignmentOptions.TopRight:
						alignRTL = TextAlignmentOptions.TopLeft;
						break;
					case TextAlignmentOptions.Right:
						alignRTL = TextAlignmentOptions.Left;
						break;
					case TextAlignmentOptions.BottomRight:
						alignRTL = TextAlignmentOptions.BottomLeft;
						break;
					case TextAlignmentOptions.BaselineRight:
						alignRTL = TextAlignmentOptions.BaselineLeft;
						break;
					case TextAlignmentOptions.MidlineRight:
						alignRTL = TextAlignmentOptions.MidlineLeft;
						break;
					case TextAlignmentOptions.CaplineRight:
						alignRTL = TextAlignmentOptions.CaplineLeft;
						break;
					case TextAlignmentOptions.TopLeft:
						alignRTL = TextAlignmentOptions.TopRight;
						break;
					case TextAlignmentOptions.Left:
						alignRTL = TextAlignmentOptions.Right;
						break;
					case TextAlignmentOptions.BottomLeft:
						alignRTL = TextAlignmentOptions.BottomRight;
						break;
					case TextAlignmentOptions.BaselineLeft:
						alignRTL = TextAlignmentOptions.BaselineRight;
						break;
					case TextAlignmentOptions.MidlineLeft:
						alignRTL = TextAlignmentOptions.MidlineRight;
						break;
					case TextAlignmentOptions.CaplineLeft:
						alignRTL = TextAlignmentOptions.CaplineRight;
						break;
					}
				}
			}

			internal static void SetFont(TMP_Text label, TMP_FontAsset newFont)
			{
				if (label.font != newFont)
				{
					label.font = newFont;
				}
				if (label.linkedTextComponent != null)
				{
					SetFont(label.linkedTextComponent, newFont);
				}
			}

			internal static void SetMaterial(TMP_Text label, Material newMat)
			{
				if (label.fontSharedMaterial != newMat)
				{
					label.fontSharedMaterial = newMat;
				}
				if (label.linkedTextComponent != null)
				{
					SetMaterial(label.linkedTextComponent, newMat);
				}
			}
		}
		public class LocalizeTarget_TextMeshPro_UGUI : LocalizeTarget<TextMeshProUGUI>
		{
			public TextAlignmentOptions mAlignment_RTL = TextAlignmentOptions.Right;

			public TextAlignmentOptions mAlignment_LTR = TextAlignmentOptions.Left;

			public bool mAlignmentWasRTL;

			public bool mInitializeAlignment = true;

			static LocalizeTarget_TextMeshPro_UGUI()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMeshProUGUI, LocalizeTarget_TextMeshPro_UGUI>
				{
					Name = "TextMeshPro UGUI",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.TextMeshPFont;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				TMP_FontAsset secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<TMP_FontAsset>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null)
				{
					LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
				}
				else
				{
					Material secondaryTranslatedObj2 = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
					if (secondaryTranslatedObj2 != null && mTarget.fontMaterial != secondaryTranslatedObj2)
					{
						if (!secondaryTranslatedObj2.name.StartsWith(mTarget.font.name, StringComparison.Ordinal))
						{
							secondaryTranslatedObj = LocalizeTarget_TextMeshPro_Label.GetTMPFontFromMaterial(cmp, secondaryTranslation.EndsWith(secondaryTranslatedObj2.name, StringComparison.Ordinal) ? secondaryTranslation : secondaryTranslatedObj2.name);
							if (secondaryTranslatedObj != null)
							{
								LocalizeTarget_TextMeshPro_Label.SetFont(mTarget, secondaryTranslatedObj);
							}
						}
						LocalizeTarget_TextMeshPro_Label.SetMaterial(mTarget, secondaryTranslatedObj2);
					}
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
					LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
				}
				else
				{
					LocalizeTarget_TextMeshPro_Label.InitAlignment_TMPro(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
					if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
					{
						mAlignment_LTR = alignLTR;
						mAlignment_RTL = alignRTL;
					}
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				}
				if (mainTranslation != null && mTarget.text != mainTranslation)
				{
					if (cmp.CorrectAlignmentForRTL)
					{
						mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					}
					mTarget.isRightToLeftText = LocalizationManager.IsRight2Left;
					if (LocalizationManager.IsRight2Left)
					{
						mainTranslation = I2Utils.ReverseText(mainTranslation);
					}
					mTarget.text = mainTranslation;
				}
			}
		}
		public class LocalizeTarget_UnityStandard_AudioSource : LocalizeTarget<AudioSource>
		{
			static LocalizeTarget_UnityStandard_AudioSource()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<AudioSource, LocalizeTarget_UnityStandard_AudioSource>
				{
					Name = "AudioSource",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.AudioClip;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				AudioClip clip = mTarget.clip;
				primaryTerm = (clip ? clip.name : string.Empty);
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				bool num = (mTarget.isPlaying || mTarget.loop) && Application.isPlaying;
				AudioClip clip = mTarget.clip;
				AudioClip audioClip = cmp.FindTranslatedObject<AudioClip>(mainTranslation);
				if (clip != audioClip)
				{
					mTarget.clip = audioClip;
				}
				if (num && (bool)mTarget.clip)
				{
					mTarget.Play();
				}
			}
		}
		public class LocalizeTargetDesc_Child : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Child>
		{
			public override bool CanLocalize(Localize cmp)
			{
				return cmp.transform.childCount > 1;
			}
		}
		public class LocalizeTarget_UnityStandard_Child : LocalizeTarget<GameObject>
		{
			static LocalizeTarget_UnityStandard_Child()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Child
				{
					Name = "Child",
					Priority = 200
				});
			}

			public override bool IsValid(Localize cmp)
			{
				return cmp.transform.childCount > 1;
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.GameObject;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = cmp.name;
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				if (!string.IsNullOrEmpty(mainTranslation))
				{
					Transform transform = cmp.transform;
					string text = mainTranslation;
					int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
					if (num >= 0)
					{
						text = text.Substring(num + 1);
					}
					for (int i = 0; i < transform.childCount; i++)
					{
						Transform child = transform.GetChild(i);
						child.gameObject.SetActive(child.name == text);
					}
				}
			}
		}
		public class LocalizeTarget_UnityStandard_MeshRenderer : LocalizeTarget<MeshRenderer>
		{
			static LocalizeTarget_UnityStandard_MeshRenderer()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<MeshRenderer, LocalizeTarget_UnityStandard_MeshRenderer>
				{
					Name = "MeshRenderer",
					Priority = 800
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Mesh;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Material;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				if (mTarget == null)
				{
					primaryTerm = (secondaryTerm = null);
				}
				else
				{
					MeshFilter component = mTarget.GetComponent<MeshFilter>();
					if (component == null || component.sharedMesh == null)
					{
						primaryTerm = null;
					}
					else
					{
						primaryTerm = component.sharedMesh.name;
					}
				}
				if (mTarget == null || mTarget.sharedMaterial == null)
				{
					secondaryTerm = null;
				}
				else
				{
					secondaryTerm = mTarget.sharedMaterial.name;
				}
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Material secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Material>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null && mTarget.sharedMaterial != secondaryTranslatedObj)
				{
					mTarget.material = secondaryTranslatedObj;
				}
				Mesh mesh = cmp.FindTranslatedObject<Mesh>(mainTranslation);
				MeshFilter component = mTarget.GetComponent<MeshFilter>();
				if (mesh != null && component.sharedMesh != mesh)
				{
					component.mesh = mesh;
				}
			}
		}
		public class LocalizeTargetDesc_Prefab : LocalizeTargetDesc<LocalizeTarget_UnityStandard_Prefab>
		{
			public override bool CanLocalize(Localize cmp)
			{
				return true;
			}
		}
		public class LocalizeTarget_UnityStandard_Prefab : LocalizeTarget<GameObject>
		{
			static LocalizeTarget_UnityStandard_Prefab()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Prefab
				{
					Name = "Prefab",
					Priority = 250
				});
			}

			public override bool IsValid(Localize cmp)
			{
				return true;
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.GameObject;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = cmp.name;
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				if (string.IsNullOrEmpty(mainTranslation) || ((bool)mTarget && mTarget.name == mainTranslation))
				{
					return;
				}
				Transform transform = cmp.transform;
				string text = mainTranslation;
				int num = mainTranslation.LastIndexOfAny(LanguageSourceData.CategorySeparators);
				if (num >= 0)
				{
					text = text.Substring(num + 1);
				}
				Transform transform2 = InstantiateNewPrefab(cmp, mainTranslation);
				if (transform2 == null)
				{
					return;
				}
				transform2.name = text;
				for (int num2 = transform.childCount - 1; num2 >= 0; num2--)
				{
					Transform child = transform.GetChild(num2);
					if (child != transform2)
					{
						UnityEngine.Object.Destroy(child.gameObject);
					}
				}
			}

			private Transform InstantiateNewPrefab(Localize cmp, string mainTranslation)
			{
				GameObject gameObject = cmp.FindTranslatedObject<GameObject>(mainTranslation);
				if (gameObject == null)
				{
					return null;
				}
				GameObject gameObject2 = mTarget;
				mTarget = UnityEngine.Object.Instantiate(gameObject);
				if (mTarget == null)
				{
					return null;
				}
				Transform transform = cmp.transform;
				Transform transform2 = mTarget.transform;
				transform2.SetParent(transform);
				Transform transform3 = (gameObject2 ? gameObject2.transform : transform);
				transform2.rotation = transform3.rotation;
				transform2.position = transform3.position;
				return transform2;
			}
		}
		public class LocalizeTarget_UnityStandard_SpriteRenderer : LocalizeTarget<SpriteRenderer>
		{
			static LocalizeTarget_UnityStandard_SpriteRenderer()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<SpriteRenderer, LocalizeTarget_UnityStandard_SpriteRenderer>
				{
					Name = "SpriteRenderer",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Sprite;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				Sprite sprite = mTarget.sprite;
				primaryTerm = ((sprite != null) ? sprite.name : string.Empty);
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Sprite sprite = mTarget.sprite;
				if (sprite == null || sprite.name != mainTranslation)
				{
					mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityStandard_TextMesh : LocalizeTarget<TextMesh>
		{
			private TextAlignment mAlignment_RTL = TextAlignment.Right;

			private TextAlignment mAlignment_LTR;

			private bool mAlignmentWasRTL;

			private bool mInitializeAlignment = true;

			static LocalizeTarget_UnityStandard_TextMesh()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<TextMesh, LocalizeTarget_UnityStandard_TextMesh>
				{
					Name = "TextMesh",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Font;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((string.IsNullOrEmpty(Secondary) && mTarget.font != null) ? mTarget.font.name : null);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null && mTarget.font != secondaryTranslatedObj)
				{
					mTarget.font = secondaryTranslatedObj;
					mTarget.GetComponentInChildren<MeshRenderer>().material = secondaryTranslatedObj.material;
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignment_LTR = (mAlignment_RTL = mTarget.alignment);
					if (LocalizationManager.IsRight2Left && mAlignment_RTL == TextAlignment.Right)
					{
						mAlignment_LTR = TextAlignment.Left;
					}
					if (!LocalizationManager.IsRight2Left && mAlignment_LTR == TextAlignment.Left)
					{
						mAlignment_RTL = TextAlignment.Right;
					}
				}
				if (mainTranslation != null && mTarget.text != mainTranslation)
				{
					if (cmp.CorrectAlignmentForRTL && mTarget.alignment != TextAlignment.Center)
					{
						mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					}
					mTarget.font.RequestCharactersInTexture(mainTranslation);
					mTarget.text = mainTranslation;
				}
			}
		}
		public class LocalizeTarget_UnityStandard_VideoPlayer : LocalizeTarget<VideoPlayer>
		{
			static LocalizeTarget_UnityStandard_VideoPlayer()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<VideoPlayer, LocalizeTarget_UnityStandard_VideoPlayer>
				{
					Name = "VideoPlayer",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Video;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				VideoClip clip = mTarget.clip;
				primaryTerm = ((clip != null) ? clip.name : string.Empty);
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				VideoClip clip = mTarget.clip;
				if (clip == null || clip.name != mainTranslation)
				{
					mTarget.clip = cmp.FindTranslatedObject<VideoClip>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityUI_Image : LocalizeTarget<Image>
		{
			static LocalizeTarget_UnityUI_Image()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Image, LocalizeTarget_UnityUI_Image>
				{
					Name = "Image",
					Priority = 100
				});
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				if (!(mTarget.sprite == null))
				{
					return eTermType.Sprite;
				}
				return eTermType.Texture;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
				if (mTarget.sprite != null && mTarget.sprite.name != primaryTerm)
				{
					primaryTerm = primaryTerm + "." + mTarget.sprite.name;
				}
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Sprite sprite = mTarget.sprite;
				if (sprite == null || sprite.name != mainTranslation)
				{
					mTarget.sprite = cmp.FindTranslatedObject<Sprite>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityUI_RawImage : LocalizeTarget<RawImage>
		{
			static LocalizeTarget_UnityUI_RawImage()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<RawImage, LocalizeTarget_UnityUI_RawImage>
				{
					Name = "RawImage",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Texture;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override bool CanUseSecondaryTerm()
			{
				return false;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return false;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget.mainTexture ? mTarget.mainTexture.name : "");
				secondaryTerm = null;
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Texture texture = mTarget.texture;
				if (texture == null || texture.name != mainTranslation)
				{
					mTarget.texture = cmp.FindTranslatedObject<Texture>(mainTranslation);
				}
			}
		}
		public class LocalizeTarget_UnityUI_Text : LocalizeTarget<Text>
		{
			private TextAnchor mAlignment_RTL = TextAnchor.UpperRight;

			private TextAnchor mAlignment_LTR;

			private bool mAlignmentWasRTL;

			private bool mInitializeAlignment = true;

			static LocalizeTarget_UnityUI_Text()
			{
				AutoRegister();
			}

			[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
			private static void AutoRegister()
			{
				LocalizationManager.RegisterTarget(new LocalizeTargetDesc_Type<Text, LocalizeTarget_UnityUI_Text>
				{
					Name = "Text",
					Priority = 100
				});
			}

			public override eTermType GetPrimaryTermType(Localize cmp)
			{
				return eTermType.Text;
			}

			public override eTermType GetSecondaryTermType(Localize cmp)
			{
				return eTermType.Font;
			}

			public override bool CanUseSecondaryTerm()
			{
				return true;
			}

			public override bool AllowMainTermToBeRTL()
			{
				return true;
			}

			public override bool AllowSecondTermToBeRTL()
			{
				return false;
			}

			public override void GetFinalTerms(Localize cmp, string Main, string Secondary, out string primaryTerm, out string secondaryTerm)
			{
				primaryTerm = (mTarget ? mTarget.text : null);
				secondaryTerm = ((mTarget.font != null) ? mTarget.font.name : string.Empty);
			}

			public override void DoLocalize(Localize cmp, string mainTranslation, string secondaryTranslation)
			{
				Font secondaryTranslatedObj = cmp.GetSecondaryTranslatedObj<Font>(ref mainTranslation, ref secondaryTranslation);
				if (secondaryTranslatedObj != null && secondaryTranslatedObj != mTarget.font)
				{
					mTarget.font = secondaryTranslatedObj;
				}
				if (mInitializeAlignment)
				{
					mInitializeAlignment = false;
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
					InitAlignment(mAlignmentWasRTL, mTarget.alignment, out mAlignment_LTR, out mAlignment_RTL);
				}
				else
				{
					InitAlignment(mAlignmentWasRTL, mTarget.alignment, out var alignLTR, out var alignRTL);
					if ((mAlignmentWasRTL && mAlignment_RTL != alignRTL) || (!mAlignmentWasRTL && mAlignment_LTR != alignLTR))
					{
						mAlignment_LTR = alignLTR;
						mAlignment_RTL = alignRTL;
					}
					mAlignmentWasRTL = LocalizationManager.IsRight2Left;
				}
				if (mainTranslation != null && mTarget.text != mainTranslation)
				{
					if (cmp.CorrectAlignmentForRTL)
					{
						mTarget.alignment = (LocalizationManager.IsRight2Left ? mAlignment_RTL : mAlignment_LTR);
					}
					mTarget.text = mainTranslation;
					mTarget.SetVerticesDirty();
				}
			}

			private void InitAlignment(bool isRTL, TextAnchor alignment, out TextAnchor alignLTR, out TextAnchor alignRTL)
			{
				alignLTR = (alignRTL = alignment);
				if (isRTL)
				{
					switch (alignment)
					{
					case TextAnchor.UpperRight:
						alignLTR = TextAnchor.UpperLeft;
						break;
					case TextAnchor.MiddleRight:
						alignLTR = TextAnchor.MiddleLeft;
						break;
					case TextAnchor.LowerRight:
						alignLTR = TextAnchor.LowerLeft;
						break;
					case TextAnchor.UpperLeft:
						alignLTR = TextAnchor.UpperRight;
						break;
					case TextAnchor.MiddleLeft:
						alignLTR = TextAnchor.MiddleRight;
						break;
					case TextAnchor.LowerLeft:
						alignLTR = TextAnchor.LowerRight;
						break;
					case TextAnchor.UpperCenter:
					case TextAnchor.MiddleCenter:
					case TextAnchor.LowerCenter:
						break;
					}
				}
				else
				{
					switch (alignment)
					{
					case TextAnchor.UpperRight:
						alignRTL = TextAnchor.UpperLeft;
						break;
					case TextAnchor.MiddleRight:
						alignRTL = TextAnchor.MiddleLeft;
						break;
					case TextAnchor.LowerRight:
						alignRTL = TextAnchor.LowerLeft;
						break;
					case TextAnchor.UpperLeft:
						alignRTL = TextAnchor.UpperRight;
						break;
					case TextAnchor.MiddleLeft:
						alignRTL = TextAnchor.MiddleRight;
						break;
					case TextAnchor.LowerLeft:
						alignRTL = TextAnchor.LowerRight;
						break;
					case TextAnchor.UpperCenter:
					case TextAnchor.MiddleCenter:
					case TextAnchor.LowerCenter:
						break;
					}
				}
			}
		}
		public enum eTermType
		{
			Text,
			Font,
			Texture,
			AudioClip,
			GameObject,
			Sprite,
			Material,
			Child,
			Mesh,
			TextMeshPFont,
			Object,
			Video
		}
		public enum TranslationFlag : byte
		{
			Normal = 1,
			AutoTranslated
		}
		[Serializable]
		public class TermData
		{
			public string Term = string.Empty;

			public eTermType TermType;

			[NonSerialized]
			public string Description;

			public string[] Languages = Array.Empty<string>();

			public byte[] Flags = Array.Empty<byte>();

			[SerializeField]
			private string[] Languages_Touch;

			public string GetTranslation(int idx, string specialization = null, bool editMode = false)
			{
				string text = Languages[idx];
				if (text != null)
				{
					text = SpecializationManager.GetSpecializedText(text, specialization);
					if (!editMode)
					{
						text = text.Replace("[i2nt]", "").Replace("[/i2nt]", "");
					}
				}
				return text;
			}

			public void SetTranslation(int idx, string translation, string specialization = null)
			{
				Languages[idx] = SpecializationManager.SetSpecializedText(Languages[idx], translation, specialization);
			}

			public void RemoveSpecialization(string specialization)
			{
				for (int i = 0; i < Languages.Length; i++)
				{
					RemoveSpecialization(i, specialization);
				}
			}

			public void RemoveSpecialization(int idx, string specialization)
			{
				string text = Languages[idx];
				if (!(specialization == "Any") && text.Contains("[i2s_" + specialization + "]"))
				{
					Dictionary<string, string> specializations = SpecializationManager.GetSpecializations(text);
					specializations.Remove(specialization);
					Languages[idx] = SpecializationManager.SetSpecializedText(specializations);
				}
			}

			public bool IsAutoTranslated(int idx, bool IsTouch)
			{
				return (Flags[idx] & 2) > 0;
			}

			public void Validate()
			{
				int num = Mathf.Max(Languages.Length, Flags.Length);
				if (Languages.Length != num)
				{
					Array.Resize(ref Languages, num);
				}
				if (Flags.Length != num)
				{
					Array.Resize(ref Flags, num);
				}
				if (Languages_Touch == null)
				{
					return;
				}
				for (int i = 0; i < Mathf.Min(Languages_Touch.Length, num); i++)
				{
					if (string.IsNullOrEmpty(Languages[i]) && !string.IsNullOrEmpty(Languages_Touch[i]))
					{
						Languages[i] = Languages_Touch[i];
						Languages_Touch[i] = null;
					}
				}
				Languages_Touch = null;
			}

			public bool IsTerm(string name, bool allowCategoryMistmatch)
			{
				if (!allowCategoryMistmatch)
				{
					return name == Term;
				}
				return name == LanguageSourceData.GetKeyFromFullTerm(Term);
			}

			public bool HasSpecializations()
			{
				for (int i = 0; i < Languages.Length; i++)
				{
					if (!string.IsNullOrEmpty(Languages[i]) && Languages[i].Contains("[i2s_"))
					{
						return true;
					}
				}
				return false;
			}

			public List<string> GetAllSpecializations()
			{
				List<string> list = new List<string>();
				for (int i = 0; i < Languages.Length; i++)
				{
					SpecializationManager.AppendSpecializations(Languages[i], list);
				}
				return list;
			}
		}
		public class TermsPopup : PropertyAttribute
		{
			public string Filter { get; private set; }

			public TermsPopup(string filter = "")
			{
				Filter = filter;
			}
		}
		public class AutoChangeCultureInfo : MonoBehaviour
		{
			public void Start()
			{
				LocalizationManager.EnableChangingCultureInfo(bEnable: true);
			}
		}
		public class CoroutineManager : MonoBehaviour
		{
			private static CoroutineManager mInstance;

			private static CoroutineManager pInstance
			{
				get
				{
					if (mInstance == null)
					{
						GameObject gameObject = new GameObject("_Coroutiner");
						gameObject.hideFlags = HideFlags.HideAndDontSave;
						mInstance = gameObject.AddComponent<CoroutineManager>();
						if (Application.isPlaying)
						{
							UnityEngine.Object.DontDestroyOnLoad(gameObject);
						}
					}
					return mInstance;
				}
			}

			private void Awake()
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}

			public static Coroutine Start(IEnumerator coroutine)
			{
				return pInstance.StartCoroutine(coroutine);
			}
		}
		[AddComponentMenu("I2/Localization/I2 Localize Callback")]
		public class CustomLocalizeCallback : MonoBehaviour
		{
			public UnityEvent _OnLocalize = new UnityEvent();

			public void OnEnable()
			{
				LocalizationManager.OnLocalizeEvent -= OnLocalize;
				LocalizationManager.OnLocalizeEvent += OnLocalize;
			}

			public void OnDisable()
			{
				LocalizationManager.OnLocalizeEvent -= OnLocalize;
			}

			public void OnLocalize()
			{
				_OnLocalize.Invoke();
			}
		}
		public class HindiFixer
		{
			internal static string Fix(string text)
			{
				char[] array = text.ToCharArray();
				bool flag = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == '\u093f' && !char.IsWhiteSpace(array[i - 1]) && array[i - 1] != 0)
					{
						array[i] = array[i - 1];
						array[i - 1] = '\u093f';
						flag = true;
					}
					if (i != array.Length - 1)
					{
						if (array[i] == '' && array[i + 1] == '\u093c')
						{
							array[i] = '';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u0943' && array[i + 1] == '\u093c')
						{
							array[i] = '\u0944';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u0901' && array[i + 1] == '\u093c')
						{
							array[i] = '';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '' && array[i + 1] == '\u093c')
						{
							array[i] = '';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '' && array[i + 1] == '\u093c')
						{
							array[i] = '';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u093f' && array[i + 1] == '\u093c')
						{
							array[i] = '\u0962';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '\u0940' && array[i + 1] == '\u093c')
						{
							array[i] = '\u0963';
							array[i + 1] = '\0';
							flag = true;
						}
						if (array[i] == '' && array[i + 1] == '\u093c')
						{
							array[i] = '';
							array[i + 1] = '\0';
							flag = true;
						}
					}
				}
				if (!flag)
				{
					return text;
				}
				string text2 = new string(array.Where((char x) => x != '\0').ToArray());
				if (text2 == text)
				{
					return text2;
				}
				text = text2;
				return text;
			}
		}
		public static class I2Utils
		{
			public const string ValidChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_";

			public const string NumberChars = "0123456789";

			public const string ValidNameSymbols = ".-_$#@*()[]{}+:?!&',^=<>~`";

			public static string ReverseText(string source)
			{
				int length = source.Length;
				char[] output = new char[length];
				char[] anyOf = new char[2] { '\r', '\n' };
				int i = 0;
				while (i < length)
				{
					int num = source.IndexOfAny(anyOf, i);
					if (num < 0)
					{
						num = length;
					}
					Reverse(i, num - 1);
					for (i = num; i < length && (source[i] == '\r' || source[i] == '\n'); i++)
					{
						output[i] = source[i];
					}
				}
				return new string(output);
				void Reverse(int start, int end)
				{
					for (int j = 0; j <= end - start; j++)
					{
						output[end - j] = source[start + j];
					}
				}
			}

			public static string RemoveNonASCII(string text, bool allowCategory = false)
			{
				if (string.IsNullOrEmpty(text))
				{
					return text;
				}
				int num = 0;
				char[] array = new char[text.Length];
				bool flag = false;
				string text2 = text.Trim();
				foreach (char c in text2)
				{
					char c2 = ' ';
					if ((allowCategory && (c == '\\' || c == '"' || c == '/')) || char.IsLetterOrDigit(c) || ".-_$#@*()[]{}+:?!&',^=<>~`".IndexOf(c) >= 0)
					{
						c2 = c;
					}
					if (char.IsWhiteSpace(c2))
					{
						if (!flag)
						{
							if (num > 0)
							{
								array[num++] = ' ';
							}
							flag = true;
						}
					}
					else
					{
						flag = false;
						array[num++] = c2;
					}
				}
				return new string(array, 0, num);
			}

			public static string GetValidTermName(string text, bool allowCategory = false)
			{
				if (text == null)
				{
					return null;
				}
				text = RemoveTags(text);
				return RemoveNonASCII(text, allowCategory);
			}

			public static string SplitLine(string line, int maxCharacters)
			{
				if (maxCharacters <= 0 || line.Length < maxCharacters)
				{
					return line;
				}
				char[] array = line.ToCharArray();
				bool flag = true;
				bool flag2 = false;
				int i = 0;
				int num = 0;
				for (; i < array.Length; i++)
				{
					if (flag)
					{
						num++;
						if (array[i] == '\n')
						{
							num = 0;
						}
						if (num >= maxCharacters && char.IsWhiteSpace(array[i]))
						{
							array[i] = '\n';
							flag = false;
							flag2 = false;
						}
					}
					else if (!char.IsWhiteSpace(array[i]))
					{
						flag = true;
						num = 0;
					}
					else if (array[i] != '\n')
					{
						array[i] = '\0';
					}
					else
					{
						if (!flag2)
						{
							array[i] = '\0';
						}
						flag2 = true;
					}
				}
				return new string(array.Where((char c) => c != '\0').ToArray());
			}

			public static bool FindNextTag(string line, int iStart, out int tagStart, out int tagEnd)
			{
				tagStart = -1;
				tagEnd = -1;
				int length = line.Length;
				tagStart = iStart;
				while (tagStart < length && line[tagStart] != '[' && line[tagStart] != '(' && line[tagStart] != '{' && line[tagStart] != '<')
				{
					tagStart++;
				}
				if (tagStart == length)
				{
					return false;
				}
				bool flag = false;
				for (tagEnd = tagStart + 1; tagEnd < length; tagEnd++)
				{
					char c = line[tagEnd];
					if (c == ']' || c == ')' || c == '}' || c == '>')
					{
						if (flag)
						{
							return FindNextTag(line, tagEnd + 1, out tagStart, out tagEnd);
						}
						return true;
					}
					if (c > '')
					{
						flag = true;
					}
				}
				return false;
			}

			public static string RemoveTags(string text)
			{
				return Regex.Replace(text, "\\{\\[(.*?)]}|\\[(.*?)]|\\<(.*?)>", "");
			}

			public static bool RemoveResourcesPath(ref string sPath)
			{
				int num = sPath.IndexOf("\\Resources\\", StringComparison.Ordinal);
				int num2 = sPath.IndexOf("\\Resources/", StringComparison.Ordinal);
				int num3 = sPath.IndexOf("/Resources\\", StringComparison.Ordinal);
				int num4 = sPath.IndexOf("/Resources/", StringComparison.Ordinal);
				int num5 = Mathf.Max(num, num2, num3, num4);
				bool result = false;
				if (num5 >= 0)
				{
					sPath = sPath.Substring(num5 + 11);
					result = true;
				}
				else
				{
					num5 = sPath.LastIndexOfAny(LanguageSourceData.CategorySeparators);
					if (num5 > 0)
					{
						sPath = sPath.Substring(num5 + 1);
					}
				}
				string extension = Path.GetExtension(sPath);
				if (!string.IsNullOrEmpty(extension))
				{
					sPath = sPath.Substring(0, sPath.Length - extension.Length);
				}
				return result;
			}

			public static bool IsPlaying()
			{
				if (Application.isPlaying)
				{
					return true;
				}
				return false;
			}

			public static string GetPath(this Transform tr)
			{
				Transform parent = tr.parent;
				if (tr == null)
				{
					return tr.name;
				}
				return parent.GetPath() + "/" + tr.name;
			}

			public static Transform FindObject(string objectPath)
			{
				return FindObject(SceneManager.GetActiveScene(), objectPath);
			}

			public static Transform FindObject(Scene scene, string objectPath)
			{
				GameObject[] rootGameObjects = scene.GetRootGameObjects();
				for (int i = 0; i < rootGameObjects.Length; i++)
				{
					Transform transform = rootGameObjects[i].transform;
					if (transform.name == objectPath)
					{
						return transform;
					}
					if (objectPath.StartsWith(transform.name + "/", StringComparison.Ordinal))
					{
						return FindObject(transform, objectPath.Substring(transform.name.Length + 1));
					}
				}
				return null;
			}

			public static Transform FindObject(Transform root, string objectPath)
			{
				for (int i = 0; i < root.childCount; i++)
				{
					Transform child = root.GetChild(i);
					if (child.name == objectPath)
					{
						return child;
					}
					if (objectPath.StartsWith(child.name + "/", StringComparison.Ordinal))
					{
						return FindObject(child, objectPath.Substring(child.name.Length + 1));
					}
				}
				return null;
			}

			public static H FindInParents<H>(Transform tr) where H : Component
			{
				if (!tr)
				{
					return null;
				}
				H component = tr.GetComponent<H>();
				while (!component && (bool)tr)
				{
					component = tr.GetComponent<H>();
					tr = tr.parent;
				}
				return component;
			}

			public static string GetCaptureMatch(Match match)
			{
				for (int num = match.Groups.Count - 1; num >= 0; num--)
				{
					if (match.Groups[num].Success)
					{
						return match.Groups[num].ToString();
					}
				}
				return match.ToString();
			}

			public static void SendWebRequest(UnityWebRequest www)
			{
				www.SendWebRequest();
			}
		}
		public interface ILocalizationParamsManager
		{
			string GetParameterValue(string Param);
		}
		public class LocalizationParamsManager : MonoBehaviour, ILocalizationParamsManager
		{
			[Serializable]
			public struct ParamValue
			{
				public string Name;

				public string Value;
			}

			[SerializeField]
			public List<ParamValue> _Params = new List<ParamValue>();

			public bool _IsGlobalManager;

			public string GetParameterValue(string ParamName)
			{
				if (_Params != null)
				{
					int i = 0;
					for (int count = _Params.Count; i < count; i++)
					{
						if (_Params[i].Name == ParamName)
						{
							return _Params[i].Value;
						}
					}
				}
				return null;
			}

			public void SetParameterValue(string ParamName, string ParamValue, bool localize = true)
			{
				bool flag = false;
				int i = 0;
				for (int count = _Params.Count; i < count; i++)
				{
					if (_Params[i].Name == ParamName)
					{
						ParamValue value = _Params[i];
						value.Value = ParamValue;
						_Params[i] = value;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					_Params.Add(new ParamValue
					{
						Name = ParamName,
						Value = ParamValue
					});
				}
				if (localize)
				{
					OnLocalize();
				}
			}

			public void OnLocalize()
			{
				Localize component = GetComponent<Localize>();
				if (component != null)
				{
					component.OnLocalize(Force: true);
				}
			}

			public virtual void OnEnable()
			{
				if (_IsGlobalManager)
				{
					DoAutoRegister();
				}
			}

			public void DoAutoRegister()
			{
				if (!LocalizationManager.ParamManagers.Contains(this))
				{
					LocalizationManager.ParamManagers.Add(this);
					LocalizationManager.LocalizeAll(Force: true);
				}
			}

			public void OnDisable()
			{
				LocalizationManager.ParamManagers.Remove(this);
			}
		}
		[Serializable]
		public struct LocalizedString
		{
			public string mTerm;

			public bool mRTL_IgnoreArabicFix;

			public int mRTL_MaxLineLength;

			public bool mRTL_ConvertNumbers;

			public bool m_DontLocalizeParameters;

			public static implicit operator string(LocalizedString s)
			{
				return s.ToString();
			}

			public static implicit operator LocalizedString(string term)
			{
				LocalizedString result = default(LocalizedString);
				result.mTerm = term;
				return result;
			}

			public LocalizedString(LocalizedString str)
			{
				mTerm = str.mTerm;
				mRTL_IgnoreArabicFix = str.mRTL_IgnoreArabicFix;
				mRTL_MaxLineLength = str.mRTL_MaxLineLength;
				mRTL_ConvertNumbers = str.mRTL_ConvertNumbers;
				m_DontLocalizeParameters = str.m_DontLocalizeParameters;
			}

			public override string ToString()
			{
				string translation = LocalizationManager.GetTranslation(mTerm, !mRTL_IgnoreArabicFix, mRTL_MaxLineLength, !mRTL_ConvertNumbers, applyParameters: true);
				LocalizationManager.ApplyLocalizationParams(ref translation, !m_DontLocalizeParameters);
				return translation;
			}
		}
		public class RTLFixer
		{
			public static string Fix(string str)
			{
				return Fix(str, showTashkeel: false, useHinduNumbers: true);
			}

			public static string Fix(string str, bool rtl)
			{
				if (rtl)
				{
					return Fix(str);
				}
				string[] array = str.Split(' ');
				string text = "";
				string text2 = "";
				string[] array2 = array;
				foreach (string text3 in array2)
				{
					if (char.IsLower(text3.ToLower()[text3.Length / 2]))
					{
						text = text + Fix(text2) + text3 + " ";
						text2 = "";
					}
					else
					{
						text2 = text2 + text3 + " ";
					}
				}
				if (text2 != "")
				{
					text += Fix(text2);
				}
				return text;
			}

			public static string Fix(string str, bool showTashkeel, bool useHinduNumbers)
			{
				string text = HindiFixer.Fix(str);
				if (text != str)
				{
					return text;
				}
				RTLFixerTool.showTashkeel = showTashkeel;
				RTLFixerTool.useHinduNumbers = useHinduNumbers;
				if (str.Contains("\n"))
				{
					str = str.Replace("\n", Environment.NewLine);
				}
				if (str.Contains(Environment.NewLine))
				{
					string[] separator = new string[1] { Environment.NewLine };
					string[] array = str.Split(separator, StringSplitOptions.None);
					if (array.Length == 0)
					{
						return RTLFixerTool.FixLine(str);
					}
					if (array.Length == 1)
					{
						return RTLFixerTool.FixLine(str);
					}
					string text2 = RTLFixerTool.FixLine(array[0]);
					int i = 1;
					if (array.Length > 1)
					{
						for (; i < array.Length; i++)
						{
							text2 = text2 + Environment.NewLine + RTLFixerTool.FixLine(array[i]);
						}
					}
					return text2;
				}
				return RTLFixerTool.FixLine(str);
			}
		}
		internal enum IsolatedArabicLetters
		{
			Hamza = 65152,
			Alef = 65165,
			AlefHamza = 65155,
			WawHamza = 65157,
			AlefMaksoor = 65159,
			AlefMaksora = 64508,
			HamzaNabera = 65161,
			Ba = 65167,
			Ta = 65173,
			Tha2 = 65177,
			Jeem = 65181,
			H7aa = 65185,
			Khaa2 = 65189,
			Dal = 65193,
			Thal = 65195,
			Ra2 = 65197,
			Zeen = 65199,
			Seen = 65201,
			Sheen = 65205,
			S9a = 65209,
			Dha = 65213,
			T6a = 65217,
			T6ha = 65221,
			Ain = 65225,
			Gain = 65229,
			Fa = 65233,
			Gaf = 65237,
			Kaf = 65241,
			Lam = 65245,
			Meem = 65249,
			Noon = 65253,
			Ha = 65257,
			Waw = 65261,
			Ya = 65265,
			AlefMad = 65153,
			TaMarboota = 65171,
			PersianPe = 64342,
			PersianChe = 64378,
			PersianZe = 64394,
			PersianGaf = 64402,
			PersianGaf2 = 64398
		}
		internal enum GeneralArabicLetters
		{
			Hamza = 1569,
			Alef = 1575,
			AlefHamza = 1571,
			WawHamza = 1572,
			AlefMaksoor = 1573,
			AlefMagsora = 1609,
			HamzaNabera = 1574,
			Ba = 1576,
			Ta = 1578,
			Tha2 = 1579,
			Jeem = 1580,
			H7aa = 1581,
			Khaa2 = 1582,
			Dal = 1583,
			Thal = 1584,
			Ra2 = 1585,
			Zeen = 1586,
			Seen = 1587,
			Sheen = 1588,
			S9a = 1589,
			Dha = 1590,
			T6a = 1591,
			T6ha = 1592,
			Ain = 1593,
			Gain = 1594,
			Fa = 1601,
			Gaf = 1602,
			Kaf = 1603,
			Lam = 1604,
			Meem = 1605,
			Noon = 1606,
			Ha = 1607,
			Waw = 1608,
			Ya = 1610,
			AlefMad = 1570,
			TaMarboota = 1577,
			PersianPe = 1662,
			PersianChe = 1670,
			PersianZe = 1688,
			PersianGaf = 1711,
			PersianGaf2 = 1705
		}
		internal class ArabicMapping
		{
			public int from;

			public int to;

			public ArabicMapping(int from, int to)
			{
				this.from = from;
				this.to = to;
			}
		}
		internal class ArabicTable
		{
			private static List<ArabicMapping> mapList;

			private static ArabicTable arabicMapper;

			internal static ArabicTable ArabicMapper
			{
				get
				{
					if (arabicMapper == null)
					{
						arabicMapper = new ArabicTable();
					}
					return arabicMapper;
				}
			}

			private ArabicTable()
			{
				mapList = new List<ArabicMapping>();
				mapList.Add(new ArabicMapping(1569, 65152));
				mapList.Add(new ArabicMapping(1575, 65165));
				mapList.Add(new ArabicMapping(1571, 65155));
				mapList.Add(new ArabicMapping(1572, 65157));
				mapList.Add(new ArabicMapping(1573, 65159));
				mapList.Add(new ArabicMapping(1609, 64508));
				mapList.Add(new ArabicMapping(1574, 65161));
				mapList.Add(new ArabicMapping(1576, 65167));
				mapList.Add(new ArabicMapping(1578, 65173));
				mapList.Add(new ArabicMapping(1579, 65177));
				mapList.Add(new ArabicMapping(1580, 65181));
				mapList.Add(new ArabicMapping(1581, 65185));
				mapList.Add(new ArabicMapping(1582, 65189));
				mapList.Add(new ArabicMapping(1583, 65193));
				mapList.Add(new ArabicMapping(1584, 65195));
				mapList.Add(new ArabicMapping(1585, 65197));
				mapList.Add(new ArabicMapping(1586, 65199));
				mapList.Add(new ArabicMapping(1587, 65201));
				mapList.Add(new ArabicMapping(1588, 65205));
				mapList.Add(new ArabicMapping(1589, 65209));
				mapList.Add(new ArabicMapping(1590, 65213));
				mapList.Add(new ArabicMapping(1591, 65217));
				mapList.Add(new ArabicMapping(1592, 65221));
				mapList.Add(new ArabicMapping(1593, 65225));
				mapList.Add(new ArabicMapping(1594, 65229));
				mapList.Add(new ArabicMapping(1601, 65233));
				mapList.Add(new ArabicMapping(1602, 65237));
				mapList.Add(new ArabicMapping(1603, 65241));
				mapList.Add(new ArabicMapping(1604, 65245));
				mapList.Add(new ArabicMapping(1605, 65249));
				mapList.Add(new ArabicMapping(1606, 65253));
				mapList.Add(new ArabicMapping(1607, 65257));
				mapList.Add(new ArabicMapping(1608, 65261));
				mapList.Add(new ArabicMapping(1610, 65265));
				mapList.Add(new ArabicMapping(1570, 65153));
				mapList.Add(new ArabicMapping(1577, 65171));
				mapList.Add(new ArabicMapping(1662, 64342));
				mapList.Add(new ArabicMapping(1670, 64378));
				mapList.Add(new ArabicMapping(1688, 64394));
				mapList.Add(new ArabicMapping(1711, 64402));
				mapList.Add(new ArabicMapping(1705, 64398));
			}

			internal int Convert(int toBeConverted)
			{
				foreach (ArabicMapping map in mapList)
				{
					if (map.from == toBeConverted)
					{
						return map.to;
					}
				}
				return toBeConverted;
			}
		}
		internal class TashkeelLocation
		{
			public char tashkeel;

			public int position;

			public TashkeelLocation(char tashkeel, int position)
			{
				this.tashkeel = tashkeel;
				this.position = position;
			}
		}
		internal class RTLFixerTool
		{
			internal static bool showTashkeel = true;

			internal static bool useHinduNumbers;

			internal static string RemoveTashkeel(string str, out List<TashkeelLocation> tashkeelLocation)
			{
				tashkeelLocation = new List<TashkeelLocation>();
				char[] array = str.ToCharArray();
				int num = 0;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == '\u064b')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u064b', i));
						num++;
					}
					else if (array[i] == '\u064c')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u064c', i));
						num++;
					}
					else if (array[i] == '\u064d')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u064d', i));
						num++;
					}
					else if (array[i] == '\u064e')
					{
						if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						tashkeelLocation.Add(new TashkeelLocation('\u064e', i));
						num++;
					}
					else if (array[i] == '\u064f')
					{
						if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						tashkeelLocation.Add(new TashkeelLocation('\u064f', i));
						num++;
					}
					else if (array[i] == '\u0650')
					{
						if (num > 0 && tashkeelLocation[num - 1].tashkeel == '\u0651')
						{
							tashkeelLocation[num - 1].tashkeel = '';
							continue;
						}
						tashkeelLocation.Add(new TashkeelLocation('\u0650', i));
						num++;
					}
					else if (array[i] == '\u0651')
					{
						if (num > 0)
						{
							if (tashkeelLocation[num - 1].tashkeel == '\u064e')
							{
								tashkeelLocation[num - 1].tashkeel = '';
								continue;
							}
							if (tashkeelLocation[num - 1].tashkeel == '\u064f')
							{
								tashkeelLocation[num - 1].tashkeel = '';
								continue;
							}
							if (tashkeelLocation[num - 1].tashkeel == '\u0650')
							{
								tashkeelLocation[num - 1].tashkeel = '';
								continue;
							}
						}
						tashkeelLocation.Add(new TashkeelLocation('\u0651', i));
						num++;
					}
					else if (array[i] == '\u0652')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u0652', i));
						num++;
					}
					else if (array[i] == '\u0653')
					{
						tashkeelLocation.Add(new TashkeelLocation('\u0653', i));
						num++;
					}
				}
				string[] array2 = str.Split('\u064b', '\u064c', '\u064d', '\u064e', '\u064f', '\u0650', '\u0651', '\u0652', '\u0653', '', '', '');
				str = "";
				string[] array3 = array2;
				foreach (string text in array3)
				{
					str += text;
				}
				return str;
			}

			internal static char[] ReturnTashkeel(char[] letters, List<TashkeelLocation> tashkeelLocation)
			{
				char[] array = new char[letters.Length + tashkeelLocation.Count];
				int num = 0;
				for (int i = 0; i < letters.Length; i++)
				{
					array[num] = letters[i];
					num++;
					foreach (TashkeelLocation item in tashkeelLocation)
					{
						if (item.position == num)
						{
							array[num] = item.tashkeel;
							num++;
						}
					}
				}
				return array;
			}

			internal static string FixLine(string str)
			{
				string text = "";
				List<TashkeelLocation> tashkeelLocation;
				string text2 = RemoveTashkeel(str, out tashkeelLocation);
				char[] array = text2.ToCharArray();
				char[] array2 = text2.ToCharArray();
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = (char)ArabicTable.ArabicMapper.Convert(array[i]);
				}
				for (int j = 0; j < array.Length; j++)
				{
					bool flag = false;
					if (array[j] == '' && j < array.Length - 1)
					{
						if (array[j + 1] == '')
						{
							array[j] = '';
							array2[j + 1] = '\uffff';
							flag = true;
						}
						else if (array[j + 1] == '')
						{
							array[j] = '';
							array2[j + 1] = '\uffff';
							flag = true;
						}
						else if (array[j + 1] == '')
						{
							array[j] = '';
							array2[j + 1] = '\uffff';
							flag = true;
						}
						else if (array[j + 1] == '')
						{
							array[j] = '';
							array2[j + 1] = '\uffff';
							flag = true;
						}
					}
					if (!IsIgnoredCharacter(array[j]))
					{
						if (IsMiddleLetter(array, j))
						{
							array2[j] = (char)(array[j] + 3);
						}
						else if (IsFinishingLetter(array, j))
						{
							array2[j] = (char)(array[j] + 1);
						}
						else if (IsLeadingLetter(array, j))
						{
							array2[j] = (char)(array[j] + 2);
						}
					}
					text = text + Convert.ToString(array[j], 16) + " ";
					if (flag)
					{
						j++;
					}
					if (useHinduNumbers)
					{
						if (array[j] == '0')
						{
							array2[j] = '';
						}
						else if (array[j] == '1')
						{
							array2[j] = '';
						}
						else if (array[j] == '2')
						{
							array2[j] = '';
						}
						else if (array[j] == '3')
						{
							array2[j] = '';
						}
						else if (array[j] == '4')
						{
							array2[j] = '';
						}
						else if (array[j] == '5')
						{
							array2[j] = '';
						}
						else if (array[j] == '6')
						{
							array2[j] = '';
						}
						else if (array[j] == '7')
						{
							array2[j] = '';
						}
						else if (array[j] == '8')
						{
							array2[j] = '';
						}
						else if (array[j] == '9')
						{
							array2[j] = '';
						}
					}
				}
				if (showTashkeel)
				{
					array2 = ReturnTashkeel(array2, tashkeelLocation);
				}
				List<char> list = new List<char>();
				List<char> list2 = new List<char>();
				for (int num = array2.Length - 1; num >= 0; num--)
				{
					if (char.IsPunctuation(array2[num]) && num > 0 && num < array2.Length - 1 && (char.IsPunctuation(array2[num - 1]) || char.IsPunctuation(array2[num + 1])))
					{
						if (array2[num] == '(')
						{
							list.Add(')');
						}
						else if (array2[num] == ')')
						{
							list.Add('(');
						}
						else if (array2[num] == '<')
						{
							list.Add('>');
						}
						else if (array2[num] == '>')
						{
							list.Add('<');
						}
						else if (array2[num] == '[')
						{
							list.Add(']');
						}
						else if (array2[num] == ']')
						{
							list.Add('[');
						}
						else if (array2[num] != '\uffff')
						{
							list.Add(array2[num]);
						}
					}
					else if (array2[num] == ' ' && num > 0 && num < array2.Length - 1 && (char.IsLower(array2[num - 1]) || char.IsUpper(array2[num - 1]) || char.IsNumber(array2[num - 1])) && (char.IsLower(array2[num + 1]) || char.IsUpper(array2[num + 1]) || char.IsNumber(array2[num + 1])))
					{
						list2.Add(array2[num]);
					}
					else if (char.IsNumber(array2[num]) || char.IsLower(array2[num]) || char.IsUpper(array2[num]) || char.IsSymbol(array2[num]) || char.IsPunctuation(array2[num]))
					{
						if (array2[num] == '(')
						{
							list2.Add(')');
						}
						else if (array2[num] == ')')
						{
							list2.Add('(');
						}
						else if (array2[num] == '<')
						{
							list2.Add('>');
						}
						else if (array2[num] == '>')
						{
							list2.Add('<');
						}
						else if (array2[num] == '[')
						{
							list.Add(']');
						}
						else if (array2[num] == ']')
						{
							list.Add('[');
						}
						else
						{
							list2.Add(array2[num]);
						}
					}
					else if ((array2[num] >= '\ud800' && array2[num] <= '\udbff') || (array2[num] >= '\udc00' && array2[num] <= '\udfff'))
					{
						list2.Add(array2[num]);
					}
					else
					{
						if (list2.Count > 0)
						{
							for (int k = 0; k < list2.Count; k++)
							{
								list.Add(list2[list2.Count - 1 - k]);
							}
							list2.Clear();
						}
						if (array2[num] != '\uffff')
						{
							list.Add(array2[num]);
						}
					}
				}
				if (list2.Count > 0)
				{
					for (int l = 0; l < list2.Count; l++)
					{
						list.Add(list2[list2.Count - 1 - l]);
					}
					list2.Clear();
				}
				array2 = new char[list.Count];
				for (int m = 0; m < array2.Length; m++)
				{
					array2[m] = list[m];
				}
				str = new string(array2);
				return str;
			}

			internal static bool IsIgnoredCharacter(char ch)
			{
				bool num = char.IsPunctuation(ch);
				bool flag = char.IsNumber(ch);
				bool flag2 = char.IsLower(ch);
				bool flag3 = char.IsUpper(ch);
				bool flag4 = char.IsSymbol(ch);
				bool flag5 = ch == '' || ch == '' || ch == '' || ch == '' || ch == '';
				bool flag6 = (ch <= '\ufeff' && ch >= '') || flag5 || ch == '';
				if (!(num || flag || flag2 || flag3 || flag4) && flag6 && ch != 'a' && ch != '>' && ch != '<')
				{
					return ch == '';
				}
				return true;
			}

			internal static bool IsLeadingLetter(char[] letters, int index)
			{
				bool num = index == 0 || letters[index - 1] == ' ' || letters[index - 1] == '*' || letters[index - 1] == 'A' || char.IsPunctuation(letters[index - 1]) || letters[index - 1] == '>' || letters[index - 1] == '<' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '' || letters[index - 1] == '';
				bool flag = letters[index] != ' ' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '';
				bool flag2 = index < letters.Length - 1 && letters[index + 1] != ' ' && !char.IsPunctuation(letters[index + 1]) && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsLower(letters[index + 1]) && !char.IsUpper(letters[index + 1]) && letters[index + 1] != '';
				if (num && flag && flag2)
				{
					return true;
				}
				return false;
			}

			internal static bool IsFinishingLetter(char[] letters, int index)
			{
				bool num = index != 0 && letters[index - 1] != ' ' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<';
				bool flag = letters[index] != ' ' && letters[index] != '';
				if (num && flag)
				{
					return true;
				}
				return false;
			}

			internal static bool IsMiddleLetter(char[] letters, int index)
			{
				bool flag = index != 0 && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '' && letters[index] != '';
				bool flag2 = index != 0 && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && letters[index - 1] != '' && !char.IsPunctuation(letters[index - 1]) && letters[index - 1] != '>' && letters[index - 1] != '<' && letters[index - 1] != ' ' && letters[index - 1] != '*';
				if (index < letters.Length - 1 && letters[index + 1] != ' ' && letters[index + 1] != '\r' && letters[index + 1] != '' && !char.IsNumber(letters[index + 1]) && !char.IsSymbol(letters[index + 1]) && !char.IsPunctuation(letters[index + 1]) && flag2 && flag)
				{
					try
					{
						if (char.IsPunctuation(letters[index + 1]))
						{
							return false;
						}
						return true;
					}
					catch
					{
						return false;
					}
				}
				return false;
			}
		}
		public class RegisterCallback_AllowSyncFromGoogle : MonoBehaviour
		{
			public void Awake()
			{
				LocalizationManager.Callback_AllowSyncFromGoogle = AllowSyncFromGoogle;
			}

			public void OnEnable()
			{
				LocalizationManager.Callback_AllowSyncFromGoogle = AllowSyncFromGoogle;
			}

			public void OnDisable()
			{
				LocalizationManager.Callback_AllowSyncFromGoogle = null;
			}

			public virtual bool AllowSyncFromGoogle(LanguageSourceData Source)
			{
				return true;
			}
		}
		public class RegisterGlobalParameters : MonoBehaviour, ILocalizationParamsManager
		{
			public virtual void OnEnable()
			{
				if (!LocalizationManager.ParamManagers.Contains(this))
				{
					LocalizationManager.ParamManagers.Add(this);
					LocalizationManager.LocalizeAll(Force: true);
				}
			}

			public virtual void OnDisable()
			{
				LocalizationManager.ParamManagers.Remove(this);
			}

			public virtual string GetParameterValue(string ParamName)
			{
				return null;
			}
		}
		public interface IResourceManager_Bundles
		{
			UnityEngine.Object LoadFromBundle(string path, Type assetType);
		}
		public class ResourceManager : MonoBehaviour
		{
			private static ResourceManager mInstance;

			public List<IResourceManager_Bundles> mBundleManagers = new List<IResourceManager_Bundles>();

			public UnityEngine.Object[] Assets;

			private readonly Dictionary<string, UnityEngine.Object> mResourcesCache = new Dictionary<string, UnityEngine.Object>(StringComparer.Ordinal);

			public static ResourceManager pInstance
			{
				get
				{
					bool flag = mInstance == null;
					if (mInstance == null)
					{
						mInstance = (ResourceManager)UnityEngine.Object.FindObjectOfType(typeof(ResourceManager));
					}
					if (mInstance == null)
					{
						GameObject obj = new GameObject("I2ResourceManager", typeof(ResourceManager));
						obj.hideFlags |= HideFlags.HideAndDontSave;
						mInstance = obj.GetComponent<ResourceManager>();
						SceneManager.sceneLoaded += MyOnLevelWasLoaded;
					}
					if (flag && Application.isPlaying)
					{
						UnityEngine.Object.DontDestroyOnLoad(mInstance.gameObject);
					}
					return mInstance;
				}
			}

			public static void MyOnLevelWasLoaded(Scene scene, LoadSceneMode mode)
			{
				pInstance.CleanResourceCache();
				LocalizationManager.UpdateSources();
			}

			public T GetAsset<T>(string Name) where T : UnityEngine.Object
			{
				T val = FindAsset(Name) as T;
				if (val != null)
				{
					return val;
				}
				return LoadFromResources<T>(Name);
			}

			private UnityEngine.Object FindAsset(string Name)
			{
				if (Assets != null)
				{
					int i = 0;
					for (int num = Assets.Length; i < num; i++)
					{
						if (Assets[i] != null && Assets[i].name == Name)
						{
							return Assets[i];
						}
					}
				}
				return null;
			}

			public bool HasAsset(UnityEngine.Object Obj)
			{
				if (Assets == null)
				{
					return false;
				}
				return Array.IndexOf(Assets, Obj) >= 0;
			}

			public T LoadFromResources<T>(string Path) where T : UnityEngine.Object
			{
				try
				{
					if (string.IsNullOrEmpty(Path))
					{
						return null;
					}
					if (mResourcesCache.TryGetValue(Path, out var value) && value != null)
					{
						return value as T;
					}
					T val = null;
					if (Path.EndsWith("]", StringComparison.OrdinalIgnoreCase))
					{
						int num = Path.LastIndexOf("[", StringComparison.OrdinalIgnoreCase);
						int length = Path.Length - num - 2;
						string value2 = Path.Substring(num + 1, length);
						Path = Path.Substring(0, num);
						T[] array = Resources.LoadAll<T>(Path);
						int i = 0;
						for (int num2 = array.Length; i < num2; i++)
						{
							if (array[i].name.Equals(value2))
							{
								val = array[i];
								break;
							}
						}
					}
					else
					{
						val = Resources.Load(Path, typeof(T)) as T;
					}
					if (val == null)
					{
						val = LoadFromBundle<T>(Path);
					}
					if (val != null)
					{
						mResourcesCache[Path] = val;
					}
					return val;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogErrorFormat("Unable to load {0} '{1}'\nERROR: {2}", typeof(T), Path, ex.ToString());
					return null;
				}
			}

			public T LoadFromBundle<T>(string path) where T : UnityEngine.Object
			{
				int i = 0;
				for (int count = mBundleManagers.Count; i < count; i++)
				{
					if (mBundleManagers[i] != null)
					{
						T val = mBundleManagers[i].LoadFromBundle(path, typeof(T)) as T;
						if (val != null)
						{
							return val;
						}
					}
				}
				return null;
			}

			public void CleanResourceCache(bool unloadResources = false)
			{
				mResourcesCache.Clear();
				if (unloadResources)
				{
					Resources.UnloadUnusedAssets();
				}
				CancelInvoke();
			}
		}
		[AddComponentMenu("I2/Localization/SetLanguage Button")]
		public class SetLanguage : MonoBehaviour
		{
			public string _Language;

			private void OnClick()
			{
				ApplyLanguage();
			}

			public void ApplyLanguage()
			{
				if (LocalizationManager.HasLanguage(_Language))
				{
					LocalizationManager.CurrentLanguage = _Language;
				}
			}
		}
		[AddComponentMenu("I2/Localization/SetLanguage Dropdown")]
		public class SetLanguageDropdown : MonoBehaviour
		{
			private void OnEnable()
			{
				Dropdown component = GetComponent<Dropdown>();
				if (!(component == null))
				{
					string currentLanguage = LocalizationManager.CurrentLanguage;
					if (LocalizationManager.Sources.Count == 0)
					{
						LocalizationManager.UpdateSources();
					}
					List<string> allLanguages = LocalizationManager.GetAllLanguages();
					component.ClearOptions();
					component.AddOptions(allLanguages);
					component.value = allLanguages.IndexOf(currentLanguage);
					component.onValueChanged.RemoveListener(OnValueChanged);
					component.onValueChanged.AddListener(OnValueChanged);
				}
			}

			private void OnValueChanged(int index)
			{
				Dropdown component = GetComponent<Dropdown>();
				if (index < 0)
				{
					index = 0;
					component.value = index;
				}
				LocalizationManager.CurrentLanguage = component.options[index].text;
			}
		}
		public class StringObfucator
		{
			public static char[] StringObfuscatorPassword = "bUu\u00b8C*4P-@T6DlWuzm4G$=g,QiKEr60t4~^y:d1<QbUu\u00b8C*4P-@T6DlWuzm4G$=g,QiKEr60t4~^y:d".ToCharArray();

			public static string Encode(string NormalString)
			{
				try
				{
					return ToBase64(XoREncode(NormalString));
				}
				catch (Exception)
				{
					return null;
				}
			}

			public static string Decode(string ObfucatedString)
			{
				try
				{
					return XoREncode(FromBase64(ObfucatedString));
				}
				catch (Exception)
				{
					return null;
				}
			}

			private static string ToBase64(string regularString)
			{
				return Convert.ToBase64String(Encoding.UTF8.GetBytes(regularString));
			}

			private static string FromBase64(string base64string)
			{
				byte[] array = Convert.FromBase64String(base64string);
				return Encoding.UTF8.GetString(array, 0, array.Length);
			}

			private static string XoREncode(string NormalString)
			{
				try
				{
					char[] stringObfuscatorPassword = StringObfuscatorPassword;
					char[] array = NormalString.ToCharArray();
					int num = stringObfuscatorPassword.Length;
					int i = 0;
					for (int num2 = array.Length; i < num2; i++)
					{
						array[i] = (char)(array[i] ^ stringObfuscatorPassword[i % num] ^ (byte)((i % 2 == 0) ? (i * 23) : (-i * 51)));
					}
					return new string(array);
				}
				catch (Exception)
				{
					return null;
				}
			}
		}
	}
	namespace I2.Loc.SimpleJSON
	{
		public enum JSONBinaryTag
		{
			Array = 1,
			Class,
			Value,
			IntValue,
			DoubleValue,
			BoolValue,
			FloatValue
		}
		public class JSONNode
		{
			public virtual JSONNode this[int aIndex]
			{
				get
				{
					return null;
				}
				set
				{
				}
			}

			public virtual JSONNode this[string aKey]
			{
				get
				{
					return null;
				}
				set
				{
				}
			}

			public virtual string Value
			{
				get
				{
					return "";
				}
				set
				{
				}
			}

			public virtual int Count => 0;

			public virtual IEnumerable<JSONNode> Childs
			{
				get
				{
					yield break;
				}
			}

			public IEnumerable<JSONNode> DeepChilds
			{
				get
				{
					foreach (JSONNode child in Childs)
					{
						foreach (JSONNode deepChild in child.DeepChilds)
						{
							yield return deepChild;
						}
					}
				}
			}

			public virtual int AsInt
			{
				get
				{
					int result = 0;
					if (int.TryParse(Value, out result))
					{
						return result;
					}
					return 0;
				}
				set
				{
					Value = value.ToString();
				}
			}

			public virtual float AsFloat
			{
				get
				{
					float result = 0f;
					if (float.TryParse(Value, out result))
					{
						return result;
					}
					return 0f;
				}
				set
				{
					Value = value.ToString();
				}
			}

			public virtual double AsDouble
			{
				get
				{
					double result = 0.0;
					if (double.TryParse(Value, out result))
					{
						return result;
					}
					return 0.0;
				}
				set
				{
					Value = value.ToString();
				}
			}

			public virtual bool AsBool
			{
				get
				{
					bool result = false;
					if (bool.TryParse(Value, out result))
					{
						return result;
					}
					return !string.IsNullOrEmpty(Value);
				}
				set
				{
					Value = (value ? "true" : "false");
				}
			}

			public virtual JSONArray AsArray => this as JSONArray;

			public virtual JSONClass AsObject => this as JSONClass;

			public virtual void Add(string aKey, JSONNode aItem)
			{
			}

			public virtual void Add(JSONNode aItem)
			{
				Add("", aItem);
			}

			public virtual JSONNode Remove(string aKey)
			{
				return null;
			}

			public virtual JSONNode Remove(int aIndex)
			{
				return null;
			}

			public virtual JSONNode Remove(JSONNode aNode)
			{
				return aNode;
			}

			public override string ToString()
			{
				return "JSONNode";
			}

			public virtual string ToString(string aPrefix)
			{
				return "JSONNode";
			}

			public static implicit operator JSONNode(string s)
			{
				return new JSONData(s);
			}

			public static implicit operator string(JSONNode d)
			{
				if (!(d == null))
				{
					return d.Value;
				}
				return null;
			}

			public static bool operator ==(JSONNode a, object b)
			{
				if (b == null && a is JSONLazyCreator)
				{
					return true;
				}
				return (object)a == b;
			}

			public static bool operator !=(JSONNode a, object b)
			{
				return !(a == b);
			}

			public override bool Equals(object obj)
			{
				return (object)this == obj;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			internal static string Escape(string aText)
			{
				string text = "";
				for (int i = 0; i < aText.Length; i++)
				{
					char c = aText[i];
					text = c switch
					{
						'\\' => text + "\\\\", 
						'"' => text + "\\\"", 
						'\n' => text + "\\n", 
						'\r' => text + "\\r", 
						'\t' => text + "\\t", 
						'\b' => text + "\\b", 
						'\f' => text + "\\f", 
						_ => text + c, 
					};
				}
				return text;
			}

			public static JSONNode Parse(string aJSON)
			{
				Stack<JSONNode> stack = new Stack<JSONNode>();
				JSONNode jSONNode = null;
				int i = 0;
				string text = "";
				string text2 = "";
				bool flag = false;
				for (; i < aJSON.Length; i++)
				{
					switch (aJSON[i])
					{
					case '{':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						stack.Push(new JSONClass());
						if (jSONNode != null)
						{
							text2 = text2.Trim();
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(stack.Peek());
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, stack.Peek());
							}
						}
						text2 = "";
						text = "";
						jSONNode = stack.Peek();
						break;
					case '[':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						stack.Push(new JSONArray());
						if (jSONNode != null)
						{
							text2 = text2.Trim();
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(stack.Peek());
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, stack.Peek());
							}
						}
						text2 = "";
						text = "";
						jSONNode = stack.Peek();
						break;
					case ']':
					case '}':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						if (stack.Count == 0)
						{
							throw new Exception("JSON Parse: Too many closing brackets");
						}
						stack.Pop();
						if (text != "")
						{
							text2 = text2.Trim();
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(text);
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, text);
							}
						}
						text2 = "";
						text = "";
						if (stack.Count > 0)
						{
							jSONNode = stack.Peek();
						}
						break;
					case ':':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						text2 = text;
						text = "";
						break;
					case '"':
						flag = !flag;
						break;
					case ',':
						if (flag)
						{
							text += aJSON[i];
							break;
						}
						if (text != "")
						{
							if (jSONNode is JSONArray)
							{
								jSONNode.Add(text);
							}
							else if (text2 != "")
							{
								jSONNode.Add(text2, text);
							}
						}
						text2 = "";
						text = "";
						break;
					case '\t':
					case ' ':
						if (flag)
						{
							text += aJSON[i];
						}
						break;
					case '\\':
						i++;
						if (flag)
						{
							char c = aJSON[i];
							switch (c)
							{
							case 't':
								text += "\t";
								break;
							case 'r':
								text += "\r";
								break;
							case 'n':
								text += "\n";
								break;
							case 'b':
								text += "\b";
								break;
							case 'f':
								text += "\f";
								break;
							case 'u':
							{
								string s = aJSON.Substring(i + 1, 4);
								text += (char)int.Parse(s, NumberStyles.AllowHexSpecifier);
								i += 4;
								break;
							}
							default:
								text += c;
								break;
							}
						}
						break;
					default:
						text += aJSON[i];
						break;
					case '\n':
					case '\r':
						break;
					}
				}
				if (flag)
				{
					throw new Exception("JSON Parse: Quotation marks seems to be messed up.");
				}
				return jSONNode;
			}

			public virtual void Serialize(BinaryWriter aWriter)
			{
			}

			public void SaveToStream(Stream aData)
			{
				BinaryWriter aWriter = new BinaryWriter(aData);
				Serialize(aWriter);
			}

			public void SaveToCompressedStream(Stream aData)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public void SaveToCompressedFile(string aFileName)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public string SaveToCompressedBase64()
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public void SaveToFile(string aFileName)
			{
				Directory.CreateDirectory(new FileInfo(aFileName).Directory.FullName);
				using FileStream aData = File.OpenWrite(aFileName);
				SaveToStream(aData);
			}

			public string SaveToBase64()
			{
				using MemoryStream memoryStream = new MemoryStream();
				SaveToStream(memoryStream);
				memoryStream.Position = 0L;
				return Convert.ToBase64String(memoryStream.ToArray());
			}

			public static JSONNode Deserialize(BinaryReader aReader)
			{
				JSONBinaryTag jSONBinaryTag = (JSONBinaryTag)aReader.ReadByte();
				switch (jSONBinaryTag)
				{
				case JSONBinaryTag.Array:
				{
					int num2 = aReader.ReadInt32();
					JSONArray jSONArray = new JSONArray();
					for (int j = 0; j < num2; j++)
					{
						jSONArray.Add(Deserialize(aReader));
					}
					return jSONArray;
				}
				case JSONBinaryTag.Class:
				{
					int num = aReader.ReadInt32();
					JSONClass jSONClass = new JSONClass();
					for (int i = 0; i < num; i++)
					{
						string aKey = aReader.ReadString();
						JSONNode aItem = Deserialize(aReader);
						jSONClass.Add(aKey, aItem);
					}
					return jSONClass;
				}
				case JSONBinaryTag.Value:
					return new JSONData(aReader.ReadString());
				case JSONBinaryTag.IntValue:
					return new JSONData(aReader.ReadInt32());
				case JSONBinaryTag.DoubleValue:
					return new JSONData(aReader.ReadDouble());
				case JSONBinaryTag.BoolValue:
					return new JSONData(aReader.ReadBoolean());
				case JSONBinaryTag.FloatValue:
					return new JSONData(aReader.ReadSingle());
				default:
					throw new Exception("Error deserializing JSON. Unknown tag: " + jSONBinaryTag);
				}
			}

			public static JSONNode LoadFromCompressedFile(string aFileName)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public static JSONNode LoadFromCompressedStream(Stream aData)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public static JSONNode LoadFromCompressedBase64(string aBase64)
			{
				throw new Exception("Can't use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON");
			}

			public static JSONNode LoadFromStream(Stream aData)
			{
				using BinaryReader aReader = new BinaryReader(aData);
				return Deserialize(aReader);
			}

			public static JSONNode LoadFromFile(string aFileName)
			{
				using FileStream aData = File.OpenRead(aFileName);
				return LoadFromStream(aData);
			}

			public static JSONNode LoadFromBase64(string aBase64)
			{
				return LoadFromStream(new MemoryStream(Convert.FromBase64String(aBase64))
				{
					Position = 0L
				});
			}
		}
		public class JSONArray : JSONNode, IEnumerable
		{
			private List<JSONNode> m_List = new List<JSONNode>();

			public override JSONNode this[int aIndex]
			{
				get
				{
					if (aIndex < 0 || aIndex >= m_List.Count)
					{
						return new JSONLazyCreator(this);
					}
					return m_List[aIndex];
				}
				set
				{
					if (aIndex < 0 || aIndex >= m_List.Count)
					{
						m_List.Add(value);
					}
					else
					{
						m_List[aIndex] = value;
					}
				}
			}

			public override JSONNode this[string aKey]
			{
				get
				{
					return new JSONLazyCreator(this);
				}
				set
				{
					m_List.Add(value);
				}
			}

			public override int Count => m_List.Count;

			public override IEnumerable<JSONNode> Childs
			{
				get
				{
					foreach (JSONNode item in m_List)
					{
						yield return item;
					}
				}
			}

			public override void Add(string aKey, JSONNode aItem)
			{
				m_List.Add(aItem);
			}

			public override JSONNode Remove(int aIndex)
			{
				if (aIndex < 0 || aIndex >= m_List.Count)
				{
					return null;
				}
				JSONNode result = m_List[aIndex];
				m_List.RemoveAt(aIndex);
				return result;
			}

			public override JSONNode Remove(JSONNode aNode)
			{
				m_List.Remove(aNode);
				return aNode;
			}

			public IEnumerator GetEnumerator()
			{
				foreach (JSONNode item in m_List)
				{
					yield return item;
				}
			}

			public override string ToString()
			{
				string text = "[ ";
				foreach (JSONNode item in m_List)
				{
					if (text.Length > 2)
					{
						text += ", ";
					}
					text += item.ToString();
				}
				return text + " ]";
			}

			public override string ToString(string aPrefix)
			{
				string text = "[ ";
				foreach (JSONNode item in m_List)
				{
					if (text.Length > 3)
					{
						text += ", ";
					}
					text = text + "\n" + aPrefix + "   ";
					text += item.ToString(aPrefix + "   ");
				}
				return text + "\n" + aPrefix + "]";
			}

			public override void Serialize(BinaryWriter aWriter)
			{
				aWriter.Write((byte)1);
				aWriter.Write(m_List.Count);
				for (int i = 0; i < m_List.Count; i++)
				{
					m_List[i].Serialize(aWriter);
				}
			}
		}
		public class JSONClass : JSONNode, IEnumerable
		{
			private Dictionary<string, JSONNode> m_Dict = new Dictionary<string, JSONNode>(StringComparer.Ordinal);

			public override JSONNode this[string aKey]
			{
				get
				{
					if (m_Dict.ContainsKey(aKey))
					{
						return m_Dict[aKey];
					}
					return new JSONLazyCreator(this, aKey);
				}
				set
				{
					if (m_Dict.ContainsKey(aKey))
					{
						m_Dict[aKey] = value;
					}
					else
					{
						m_Dict.Add(aKey, value);
					}
				}
			}

			public override JSONNode this[int aIndex]
			{
				get
				{
					if (aIndex < 0 || aIndex >= m_Dict.Count)
					{
						return null;
					}
					return m_Dict.ElementAt(aIndex).Value;
				}
				set
				{
					if (aIndex >= 0 && aIndex < m_Dict.Count)
					{
						string key = m_Dict.ElementAt(aIndex).Key;
						m_Dict[key] = value;
					}
				}
			}

			public override int Count => m_Dict.Count;

			public override IEnumerable<JSONNode> Childs
			{
				get
				{
					foreach (KeyValuePair<string, JSONNode> item in m_Dict)
					{
						yield return item.Value;
					}
				}
			}

			public override void Add(string aKey, JSONNode aItem)
			{
				if (!string.IsNullOrEmpty(aKey))
				{
					if (m_Dict.ContainsKey(aKey))
					{
						m_Dict[aKey] = aItem;
					}
					else
					{
						m_Dict.Add(aKey, aItem);
					}
				}
				else
				{
					m_Dict.Add(Guid.NewGuid().ToString(), aItem);
				}
			}

			public override JSONNode Remove(string aKey)
			{
				if (!m_Dict.ContainsKey(aKey))
				{
					return null;
				}
				JSONNode result = m_Dict[aKey];
				m_Dict.Remove(aKey);
				return result;
			}

			public override JSONNode Remove(int aIndex)
			{
				if (aIndex < 0 || aIndex >= m_Dict.Count)
				{
					return null;
				}
				KeyValuePair<string, JSONNode> keyValuePair = m_Dict.ElementAt(aIndex);
				m_Dict.Remove(keyValuePair.Key);
				return keyValuePair.Value;
			}

			public override JSONNode Remove(JSONNode aNode)
			{
				try
				{
					KeyValuePair<string, JSONNode> keyValuePair = m_Dict.Where((KeyValuePair<string, JSONNode> k) => k.Value == aNode).First();
					m_Dict.Remove(keyValuePair.Key);
					return aNode;
				}
				catch
				{
					return null;
				}
			}

			public IEnumerator GetEnumerator()
			{
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					yield return item;
				}
			}

			public override string ToString()
			{
				string text = "{";
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					if (text.Length > 2)
					{
						text += ", ";
					}
					text = text + "\"" + JSONNode.Escape(item.Key) + "\":" + item.Value;
				}
				return text + "}";
			}

			public override string ToString(string aPrefix)
			{
				string text = "{ ";
				foreach (KeyValuePair<string, JSONNode> item in m_Dict)
				{
					if (text.Length > 3)
					{
						text += ", ";
					}
					text = text + "\n" + aPrefix + "   ";
					text = text + "\"" + JSONNode.Escape(item.Key) + "\" : " + item.Value.ToString(aPrefix + "   ");
				}
				return text + "\n" + aPrefix + "}";
			}

			public override void Serialize(BinaryWriter aWriter)
			{
				aWriter.Write((byte)2);
				aWriter.Write(m_Dict.Count);
				foreach (string key in m_Dict.Keys)
				{
					aWriter.Write(key);
					m_Dict[key].Serialize(aWriter);
				}
			}
		}
		public class JSONData : JSONNode
		{
			private string m_Data;

			public override string Value
			{
				get
				{
					return m_Data;
				}
				set
				{
					m_Data = value;
				}
			}

			public JSONData(string aData)
			{
				m_Data = aData;
			}

			public JSONData(float aData)
			{
				AsFloat = aData;
			}

			public JSONData(double aData)
			{
				AsDouble = aData;
			}

			public JSONData(bool aData)
			{
				AsBool = aData;
			}

			public JSONData(int aData)
			{
				AsInt = aData;
			}

			public override string ToString()
			{
				return "\"" + JSONNode.Escape(m_Data) + "\"";
			}

			public override string ToString(string aPrefix)
			{
				return "\"" + JSONNode.Escape(m_Data) + "\"";
			}

			public override void Serialize(BinaryWriter aWriter)
			{
				JSONData jSONData = new JSONData("");
				jSONData.AsInt = AsInt;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)4);
					aWriter.Write(AsInt);
					return;
				}
				jSONData.AsFloat = AsFloat;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)7);
					aWriter.Write(AsFloat);
					return;
				}
				jSONData.AsDouble = AsDouble;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)5);
					aWriter.Write(AsDouble);
					return;
				}
				jSONData.AsBool = AsBool;
				if (jSONData.m_Data == m_Data)
				{
					aWriter.Write((byte)6);
					aWriter.Write(AsBool);
				}
				else
				{
					aWriter.Write((byte)3);
					aWriter.Write(m_Data);
				}
			}
		}
		internal class JSONLazyCreator : JSONNode
		{
			private JSONNode m_Node;

			private string m_Key;

			public override JSONNode this[int aIndex]
			{
				get
				{
					return new JSONLazyCreator(this);
				}
				set
				{
					JSONArray jSONArray = new JSONArray();
					jSONArray.Add(value);
					Set(jSONArray);
				}
			}

			public override JSONNode this[string aKey]
			{
				get
				{
					return new JSONLazyCreator(this, aKey);
				}
				set
				{
					JSONClass jSONClass = new JSONClass();
					jSONClass.Add(aKey, value);
					Set(jSONClass);
				}
			}

			public override int AsInt
			{
				get
				{
					JSONData aVal = new JSONData(0);
					Set(aVal);
					return 0;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override float AsFloat
			{
				get
				{
					JSONData aVal = new JSONData(0f);
					Set(aVal);
					return 0f;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override double AsDouble
			{
				get
				{
					JSONData aVal = new JSONData(0.0);
					Set(aVal);
					return 0.0;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override bool AsBool
			{
				get
				{
					JSONData aVal = new JSONData(aData: false);
					Set(aVal);
					return false;
				}
				set
				{
					JSONData aVal = new JSONData(value);
					Set(aVal);
				}
			}

			public override JSONArray AsArray
			{
				get
				{
					JSONArray jSONArray = new JSONArray();
					Set(jSONArray);
					return jSONArray;
				}
			}

			public override JSONClass AsObject
			{
				get
				{
					JSONClass jSONClass = new JSONClass();
					Set(jSONClass);
					return jSONClass;
				}
			}

			public JSONLazyCreator(JSONNode aNode)
			{
				m_Node = aNode;
				m_Key = null;
			}

			public JSONLazyCreator(JSONNode aNode, string aKey)
			{
				m_Node = aNode;
				m_Key = aKey;
			}

			private void Set(JSONNode aVal)
			{
				if (m_Key == null)
				{
					m_Node.Add(aVal);
				}
				else
				{
					m_Node.Add(m_Key, aVal);
				}
				m_Node = null;
			}

			public override void Add(JSONNode aItem)
			{
				JSONArray jSONArray = new JSONArray();
				jSONArray.Add(aItem);
				Set(jSONArray);
			}

			public override void Add(string aKey, JSONNode aItem)
			{
				JSONClass jSONClass = new JSONClass();
				jSONClass.Add(aKey, aItem);
				Set(jSONClass);
			}

			public static bool operator ==(JSONLazyCreator a, object b)
			{
				if (b == null)
				{
					return true;
				}
				return (object)a == b;
			}

			public static bool operator !=(JSONLazyCreator a, object b)
			{
				return !(a == b);
			}

			public override bool Equals(object obj)
			{
				if (obj == null)
				{
					return true;
				}
				return (object)this == obj;
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			public override string ToString()
			{
				return "";
			}

			public override string ToString(string aPrefix)
			{
				return "";
			}
		}
		public static class JSON
		{
			public static JSONNode Parse(string aJSON)
			{
				return JSONNode.Parse(aJSON);
			}
		}
	}
	namespace HighlightPlus
	{
		public delegate bool OnObjectHighlightEvent(GameObject obj);
		public delegate bool OnRendererHighlightEvent(Renderer renderer);
		public delegate void OnTargetAnimatesEvent(ref Vector3 center, ref Quaternion rotation, ref Vector3 scale, float t);
		public enum NormalsOption
		{
			Smooth,
			PreserveOriginal,
			Reorient,
			Planar
		}
		public enum SeeThroughMode
		{
			WhenHighlighted,
			AlwaysWhenOccluded,
			Never
		}
		public enum QualityLevel
		{
			Fastest,
			High,
			Highest,
			Medium
		}
		public static class QualityLevelExtensions
		{
			public static bool UsesMultipleOffsets(this QualityLevel qualityLevel)
			{
				if (qualityLevel != QualityLevel.Medium)
				{
					return qualityLevel == QualityLevel.High;
				}
				return true;
			}
		}
		public enum TargetOptions
		{
			Children,
			OnlyThisObject,
			RootToChildren,
			LayerInScene,
			LayerInChildren,
			Scripting
		}
		public enum Visibility
		{
			Normal,
			AlwaysOnTop,
			OnlyWhenOccluded
		}
		public enum GlowBlendMode
		{
			Additive,
			AlphaBlending
		}
		[Serializable]
		public struct GlowPassData
		{
			public float offset;

			public float alpha;

			public Color color;
		}
		[ExecuteInEditMode]
		[HelpURL("https://www.dropbox.com/s/v9qgn68ydblqz8x/Documentation.pdf?dl=0")]
		public class HighlightEffect : MonoBehaviour
		{
			private struct ModelMaterials
			{
				public bool render;

				public Transform transform;

				public bool bakedTransform;

				public Vector3 currentPosition;

				public Vector3 currentRotation;

				public Vector3 currentScale;

				public bool renderWasVisibleDuringSetup;

				public Mesh mesh;

				public Mesh originalMesh;

				public Renderer renderer;

				public bool isSkinnedMesh;

				public NormalsOption normalsOption;

				public Material[] fxMatMask;

				public Material[] fxMatSolidColor;

				public Material[] fxMatSeeThroughInner;

				public Material[] fxMatSeeThroughBorder;

				public Material[] fxMatOverlay;

				public Material[] fxMatInnerGlow;

				public Matrix4x4 renderingMatrix;

				public bool isCombined;

				public bool preserveOriginalMesh
				{
					get
					{
						if (!isCombined)
						{
							return normalsOption == NormalsOption.PreserveOriginal;
						}
						return false;
					}
				}

				public void Init()
				{
					render = false;
					transform = null;
					bakedTransform = false;
					currentPosition = (currentRotation = (currentScale = Vector3.zero));
					mesh = (originalMesh = null);
					renderer = null;
					isSkinnedMesh = false;
					normalsOption = NormalsOption.Smooth;
					isCombined = false;
				}
			}

			private enum FadingState
			{
				FadingOut = -1,
				NoFading,
				FadingIn
			}

			[Tooltip("The current profile (optional). A profile let you store Highlight Plus settings and apply those settings easily to many objects. You can also load a profile and apply its settings at runtime, using the ProfileLoad() method of the Highlight Effect component.")]
			public HighlightProfile profile;

			[Tooltip("If enabled, settings from the profile will be applied to this component automatically when game starts or when any profile setting is updated.")]
			public bool profileSync;

			[Tooltip("If enabled, effects will be visible also when not in Play mode.")]
			public bool previewInEditor = true;

			[Tooltip("Which cameras can render the effect.")]
			public LayerMask camerasLayerMask = -1;

			[Tooltip("Different options to specify which objects are affected by this Highlight Effect component.")]
			public TargetOptions effectGroup;

			[Tooltip("The layer that contains the affected objects by this effect when effectGroup is set to LayerMask.")]
			public LayerMask effectGroupLayer = -1;

			[Tooltip("Only include objects whose names contains this text.")]
			public string effectNameFilter;

			[Tooltip("Combine meshes of all objects in this group affected by Highlight Effect reducing draw calls.")]
			public bool combineMeshes;

			[Tooltip("The alpha threshold for transparent cutout objects. Pixels with alpha below this value will be discarded.")]
			[Range(0f, 1f)]
			public float alphaCutOff;

			[Tooltip("If back facing triangles are ignored.Backfaces triangles are not visible but you may set this property to false to force highlight effects to act on those triangles as well.")]
			public bool cullBackFaces = true;

			[Tooltip("Show highlight effects even if the object is not visible. If this object or its children use GPU Instancing tools, the MeshRenderer can be disabled although the object is visible. In this case, this option is useful to enable highlighting.")]
			public bool ignoreObjectVisibility;

			[Tooltip("Support reflection probes. Enable only if you want the effects to be visible in reflections.")]
			public bool reflectionProbes;

			[Tooltip("Enables GPU instancing. Reduces draw calls in outline and outer glow effects on platforms that support GPU instancing. Should be enabled by default.")]
			public bool GPUInstancing = true;

			[Tooltip("Enables depth buffer clipping. Only applies to outline or outer glow in High Quality mode.")]
			public bool depthClip;

			[Tooltip("Normals handling option:\nPreserve original: use original mesh normals.\nSmooth: average normals to produce a smoother outline/glow mesh based effect.\nReorient: recomputes normals based on vertex direction to centroid.\nPlanar: same than reorient but renders outline and glow in an optimized way for 2D or planar meshes like quads or planes.")]
			public NormalsOption normalsOption;

			[Tooltip("Ignore highlighting on this object.")]
			public bool ignore;

			[SerializeField]
			private bool _highlighted;

			public float fadeInDuration;

			public float fadeOutDuration;

			public bool flipY;

			[Tooltip("Keeps the outline/glow size unaffected by object distance.")]
			public bool constantWidth = true;

			[Tooltip("Mask to include or exclude certain submeshes. By default, all submeshes are included.")]
			public int subMeshMask = -1;

			[Range(0f, 1f)]
			[Tooltip("Intensity of the overlay effect. A value of 0 disables the overlay completely.")]
			public float overlay;

			[ColorUsage(true, true)]
			public Color overlayColor = Color.yellow;

			public float overlayAnimationSpeed = 1f;

			[Range(0f, 1f)]
			public float overlayMinIntensity = 0.5f;

			[Range(0f, 1f)]
			[Tooltip("Controls the blending or mix of the overlay color with the natural colors of the object.")]
			public float overlayBlending = 1f;

			[Tooltip("Optional overlay texture.")]
			public Texture2D overlayTexture;

			public float overlayTextureScale = 1f;

			[Range(0f, 1f)]
			[Tooltip("Intensity of the outline. A value of 0 disables the outline completely.")]
			public float outline = 1f;

			[ColorUsage(true, true)]
			public Color outlineColor = Color.black;

			public float outlineWidth = 0.45f;

			public QualityLevel outlineQuality = QualityLevel.Medium;

			[Range(1f, 8f)]
			[Tooltip("Reduces the quality of the outline but improves performance a bit.")]
			public int outlineDownsampling = 2;

			public Visibility outlineVisibility;

			public GlowBlendMode glowBlendMode;

			public bool outlineOptimalBlit = true;

			public bool outlineBlitDebug;

			[Tooltip("If enabled, this object won't combine the outline with other objects.")]
			public bool outlineIndependent;

			[Range(0f, 5f)]
			[Tooltip("The intensity of the outer glow effect. A value of 0 disables the glow completely.")]
			public float glow;

			public float glowWidth = 0.4f;

			public QualityLevel glowQuality = QualityLevel.Medium;

			[Range(1f, 8f)]
			[Tooltip("Reduces the quality of the glow but improves performance a bit.")]
			public int glowDownsampling = 2;

			[ColorUsage(true, true)]
			public Color glowHQColor = new Color(0.64f, 1f, 0f, 1f);

			[Tooltip("When enabled, outer glow renders with dithering. When disabled, glow appears as a solid color.")]
			public bool glowDithering = true;

			[Tooltip("Seed for the dithering effect")]
			public float glowMagicNumber1 = 0.75f;

			[Tooltip("Another seed for the dithering effect that combines with first seed to create different patterns")]
			public float glowMagicNumber2 = 0.5f;

			public float glowAnimationSpeed = 1f;

			public Visibility glowVisibility;

			[Tooltip("Performs a blit to screen only over the affected area, instead of a full-screen pass")]
			public bool glowOptimalBlit = true;

			public bool glowBlitDebug;

			[Tooltip("Blends glow passes one after another. If this option is disabled, glow passes won't overlap (in this case, make sure the glow pass 1 has a smaller offset than pass 2, etc.)")]
			public bool glowBlendPasses = true;

			public GlowPassData[] glowPasses;

			[Range(0f, 5f)]
			[Tooltip("The intensity of the inner glow effect. A value of 0 disables the glow completely.")]
			public float innerGlow;

			[Range(0f, 2f)]
			public float innerGlowWidth = 1f;

			[ColorUsage(true, true)]
			public Color innerGlowColor = Color.white;

			public Visibility innerGlowVisibility;

			[Tooltip("Enables the targetFX effect. This effect draws an animated sprite over the object.")]
			public bool targetFX;

			public Texture2D targetFXTexture;

			[ColorUsage(true, true)]
			public Color targetFXColor = Color.white;

			public Transform targetFXCenter;

			public float targetFXRotationSpeed = 50f;

			public float targetFXInitialScale = 4f;

			public float targetFXEndScale = 1.5f;

			[Tooltip("Makes target scale relative to object renderer bounds")]
			public bool targetFXScaleToRenderBounds = true;

			[Tooltip("Places target FX sprite at the bottom of the highlighted object.")]
			public bool targetFXAlignToGround;

			[Tooltip("Fade out effect with altitude")]
			public float targetFXFadePower = 32f;

			public float targetFXGroundMaxDistance = 10f;

			public LayerMask targetFXGroundLayerMask = -1;

			public float targetFXTransitionDuration = 0.5f;

			[Tooltip("The duration of the effect. A value of 0 will keep the target sprite on screen while object is highlighted.")]
			public float targetFXStayDuration = 1.5f;

			public Visibility targetFXVisibility = Visibility.AlwaysOnTop;

			[Tooltip("See-through mode for this Highlight Effect component.")]
			public SeeThroughMode seeThrough = SeeThroughMode.Never;

			[Tooltip("This mask setting let you specify which objects will be considered as occluders and cause the see-through effect for this Highlight Effect component. For example, you assign your walls to a different layer and specify that layer here, so only walls and not other objects, like ground or ceiling, will trigger the see-through effect.")]
			public LayerMask seeThroughOccluderMask = -1;

			[Tooltip("A multiplier for the occluder volume size which can be used to reduce the actual size of occluders when Highlight Effect checks if they're occluding this object.")]
			[Range(0.01f, 0.6f)]
			public float seeThroughOccluderThreshold = 0.3f;

			[Tooltip("Uses stencil buffers to ensure pixel-accurate occlusion test. If this option is disabled, only physics raycasting is used to test for occlusion.")]
			public bool seeThroughOccluderMaskAccurate;

			[Tooltip("The interval of time between occlusion tests.")]
			public float seeThroughOccluderCheckInterval = 1f;

			[Tooltip("If enabled, occlusion test is performed for each children element. If disabled, the bounds of all children is combined and a single occlusion test is performed for the combined bounds.")]
			public bool seeThroughOccluderCheckIndividualObjects;

			[Tooltip("Shows the see-through effect only if the occluder if at this 'offset' distance from the object.")]
			public float seeThroughDepthOffset;

			[Tooltip("Hides the see-through effect if the occluder is further than this distance from the object (0 = infinite)")]
			public float seeThroughMaxDepth;

			[Range(0f, 5f)]
			public float seeThroughIntensity = 0.8f;

			[Range(0f, 1f)]
			public float seeThroughTintAlpha = 0.5f;

			[ColorUsage(true, true)]
			public Color seeThroughTintColor = Color.red;

			[Range(0f, 1f)]
			public float seeThroughNoise = 1f;

			[Range(0f, 1f)]
			public float seeThroughBorder;

			public Color seeThroughBorderColor = Color.black;

			public float seeThroughBorderWidth = 0.45f;

			[Tooltip("Renders see-through effect on overlapping objects in a sequence that's relative to the distance to the camera")]
			public bool seeThroughOrdered;

			[SerializeField]
			[HideInInspector]
			private ModelMaterials[] rms;

			[SerializeField]
			[HideInInspector]
			private int rmsCount;

			[NonSerialized]
			public Transform target;

			[NonSerialized]
			public float highlightStartTime;

			[NonSerialized]
			public float targetFxStartTime;

			[NonSerialized]
			public bool isSelected;

			[NonSerialized]
			public HighlightProfile previousSettings;

			private const float TAU = 0.70711f;

			private static Material fxMatMask;

			private static Material fxMatSolidColor;

			private static Material fxMatSeeThroughInner;

			private static Material fxMatSeeThroughBorder;

			private static Material fxMatOverlay;

			private static Material fxMatClearStencil;

			private static Material fxMatGlowRef;

			private static Material fxMatInnerGlow;

			private static Material fxMatOutlineRef;

			private static Material fxMatTargetRef;

			private static Material fxMatComposeGlowRef;

			private static Material fxMatComposeOutlineRef;

			private static Material fxMatBlurGlowRef;

			private static Material fxMatBlurOutlineRef;

			private static Material fxMatSeeThroughMask;

			private Material _fxMatOutline;

			private Material _fxMatGlow;

			private Material _fxMatTarget;

			private Material _fxMatComposeGlow;

			private Material _fxMatComposeOutline;

			private Material _fxMatBlurGlow;

			private Material _fxMatBlurOutline;

			private static Vector4[] offsets;

			private float fadeStartTime;

			private FadingState fading;

			private CommandBuffer cbMask;

			private CommandBuffer cbSeeThrough;

			private CommandBuffer cbGlow;

			private CommandBuffer cbOutline;

			private CommandBuffer cbOverlay;

			private CommandBuffer cbInnerGlow;

			private CommandBuffer cbSmoothBlend;

			private int[] mipGlowBuffers;

			private int[] mipOutlineBuffers;

			private int glowRT;

			private int outlineRT;

			private static Mesh quadMesh;

			private static Mesh cubeMesh;

			private int sourceRT;

			private Matrix4x4 quadGlowMatrix;

			private Matrix4x4 quadOutlineMatrix;

			private Vector3[] corners;

			private RenderTextureDescriptor sourceDesc;

			private Color debugColor;

			private Color blackColor;

			private Visibility lastOutlineVisibility;

			private bool requireUpdateMaterial;

			private bool usingPipeline;

			private float occlusionCheckLastTime;

			private int occlusionRenderFrame;

			private bool lastOcclusionTestResult;

			private bool useGPUInstancing;

			private MaterialPropertyBlock glowPropertyBlock;

			private MaterialPropertyBlock outlinePropertyBlock;

			private static readonly List<Vector4> matDataDirection = new List<Vector4>();

			private static readonly List<Vector4> matDataGlow = new List<Vector4>();

			private static readonly List<Vector4> matDataColor = new List<Vector4>();

			private static Matrix4x4[] matrices;

			public static readonly List<HighlightEffect> effects = new List<HighlightEffect>();

			public static bool customSorting;

			private static int customSortingFrame;

			private static Camera customSortingCamera;

			private int skipThisFrame = -1;

			private int outlineOffsetsMin;

			private int outlineOffsetsMax;

			private int glowOffsetsMin;

			private int glowOffsetsMax;

			private static CombineInstance[] combineInstances;

			private Matrix4x4 matrix4X4Identity = Matrix4x4.identity;

			private bool maskRequired;

			private List<Renderer> tempRR;

			private static List<Vector3> vertices;

			private static List<Vector3> normals;

			private static Vector3[] newNormals;

			private static int[] matches;

			private static readonly Dictionary<Vector3, int> vv = new Dictionary<Vector3, int>();

			private static readonly Dictionary<int, Mesh> smoothMeshes = new Dictionary<int, Mesh>();

			private static readonly Dictionary<int, Mesh> reorientedMeshes = new Dictionary<int, Mesh>();

			private static readonly Dictionary<int, Mesh> combinedMeshes = new Dictionary<int, Mesh>();

			private static readonly List<Material> rendererSharedMaterials = new List<Material>();

			private int combinedMeshesHashId;

			private const int MAX_VERTEX_COUNT = 65535;

			[Range(0f, 1f)]
			public float hitFxInitialIntensity;

			public HitFxMode hitFxMode;

			public float hitFxFadeOutDuration = 0.25f;

			[ColorUsage(true, true)]
			public Color hitFxColor = Color.white;

			public float hitFxRadius = 0.5f;

			private float hitInitialIntensity;

			private float hitStartTime;

			private float hitFadeOutDuration;

			private Color hitColor;

			private bool hitActive;

			private Vector3 hitPosition;

			private float hitRadius;

			private static readonly List<HighlightSeeThroughOccluder> occluders = new List<HighlightSeeThroughOccluder>();

			private static readonly Dictionary<Camera, int> occludersFrameCount = new Dictionary<Camera, int>();

			private static CommandBuffer cbOccluder;

			private static Material fxMatOccluder;

			private static RaycastHit[] hits;

			private const int MAX_OCCLUDER_HITS = 50;

			private static RaycastHit[] occluderHits;

			private readonly Dictionary<Camera, List<Renderer>> cachedOccludersPerCamera = new Dictionary<Camera, List<Renderer>>();

			public bool highlighted
			{
				get
				{
					return _highlighted;
				}
				set
				{
					SetHighlighted(value);
				}
			}

			public int includedObjectsCount => rmsCount;

			private Material fxMatOutline
			{
				get
				{
					if (_fxMatOutline == null && fxMatOutlineRef != null)
					{
						_fxMatOutline = UnityEngine.Object.Instantiate(fxMatOutlineRef);
						if (useGPUInstancing)
						{
							_fxMatOutline.enableInstancing = true;
						}
						else
						{
							_fxMatOutline.enableInstancing = false;
						}
					}
					return _fxMatOutline;
				}
			}

			private Material fxMatGlow
			{
				get
				{
					if (_fxMatGlow == null && fxMatGlowRef != null)
					{
						_fxMatGlow = UnityEngine.Object.Instantiate(fxMatGlowRef);
						if (useGPUInstancing)
						{
							_fxMatGlow.enableInstancing = true;
						}
						else
						{
							_fxMatGlow.enableInstancing = false;
						}
					}
					return _fxMatGlow;
				}
			}

			private Material fxMatTarget
			{
				get
				{
					if (_fxMatTarget == null && fxMatTargetRef != null)
					{
						_fxMatTarget = UnityEngine.Object.Instantiate(fxMatTargetRef);
					}
					return _fxMatTarget;
				}
			}

			private Material fxMatComposeGlow
			{
				get
				{
					if (_fxMatComposeGlow == null && fxMatComposeGlowRef != null)
					{
						_fxMatComposeGlow = UnityEngine.Object.Instantiate(fxMatComposeGlowRef);
					}
					return _fxMatComposeGlow;
				}
			}

			private Material fxMatComposeOutline
			{
				get
				{
					if (_fxMatComposeOutline == null && fxMatComposeOutlineRef != null)
					{
						_fxMatComposeOutline = UnityEngine.Object.Instantiate(fxMatComposeOutlineRef);
					}
					return _fxMatComposeOutline;
				}
			}

			private Material fxMatBlurGlow
			{
				get
				{
					if (_fxMatBlurGlow == null && fxMatBlurGlowRef != null)
					{
						_fxMatBlurGlow = UnityEngine.Object.Instantiate(fxMatBlurGlowRef);
					}
					return _fxMatBlurGlow;
				}
			}

			private Material fxMatBlurOutline
			{
				get
				{
					if (_fxMatBlurOutline == null && fxMatBlurOutlineRef != null)
					{
						_fxMatBlurOutline = UnityEngine.Object.Instantiate(fxMatBlurOutlineRef);
					}
					return _fxMatBlurOutline;
				}
			}

			public event OnObjectHighlightEvent OnObjectHighlightStart;

			public event OnObjectHighlightEvent OnObjectHighlightEnd;

			public event OnRendererHighlightEvent OnRendererHighlightStart;

			public event OnTargetAnimatesEvent OnTargetAnimates;

			private void OnEnable()
			{
				lastOutlineVisibility = outlineVisibility;
				debugColor = new Color(1f, 0f, 0f, 0.5f);
				blackColor = new Color(0f, 0f, 0f, 0f);
				if (offsets == null || offsets.Length != 8)
				{
					offsets = new Vector4[8]
					{
						new Vector4(0f, 1f),
						new Vector4(1f, 0f),
						new Vector4(0f, -1f),
						new Vector4(-1f, 0f),
						new Vector4(-0.70711f, 0.70711f),
						new Vector4(0.70711f, 0.70711f),
						new Vector4(0.70711f, -0.70711f),
						new Vector4(-0.70711f, -0.70711f)
					};
				}
				if (corners == null || corners.Length != 8)
				{
					corners = new Vector3[8];
				}
				if (quadMesh == null)
				{
					BuildQuad();
				}
				if (cubeMesh == null)
				{
					BuildCube();
				}
				if (target == null)
				{
					target = base.transform;
				}
				if (profileSync && profile != null)
				{
					profile.Load(this);
				}
				if (glowPasses == null || glowPasses.Length == 0)
				{
					glowPasses = new GlowPassData[4];
					glowPasses[0] = new GlowPassData
					{
						offset = 4f,
						alpha = 0.1f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
					glowPasses[1] = new GlowPassData
					{
						offset = 3f,
						alpha = 0.2f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
					glowPasses[2] = new GlowPassData
					{
						offset = 2f,
						alpha = 0.3f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
					glowPasses[3] = new GlowPassData
					{
						offset = 1f,
						alpha = 0.4f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
				}
				sourceRT = Shader.PropertyToID("_HPSourceRT");
				useGPUInstancing = GPUInstancing && SystemInfo.supportsInstancing;
				if (useGPUInstancing)
				{
					if (glowPropertyBlock == null)
					{
						glowPropertyBlock = new MaterialPropertyBlock();
					}
					if (outlinePropertyBlock == null)
					{
						outlinePropertyBlock = new MaterialPropertyBlock();
					}
				}
				CheckGeometrySupportDependencies();
				SetupMaterial();
				if (!effects.Contains(this))
				{
					effects.Add(this);
				}
			}

			private void OnDisable()
			{
				UpdateMaterialPropertiesNow();
			}

			private void Reset()
			{
				SetupMaterial();
			}

			private void DestroyMaterial(Material mat)
			{
				if (mat != null)
				{
					UnityEngine.Object.DestroyImmediate(mat);
				}
			}

			private void DestroyMaterialArray(Material[] mm)
			{
				if (mm != null)
				{
					for (int i = 0; i < mm.Length; i++)
					{
						DestroyMaterial(mm[i]);
					}
				}
			}

			private void OnDestroy()
			{
				if (rms != null)
				{
					for (int i = 0; i < rms.Length; i++)
					{
						DestroyMaterialArray(rms[i].fxMatMask);
						DestroyMaterialArray(rms[i].fxMatSolidColor);
						DestroyMaterialArray(rms[i].fxMatSeeThroughInner);
						DestroyMaterialArray(rms[i].fxMatSeeThroughBorder);
						DestroyMaterialArray(rms[i].fxMatOverlay);
						DestroyMaterialArray(rms[i].fxMatInnerGlow);
					}
				}
				DestroyMaterial(fxMatGlow);
				DestroyMaterial(fxMatOutline);
				DestroyMaterial(fxMatTarget);
				DestroyMaterial(fxMatComposeGlow);
				DestroyMaterial(fxMatComposeOutline);
				DestroyMaterial(fxMatBlurGlow);
				DestroyMaterial(fxMatBlurOutline);
				if (effects.Contains(this))
				{
					effects.Remove(this);
				}
				if (combinedMeshes.ContainsKey(combinedMeshesHashId))
				{
					combinedMeshes.Remove(combinedMeshesHashId);
				}
			}

			public static void DrawEffectsNow(Camera cam = null)
			{
				if (cam == null)
				{
					cam = Camera.current;
					if (cam == null)
					{
						return;
					}
				}
				int count = effects.Count;
				int frameCount = Time.frameCount;
				for (int i = 0; i < count; i++)
				{
					HighlightEffect highlightEffect = effects[i];
					if (highlightEffect != null)
					{
						highlightEffect.DoOnRenderObject(cam);
						highlightEffect.skipThisFrame = frameCount;
					}
				}
			}

			private void OnRenderObject()
			{
				if (!usingPipeline)
				{
					DoOnRenderObject(Camera.current);
				}
			}

			public void ProfileLoad(HighlightProfile profile)
			{
				if (profile != null)
				{
					this.profile = profile;
					profile.Load(this);
				}
			}

			public void ProfileReload()
			{
				if (profile != null)
				{
					profile.Load(this);
				}
			}

			public void ProfileSaveChanges(HighlightProfile profile)
			{
				if (profile != null)
				{
					profile.Save(this);
				}
			}

			public void ProfileSaveChanges()
			{
				if (profile != null)
				{
					profile.Save(this);
				}
			}

			public void Refresh()
			{
				if (base.enabled)
				{
					SetupMaterial();
				}
			}

			private void DoOnRenderObject(Camera cam)
			{
				if (customSorting)
				{
					int frameCount = Time.frameCount;
					if (customSortingFrame != frameCount || customSortingCamera != cam)
					{
						customSortingFrame = frameCount;
						customSortingCamera = cam;
						int count = effects.Count;
						for (int i = 0; i < count; i++)
						{
							HighlightEffect highlightEffect = effects[i];
							highlightEffect.skipThisFrame = -1;
							highlightEffect.RenderEffect(cam);
							highlightEffect.skipThisFrame = frameCount;
						}
					}
				}
				else
				{
					RenderEffect(cam);
				}
			}

			private void RenderEffect(Camera cam)
			{
				if (cam == null || ((1 << cam.gameObject.layer) & (int)camerasLayerMask) == 0 || (!reflectionProbes && cam.cameraType == CameraType.Reflection))
				{
					return;
				}
				if (requireUpdateMaterial)
				{
					requireUpdateMaterial = false;
					UpdateMaterialPropertiesNow();
				}
				bool flag = seeThroughIntensity > 0f && (seeThrough == SeeThroughMode.AlwaysWhenOccluded || (seeThrough == SeeThroughMode.WhenHighlighted && _highlighted));
				if (flag)
				{
					flag = RenderSeeThroughOccluders(cam);
					if (flag && (int)seeThroughOccluderMask != -1)
					{
						if (seeThroughOccluderMaskAccurate)
						{
							CheckOcclusionAccurate(cam);
						}
						else
						{
							flag = CheckOcclusion(cam);
						}
					}
				}
				if ((!_highlighted && !flag && !hitActive) || skipThisFrame == Time.frameCount || rms == null)
				{
					return;
				}
				int cullingMask = cam.cullingMask;
				if (!ignoreObjectVisibility)
				{
					for (int i = 0; i < rmsCount; i++)
					{
						if (rms[i].renderer != null && rms[i].renderer.isVisible != rms[i].renderWasVisibleDuringSetup)
						{
							SetupMaterial();
							break;
						}
					}
				}
				if (fxMatMask == null)
				{
					return;
				}
				float num = (_highlighted ? glow : 0f);
				bool flag2 = glow > 0f && glowQuality == QualityLevel.Highest;
				bool flag3 = outline > 0f && outlineQuality == QualityLevel.Highest;
				bool flag4 = flag2 || flag3;
				if (flag4 && flag2 && flag3)
				{
					outlineVisibility = glowVisibility;
				}
				Visibility visibility = glowVisibility;
				Visibility visibility2 = outlineVisibility;
				if (flag4)
				{
					if (depthClip)
					{
						cam.depthTextureMode |= DepthTextureMode.Depth;
					}
					if (Application.isMobilePlatform || (cam.allowMSAA && QualitySettings.antiAliasing > 1))
					{
						visibility = (visibility2 = Visibility.AlwaysOnTop);
					}
					else if (XRSettings.enabled && Application.isPlaying)
					{
						visibility = (visibility2 = Visibility.AlwaysOnTop);
					}
				}
				float aspect = cam.aspect;
				bool flag5 = true;
				bool flag6 = false;
				bool flag7 = _highlighted && ((outline > 0f && visibility2 != 0) || (glow > 0f && visibility != 0) || (innerGlow > 0f && innerGlowVisibility != Visibility.Normal));
				for (int j = 0; j < rmsCount; j++)
				{
					rms[j].render = false;
					Transform transform = rms[j].transform;
					if (transform == null)
					{
						continue;
					}
					int layer = transform.gameObject.layer;
					if (((1 << layer) & cullingMask) == 0)
					{
						continue;
					}
					Mesh mesh = rms[j].mesh;
					if (mesh == null || (!rms[j].renderer.isVisible && !ignoreObjectVisibility))
					{
						continue;
					}
					rms[j].render = true;
					flag6 = true;
					if (rms[j].isCombined)
					{
						rms[j].renderingMatrix = transform.localToWorldMatrix;
					}
					else if (!rms[j].preserveOriginalMesh)
					{
						Vector3 lossyScale = transform.lossyScale;
						Vector3 position = transform.position;
						if (rms[j].bakedTransform)
						{
							if (rms[j].currentPosition != transform.position || rms[j].currentRotation != transform.eulerAngles || rms[j].currentScale != transform.lossyScale)
							{
								BakeTransform(j, duplicateMesh: true);
							}
							rms[j].renderingMatrix = matrix4X4Identity;
						}
						else
						{
							rms[j].renderingMatrix = Matrix4x4.TRS(position, transform.rotation, lossyScale);
						}
					}
					if (outlineIndependent)
					{
						if (flag4)
						{
							if (flag5)
							{
								flag5 = false;
								fxMatClearStencil.SetPass(0);
								if (subMeshMask > 0)
								{
									for (int k = 0; k < mesh.subMeshCount; k++)
									{
										if (((1 << k) & subMeshMask) != 0)
										{
											Graphics.DrawMeshNow(quadMesh, matrix4X4Identity, k);
										}
									}
								}
								else
								{
									Graphics.DrawMeshNow(quadMesh, matrix4X4Identity);
								}
							}
						}
						else if (outline > 0f || glow > 0f)
						{
							float num2 = outlineWidth;
							if (glow > 0f)
							{
								num2 = Mathf.Max(num2, glowWidth);
							}
							Material material = fxMatOutline;
							bool flag8 = normalsOption != NormalsOption.Planar && outlineQuality.UsesMultipleOffsets();
							for (int l = 0; l < mesh.subMeshCount; l++)
							{
								if (((1 << l) & subMeshMask) == 0)
								{
									continue;
								}
								if (flag8)
								{
									for (int m = outlineOffsetsMin; m <= outlineOffsetsMax; m++)
									{
										Vector3 vector = offsets[m] * (num2 / 100f);
										vector.y *= aspect;
										material.SetVector(ShaderParams.OutlineDirection, vector);
										if (rms[j].preserveOriginalMesh)
										{
											cbOutline.Clear();
											cbOutline.DrawRenderer(rms[j].renderer, material, l, 1);
											Graphics.ExecuteCommandBuffer(cbOutline);
										}
										else
										{
											material.SetPass(1);
											Graphics.DrawMeshNow(mesh, rms[j].renderingMatrix, l);
										}
									}
								}
								else if (rms[j].preserveOriginalMesh)
								{
									cbOutline.Clear();
									cbOutline.DrawRenderer(rms[j].renderer, material, l, 1);
									Graphics.ExecuteCommandBuffer(cbOutline);
								}
								else
								{
									material.SetPass(1);
									Graphics.DrawMeshNow(mesh, rms[j].renderingMatrix, l);
								}
							}
						}
					}
					if (maskRequired)
					{
						RenderMask(j, mesh, flag7);
					}
				}
				if (!flag6)
				{
					return;
				}
				float num3 = 1f;
				if (fading != 0)
				{
					if (fading == FadingState.FadingIn)
					{
						if (fadeInDuration > 0f)
						{
							num3 = (Time.time - fadeStartTime) / fadeInDuration;
							if (num3 > 1f)
							{
								num3 = 1f;
								fading = FadingState.NoFading;
							}
						}
					}
					else if (fadeOutDuration > 0f)
					{
						num3 = 1f - (Time.time - fadeStartTime) / fadeOutDuration;
						if (num3 < 0f)
						{
							num3 = 0f;
							fading = FadingState.NoFading;
							_highlighted = false;
							if (this.OnObjectHighlightEnd != null)
							{
								this.OnObjectHighlightEnd(base.gameObject);
							}
							SendMessage("HighlightEnd", null, SendMessageOptions.DontRequireReceiver);
						}
					}
				}
				if (glowQuality == QualityLevel.High)
				{
					num *= 0.25f;
				}
				else if (glowQuality == QualityLevel.Medium)
				{
					num *= 0.5f;
				}
				int num4 = 0;
				int num5 = 0;
				Bounds bounds = default(Bounds);
				if (flag4)
				{
					if (cbSmoothBlend == null)
					{
						CheckBlurCommandBuffer();
					}
					cbSmoothBlend.Clear();
					num4 = cam.pixelWidth;
					num5 = cam.pixelHeight;
					if (num5 <= 0)
					{
						num5 = 1;
					}
					if (XRSettings.enabled && Application.isPlaying)
					{
						sourceDesc = XRSettings.eyeTextureDesc;
					}
					else
					{
						sourceDesc = new RenderTextureDescriptor(num4, num5, Application.isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
						sourceDesc.volumeDepth = 1;
					}
					sourceDesc.msaaSamples = 1;
					sourceDesc.useMipMap = false;
					sourceDesc.depthBufferBits = 0;
					cbSmoothBlend.GetTemporaryRT(sourceRT, sourceDesc, FilterMode.Bilinear);
					RenderTargetIdentifier renderTargetIdentifier = new RenderTargetIdentifier(sourceRT, 0, CubemapFace.Unknown, -1);
					if ((glow > 0f && visibility == Visibility.AlwaysOnTop) || (outline > 0f && visibility2 == Visibility.AlwaysOnTop))
					{
						if (Application.isMobilePlatform)
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier);
						}
						else
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier, RenderBufferLoadAction.Load, RenderBufferStoreAction.DontCare);
						}
					}
					else
					{
						RenderTargetIdentifier depth = new RenderTargetIdentifier(BuiltinRenderTextureType.CameraTarget, 0, CubemapFace.Unknown, -1);
						if (Application.isMobilePlatform)
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.DontCare, depth, RenderBufferLoadAction.Load, RenderBufferStoreAction.DontCare);
						}
						else
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier, depth);
						}
					}
					cbSmoothBlend.ClearRenderTarget(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
				}
				bool flag9 = false;
				cbSeeThrough.Clear();
				if (flag && flag7)
				{
					for (int n = 0; n < rmsCount; n++)
					{
						if (rms[n].render)
						{
							Mesh mesh2 = rms[n].mesh;
							RenderSeeThroughClearStencil(n, mesh2);
						}
					}
					for (int num6 = 0; num6 < rmsCount; num6++)
					{
						if (rms[num6].render)
						{
							Mesh mesh3 = rms[num6].mesh;
							RenderSeeThroughMask(num6, mesh3);
						}
					}
				}
				for (int num7 = 0; num7 < rmsCount; num7++)
				{
					if (!rms[num7].render)
					{
						continue;
					}
					Mesh mesh4 = rms[num7].mesh;
					if (flag)
					{
						if (seeThroughDepthOffset > 0f)
						{
							cam.depthTextureMode |= DepthTextureMode.Depth;
						}
						bool flag10 = seeThroughBorder * seeThroughBorderWidth > 0f;
						if (rms[num7].preserveOriginalMesh)
						{
							for (int num8 = 0; num8 < mesh4.subMeshCount; num8++)
							{
								if (((1 << num8) & subMeshMask) != 0 && num8 < rms[num7].fxMatSeeThroughInner.Length && rms[num7].fxMatSeeThroughInner[num8] != null)
								{
									cbSeeThrough.DrawRenderer(rms[num7].renderer, rms[num7].fxMatSeeThroughInner[num8], num8);
									if (flag10)
									{
										cbSeeThrough.DrawRenderer(rms[num7].renderer, rms[num7].fxMatSeeThroughBorder[num8], num8);
									}
								}
							}
						}
						else
						{
							for (int num9 = 0; num9 < mesh4.subMeshCount; num9++)
							{
								if (((1 << num9) & subMeshMask) != 0 && num9 < rms[num7].fxMatSeeThroughInner.Length && rms[num7].fxMatSeeThroughInner[num9] != null)
								{
									cbSeeThrough.DrawMesh(mesh4, rms[num7].renderingMatrix, rms[num7].fxMatSeeThroughInner[num9], num9);
									if (flag10)
									{
										cbSeeThrough.DrawMesh(mesh4, rms[num7].renderingMatrix, rms[num7].fxMatSeeThroughBorder[num9], num9);
									}
								}
							}
						}
					}
					if (_highlighted || hitActive)
					{
						Color color = overlayColor;
						float y = overlayMinIntensity;
						float z = overlayBlending;
						Color value = innerGlowColor;
						float num10 = innerGlow;
						if (hitActive)
						{
							color.a = (_highlighted ? overlay : 0f);
							value.a = (_highlighted ? num10 : 0f);
							float num11 = ((hitFadeOutDuration > 0f) ? ((Time.time - hitStartTime) / hitFadeOutDuration) : 1f);
							if (num11 >= 1f)
							{
								hitActive = false;
							}
							else if (hitFxMode == HitFxMode.InnerGlow)
							{
								bool flag11 = _highlighted && num10 > 0f;
								value = (flag11 ? Color.Lerp(hitColor, innerGlowColor, num11) : hitColor);
								value.a = (flag11 ? Mathf.Lerp(1f - num11, num10, num11) : (1f - num11));
								value.a *= hitInitialIntensity;
							}
							else
							{
								bool flag12 = _highlighted && overlay > 0f;
								color = (flag12 ? Color.Lerp(hitColor, color, num11) : hitColor);
								color.a = (flag12 ? Mathf.Lerp(1f - num11, overlay, num11) : (1f - num11));
								color.a *= hitInitialIntensity;
								y = 1f;
								z = 0f;
							}
						}
						else
						{
							color.a = overlay * num3;
							value.a = num10 * num3;
						}
						for (int num12 = 0; num12 < mesh4.subMeshCount; num12++)
						{
							if (((1 << num12) & subMeshMask) == 0)
							{
								continue;
							}
							if (color.a > 0f)
							{
								Material material2 = rms[num7].fxMatOverlay[num12];
								material2.SetColor(ShaderParams.OverlayColor, color);
								material2.SetVector(ShaderParams.OverlayData, new Vector4(overlayAnimationSpeed, y, z, overlayTextureScale));
								if (hitActive && hitFxMode == HitFxMode.LocalHit)
								{
									material2.SetVector(ShaderParams.OverlayHitPosData, new Vector4(hitPosition.x, hitPosition.y, hitPosition.z, hitRadius));
									material2.SetFloat(ShaderParams.OverlayHitStartTime, hitStartTime);
								}
								else
								{
									material2.SetVector(ShaderParams.OverlayHitPosData, Vector4.zero);
								}
								if (rms[num7].preserveOriginalMesh)
								{
									cbOverlay.Clear();
									cbOverlay.DrawRenderer(rms[num7].renderer, material2, num12);
									Graphics.ExecuteCommandBuffer(cbOverlay);
								}
								else
								{
									material2.SetPass(0);
									Graphics.DrawMeshNow(mesh4, rms[num7].renderingMatrix, num12);
								}
							}
							if (value.a > 0f)
							{
								rms[num7].fxMatInnerGlow[num12].SetColor(ShaderParams.InnerGlowColor, value);
								if (rms[num7].preserveOriginalMesh)
								{
									cbInnerGlow.Clear();
									cbInnerGlow.DrawRenderer(rms[num7].renderer, rms[num7].fxMatInnerGlow[num12], num12);
									Graphics.ExecuteCommandBuffer(cbInnerGlow);
								}
								else
								{
									rms[num7].fxMatInnerGlow[num12].SetPass(0);
									Graphics.DrawMeshNow(mesh4, rms[num7].renderingMatrix, num12);
								}
							}
						}
					}
					if (!_highlighted)
					{
						continue;
					}
					if (flag4)
					{
						if (num7 == 0)
						{
							bounds = rms[num7].renderer.bounds;
						}
						else
						{
							bounds.Encapsulate(rms[num7].renderer.bounds);
						}
					}
					for (int num13 = 0; num13 < mesh4.subMeshCount; num13++)
					{
						if (((1 << num13) & subMeshMask) == 0)
						{
							continue;
						}
						if (flag4 && num13 < rms[num7].fxMatSolidColor.Length)
						{
							if (rms[num7].preserveOriginalMesh)
							{
								cbSmoothBlend.DrawRenderer(rms[num7].renderer, rms[num7].fxMatSolidColor[num13], num13);
							}
							else
							{
								cbSmoothBlend.DrawMesh(mesh4, rms[num7].renderingMatrix, rms[num7].fxMatSolidColor[num13], num13);
							}
						}
						if (glow > 0f && glowQuality != QualityLevel.Highest)
						{
							matDataGlow.Clear();
							matDataColor.Clear();
							matDataDirection.Clear();
							Material material3 = fxMatGlow;
							Vector4 vector2 = ((normalsOption == NormalsOption.Planar) ? new Vector4(0f, 0f, glowWidth / 100f, 0f) : Vector4.zero);
							material3.SetVector(ShaderParams.GlowDirection, vector2);
							for (int num14 = 0; num14 < glowPasses.Length; num14++)
							{
								Color color2 = glowPasses[num14].color;
								material3.SetColor(ShaderParams.GlowColor, color2);
								Vector4 vector3 = new Vector4(num3 * num * glowPasses[num14].alpha, (normalsOption == NormalsOption.Planar) ? 0f : (glowPasses[num14].offset * glowWidth / 100f), glowMagicNumber1, glowMagicNumber2);
								material3.SetVector(ShaderParams.Glow, vector3);
								if (normalsOption != NormalsOption.Planar && glowQuality.UsesMultipleOffsets())
								{
									for (int num15 = glowOffsetsMin; num15 <= glowOffsetsMax; num15++)
									{
										Vector4 vector4 = offsets[num15];
										vector4.y *= aspect;
										material3.SetVector(ShaderParams.GlowDirection, vector4);
										if (rms[num7].preserveOriginalMesh)
										{
											cbGlow.Clear();
											cbGlow.DrawRenderer(rms[num7].renderer, material3, num13);
											Graphics.ExecuteCommandBuffer(cbGlow);
										}
										else if (useGPUInstancing)
										{
											matDataDirection.Add(vector4);
											matDataGlow.Add(vector3);
											matDataColor.Add(new Vector4(color2.r, color2.g, color2.b, color2.a));
										}
										else
										{
											material3.SetPass(0);
											Graphics.DrawMeshNow(mesh4, rms[num7].renderingMatrix, num13);
										}
									}
								}
								else if (rms[num7].preserveOriginalMesh)
								{
									cbGlow.Clear();
									cbGlow.DrawRenderer(rms[num7].renderer, material3, num13);
									Graphics.ExecuteCommandBuffer(cbGlow);
								}
								else if (useGPUInstancing)
								{
									matDataDirection.Add(vector2);
									matDataGlow.Add(vector3);
									matDataColor.Add(new Vector4(color2.r, color2.g, color2.b, color2.a));
								}
								else
								{
									material3.SetPass(0);
									Graphics.DrawMeshNow(mesh4, rms[num7].renderingMatrix, num13);
								}
							}
							if (useGPUInstancing)
							{
								int count = matDataDirection.Count;
								if (count > 0)
								{
									glowPropertyBlock.Clear();
									glowPropertyBlock.SetVectorArray(ShaderParams.GlowDirection, matDataDirection);
									glowPropertyBlock.SetVectorArray(ShaderParams.GlowColor, matDataColor);
									glowPropertyBlock.SetVectorArray(ShaderParams.Glow, matDataGlow);
									if (matrices == null || matrices.Length < count)
									{
										matrices = new Matrix4x4[count];
									}
									for (int num16 = 0; num16 < count; num16++)
									{
										matrices[num16] = rms[num7].renderingMatrix;
									}
									cbGlow.Clear();
									cbGlow.DrawMeshInstanced(mesh4, num13, material3, 0, matrices, count, glowPropertyBlock);
									Graphics.ExecuteCommandBuffer(cbGlow);
								}
							}
						}
						if (!(outline > 0f) || outlineQuality == QualityLevel.Highest)
						{
							continue;
						}
						Color value2 = outlineColor;
						value2.a = outline * num3;
						Material material4 = fxMatOutline;
						material4.SetColor(ShaderParams.OutlineColor, value2);
						if (normalsOption != NormalsOption.Planar && outlineQuality.UsesMultipleOffsets())
						{
							matDataDirection.Clear();
							for (int num17 = outlineOffsetsMin; num17 <= outlineOffsetsMax; num17++)
							{
								Vector4 vector5 = offsets[num17] * (outlineWidth / 100f);
								vector5.y *= aspect;
								material4.SetVector(ShaderParams.OutlineDirection, vector5);
								if (rms[num7].preserveOriginalMesh)
								{
									cbOutline.Clear();
									cbOutline.DrawRenderer(rms[num7].renderer, material4, num13, 0);
									Graphics.ExecuteCommandBuffer(cbOutline);
								}
								else if (useGPUInstancing)
								{
									matDataDirection.Add(vector5);
								}
								else
								{
									material4.SetPass(0);
									Graphics.DrawMeshNow(mesh4, rms[num7].renderingMatrix, num13);
								}
							}
							if (!useGPUInstancing)
							{
								continue;
							}
							int count2 = matDataDirection.Count;
							if (count2 > 0)
							{
								outlinePropertyBlock.Clear();
								outlinePropertyBlock.SetVectorArray(ShaderParams.OutlineDirection, matDataDirection);
								if (matrices == null || matrices.Length < count2)
								{
									matrices = new Matrix4x4[count2];
								}
								for (int num18 = 0; num18 < count2; num18++)
								{
									matrices[num18] = rms[num7].renderingMatrix;
								}
								cbGlow.Clear();
								cbGlow.DrawMeshInstanced(mesh4, num13, material4, 0, matrices, count2, outlinePropertyBlock);
								Graphics.ExecuteCommandBuffer(cbGlow);
							}
						}
						else if (rms[num7].preserveOriginalMesh)
						{
							cbOutline.Clear();
							cbOutline.DrawRenderer(rms[num7].renderer, material4, num13, 0);
							Graphics.ExecuteCommandBuffer(cbOutline);
						}
						else
						{
							material4.SetPass(0);
							Graphics.DrawMeshNow(mesh4, rms[num7].renderingMatrix, num13);
						}
					}
					if (!targetFX)
					{
						continue;
					}
					float num19 = 1f;
					if (targetFXStayDuration > 0f && Application.isPlaying)
					{
						num19 = Time.time - targetFxStartTime;
						if (num19 >= targetFXStayDuration)
						{
							num19 -= targetFXStayDuration;
							num19 = 1f - num19;
						}
						if (num19 > 1f)
						{
							num19 = 1f;
						}
					}
					bool flag13 = targetFXCenter != null;
					if (!(num19 > 0f) || (flag9 && flag13))
					{
						continue;
					}
					flag9 = true;
					float t = 1f;
					float num20 = 0f;
					float num21;
					if (Application.isPlaying)
					{
						num20 = (Time.time - targetFxStartTime) / targetFXTransitionDuration;
						if (num20 > 1f)
						{
							num20 = 1f;
						}
						t = Mathf.Sin(num20 * (float)Math.PI * 0.5f);
						num21 = Time.time;
					}
					else
					{
						num21 = (float)DateTime.Now.Subtract(DateTime.Today).TotalSeconds;
					}
					Bounds bounds2 = rms[num7].renderer.bounds;
					if (!targetFXScaleToRenderBounds)
					{
						bounds2.size = Vector3.one;
					}
					Vector3 size = bounds2.size;
					float num22 = size.x;
					if (size.y < num22)
					{
						num22 = size.y;
					}
					if (size.z < num22)
					{
						num22 = size.z;
					}
					size.x = (size.y = (size.z = num22));
					size = Vector3.Lerp(size * targetFXInitialScale, size * targetFXEndScale, t);
					Vector3 center = (flag13 ? targetFXCenter.transform.position : bounds2.center);
					if (targetFXAlignToGround)
					{
						Quaternion quaternion = Quaternion.Euler(90f, 0f, 0f);
						center.y += 0.5f;
						if (Physics.Raycast(center, Vector3.down, out var hitInfo, targetFXGroundMaxDistance, targetFXGroundLayerMask))
						{
							center = hitInfo.point;
							center.y += 0.01f;
							Vector4 value3 = hitInfo.normal;
							value3.w = targetFXFadePower;
							fxMatTarget.SetVector(ShaderParams.TargetFXRenderData, value3);
							quaternion = Quaternion.Euler(0f, num21 * targetFXRotationSpeed, 0f);
							if (this.OnTargetAnimates != null)
							{
								this.OnTargetAnimates(ref center, ref quaternion, ref size, num20);
							}
							Matrix4x4 matrix = Matrix4x4.TRS(center, quaternion, size);
							Color color3 = targetFXColor;
							color3.a *= num3 * num19;
							Material material5 = fxMatTarget;
							material5.color = color3;
							material5.SetPass(0);
							Graphics.DrawMeshNow(cubeMesh, matrix);
						}
					}
					else
					{
						Quaternion quaternion = Quaternion.LookRotation(cam.transform.position - rms[num7].transform.position);
						Quaternion quaternion2 = Quaternion.Euler(0f, 0f, num21 * targetFXRotationSpeed);
						quaternion *= quaternion2;
						if (this.OnTargetAnimates != null)
						{
							this.OnTargetAnimates(ref center, ref quaternion, ref size, num20);
						}
						Matrix4x4 matrix2 = Matrix4x4.TRS(center, quaternion, size);
						Color color4 = targetFXColor;
						color4.a *= num3 * num19;
						Material material6 = fxMatTarget;
						material6.color = color4;
						material6.SetPass(1);
						Graphics.DrawMeshNow(quadMesh, matrix2);
					}
				}
				if (flag4 && ComputeSmoothQuadMatrix(cam, bounds))
				{
					if (flag2)
					{
						float num23 = glow * num3;
						fxMatComposeGlow.color = new Color(glowHQColor.r * num23, glowHQColor.g * num23, glowHQColor.b * num23, glowHQColor.a * num23);
						SmoothGlow(num4 / glowDownsampling, num5 / glowDownsampling);
					}
					if (flag3)
					{
						fxMatComposeOutline.color = new Color(outlineColor.r, outlineColor.g, outlineColor.b, 5f * outlineColor.a * outline * num3);
						SmoothOutline(num4 / outlineDownsampling, num5 / outlineDownsampling);
					}
					ComposeSmoothBlend(visibility, visibility2);
				}
				if (flag && seeThroughOrdered)
				{
					for (int num24 = 0; num24 < rmsCount; num24++)
					{
						if (!rms[num24].render)
						{
							continue;
						}
						Mesh mesh5 = rms[num24].mesh;
						for (int num25 = 0; num25 < mesh5.subMeshCount; num25++)
						{
							if (((1 << num25) & subMeshMask) != 0)
							{
								if (rms[num24].isCombined)
								{
									cbSeeThrough.DrawMesh(mesh5, rms[num24].renderingMatrix, fxMatClearStencil, num25, 1);
								}
								else
								{
									cbSeeThrough.DrawRenderer(rms[num24].renderer, fxMatClearStencil, num25, 1);
								}
							}
						}
					}
				}
				Graphics.ExecuteCommandBuffer(cbSeeThrough);
			}

			private void RenderMask(int k, Mesh mesh, bool alwaysOnTop)
			{
				if (rms[k].preserveOriginalMesh)
				{
					cbMask.Clear();
					for (int i = 0; i < mesh.subMeshCount; i++)
					{
						if (((1 << i) & subMeshMask) != 0)
						{
							if (alwaysOnTop)
							{
								rms[k].fxMatMask[i].SetInt(ShaderParams.ZTest, 8);
							}
							else
							{
								rms[k].fxMatMask[i].SetInt(ShaderParams.ZTest, 4);
							}
							cbMask.DrawRenderer(rms[k].renderer, rms[k].fxMatMask[i], i, 0);
						}
					}
					Graphics.ExecuteCommandBuffer(cbMask);
					return;
				}
				for (int j = 0; j < mesh.subMeshCount; j++)
				{
					if (((1 << j) & subMeshMask) != 0)
					{
						if (alwaysOnTop)
						{
							rms[k].fxMatMask[j].SetInt(ShaderParams.ZTest, 8);
						}
						else
						{
							rms[k].fxMatMask[j].SetInt(ShaderParams.ZTest, 4);
						}
						rms[k].fxMatMask[j].SetPass(0);
						Graphics.DrawMeshNow(mesh, rms[k].renderingMatrix, j);
					}
				}
			}

			private void RenderSeeThroughClearStencil(int k, Mesh mesh)
			{
				if (rms[k].preserveOriginalMesh)
				{
					for (int i = 0; i < mesh.subMeshCount; i++)
					{
						if (((1 << i) & subMeshMask) != 0)
						{
							cbSeeThrough.DrawRenderer(rms[k].renderer, fxMatClearStencil, i, 1);
						}
					}
					return;
				}
				for (int j = 0; j < mesh.subMeshCount; j++)
				{
					if (((1 << j) & subMeshMask) != 0)
					{
						cbSeeThrough.DrawMesh(mesh, rms[k].renderingMatrix, fxMatClearStencil, j, 1);
					}
				}
			}

			private void RenderSeeThroughMask(int k, Mesh mesh)
			{
				if (rms[k].preserveOriginalMesh)
				{
					for (int i = 0; i < mesh.subMeshCount; i++)
					{
						if (((1 << i) & subMeshMask) != 0)
						{
							cbSeeThrough.DrawRenderer(rms[k].renderer, rms[k].fxMatMask[i], i, 1);
						}
					}
					return;
				}
				for (int j = 0; j < mesh.subMeshCount; j++)
				{
					if (((1 << j) & subMeshMask) != 0)
					{
						cbSeeThrough.DrawMesh(mesh, rms[k].renderingMatrix, rms[k].fxMatMask[j], j, 1);
					}
				}
			}

			private bool ComputeSmoothQuadMatrix(Camera cam, Bounds bounds)
			{
				Vector3 min = bounds.min;
				Vector3 max = bounds.max;
				corners[0] = new Vector3(min.x, min.y, min.z);
				corners[1] = new Vector3(min.x, min.y, max.z);
				corners[2] = new Vector3(max.x, min.y, min.z);
				corners[3] = new Vector3(max.x, min.y, max.z);
				corners[4] = new Vector3(min.x, max.y, min.z);
				corners[5] = new Vector3(min.x, max.y, max.z);
				corners[6] = new Vector3(max.x, max.y, min.z);
				corners[7] = new Vector3(max.x, max.y, max.z);
				Vector3 scrMin = new Vector3(float.MaxValue, float.MaxValue, 0f);
				Vector3 scrMax = new Vector3(float.MinValue, float.MinValue, 0f);
				float num = float.MaxValue;
				for (int i = 0; i < corners.Length; i++)
				{
					corners[i] = cam.WorldToScreenPoint(corners[i]);
					if (corners[i].x < scrMin.x)
					{
						scrMin.x = corners[i].x;
					}
					if (corners[i].y < scrMin.y)
					{
						scrMin.y = corners[i].y;
					}
					if (corners[i].x > scrMax.x)
					{
						scrMax.x = corners[i].x;
					}
					if (corners[i].y > scrMax.y)
					{
						scrMax.y = corners[i].y;
					}
					if (corners[i].z < num)
					{
						num = corners[i].z;
						if (num < cam.nearClipPlane)
						{
							scrMin.x = (scrMin.y = 0f);
							scrMax.x = cam.pixelWidth;
							scrMax.y = cam.pixelHeight;
							break;
						}
					}
				}
				if (scrMax.y == scrMin.y)
				{
					return false;
				}
				if (num < cam.nearClipPlane)
				{
					num = cam.nearClipPlane + 0.01f;
				}
				scrMin.z = (scrMax.z = num);
				if (outline > 0f)
				{
					BuildMatrix(cam, scrMin, scrMax, (int)(10f + 20f * outlineWidth + (float)(5 * outlineDownsampling)), ref quadOutlineMatrix);
				}
				if (glow > 0f)
				{
					BuildMatrix(cam, scrMin, scrMax, (int)(20f + 30f * glowWidth + (float)(10 * glowDownsampling)), ref quadGlowMatrix);
				}
				return true;
			}

			private void BuildMatrix(Camera cam, Vector3 scrMin, Vector3 scrMax, int border, ref Matrix4x4 quadMatrix)
			{
				scrMin.x -= border;
				scrMin.y -= border;
				scrMax.x += border;
				scrMax.y += border;
				Vector3 position = new Vector3(scrMax.x, scrMin.y, scrMin.z);
				scrMin = cam.ScreenToWorldPoint(scrMin);
				scrMax = cam.ScreenToWorldPoint(scrMax);
				position = cam.ScreenToWorldPoint(position);
				float x = Vector3.Distance(scrMin, position);
				float y = Vector3.Distance(scrMax, position);
				quadMatrix = Matrix4x4.TRS((scrMin + scrMax) * 0.5f, cam.transform.rotation, new Vector3(x, y, 1f));
			}

			private void SmoothGlow(int rtWidth, int rtHeight)
			{
				int num = 8;
				if (mipGlowBuffers == null || mipGlowBuffers.Length != num)
				{
					mipGlowBuffers = new int[num];
					for (int i = 0; i < num; i++)
					{
						mipGlowBuffers[i] = Shader.PropertyToID("_HPSmoothGlowTemp" + i);
					}
					glowRT = Shader.PropertyToID("_HPComposeGlowFinal");
					mipGlowBuffers[num - 2] = glowRT;
				}
				RenderTextureDescriptor desc = sourceDesc;
				desc.depthBufferBits = 0;
				for (int j = 0; j < num; j++)
				{
					float num2 = j / 2 + 2;
					int num3 = (int)((float)rtWidth / num2);
					int num4 = (int)((float)rtHeight / num2);
					if (num3 <= 0)
					{
						num3 = 1;
					}
					if (num4 <= 0)
					{
						num4 = 1;
					}
					desc.width = num3;
					desc.height = num4;
					cbSmoothBlend.GetTemporaryRT(mipGlowBuffers[j], desc, FilterMode.Bilinear);
				}
				Material mat = fxMatBlurGlow;
				for (int k = 0; k < num - 1; k += 2)
				{
					if (k == 0)
					{
						cbSmoothBlend.Blit(sourceRT, mipGlowBuffers[k + 1], mat, 0);
					}
					else
					{
						cbSmoothBlend.Blit(mipGlowBuffers[k], mipGlowBuffers[k + 1], mat, 0);
					}
					cbSmoothBlend.Blit(mipGlowBuffers[k + 1], mipGlowBuffers[k], mat, 1);
					if (k < num - 2)
					{
						cbSmoothBlend.Blit(mipGlowBuffers[k], mipGlowBuffers[k + 2], mat, 2);
					}
				}
			}

			private void SmoothOutline(int rtWidth, int rtHeight)
			{
				int num = 4;
				if (mipOutlineBuffers == null || mipOutlineBuffers.Length != num)
				{
					mipOutlineBuffers = new int[num];
					for (int i = 0; i < num; i++)
					{
						mipOutlineBuffers[i] = Shader.PropertyToID("_HPSmoothOutlineTemp" + i);
					}
					outlineRT = Shader.PropertyToID("_HPComposeOutlineFinal");
					mipOutlineBuffers[num - 2] = outlineRT;
				}
				RenderTextureDescriptor desc = sourceDesc;
				desc.depthBufferBits = 0;
				for (int j = 0; j < num; j++)
				{
					float num2 = j / 2 + 2;
					int num3 = (int)((float)rtWidth / num2);
					int num4 = (int)((float)rtHeight / num2);
					if (num3 <= 0)
					{
						num3 = 1;
					}
					if (num4 <= 0)
					{
						num4 = 1;
					}
					desc.width = num3;
					desc.height = num4;
					cbSmoothBlend.GetTemporaryRT(mipOutlineBuffers[j], desc, FilterMode.Bilinear);
				}
				Material mat = fxMatBlurOutline;
				for (int k = 0; k < num - 1; k += 2)
				{
					if (k == 0)
					{
						cbSmoothBlend.Blit(sourceRT, mipOutlineBuffers[k + 1], mat, 0);
					}
					else
					{
						cbSmoothBlend.Blit(mipOutlineBuffers[k], mipOutlineBuffers[k + 1], mat, 0);
					}
					cbSmoothBlend.Blit(mipOutlineBuffers[k + 1], mipOutlineBuffers[k], mat, 1);
					if (k < num - 2)
					{
						cbSmoothBlend.Blit(mipOutlineBuffers[k], mipOutlineBuffers[k + 2], mat, 2);
					}
				}
			}

			private void ComposeSmoothBlend(Visibility smoothGlowVisibility, Visibility smoothOutlineVisibility)
			{
				bool num = glow > 0f && glowQuality == QualityLevel.Highest;
				RenderTargetIdentifier renderTargetIdentifier = new RenderTargetIdentifier(BuiltinRenderTextureType.CameraTarget, 0, CubemapFace.Unknown, -1);
				if (num)
				{
					Material material = fxMatComposeGlow;
					material.SetVector(ShaderParams.Flip, (XRSettings.enabled && flipY) ? new Vector3(1f, -1f, 0f) : new Vector3(0f, 1f, 0f));
					if (glowOptimalBlit)
					{
						if (Application.isMobilePlatform && smoothGlowVisibility != Visibility.AlwaysOnTop)
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier, RenderBufferLoadAction.Load, RenderBufferStoreAction.DontCare);
						}
						else
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier);
						}
						material.SetInt(ShaderParams.ZTest, GetZTestValue(smoothGlowVisibility));
						material.SetColor(ShaderParams.Debug, glowBlitDebug ? debugColor : blackColor);
						cbSmoothBlend.DrawMesh(quadMesh, quadGlowMatrix, material, 0, 0);
					}
					else
					{
						cbSmoothBlend.Blit(glowRT, renderTargetIdentifier, material, 1);
					}
				}
				bool flag = outline > 0f && outlineQuality == QualityLevel.Highest;
				if (flag)
				{
					Material material2 = fxMatComposeOutline;
					material2.SetVector(ShaderParams.Flip, (XRSettings.enabled && flipY) ? new Vector3(1f, -1f, 0f) : new Vector3(0f, 1f, 0f));
					if (outlineOptimalBlit)
					{
						if (Application.isMobilePlatform && smoothOutlineVisibility != Visibility.AlwaysOnTop)
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier, RenderBufferLoadAction.Load, RenderBufferStoreAction.DontCare);
						}
						else
						{
							cbSmoothBlend.SetRenderTarget(renderTargetIdentifier);
						}
						material2.SetInt(ShaderParams.ZTest, GetZTestValue(smoothOutlineVisibility));
						material2.SetColor(ShaderParams.Debug, outlineBlitDebug ? debugColor : blackColor);
						cbSmoothBlend.DrawMesh(quadMesh, quadOutlineMatrix, material2, 0, 0);
					}
					else
					{
						cbSmoothBlend.Blit(outlineRT, renderTargetIdentifier, material2, 1);
					}
				}
				if (num)
				{
					for (int i = 0; i < mipGlowBuffers.Length; i++)
					{
						cbSmoothBlend.ReleaseTemporaryRT(mipGlowBuffers[i]);
					}
				}
				if (flag)
				{
					for (int j = 0; j < mipOutlineBuffers.Length; j++)
					{
						cbSmoothBlend.ReleaseTemporaryRT(mipOutlineBuffers[j]);
					}
				}
				cbSmoothBlend.ReleaseTemporaryRT(sourceRT);
				Graphics.ExecuteCommandBuffer(cbSmoothBlend);
			}

			private void InitMaterial(ref Material material, string shaderName)
			{
				if (material == null)
				{
					Shader shader = Shader.Find(shaderName);
					if (shader == null)
					{
						UnityEngine.Debug.LogError("Shader " + shaderName + " not found.");
						base.enabled = false;
					}
					else
					{
						material = new Material(shader);
					}
				}
			}

			public void SetTarget(Transform transform)
			{
				if (!(transform == target) && !(transform == null))
				{
					if (_highlighted)
					{
						ImmediateFadeOut();
					}
					target = transform;
					SetupMaterial();
				}
			}

			public void SetTargets(Transform transform, Renderer[] renderers)
			{
				if (!(transform == null))
				{
					if (_highlighted)
					{
						ImmediateFadeOut();
					}
					effectGroup = TargetOptions.Scripting;
					target = transform;
					SetupMaterial(renderers);
				}
			}

			public void SetHighlighted(bool state)
			{
				if (!Application.isPlaying)
				{
					_highlighted = state;
					return;
				}
				float time = Time.time;
				if (fading == FadingState.NoFading)
				{
					fadeStartTime = time;
				}
				if (state && !ignore)
				{
					if ((_highlighted && fading == FadingState.NoFading) || (this.OnObjectHighlightStart != null && !this.OnObjectHighlightStart(base.gameObject)))
					{
						return;
					}
					SendMessage("HighlightStart", null, SendMessageOptions.DontRequireReceiver);
					highlightStartTime = (targetFxStartTime = time);
					if (fadeInDuration > 0f)
					{
						if (fading == FadingState.FadingOut)
						{
							float num = fadeOutDuration - (time - fadeStartTime);
							fadeStartTime = time - num;
							fadeStartTime = Mathf.Min(fadeStartTime, time);
						}
						fading = FadingState.FadingIn;
					}
					else
					{
						fading = FadingState.NoFading;
					}
					_highlighted = true;
					requireUpdateMaterial = true;
				}
				else
				{
					if (!_highlighted)
					{
						return;
					}
					if (fadeOutDuration > 0f)
					{
						if (fading == FadingState.FadingIn)
						{
							float num2 = time - fadeStartTime;
							fadeStartTime = time + num2 - fadeInDuration;
							fadeStartTime = Mathf.Min(fadeStartTime, time);
						}
						fading = FadingState.FadingOut;
					}
					else
					{
						fading = FadingState.NoFading;
						ImmediateFadeOut();
						requireUpdateMaterial = true;
					}
				}
			}

			private void ImmediateFadeOut()
			{
				fading = FadingState.NoFading;
				_highlighted = false;
				if (this.OnObjectHighlightEnd != null)
				{
					this.OnObjectHighlightEnd(base.gameObject);
				}
				SendMessage("HighlightEnd", null, SendMessageOptions.DontRequireReceiver);
			}

			private void SetupMaterial()
			{
				if (target == null || fxMatMask == null)
				{
					return;
				}
				Renderer[] rr = null;
				switch (effectGroup)
				{
				case TargetOptions.OnlyThisObject:
				{
					Renderer component2 = target.GetComponent<Renderer>();
					if (component2 != null)
					{
						rr = new Renderer[1] { component2 };
					}
					break;
				}
				case TargetOptions.RootToChildren:
				{
					Transform parent = target;
					while (parent.parent != null)
					{
						parent = parent.parent;
					}
					rr = parent.GetComponentsInChildren<Renderer>();
					break;
				}
				case TargetOptions.LayerInScene:
				{
					HighlightEffect highlightEffect2 = this;
					if (target != base.transform)
					{
						HighlightEffect component3 = target.GetComponent<HighlightEffect>();
						if (component3 != null)
						{
							highlightEffect2 = component3;
						}
					}
					rr = FindRenderersWithLayerInScene(highlightEffect2.effectGroupLayer);
					break;
				}
				case TargetOptions.LayerInChildren:
				{
					HighlightEffect highlightEffect = this;
					if (target != base.transform)
					{
						HighlightEffect component = target.GetComponent<HighlightEffect>();
						if (component != null)
						{
							highlightEffect = component;
						}
					}
					rr = FindRenderersWithLayerInChildren(highlightEffect.effectGroupLayer);
					break;
				}
				case TargetOptions.Children:
					rr = target.GetComponentsInChildren<Renderer>();
					break;
				case TargetOptions.Scripting:
					_ = rmsCount;
					_ = 0;
					return;
				}
				SetupMaterial(rr);
			}

			private void SetupMaterial(Renderer[] rr)
			{
				if (rr == null)
				{
					rr = new Renderer[0];
				}
				if (rms == null || rms.Length < rr.Length)
				{
					rms = new ModelMaterials[rr.Length];
				}
				rmsCount = 0;
				for (int i = 0; i < rr.Length; i++)
				{
					rms[rmsCount].Init();
					Renderer renderer = rr[i];
					if (effectGroup != TargetOptions.OnlyThisObject && !string.IsNullOrEmpty(effectNameFilter) && !renderer.name.Contains(effectNameFilter))
					{
						continue;
					}
					rms[rmsCount].renderer = renderer;
					rms[rmsCount].renderWasVisibleDuringSetup = renderer.isVisible;
					if (renderer.transform != target)
					{
						HighlightEffect component = renderer.GetComponent<HighlightEffect>();
						if (component != null && component.enabled)
						{
							component.highlighted = highlighted;
							continue;
						}
					}
					if (this.OnRendererHighlightStart != null && !this.OnRendererHighlightStart(renderer))
					{
						rmsCount++;
						continue;
					}
					rms[rmsCount].isCombined = false;
					bool flag = renderer is SkinnedMeshRenderer;
					rms[rmsCount].isSkinnedMesh = flag;
					rms[rmsCount].normalsOption = (flag ? NormalsOption.PreserveOriginal : normalsOption);
					if (rms[rmsCount].preserveOriginalMesh || combineMeshes)
					{
						CheckCommandBuffers();
					}
					if (flag)
					{
						rms[rmsCount].mesh = ((SkinnedMeshRenderer)renderer).sharedMesh;
					}
					else if (Application.isPlaying && renderer.isPartOfStaticBatch)
					{
						MeshCollider component2 = renderer.GetComponent<MeshCollider>();
						if (component2 != null)
						{
							rms[rmsCount].mesh = component2.sharedMesh;
						}
					}
					else
					{
						MeshFilter component3 = renderer.GetComponent<MeshFilter>();
						if (component3 != null)
						{
							rms[rmsCount].mesh = component3.sharedMesh;
						}
					}
					if (rms[rmsCount].mesh == null)
					{
						continue;
					}
					rms[rmsCount].transform = renderer.transform;
					Fork(fxMatMask, ref rms[rmsCount].fxMatMask, rms[rmsCount].mesh);
					Fork(fxMatSeeThroughInner, ref rms[rmsCount].fxMatSeeThroughInner, rms[rmsCount].mesh);
					Fork(fxMatSeeThroughBorder, ref rms[rmsCount].fxMatSeeThroughBorder, rms[rmsCount].mesh);
					Fork(fxMatOverlay, ref rms[rmsCount].fxMatOverlay, rms[rmsCount].mesh);
					Fork(fxMatInnerGlow, ref rms[rmsCount].fxMatInnerGlow, rms[rmsCount].mesh);
					Fork(fxMatSolidColor, ref rms[rmsCount].fxMatSolidColor, rms[rmsCount].mesh);
					rms[rmsCount].originalMesh = rms[rmsCount].mesh;
					if (!rms[rmsCount].preserveOriginalMesh)
					{
						if (innerGlow > 0f || (glow > 0f && glowQuality != QualityLevel.Highest) || (outline > 0f && outlineQuality != QualityLevel.Highest))
						{
							if (normalsOption == NormalsOption.Reorient || normalsOption == NormalsOption.Planar)
							{
								ReorientNormals(rmsCount);
							}
							else
							{
								AverageNormals(rmsCount);
							}
						}
						BakeTransform(rmsCount, duplicateMesh: true);
					}
					rmsCount++;
				}
				if (combineMeshes)
				{
					CombineMeshes();
				}
				UpdateMaterialPropertiesNow();
			}

			private Renderer[] FindRenderersWithLayerInScene(LayerMask layer)
			{
				Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
				if (tempRR == null)
				{
					tempRR = new List<Renderer>();
				}
				else
				{
					tempRR.Clear();
				}
				foreach (Renderer renderer in array)
				{
					if (((1 << renderer.gameObject.layer) & (int)layer) != 0)
					{
						tempRR.Add(renderer);
					}
				}
				return tempRR.ToArray();
			}

			private Renderer[] FindRenderersWithLayerInChildren(LayerMask layer)
			{
				Renderer[] componentsInChildren = target.GetComponentsInChildren<Renderer>();
				if (tempRR == null)
				{
					tempRR = new List<Renderer>();
				}
				else
				{
					tempRR.Clear();
				}
				foreach (Renderer renderer in componentsInChildren)
				{
					if (((1 << renderer.gameObject.layer) & (int)layer) != 0)
					{
						tempRR.Add(renderer);
					}
				}
				return tempRR.ToArray();
			}

			private void CheckGeometrySupportDependencies()
			{
				InitMaterial(ref fxMatMask, "HighlightPlus/Geometry/Mask");
				InitMaterial(ref fxMatOverlay, "HighlightPlus/Geometry/Overlay");
				InitMaterial(ref fxMatSeeThroughInner, "HighlightPlus/Geometry/SeeThroughInner");
				InitMaterial(ref fxMatSeeThroughBorder, "HighlightPlus/Geometry/SeeThroughBorder");
				InitMaterial(ref fxMatSeeThroughMask, "HighlightPlus/Geometry/SeeThroughMask");
				InitMaterial(ref fxMatSolidColor, "HighlightPlus/Geometry/SolidColor");
				InitMaterial(ref fxMatClearStencil, "HighlightPlus/ClearStencil");
				InitMaterial(ref fxMatOutlineRef, "HighlightPlus/Geometry/Outline");
				InitMaterial(ref fxMatGlowRef, "HighlightPlus/Geometry/Glow");
				InitMaterial(ref fxMatInnerGlow, "HighlightPlus/Geometry/InnerGlow");
				InitMaterial(ref fxMatTargetRef, "HighlightPlus/Geometry/Target");
				InitMaterial(ref fxMatComposeOutlineRef, "HighlightPlus/Geometry/ComposeOutline");
				InitMaterial(ref fxMatComposeGlowRef, "HighlightPlus/Geometry/ComposeGlow");
				InitMaterial(ref fxMatBlurOutlineRef, "HighlightPlus/Geometry/BlurOutline");
				InitMaterial(ref fxMatBlurGlowRef, "HighlightPlus/Geometry/BlurGlow");
				CheckRequiredCommandBuffers();
			}

			private void CheckRequiredCommandBuffers()
			{
				if (cbGlow == null)
				{
					cbGlow = new CommandBuffer();
					cbGlow.name = "Outer Glow for " + base.name;
				}
				if (cbSeeThrough == null)
				{
					cbSeeThrough = new CommandBuffer();
					cbSeeThrough.name = "See Through for " + base.name;
				}
			}

			private void CheckCommandBuffers()
			{
				if (cbMask == null)
				{
					cbMask = new CommandBuffer();
					cbMask.name = "Mask for " + base.name;
				}
				if (cbOutline == null)
				{
					cbOutline = new CommandBuffer();
					cbOutline.name = "Outline for " + base.name;
				}
				if (cbOverlay == null)
				{
					cbOverlay = new CommandBuffer();
					cbOverlay.name = "Overlay for " + base.name;
				}
				if (cbInnerGlow == null)
				{
					cbInnerGlow = new CommandBuffer();
					cbInnerGlow.name = "Inner Glow for " + base.name;
				}
			}

			private void CheckBlurCommandBuffer()
			{
				if (cbSmoothBlend == null)
				{
					cbSmoothBlend = new CommandBuffer();
					cbSmoothBlend.name = "Smooth Blend for " + base.name;
				}
			}

			private void Fork(Material mat, ref Material[] mats, Mesh mesh)
			{
				if (mesh == null)
				{
					return;
				}
				int subMeshCount = mesh.subMeshCount;
				if (mats == null || mats.Length < subMeshCount)
				{
					DestroyMaterialArray(mats);
					mats = new Material[subMeshCount];
				}
				for (int i = 0; i < subMeshCount; i++)
				{
					if (mats[i] == null)
					{
						mats[i] = UnityEngine.Object.Instantiate(mat);
					}
				}
			}

			private void BakeTransform(int objIndex, bool duplicateMesh)
			{
				if (rms[objIndex].mesh == null)
				{
					return;
				}
				Transform transform = rms[objIndex].transform;
				Vector3 localScale = transform.localScale;
				if (localScale.x >= 0f && localScale.y >= 0f && localScale.z >= 0f)
				{
					rms[objIndex].bakedTransform = false;
					return;
				}
				Mesh mesh = (duplicateMesh ? UnityEngine.Object.Instantiate(rms[objIndex].originalMesh) : rms[objIndex].mesh);
				Vector3[] array = mesh.vertices;
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = transform.TransformPoint(array[i]);
				}
				mesh.vertices = array;
				Vector3[] array2 = mesh.normals;
				if (array2 != null)
				{
					for (int j = 0; j < array2.Length; j++)
					{
						array2[j] = transform.TransformVector(array2[j]).normalized;
					}
					mesh.normals = array2;
				}
				mesh.RecalculateBounds();
				rms[objIndex].mesh = mesh;
				rms[objIndex].bakedTransform = true;
				rms[objIndex].currentPosition = transform.position;
				rms[objIndex].currentRotation = transform.eulerAngles;
				rms[objIndex].currentScale = transform.lossyScale;
			}

			public void UpdateMaterialProperties(bool forceNow = false)
			{
				if (forceNow || !Application.isPlaying)
				{
					requireUpdateMaterial = false;
					UpdateMaterialPropertiesNow();
				}
				else
				{
					requireUpdateMaterial = true;
				}
			}

			private void UpdateMaterialPropertiesNow()
			{
				if (rms == null)
				{
					return;
				}
				if (ignore)
				{
					_highlighted = false;
				}
				maskRequired = (_highlighted && (outline > 0f || glow > 0f)) || seeThrough != SeeThroughMode.Never || (targetFX && targetFXAlignToGround);
				Color value = seeThroughTintColor;
				value.a = seeThroughTintAlpha;
				if (lastOutlineVisibility != outlineVisibility)
				{
					if (glowQuality == QualityLevel.Highest && outlineQuality == QualityLevel.Highest)
					{
						glowVisibility = outlineVisibility;
					}
					lastOutlineVisibility = outlineVisibility;
				}
				if (outlineWidth < 0f)
				{
					outlineWidth = 0f;
				}
				if (outlineQuality == QualityLevel.Medium)
				{
					outlineOffsetsMin = 4;
					outlineOffsetsMax = 7;
				}
				else if (outlineQuality == QualityLevel.High)
				{
					outlineOffsetsMin = 0;
					outlineOffsetsMax = 7;
				}
				else
				{
					outlineOffsetsMin = (outlineOffsetsMax = 0);
				}
				if (glowWidth < 0f)
				{
					glowWidth = 0f;
				}
				if (glowQuality == QualityLevel.Medium)
				{
					glowOffsetsMin = 4;
					glowOffsetsMax = 7;
				}
				else if (glowQuality == QualityLevel.High)
				{
					glowOffsetsMin = 0;
					glowOffsetsMax = 7;
				}
				else
				{
					glowOffsetsMin = (glowOffsetsMax = 0);
				}
				if (targetFXTransitionDuration <= 0f)
				{
					targetFXTransitionDuration = 0.0001f;
				}
				if (targetFXStayDuration <= 0f)
				{
					targetFXStayDuration = 0f;
				}
				if (seeThroughDepthOffset < 0f)
				{
					seeThroughDepthOffset = 0f;
				}
				if (seeThroughMaxDepth < 0f)
				{
					seeThroughMaxDepth = 0f;
				}
				if (seeThroughBorderWidth < 0f)
				{
					seeThroughBorderWidth = 0f;
				}
				if (targetFXFadePower < 0f)
				{
					targetFXFadePower = 0f;
				}
				bool flag = glow > 0f && glowQuality == QualityLevel.Highest;
				if (flag)
				{
					CheckBlurCommandBuffer();
					fxMatComposeGlow.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
					if (glowBlendMode == GlowBlendMode.Additive)
					{
						fxMatComposeGlow.SetInt(ShaderParams.BlendSrc, 1);
						fxMatComposeGlow.SetInt(ShaderParams.BlendDst, 1);
					}
					else
					{
						fxMatComposeGlow.SetInt(ShaderParams.BlendSrc, 5);
						fxMatComposeGlow.SetInt(ShaderParams.BlendDst, 10);
					}
					fxMatBlurGlow.SetFloat(ShaderParams.BlurScale, glowWidth / (float)glowDownsampling);
					fxMatBlurGlow.SetFloat(ShaderParams.Speed, glowAnimationSpeed);
				}
				if (outline > 0f && outlineQuality == QualityLevel.Highest)
				{
					CheckBlurCommandBuffer();
					fxMatComposeOutline.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
					fxMatBlurOutline.SetFloat(ShaderParams.BlurScale, outlineWidth / (float)outlineDownsampling);
				}
				float value2 = ((outlineQuality == QualityLevel.High || normalsOption == NormalsOption.Planar) ? 0f : (outlineWidth / 100f));
				Material material = fxMatOutline;
				material.SetFloat(ShaderParams.OutlineWidth, value2);
				material.SetFloat(ShaderParams.OutlineVertexWidth, (normalsOption == NormalsOption.Planar) ? (outlineWidth / 100f) : 0f);
				material.SetVector(ShaderParams.OutlineDirection, Vector3.zero);
				material.SetInt(ShaderParams.OutlineZTest, GetZTestValue(outlineVisibility));
				material.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
				material.SetFloat(ShaderParams.ConstantWidth, constantWidth ? 1f : 0f);
				Material material2 = fxMatGlow;
				material2.SetVector(ShaderParams.Glow2, new Vector3((normalsOption == NormalsOption.Planar) ? 0f : (outlineWidth / 100f), glowAnimationSpeed, (!glowDithering) ? 1 : 0));
				material2.SetInt(ShaderParams.GlowZTest, GetZTestValue(glowVisibility));
				material2.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
				material2.SetFloat(ShaderParams.ConstantWidth, constantWidth ? 1f : 0f);
				material2.SetInt(ShaderParams.GlowStencilOp, (!glowBlendPasses) ? 2 : 0);
				if (targetFX)
				{
					if (targetFXTexture == null)
					{
						targetFXTexture = Resources.Load<Texture2D>("HighlightPlus/target");
					}
					fxMatTarget.mainTexture = targetFXTexture;
					fxMatTarget.SetInt(ShaderParams.ZTest, GetZTestValue(targetFXVisibility));
				}
				for (int i = 0; i < rmsCount; i++)
				{
					if (!(rms[i].mesh != null))
					{
						continue;
					}
					Renderer renderer = rms[i].renderer;
					if (renderer == null)
					{
						continue;
					}
					for (int j = 0; j < rms[i].mesh.subMeshCount; j++)
					{
						if (((1 << j) & subMeshMask) == 0)
						{
							continue;
						}
						Material material3 = null;
						renderer.GetSharedMaterials(rendererSharedMaterials);
						if (j < rendererSharedMaterials.Count)
						{
							material3 = rendererSharedMaterials[j];
						}
						if (material3 == null)
						{
							continue;
						}
						bool flag2 = material3.HasProperty(ShaderParams.MainTex);
						bool flag3 = alphaCutOff > 0f && flag2;
						if (rms[i].fxMatMask != null && rms[i].fxMatMask.Length > j)
						{
							Material material4 = rms[i].fxMatMask[j];
							if (material4 != null)
							{
								if (flag2)
								{
									Texture mainTexture = material3.mainTexture;
									material4.mainTexture = mainTexture;
									material4.mainTextureOffset = material3.mainTextureOffset;
									material4.mainTextureScale = material3.mainTextureScale;
								}
								if (flag3)
								{
									material4.SetFloat(ShaderParams.CutOff, alphaCutOff);
									material4.EnableKeyword("HP_ALPHACLIP");
								}
								else
								{
									material4.DisableKeyword("HP_ALPHACLIP");
								}
								if (depthClip)
								{
									material4.EnableKeyword("HP_DEPTHCLIP");
								}
								else
								{
									material4.DisableKeyword("HP_DEPTHCLIP");
								}
								material4.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
							}
						}
						bool num = rms[i].fxMatSeeThroughBorder != null && rms[i].fxMatSeeThroughBorder.Length > j && seeThroughBorder * seeThroughBorderWidth > 0f;
						if (rms[i].fxMatSeeThroughInner != null && rms[i].fxMatSeeThroughInner.Length > j)
						{
							Material material5 = rms[i].fxMatSeeThroughInner[j];
							if (material5 != null)
							{
								material5.SetFloat(ShaderParams.SeeThrough, seeThroughIntensity);
								material5.SetFloat(ShaderParams.SeeThroughNoise, seeThroughNoise);
								material5.SetColor(ShaderParams.SeeThroughTintColor, value);
								material5.SetFloat(ShaderParams.SeeThroughBorderWidth, (seeThroughBorder * seeThroughBorderWidth > 0f) ? (seeThroughBorderWidth / 100f) : 0f);
								material5.SetFloat(ShaderParams.SeeThroughBorderConstantWidth, constantWidth ? 1f : 0f);
								if (seeThroughOccluderMaskAccurate && (int)seeThroughOccluderMask != -1)
								{
									material5.SetInt(ShaderParams.SeeThroughStencilRef, 1);
									material5.SetInt(ShaderParams.SeeThroughStencilComp, 3);
									material5.SetInt(ShaderParams.SeeThroughStencilPassOp, 1);
								}
								else
								{
									material5.SetInt(ShaderParams.SeeThroughStencilRef, 2);
									material5.SetInt(ShaderParams.SeeThroughStencilComp, 5);
									material5.SetInt(ShaderParams.SeeThroughStencilPassOp, 2);
								}
								if (seeThroughOrdered)
								{
									material5.SetInt(ShaderParams.ZTest, 4);
									material5.SetInt(ShaderParams.SeeThroughOrdered, 1);
								}
								else
								{
									material5.SetInt(ShaderParams.ZTest, 5);
									material5.SetInt(ShaderParams.SeeThroughOrdered, 0);
								}
								if (flag2)
								{
									Texture mainTexture2 = material3.mainTexture;
									material5.mainTexture = mainTexture2;
									material5.mainTextureOffset = material3.mainTextureOffset;
									material5.mainTextureScale = material3.mainTextureScale;
								}
								if (flag3)
								{
									material5.SetFloat(ShaderParams.CutOff, alphaCutOff);
									material5.EnableKeyword("HP_ALPHACLIP");
								}
								else
								{
									material5.DisableKeyword("HP_ALPHACLIP");
								}
								if (seeThroughDepthOffset > 0f || seeThroughMaxDepth > 0f)
								{
									material5.SetFloat(ShaderParams.SeeThroughDepthOffset, (seeThroughDepthOffset > 0f) ? seeThroughDepthOffset : (-1f));
									material5.SetFloat(ShaderParams.SeeThroughMaxDepth, (seeThroughMaxDepth > 0f) ? seeThroughMaxDepth : 999999f);
									material5.EnableKeyword("HP_DEPTH_OFFSET");
								}
								else
								{
									material5.DisableKeyword("HP_DEPTH_OFFSET");
								}
							}
						}
						if (num)
						{
							Material material6 = rms[i].fxMatSeeThroughBorder[j];
							if (material6 != null)
							{
								material6.SetColor(ShaderParams.SeeThroughBorderColor, new Color(seeThroughBorderColor.r, seeThroughBorderColor.g, seeThroughBorderColor.b, seeThroughBorder));
								if (seeThroughOccluderMaskAccurate && (int)seeThroughOccluderMask != -1)
								{
									material6.SetInt(ShaderParams.SeeThroughStencilRef, 1);
									material6.SetInt(ShaderParams.SeeThroughStencilComp, 3);
									material6.SetInt(ShaderParams.SeeThroughStencilPassOp, 1);
								}
								else
								{
									material6.SetInt(ShaderParams.SeeThroughStencilRef, 2);
									material6.SetInt(ShaderParams.SeeThroughStencilComp, 5);
									material6.SetInt(ShaderParams.SeeThroughStencilPassOp, 2);
								}
								if (seeThroughOrdered)
								{
									material6.SetInt(ShaderParams.ZTest, 4);
									material6.SetInt(ShaderParams.SeeThroughOrdered, 1);
								}
								else
								{
									material6.SetInt(ShaderParams.ZTest, 5);
									material6.SetInt(ShaderParams.SeeThroughOrdered, 0);
								}
								if (flag2)
								{
									Texture mainTexture3 = material3.mainTexture;
									material6.mainTexture = mainTexture3;
									material6.mainTextureOffset = material3.mainTextureOffset;
									material6.mainTextureScale = material3.mainTextureScale;
								}
								if (flag3)
								{
									material6.SetFloat(ShaderParams.CutOff, alphaCutOff);
									material6.EnableKeyword("HP_ALPHACLIP");
								}
								else
								{
									material6.DisableKeyword("HP_ALPHACLIP");
								}
								if (seeThroughDepthOffset > 0f || seeThroughMaxDepth > 0f)
								{
									material6.SetFloat(ShaderParams.SeeThroughDepthOffset, (seeThroughDepthOffset > 0f) ? seeThroughDepthOffset : (-1f));
									material6.SetFloat(ShaderParams.SeeThroughMaxDepth, (seeThroughMaxDepth > 0f) ? seeThroughMaxDepth : 999999f);
									material6.EnableKeyword("HP_DEPTH_OFFSET");
								}
								else
								{
									material6.DisableKeyword("HP_DEPTH_OFFSET");
								}
							}
						}
						if (rms[i].fxMatOverlay != null && rms[i].fxMatOverlay.Length > j)
						{
							Material material7 = rms[i].fxMatOverlay[j];
							if (material7 != null)
							{
								if (flag2)
								{
									Texture mainTexture4 = material3.mainTexture;
									material7.mainTexture = mainTexture4;
									material7.mainTextureOffset = material3.mainTextureOffset;
									material7.mainTextureScale = material3.mainTextureScale;
								}
								if (material3.HasProperty(ShaderParams.Color))
								{
									material7.SetColor(ShaderParams.OverlayBackColor, material3.GetColor(ShaderParams.Color));
								}
								material7.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
								if (overlayTexture != null)
								{
									material7.SetTexture(ShaderParams.OverlayTexture, overlayTexture);
									material7.EnableKeyword("HP_USES_OVERLAY_TEXTURE");
								}
								else
								{
									material7.DisableKeyword("HP_USES_OVERLAY_TEXTURE");
								}
								if (flag3)
								{
									material7.SetFloat(ShaderParams.CutOff, alphaCutOff);
									material7.EnableKeyword("HP_ALPHACLIP");
								}
								else
								{
									material7.DisableKeyword("HP_ALPHACLIP");
								}
							}
						}
						if (rms[i].fxMatInnerGlow != null && rms[i].fxMatInnerGlow.Length > j)
						{
							Material material8 = rms[i].fxMatInnerGlow[j];
							if (material8 != null)
							{
								if (flag2)
								{
									Texture mainTexture5 = material3.mainTexture;
									material8.mainTexture = mainTexture5;
									material8.mainTextureOffset = material3.mainTextureOffset;
									material8.mainTextureScale = material3.mainTextureScale;
								}
								material8.SetFloat(ShaderParams.InnerGlowWidth, innerGlowWidth);
								material8.SetInt(ShaderParams.InnerGlowZTest, GetZTestValue(innerGlowVisibility));
								material8.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
								if (flag3)
								{
									material8.SetFloat(ShaderParams.CutOff, alphaCutOff);
									material8.EnableKeyword("HP_ALPHACLIP");
								}
								else
								{
									material8.DisableKeyword("HP_ALPHACLIP");
								}
							}
						}
						if (rms[i].fxMatSolidColor == null || rms[i].fxMatSolidColor.Length <= j)
						{
							continue;
						}
						Material material9 = rms[i].fxMatSolidColor[j];
						if (material9 != null)
						{
							material9.color = glowHQColor;
							material9.SetInt(ShaderParams.Cull, cullBackFaces ? 2 : 0);
							material9.SetInt(ShaderParams.ZTest, GetZTestValue(flag ? glowVisibility : outlineVisibility));
							if (flag2)
							{
								Texture mainTexture6 = material3.mainTexture;
								material9.mainTexture = mainTexture6;
								material9.mainTextureOffset = material3.mainTextureOffset;
								material9.mainTextureScale = material3.mainTextureScale;
							}
							if (flag3)
							{
								material9.SetFloat(ShaderParams.CutOff, alphaCutOff);
								material9.EnableKeyword("HP_ALPHACLIP");
							}
							else
							{
								material9.DisableKeyword("HP_ALPHACLIP");
							}
							if (depthClip)
							{
								material9.EnableKeyword("HP_DEPTHCLIP");
							}
							else
							{
								material9.DisableKeyword("HP_DEPTHCLIP");
							}
						}
					}
				}
			}

			private int GetZTestValue(Visibility param)
			{
				return param switch
				{
					Visibility.AlwaysOnTop => 8, 
					Visibility.OnlyWhenOccluded => 5, 
					_ => 4, 
				};
			}

			private void BuildQuad()
			{
				quadMesh = new Mesh();
				Vector3[] array = new Vector3[4];
				float num = 0.5f;
				float num2 = 0.5f;
				array[0] = new Vector3(0f - num2, 0f - num, 0f);
				array[1] = new Vector3(0f - num2, num, 0f);
				array[2] = new Vector3(num2, 0f - num, 0f);
				array[3] = new Vector3(num2, num, 0f);
				Vector2[] array2 = new Vector2[array.Length];
				array2[0] = new Vector2(0f, 0f);
				array2[1] = new Vector2(0f, 1f);
				array2[2] = new Vector2(1f, 0f);
				array2[3] = new Vector2(1f, 1f);
				int[] triangles = new int[6] { 0, 1, 2, 3, 2, 1 };
				Vector3[] array3 = new Vector3[array.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					array3[i] = Vector3.forward;
				}
				quadMesh.vertices = array;
				quadMesh.uv = array2;
				quadMesh.triangles = triangles;
				quadMesh.normals = array3;
				quadMesh.RecalculateBounds();
			}

			private void BuildCube()
			{
				cubeMesh = Resources.GetBuiltinResource<Mesh>("Cube.fbx");
			}

			public bool Includes(Transform transform)
			{
				for (int i = 0; i < rmsCount; i++)
				{
					if (rms[i].transform == transform)
					{
						return true;
					}
				}
				return false;
			}

			public void SetGlowColor(Color color)
			{
				if (glowPasses != null)
				{
					for (int i = 0; i < glowPasses.Length; i++)
					{
						glowPasses[i].color = color;
					}
				}
				glowHQColor = color;
				UpdateMaterialProperties();
			}

			private void AverageNormals(int objIndex)
			{
				if (rms == null || objIndex >= rms.Length)
				{
					return;
				}
				Mesh mesh = rms[objIndex].mesh;
				int hashCode = mesh.GetHashCode();
				if (!smoothMeshes.TryGetValue(hashCode, out var value) || value == null)
				{
					if (!mesh.isReadable)
					{
						return;
					}
					if (normals == null)
					{
						normals = new List<Vector3>();
					}
					else
					{
						normals.Clear();
					}
					mesh.GetNormals(normals);
					int count = normals.Count;
					if (count == 0)
					{
						return;
					}
					if (vertices == null)
					{
						vertices = new List<Vector3>();
					}
					else
					{
						vertices.Clear();
					}
					mesh.GetVertices(vertices);
					int num = vertices.Count;
					if (count < num)
					{
						num = count;
					}
					if (newNormals == null || newNormals.Length < num)
					{
						newNormals = new Vector3[num];
					}
					else
					{
						Vector3 zero = Vector3.zero;
						for (int i = 0; i < num; i++)
						{
							newNormals[i] = zero;
						}
					}
					if (matches == null || matches.Length < num)
					{
						matches = new int[num];
					}
					vv.Clear();
					for (int j = 0; j < num; j++)
					{
						Vector3 key = vertices[j];
						if (!vv.TryGetValue(key, out var value2))
						{
							value2 = (vv[key] = j);
						}
						matches[j] = value2;
					}
					for (int k = 0; k < num; k++)
					{
						int num3 = matches[k];
						newNormals[num3] += normals[k];
					}
					for (int l = 0; l < num; l++)
					{
						int num4 = matches[l];
						normals[l] = newNormals[num4].normalized;
					}
					value = UnityEngine.Object.Instantiate(mesh);
					value.SetNormals(normals);
					smoothMeshes[hashCode] = value;
				}
				rms[objIndex].mesh = value;
			}

			private void ReorientNormals(int objIndex)
			{
				if (rms == null || objIndex >= rms.Length)
				{
					return;
				}
				Mesh mesh = rms[objIndex].mesh;
				int hashCode = mesh.GetHashCode();
				if (!reorientedMeshes.TryGetValue(hashCode, out var value) || value == null)
				{
					if (!mesh.isReadable)
					{
						return;
					}
					if (normals == null)
					{
						normals = new List<Vector3>();
					}
					else
					{
						normals.Clear();
					}
					if (vertices == null)
					{
						vertices = new List<Vector3>();
					}
					else
					{
						vertices.Clear();
					}
					mesh.GetVertices(vertices);
					int count = vertices.Count;
					if (count == 0)
					{
						return;
					}
					Vector3 zero = Vector3.zero;
					for (int i = 0; i < count; i++)
					{
						zero += vertices[i];
					}
					zero /= (float)count;
					for (int j = 0; j < count; j++)
					{
						normals.Add((vertices[j] - zero).normalized);
					}
					value = UnityEngine.Object.Instantiate(mesh);
					value.SetNormals(normals);
					reorientedMeshes[hashCode] = value;
				}
				rms[objIndex].mesh = value;
			}

			private void CombineMeshes()
			{
				if (combineInstances == null || combineInstances.Length != rmsCount)
				{
					combineInstances = new CombineInstance[rmsCount];
				}
				int num = -1;
				int num2 = 0;
				combinedMeshesHashId = 0;
				int num3 = 0;
				Matrix4x4 worldToLocalMatrix = matrix4X4Identity;
				for (int i = 0; i < rmsCount; i++)
				{
					combineInstances[i].mesh = null;
					if (rms[i].isSkinnedMesh)
					{
						continue;
					}
					Mesh mesh = rms[i].mesh;
					if (mesh != null && mesh.isReadable && num3 + mesh.vertexCount <= 65535)
					{
						combineInstances[i].mesh = mesh;
						int instanceID = rms[i].renderer.gameObject.GetInstanceID();
						if (num < 0)
						{
							num = i;
							combinedMeshesHashId = instanceID;
							worldToLocalMatrix = rms[i].transform.worldToLocalMatrix;
						}
						else
						{
							combinedMeshesHashId ^= instanceID;
							rms[i].mesh = null;
						}
						combineInstances[i].transform = worldToLocalMatrix * rms[i].transform.localToWorldMatrix;
						num2++;
					}
				}
				if (num2 >= 2)
				{
					if (!combinedMeshes.TryGetValue(combinedMeshesHashId, out var value) || value == null)
					{
						value = new Mesh();
						value.CombineMeshes(combineInstances, mergeSubMeshes: true, useMatrices: true);
						combinedMeshes[combinedMeshesHashId] = value;
					}
					rms[num].mesh = value;
					rms[num].isCombined = true;
				}
			}

			public void HitFX()
			{
				HitFX(hitFxColor, hitFxFadeOutDuration, hitFxInitialIntensity);
			}

			public void HitFX(Vector3 position)
			{
				HitFX(hitFxColor, hitFxFadeOutDuration, hitFxInitialIntensity, position, hitFxRadius);
			}

			public void HitFX(Color color, float fadeOutDuration, float initialIntensity = 1f)
			{
				hitInitialIntensity = initialIntensity;
				hitFadeOutDuration = fadeOutDuration;
				hitColor = color;
				hitStartTime = Time.time;
				hitActive = true;
				if (overlay == 0f)
				{
					UpdateMaterialProperties();
				}
			}

			public void HitFX(Color color, float fadeOutDuration, float initialIntensity, Vector3 position, float radius)
			{
				hitInitialIntensity = initialIntensity;
				hitFadeOutDuration = fadeOutDuration;
				hitColor = color;
				hitStartTime = Time.time;
				hitActive = true;
				hitPosition = position;
				hitRadius = radius;
				if (overlay == 0f)
				{
					UpdateMaterialProperties();
				}
			}

			public void TargetFX()
			{
				targetFxStartTime = Time.time;
				if (!targetFX)
				{
					targetFX = true;
					UpdateMaterialProperties();
				}
			}

			public bool IsSeeThroughOccluded(Camera cam)
			{
				Bounds bounds = default(Bounds);
				for (int i = 0; i < rms.Length; i++)
				{
					if (rms[i].renderer != null)
					{
						if (bounds.size.x == 0f)
						{
							bounds = rms[i].renderer.bounds;
						}
						else
						{
							bounds.Encapsulate(rms[i].renderer.bounds);
						}
					}
				}
				Vector3 center = bounds.center;
				Vector3 position = cam.transform.position;
				Vector3 vector = center - position;
				float maxDistance = Vector3.Distance(center, position);
				if (hits == null || hits.Length == 0)
				{
					hits = new RaycastHit[64];
				}
				int count = occluders.Count;
				int num = Physics.BoxCastNonAlloc(center - vector, bounds.extents * 0.9f, vector.normalized, hits, Quaternion.identity, maxDistance);
				for (int j = 0; j < num; j++)
				{
					for (int k = 0; k < count; k++)
					{
						if (hits[j].collider.transform == occluders[k].transform)
						{
							return true;
						}
					}
				}
				return false;
			}

			public static void RegisterOccluder(HighlightSeeThroughOccluder occluder)
			{
				if (!occluders.Contains(occluder))
				{
					occluders.Add(occluder);
				}
			}

			public static void UnregisterOccluder(HighlightSeeThroughOccluder occluder)
			{
				if (occluders.Contains(occluder))
				{
					occluders.Remove(occluder);
				}
			}

			public bool RenderSeeThroughOccluders(Camera cam)
			{
				int count = occluders.Count;
				if (count == 0 || rmsCount == 0)
				{
					return true;
				}
				bool flag = false;
				for (int i = 0; i < count; i++)
				{
					HighlightSeeThroughOccluder highlightSeeThroughOccluder = occluders[i];
					if (!(highlightSeeThroughOccluder == null) && highlightSeeThroughOccluder.isActiveAndEnabled && highlightSeeThroughOccluder.detectionMethod == DetectionMethod.RayCast)
					{
						flag = true;
						break;
					}
				}
				if (flag && IsSeeThroughOccluded(cam))
				{
					return false;
				}
				occludersFrameCount.TryGetValue(cam, out var value);
				int frameCount = Time.frameCount;
				if (frameCount == value)
				{
					return true;
				}
				occludersFrameCount[cam] = frameCount;
				if (cbOccluder == null)
				{
					cbOccluder = new CommandBuffer();
					cbOccluder.name = "Occluder";
				}
				if (fxMatOccluder == null)
				{
					InitMaterial(ref fxMatOccluder, "HighlightPlus/Geometry/SeeThroughOccluder");
					if (fxMatOccluder == null)
					{
						return true;
					}
				}
				cbOccluder.Clear();
				for (int j = 0; j < count; j++)
				{
					HighlightSeeThroughOccluder highlightSeeThroughOccluder2 = occluders[j];
					if (highlightSeeThroughOccluder2 == null || !highlightSeeThroughOccluder2.isActiveAndEnabled || highlightSeeThroughOccluder2.detectionMethod != 0 || highlightSeeThroughOccluder2.meshData == null || highlightSeeThroughOccluder2.meshData.Length == 0)
					{
						continue;
					}
					for (int k = 0; k < highlightSeeThroughOccluder2.meshData.Length; k++)
					{
						Renderer renderer = highlightSeeThroughOccluder2.meshData[k].renderer;
						if (renderer.isVisible)
						{
							for (int l = 0; l < highlightSeeThroughOccluder2.meshData[k].subMeshCount; l++)
							{
								cbOccluder.DrawRenderer(renderer, fxMatOccluder, l);
							}
						}
					}
				}
				Graphics.ExecuteCommandBuffer(cbOccluder);
				return true;
			}

			private bool CheckOcclusion(Camera cam)
			{
				float time = Time.time;
				int frameCount = Time.frameCount;
				if (Time.time - occlusionCheckLastTime < seeThroughOccluderCheckInterval && Application.isPlaying && occlusionRenderFrame != frameCount)
				{
					return lastOcclusionTestResult;
				}
				occlusionCheckLastTime = time;
				occlusionRenderFrame = frameCount;
				if (rms.Length == 0 || rms[0].renderer == null)
				{
					return false;
				}
				Vector3 position = cam.transform.position;
				if (seeThroughOccluderCheckIndividualObjects)
				{
					for (int i = 0; i < rms.Length; i++)
					{
						if (rms[i].renderer != null)
						{
							Bounds bounds = rms[i].renderer.bounds;
							Vector3 center = bounds.center;
							float maxDistance = Vector3.Distance(center, position);
							if (Physics.BoxCast(center, bounds.extents * seeThroughOccluderThreshold, (position - center).normalized, Quaternion.identity, maxDistance, seeThroughOccluderMask))
							{
								lastOcclusionTestResult = true;
								return true;
							}
						}
					}
					lastOcclusionTestResult = false;
					return false;
				}
				Bounds bounds2 = rms[0].renderer.bounds;
				for (int j = 1; j < rms.Length; j++)
				{
					if (rms[j].renderer != null)
					{
						bounds2.Encapsulate(rms[j].renderer.bounds);
					}
				}
				Vector3 center2 = bounds2.center;
				float maxDistance2 = Vector3.Distance(center2, position);
				lastOcclusionTestResult = Physics.BoxCast(center2, bounds2.extents * seeThroughOccluderThreshold, (position - center2).normalized, Quaternion.identity, maxDistance2, seeThroughOccluderMask);
				return lastOcclusionTestResult;
			}

			private void CheckOcclusionAccurate(Camera cam)
			{
				if (!cachedOccludersPerCamera.TryGetValue(cam, out var value))
				{
					value = new List<Renderer>();
					cachedOccludersPerCamera[cam] = value;
				}
				float time = Time.time;
				int frameCount = Time.frameCount;
				if (!(Time.time - occlusionCheckLastTime < seeThroughOccluderCheckInterval) || !Application.isPlaying || occlusionRenderFrame == frameCount)
				{
					if (rms.Length == 0 || rms[0].renderer == null)
					{
						return;
					}
					occlusionCheckLastTime = time;
					occlusionRenderFrame = frameCount;
					Quaternion identity = Quaternion.identity;
					Vector3 position = cam.transform.position;
					value.Clear();
					if (occluderHits == null || occluderHits.Length < 50)
					{
						occluderHits = new RaycastHit[50];
					}
					if (seeThroughOccluderCheckIndividualObjects)
					{
						for (int i = 0; i < rms.Length; i++)
						{
							if (!(rms[i].renderer != null))
							{
								continue;
							}
							Bounds bounds = rms[i].renderer.bounds;
							Vector3 center = bounds.center;
							float maxDistance = Vector3.Distance(center, position);
							int num = Physics.BoxCastNonAlloc(center, bounds.extents * seeThroughOccluderThreshold, (position - center).normalized, occluderHits, identity, maxDistance, seeThroughOccluderMask);
							for (int j = 0; j < num; j++)
							{
								Renderer componentInChildren = occluderHits[j].collider.GetComponentInChildren<Renderer>();
								if (componentInChildren != null && !value.Contains(componentInChildren))
								{
									value.Add(componentInChildren);
								}
							}
						}
					}
					else
					{
						Bounds bounds2 = rms[0].renderer.bounds;
						for (int k = 1; k < rms.Length; k++)
						{
							if (rms[k].renderer != null)
							{
								bounds2.Encapsulate(rms[k].renderer.bounds);
							}
						}
						Vector3 center2 = bounds2.center;
						float maxDistance2 = Vector3.Distance(center2, position);
						int num2 = Physics.BoxCastNonAlloc(center2, bounds2.extents * seeThroughOccluderThreshold, (position - center2).normalized, occluderHits, identity, maxDistance2, seeThroughOccluderMask);
						for (int l = 0; l < num2; l++)
						{
							Renderer componentInChildren2 = occluderHits[l].collider.GetComponentInChildren<Renderer>();
							if (componentInChildren2 != null)
							{
								value.Add(componentInChildren2);
							}
						}
					}
				}
				int count = value.Count;
				if (count <= 0)
				{
					return;
				}
				cbSeeThrough.Clear();
				for (int m = 0; m < count; m++)
				{
					Renderer renderer = value[m];
					if (renderer != null)
					{
						cbSeeThrough.DrawRenderer(renderer, fxMatSeeThroughMask);
					}
				}
				Graphics.ExecuteCommandBuffer(cbSeeThrough);
			}

			public List<Renderer> GetOccluders(Camera camera)
			{
				List<Renderer> value = null;
				if (cachedOccludersPerCamera != null)
				{
					cachedOccludersPerCamera.TryGetValue(camera, out value);
				}
				return value;
			}
		}
		public enum HitFxMode
		{
			Overlay,
			InnerGlow,
			LocalHit
		}
		public delegate bool OnObjectSelectionEvent(GameObject obj);
		[RequireComponent(typeof(HighlightEffect))]
		[DefaultExecutionOrder(100)]
		[HelpURL("https://www.dropbox.com/s/v9qgn68ydblqz8x/Documentation.pdf?dl=0")]
		public class HighlightManager : MonoBehaviour
		{
			[Tooltip("Enables highlight when pointer is over this object.")]
			public bool highlightOnHover = true;

			public LayerMask layerMask = -1;

			public Camera raycastCamera;

			public RayCastSource raycastSource;

			[Tooltip("Minimum distance for target.")]
			public float minDistance;

			[Tooltip("Maximum distance for target. 0 = infinity")]
			public float maxDistance;

			[Tooltip("Blocks interaction if pointer is over an UI element")]
			public bool respectUI = true;

			[Tooltip("If the object will be selected by clicking with mouse or tapping on it.")]
			public bool selectOnClick;

			[Tooltip("Optional profile for objects selected by clicking on them")]
			public HighlightProfile selectedProfile;

			[Tooltip("Profile to use whtn object is selected and highlighted.")]
			public HighlightProfile selectedAndHighlightedProfile;

			[Tooltip("Automatically deselects other previously selected objects")]
			public bool singleSelection;

			[Tooltip("Toggles selection on/off when clicking object")]
			public bool toggle;

			private HighlightEffect baseEffect;

			private HighlightEffect currentEffect;

			private Transform currentObject;

			public static readonly List<HighlightEffect> selectedObjects = new List<HighlightEffect>();

			public static int lastTriggerTime;

			private static HighlightManager _instance;

			public static HighlightManager instance
			{
				get
				{
					if (_instance == null)
					{
						_instance = UnityEngine.Object.FindObjectOfType<HighlightManager>();
					}
					return _instance;
				}
			}

			public event OnObjectSelectionEvent OnObjectSelected;

			public event OnObjectSelectionEvent OnObjectUnSelected;

			public event OnObjectHighlightEvent OnObjectHighlightStart;

			public event OnObjectHighlightEvent OnObjectHighlightEnd;

			[RuntimeInitializeOnLoadMethod]
			private void DomainReloadDisabledSupport()
			{
				selectedObjects.Clear();
				lastTriggerTime = 0;
				_instance = null;
			}

			private void OnEnable()
			{
				currentObject = null;
				currentEffect = null;
				if (baseEffect == null)
				{
					baseEffect = GetComponent<HighlightEffect>();
					if (baseEffect == null)
					{
						baseEffect = base.gameObject.AddComponent<HighlightEffect>();
					}
				}
				raycastCamera = GetComponent<Camera>();
				if (raycastCamera == null)
				{
					raycastCamera = GetCamera();
					if (raycastCamera == null)
					{
						UnityEngine.Debug.LogError("Highlight Manager: no camera found!");
					}
				}
			}

			private void OnDisable()
			{
				SwitchesCollider(null);
				internal_DeselectAll();
			}

			private void Update()
			{
				if (raycastCamera == null)
				{
					return;
				}
				Ray ray;
				if (raycastSource == RayCastSource.MousePosition)
				{
					if (!CanInteract())
					{
						return;
					}
					ray = raycastCamera.ScreenPointToRay(InputProxy.mousePosition);
				}
				else
				{
					ray = new Ray(raycastCamera.transform.position, raycastCamera.transform.forward);
				}
				if (Physics.Raycast(ray, out var hitInfo, (maxDistance > 0f) ? maxDistance : raycastCamera.farClipPlane, layerMask) && Vector3.Distance(hitInfo.point, ray.origin) >= minDistance)
				{
					Transform transform = hitInfo.collider.transform;
					if (InputProxy.GetMouseButtonDown(0))
					{
						if (selectOnClick)
						{
							ToggleSelection(transform, !toggle);
						}
						else if (lastTriggerTime < Time.frameCount)
						{
							internal_DeselectAll();
						}
					}
					else if (transform != currentObject)
					{
						SwitchesCollider(transform);
					}
				}
				else
				{
					if (InputProxy.GetMouseButtonDown(0) && lastTriggerTime < Time.frameCount)
					{
						internal_DeselectAll();
					}
					SwitchesCollider(null);
				}
			}

			private void SwitchesCollider(Transform newObject)
			{
				if (currentEffect != null)
				{
					if (highlightOnHover)
					{
						Highlight(state: false);
					}
					currentEffect = null;
				}
				currentObject = newObject;
				if (newObject == null)
				{
					return;
				}
				HighlightTrigger component = newObject.GetComponent<HighlightTrigger>();
				if (component != null && component.enabled)
				{
					return;
				}
				HighlightEffect component2 = newObject.GetComponent<HighlightEffect>();
				if (component2 == null)
				{
					HighlightEffect componentInParent = newObject.GetComponentInParent<HighlightEffect>();
					if (componentInParent != null && componentInParent.Includes(newObject))
					{
						currentEffect = componentInParent;
						if (highlightOnHover)
						{
							Highlight(state: true);
						}
						return;
					}
				}
				currentEffect = ((component2 != null) ? component2 : baseEffect);
				baseEffect.enabled = currentEffect == baseEffect;
				currentEffect.SetTarget(currentObject);
				if (highlightOnHover)
				{
					Highlight(state: true);
				}
			}

			private bool CanInteract()
			{
				if (respectUI && EventSystem.current != null)
				{
					if (Application.isMobilePlatform && InputProxy.touchCount > 0 && EventSystem.current.IsPointerOverGameObject(InputProxy.GetFingerIdFromTouch(0)))
					{
						return false;
					}
					if (EventSystem.current.IsPointerOverGameObject(-1))
					{
						return false;
					}
				}
				return true;
			}

			private void ToggleSelection(Transform t, bool forceSelection)
			{
				HighlightEffect highlightEffect = t.GetComponent<HighlightEffect>();
				if (highlightEffect == null)
				{
					HighlightEffect componentInParent = t.GetComponentInParent<HighlightEffect>();
					if (componentInParent != null && componentInParent.Includes(t))
					{
						highlightEffect = componentInParent;
						if (highlightEffect.previousSettings == null)
						{
							highlightEffect.previousSettings = ScriptableObject.CreateInstance<HighlightProfile>();
						}
						highlightEffect.previousSettings.Save(highlightEffect);
					}
					else
					{
						highlightEffect = t.gameObject.AddComponent<HighlightEffect>();
						highlightEffect.previousSettings = ScriptableObject.CreateInstance<HighlightProfile>();
						highlightEffect.previousSettings.Save(baseEffect);
						highlightEffect.previousSettings.Load(highlightEffect);
					}
				}
				bool isSelected = highlightEffect.isSelected;
				bool flag = forceSelection || !isSelected;
				if (flag == isSelected)
				{
					return;
				}
				if (flag)
				{
					if (this.OnObjectSelected != null && !this.OnObjectSelected(t.gameObject))
					{
						return;
					}
				}
				else if (this.OnObjectUnSelected != null && !this.OnObjectUnSelected(t.gameObject))
				{
					return;
				}
				if (singleSelection)
				{
					internal_DeselectAll();
				}
				currentEffect = highlightEffect;
				currentEffect.isSelected = flag;
				baseEffect.enabled = false;
				if (currentEffect.isSelected)
				{
					if (currentEffect.previousSettings == null)
					{
						currentEffect.previousSettings = ScriptableObject.CreateInstance<HighlightProfile>();
					}
					highlightEffect.previousSettings.Save(highlightEffect);
					if (!selectedObjects.Contains(currentEffect))
					{
						selectedObjects.Add(currentEffect);
					}
				}
				else
				{
					if (currentEffect.previousSettings != null)
					{
						currentEffect.previousSettings.Load(highlightEffect);
					}
					if (selectedObjects.Contains(currentEffect))
					{
						selectedObjects.Remove(currentEffect);
					}
				}
				Highlight(state: true);
			}

			private void Highlight(bool state)
			{
				if (state)
				{
					if (!currentEffect.highlighted && this.OnObjectHighlightStart != null && currentEffect.target != null && !this.OnObjectHighlightStart(currentEffect.target.gameObject))
					{
						return;
					}
				}
				else if (currentEffect.highlighted && this.OnObjectHighlightEnd != null && currentEffect.target != null)
				{
					this.OnObjectHighlightEnd(currentEffect.target.gameObject);
				}
				if (selectOnClick)
				{
					if (currentEffect.isSelected)
					{
						if (state)
						{
							if (selectedAndHighlightedProfile != null)
							{
								selectedAndHighlightedProfile.Load(currentEffect);
							}
						}
						else if (selectedProfile != null)
						{
							selectedProfile.Load(currentEffect);
						}
						else
						{
							currentEffect.previousSettings.Load(currentEffect);
						}
						if (currentEffect.highlighted)
						{
							currentEffect.UpdateMaterialProperties();
						}
						else
						{
							currentEffect.SetHighlighted(state: true);
						}
						return;
					}
					if (!highlightOnHover)
					{
						currentEffect.SetHighlighted(state: false);
						return;
					}
				}
				currentEffect.SetHighlighted(state);
			}

			public static Camera GetCamera()
			{
				Camera camera = Camera.main;
				if (camera == null)
				{
					camera = UnityEngine.Object.FindObjectOfType<Camera>();
				}
				return camera;
			}

			private void internal_DeselectAll()
			{
				foreach (HighlightEffect selectedObject in selectedObjects)
				{
					if (selectedObject != null && selectedObject.gameObject != null && (this.OnObjectUnSelected == null || this.OnObjectUnSelected(selectedObject.gameObject)))
					{
						selectedObject.isSelected = false;
						selectedObject.SetHighlighted(state: false);
					}
				}
				selectedObjects.Clear();
			}

			public static void DeselectAll()
			{
				foreach (HighlightEffect selectedObject in selectedObjects)
				{
					if (selectedObject != null && selectedObject.gameObject != null)
					{
						selectedObject.isSelected = false;
						if (selectedObject.highlighted && _instance != null)
						{
							_instance.Highlight(state: false);
						}
						else
						{
							selectedObject.SetHighlighted(state: false);
						}
					}
				}
				selectedObjects.Clear();
			}

			public void SelectObject(Transform t)
			{
				ToggleSelection(t, forceSelection: true);
			}

			public void ToggleObject(Transform t)
			{
				ToggleSelection(t, forceSelection: false);
			}

			public void UnselectObject(Transform t)
			{
				if (!(t == null))
				{
					HighlightEffect component = t.GetComponent<HighlightEffect>();
					if (!(component == null) && selectedObjects.Contains(component) && (this.OnObjectUnSelected == null || this.OnObjectUnSelected(component.gameObject)))
					{
						component.isSelected = false;
						component.SetHighlighted(state: false);
						selectedObjects.Remove(component);
					}
				}
			}
		}
		[CreateAssetMenu(menuName = "Highlight Plus Profile", fileName = "Highlight Plus Profile", order = 100)]
		[HelpURL("https://www.dropbox.com/s/v9qgn68ydblqz8x/Documentation.pdf?dl=0")]
		public class HighlightProfile : ScriptableObject
		{
			[Tooltip("Different options to specify which objects are affected by this Highlight Effect component.")]
			public TargetOptions effectGroup;

			[Tooltip("The layer that contains the affected objects by this effect when effectGroup is set to LayerMask.")]
			public LayerMask effectGroupLayer = -1;

			[Tooltip("Only include objects whose names contains this text.")]
			public string effectNameFilter;

			[Tooltip("Combine meshes of all objects in this group affected by Highlight Effect reducing draw calls.")]
			public bool combineMeshes;

			[Tooltip("The alpha threshold for transparent cutout objects. Pixels with alpha below this value will be discarded.")]
			[Range(0f, 1f)]
			public float alphaCutOff;

			[Tooltip("If back facing triangles are ignored.Backfaces triangles are not visible but you may set this property to false to force highlight effects to act on those triangles as well.")]
			public bool cullBackFaces = true;

			public bool depthClip;

			[Tooltip("Normals handling option:\nPreserve original: use original mesh normals.\nSmooth: average normals to produce a smoother outline/glow mesh based effect.\nReorient: recomputes normals based on vertex direction to centroid.")]
			public NormalsOption normalsOption;

			public float fadeInDuration;

			public float fadeOutDuration;

			[Tooltip("Keeps the outline/glow size unaffected by object distance.")]
			public bool constantWidth = true;

			[Range(0f, 1f)]
			[Tooltip("Intensity of the overlay effect. A value of 0 disables the overlay completely.")]
			public float overlay;

			[ColorUsage(true, true)]
			public Color overlayColor = Color.yellow;

			public float overlayAnimationSpeed = 1f;

			[Range(0f, 1f)]
			public float overlayMinIntensity = 0.5f;

			[Range(0f, 1f)]
			[Tooltip("Controls the blending or mix of the overlay color with the natural colors of the object.")]
			public float overlayBlending = 1f;

			[Tooltip("Optional overlay texture.")]
			public Texture2D overlayTexture;

			public float overlayTextureScale = 1f;

			[Range(0f, 1f)]
			[Tooltip("Intensity of the outline. A value of 0 disables the outline completely.")]
			public float outline = 1f;

			[ColorUsage(true, true)]
			public Color outlineColor = Color.black;

			public float outlineWidth = 0.45f;

			public QualityLevel outlineQuality = QualityLevel.High;

			[Range(1f, 8f)]
			[Tooltip("Reduces the quality of the outline but improves performance a bit.")]
			public int outlineDownsampling = 2;

			public bool outlineOptimalBlit = true;

			public Visibility outlineVisibility;

			[Tooltip("If enabled, this object won't combine the outline with other objects.")]
			public bool outlineIndependent;

			[Range(0f, 5f)]
			[Tooltip("The intensity of the outer glow effect. A value of 0 disables the glow completely.")]
			public float glow;

			public float glowWidth = 0.4f;

			public QualityLevel glowQuality = QualityLevel.High;

			[Range(1f, 8f)]
			[Tooltip("Reduces the quality of the glow but improves performance a bit.")]
			public int glowDownsampling = 2;

			[ColorUsage(true, true)]
			public Color glowHQColor = new Color(0.64f, 1f, 0f, 1f);

			[Tooltip("When enabled, outer glow renders with dithering. When disabled, glow appears as a solid color.")]
			public bool glowDithering = true;

			public bool glowOptimalBlit = true;

			[Tooltip("Seed for the dithering effect")]
			public float glowMagicNumber1 = 0.75f;

			[Tooltip("Another seed for the dithering effect that combines with first seed to create different patterns")]
			public float glowMagicNumber2 = 0.5f;

			public float glowAnimationSpeed = 1f;

			public Visibility glowVisibility;

			public GlowBlendMode glowBlendMode;

			[Tooltip("Blends glow passes one after another. If this option is disabled, glow passes won't overlap (in this case, make sure the glow pass 1 has a smaller offset than pass 2, etc.)")]
			public bool glowBlendPasses = true;

			public GlowPassData[] glowPasses;

			[Range(0f, 5f)]
			[Tooltip("The intensity of the inner glow effect. A value of 0 disables the glow completely.")]
			public float innerGlow;

			[Range(0f, 2f)]
			public float innerGlowWidth = 1f;

			[ColorUsage(true, true)]
			public Color innerGlowColor = Color.white;

			public Visibility innerGlowVisibility;

			[Tooltip("Enables the targetFX effect. This effect draws an animated sprite over the object.")]
			public bool targetFX;

			public Texture2D targetFXTexture;

			[ColorUsage(true, true)]
			public Color targetFXColor = Color.white;

			public float targetFXRotationSpeed = 50f;

			public float targetFXInitialScale = 4f;

			public float targetFXEndScale = 1.5f;

			[Tooltip("Makes target scale relative to object renderer bounds.")]
			public bool targetFXScaleToRenderBounds;

			[Tooltip("Places target FX sprite at the bottom of the highlighted object.")]
			public bool targetFXAlignToGround;

			[Tooltip("Max distance from the center of the highlighted object to the ground.")]
			public float targetFXGroundMaxDistance = 15f;

			public LayerMask targetFXGroundLayerMask = -1;

			[Tooltip("Fade out effect with altitude")]
			public float targetFXFadePower = 32f;

			public float targetFXTransitionDuration = 0.5f;

			public float targetFXStayDuration = 1.5f;

			public Visibility targetFXVisibility = Visibility.AlwaysOnTop;

			[Tooltip("See-through mode for this Highlight Effect component.")]
			public SeeThroughMode seeThrough = SeeThroughMode.Never;

			[Tooltip("This mask setting let you specify which objects will be considered as occluders and cause the see-through effect for this Highlight Effect component. For example, you assign your walls to a different layer and specify that layer here, so only walls and not other objects, like ground or ceiling, will trigger the see-through effect.")]
			public LayerMask seeThroughOccluderMask = -1;

			[Tooltip("Uses stencil buffers to ensure pixel-accurate occlusion test. If this option is disabled, only physics raycasting is used to test for occlusion.")]
			public bool seeThroughOccluderMaskAccurate;

			[Tooltip("A multiplier for the occluder volume size which can be used to reduce the actual size of occluders when Highlight Effect checks if they're occluding this object.")]
			[Range(0.01f, 0.9f)]
			public float seeThroughOccluderThreshold = 0.4f;

			[Tooltip("The interval of time between occlusion tests.")]
			public float seeThroughOccluderCheckInterval = 1f;

			[Tooltip("If enabled, occlusion test is performed for each children element. If disabled, the bounds of all children is combined and a single occlusion test is performed for the combined bounds.")]
			public bool seeThroughOccluderCheckIndividualObjects;

			[Tooltip("Shows the see-through effect only if the occluder if at this 'offset' distance from the object.")]
			public float seeThroughDepthOffset;

			[Tooltip("Hides the see-through effect if the occluder is further than this distance from the object (0 = infinite)")]
			public float seeThroughMaxDepth;

			[Range(0f, 5f)]
			public float seeThroughIntensity = 0.8f;

			[Range(0f, 1f)]
			public float seeThroughTintAlpha = 0.5f;

			public Color seeThroughTintColor = Color.red;

			[Range(0f, 1f)]
			public float seeThroughNoise = 1f;

			[Range(0f, 1f)]
			public float seeThroughBorder;

			public Color seeThroughBorderColor = Color.black;

			public float seeThroughBorderWidth = 0.45f;

			[Tooltip("Renders see-through effect on overlapping objects in a sequence that's relative to the distance to the camera")]
			public bool seeThroughOrdered = true;

			[Range(0f, 1f)]
			public float hitFxInitialIntensity;

			public HitFxMode hitFxMode;

			public float hitFxFadeOutDuration = 0.25f;

			[ColorUsage(true, true)]
			public Color hitFxColor = Color.white;

			public float hitFxRadius = 0.5f;

			public void Load(HighlightEffect effect)
			{
				effect.effectGroup = effectGroup;
				effect.effectGroupLayer = effectGroupLayer;
				effect.effectNameFilter = effectNameFilter;
				effect.combineMeshes = combineMeshes;
				effect.alphaCutOff = alphaCutOff;
				effect.cullBackFaces = cullBackFaces;
				effect.depthClip = depthClip;
				effect.normalsOption = normalsOption;
				effect.fadeInDuration = fadeInDuration;
				effect.fadeOutDuration = fadeOutDuration;
				effect.constantWidth = constantWidth;
				effect.overlay = overlay;
				effect.overlayColor = overlayColor;
				effect.overlayAnimationSpeed = overlayAnimationSpeed;
				effect.overlayMinIntensity = overlayMinIntensity;
				effect.overlayBlending = overlayBlending;
				effect.overlayTexture = overlayTexture;
				effect.overlayTextureScale = overlayTextureScale;
				effect.outline = outline;
				effect.outlineColor = outlineColor;
				effect.outlineWidth = outlineWidth;
				effect.outlineQuality = outlineQuality;
				effect.outlineOptimalBlit = outlineOptimalBlit;
				effect.outlineDownsampling = outlineDownsampling;
				effect.outlineVisibility = outlineVisibility;
				effect.outlineIndependent = outlineIndependent;
				effect.glow = glow;
				effect.glowWidth = glowWidth;
				effect.glowQuality = glowQuality;
				effect.glowOptimalBlit = glowOptimalBlit;
				effect.glowDownsampling = glowDownsampling;
				effect.glowHQColor = glowHQColor;
				effect.glowDithering = glowDithering;
				effect.glowMagicNumber1 = glowMagicNumber1;
				effect.glowMagicNumber2 = glowMagicNumber2;
				effect.glowAnimationSpeed = glowAnimationSpeed;
				effect.glowVisibility = glowVisibility;
				effect.glowBlendMode = glowBlendMode;
				effect.glowBlendPasses = glowBlendPasses;
				effect.glowPasses = GetGlowPassesCopy(glowPasses);
				effect.innerGlow = innerGlow;
				effect.innerGlowWidth = innerGlowWidth;
				effect.innerGlowColor = innerGlowColor;
				effect.innerGlowVisibility = innerGlowVisibility;
				effect.targetFX = targetFX;
				effect.targetFXColor = targetFXColor;
				effect.targetFXInitialScale = targetFXInitialScale;
				effect.targetFXEndScale = targetFXEndScale;
				effect.targetFXScaleToRenderBounds = targetFXScaleToRenderBounds;
				effect.targetFXAlignToGround = targetFXAlignToGround;
				effect.targetFXGroundMaxDistance = targetFXGroundMaxDistance;
				effect.targetFXGroundLayerMask = targetFXGroundLayerMask;
				effect.targetFXFadePower = targetFXFadePower;
				effect.targetFXRotationSpeed = targetFXRotationSpeed;
				effect.targetFXStayDuration = targetFXStayDuration;
				effect.targetFXTexture = targetFXTexture;
				effect.targetFXTransitionDuration = targetFXTransitionDuration;
				effect.targetFXVisibility = targetFXVisibility;
				effect.seeThrough = seeThrough;
				effect.seeThroughOccluderMask = seeThroughOccluderMask;
				effect.seeThroughOccluderMaskAccurate = seeThroughOccluderMaskAccurate;
				effect.seeThroughOccluderThreshold = seeThroughOccluderThreshold;
				effect.seeThroughOccluderCheckInterval = seeThroughOccluderCheckInterval;
				effect.seeThroughOccluderCheckIndividualObjects = seeThroughOccluderCheckIndividualObjects;
				effect.seeThroughIntensity = seeThroughIntensity;
				effect.seeThroughTintAlpha = seeThroughTintAlpha;
				effect.seeThroughTintColor = seeThroughTintColor;
				effect.seeThroughNoise = seeThroughNoise;
				effect.seeThroughBorder = seeThroughBorder;
				effect.seeThroughBorderColor = seeThroughBorderColor;
				effect.seeThroughBorderWidth = seeThroughBorderWidth;
				effect.seeThroughDepthOffset = seeThroughDepthOffset;
				effect.seeThroughMaxDepth = seeThroughMaxDepth;
				effect.seeThroughOrdered = seeThroughOrdered;
				effect.hitFxInitialIntensity = hitFxInitialIntensity;
				effect.hitFxMode = hitFxMode;
				effect.hitFxFadeOutDuration = hitFxFadeOutDuration;
				effect.hitFxColor = hitFxColor;
				effect.hitFxRadius = hitFxRadius;
				effect.UpdateMaterialProperties();
			}

			public void Save(HighlightEffect effect)
			{
				effectGroup = effect.effectGroup;
				effectGroupLayer = effect.effectGroupLayer;
				effectNameFilter = effect.effectNameFilter;
				combineMeshes = effect.combineMeshes;
				alphaCutOff = effect.alphaCutOff;
				cullBackFaces = effect.cullBackFaces;
				depthClip = effect.depthClip;
				normalsOption = effect.normalsOption;
				fadeInDuration = effect.fadeInDuration;
				fadeOutDuration = effect.fadeOutDuration;
				constantWidth = effect.constantWidth;
				overlay = effect.overlay;
				overlayColor = effect.overlayColor;
				overlayAnimationSpeed = effect.overlayAnimationSpeed;
				overlayMinIntensity = effect.overlayMinIntensity;
				overlayBlending = effect.overlayBlending;
				overlayTexture = effect.overlayTexture;
				overlayTextureScale = effect.overlayTextureScale;
				outline = effect.outline;
				outlineColor = effect.outlineColor;
				outlineWidth = effect.outlineWidth;
				outlineQuality = effect.outlineQuality;
				outlineDownsampling = effect.outlineDownsampling;
				outlineVisibility = effect.outlineVisibility;
				outlineIndependent = effect.outlineIndependent;
				outlineOptimalBlit = effect.outlineOptimalBlit;
				glow = effect.glow;
				glowWidth = effect.glowWidth;
				glowQuality = effect.glowQuality;
				glowOptimalBlit = effect.glowOptimalBlit;
				glowDownsampling = effect.glowDownsampling;
				glowHQColor = effect.glowHQColor;
				glowDithering = effect.glowDithering;
				glowMagicNumber1 = effect.glowMagicNumber1;
				glowMagicNumber2 = effect.glowMagicNumber2;
				glowAnimationSpeed = effect.glowAnimationSpeed;
				glowVisibility = effect.glowVisibility;
				glowBlendMode = effect.glowBlendMode;
				glowBlendPasses = effect.glowBlendPasses;
				glowPasses = GetGlowPassesCopy(effect.glowPasses);
				innerGlow = effect.innerGlow;
				innerGlowWidth = effect.innerGlowWidth;
				innerGlowColor = effect.innerGlowColor;
				innerGlowVisibility = effect.innerGlowVisibility;
				targetFX = effect.targetFX;
				targetFXColor = effect.targetFXColor;
				targetFXInitialScale = effect.targetFXInitialScale;
				targetFXEndScale = effect.targetFXEndScale;
				targetFXScaleToRenderBounds = effect.targetFXScaleToRenderBounds;
				targetFXAlignToGround = effect.targetFXAlignToGround;
				targetFXGroundMaxDistance = effect.targetFXGroundMaxDistance;
				targetFXGroundLayerMask = effect.targetFXGroundLayerMask;
				targetFXFadePower = effect.targetFXFadePower;
				targetFXRotationSpeed = effect.targetFXRotationSpeed;
				targetFXStayDuration = effect.targetFXStayDuration;
				targetFXTexture = effect.targetFXTexture;
				targetFXTransitionDuration = effect.targetFXTransitionDuration;
				targetFXVisibility = effect.targetFXVisibility;
				seeThrough = effect.seeThrough;
				seeThroughOccluderMask = effect.seeThroughOccluderMask;
				seeThroughOccluderMaskAccurate = effect.seeThroughOccluderMaskAccurate;
				seeThroughOccluderThreshold = effect.seeThroughOccluderThreshold;
				seeThroughOccluderCheckInterval = effect.seeThroughOccluderCheckInterval;
				seeThroughOccluderCheckIndividualObjects = effect.seeThroughOccluderCheckIndividualObjects;
				seeThroughIntensity = effect.seeThroughIntensity;
				seeThroughTintAlpha = effect.seeThroughTintAlpha;
				seeThroughTintColor = effect.seeThroughTintColor;
				seeThroughNoise = effect.seeThroughNoise;
				seeThroughBorder = effect.seeThroughBorder;
				seeThroughBorderColor = effect.seeThroughBorderColor;
				seeThroughBorderWidth = effect.seeThroughBorderWidth;
				seeThroughDepthOffset = effect.seeThroughDepthOffset;
				seeThroughMaxDepth = effect.seeThroughMaxDepth;
				seeThroughOrdered = effect.seeThroughOrdered;
				hitFxInitialIntensity = effect.hitFxInitialIntensity;
				hitFxMode = effect.hitFxMode;
				hitFxFadeOutDuration = effect.hitFxFadeOutDuration;
				hitFxColor = effect.hitFxColor;
				hitFxRadius = effect.hitFxRadius;
			}

			private GlowPassData[] GetGlowPassesCopy(GlowPassData[] glowPasses)
			{
				if (glowPasses == null)
				{
					return new GlowPassData[0];
				}
				GlowPassData[] array = new GlowPassData[glowPasses.Length];
				for (int i = 0; i < glowPasses.Length; i++)
				{
					array[i].alpha = glowPasses[i].alpha;
					array[i].color = glowPasses[i].color;
					array[i].offset = glowPasses[i].offset;
				}
				return array;
			}

			public void OnValidate()
			{
				seeThroughDepthOffset = Mathf.Max(0f, seeThroughDepthOffset);
				seeThroughMaxDepth = Mathf.Max(0f, seeThroughMaxDepth);
				seeThroughBorderWidth = Mathf.Max(0f, seeThroughBorderWidth);
				targetFXFadePower = Mathf.Max(0f, targetFXFadePower);
				if (glowPasses == null || glowPasses.Length == 0)
				{
					glowPasses = new GlowPassData[4];
					glowPasses[0] = new GlowPassData
					{
						offset = 4f,
						alpha = 0.1f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
					glowPasses[1] = new GlowPassData
					{
						offset = 3f,
						alpha = 0.2f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
					glowPasses[2] = new GlowPassData
					{
						offset = 2f,
						alpha = 0.3f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
					glowPasses[3] = new GlowPassData
					{
						offset = 1f,
						alpha = 0.4f,
						color = new Color(0.64f, 1f, 0f, 1f)
					};
				}
			}
		}
		public struct MeshData
		{
			public Renderer renderer;

			public int subMeshCount;
		}
		public enum DetectionMethod
		{
			Stencil,
			RayCast
		}
		[ExecuteInEditMode]
		public class HighlightSeeThroughOccluder : MonoBehaviour
		{
			public DetectionMethod detectionMethod;

			[NonSerialized]
			public MeshData[] meshData;

			private List<Renderer> rr;

			private void OnEnable()
			{
				if (base.gameObject.activeInHierarchy)
				{
					Init();
				}
			}

			private void Init()
			{
				if (detectionMethod == DetectionMethod.RayCast)
				{
					HighlightEffect.RegisterOccluder(this);
					return;
				}
				if (rr == null)
				{
					rr = new List<Renderer>();
				}
				else
				{
					rr.Clear();
				}
				GetComponentsInChildren(rr);
				int count = rr.Count;
				meshData = new MeshData[count];
				for (int i = 0; i < count; i++)
				{
					meshData[i].renderer = rr[i];
					meshData[i].subMeshCount = 1;
					if (rr[i] is MeshRenderer)
					{
						MeshFilter component = rr[i].GetComponent<MeshFilter>();
						if (component != null && component.sharedMesh != null)
						{
							meshData[i].subMeshCount = component.sharedMesh.subMeshCount;
						}
					}
					else if (rr[i] is SkinnedMeshRenderer)
					{
						SkinnedMeshRenderer skinnedMeshRenderer = (SkinnedMeshRenderer)rr[i];
						meshData[i].subMeshCount = skinnedMeshRenderer.sharedMesh.subMeshCount;
					}
				}
				if (count > 0)
				{
					HighlightEffect.RegisterOccluder(this);
				}
			}

			private void OnDisable()
			{
				HighlightEffect.UnregisterOccluder(this);
			}
		}
		public enum TriggerMode
		{
			ColliderEventsOnlyOnThisObject,
			RaycastOnThisObjectAndChildren,
			Volume
		}
		public enum RayCastSource
		{
			MousePosition,
			CameraDirection
		}
		[RequireComponent(typeof(HighlightEffect))]
		[ExecuteInEditMode]
		[HelpURL("https://www.dropbox.com/s/v9qgn68ydblqz8x/Documentation.pdf?dl=0")]
		public class HighlightTrigger : MonoBehaviour
		{
			[Tooltip("Enables highlight when pointer is over this object.")]
			public bool highlightOnHover = true;

			[Tooltip("Used to trigger automatic highlighting including children objects.")]
			public TriggerMode triggerMode;

			public Camera raycastCamera;

			public RayCastSource raycastSource;

			[Tooltip("Minimum distance for target.")]
			public float minDistance;

			[Tooltip("Maximum distance for target. 0 = infinity")]
			public float maxDistance;

			[Tooltip("Blocks interaction if pointer is over an UI element")]
			public bool respectUI = true;

			public LayerMask volumeLayerMask;

			private const int MAX_RAYCAST_HITS = 100;

			[Tooltip("If the object will be selected by clicking with mouse or tapping on it.")]
			public bool selectOnClick;

			[Tooltip("Profile to use when object is selected by clicking on it.")]
			public HighlightProfile selectedProfile;

			[Tooltip("Profile to use whtn object is selected and highlighted.")]
			public HighlightProfile selectedAndHighlightedProfile;

			[Tooltip("Automatically deselects any other selected object prior selecting this one")]
			public bool singleSelection;

			[Tooltip("Toggles selection on/off when clicking object")]
			public bool toggle;

			[NonSerialized]
			public Collider[] colliders;

			private Collider currentCollider;

			private static RaycastHit[] hits;

			private HighlightEffect hb;

			public HighlightEffect highlightEffect => hb;

			public event OnObjectSelectionEvent OnObjectSelected;

			public event OnObjectSelectionEvent OnObjectUnSelected;

			public event OnObjectHighlightEvent OnObjectHighlightStart;

			public event OnObjectHighlightEvent OnObjectHighlightEnd;

			[RuntimeInitializeOnLoadMethod]
			private void DomainReloadDisabledSupport()
			{
				HighlightManager.selectedObjects.Clear();
			}

			private void OnEnable()
			{
				Init();
			}

			public void Init()
			{
				if (raycastCamera == null)
				{
					raycastCamera = HighlightManager.GetCamera();
				}
				if (triggerMode == TriggerMode.RaycastOnThisObjectAndChildren)
				{
					colliders = GetComponentsInChildren<Collider>();
				}
				if (hb == null)
				{
					hb = GetComponent<HighlightEffect>();
				}
			}

			private void Start()
			{
				if (triggerMode == TriggerMode.RaycastOnThisObjectAndChildren)
				{
					if (raycastCamera == null)
					{
						raycastCamera = HighlightManager.GetCamera();
						if (raycastCamera == null)
						{
							UnityEngine.Debug.LogError("Highlight Trigger on " + base.gameObject.name + ": no camera found!");
						}
					}
					if (colliders != null && colliders.Length != 0)
					{
						hits = new RaycastHit[100];
						StartCoroutine(DoRayCast());
					}
				}
				else if (GetComponent<Collider>() == null && GetComponent<MeshFilter>() != null)
				{
					base.gameObject.AddComponent<MeshCollider>();
				}
			}

			private IEnumerator DoRayCast()
			{
				while (triggerMode == TriggerMode.RaycastOnThisObjectAndChildren)
				{
					if (raycastCamera != null)
					{
						Ray ray;
						if (raycastSource == RayCastSource.MousePosition)
						{
							if (!CanInteract())
							{
								yield return null;
								continue;
							}
							ray = raycastCamera.ScreenPointToRay(InputProxy.mousePosition);
						}
						else
						{
							ray = new Ray(raycastCamera.transform.position, raycastCamera.transform.forward);
						}
						int num = ((!(maxDistance > 0f)) ? Physics.RaycastNonAlloc(ray, hits) : Physics.RaycastNonAlloc(ray, hits, maxDistance));
						bool flag = false;
						for (int i = 0; i < num; i++)
						{
							if (Vector3.Distance(hits[i].point, ray.origin) < minDistance)
							{
								continue;
							}
							Collider collider = hits[i].collider;
							for (int j = 0; j < colliders.Length; j++)
							{
								if (colliders[j] == collider)
								{
									flag = true;
									if (selectOnClick && InputProxy.GetMouseButtonDown(0))
									{
										ToggleSelection();
										break;
									}
									if (collider != currentCollider)
									{
										SwitchCollider(collider);
										i = num;
										break;
									}
								}
							}
						}
						if (!flag && currentCollider != null)
						{
							SwitchCollider(null);
						}
					}
					yield return null;
				}
			}

			private void SwitchCollider(Collider newCollider)
			{
				if (highlightOnHover || hb.isSelected)
				{
					currentCollider = newCollider;
					if (currentCollider != null)
					{
						Highlight(state: true);
					}
					else
					{
						Highlight(state: false);
					}
				}
			}

			private bool CanInteract()
			{
				if (respectUI && EventSystem.current != null)
				{
					if (Application.isMobilePlatform && InputProxy.touchCount > 0 && EventSystem.current.IsPointerOverGameObject(InputProxy.GetFingerIdFromTouch(0)))
					{
						return false;
					}
					if (EventSystem.current.IsPointerOverGameObject(-1))
					{
						return false;
					}
				}
				return true;
			}

			private void OnMouseDown()
			{
				if (base.isActiveAndEnabled && triggerMode == TriggerMode.ColliderEventsOnlyOnThisObject && CanInteract())
				{
					if (selectOnClick && InputProxy.GetMouseButtonDown(0))
					{
						ToggleSelection();
					}
					else
					{
						Highlight(state: true);
					}
				}
			}

			private void OnMouseEnter()
			{
				if (base.isActiveAndEnabled && triggerMode == TriggerMode.ColliderEventsOnlyOnThisObject && CanInteract())
				{
					Highlight(state: true);
				}
			}

			private void OnMouseExit()
			{
				if (base.isActiveAndEnabled && triggerMode == TriggerMode.ColliderEventsOnlyOnThisObject && CanInteract())
				{
					Highlight(state: false);
				}
			}

			private void Highlight(bool state)
			{
				if (state)
				{
					if (!hb.highlighted && this.OnObjectHighlightStart != null && hb.target != null && !this.OnObjectHighlightStart(hb.target.gameObject))
					{
						return;
					}
				}
				else if (hb.highlighted && this.OnObjectHighlightEnd != null && hb.target != null)
				{
					this.OnObjectHighlightEnd(hb.target.gameObject);
				}
				if (selectOnClick)
				{
					if (hb.isSelected)
					{
						if (state)
						{
							if (selectedAndHighlightedProfile != null)
							{
								selectedAndHighlightedProfile.Load(hb);
							}
						}
						else if (selectedProfile != null)
						{
							selectedProfile.Load(hb);
						}
						else
						{
							hb.previousSettings.Load(hb);
						}
						if (hb.highlighted)
						{
							hb.UpdateMaterialProperties();
						}
						else
						{
							hb.SetHighlighted(state: true);
						}
						return;
					}
					if (!highlightOnHover)
					{
						hb.SetHighlighted(state: false);
						return;
					}
				}
				hb.SetHighlighted(state);
			}

			private void ToggleSelection()
			{
				HighlightManager.lastTriggerTime = Time.frameCount;
				bool flag = !toggle || !hb.isSelected;
				if (flag)
				{
					if (this.OnObjectSelected != null && !this.OnObjectSelected(base.gameObject))
					{
						return;
					}
				}
				else if (this.OnObjectUnSelected != null && !this.OnObjectUnSelected(base.gameObject))
				{
					return;
				}
				if (singleSelection && flag)
				{
					HighlightManager.DeselectAll();
				}
				hb.isSelected = flag;
				if (flag && !HighlightManager.selectedObjects.Contains(hb))
				{
					HighlightManager.selectedObjects.Add(hb);
				}
				else if (!flag && HighlightManager.selectedObjects.Contains(hb))
				{
					HighlightManager.selectedObjects.Remove(hb);
				}
				if (hb.isSelected)
				{
					if (hb.previousSettings == null)
					{
						hb.previousSettings = ScriptableObject.CreateInstance<HighlightProfile>();
					}
					hb.previousSettings.Save(hb);
				}
				else if (hb.previousSettings != null)
				{
					hb.previousSettings.Load(hb);
				}
				Highlight(state: true);
			}

			public void OnTriggerEnter(Collider other)
			{
				if (triggerMode == TriggerMode.Volume && ((int)volumeLayerMask & (1 << other.gameObject.layer)) != 0)
				{
					Highlight(state: true);
				}
			}

			public void OnTriggerExit(Collider other)
			{
				if (triggerMode == TriggerMode.Volume && ((int)volumeLayerMask & (1 << other.gameObject.layer)) != 0)
				{
					Highlight(state: false);
				}
			}
		}
		public static class InputProxy
		{
			public static Vector3 mousePosition => Mouse.current.position.ReadValue();

			public static int touchCount => UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches.Count;

			public static bool GetMouseButtonDown(int buttonIndex)
			{
				return buttonIndex switch
				{
					1 => Mouse.current.rightButton.wasPressedThisFrame, 
					2 => Mouse.current.middleButton.wasPressedThisFrame, 
					_ => Mouse.current.leftButton.wasPressedThisFrame, 
				};
			}

			public static int GetFingerIdFromTouch(int touchIndex)
			{
				return UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches[touchIndex].finger.index;
			}

			public static bool GetKeyDown(string name)
			{
				return ((KeyControl)Keyboard.current[name]).wasPressedThisFrame;
			}
		}
		public static class ShaderParams
		{
			public static int Cull = Shader.PropertyToID("_Cull");

			public static int BlurScale = Shader.PropertyToID("_BlurScale");

			public static int Speed = Shader.PropertyToID("_Speed");

			public static int ConstantWidth = Shader.PropertyToID("_ConstantWidth");

			public static int CutOff = Shader.PropertyToID("_CutOff");

			public static int ZTest = Shader.PropertyToID("_ZTest");

			public static int Flip = Shader.PropertyToID("_Flip");

			public static int Debug = Shader.PropertyToID("_Debug");

			public static int Color = Shader.PropertyToID("_Color");

			public static int MainTex = Shader.PropertyToID("_MainTex");

			public static int BlendSrc = Shader.PropertyToID("_BlendSrc");

			public static int BlendDst = Shader.PropertyToID("_BlendDst");

			public static int OutlineWidth = Shader.PropertyToID("_OutlineWidth");

			public static int OutlineZTest = Shader.PropertyToID("_OutlineZTest");

			public static int OutlineDirection = Shader.PropertyToID("_OutlineDirection");

			public static int OutlineColor = Shader.PropertyToID("_OutlineColor");

			public static int OutlineVertexWidth = Shader.PropertyToID("_OutlineVertexWidth");

			public static int GlowZTest = Shader.PropertyToID("_GlowZTest");

			public static int GlowStencilOp = Shader.PropertyToID("_GlowStencilOp");

			public static int GlowDirection = Shader.PropertyToID("_GlowDirection");

			public static int Glow = Shader.PropertyToID("_Glow");

			public static int GlowColor = Shader.PropertyToID("_GlowColor");

			public static int Glow2 = Shader.PropertyToID("_Glow2");

			public static int SeeThrough = Shader.PropertyToID("_SeeThrough");

			public static int SeeThroughNoise = Shader.PropertyToID("_SeeThroughNoise");

			public static int SeeThroughBorderWidth = Shader.PropertyToID("_SeeThroughBorderWidth");

			public static int SeeThroughBorderConstantWidth = Shader.PropertyToID("_SeeThroughBorderConstantWidth");

			public static int SeeThroughTintColor = Shader.PropertyToID("_SeeThroughTintColor");

			public static int SeeThroughBorderColor = Shader.PropertyToID("_SeeThroughBorderColor");

			public static int SeeThroughStencilRef = Shader.PropertyToID("_SeeThroughStencilRef");

			public static int SeeThroughStencilComp = Shader.PropertyToID("_SeeThroughStencilComp");

			public static int SeeThroughStencilPassOp = Shader.PropertyToID("_SeeThroughStencilPassOp");

			public static int SeeThroughDepthOffset = Shader.PropertyToID("_SeeThroughDepthOffset");

			public static int SeeThroughMaxDepth = Shader.PropertyToID("_SeeThroughMaxDepth");

			public static int SeeThroughOrdered = Shader.PropertyToID("_SeeThroughOrdered");

			public static int InnerGlowWidth = Shader.PropertyToID("_InnerGlowWidth");

			public static int InnerGlowZTest = Shader.PropertyToID("_InnerGlowZTest");

			public static int InnerGlowColor = Shader.PropertyToID("_InnerGlowColor");

			public static int OverlayData = Shader.PropertyToID("_OverlayData");

			public static int OverlayBackColor = Shader.PropertyToID("_OverlayBackColor");

			public static int OverlayColor = Shader.PropertyToID("_OverlayColor");

			public static int OverlayHitPosData = Shader.PropertyToID("_OverlayHitPosData");

			public static int OverlayHitStartTime = Shader.PropertyToID("_OverlayHitStartTime");

			public static int OverlayTexture = Shader.PropertyToID("_OverlayTexture");

			public static int TargetFXRenderData = Shader.PropertyToID("_TargetFXRenderData");

			public const string SKW_ALPHACLIP = "HP_ALPHACLIP";

			public const string SKW_DEPTHCLIP = "HP_DEPTHCLIP";

			public const string SKW_DEPTH_OFFSET = "HP_DEPTH_OFFSET";

			public const string SKW_USES_OVERLAY_TEXTURE = "HP_USES_OVERLAY_TEXTURE";
		}
	}
	namespace HighlightPlus.Demos
	{
		public class HitFxDemo : MonoBehaviour
		{
			public AudioClip hitSound;

			private void Update()
			{
				if (InputProxy.GetMouseButtonDown(0) && Physics.Raycast(Camera.main.ScreenPointToRay(InputProxy.mousePosition), out var hitInfo))
				{
					HighlightEffect component = hitInfo.collider.GetComponent<HighlightEffect>();
					if (!(component == null))
					{
						AudioSource.PlayClipAtPoint(hitSound, hitInfo.point);
						component.HitFX(hitInfo.point);
					}
				}
			}
		}
		public class ManualSelectionDemo : MonoBehaviour
		{
			private HighlightManager hm;

			public Transform objectToSelect;

			private void Start()
			{
				hm = UnityEngine.Object.FindObjectOfType<HighlightManager>();
			}

			private void Update()
			{
				if (Input.GetKeyDown(KeyCode.Alpha1))
				{
					hm.SelectObject(objectToSelect);
				}
				if (Input.GetKeyDown(KeyCode.Alpha2))
				{
					hm.ToggleObject(objectToSelect);
				}
				if (Input.GetKeyDown(KeyCode.Alpha3))
				{
					hm.UnselectObject(objectToSelect);
				}
			}
		}
		public class SphereHighlightEventExample : MonoBehaviour
		{
			private HighlightEffect effect;

			private void Start()
			{
				effect = GetComponent<HighlightEffect>();
				effect.OnObjectHighlightStart += ValidateHighlightObject;
			}

			private bool ValidateHighlightObject(GameObject obj)
			{
				return true;
			}

			private void HighlightStart()
			{
				UnityEngine.Debug.Log("Gold sphere highlighted!");
			}

			private void HighlightEnd()
			{
				UnityEngine.Debug.Log("Gold sphere not highlighted!");
			}

			private void Update()
			{
				if (InputProxy.GetKeyDown("space"))
				{
					effect.HitFX(Color.white, 0.2f);
				}
				if (InputProxy.GetKeyDown("c"))
				{
					effect.SetGlowColor(new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value));
				}
			}
		}
		public class SphereSelectionEventsExample : MonoBehaviour
		{
			private void Start()
			{
				HighlightManager.instance.OnObjectSelected += OnObjectSelected;
				HighlightManager.instance.OnObjectUnSelected += OnObjectUnSelected;
			}

			private bool OnObjectSelected(GameObject go)
			{
				UnityEngine.Debug.Log(go.name + " selected!");
				return true;
			}

			private bool OnObjectUnSelected(GameObject go)
			{
				UnityEngine.Debug.Log(go.name + " un-selected!");
				return true;
			}
		}
	}
	namespace FogVolumeUtilities
	{
		public static class ExtensionMethods
		{
			public static float Remap(this float value, float from1, float to1, float from2, float to2)
			{
				return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
			}

			public static bool TimeSnap(int Frames)
			{
				if (Application.isPlaying)
				{
					if (Time.frameCount > 3)
					{
						return Time.frameCount % (1 + Frames) == 0;
					}
					return true;
				}
				return true;
			}

			public static void Swap<T>(ref T lhs, ref T rhs)
			{
				T val = lhs;
				lhs = rhs;
				rhs = val;
			}
		}
		public class Rendering
		{
			public static void EnsureKeyword(Material material, string name, bool enabled)
			{
				if (enabled != material.IsKeywordEnabled(name))
				{
					if (enabled)
					{
						material.EnableKeyword(name);
					}
					else
					{
						material.DisableKeyword(name);
					}
				}
			}
		}
		public struct int2
		{
			public int x;

			public int y;

			public int2(int x, int y)
			{
				this.x = x;
				this.y = y;
			}
		}
		public static class EditorExtension
		{
			private static string[] m_LayerNames;

			private static int[] m_LayerMasks;

			static EditorExtension()
			{
				List<string> list = new List<string>();
				List<int> list2 = new List<int>();
				for (int i = 0; i < 32; i++)
				{
					try
					{
						string text = LayerMask.LayerToName(i);
						if (text != "")
						{
							list.Add(text);
							list2.Add(1 << i);
						}
					}
					catch
					{
					}
				}
				m_LayerNames = list.ToArray();
				m_LayerMasks = list2.ToArray();
			}

			public static void ToggleInHierarchy(UnityEngine.Object obj, bool visible)
			{
			}
		}
	}
	namespace FogVolumePlaydeadTAA
	{
		public abstract class EffectBase : MonoBehaviour
		{
			public void EnsureArray<T>(ref T[] array, int size, T initialValue = default(T))
			{
				if (array == null || array.Length != size)
				{
					array = new T[size];
					for (int i = 0; i != size; i++)
					{
						array[i] = initialValue;
					}
				}
			}

			public void EnsureArray<T>(ref T[,] array, int size0, int size1, T defaultValue = default(T))
			{
				if (array != null && array.Length == size0 * size1)
				{
					return;
				}
				array = new T[size0, size1];
				for (int i = 0; i != size0; i++)
				{
					for (int j = 0; j != size1; j++)
					{
						array[i, j] = defaultValue;
					}
				}
			}

			public void EnsureMaterial(ref Material material, Shader shader)
			{
				if (shader != null)
				{
					if (material == null || material.shader != shader)
					{
						material = new Material(shader);
					}
					if (material != null)
					{
						material.hideFlags = HideFlags.DontSave;
					}
				}
				else
				{
					UnityEngine.Debug.LogWarning("missing shader", this);
				}
			}

			public void EnsureDepthTexture(Camera camera)
			{
				if ((camera.depthTextureMode & DepthTextureMode.Depth) == 0)
				{
					camera.depthTextureMode |= DepthTextureMode.Depth;
				}
			}

			public void EnsureKeyword(Material material, string name, bool enabled)
			{
				if (enabled != material.IsKeywordEnabled(name))
				{
					if (enabled)
					{
						material.EnableKeyword(name);
					}
					else
					{
						material.DisableKeyword(name);
					}
				}
			}

			public bool EnsureRenderTarget(ref RenderTexture rt, int width, int height, RenderTextureFormat format, FilterMode filterMode, int depthBits = 0, int antiAliasing = 1)
			{
				if (rt != null && (rt.width != width || rt.height != height || rt.format != format || rt.filterMode != filterMode || rt.antiAliasing != antiAliasing))
				{
					RenderTexture.ReleaseTemporary(rt);
					rt = null;
				}
				if (rt == null)
				{
					rt = RenderTexture.GetTemporary(width, height, depthBits, format, RenderTextureReadWrite.Default, antiAliasing);
					rt.filterMode = filterMode;
					rt.wrapMode = TextureWrapMode.Clamp;
					return true;
				}
				return false;
			}

			public void ReleaseRenderTarget(ref RenderTexture rt)
			{
				if (rt != null)
				{
					RenderTexture.ReleaseTemporary(rt);
					rt = null;
				}
			}

			public void DrawFullscreenQuad()
			{
				GL.PushMatrix();
				GL.LoadOrtho();
				GL.Begin(7);
				GL.MultiTexCoord2(0, 0f, 0f);
				GL.Vertex3(0f, 0f, 0f);
				GL.MultiTexCoord2(0, 1f, 0f);
				GL.Vertex3(1f, 0f, 0f);
				GL.MultiTexCoord2(0, 1f, 1f);
				GL.Vertex3(1f, 1f, 0f);
				GL.MultiTexCoord2(0, 0f, 1f);
				GL.Vertex3(0f, 1f, 0f);
				GL.End();
				GL.PopMatrix();
			}
		}
		public static class Vector2Extension
		{
			public static float SignedAngle(this Vector2 v1, Vector2 v2)
			{
				Vector2 normalized = v1.normalized;
				Vector2 normalized2 = v2.normalized;
				float num = Vector2.Dot(normalized, normalized2);
				if (num > 1f)
				{
					num = 1f;
				}
				if (num < -1f)
				{
					num = -1f;
				}
				float num2 = Mathf.Acos(num);
				if (Vector2.Dot(new Vector2(0f - normalized.y, normalized.x), normalized2) >= 0f)
				{
					return num2;
				}
				return 0f - num2;
			}

			public static Vector2 Rotate(this Vector2 v, float theta)
			{
				float num = Mathf.Cos(theta);
				float num2 = Mathf.Sin(theta);
				float x = v.x * num - v.y * num2;
				float y = v.x * num2 + v.y * num;
				return new Vector2(x, y);
			}
		}
		public static class Vector3Extension
		{
			public static Vector3 WithX(this Vector3 v, float x)
			{
				return new Vector3(x, v.y, v.z);
			}

			public static Vector3 WithY(this Vector3 v, float y)
			{
				return new Vector3(v.x, y, v.z);
			}

			public static Vector3 WithZ(this Vector3 v, float z)
			{
				return new Vector3(v.x, v.y, z);
			}
		}
		public static class Matrix4x4Extension
		{
			public static Matrix4x4 GetPerspectiveProjection(float left, float right, float bottom, float top, float near, float far)
			{
				float value = 2f * near / (right - left);
				float value2 = 2f * near / (top - bottom);
				float value3 = (right + left) / (right - left);
				float value4 = (top + bottom) / (top - bottom);
				float value5 = (0f - (far + near)) / (far - near);
				float value6 = (0f - 2f * far * near) / (far - near);
				float value7 = -1f;
				Matrix4x4 result = default(Matrix4x4);
				result[0, 0] = value;
				result[0, 1] = 0f;
				result[0, 2] = value3;
				result[0, 3] = 0f;
				result[1, 0] = 0f;
				result[1, 1] = value2;
				result[1, 2] = value4;
				result[1, 3] = 0f;
				result[2, 0] = 0f;
				result[2, 1] = 0f;
				result[2, 2] = value5;
				result[2, 3] = value6;
				result[3, 0] = 0f;
				result[3, 1] = 0f;
				result[3, 2] = value7;
				result[3, 3] = 0f;
				return result;
			}

			public static Matrix4x4 GetOrthographicProjection(float left, float right, float bottom, float top, float near, float far)
			{
				float value = 2f / (right - left);
				float value2 = 2f / (top - bottom);
				float value3 = -2f / (far - near);
				float value4 = (0f - (right + left)) / (right - left);
				float value5 = (0f - (top + bottom)) / (top - bottom);
				float value6 = (0f - (far + near)) / (far - near);
				float value7 = 1f;
				Matrix4x4 result = default(Matrix4x4);
				result[0, 0] = value;
				result[0, 1] = 0f;
				result[0, 2] = 0f;
				result[0, 3] = value4;
				result[1, 0] = 0f;
				result[1, 1] = value2;
				result[1, 2] = 0f;
				result[1, 3] = value5;
				result[2, 0] = 0f;
				result[2, 1] = 0f;
				result[2, 2] = value3;
				result[2, 3] = value6;
				result[3, 0] = 0f;
				result[3, 1] = 0f;
				result[3, 2] = 0f;
				result[3, 3] = value7;
				return result;
			}
		}
		public static class CameraExtension
		{
			public static Vector4 GetProjectionExtents(this Camera camera)
			{
				return camera.GetProjectionExtents(0f, 0f);
			}

			public static Vector4 GetProjectionExtents(this Camera camera, float texelOffsetX, float texelOffsetY)
			{
				if (camera == null)
				{
					return Vector4.zero;
				}
				float num = (camera.orthographic ? camera.orthographicSize : Mathf.Tan((float)Math.PI / 360f * camera.fieldOfView));
				float num2 = num * camera.aspect;
				float num3 = num2 / (0.5f * (float)camera.pixelWidth);
				float num4 = num / (0.5f * (float)camera.pixelHeight);
				float z = num3 * texelOffsetX;
				float w = num4 * texelOffsetY;
				return new Vector4(num2, num, z, w);
			}

			public static Vector4 GetProjectionExtents(this Camera camera, Camera.StereoscopicEye eye)
			{
				return camera.GetProjectionExtents(eye, 0f, 0f);
			}

			public static Vector4 GetProjectionExtents(this Camera camera, Camera.StereoscopicEye eye, float texelOffsetX, float texelOffsetY)
			{
				Matrix4x4 matrix4x = Matrix4x4.Inverse(camera.GetStereoProjectionMatrix(eye));
				Vector3 vector = matrix4x.MultiplyPoint3x4(new Vector3(-1f, -1f, 0.95f));
				Vector3 vector2 = matrix4x.MultiplyPoint3x4(new Vector3(1f, 1f, 0.95f));
				vector /= 0f - vector.z;
				vector2 /= 0f - vector2.z;
				float num = 0.5f * (vector2.x - vector.x);
				float num2 = 0.5f * (vector2.y - vector.y);
				float num3 = num / (0.5f * (float)camera.pixelWidth);
				float num4 = num2 / (0.5f * (float)camera.pixelHeight);
				float z = 0.5f * (vector2.x + vector.x) + num3 * texelOffsetX;
				float w = 0.5f * (vector2.y + vector.y) + num4 * texelOffsetY;
				return new Vector4(num, num2, z, w);
			}

			public static Matrix4x4 GetProjectionMatrix(this Camera camera)
			{
				return camera.GetProjectionMatrix(0f, 0f);
			}

			public static Matrix4x4 GetProjectionMatrix(this Camera camera, float texelOffsetX, float texelOffsetY)
			{
				if (camera == null)
				{
					return Matrix4x4.identity;
				}
				Vector4 projectionExtents = camera.GetProjectionExtents(texelOffsetX, texelOffsetY);
				float farClipPlane = camera.farClipPlane;
				float nearClipPlane = camera.nearClipPlane;
				float num = projectionExtents.z - projectionExtents.x;
				float num2 = projectionExtents.z + projectionExtents.x;
				float num3 = projectionExtents.w - projectionExtents.y;
				float num4 = projectionExtents.w + projectionExtents.y;
				if (camera.orthographic)
				{
					return Matrix4x4Extension.GetOrthographicProjection(num, num2, num3, num4, nearClipPlane, farClipPlane);
				}
				return Matrix4x4Extension.GetPerspectiveProjection(num * nearClipPlane, num2 * nearClipPlane, num3 * nearClipPlane, num4 * nearClipPlane, nearClipPlane, farClipPlane);
			}
		}
		public class FrustumJitter : MonoBehaviour
		{
			public enum Pattern
			{
				Still,
				Uniform2,
				Uniform4,
				Uniform4_Helix,
				Uniform4_DoubleHelix,
				SkewButterfly,
				Rotated4,
				Rotated4_Helix,
				Rotated4_Helix2,
				Poisson10,
				Pentagram,
				Halton_2_3_X8,
				Halton_2_3_X16,
				Halton_2_3_X32,
				Halton_2_3_X256,
				MotionPerp2
			}

			private static float[] points_Still;

			private static float[] points_Uniform2;

			private static float[] points_Uniform4;

			private static float[] points_Uniform4_Helix;

			private static float[] points_Uniform4_DoubleHelix;

			private static float[] points_SkewButterfly;

			private static float[] points_Rotated4;

			private static float[] points_Rotated4_Helix;

			private static float[] points_Rotated4_Helix2;

			private static float[] points_Poisson10;

			private static float[] points_Pentagram;

			private static float[] points_Halton_2_3_x8;

			private static float[] points_Halton_2_3_x16;

			private static float[] points_Halton_2_3_x32;

			private static float[] points_Halton_2_3_x256;

			private static float[] points_MotionPerp2;

			private Camera _camera;

			private Vector3 focalMotionPos = Vector3.zero;

			private Vector3 focalMotionDir = Vector3.right;

			public Pattern pattern = Pattern.Halton_2_3_X16;

			public float patternScale = 0.2f;

			public Vector4 activeSample = Vector4.zero;

			public int activeIndex = -2;

			private static void TransformPattern(float[] seq, float theta, float scale)
			{
				float num = Mathf.Cos(theta);
				float num2 = Mathf.Sin(theta);
				int num3 = 0;
				int num4 = 1;
				int num5 = seq.Length;
				while (num3 != num5)
				{
					float num6 = scale * seq[num3];
					float num7 = scale * seq[num4];
					seq[num3] = num6 * num - num7 * num2;
					seq[num4] = num6 * num2 + num7 * num;
					num3 += 2;
					num4 += 2;
				}
			}

			private static float HaltonSeq(int prime, int index = 1)
			{
				float num = 0f;
				float num2 = 1f;
				for (int num3 = index; num3 > 0; num3 = (int)Mathf.Floor((float)num3 / (float)prime))
				{
					num2 /= (float)prime;
					num += num2 * (float)(num3 % prime);
				}
				return num;
			}

			private static void InitializeHalton_2_3(float[] seq)
			{
				int i = 0;
				for (int num = seq.Length / 2; i != num; i++)
				{
					float num2 = HaltonSeq(2, i + 1) - 0.5f;
					float num3 = HaltonSeq(3, i + 1) - 0.5f;
					seq[2 * i] = num2;
					seq[2 * i + 1] = num3;
				}
			}

			static FrustumJitter()
			{
				points_Still = new float[2] { 0.5f, 0.5f };
				points_Uniform2 = new float[4] { -0.25f, -0.25f, 0.25f, 0.25f };
				points_Uniform4 = new float[8] { -0.25f, -0.25f, 0.25f, -0.25f, 0.25f, 0.25f, -0.25f, 0.25f };
				points_Uniform4_Helix = new float[8] { -0.25f, -0.25f, 0.25f, 0.25f, 0.25f, -0.25f, -0.25f, 0.25f };
				points_Uniform4_DoubleHelix = new float[16]
				{
					-0.25f, -0.25f, 0.25f, 0.25f, 0.25f, -0.25f, -0.25f, 0.25f, -0.25f, -0.25f,
					0.25f, -0.25f, -0.25f, 0.25f, 0.25f, 0.25f
				};
				points_SkewButterfly = new float[8] { -0.25f, -0.25f, 0.25f, 0.25f, 0.125f, -0.125f, -0.125f, 0.125f };
				points_Rotated4 = new float[8] { -0.125f, -0.375f, 0.375f, -0.125f, 0.125f, 0.375f, -0.375f, 0.125f };
				points_Rotated4_Helix = new float[8] { -0.125f, -0.375f, 0.125f, 0.375f, 0.375f, -0.125f, -0.375f, 0.125f };
				points_Rotated4_Helix2 = new float[8] { -0.125f, -0.375f, 0.125f, 0.375f, -0.375f, 0.125f, 0.375f, -0.125f };
				points_Poisson10 = new float[20]
				{
					-0.0419899f, 0.16386227f, -0.17274007f, 0.14753993f, 0.12460955f, 0.2077493f, 0.043075375f, -0.009706758f, -0.15193167f, -0.015033968f,
					0.16401598f, 0.060019f, 0.20087093f, -0.12024225f, 0.08359135f, -0.18251757f, -0.1195988f, -0.14001325f, -0.0309703f, -0.24158497f
				};
				points_Pentagram = new float[10] { 0f, 0.2628655f, -0.1545085f, -0.2126625f, 0.25f, 0.08123f, -0.25f, 0.08123f, 0.1545085f, -0.2126625f };
				points_Halton_2_3_x8 = new float[16];
				points_Halton_2_3_x16 = new float[32];
				points_Halton_2_3_x32 = new float[64];
				points_Halton_2_3_x256 = new float[512];
				points_MotionPerp2 = new float[4] { 0f, -0.25f, 0f, 0.25f };
				TransformPattern(theta: (float)Math.PI / 180f * (0.5f * Vector2.Angle(to: new Vector2(points_Pentagram[0] - points_Pentagram[2], points_Pentagram[1] - points_Pentagram[3]), from: new Vector2(0f, 1f))), seq: points_Pentagram, scale: 1f);
				InitializeHalton_2_3(points_Halton_2_3_x8);
				InitializeHalton_2_3(points_Halton_2_3_x16);
				InitializeHalton_2_3(points_Halton_2_3_x32);
				InitializeHalton_2_3(points_Halton_2_3_x256);
			}

			private static float[] AccessPointData(Pattern pattern)
			{
				switch (pattern)
				{
				case Pattern.Still:
					return points_Still;
				case Pattern.Uniform2:
					return points_Uniform2;
				case Pattern.Uniform4:
					return points_Uniform4;
				case Pattern.Uniform4_Helix:
					return points_Uniform4_Helix;
				case Pattern.Uniform4_DoubleHelix:
					return points_Uniform4_DoubleHelix;
				case Pattern.SkewButterfly:
					return points_SkewButterfly;
				case Pattern.Rotated4:
					return points_Rotated4;
				case Pattern.Rotated4_Helix:
					return points_Rotated4_Helix;
				case Pattern.Rotated4_Helix2:
					return points_Rotated4_Helix2;
				case Pattern.Poisson10:
					return points_Poisson10;
				case Pattern.Pentagram:
					return points_Pentagram;
				case Pattern.Halton_2_3_X8:
					return points_Halton_2_3_x8;
				case Pattern.Halton_2_3_X16:
					return points_Halton_2_3_x16;
				case Pattern.Halton_2_3_X32:
					return points_Halton_2_3_x32;
				case Pattern.Halton_2_3_X256:
					return points_Halton_2_3_x256;
				case Pattern.MotionPerp2:
					return points_MotionPerp2;
				default:
					UnityEngine.Debug.LogError("missing point distribution");
					return points_Halton_2_3_x16;
				}
			}

			public static int AccessLength(Pattern pattern)
			{
				return AccessPointData(pattern).Length / 2;
			}

			public Vector2 Sample(Pattern pattern, int index)
			{
				float[] array = AccessPointData(pattern);
				int num = array.Length / 2;
				int num2 = index % num;
				float x = patternScale * array[2 * num2];
				float y = patternScale * array[2 * num2 + 1];
				if (pattern != Pattern.MotionPerp2)
				{
					return new Vector2(x, y);
				}
				return new Vector2(x, y).Rotate(Vector2.right.SignedAngle(focalMotionDir));
			}

			private void Reset()
			{
				_camera = GetComponent<Camera>();
			}

			private void Clear()
			{
				_camera.ResetProjectionMatrix();
				activeSample = Vector4.zero;
				activeIndex = -2;
			}

			private void Awake()
			{
				Reset();
				Clear();
			}

			private void OnPreCull()
			{
				Vector3 vector = focalMotionPos;
				Vector3 vector2 = _camera.transform.TransformVector(_camera.nearClipPlane * Vector3.forward);
				Vector3 vector3 = _camera.worldToCameraMatrix * vector;
				Vector3 vector4 = ((Vector3)(_camera.worldToCameraMatrix * vector2) - vector3).WithZ(0f);
				float magnitude = vector4.magnitude;
				if (magnitude != 0f)
				{
					Vector3 b = vector4 / magnitude;
					if (b.sqrMagnitude != 0f)
					{
						focalMotionPos = vector2;
						focalMotionDir = Vector3.Slerp(focalMotionDir, b, 0.2f);
					}
				}
				if (_camera.stereoEnabled)
				{
					Clear();
					return;
				}
				if (activeIndex == -2)
				{
					activeSample = Vector4.zero;
					activeIndex++;
					_camera.projectionMatrix = _camera.GetProjectionMatrix();
					return;
				}
				activeIndex++;
				activeIndex %= AccessLength(pattern);
				Vector2 vector5 = Sample(pattern, activeIndex);
				activeSample.z = activeSample.x;
				activeSample.w = activeSample.y;
				activeSample.x = vector5.x;
				activeSample.y = vector5.y;
				_camera.projectionMatrix = _camera.GetProjectionMatrix(vector5.x, vector5.y);
			}

			private void OnDisable()
			{
				Clear();
			}
		}
		public class VelocityBuffer : EffectBase
		{
			public enum NeighborMaxSupport
			{
				TileSize10,
				TileSize20,
				TileSize40
			}

			private const RenderTextureFormat velocityFormat = RenderTextureFormat.RGFloat;

			private Camera _camera;

			private FrustumJitter _frustumJitter;

			public Shader velocityShader;

			private Material velocityMaterial;

			private RenderTexture[] velocityBuffer;

			private RenderTexture[] velocityNeighborMax;

			private bool[] paramInitialized;

			private Vector4[] paramProjectionExtents;

			private Matrix4x4[] paramCurrV;

			private Matrix4x4[] paramCurrVP;

			private Matrix4x4[] paramPrevVP;

			private Matrix4x4[] paramPrevVP_NoFlip;

			private int activeEyeIndex = -1;

			public bool neighborMaxGen;

			public NeighborMaxSupport neighborMaxSupport = NeighborMaxSupport.TileSize20;

			public RenderTexture activeVelocityBuffer
			{
				get
				{
					if (activeEyeIndex == -1)
					{
						return null;
					}
					return velocityBuffer[activeEyeIndex];
				}
			}

			public RenderTexture activeVelocityNeighborMax
			{
				get
				{
					if (activeEyeIndex == -1)
					{
						return null;
					}
					return velocityNeighborMax[activeEyeIndex];
				}
			}

			private void Reset()
			{
				_camera = GetComponent<Camera>();
				_frustumJitter = GetComponent<FrustumJitter>();
			}

			private void Clear()
			{
				EnsureArray(ref paramInitialized, 2, initialValue: false);
				paramInitialized[0] = false;
				paramInitialized[1] = false;
			}

			private void OnEnable()
			{
				velocityShader = Shader.Find("Hidden/VelocityBuffer");
				Reset();
			}

			private void Awake()
			{
				Reset();
				Clear();
			}

			private void OnPreRender()
			{
			}

			public void GenerateVelocityBuffer()
			{
				EnsureArray(ref velocityBuffer, 2);
				EnsureArray(ref velocityNeighborMax, 2);
				EnsureArray(ref paramInitialized, 2, initialValue: false);
				EnsureArray(ref paramProjectionExtents, 2);
				EnsureArray(ref paramCurrV, 2);
				EnsureArray(ref paramCurrVP, 2);
				EnsureArray(ref paramPrevVP, 2);
				EnsureArray(ref paramPrevVP_NoFlip, 2);
				EnsureMaterial(ref velocityMaterial, velocityShader);
				if (velocityMaterial == null)
				{
					return;
				}
				if (_camera == null)
				{
					_camera = GetComponent<Camera>();
				}
				if (_frustumJitter == null)
				{
					_frustumJitter = GetComponent<FrustumJitter>();
				}
				int num = 0;
				num = ((_camera.stereoActiveEye == Camera.MonoOrStereoscopicEye.Right) ? 1 : 0);
				int pixelWidth = _camera.pixelWidth;
				int pixelHeight = _camera.pixelHeight;
				if (EnsureRenderTarget(ref velocityBuffer[num], pixelWidth, pixelHeight, RenderTextureFormat.RGFloat, FilterMode.Point, 16))
				{
					Clear();
				}
				EnsureKeyword(velocityMaterial, "CAMERA_PERSPECTIVE", !_camera.orthographic);
				EnsureKeyword(velocityMaterial, "CAMERA_ORTHOGRAPHIC", _camera.orthographic);
				EnsureKeyword(velocityMaterial, "TILESIZE_10", neighborMaxSupport == NeighborMaxSupport.TileSize10);
				EnsureKeyword(velocityMaterial, "TILESIZE_20", neighborMaxSupport == NeighborMaxSupport.TileSize20);
				EnsureKeyword(velocityMaterial, "TILESIZE_40", neighborMaxSupport == NeighborMaxSupport.TileSize40);
				if (_camera.stereoEnabled)
				{
					for (int i = 0; i != 2; i++)
					{
						Camera.StereoscopicEye eye = (Camera.StereoscopicEye)i;
						Matrix4x4 stereoViewMatrix = _camera.GetStereoViewMatrix(eye);
						Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.GetStereoProjectionMatrix(eye), renderIntoTexture: true);
						Matrix4x4 gPUProjectionMatrix2 = GL.GetGPUProjectionMatrix(_camera.GetStereoProjectionMatrix(eye), renderIntoTexture: false);
						Matrix4x4 matrix4x = (paramInitialized[i] ? paramCurrV[i] : stereoViewMatrix);
						paramInitialized[i] = true;
						paramProjectionExtents[i] = _camera.GetProjectionExtents(eye);
						paramCurrV[i] = stereoViewMatrix;
						paramCurrVP[i] = gPUProjectionMatrix * stereoViewMatrix;
						paramPrevVP[i] = gPUProjectionMatrix * matrix4x;
						paramPrevVP_NoFlip[i] = gPUProjectionMatrix2 * matrix4x;
					}
				}
				else
				{
					Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
					Matrix4x4 gPUProjectionMatrix3 = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
					Matrix4x4 gPUProjectionMatrix4 = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: false);
					Matrix4x4 matrix4x2 = (paramInitialized[0] ? paramCurrV[0] : worldToCameraMatrix);
					paramInitialized[0] = true;
					paramProjectionExtents[0] = (_frustumJitter.enabled ? _camera.GetProjectionExtents(_frustumJitter.activeSample.x, _frustumJitter.activeSample.y) : _camera.GetProjectionExtents());
					paramCurrV[0] = worldToCameraMatrix;
					paramCurrVP[0] = gPUProjectionMatrix3 * worldToCameraMatrix;
					paramPrevVP[0] = gPUProjectionMatrix3 * matrix4x2;
					paramPrevVP_NoFlip[0] = gPUProjectionMatrix4 * matrix4x2;
				}
				RenderTexture active = RenderTexture.active;
				RenderTexture.active = velocityBuffer[num];
				GL.Clear(clearDepth: true, clearColor: true, Color.black);
				velocityMaterial.SetVectorArray("_ProjectionExtents", paramProjectionExtents);
				velocityMaterial.SetMatrixArray("_CurrV", paramCurrV);
				velocityMaterial.SetMatrixArray("_CurrVP", paramCurrVP);
				velocityMaterial.SetMatrixArray("_PrevVP", paramPrevVP);
				velocityMaterial.SetMatrixArray("_PrevVP_NoFlip", paramPrevVP_NoFlip);
				velocityMaterial.SetPass(0);
				DrawFullscreenQuad();
				if (neighborMaxGen)
				{
					int num2 = 1;
					switch (neighborMaxSupport)
					{
					case NeighborMaxSupport.TileSize10:
						num2 = 10;
						break;
					case NeighborMaxSupport.TileSize20:
						num2 = 20;
						break;
					case NeighborMaxSupport.TileSize40:
						num2 = 40;
						break;
					}
					int num3 = pixelWidth / num2;
					int num4 = pixelHeight / num2;
					EnsureRenderTarget(ref velocityNeighborMax[num], num3, num4, RenderTextureFormat.RGFloat, FilterMode.Bilinear);
					RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(num3, num4, 0, RenderTextureFormat.RGFloat));
					velocityMaterial.SetTexture("_VelocityTex", velocityBuffer[num]);
					velocityMaterial.SetVector("_VelocityTex_TexelSize", new Vector4(1f / (float)pixelWidth, 1f / (float)pixelHeight, 0f, 0f));
					velocityMaterial.SetPass(3);
					DrawFullscreenQuad();
					RenderTexture.active = velocityNeighborMax[num];
					velocityMaterial.SetTexture("_VelocityTex", renderTexture);
					velocityMaterial.SetVector("_VelocityTex_TexelSize", new Vector4(1f / (float)num3, 1f / (float)num4, 0f, 0f));
					velocityMaterial.SetPass(4);
					DrawFullscreenQuad();
					RenderTexture.ReleaseTemporary(renderTexture);
				}
				else
				{
					ReleaseRenderTarget(ref velocityNeighborMax[0]);
					ReleaseRenderTarget(ref velocityNeighborMax[1]);
				}
				RenderTexture.active = active;
				activeEyeIndex = num;
			}

			private void OnDisable()
			{
				if (velocityBuffer != null)
				{
					ReleaseRenderTarget(ref velocityBuffer[0]);
					ReleaseRenderTarget(ref velocityBuffer[1]);
				}
				if (velocityNeighborMax != null)
				{
					ReleaseRenderTarget(ref velocityNeighborMax[0]);
					ReleaseRenderTarget(ref velocityNeighborMax[1]);
				}
			}
		}
	}
	namespace FogVolumeRenderPriority
	{
		[ExecuteInEditMode]
		public class RenderPriority : MonoBehaviour
		{
			public int DrawOrder;

			public bool UpdateRealTime;

			private void OnEnable()
			{
				base.gameObject.GetComponent<Renderer>().sortingOrder = DrawOrder;
			}

			private void Update()
			{
				if (UpdateRealTime)
				{
					base.gameObject.GetComponent<Renderer>().sortingOrder = DrawOrder;
				}
			}
		}
	}
	namespace FogVolumeUtils.FPSCounter
	{
		[RequireComponent(typeof(Text))]
		public class FPSCounter : MonoBehaviour
		{
			private const float fpsMeasurePeriod = 0.5f;

			private int m_FpsAccumulator;

			private float m_FpsNextPeriod;

			private int m_CurrentFps;

			private const string display = "{0} FPS";

			private Text m_Text;

			private void Start()
			{
				m_FpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
				m_Text = GetComponent<Text>();
			}

			private void Update()
			{
				m_FpsAccumulator++;
				if (Time.realtimeSinceStartup > m_FpsNextPeriod)
				{
					m_CurrentFps = (int)((float)m_FpsAccumulator / 0.5f);
					m_FpsAccumulator = 0;
					m_FpsNextPeriod += 0.5f;
					m_Text.text = $"{m_CurrentFps} FPS";
				}
			}
		}
	}
	namespace UltimatePolyFantasy
	{
		public class PathMovement : MonoBehaviour
		{
			public WaypointPath pathToFollow;

			public int currentWayPointID;

			public float moveSpeed;

			public float reach = 1f;

			public float rotationSpeed = 0.5f;

			public string pathName;

			private Vector3 lastPosition;

			private Vector3 currentPosition;

			private void Start()
			{
				lastPosition = base.transform.position;
			}

			private void Update()
			{
				float num = Vector3.Distance(pathToFollow.pathPoints[currentWayPointID].position, base.transform.position);
				base.transform.position = Vector3.MoveTowards(base.transform.position, pathToFollow.pathPoints[currentWayPointID].position, Time.deltaTime * moveSpeed);
				Quaternion b = Quaternion.LookRotation(pathToFollow.pathPoints[currentWayPointID].position - base.transform.position);
				base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, Time.deltaTime * rotationSpeed);
				if (num <= reach)
				{
					currentWayPointID++;
				}
				if (currentWayPointID >= pathToFollow.pathPoints.Count)
				{
					currentWayPointID = 0;
				}
			}
		}
		public class Rotator2 : MonoBehaviour
		{
			public float x;

			public float y;

			public float z;

			private void Update()
			{
				base.transform.Rotate(x, y, z);
			}
		}
		public class WaypointPath : MonoBehaviour
		{
			public Color rayColor = Color.white;

			public List<Transform> pathPoints = new List<Transform>();

			private Transform[] theArray;

			private void OnDrawGizmos()
			{
				Gizmos.color = rayColor;
				theArray = GetComponentsInChildren<Transform>();
				pathPoints.Clear();
				Transform[] array = theArray;
				foreach (Transform transform in array)
				{
					if (transform != base.transform)
					{
						pathPoints.Add(transform);
					}
				}
				for (int j = 0; j < pathPoints.Count; j++)
				{
					Vector3 position = pathPoints[j].position;
					if (j > 0)
					{
						Gizmos.DrawLine(pathPoints[j - 1].position, position);
						Gizmos.DrawSphere(position, 0.4f);
					}
				}
			}

			private void Start()
			{
			}

			private void Update()
			{
			}
		}
	}
	namespace TornadoBanditsStudio.LowPolyDungeonPack
	{
		public class TBS_Banner_Movement : MonoBehaviour
		{
			[Header("Waves settings")]
			public float waveHeight = 0.1f;

			public float speed = 1f;

			public float waveLength = 1f;

			[Header("Randomize variables")]
			public float randomHeight = 0.2f;

			public float randomSpeed = 5f;

			public float noiseOffset = 20f;

			private Vector3[] baseHeight;

			private Vector3[] vertices;

			private List<float> perVertexRandoms = new List<float>();

			private Mesh mesh;

			private void Awake()
			{
				mesh = GetComponent<MeshFilter>().mesh;
				if (baseHeight == null)
				{
					baseHeight = mesh.vertices;
				}
				for (int i = 0; i < baseHeight.Length; i++)
				{
					perVertexRandoms.Add(UnityEngine.Random.value * randomHeight);
				}
			}

			private void Update()
			{
				if (vertices == null)
				{
					vertices = new Vector3[baseHeight.Length];
				}
				for (int i = 0; i < vertices.Length; i++)
				{
					Vector3 vector = baseHeight[i];
					UnityEngine.Random.seed = (int)((vector.x + noiseOffset) * (vector.x + noiseOffset) + (vector.z + noiseOffset) * (vector.z + noiseOffset));
					vector.z += Mathf.Sin(Time.time * speed + baseHeight[i].x * waveLength + baseHeight[i].z * waveLength) * waveHeight;
					vector.z += Mathf.Sin(Mathf.Cos(UnityEngine.Random.value * 1f) * randomHeight * Mathf.Cos(Time.time * randomSpeed * Mathf.Sin(UnityEngine.Random.value * 1f)));
					vertices[i] = vector;
				}
				mesh.vertices = vertices;
				mesh.RecalculateNormals();
			}
		}
		public class TBS_CameraMovement : MonoBehaviour
		{
			[SerializeField]
			private Vector3 targePosition;

			private Vector3 startPostion;

			[SerializeField]
			private float duration = 25f;

			private IEnumerator Start()
			{
				startPostion = base.transform.position;
				while (true)
				{
					yield return StartCoroutine(MoveCamera(startPostion, targePosition));
					yield return StartCoroutine(MoveCamera(targePosition, startPostion));
				}
			}

			private IEnumerator MoveCamera(Vector3 startPoint, Vector3 targetPoint)
			{
				float i = 0f;
				float rate = 1f / duration;
				while (i < 1f)
				{
					i += Time.deltaTime * rate;
					base.transform.position = Vector3.Lerp(startPoint, targetPoint, i);
					yield return null;
				}
			}

			private void OnDrawGizmosSelected()
			{
				Gizmos.color = Color.red;
				Gizmos.DrawWireSphere(base.transform.position, 0.3f);
				Gizmos.DrawLine(base.transform.position, targePosition);
				Gizmos.DrawWireSphere(targePosition, 0.3f);
			}
		}
		[RequireComponent(typeof(Light))]
		public class TBS_FlickeringLight : MonoBehaviour
		{
			[SerializeField]
			private AnimationCurve lightIntenstityCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

			private float activatedTime;

			private Light light;

			[Range(0f, 8f)]
			[SerializeField]
			private float intensityToReach = 5f;

			[SerializeField]
			private float speed = 1f;

			private void Awake()
			{
				light = GetComponent<Light>();
			}

			private void OnEnable()
			{
				activatedTime = Time.time;
			}

			private void Update()
			{
				float num = Time.time - activatedTime;
				float intensity = lightIntenstityCurve.Evaluate(num * speed) * intensityToReach;
				light.intensity = intensity;
			}
		}
		public class TBS_LightBounce : MonoBehaviour
		{
			[SerializeField]
			private float duration = 1f;

			private float maxLightIntenstity = 2f;

			private Light light;

			private float activatedTime;

			private void Awake()
			{
				light = GetComponent<Light>();
				maxLightIntenstity = light.intensity;
			}

			private void OnEnable()
			{
				activatedTime = Time.time;
			}

			private void Update()
			{
				float num = Mathf.Cos((Time.time - activatedTime) / duration * 2f * (float)Math.PI) * 0.5f + 0.5f;
				light.intensity = num * maxLightIntenstity;
			}
		}
		public class TBS_RotateableObject : MonoBehaviour
		{
			private enum ROTATION_AXIS
			{
				X,
				Y,
				Z
			}

			[SerializeField]
			private ROTATION_AXIS rotationAxis;

			[SerializeField]
			private float rotationSpeed = 60f;

			[SerializeField]
			private bool randomSpeed;

			[SerializeField]
			private bool randomDirection = true;

			private void Start()
			{
				if (randomSpeed)
				{
					rotationSpeed = UnityEngine.Random.Range(rotationSpeed - rotationSpeed / 3f, rotationSpeed + rotationSpeed / 3f);
				}
				if (randomDirection && UnityEngine.Random.Range(0, 2) == 1)
				{
					rotationSpeed *= -1f;
				}
			}

			private void Update()
			{
				switch (rotationAxis)
				{
				case ROTATION_AXIS.X:
					base.transform.Rotate(rotationSpeed * Time.deltaTime, 0f, 0f);
					break;
				case ROTATION_AXIS.Y:
					base.transform.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);
					break;
				case ROTATION_AXIS.Z:
					base.transform.Rotate(0f, 0f, rotationSpeed * Time.deltaTime);
					break;
				}
			}
		}
		public class TBS_SimpleForwardMovement : MonoBehaviour
		{
			[SerializeField]
			private float speed_ = 2f;

			private void Update()
			{
				base.transform.Translate(Vector3.forward * speed_ * Time.deltaTime);
			}
		}
		public class TBS_Water : MonoBehaviour
		{
			[Header("Waves settings")]
			public float waveHeight = 1f;

			public float speed = 1f;

			public float waveLength = 1f;

			[Header("Randomize variables")]
			public float randomHeight = 0.2f;

			public float randomSpeed = 5f;

			public float noiseOffset = 20f;

			private Vector3[] baseHeight;

			private Vector3[] vertices;

			private List<float> perVertexRandoms = new List<float>();

			private Mesh mesh;

			private void Awake()
			{
				mesh = GetComponent<MeshFilter>().mesh;
				if (baseHeight == null)
				{
					baseHeight = mesh.vertices;
				}
				for (int i = 0; i < baseHeight.Length; i++)
				{
					perVertexRandoms.Add(UnityEngine.Random.value * randomHeight);
				}
			}

			private void Update()
			{
				if (vertices == null)
				{
					vertices = new Vector3[baseHeight.Length];
				}
				for (int i = 0; i < vertices.Length; i++)
				{
					Vector3 vector = baseHeight[i];
					UnityEngine.Random.seed = (int)((vector.x + noiseOffset) * (vector.x + noiseOffset) + (vector.y + noiseOffset) * (vector.y + noiseOffset));
					vector.y += Mathf.Sin(Time.time * speed + baseHeight[i].x * waveLength + baseHeight[i].y * waveLength) * waveHeight;
					vector.y += Mathf.Sin(Mathf.Cos(UnityEngine.Random.value * 1f) * randomHeight * Mathf.Cos(Time.time * randomSpeed * Mathf.Sin(UnityEngine.Random.value * 1f)));
					vertices[i] = vector;
				}
				mesh.vertices = vertices;
				mesh.RecalculateNormals();
			}
		}
	}
	namespace UnityStandardAssets.Utility
	{
		public class ActivateTrigger : MonoBehaviour
		{
			public enum Mode
			{
				Trigger,
				Replace,
				Activate,
				Enable,
				Animate,
				Deactivate
			}

			public Mode action = Mode.Activate;

			public UnityEngine.Object target;

			public GameObject source;

			public int triggerCount = 1;

			public bool repeatTrigger;

			private void DoActivateTrigger()
			{
				triggerCount--;
				if (triggerCount != 0 && !repeatTrigger)
				{
					return;
				}
				UnityEngine.Object obj = target ?? base.gameObject;
				Behaviour behaviour = obj as Behaviour;
				GameObject gameObject = obj as GameObject;
				if (behaviour != null)
				{
					gameObject = behaviour.gameObject;
				}
				switch (action)
				{
				case Mode.Trigger:
					if (gameObject != null)
					{
						gameObject.BroadcastMessage("DoActivateTrigger");
					}
					break;
				case Mode.Replace:
					if (source != null && gameObject != null)
					{
						UnityEngine.Object.Instantiate(source, gameObject.transform.position, gameObject.transform.rotation);
						UnityEngine.Object.DestroyObject(gameObject);
					}
					break;
				case Mode.Activate:
					if (gameObject != null)
					{
						gameObject.SetActive(value: true);
					}
					break;
				case Mode.Enable:
					if (behaviour != null)
					{
						behaviour.enabled = true;
					}
					break;
				case Mode.Animate:
					if (gameObject != null)
					{
						gameObject.GetComponent<Animation>().Play();
					}
					break;
				case Mode.Deactivate:
					if (gameObject != null)
					{
						gameObject.SetActive(value: false);
					}
					break;
				}
			}

			private void OnTriggerEnter(Collider other)
			{
				DoActivateTrigger();
			}
		}
		public class AutoMobileShaderSwitch : MonoBehaviour
		{
			[Serializable]
			public class ReplacementDefinition
			{
				public Shader original;

				public Shader replacement;
			}

			[Serializable]
			public class ReplacementList
			{
				public ReplacementDefinition[] items = new ReplacementDefinition[0];
			}

			[SerializeField]
			private ReplacementList m_ReplacementList;

			private void OnEnable()
			{
				Renderer[] array = UnityEngine.Object.FindObjectsOfType<Renderer>();
				UnityEngine.Debug.Log(array.Length + " renderers");
				List<Material> list = new List<Material>();
				List<Material> list2 = new List<Material>();
				int num = 0;
				int num2 = 0;
				ReplacementDefinition[] items = m_ReplacementList.items;
				foreach (ReplacementDefinition replacementDefinition in items)
				{
					Renderer[] array2 = array;
					foreach (Renderer renderer in array2)
					{
						Material[] array3 = null;
						for (int k = 0; k < renderer.sharedMaterials.Length; k++)
						{
							Material material = renderer.sharedMaterials[k];
							if (material.shader == replacementDefinition.original)
							{
								if (array3 == null)
								{
									array3 = renderer.materials;
								}
								if (!list.Contains(material))
								{
									list.Add(material);
									Material material2 = UnityEngine.Object.Instantiate(material);
									material2.shader = replacementDefinition.replacement;
									list2.Add(material2);
									num++;
								}
								UnityEngine.Debug.Log("replacing " + renderer.gameObject.name + " renderer " + k + " with " + list2[list.IndexOf(material)].name);
								array3[k] = list2[list.IndexOf(material)];
								num2++;
							}
						}
						if (array3 != null)
						{
							renderer.materials = array3;
						}
					}
				}
				UnityEngine.Debug.Log(num2 + " material instances replaced");
				UnityEngine.Debug.Log(num + " materials replaced");
				for (int l = 0; l < list.Count; l++)
				{
					UnityEngine.Debug.Log(list[l].name + " (" + list[l].shader.name + ") replaced with " + list2[l].name + " (" + list2[l].shader.name + ")");
				}
			}
		}
		public class AutoMoveAndRotate : MonoBehaviour
		{
			[Serializable]
			public class Vector3andSpace
			{
				public Vector3 value;

				public Space space = Space.Self;
			}

			public Vector3andSpace moveUnitsPerSecond;

			public Vector3andSpace rotateDegreesPerSecond;

			public bool ignoreTimescale;

			private float m_LastRealTime;

			private void Start()
			{
				m_LastRealTime = Time.realtimeSinceStartup;
			}

			private void Update()
			{
				float num = Time.deltaTime;
				if (ignoreTimescale)
				{
					num = Time.realtimeSinceStartup - m_LastRealTime;
					m_LastRealTime = Time.realtimeSinceStartup;
				}
				base.transform.Translate(moveUnitsPerSecond.value * num, moveUnitsPerSecond.space);
				base.transform.Rotate(rotateDegreesPerSecond.value * num, moveUnitsPerSecond.space);
			}
		}
		public class CameraRefocus
		{
			public Camera Camera;

			public Vector3 Lookatpoint;

			public Transform Parent;

			private Vector3 m_OrigCameraPos;

			private bool m_Refocus;

			public CameraRefocus(Camera camera, Transform parent, Vector3 origCameraPos)
			{
				m_OrigCameraPos = origCameraPos;
				Camera = camera;
				Parent = parent;
			}

			public void ChangeCamera(Camera camera)
			{
				Camera = camera;
			}

			public void ChangeParent(Transform parent)
			{
				Parent = parent;
			}

			public void GetFocusPoint()
			{
				if (Physics.Raycast(Parent.transform.position + m_OrigCameraPos, Parent.transform.forward, out var hitInfo, 100f))
				{
					Lookatpoint = hitInfo.point;
					m_Refocus = true;
				}
				else
				{
					m_Refocus = false;
				}
			}

			public void SetFocusPoint()
			{
				if (m_Refocus)
				{
					Camera.transform.LookAt(Lookatpoint);
				}
			}
		}
		[Serializable]
		public class CurveControlledBob
		{
			public float HorizontalBobRange = 0.33f;

			public float VerticalBobRange = 0.33f;

			public AnimationCurve Bobcurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f), new Keyframe(1.5f, -1f), new Keyframe(2f, 0f));

			public float VerticaltoHorizontalRatio = 1f;

			private float m_CyclePositionX;

			private float m_CyclePositionY;

			private float m_BobBaseInterval;

			private Vector3 m_OriginalCameraPosition;

			private float m_Time;

			public void Setup(Camera camera, float bobBaseInterval)
			{
				m_BobBaseInterval = bobBaseInterval;
				m_OriginalCameraPosition = camera.transform.localPosition;
				m_Time = Bobcurve[Bobcurve.length - 1].time;
			}

			public Vector3 DoHeadBob(float speed)
			{
				float x = m_OriginalCameraPosition.x + Bobcurve.Evaluate(m_CyclePositionX) * HorizontalBobRange;
				float y = m_OriginalCameraPosition.y + Bobcurve.Evaluate(m_CyclePositionY) * VerticalBobRange;
				m_CyclePositionX += speed * Time.deltaTime / m_BobBaseInterval;
				m_CyclePositionY += speed * Time.deltaTime / m_BobBaseInterval * VerticaltoHorizontalRatio;
				if (m_CyclePositionX > m_Time)
				{
					m_CyclePositionX -= m_Time;
				}
				if (m_CyclePositionY > m_Time)
				{
					m_CyclePositionY -= m_Time;
				}
				return new Vector3(x, y, 0f);
			}
		}
		public class DragRigidbody : MonoBehaviour
		{
			private const float k_Spring = 50f;

			private const float k_Damper = 5f;

			private const float k_Drag = 10f;

			private const float k_AngularDrag = 5f;

			private const float k_Distance = 0.2f;

			private const bool k_AttachToCenterOfMass = false;

			private SpringJoint m_SpringJoint;

			private void Update()
			{
				if (!Input.GetMouseButtonDown(0))
				{
					return;
				}
				Camera camera = FindCamera();
				RaycastHit hitInfo = default(RaycastHit);
				if (Physics.Raycast(camera.ScreenPointToRay(Input.mousePosition).origin, camera.ScreenPointToRay(Input.mousePosition).direction, out hitInfo, 100f, -5) && (bool)hitInfo.rigidbody && !hitInfo.rigidbody.isKinematic)
				{
					if (!m_SpringJoint)
					{
						GameObject gameObject = new GameObject("Rigidbody dragger");
						Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
						m_SpringJoint = gameObject.AddComponent<SpringJoint>();
						rigidbody.isKinematic = true;
					}
					m_SpringJoint.transform.position = hitInfo.point;
					m_SpringJoint.anchor = Vector3.zero;
					m_SpringJoint.spring = 50f;
					m_SpringJoint.damper = 5f;
					m_SpringJoint.maxDistance = 0.2f;
					m_SpringJoint.connectedBody = hitInfo.rigidbody;
					StartCoroutine("DragObject", hitInfo.distance);
				}
			}

			private IEnumerator DragObject(float distance)
			{
				float oldDrag = m_SpringJoint.connectedBody.drag;
				float oldAngularDrag = m_SpringJoint.connectedBody.angularDrag;
				m_SpringJoint.connectedBody.drag = 10f;
				m_SpringJoint.connectedBody.angularDrag = 5f;
				Camera mainCamera = FindCamera();
				while (Input.GetMouseButton(0))
				{
					Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
					m_SpringJoint.transform.position = ray.GetPoint(distance);
					yield return null;
				}
				if ((bool)m_SpringJoint.connectedBody)
				{
					m_SpringJoint.connectedBody.drag = oldDrag;
					m_SpringJoint.connectedBody.angularDrag = oldAngularDrag;
					m_SpringJoint.connectedBody = null;
				}
			}

			private Camera FindCamera()
			{
				if ((bool)GetComponent<Camera>())
				{
					return GetComponent<Camera>();
				}
				return Camera.main;
			}
		}
		public class DynamicShadowSettings : MonoBehaviour
		{
			public Light sunLight;

			public float minHeight = 10f;

			public float minShadowDistance = 80f;

			public float minShadowBias = 1f;

			public float maxHeight = 1000f;

			public float maxShadowDistance = 10000f;

			public float maxShadowBias = 0.1f;

			public float adaptTime = 1f;

			private float m_SmoothHeight;

			private float m_ChangeSpeed;

			private float m_OriginalStrength = 1f;

			private void Start()
			{
				m_OriginalStrength = sunLight.shadowStrength;
			}

			private void Update()
			{
				Ray ray = new Ray(Camera.main.transform.position, -Vector3.up);
				float num = base.transform.position.y;
				if (Physics.Raycast(ray, out var hitInfo))
				{
					num = hitInfo.distance;
				}
				if (Mathf.Abs(num - m_SmoothHeight) > 1f)
				{
					m_SmoothHeight = Mathf.SmoothDamp(m_SmoothHeight, num, ref m_ChangeSpeed, adaptTime);
				}
				float num2 = Mathf.InverseLerp(minHeight, maxHeight, m_SmoothHeight);
				QualitySettings.shadowDistance = Mathf.Lerp(minShadowDistance, maxShadowDistance, num2);
				sunLight.shadowBias = Mathf.Lerp(minShadowBias, maxShadowBias, 1f - (1f - num2) * (1f - num2));
				sunLight.shadowStrength = Mathf.Lerp(m_OriginalStrength, 0f, num2);
			}
		}
		[Serializable]
		public class FOVKick
		{
			public Camera Camera;

			[HideInInspector]
			public float originalFov;

			public float FOVIncrease = 3f;

			public float TimeToIncrease = 1f;

			public float TimeToDecrease = 1f;

			public AnimationCurve IncreaseCurve;

			public void Setup(Camera camera)
			{
				CheckStatus(camera);
				Camera = camera;
				originalFov = camera.fieldOfView;
			}

			private void CheckStatus(Camera camera)
			{
				if (camera == null)
				{
					throw new Exception("FOVKick camera is null, please supply the camera to the constructor");
				}
				if (IncreaseCurve == null)
				{
					throw new Exception("FOVKick Increase curve is null, please define the curve for the field of view kicks");
				}
			}

			public void ChangeCamera(Camera camera)
			{
				Camera = camera;
			}

			public IEnumerator FOVKickUp()
			{
				float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
				while (t < TimeToIncrease)
				{
					Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToIncrease) * FOVIncrease;
					t += Time.deltaTime;
					yield return new WaitForEndOfFrame();
				}
			}

			public IEnumerator FOVKickDown()
			{
				float t = Mathf.Abs((Camera.fieldOfView - originalFov) / FOVIncrease);
				while (t > 0f)
				{
					Camera.fieldOfView = originalFov + IncreaseCurve.Evaluate(t / TimeToDecrease) * FOVIncrease;
					t -= Time.deltaTime;
					yield return new WaitForEndOfFrame();
				}
				Camera.fieldOfView = originalFov;
			}
		}
		[RequireComponent(typeof(Text))]
		public class FPSCounter : MonoBehaviour
		{
			private const float fpsMeasurePeriod = 0.5f;

			private int m_FpsAccumulator;

			private float m_FpsNextPeriod;

			private int m_CurrentFps;

			private const string display = "{0} FPS";

			private Text m_Text;

			private void Start()
			{
				m_FpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
				m_Text = GetComponent<Text>();
			}

			private void Update()
			{
				m_FpsAccumulator++;
				if (Time.realtimeSinceStartup > m_FpsNextPeriod)
				{
					m_CurrentFps = (int)((float)m_FpsAccumulator / 0.5f);
					m_FpsAccumulator = 0;
					m_FpsNextPeriod += 0.5f;
					m_Text.text = $"{m_CurrentFps} FPS";
				}
			}
		}
		public class FollowTarget : MonoBehaviour
		{
			public Transform target;

			public Vector3 offset = new Vector3(0f, 7.5f, 0f);

			private void LateUpdate()
			{
				base.transform.position = target.position + offset;
			}
		}
		[Serializable]
		public class LerpControlledBob
		{
			public float BobDuration;

			public float BobAmount;

			private float m_Offset;

			public float Offset()
			{
				return m_Offset;
			}

			public IEnumerator DoBobCycle()
			{
				float t2 = 0f;
				while (t2 < BobDuration)
				{
					m_Offset = Mathf.Lerp(0f, BobAmount, t2 / BobDuration);
					t2 += Time.deltaTime;
					yield return new WaitForFixedUpdate();
				}
				t2 = 0f;
				while (t2 < BobDuration)
				{
					m_Offset = Mathf.Lerp(BobAmount, 0f, t2 / BobDuration);
					t2 += Time.deltaTime;
					yield return new WaitForFixedUpdate();
				}
				m_Offset = 0f;
			}
		}
		public class ObjectResetter : MonoBehaviour
		{
			private Vector3 originalPosition;

			private Quaternion originalRotation;

			private Rigidbody Rigidbody;

			private void Start()
			{
				originalPosition = base.transform.position;
				originalRotation = base.transform.rotation;
				Rigidbody = GetComponent<Rigidbody>();
			}

			public void SetResetterPosition(Transform t)
			{
				originalPosition = t.position;
				originalRotation = base.gameObject.transform.rotation;
			}

			public void DelayedReset(float delay)
			{
				StartCoroutine(ResetCoroutine(delay));
			}

			public IEnumerator ResetCoroutine(float delay)
			{
				yield return new WaitForSeconds(delay);
				base.transform.position = originalPosition;
				base.transform.rotation = originalRotation;
				if ((bool)Rigidbody)
				{
					Rigidbody.velocity = Vector3.zero;
					Rigidbody.angularVelocity = Vector3.zero;
				}
				SendMessage("Reset");
			}
		}
		public class ParticleSystemDestroyer : MonoBehaviour
		{
			public float minDuration = 8f;

			public float maxDuration = 10f;

			private float m_MaxLifetime;

			private bool m_EarlyStop;

			private IEnumerator Start()
			{
				ParticleSystem[] systems = GetComponentsInChildren<ParticleSystem>();
				ParticleSystem[] array = systems;
				foreach (ParticleSystem particleSystem in array)
				{
					m_MaxLifetime = Mathf.Max(particleSystem.main.startLifetime.constant, m_MaxLifetime);
				}
				float stopTime = Time.time + UnityEngine.Random.Range(minDuration, maxDuration);
				while (Time.time < stopTime && !m_EarlyStop)
				{
					yield return null;
				}
				UnityEngine.Debug.Log("stopping " + base.name);
				array = systems;
				for (int i = 0; i < array.Length; i++)
				{
					ParticleSystem.EmissionModule emission = array[i].emission;
					emission.enabled = false;
				}
				BroadcastMessage("Extinguish", SendMessageOptions.DontRequireReceiver);
				yield return new WaitForSeconds(m_MaxLifetime);
				UnityEngine.Object.Destroy(base.gameObject);
			}

			public void Stop()
			{
				m_EarlyStop = true;
			}
		}
		public class PlatformSpecificContent : MonoBehaviour
		{
			private enum BuildTargetGroup
			{
				Standalone,
				Mobile
			}

			[SerializeField]
			private BuildTargetGroup m_BuildTargetGroup;

			[SerializeField]
			private GameObject[] m_Content = new GameObject[0];

			[SerializeField]
			private MonoBehaviour[] m_MonoBehaviours = new MonoBehaviour[0];

			[SerializeField]
			private bool m_ChildrenOfThisObject;

			private void OnEnable()
			{
				CheckEnableContent();
			}

			private void CheckEnableContent()
			{
				if (m_BuildTargetGroup == BuildTargetGroup.Mobile)
				{
					EnableContent(enabled: true);
				}
				else
				{
					EnableContent(enabled: false);
				}
			}

			private void EnableContent(bool enabled)
			{
				if (m_Content.Length != 0)
				{
					GameObject[] content = m_Content;
					foreach (GameObject gameObject in content)
					{
						if (gameObject != null)
						{
							gameObject.SetActive(enabled);
						}
					}
				}
				if (m_ChildrenOfThisObject)
				{
					foreach (Transform item in base.transform)
					{
						item.gameObject.SetActive(enabled);
					}
				}
				if (m_MonoBehaviours.Length != 0)
				{
					MonoBehaviour[] monoBehaviours = m_MonoBehaviours;
					for (int i = 0; i < monoBehaviours.Length; i++)
					{
						monoBehaviours[i].enabled = enabled;
					}
				}
			}
		}
		public class SimpleMouseRotator : MonoBehaviour
		{
			public Vector2 rotationRange = new Vector3(70f, 70f);

			public float rotationSpeed = 10f;

			public float dampingTime = 0.2f;

			public bool autoZeroVerticalOnMobile = true;

			public bool autoZeroHorizontalOnMobile;

			public bool relative = true;

			private Vector3 m_TargetAngles;

			private Vector3 m_FollowAngles;

			private Vector3 m_FollowVelocity;

			private Quaternion m_OriginalRotation;

			private void Start()
			{
				m_OriginalRotation = base.transform.localRotation;
			}

			private void Update()
			{
				base.transform.localRotation = m_OriginalRotation;
				if (relative)
				{
					float axis = CrossPlatformInputManager.GetAxis("Mouse X");
					float axis2 = CrossPlatformInputManager.GetAxis("Mouse Y");
					if (m_TargetAngles.y > 180f)
					{
						m_TargetAngles.y -= 360f;
						m_FollowAngles.y -= 360f;
					}
					if (m_TargetAngles.x > 180f)
					{
						m_TargetAngles.x -= 360f;
						m_FollowAngles.x -= 360f;
					}
					if (m_TargetAngles.y < -180f)
					{
						m_TargetAngles.y += 360f;
						m_FollowAngles.y += 360f;
					}
					if (m_TargetAngles.x < -180f)
					{
						m_TargetAngles.x += 360f;
						m_FollowAngles.x += 360f;
					}
					if (autoZeroHorizontalOnMobile)
					{
						m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis * 0.5f + 0.5f);
					}
					else
					{
						m_TargetAngles.y += axis * rotationSpeed;
					}
					if (autoZeroVerticalOnMobile)
					{
						m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 * 0.5f + 0.5f);
					}
					else
					{
						m_TargetAngles.x += axis2 * rotationSpeed;
					}
					m_TargetAngles.y = Mathf.Clamp(m_TargetAngles.y, (0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f);
					m_TargetAngles.x = Mathf.Clamp(m_TargetAngles.x, (0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f);
				}
				else
				{
					float axis = Input.mousePosition.x;
					float axis2 = Input.mousePosition.y;
					m_TargetAngles.y = Mathf.Lerp((0f - rotationRange.y) * 0.5f, rotationRange.y * 0.5f, axis / (float)Screen.width);
					m_TargetAngles.x = Mathf.Lerp((0f - rotationRange.x) * 0.5f, rotationRange.x * 0.5f, axis2 / (float)Screen.height);
				}
				m_FollowAngles = Vector3.SmoothDamp(m_FollowAngles, m_TargetAngles, ref m_FollowVelocity, dampingTime);
				base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f - m_FollowAngles.x, m_FollowAngles.y, 0f);
			}
		}
		public class SmoothFollow : MonoBehaviour
		{
			[SerializeField]
			private Transform target;

			[SerializeField]
			private float distance = 10f;

			[SerializeField]
			private float height = 5f;

			[SerializeField]
			private float rotationDamping;

			[SerializeField]
			private float heightDamping;

			private void Start()
			{
			}

			private void LateUpdate()
			{
				if ((bool)target)
				{
					float y = target.eulerAngles.y;
					float b = target.position.y + height;
					float y2 = base.transform.eulerAngles.y;
					float y3 = base.transform.position.y;
					y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
					y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
					Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
					base.transform.position = target.position;
					base.transform.position -= quaternion * Vector3.forward * distance;
					base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
					base.transform.LookAt(target);
				}
			}
		}
		public class TimedObjectActivator : MonoBehaviour
		{
			public enum Action
			{
				Activate,
				Deactivate,
				Destroy,
				ReloadLevel,
				Call
			}

			[Serializable]
			public class Entry
			{
				public GameObject target;

				public Action action;

				public float delay;
			}

			[Serializable]
			public class Entries
			{
				public Entry[] entries;
			}

			public Entries entries = new Entries();

			private void Awake()
			{
				Entry[] array = entries.entries;
				foreach (Entry entry in array)
				{
					switch (entry.action)
					{
					case Action.Activate:
						StartCoroutine(Activate(entry));
						break;
					case Action.Deactivate:
						StartCoroutine(Deactivate(entry));
						break;
					case Action.Destroy:
						UnityEngine.Object.Destroy(entry.target, entry.delay);
						break;
					case Action.ReloadLevel:
						StartCoroutine(ReloadLevel(entry));
						break;
					}
				}
			}

			private IEnumerator Activate(Entry entry)
			{
				yield return new WaitForSeconds(entry.delay);
				entry.target.SetActive(value: true);
			}

			private IEnumerator Deactivate(Entry entry)
			{
				yield return new WaitForSeconds(entry.delay);
				entry.target.SetActive(value: false);
			}

			private IEnumerator ReloadLevel(Entry entry)
			{
				yield return new WaitForSeconds(entry.delay);
				SceneManager.LoadScene(SceneManager.GetSceneAt(0).name);
			}
		}
		public class TimedObjectDestructor : MonoBehaviour
		{
			[SerializeField]
			private float m_TimeOut = 1f;

			[SerializeField]
			private bool m_DetachChildren;

			private void Awake()
			{
				Invoke("DestroyNow", m_TimeOut);
			}

			private void DestroyNow()
			{
				if (m_DetachChildren)
				{
					base.transform.DetachChildren();
				}
				UnityEngine.Object.DestroyObject(base.gameObject);
			}
		}
		public class WaypointCircuit : MonoBehaviour
		{
			[Serializable]
			public class WaypointList
			{
				public WaypointCircuit circuit;

				public Transform[] items = new Transform[0];
			}

			public struct RoutePoint
			{
				public Vector3 position;

				public Vector3 direction;

				public RoutePoint(Vector3 position, Vector3 direction)
				{
					this.position = position;
					this.direction = direction;
				}
			}

			public WaypointList waypointList = new WaypointList();

			[SerializeField]
			private bool smoothRoute = true;

			private int numPoints;

			private Vector3[] points;

			private float[] distances;

			public float editorVisualisationSubsteps = 100f;

			private int p0n;

			private int p1n;

			private int p2n;

			private int p3n;

			private float i;

			private Vector3 P0;

			private Vector3 P1;

			private Vector3 P2;

			private Vector3 P3;

			public float Length { get; private set; }

			public Transform[] Waypoints => waypointList.items;

			private void Awake()
			{
				if (Waypoints.Length > 1)
				{
					CachePositionsAndDistances();
				}
				numPoints = Waypoints.Length;
			}

			public RoutePoint GetRoutePoint(float dist)
			{
				Vector3 routePosition = GetRoutePosition(dist);
				return new RoutePoint(routePosition, (GetRoutePosition(dist + 0.1f) - routePosition).normalized);
			}

			public Vector3 GetRoutePosition(float dist)
			{
				int i = 0;
				if (Length == 0f)
				{
					Length = distances[distances.Length - 1];
				}
				for (dist = Mathf.Repeat(dist, Length); distances[i] < dist; i++)
				{
				}
				p1n = (i - 1 + numPoints) % numPoints;
				p2n = i;
				this.i = Mathf.InverseLerp(distances[p1n], distances[p2n], dist);
				if (smoothRoute)
				{
					p0n = (i - 2 + numPoints) % numPoints;
					p3n = (i + 1) % numPoints;
					p2n %= numPoints;
					P0 = points[p0n];
					P1 = points[p1n];
					P2 = points[p2n];
					P3 = points[p3n];
					return CatmullRom(P0, P1, P2, P3, this.i);
				}
				p1n = (i - 1 + numPoints) % numPoints;
				p2n = i;
				return Vector3.Lerp(points[p1n], points[p2n], this.i);
			}

			private Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float i)
			{
				return 0.5f * (2f * p1 + (-p0 + p2) * i + (2f * p0 - 5f * p1 + 4f * p2 - p3) * i * i + (-p0 + 3f * p1 - 3f * p2 + p3) * i * i * i);
			}

			private void CachePositionsAndDistances()
			{
				points = new Vector3[Waypoints.Length + 1];
				distances = new float[Waypoints.Length + 1];
				float num = 0f;
				for (int i = 0; i < points.Length; i++)
				{
					Transform transform = Waypoints[i % Waypoints.Length];
					Transform transform2 = Waypoints[(i + 1) % Waypoints.Length];
					if (transform != null && transform2 != null)
					{
						Vector3 position = transform.position;
						Vector3 position2 = transform2.position;
						points[i] = Waypoints[i % Waypoints.Length].position;
						distances[i] = num;
						num += (position - position2).magnitude;
					}
				}
			}

			private void OnDrawGizmos()
			{
				DrawGizmos(selected: false);
			}

			private void OnDrawGizmosSelected()
			{
				DrawGizmos(selected: true);
			}

			private void DrawGizmos(bool selected)
			{
				waypointList.circuit = this;
				if (Waypoints.Length <= 1)
				{
					return;
				}
				numPoints = Waypoints.Length;
				CachePositionsAndDistances();
				Length = distances[distances.Length - 1];
				Gizmos.color = (selected ? Color.yellow : new Color(1f, 1f, 0f, 0.5f));
				Vector3 from = Waypoints[0].position;
				if (smoothRoute)
				{
					for (float num = 0f; num < Length; num += Length / editorVisualisationSubsteps)
					{
						Vector3 routePosition = GetRoutePosition(num + 1f);
						Gizmos.DrawLine(from, routePosition);
						from = routePosition;
					}
					Gizmos.DrawLine(from, Waypoints[0].position);
				}
				else
				{
					for (int i = 0; i < Waypoints.Length; i++)
					{
						Vector3 position = Waypoints[(i + 1) % Waypoints.Length].position;
						Gizmos.DrawLine(from, position);
						from = position;
					}
				}
			}
		}
		public class WaypointProgressTracker : MonoBehaviour
		{
			public enum ProgressStyle
			{
				SmoothAlongRoute,
				PointToPoint
			}

			[SerializeField]
			private WaypointCircuit circuit;

			[SerializeField]
			private float lookAheadForTargetOffset = 5f;

			[SerializeField]
			private float lookAheadForTargetFactor = 0.1f;

			[SerializeField]
			private float lookAheadForSpeedOffset = 10f;

			[SerializeField]
			private float lookAheadForSpeedFactor = 0.2f;

			[SerializeField]
			private ProgressStyle progressStyle;

			[SerializeField]
			private float pointToPointThreshold = 4f;

			public Transform target;

			private float progressDistance;

			private int progressNum;

			private Vector3 lastPosition;

			private float speed;

			public WaypointCircuit.RoutePoint targetPoint { get; private set; }

			public WaypointCircuit.RoutePoint speedPoint { get; private set; }

			public WaypointCircuit.RoutePoint progressPoint { get; private set; }

			private void Start()
			{
				if (target == null)
				{
					target = new GameObject(base.name + " Waypoint Target").transform;
				}
				Reset();
			}

			public void Reset()
			{
				progressDistance = 0f;
				progressNum = 0;
				if (progressStyle == ProgressStyle.PointToPoint)
				{
					target.position = circuit.Waypoints[progressNum].position;
					target.rotation = circuit.Waypoints[progressNum].rotation;
				}
			}

			private void Update()
			{
				if (progressStyle == ProgressStyle.SmoothAlongRoute)
				{
					if (Time.deltaTime > 0f)
					{
						speed = Mathf.Lerp(speed, (lastPosition - base.transform.position).magnitude / Time.deltaTime, Time.deltaTime);
					}
					target.position = circuit.GetRoutePoint(progressDistance + lookAheadForTargetOffset + lookAheadForTargetFactor * speed).position;
					target.rotation = Quaternion.LookRotation(circuit.GetRoutePoint(progressDistance + lookAheadForSpeedOffset + lookAheadForSpeedFactor * speed).direction);
					progressPoint = circuit.GetRoutePoint(progressDistance);
					Vector3 lhs = progressPoint.position - base.transform.position;
					if (Vector3.Dot(lhs, progressPoint.direction) < 0f)
					{
						progressDistance += lhs.magnitude * 0.5f;
					}
					lastPosition = base.transform.position;
				}
				else
				{
					if ((target.position - base.transform.position).magnitude < pointToPointThreshold)
					{
						progressNum = (progressNum + 1) % circuit.Waypoints.Length;
					}
					target.position = circuit.Waypoints[progressNum].position;
					target.rotation = circuit.Waypoints[progressNum].rotation;
					progressPoint = circuit.GetRoutePoint(progressDistance);
					Vector3 lhs2 = progressPoint.position - base.transform.position;
					if (Vector3.Dot(lhs2, progressPoint.direction) < 0f)
					{
						progressDistance += lhs2.magnitude;
					}
					lastPosition = base.transform.position;
				}
			}

			private void OnDrawGizmos()
			{
				if (Application.isPlaying)
				{
					Gizmos.color = Color.green;
					Gizmos.DrawLine(base.transform.position, target.position);
					Gizmos.DrawWireSphere(circuit.GetRoutePosition(progressDistance), 1f);
					Gizmos.color = Color.yellow;
					Gizmos.DrawLine(target.position, target.position + target.forward);
				}
			}
		}
	}
	namespace UnityStandardAssets.ImageEffects
	{
		public enum AAMode
		{
			FXAA2,
			FXAA3Console,
			FXAA1PresetA,
			FXAA1PresetB,
			NFAA,
			SSAA,
			DLAA
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Other/Antialiasing")]
		public class Antialiasing : PostEffectsBase
		{
			public AAMode mode = AAMode.FXAA3Console;

			public bool showGeneratedNormals;

			public float offsetScale = 0.2f;

			public float blurRadius = 18f;

			public float edgeThresholdMin = 0.05f;

			public float edgeThreshold = 0.2f;

			public float edgeSharpness = 4f;

			public bool dlaaSharp;

			public Shader ssaaShader;

			private Material ssaa;

			public Shader dlaaShader;

			private Material dlaa;

			public Shader nfaaShader;

			private Material nfaa;

			public Shader shaderFXAAPreset2;

			private Material materialFXAAPreset2;

			public Shader shaderFXAAPreset3;

			private Material materialFXAAPreset3;

			public Shader shaderFXAAII;

			private Material materialFXAAII;

			public Shader shaderFXAAIII;

			private Material materialFXAAIII;

			public Material CurrentAAMaterial()
			{
				Material material = null;
				return mode switch
				{
					AAMode.FXAA3Console => materialFXAAIII, 
					AAMode.FXAA2 => materialFXAAII, 
					AAMode.FXAA1PresetA => materialFXAAPreset2, 
					AAMode.FXAA1PresetB => materialFXAAPreset3, 
					AAMode.NFAA => nfaa, 
					AAMode.SSAA => ssaa, 
					AAMode.DLAA => dlaa, 
					_ => null, 
				};
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				materialFXAAPreset2 = CreateMaterial(shaderFXAAPreset2, materialFXAAPreset2);
				materialFXAAPreset3 = CreateMaterial(shaderFXAAPreset3, materialFXAAPreset3);
				materialFXAAII = CreateMaterial(shaderFXAAII, materialFXAAII);
				materialFXAAIII = CreateMaterial(shaderFXAAIII, materialFXAAIII);
				nfaa = CreateMaterial(nfaaShader, nfaa);
				ssaa = CreateMaterial(ssaaShader, ssaa);
				dlaa = CreateMaterial(dlaaShader, dlaa);
				if (!ssaaShader.isSupported)
				{
					NotSupported();
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
				}
				else if (mode == AAMode.FXAA3Console && materialFXAAIII != null)
				{
					materialFXAAIII.SetFloat("_EdgeThresholdMin", edgeThresholdMin);
					materialFXAAIII.SetFloat("_EdgeThreshold", edgeThreshold);
					materialFXAAIII.SetFloat("_EdgeSharpness", edgeSharpness);
					Graphics.Blit(source, destination, materialFXAAIII);
				}
				else if (mode == AAMode.FXAA1PresetB && materialFXAAPreset3 != null)
				{
					Graphics.Blit(source, destination, materialFXAAPreset3);
				}
				else if (mode == AAMode.FXAA1PresetA && materialFXAAPreset2 != null)
				{
					source.anisoLevel = 4;
					Graphics.Blit(source, destination, materialFXAAPreset2);
					source.anisoLevel = 0;
				}
				else if (mode == AAMode.FXAA2 && materialFXAAII != null)
				{
					Graphics.Blit(source, destination, materialFXAAII);
				}
				else if (mode == AAMode.SSAA && ssaa != null)
				{
					Graphics.Blit(source, destination, ssaa);
				}
				else if (mode == AAMode.DLAA && dlaa != null)
				{
					source.anisoLevel = 0;
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height);
					Graphics.Blit(source, temporary, dlaa, 0);
					Graphics.Blit(temporary, destination, dlaa, (!dlaaSharp) ? 1 : 2);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else if (mode == AAMode.NFAA && nfaa != null)
				{
					source.anisoLevel = 0;
					nfaa.SetFloat("_OffsetScale", offsetScale);
					nfaa.SetFloat("_BlurRadius", blurRadius);
					Graphics.Blit(source, destination, nfaa, showGeneratedNormals ? 1 : 0);
				}
				else
				{
					Graphics.Blit(source, destination);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Bloom and Glow/Bloom")]
		public class Bloom : PostEffectsBase
		{
			public enum LensFlareStyle
			{
				Ghosting,
				Anamorphic,
				Combined
			}

			public enum TweakMode
			{
				Basic,
				Complex
			}

			public enum HDRBloomMode
			{
				Auto,
				On,
				Off
			}

			public enum BloomScreenBlendMode
			{
				Screen,
				Add
			}

			public enum BloomQuality
			{
				Cheap,
				High
			}

			public TweakMode tweakMode;

			public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

			public HDRBloomMode hdr;

			private bool doHdr;

			public float sepBlurSpread = 2.5f;

			public BloomQuality quality = BloomQuality.High;

			public float bloomIntensity = 0.5f;

			public float bloomThreshold = 0.5f;

			public Color bloomThresholdColor = Color.white;

			public int bloomBlurIterations = 2;

			public int hollywoodFlareBlurIterations = 2;

			public float flareRotation;

			public LensFlareStyle lensflareMode = LensFlareStyle.Anamorphic;

			public float hollyStretchWidth = 2.5f;

			public float lensflareIntensity;

			public float lensflareThreshold = 0.3f;

			public float lensFlareSaturation = 0.75f;

			public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

			public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

			public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

			public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

			public Texture2D lensFlareVignetteMask;

			public Shader lensFlareShader;

			private Material lensFlareMaterial;

			public Shader screenBlendShader;

			private Material screenBlend;

			public Shader blurAndFlaresShader;

			private Material blurAndFlaresMaterial;

			public Shader brightPassFilterShader;

			private Material brightPassFilterMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
				lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
				blurAndFlaresMaterial = CheckShaderAndCreateMaterial(blurAndFlaresShader, blurAndFlaresMaterial);
				brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				doHdr = false;
				if (hdr == HDRBloomMode.Auto)
				{
					doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
				}
				else
				{
					doHdr = hdr == HDRBloomMode.On;
				}
				doHdr = doHdr && supportHDRTextures;
				BloomScreenBlendMode bloomScreenBlendMode = screenBlendMode;
				if (doHdr)
				{
					bloomScreenBlendMode = BloomScreenBlendMode.Add;
				}
				RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
				int width = source.width / 2;
				int height = source.height / 2;
				int width2 = source.width / 4;
				int height2 = source.height / 4;
				float num = 1f * (float)source.width / (1f * (float)source.height);
				float num2 = 0.001953125f;
				RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, format);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
				if (quality > BloomQuality.Cheap)
				{
					Graphics.Blit(source, temporary2, screenBlend, 2);
					RenderTexture temporary3 = RenderTexture.GetTemporary(width2, height2, 0, format);
					Graphics.Blit(temporary2, temporary3, screenBlend, 2);
					Graphics.Blit(temporary3, temporary, screenBlend, 6);
					RenderTexture.ReleaseTemporary(temporary3);
				}
				else
				{
					Graphics.Blit(source, temporary2);
					Graphics.Blit(temporary2, temporary, screenBlend, 6);
				}
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture renderTexture = RenderTexture.GetTemporary(width2, height2, 0, format);
				BrightFilter(bloomThreshold * bloomThresholdColor, temporary, renderTexture);
				if (bloomBlurIterations < 1)
				{
					bloomBlurIterations = 1;
				}
				else if (bloomBlurIterations > 10)
				{
					bloomBlurIterations = 10;
				}
				for (int i = 0; i < bloomBlurIterations; i++)
				{
					float num3 = (1f + (float)i * 0.25f) * sepBlurSpread;
					RenderTexture temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, num3 * num2, 0f, 0f));
					Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary4;
					temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
					Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary4;
					if (quality > BloomQuality.Cheap)
					{
						if (i == 0)
						{
							Graphics.SetRenderTarget(temporary);
							GL.Clear(clearDepth: false, clearColor: true, Color.black);
							Graphics.Blit(renderTexture, temporary);
						}
						else
						{
							temporary.MarkRestoreExpected();
							Graphics.Blit(renderTexture, temporary, screenBlend, 10);
						}
					}
				}
				if (quality > BloomQuality.Cheap)
				{
					Graphics.SetRenderTarget(renderTexture);
					GL.Clear(clearDepth: false, clearColor: true, Color.black);
					Graphics.Blit(temporary, renderTexture, screenBlend, 6);
				}
				if (lensflareIntensity > Mathf.Epsilon)
				{
					RenderTexture temporary5 = RenderTexture.GetTemporary(width2, height2, 0, format);
					if (lensflareMode == LensFlareStyle.Ghosting)
					{
						BrightFilter(lensflareThreshold, renderTexture, temporary5);
						if (quality > BloomQuality.Cheap)
						{
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f / (1f * (float)temporary.height), 0f, 0f));
							Graphics.SetRenderTarget(temporary);
							GL.Clear(clearDepth: false, clearColor: true, Color.black);
							Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(1.5f / (1f * (float)temporary.width), 0f, 0f, 0f));
							Graphics.SetRenderTarget(temporary5);
							GL.Clear(clearDepth: false, clearColor: true, Color.black);
							Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
						}
						Vignette(0.975f, temporary5, temporary5);
						BlendFlares(temporary5, renderTexture);
					}
					else
					{
						float num4 = 1f * Mathf.Cos(flareRotation);
						float num5 = 1f * Mathf.Sin(flareRotation);
						float num6 = hollyStretchWidth * 1f / num * num2;
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4, num5, 0f, 0f));
						blurAndFlaresMaterial.SetVector("_Threshhold", new Vector4(lensflareThreshold, 1f, 0f, 0f));
						blurAndFlaresMaterial.SetVector("_TintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
						blurAndFlaresMaterial.SetFloat("_Saturation", lensFlareSaturation);
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 2);
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 3);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4 * num6, num5 * num6, 0f, 0f));
						blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth);
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
						blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 2f);
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 1);
						blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 4f);
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
						for (int j = 0; j < hollywoodFlareBlurIterations; j++)
						{
							num6 = hollyStretchWidth * 2f / num * num2;
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
							temporary5.DiscardContents();
							Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
							blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
							temporary.DiscardContents();
							Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
						}
						if (lensflareMode == LensFlareStyle.Anamorphic)
						{
							AddTo(1f, temporary, renderTexture);
						}
						else
						{
							Vignette(1f, temporary, temporary5);
							BlendFlares(temporary5, temporary);
							AddTo(1f, temporary, renderTexture);
						}
					}
					RenderTexture.ReleaseTemporary(temporary5);
				}
				int pass = (int)bloomScreenBlendMode;
				screenBlend.SetFloat("_Intensity", bloomIntensity);
				screenBlend.SetTexture("_ColorBuffer", source);
				if (quality > BloomQuality.Cheap)
				{
					RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, format);
					Graphics.Blit(renderTexture, temporary6);
					Graphics.Blit(temporary6, destination, screenBlend, pass);
					RenderTexture.ReleaseTemporary(temporary6);
				}
				else
				{
					Graphics.Blit(renderTexture, destination, screenBlend, pass);
				}
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(renderTexture);
			}

			private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
			{
				screenBlend.SetFloat("_Intensity", intensity_);
				to.MarkRestoreExpected();
				Graphics.Blit(from, to, screenBlend, 9);
			}

			private void BlendFlares(RenderTexture from, RenderTexture to)
			{
				lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
				to.MarkRestoreExpected();
				Graphics.Blit(from, to, lensFlareMaterial);
			}

			private void BrightFilter(float thresh, RenderTexture from, RenderTexture to)
			{
				brightPassFilterMaterial.SetVector("_Threshhold", new Vector4(thresh, thresh, thresh, thresh));
				Graphics.Blit(from, to, brightPassFilterMaterial, 0);
			}

			private void BrightFilter(Color threshColor, RenderTexture from, RenderTexture to)
			{
				brightPassFilterMaterial.SetVector("_Threshhold", threshColor);
				Graphics.Blit(from, to, brightPassFilterMaterial, 1);
			}

			private void Vignette(float amount, RenderTexture from, RenderTexture to)
			{
				if ((bool)lensFlareVignetteMask)
				{
					screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
					to.MarkRestoreExpected();
					Graphics.Blit((from == to) ? null : from, to, screenBlend, (from == to) ? 7 : 3);
				}
				else if (from != to)
				{
					Graphics.SetRenderTarget(to);
					GL.Clear(clearDepth: false, clearColor: true, Color.black);
					Graphics.Blit(from, to);
				}
			}
		}
		public enum LensflareStyle34
		{
			Ghosting,
			Anamorphic,
			Combined
		}
		public enum TweakMode34
		{
			Basic,
			Complex
		}
		public enum HDRBloomMode
		{
			Auto,
			On,
			Off
		}
		public enum BloomScreenBlendMode
		{
			Screen,
			Add
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Bloom and Glow/BloomAndFlares (3.5, Deprecated)")]
		public class BloomAndFlares : PostEffectsBase
		{
			public TweakMode34 tweakMode;

			public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

			public HDRBloomMode hdr;

			private bool doHdr;

			public float sepBlurSpread = 1.5f;

			public float useSrcAlphaAsMask = 0.5f;

			public float bloomIntensity = 1f;

			public float bloomThreshold = 0.5f;

			public int bloomBlurIterations = 2;

			public bool lensflares;

			public int hollywoodFlareBlurIterations = 2;

			public LensflareStyle34 lensflareMode = LensflareStyle34.Anamorphic;

			public float hollyStretchWidth = 3.5f;

			public float lensflareIntensity = 1f;

			public float lensflareThreshold = 0.3f;

			public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

			public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

			public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

			public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

			public Texture2D lensFlareVignetteMask;

			public Shader lensFlareShader;

			private Material lensFlareMaterial;

			public Shader vignetteShader;

			private Material vignetteMaterial;

			public Shader separableBlurShader;

			private Material separableBlurMaterial;

			public Shader addBrightStuffOneOneShader;

			private Material addBrightStuffBlendOneOneMaterial;

			public Shader screenBlendShader;

			private Material screenBlend;

			public Shader hollywoodFlaresShader;

			private Material hollywoodFlaresMaterial;

			public Shader brightPassFilterShader;

			private Material brightPassFilterMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
				lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
				vignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, vignetteMaterial);
				separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
				addBrightStuffBlendOneOneMaterial = CheckShaderAndCreateMaterial(addBrightStuffOneOneShader, addBrightStuffBlendOneOneMaterial);
				hollywoodFlaresMaterial = CheckShaderAndCreateMaterial(hollywoodFlaresShader, hollywoodFlaresMaterial);
				brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				doHdr = false;
				if (hdr == HDRBloomMode.Auto)
				{
					doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
				}
				else
				{
					doHdr = hdr == HDRBloomMode.On;
				}
				doHdr = doHdr && supportHDRTextures;
				BloomScreenBlendMode pass = screenBlendMode;
				if (doHdr)
				{
					pass = BloomScreenBlendMode.Add;
				}
				RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
				RenderTexture temporary = RenderTexture.GetTemporary(source.width / 2, source.height / 2, 0, format);
				RenderTexture temporary2 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
				RenderTexture temporary3 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
				RenderTexture temporary4 = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0, format);
				float num = 1f * (float)source.width / (1f * (float)source.height);
				float num2 = 0.001953125f;
				Graphics.Blit(source, temporary, screenBlend, 2);
				Graphics.Blit(temporary, temporary2, screenBlend, 2);
				RenderTexture.ReleaseTemporary(temporary);
				BrightFilter(bloomThreshold, useSrcAlphaAsMask, temporary2, temporary3);
				temporary2.DiscardContents();
				if (bloomBlurIterations < 1)
				{
					bloomBlurIterations = 1;
				}
				for (int i = 0; i < bloomBlurIterations; i++)
				{
					float num3 = (1f + (float)i * 0.5f) * sepBlurSpread;
					separableBlurMaterial.SetVector("offsets", new Vector4(0f, num3 * num2, 0f, 0f));
					RenderTexture obj = ((i == 0) ? temporary3 : temporary2);
					Graphics.Blit(obj, temporary4, separableBlurMaterial);
					obj.DiscardContents();
					separableBlurMaterial.SetVector("offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
					Graphics.Blit(temporary4, temporary2, separableBlurMaterial);
					temporary4.DiscardContents();
				}
				if (lensflares)
				{
					if (lensflareMode == LensflareStyle34.Ghosting)
					{
						BrightFilter(lensflareThreshold, 0f, temporary2, temporary4);
						temporary2.DiscardContents();
						Vignette(0.975f, temporary4, temporary3);
						temporary4.DiscardContents();
						BlendFlares(temporary3, temporary2);
						temporary3.DiscardContents();
					}
					else
					{
						hollywoodFlaresMaterial.SetVector("_threshold", new Vector4(lensflareThreshold, 1f / (1f - lensflareThreshold), 0f, 0f));
						hollywoodFlaresMaterial.SetVector("tintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
						Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 2);
						temporary4.DiscardContents();
						Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 3);
						temporary3.DiscardContents();
						hollywoodFlaresMaterial.SetVector("offsets", new Vector4(sepBlurSpread * 1f / num * num2, 0f, 0f, 0f));
						hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth);
						Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
						temporary4.DiscardContents();
						hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 2f);
						Graphics.Blit(temporary3, temporary4, hollywoodFlaresMaterial, 1);
						temporary3.DiscardContents();
						hollywoodFlaresMaterial.SetFloat("stretchWidth", hollyStretchWidth * 4f);
						Graphics.Blit(temporary4, temporary3, hollywoodFlaresMaterial, 1);
						temporary4.DiscardContents();
						if (lensflareMode == LensflareStyle34.Anamorphic)
						{
							for (int j = 0; j < hollywoodFlareBlurIterations; j++)
							{
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
								temporary3.DiscardContents();
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
								temporary4.DiscardContents();
							}
							AddTo(1f, temporary3, temporary2);
							temporary3.DiscardContents();
						}
						else
						{
							for (int k = 0; k < hollywoodFlareBlurIterations; k++)
							{
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary3, temporary4, separableBlurMaterial);
								temporary3.DiscardContents();
								separableBlurMaterial.SetVector("offsets", new Vector4(hollyStretchWidth * 2f / num * num2, 0f, 0f, 0f));
								Graphics.Blit(temporary4, temporary3, separableBlurMaterial);
								temporary4.DiscardContents();
							}
							Vignette(1f, temporary3, temporary4);
							temporary3.DiscardContents();
							BlendFlares(temporary4, temporary3);
							temporary4.DiscardContents();
							AddTo(1f, temporary3, temporary2);
							temporary3.DiscardContents();
						}
					}
				}
				screenBlend.SetFloat("_Intensity", bloomIntensity);
				screenBlend.SetTexture("_ColorBuffer", source);
				Graphics.Blit(temporary2, destination, screenBlend, (int)pass);
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture.ReleaseTemporary(temporary3);
				RenderTexture.ReleaseTemporary(temporary4);
			}

			private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
			{
				addBrightStuffBlendOneOneMaterial.SetFloat("_Intensity", intensity_);
				Graphics.Blit(from, to, addBrightStuffBlendOneOneMaterial);
			}

			private void BlendFlares(RenderTexture from, RenderTexture to)
			{
				lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
				lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
				Graphics.Blit(from, to, lensFlareMaterial);
			}

			private void BrightFilter(float thresh, float useAlphaAsMask, RenderTexture from, RenderTexture to)
			{
				if (doHdr)
				{
					brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f, 0f, 0f));
				}
				else
				{
					brightPassFilterMaterial.SetVector("threshold", new Vector4(thresh, 1f / (1f - thresh), 0f, 0f));
				}
				brightPassFilterMaterial.SetFloat("useSrcAlphaAsMask", useAlphaAsMask);
				Graphics.Blit(from, to, brightPassFilterMaterial);
			}

			private void Vignette(float amount, RenderTexture from, RenderTexture to)
			{
				if ((bool)lensFlareVignetteMask)
				{
					screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
					Graphics.Blit(from, to, screenBlend, 3);
				}
				else
				{
					vignetteMaterial.SetFloat("vignetteIntensity", amount);
					Graphics.Blit(from, to, vignetteMaterial);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Bloom and Glow/Bloom (Optimized)")]
		public class BloomOptimized : PostEffectsBase
		{
			public enum Resolution
			{
				Low,
				High
			}

			public enum BlurType
			{
				Standard,
				Sgx
			}

			[Range(0f, 1.5f)]
			public float threshold = 0.25f;

			[Range(0f, 2.5f)]
			public float intensity = 0.75f;

			[Range(0.25f, 5.5f)]
			public float blurSize = 1f;

			private Resolution resolution;

			[Range(1f, 4f)]
			public int blurIterations = 1;

			public BlurType blurType;

			public Shader fastBloomShader;

			private Material fastBloomMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				fastBloomMaterial = CheckShaderAndCreateMaterial(fastBloomShader, fastBloomMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				if ((bool)fastBloomMaterial)
				{
					UnityEngine.Object.DestroyImmediate(fastBloomMaterial);
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int num = ((resolution == Resolution.Low) ? 4 : 2);
				float num2 = ((resolution == Resolution.Low) ? 0.5f : 1f);
				fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2, 0f, threshold, intensity));
				source.filterMode = FilterMode.Bilinear;
				int width = source.width / num;
				int height = source.height / num;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
				Graphics.Blit(source, renderTexture, fastBloomMaterial, 1);
				int num3 = ((blurType != 0) ? 2 : 0);
				for (int i = 0; i < blurIterations; i++)
				{
					fastBloomMaterial.SetVector("_Parameter", new Vector4(blurSize * num2 + (float)i * 1f, 0f, threshold, intensity));
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 2 + num3);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
					temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, fastBloomMaterial, 3 + num3);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				fastBloomMaterial.SetTexture("_Bloom", renderTexture);
				Graphics.Blit(source, destination, fastBloomMaterial, 0);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Blur/Blur")]
		public class Blur : MonoBehaviour
		{
			[Range(0f, 10f)]
			public int iterations = 3;

			[Range(0f, 1f)]
			public float blurSpread = 0.6f;

			public Shader blurShader;

			private static Material m_Material;

			protected Material material
			{
				get
				{
					if (m_Material == null)
					{
						m_Material = new Material(blurShader);
						m_Material.hideFlags = HideFlags.DontSave;
					}
					return m_Material;
				}
			}

			protected void OnDisable()
			{
				if ((bool)m_Material)
				{
					UnityEngine.Object.DestroyImmediate(m_Material);
				}
			}

			protected void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (!blurShader || !material.shader.isSupported)
				{
					base.enabled = false;
				}
			}

			public void FourTapCone(RenderTexture source, RenderTexture dest, int iteration)
			{
				float num = 0.5f + (float)iteration * blurSpread;
				Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
			}

			private void DownSample4x(RenderTexture source, RenderTexture dest)
			{
				float num = 1f;
				Graphics.BlitMultiTap(source, dest, material, new Vector2(0f - num, 0f - num), new Vector2(0f - num, num), new Vector2(num, num), new Vector2(num, 0f - num));
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				int width = source.width / 4;
				int height = source.height / 4;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0);
				DownSample4x(source, renderTexture);
				for (int i = 0; i < iterations; i++)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
					FourTapCone(renderTexture, temporary, i);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				Graphics.Blit(renderTexture, destination);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Blur/Blur (Optimized)")]
		public class BlurOptimized : PostEffectsBase
		{
			public enum BlurType
			{
				StandardGauss,
				SgxGauss
			}

			[Range(0f, 2f)]
			public int downsample = 1;

			[Range(0f, 10f)]
			public float blurSize = 3f;

			[Range(1f, 4f)]
			public int blurIterations = 2;

			public BlurType blurType;

			public Shader blurShader;

			private Material blurMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void OnDisable()
			{
				if ((bool)blurMaterial)
				{
					UnityEngine.Object.DestroyImmediate(blurMaterial);
				}
			}

			public void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				float num = 1f / (1f * (float)(1 << downsample));
				blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num, (0f - blurSize) * num, 0f, 0f));
				source.filterMode = FilterMode.Bilinear;
				int width = source.width >> downsample;
				int height = source.height >> downsample;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
				renderTexture.filterMode = FilterMode.Bilinear;
				Graphics.Blit(source, renderTexture, blurMaterial, 0);
				int num2 = ((blurType != 0) ? 2 : 0);
				for (int i = 0; i < blurIterations; i++)
				{
					float num3 = (float)i * 1f;
					blurMaterial.SetVector("_Parameter", new Vector4(blurSize * num + num3, (0f - blurSize) * num - num3, 0f, 0f));
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, blurMaterial, 1 + num2);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
					temporary = RenderTexture.GetTemporary(width, height, 0, source.format);
					temporary.filterMode = FilterMode.Bilinear;
					Graphics.Blit(renderTexture, temporary, blurMaterial, 2 + num2);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				Graphics.Blit(renderTexture, destination);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Camera Motion Blur")]
		public class CameraMotionBlur : PostEffectsBase
		{
			public enum MotionBlurFilter
			{
				CameraMotion,
				LocalBlur,
				Reconstruction,
				ReconstructionDX11,
				ReconstructionDisc
			}

			private static float MAX_RADIUS = 10f;

			public MotionBlurFilter filterType = MotionBlurFilter.Reconstruction;

			public bool preview;

			public Vector3 previewScale = Vector3.one;

			public float movementScale;

			public float rotationScale = 1f;

			public float maxVelocity = 8f;

			public float minVelocity = 0.1f;

			public float velocityScale = 0.375f;

			public float softZDistance = 0.005f;

			public int velocityDownsample = 1;

			public LayerMask excludeLayers = 0;

			private GameObject tmpCam;

			public Shader shader;

			public Shader dx11MotionBlurShader;

			public Shader replacementClear;

			private Material motionBlurMaterial;

			private Material dx11MotionBlurMaterial;

			public Texture2D noiseTexture;

			public float jitter = 0.05f;

			public bool showVelocity;

			public float showVelocityScale = 1f;

			private Matrix4x4 currentViewProjMat;

			private Matrix4x4[] currentStereoViewProjMat;

			private Matrix4x4 prevViewProjMat;

			private Matrix4x4[] prevStereoViewProjMat;

			private int prevFrameCount;

			private bool wasActive;

			private Vector3 prevFrameForward = Vector3.forward;

			private Vector3 prevFrameUp = Vector3.up;

			private Vector3 prevFramePos = Vector3.zero;

			private Camera _camera;

			private void CalculateViewProjection()
			{
				Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
				Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
				currentViewProjMat = gPUProjectionMatrix * worldToCameraMatrix;
				if (_camera.stereoEnabled)
				{
					for (int i = 0; i < 2; i++)
					{
						Matrix4x4 stereoViewMatrix = _camera.GetStereoViewMatrix((i != 0) ? Camera.StereoscopicEye.Right : Camera.StereoscopicEye.Left);
						Matrix4x4 stereoProjectionMatrix = _camera.GetStereoProjectionMatrix((i != 0) ? Camera.StereoscopicEye.Right : Camera.StereoscopicEye.Left);
						stereoProjectionMatrix = GL.GetGPUProjectionMatrix(stereoProjectionMatrix, renderIntoTexture: true);
						currentStereoViewProjMat[i] = stereoProjectionMatrix * stereoViewMatrix;
					}
				}
			}

			private new void Start()
			{
				CheckResources();
				if (_camera == null)
				{
					_camera = GetComponent<Camera>();
				}
				wasActive = base.gameObject.activeInHierarchy;
				currentStereoViewProjMat = new Matrix4x4[2];
				prevStereoViewProjMat = new Matrix4x4[2];
				CalculateViewProjection();
				Remember();
				wasActive = false;
			}

			private void OnEnable()
			{
				if (_camera == null)
				{
					_camera = GetComponent<Camera>();
				}
				_camera.depthTextureMode |= DepthTextureMode.Depth;
			}

			private void OnDisable()
			{
				if (null != motionBlurMaterial)
				{
					UnityEngine.Object.DestroyImmediate(motionBlurMaterial);
					motionBlurMaterial = null;
				}
				if (null != dx11MotionBlurMaterial)
				{
					UnityEngine.Object.DestroyImmediate(dx11MotionBlurMaterial);
					dx11MotionBlurMaterial = null;
				}
				if (null != tmpCam)
				{
					UnityEngine.Object.DestroyImmediate(tmpCam);
					tmpCam = null;
				}
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true, needHdr: true);
				motionBlurMaterial = CheckShaderAndCreateMaterial(shader, motionBlurMaterial);
				if (supportDX11 && filterType == MotionBlurFilter.ReconstructionDX11)
				{
					dx11MotionBlurMaterial = CheckShaderAndCreateMaterial(dx11MotionBlurShader, dx11MotionBlurMaterial);
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (filterType == MotionBlurFilter.CameraMotion)
				{
					StartFrame();
				}
				RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
				RenderTexture temporary = RenderTexture.GetTemporary(divRoundUp(source.width, velocityDownsample), divRoundUp(source.height, velocityDownsample), 0, format);
				int num = 1;
				int num2 = 1;
				maxVelocity = Mathf.Max(2f, maxVelocity);
				float num3 = maxVelocity;
				bool flag = filterType == MotionBlurFilter.ReconstructionDX11 && dx11MotionBlurMaterial == null;
				if (filterType == MotionBlurFilter.Reconstruction || flag || filterType == MotionBlurFilter.ReconstructionDisc)
				{
					maxVelocity = Mathf.Min(maxVelocity, MAX_RADIUS);
					num = divRoundUp(temporary.width, (int)maxVelocity);
					num2 = divRoundUp(temporary.height, (int)maxVelocity);
					num3 = temporary.width / num;
				}
				else
				{
					num = divRoundUp(temporary.width, (int)maxVelocity);
					num2 = divRoundUp(temporary.height, (int)maxVelocity);
					num3 = temporary.width / num;
				}
				RenderTexture temporary2 = RenderTexture.GetTemporary(num, num2, 0, format);
				RenderTexture temporary3 = RenderTexture.GetTemporary(num, num2, 0, format);
				temporary.filterMode = FilterMode.Point;
				temporary2.filterMode = FilterMode.Point;
				temporary3.filterMode = FilterMode.Point;
				if ((bool)noiseTexture)
				{
					noiseTexture.filterMode = FilterMode.Point;
				}
				source.wrapMode = TextureWrapMode.Clamp;
				temporary.wrapMode = TextureWrapMode.Clamp;
				temporary3.wrapMode = TextureWrapMode.Clamp;
				temporary2.wrapMode = TextureWrapMode.Clamp;
				CalculateViewProjection();
				if (base.gameObject.activeInHierarchy && !wasActive)
				{
					Remember();
				}
				wasActive = base.gameObject.activeInHierarchy;
				Matrix4x4 matrix4x = Matrix4x4.Inverse(currentViewProjMat);
				motionBlurMaterial.SetMatrix("_InvViewProj", matrix4x);
				motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
				motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
				if (_camera.stereoEnabled)
				{
					Matrix4x4[] array = new Matrix4x4[2]
					{
						Matrix4x4.Inverse(currentStereoViewProjMat[0]),
						Matrix4x4.Inverse(currentStereoViewProjMat[1])
					};
					Matrix4x4 value = prevStereoViewProjMat[0] * array[0];
					motionBlurMaterial.SetMatrix("_StereoToPrevViewProjCombined0", value);
					motionBlurMaterial.SetMatrix("_StereoToPrevViewProjCombined1", prevStereoViewProjMat[1] * array[1]);
				}
				motionBlurMaterial.SetFloat("_MaxVelocity", num3);
				motionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
				motionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
				motionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
				motionBlurMaterial.SetFloat("_Jitter", jitter);
				motionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
				motionBlurMaterial.SetTexture("_VelTex", temporary);
				motionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
				motionBlurMaterial.SetTexture("_TileTexDebug", temporary2);
				if (preview)
				{
					Matrix4x4 worldToCameraMatrix = _camera.worldToCameraMatrix;
					Matrix4x4 identity = Matrix4x4.identity;
					identity.SetTRS(previewScale * 0.3333f, Quaternion.identity, Vector3.one);
					Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(_camera.projectionMatrix, renderIntoTexture: true);
					prevViewProjMat = gPUProjectionMatrix * identity * worldToCameraMatrix;
					motionBlurMaterial.SetMatrix("_PrevViewProj", prevViewProjMat);
					motionBlurMaterial.SetMatrix("_ToPrevViewProjCombined", prevViewProjMat * matrix4x);
				}
				if (filterType == MotionBlurFilter.CameraMotion)
				{
					Vector4 zero = Vector4.zero;
					float num4 = Vector3.Dot(base.transform.up, Vector3.up);
					Vector3 rhs = prevFramePos - base.transform.position;
					float magnitude = rhs.magnitude;
					float num5 = 1f;
					num5 = Vector3.Angle(base.transform.up, prevFrameUp) / _camera.fieldOfView * ((float)source.width * 0.75f);
					zero.x = rotationScale * num5;
					num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
					zero.y = rotationScale * num4 * num5;
					num5 = Vector3.Angle(base.transform.forward, prevFrameForward) / _camera.fieldOfView * ((float)source.width * 0.75f);
					zero.z = rotationScale * (1f - num4) * num5;
					if (magnitude > Mathf.Epsilon && movementScale > Mathf.Epsilon)
					{
						zero.w = movementScale * Vector3.Dot(base.transform.forward, rhs) * ((float)source.width * 0.5f);
						zero.x += movementScale * Vector3.Dot(base.transform.up, rhs) * ((float)source.width * 0.5f);
						zero.y += movementScale * Vector3.Dot(base.transform.right, rhs) * ((float)source.width * 0.5f);
					}
					if (preview)
					{
						motionBlurMaterial.SetVector("_BlurDirectionPacked", new Vector4(previewScale.y, previewScale.x, 0f, previewScale.z) * 0.5f * _camera.fieldOfView);
					}
					else
					{
						motionBlurMaterial.SetVector("_BlurDirectionPacked", zero);
					}
				}
				else
				{
					Graphics.Blit(source, temporary, motionBlurMaterial, 0);
					Camera camera = null;
					if (excludeLayers.value != 0)
					{
						camera = GetTmpCam();
					}
					if ((bool)camera && excludeLayers.value != 0 && (bool)replacementClear && replacementClear.isSupported)
					{
						camera.targetTexture = temporary;
						camera.cullingMask = excludeLayers;
						camera.RenderWithShader(replacementClear, "");
					}
				}
				if (!preview && Time.frameCount != prevFrameCount)
				{
					prevFrameCount = Time.frameCount;
					Remember();
				}
				source.filterMode = FilterMode.Bilinear;
				if (showVelocity)
				{
					motionBlurMaterial.SetFloat("_DisplayVelocityScale", showVelocityScale);
					Graphics.Blit(temporary, destination, motionBlurMaterial, 1);
				}
				else if (filterType == MotionBlurFilter.ReconstructionDX11 && !flag)
				{
					dx11MotionBlurMaterial.SetFloat("_MinVelocity", minVelocity);
					dx11MotionBlurMaterial.SetFloat("_VelocityScale", velocityScale);
					dx11MotionBlurMaterial.SetFloat("_Jitter", jitter);
					dx11MotionBlurMaterial.SetTexture("_NoiseTex", noiseTexture);
					dx11MotionBlurMaterial.SetTexture("_VelTex", temporary);
					dx11MotionBlurMaterial.SetTexture("_NeighbourMaxTex", temporary3);
					dx11MotionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
					dx11MotionBlurMaterial.SetFloat("_MaxRadiusOrKInPaper", num3);
					Graphics.Blit(temporary, temporary2, dx11MotionBlurMaterial, 0);
					Graphics.Blit(temporary2, temporary3, dx11MotionBlurMaterial, 1);
					Graphics.Blit(source, destination, dx11MotionBlurMaterial, 2);
				}
				else if (filterType == MotionBlurFilter.Reconstruction || flag)
				{
					motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
					Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
					Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
					Graphics.Blit(source, destination, motionBlurMaterial, 4);
				}
				else if (filterType == MotionBlurFilter.CameraMotion)
				{
					Graphics.Blit(source, destination, motionBlurMaterial, 6);
				}
				else if (filterType == MotionBlurFilter.ReconstructionDisc)
				{
					motionBlurMaterial.SetFloat("_SoftZDistance", Mathf.Max(0.00025f, softZDistance));
					Graphics.Blit(temporary, temporary2, motionBlurMaterial, 2);
					Graphics.Blit(temporary2, temporary3, motionBlurMaterial, 3);
					Graphics.Blit(source, destination, motionBlurMaterial, 7);
				}
				else
				{
					Graphics.Blit(source, destination, motionBlurMaterial, 5);
				}
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(temporary2);
				RenderTexture.ReleaseTemporary(temporary3);
			}

			private void Remember()
			{
				prevViewProjMat = currentViewProjMat;
				prevFrameForward = base.transform.forward;
				prevFrameUp = base.transform.up;
				prevFramePos = base.transform.position;
				prevStereoViewProjMat[0] = currentStereoViewProjMat[0];
				prevStereoViewProjMat[1] = currentStereoViewProjMat[1];
			}

			private Camera GetTmpCam()
			{
				if (tmpCam == null)
				{
					string text = "_" + _camera.name + "_MotionBlurTmpCam";
					GameObject gameObject = GameObject.Find(text);
					if (null == gameObject)
					{
						tmpCam = new GameObject(text, typeof(Camera));
					}
					else
					{
						tmpCam = gameObject;
					}
				}
				tmpCam.hideFlags = HideFlags.DontSave;
				tmpCam.transform.position = _camera.transform.position;
				tmpCam.transform.rotation = _camera.transform.rotation;
				tmpCam.transform.localScale = _camera.transform.localScale;
				tmpCam.GetComponent<Camera>().CopyFrom(_camera);
				tmpCam.GetComponent<Camera>().enabled = false;
				tmpCam.GetComponent<Camera>().depthTextureMode = DepthTextureMode.None;
				tmpCam.GetComponent<Camera>().clearFlags = CameraClearFlags.Nothing;
				return tmpCam.GetComponent<Camera>();
			}

			private void StartFrame()
			{
				prevFramePos = Vector3.Slerp(prevFramePos, base.transform.position, 0.75f);
			}

			private static int divRoundUp(int x, int d)
			{
				return (x + d - 1) / d;
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Curves, Saturation)")]
		public class ColorCorrectionCurves : PostEffectsBase
		{
			public enum ColorCorrectionMode
			{
				Simple,
				Advanced
			}

			public AnimationCurve redChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve greenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve blueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public bool useDepthCorrection;

			public AnimationCurve zCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve depthRedChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve depthGreenChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			public AnimationCurve depthBlueChannel = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(1f, 1f));

			private Material ccMaterial;

			private Material ccDepthMaterial;

			private Material selectiveCcMaterial;

			private Texture2D rgbChannelTex;

			private Texture2D rgbDepthChannelTex;

			private Texture2D zCurveTex;

			public float saturation = 1f;

			public bool selectiveCc;

			public Color selectiveFromColor = Color.white;

			public Color selectiveToColor = Color.white;

			public ColorCorrectionMode mode;

			public bool updateTextures = true;

			public Shader colorCorrectionCurvesShader;

			public Shader simpleColorCorrectionCurvesShader;

			public Shader colorCorrectionSelectiveShader;

			private bool updateTexturesOnStartup = true;

			private new void Start()
			{
				base.Start();
				updateTexturesOnStartup = true;
			}

			private void Awake()
			{
			}

			public override bool CheckResources()
			{
				CheckSupport(mode == ColorCorrectionMode.Advanced);
				ccMaterial = CheckShaderAndCreateMaterial(simpleColorCorrectionCurvesShader, ccMaterial);
				ccDepthMaterial = CheckShaderAndCreateMaterial(colorCorrectionCurvesShader, ccDepthMaterial);
				selectiveCcMaterial = CheckShaderAndCreateMaterial(colorCorrectionSelectiveShader, selectiveCcMaterial);
				if (!rgbChannelTex)
				{
					rgbChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
				}
				if (!rgbDepthChannelTex)
				{
					rgbDepthChannelTex = new Texture2D(256, 4, TextureFormat.ARGB32, mipChain: false, linear: true);
				}
				if (!zCurveTex)
				{
					zCurveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
				}
				rgbChannelTex.hideFlags = HideFlags.DontSave;
				rgbDepthChannelTex.hideFlags = HideFlags.DontSave;
				zCurveTex.hideFlags = HideFlags.DontSave;
				rgbChannelTex.wrapMode = TextureWrapMode.Clamp;
				rgbDepthChannelTex.wrapMode = TextureWrapMode.Clamp;
				zCurveTex.wrapMode = TextureWrapMode.Clamp;
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public void UpdateParameters()
			{
				CheckResources();
				if (redChannel != null && greenChannel != null && blueChannel != null)
				{
					for (float num = 0f; num <= 1f; num += 0.003921569f)
					{
						float num2 = Mathf.Clamp(redChannel.Evaluate(num), 0f, 1f);
						float num3 = Mathf.Clamp(greenChannel.Evaluate(num), 0f, 1f);
						float num4 = Mathf.Clamp(blueChannel.Evaluate(num), 0f, 1f);
						rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
						rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
						rgbChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
						float num5 = Mathf.Clamp(zCurve.Evaluate(num), 0f, 1f);
						zCurveTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num5, num5, num5));
						num2 = Mathf.Clamp(depthRedChannel.Evaluate(num), 0f, 1f);
						num3 = Mathf.Clamp(depthGreenChannel.Evaluate(num), 0f, 1f);
						num4 = Mathf.Clamp(depthBlueChannel.Evaluate(num), 0f, 1f);
						rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 0, new Color(num2, num2, num2));
						rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 1, new Color(num3, num3, num3));
						rgbDepthChannelTex.SetPixel((int)Mathf.Floor(num * 255f), 2, new Color(num4, num4, num4));
					}
					rgbChannelTex.Apply();
					rgbDepthChannelTex.Apply();
					zCurveTex.Apply();
				}
			}

			private void UpdateTextures()
			{
				UpdateParameters();
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (updateTexturesOnStartup)
				{
					UpdateParameters();
					updateTexturesOnStartup = false;
				}
				if (useDepthCorrection)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				RenderTexture renderTexture = destination;
				if (selectiveCc)
				{
					renderTexture = RenderTexture.GetTemporary(source.width, source.height);
				}
				if (useDepthCorrection)
				{
					ccDepthMaterial.SetTexture("_RgbTex", rgbChannelTex);
					ccDepthMaterial.SetTexture("_ZCurve", zCurveTex);
					ccDepthMaterial.SetTexture("_RgbDepthTex", rgbDepthChannelTex);
					ccDepthMaterial.SetFloat("_Saturation", saturation);
					Graphics.Blit(source, renderTexture, ccDepthMaterial);
				}
				else
				{
					ccMaterial.SetTexture("_RgbTex", rgbChannelTex);
					ccMaterial.SetFloat("_Saturation", saturation);
					Graphics.Blit(source, renderTexture, ccMaterial);
				}
				if (selectiveCc)
				{
					selectiveCcMaterial.SetColor("selColor", selectiveFromColor);
					selectiveCcMaterial.SetColor("targetColor", selectiveToColor);
					Graphics.Blit(renderTexture, destination, selectiveCcMaterial);
					RenderTexture.ReleaseTemporary(renderTexture);
				}
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (3D Lookup Texture)")]
		public class ColorCorrectionLookup : PostEffectsBase
		{
			public Shader shader;

			private Material material;

			public Texture3D converted3DLut;

			public string basedOnTempTex = "";

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				material = CheckShaderAndCreateMaterial(shader, material);
				if (!isSupported || !SystemInfo.supports3DTextures)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				if ((bool)material)
				{
					UnityEngine.Object.DestroyImmediate(material);
					material = null;
				}
			}

			private void OnDestroy()
			{
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = null;
			}

			public void SetIdentityLut()
			{
				int num = 16;
				Color[] array = new Color[num * num * num];
				float num2 = 1f / (1f * (float)num - 1f);
				for (int i = 0; i < num; i++)
				{
					for (int j = 0; j < num; j++)
					{
						for (int k = 0; k < num; k++)
						{
							array[i + j * num + k * num * num] = new Color((float)i * 1f * num2, (float)j * 1f * num2, (float)k * 1f * num2, 1f);
						}
					}
				}
				if ((bool)converted3DLut)
				{
					UnityEngine.Object.DestroyImmediate(converted3DLut);
				}
				converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
				converted3DLut.SetPixels(array);
				converted3DLut.Apply();
				basedOnTempTex = "";
			}

			public bool ValidDimensions(Texture2D tex2d)
			{
				if (!tex2d)
				{
					return false;
				}
				if (tex2d.height != Mathf.FloorToInt(Mathf.Sqrt(tex2d.width)))
				{
					return false;
				}
				return true;
			}

			public void Convert(Texture2D temp2DTex, string path)
			{
				if ((bool)temp2DTex)
				{
					int num = temp2DTex.width * temp2DTex.height;
					num = temp2DTex.height;
					if (!ValidDimensions(temp2DTex))
					{
						UnityEngine.Debug.LogWarning("The given 2D texture " + temp2DTex.name + " cannot be used as a 3D LUT.");
						basedOnTempTex = "";
						return;
					}
					Color[] pixels = temp2DTex.GetPixels();
					Color[] array = new Color[pixels.Length];
					for (int i = 0; i < num; i++)
					{
						for (int j = 0; j < num; j++)
						{
							for (int k = 0; k < num; k++)
							{
								int num2 = num - j - 1;
								array[i + j * num + k * num * num] = pixels[k * num + i + num2 * num * num];
							}
						}
					}
					if ((bool)converted3DLut)
					{
						UnityEngine.Object.DestroyImmediate(converted3DLut);
					}
					converted3DLut = new Texture3D(num, num, num, TextureFormat.ARGB32, mipChain: false);
					converted3DLut.SetPixels(array);
					converted3DLut.Apply();
					basedOnTempTex = path;
				}
				else
				{
					UnityEngine.Debug.LogError("Couldn't color correct with 3D LUT texture. Image Effect will be disabled.");
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources() || !SystemInfo.supports3DTextures)
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (converted3DLut == null)
				{
					SetIdentityLut();
				}
				int width = converted3DLut.width;
				converted3DLut.wrapMode = TextureWrapMode.Clamp;
				material.SetFloat("_Scale", (float)(width - 1) / (1f * (float)width));
				material.SetFloat("_Offset", 1f / (2f * (float)width));
				material.SetTexture("_ClutTex", converted3DLut);
				Graphics.Blit(source, destination, material, (QualitySettings.activeColorSpace == ColorSpace.Linear) ? 1 : 0);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Color Correction (Ramp)")]
		public class ColorCorrectionRamp : ImageEffectBase
		{
			public Texture textureRamp;

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.material.SetTexture("_RampTex", textureRamp);
				Graphics.Blit(source, destination, base.material);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Color Adjustments/Contrast Enhance (Unsharp Mask)")]
		public class ContrastEnhance : PostEffectsBase
		{
			[Range(0f, 1f)]
			public float intensity = 0.5f;

			[Range(0f, 0.999f)]
			public float threshold;

			private Material separableBlurMaterial;

			private Material contrastCompositeMaterial;

			[Range(0f, 1f)]
			public float blurSpread = 1f;

			public Shader separableBlurShader;

			public Shader contrastCompositeShader;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				contrastCompositeMaterial = CheckShaderAndCreateMaterial(contrastCompositeShader, contrastCompositeMaterial);
				separableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, separableBlurMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int width = source.width;
				int height = source.height;
				RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				Graphics.Blit(source, temporary);
				RenderTexture temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
				Graphics.Blit(temporary, temporary2);
				RenderTexture.ReleaseTemporary(temporary);
				separableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 1f / (float)temporary2.height, 0f, 0f));
				RenderTexture temporary3 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
				Graphics.Blit(temporary2, temporary3, separableBlurMaterial);
				RenderTexture.ReleaseTemporary(temporary2);
				separableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 1f / (float)temporary2.width, 0f, 0f, 0f));
				temporary2 = RenderTexture.GetTemporary(width / 4, height / 4, 0);
				Graphics.Blit(temporary3, temporary2, separableBlurMaterial);
				RenderTexture.ReleaseTemporary(temporary3);
				contrastCompositeMaterial.SetTexture("_MainTexBlurred", temporary2);
				contrastCompositeMaterial.SetFloat("intensity", intensity);
				contrastCompositeMaterial.SetFloat("threshold", threshold);
				Graphics.Blit(source, destination, contrastCompositeMaterial);
				RenderTexture.ReleaseTemporary(temporary2);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Contrast Stretch")]
		public class ContrastStretch : MonoBehaviour
		{
			[Range(0.0001f, 1f)]
			public float adaptationSpeed = 0.02f;

			[Range(0f, 1f)]
			public float limitMinimum = 0.2f;

			[Range(0f, 1f)]
			public float limitMaximum = 0.6f;

			private RenderTexture[] adaptRenderTex = new RenderTexture[2];

			private int curAdaptIndex;

			public Shader shaderLum;

			private Material m_materialLum;

			public Shader shaderReduce;

			private Material m_materialReduce;

			public Shader shaderAdapt;

			private Material m_materialAdapt;

			public Shader shaderApply;

			private Material m_materialApply;

			protected Material materialLum
			{
				get
				{
					if (m_materialLum == null)
					{
						m_materialLum = new Material(shaderLum);
						m_materialLum.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialLum;
				}
			}

			protected Material materialReduce
			{
				get
				{
					if (m_materialReduce == null)
					{
						m_materialReduce = new Material(shaderReduce);
						m_materialReduce.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialReduce;
				}
			}

			protected Material materialAdapt
			{
				get
				{
					if (m_materialAdapt == null)
					{
						m_materialAdapt = new Material(shaderAdapt);
						m_materialAdapt.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialAdapt;
				}
			}

			protected Material materialApply
			{
				get
				{
					if (m_materialApply == null)
					{
						m_materialApply = new Material(shaderApply);
						m_materialApply.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_materialApply;
				}
			}

			private void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (!shaderAdapt.isSupported || !shaderApply.isSupported || !shaderLum.isSupported || !shaderReduce.isSupported)
				{
					base.enabled = false;
				}
			}

			private void OnEnable()
			{
				for (int i = 0; i < 2; i++)
				{
					if (!adaptRenderTex[i])
					{
						adaptRenderTex[i] = new RenderTexture(1, 1, 0);
						adaptRenderTex[i].hideFlags = HideFlags.HideAndDontSave;
					}
				}
			}

			private void OnDisable()
			{
				for (int i = 0; i < 2; i++)
				{
					UnityEngine.Object.DestroyImmediate(adaptRenderTex[i]);
					adaptRenderTex[i] = null;
				}
				if ((bool)m_materialLum)
				{
					UnityEngine.Object.DestroyImmediate(m_materialLum);
				}
				if ((bool)m_materialReduce)
				{
					UnityEngine.Object.DestroyImmediate(m_materialReduce);
				}
				if ((bool)m_materialAdapt)
				{
					UnityEngine.Object.DestroyImmediate(m_materialAdapt);
				}
				if ((bool)m_materialApply)
				{
					UnityEngine.Object.DestroyImmediate(m_materialApply);
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / 1, source.height / 1);
				Graphics.Blit(source, renderTexture, materialLum);
				while (renderTexture.width > 1 || renderTexture.height > 1)
				{
					int num = renderTexture.width / 2;
					if (num < 1)
					{
						num = 1;
					}
					int num2 = renderTexture.height / 2;
					if (num2 < 1)
					{
						num2 = 1;
					}
					RenderTexture temporary = RenderTexture.GetTemporary(num, num2);
					Graphics.Blit(renderTexture, temporary, materialReduce);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				CalculateAdaptation(renderTexture);
				materialApply.SetTexture("_AdaptTex", adaptRenderTex[curAdaptIndex]);
				Graphics.Blit(source, destination, materialApply);
				RenderTexture.ReleaseTemporary(renderTexture);
			}

			private void CalculateAdaptation(Texture curTexture)
			{
				int num = curAdaptIndex;
				curAdaptIndex = (curAdaptIndex + 1) % 2;
				float value = 1f - Mathf.Pow(1f - adaptationSpeed, 30f * Time.deltaTime);
				value = Mathf.Clamp(value, 0.01f, 1f);
				materialAdapt.SetTexture("_CurTex", curTexture);
				materialAdapt.SetVector("_AdaptParams", new Vector4(value, limitMinimum, limitMaximum, 0f));
				Graphics.SetRenderTarget(adaptRenderTex[curAdaptIndex]);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(adaptRenderTex[num], adaptRenderTex[curAdaptIndex], materialAdapt);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Edge Detection/Crease Shading")]
		public class CreaseShading : PostEffectsBase
		{
			public float intensity = 0.5f;

			public int softness = 1;

			public float spread = 1f;

			public Shader blurShader;

			private Material blurMaterial;

			public Shader depthFetchShader;

			private Material depthFetchMaterial;

			public Shader creaseApplyShader;

			private Material creaseApplyMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				blurMaterial = CheckShaderAndCreateMaterial(blurShader, blurMaterial);
				depthFetchMaterial = CheckShaderAndCreateMaterial(depthFetchShader, depthFetchMaterial);
				creaseApplyMaterial = CheckShaderAndCreateMaterial(creaseApplyShader, creaseApplyMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int width = source.width;
				int height = source.height;
				float num = 1f * (float)width / (1f * (float)height);
				float num2 = 0.001953125f;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				RenderTexture renderTexture = RenderTexture.GetTemporary(width / 2, height / 2, 0);
				Graphics.Blit(source, temporary, depthFetchMaterial);
				Graphics.Blit(temporary, renderTexture);
				for (int i = 0; i < softness; i++)
				{
					RenderTexture temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
					blurMaterial.SetVector("offsets", new Vector4(0f, spread * num2, 0f, 0f));
					Graphics.Blit(renderTexture, temporary2, blurMaterial);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary2;
					temporary2 = RenderTexture.GetTemporary(width / 2, height / 2, 0);
					blurMaterial.SetVector("offsets", new Vector4(spread * num2 / num, 0f, 0f, 0f));
					Graphics.Blit(renderTexture, temporary2, blurMaterial);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary2;
				}
				creaseApplyMaterial.SetTexture("_HrDepthTex", temporary);
				creaseApplyMaterial.SetTexture("_LrDepthTex", renderTexture);
				creaseApplyMaterial.SetFloat("intensity", intensity);
				Graphics.Blit(source, destination, creaseApplyMaterial);
				RenderTexture.ReleaseTemporary(temporary);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Depth of Field (Lens Blur, Scatter, DX11)")]
		public class DepthOfField : PostEffectsBase
		{
			public enum BlurType
			{
				DiscBlur,
				DX11
			}

			public enum BlurSampleCount
			{
				Low,
				Medium,
				High
			}

			public bool visualizeFocus;

			public float focalLength = 10f;

			public float focalSize = 0.05f;

			public float aperture = 0.5f;

			public Transform focalTransform;

			public float maxBlurSize = 2f;

			public bool highResolution;

			public BlurType blurType;

			public BlurSampleCount blurSampleCount = BlurSampleCount.High;

			public bool nearBlur;

			public float foregroundOverlap = 1f;

			public Shader dofHdrShader;

			private Material dofHdrMaterial;

			public Shader dx11BokehShader;

			private Material dx11bokehMaterial;

			public float dx11BokehThreshold = 0.5f;

			public float dx11SpawnHeuristic = 0.0875f;

			public Texture2D dx11BokehTexture;

			public float dx11BokehScale = 1.2f;

			public float dx11BokehIntensity = 2.5f;

			private float focalDistance01 = 10f;

			private ComputeBuffer cbDrawArgs;

			private ComputeBuffer cbPoints;

			private float internalBlurWidth = 1f;

			private Camera cachedCamera;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				dofHdrMaterial = CheckShaderAndCreateMaterial(dofHdrShader, dofHdrMaterial);
				if (supportDX11 && blurType == BlurType.DX11)
				{
					dx11bokehMaterial = CheckShaderAndCreateMaterial(dx11BokehShader, dx11bokehMaterial);
					CreateComputeResources();
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnEnable()
			{
				cachedCamera = GetComponent<Camera>();
				cachedCamera.depthTextureMode |= DepthTextureMode.Depth;
			}

			private void OnDisable()
			{
				ReleaseComputeResources();
				if ((bool)dofHdrMaterial)
				{
					UnityEngine.Object.DestroyImmediate(dofHdrMaterial);
				}
				dofHdrMaterial = null;
				if ((bool)dx11bokehMaterial)
				{
					UnityEngine.Object.DestroyImmediate(dx11bokehMaterial);
				}
				dx11bokehMaterial = null;
			}

			private void ReleaseComputeResources()
			{
				if (cbDrawArgs != null)
				{
					cbDrawArgs.Release();
				}
				cbDrawArgs = null;
				if (cbPoints != null)
				{
					cbPoints.Release();
				}
				cbPoints = null;
			}

			private void CreateComputeResources()
			{
				if (cbDrawArgs == null)
				{
					cbDrawArgs = new ComputeBuffer(1, 16, ComputeBufferType.DrawIndirect);
					int[] data = new int[4] { 0, 1, 0, 0 };
					cbDrawArgs.SetData(data);
				}
				if (cbPoints == null)
				{
					cbPoints = new ComputeBuffer(90000, 28, ComputeBufferType.Append);
				}
			}

			private float FocalDistance01(float worldDist)
			{
				return cachedCamera.WorldToViewportPoint((worldDist - cachedCamera.nearClipPlane) * cachedCamera.transform.forward + cachedCamera.transform.position).z / (cachedCamera.farClipPlane - cachedCamera.nearClipPlane);
			}

			private void WriteCoc(RenderTexture fromTo, bool fgDilate)
			{
				dofHdrMaterial.SetTexture("_FgOverlap", null);
				if (nearBlur && fgDilate)
				{
					int width = fromTo.width / 2;
					int height = fromTo.height / 2;
					RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
					Graphics.Blit(fromTo, temporary, dofHdrMaterial, 4);
					float num = internalBlurWidth * foregroundOverlap;
					dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
					RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
					Graphics.Blit(temporary, temporary2, dofHdrMaterial, 2);
					RenderTexture.ReleaseTemporary(temporary);
					dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
					temporary = RenderTexture.GetTemporary(width, height, 0, fromTo.format);
					Graphics.Blit(temporary2, temporary, dofHdrMaterial, 2);
					RenderTexture.ReleaseTemporary(temporary2);
					dofHdrMaterial.SetTexture("_FgOverlap", temporary);
					fromTo.MarkRestoreExpected();
					Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 13);
					RenderTexture.ReleaseTemporary(temporary);
				}
				else
				{
					fromTo.MarkRestoreExpected();
					Graphics.Blit(fromTo, fromTo, dofHdrMaterial, 0);
				}
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (aperture < 0f)
				{
					aperture = 0f;
				}
				if (maxBlurSize < 0.1f)
				{
					maxBlurSize = 0.1f;
				}
				focalSize = Mathf.Clamp(focalSize, 0f, 2f);
				internalBlurWidth = Mathf.Max(maxBlurSize, 0f);
				focalDistance01 = (focalTransform ? (cachedCamera.WorldToViewportPoint(focalTransform.position).z / cachedCamera.farClipPlane) : FocalDistance01(focalLength));
				dofHdrMaterial.SetVector("_CurveParams", new Vector4(1f, focalSize, 1f / (1f - aperture) - 1f, focalDistance01));
				RenderTexture renderTexture = null;
				RenderTexture renderTexture2 = null;
				RenderTexture renderTexture3 = null;
				RenderTexture renderTexture4 = null;
				float num = internalBlurWidth * foregroundOverlap;
				if (visualizeFocus)
				{
					WriteCoc(source, fgDilate: true);
					Graphics.Blit(source, destination, dofHdrMaterial, 16);
				}
				else if (blurType == BlurType.DX11 && (bool)dx11bokehMaterial)
				{
					if (highResolution)
					{
						internalBlurWidth = ((internalBlurWidth < 0.1f) ? 0.1f : internalBlurWidth);
						num = internalBlurWidth * foregroundOverlap;
						renderTexture = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
						RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0, source.format);
						WriteCoc(source, fgDilate: false);
						renderTexture3 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						renderTexture4 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						Graphics.Blit(source, renderTexture3, dofHdrMaterial, 15);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
						if (nearBlur)
						{
							Graphics.Blit(source, renderTexture4, dofHdrMaterial, 4);
						}
						dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
						dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
						dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
						dx11bokehMaterial.SetTexture("_FgCocMask", nearBlur ? renderTexture4 : null);
						Graphics.SetRandomWriteTarget(1, cbPoints);
						Graphics.Blit(source, renderTexture, dx11bokehMaterial, 0);
						Graphics.ClearRandomWriteTargets();
						if (nearBlur)
						{
							dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
							Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 2);
							dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
							Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 2);
							Graphics.Blit(renderTexture4, renderTexture, dofHdrMaterial, 3);
						}
						Graphics.Blit(renderTexture, temporary, dofHdrMaterial, 20);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
						Graphics.Blit(renderTexture, source, dofHdrMaterial, 5);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
						Graphics.Blit(source, temporary, dofHdrMaterial, 21);
						Graphics.SetRenderTarget(temporary);
						ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
						dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
						dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
						dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), internalBlurWidth));
						dx11bokehMaterial.SetPass(2);
						Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
						Graphics.Blit(temporary, destination);
						RenderTexture.ReleaseTemporary(temporary);
						RenderTexture.ReleaseTemporary(renderTexture3);
						RenderTexture.ReleaseTemporary(renderTexture4);
					}
					else
					{
						renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
						num = internalBlurWidth * foregroundOverlap;
						WriteCoc(source, fgDilate: false);
						source.filterMode = FilterMode.Bilinear;
						Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
						renderTexture3 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
						renderTexture4 = RenderTexture.GetTemporary(renderTexture.width >> 1, renderTexture.height >> 1, 0, renderTexture.format);
						Graphics.Blit(renderTexture, renderTexture3, dofHdrMaterial, 15);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f, 0f, 1.5f));
						Graphics.Blit(renderTexture3, renderTexture4, dofHdrMaterial, 19);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(1.5f, 0f, 0f, 1.5f));
						Graphics.Blit(renderTexture4, renderTexture3, dofHdrMaterial, 19);
						RenderTexture renderTexture5 = null;
						if (nearBlur)
						{
							renderTexture5 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
							Graphics.Blit(source, renderTexture5, dofHdrMaterial, 4);
						}
						dx11bokehMaterial.SetTexture("_BlurredColor", renderTexture3);
						dx11bokehMaterial.SetFloat("_SpawnHeuristic", dx11SpawnHeuristic);
						dx11bokehMaterial.SetVector("_BokehParams", new Vector4(dx11BokehScale, dx11BokehIntensity, Mathf.Clamp(dx11BokehThreshold, 0.005f, 4f), internalBlurWidth));
						dx11bokehMaterial.SetTexture("_FgCocMask", renderTexture5);
						Graphics.SetRandomWriteTarget(1, cbPoints);
						Graphics.Blit(renderTexture, renderTexture2, dx11bokehMaterial, 0);
						Graphics.ClearRandomWriteTargets();
						RenderTexture.ReleaseTemporary(renderTexture3);
						RenderTexture.ReleaseTemporary(renderTexture4);
						if (nearBlur)
						{
							dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, num, 0f, num));
							Graphics.Blit(renderTexture5, renderTexture, dofHdrMaterial, 2);
							dofHdrMaterial.SetVector("_Offsets", new Vector4(num, 0f, 0f, num));
							Graphics.Blit(renderTexture, renderTexture5, dofHdrMaterial, 2);
							Graphics.Blit(renderTexture5, renderTexture2, dofHdrMaterial, 3);
						}
						dofHdrMaterial.SetVector("_Offsets", new Vector4(internalBlurWidth, 0f, 0f, internalBlurWidth));
						Graphics.Blit(renderTexture2, renderTexture, dofHdrMaterial, 5);
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0f, internalBlurWidth));
						Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, 5);
						Graphics.SetRenderTarget(renderTexture2);
						ComputeBuffer.CopyCount(cbPoints, cbDrawArgs, 0);
						dx11bokehMaterial.SetBuffer("pointBuffer", cbPoints);
						dx11bokehMaterial.SetTexture("_MainTex", dx11BokehTexture);
						dx11bokehMaterial.SetVector("_Screen", new Vector3(1f / (1f * (float)renderTexture2.width), 1f / (1f * (float)renderTexture2.height), internalBlurWidth));
						dx11bokehMaterial.SetPass(1);
						Graphics.DrawProceduralIndirectNow(MeshTopology.Points, cbDrawArgs);
						dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
						dofHdrMaterial.SetTexture("_FgOverlap", renderTexture5);
						dofHdrMaterial.SetVector("_Offsets", 1f * (float)source.width / (1f * (float)renderTexture2.width) * internalBlurWidth * Vector4.one);
						Graphics.Blit(source, destination, dofHdrMaterial, 9);
						if ((bool)renderTexture5)
						{
							RenderTexture.ReleaseTemporary(renderTexture5);
						}
					}
				}
				else
				{
					source.filterMode = FilterMode.Bilinear;
					if (highResolution)
					{
						internalBlurWidth *= 2f;
					}
					WriteCoc(source, fgDilate: true);
					renderTexture = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					renderTexture2 = RenderTexture.GetTemporary(source.width >> 1, source.height >> 1, 0, source.format);
					int pass = ((blurSampleCount == BlurSampleCount.High || blurSampleCount == BlurSampleCount.Medium) ? 17 : 11);
					if (highResolution)
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
						Graphics.Blit(source, destination, dofHdrMaterial, pass);
					}
					else
					{
						dofHdrMaterial.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.1f, internalBlurWidth));
						Graphics.Blit(source, renderTexture, dofHdrMaterial, 6);
						Graphics.Blit(renderTexture, renderTexture2, dofHdrMaterial, pass);
						dofHdrMaterial.SetTexture("_LowRez", renderTexture2);
						dofHdrMaterial.SetTexture("_FgOverlap", null);
						dofHdrMaterial.SetVector("_Offsets", Vector4.one * (1f * (float)source.width / (1f * (float)renderTexture2.width)) * internalBlurWidth);
						Graphics.Blit(source, destination, dofHdrMaterial, (blurSampleCount == BlurSampleCount.High) ? 18 : 12);
					}
				}
				if ((bool)renderTexture)
				{
					RenderTexture.ReleaseTemporary(renderTexture);
				}
				if ((bool)renderTexture2)
				{
					RenderTexture.ReleaseTemporary(renderTexture2);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Depth of Field (deprecated)")]
		public class DepthOfFieldDeprecated : PostEffectsBase
		{
			public enum Dof34QualitySetting
			{
				OnlyBackground = 1,
				BackgroundAndForeground
			}

			public enum DofResolution
			{
				High = 2,
				Medium,
				Low
			}

			public enum DofBlurriness
			{
				Low = 1,
				High = 2,
				VeryHigh = 4
			}

			public enum BokehDestination
			{
				Background = 1,
				Foreground,
				BackgroundAndForeground
			}

			private static int SMOOTH_DOWNSAMPLE_PASS = 6;

			private static float BOKEH_EXTRA_BLUR = 2f;

			public Dof34QualitySetting quality = Dof34QualitySetting.OnlyBackground;

			public DofResolution resolution = DofResolution.Low;

			public bool simpleTweakMode = true;

			public float focalPoint = 1f;

			public float smoothness = 0.5f;

			public float focalZDistance;

			public float focalZStartCurve = 1f;

			public float focalZEndCurve = 1f;

			private float focalStartCurve = 2f;

			private float focalEndCurve = 2f;

			private float focalDistance01 = 0.1f;

			public Transform objectFocus;

			public float focalSize;

			public DofBlurriness bluriness = DofBlurriness.High;

			public float maxBlurSpread = 1.75f;

			public float foregroundBlurExtrude = 1.15f;

			public Shader dofBlurShader;

			private Material dofBlurMaterial;

			public Shader dofShader;

			private Material dofMaterial;

			public bool visualize;

			public BokehDestination bokehDestination = BokehDestination.Background;

			private float widthOverHeight = 1.25f;

			private float oneOverBaseSize = 0.001953125f;

			public bool bokeh;

			public bool bokehSupport = true;

			public Shader bokehShader;

			public Texture2D bokehTexture;

			public float bokehScale = 2.4f;

			public float bokehIntensity = 0.15f;

			public float bokehThresholdContrast = 0.1f;

			public float bokehThresholdLuminance = 0.55f;

			public int bokehDownsample = 1;

			private Material bokehMaterial;

			private Camera _camera;

			private RenderTexture foregroundTexture;

			private RenderTexture mediumRezWorkTexture;

			private RenderTexture finalDefocus;

			private RenderTexture lowRezWorkTexture;

			private RenderTexture bokehSource;

			private RenderTexture bokehSource2;

			private void CreateMaterials()
			{
				dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
				dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
				bokehSupport = bokehShader.isSupported;
				if (bokeh && bokehSupport && (bool)bokehShader)
				{
					bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
				}
			}

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				dofBlurMaterial = CheckShaderAndCreateMaterial(dofBlurShader, dofBlurMaterial);
				dofMaterial = CheckShaderAndCreateMaterial(dofShader, dofMaterial);
				bokehSupport = bokehShader.isSupported;
				if (bokeh && bokehSupport && (bool)bokehShader)
				{
					bokehMaterial = CheckShaderAndCreateMaterial(bokehShader, bokehMaterial);
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				Quads.Cleanup();
			}

			private void OnEnable()
			{
				_camera = GetComponent<Camera>();
				_camera.depthTextureMode |= DepthTextureMode.Depth;
			}

			private float FocalDistance01(float worldDist)
			{
				return _camera.WorldToViewportPoint((worldDist - _camera.nearClipPlane) * _camera.transform.forward + _camera.transform.position).z / (_camera.farClipPlane - _camera.nearClipPlane);
			}

			private int GetDividerBasedOnQuality()
			{
				int result = 1;
				if (resolution == DofResolution.Medium)
				{
					result = 2;
				}
				else if (resolution == DofResolution.Low)
				{
					result = 2;
				}
				return result;
			}

			private int GetLowResolutionDividerBasedOnQuality(int baseDivider)
			{
				int num = baseDivider;
				if (resolution == DofResolution.High)
				{
					num *= 2;
				}
				if (resolution == DofResolution.Low)
				{
					num *= 2;
				}
				return num;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (smoothness < 0.1f)
				{
					smoothness = 0.1f;
				}
				bokeh = bokeh && bokehSupport;
				float num = (bokeh ? BOKEH_EXTRA_BLUR : 1f);
				bool flag = quality > Dof34QualitySetting.OnlyBackground;
				float num2 = focalSize / (_camera.farClipPlane - _camera.nearClipPlane);
				if (simpleTweakMode)
				{
					focalDistance01 = (objectFocus ? (_camera.WorldToViewportPoint(objectFocus.position).z / _camera.farClipPlane) : FocalDistance01(focalPoint));
					focalStartCurve = focalDistance01 * smoothness;
					focalEndCurve = focalStartCurve;
					flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
				}
				else
				{
					if ((bool)objectFocus)
					{
						Vector3 vector = _camera.WorldToViewportPoint(objectFocus.position);
						vector.z /= _camera.farClipPlane;
						focalDistance01 = vector.z;
					}
					else
					{
						focalDistance01 = FocalDistance01(focalZDistance);
					}
					focalStartCurve = focalZStartCurve;
					focalEndCurve = focalZEndCurve;
					flag = flag && focalPoint > _camera.nearClipPlane + Mathf.Epsilon;
				}
				widthOverHeight = 1f * (float)source.width / (1f * (float)source.height);
				oneOverBaseSize = 0.001953125f;
				dofMaterial.SetFloat("_ForegroundBlurExtrude", foregroundBlurExtrude);
				dofMaterial.SetVector("_CurveParams", new Vector4(simpleTweakMode ? (1f / focalStartCurve) : focalStartCurve, simpleTweakMode ? (1f / focalEndCurve) : focalEndCurve, num2 * 0.5f, focalDistance01));
				dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)source.width), 1f / (1f * (float)source.height), 0f, 0f));
				int dividerBasedOnQuality = GetDividerBasedOnQuality();
				int lowResolutionDividerBasedOnQuality = GetLowResolutionDividerBasedOnQuality(dividerBasedOnQuality);
				AllocateTextures(flag, source, dividerBasedOnQuality, lowResolutionDividerBasedOnQuality);
				Graphics.Blit(source, source, dofMaterial, 3);
				Downsample(source, mediumRezWorkTexture);
				Blur(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 4, maxBlurSpread);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast, bokehThresholdLuminance, 0.95f, 0f));
					Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
					Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
					Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread * num);
				}
				else
				{
					Downsample(mediumRezWorkTexture, lowRezWorkTexture);
					Blur(lowRezWorkTexture, lowRezWorkTexture, bluriness, 0, maxBlurSpread);
				}
				dofBlurMaterial.SetTexture("_TapLow", lowRezWorkTexture);
				dofBlurMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
				Graphics.Blit(null, finalDefocus, dofBlurMaterial, 3);
				if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
				{
					AddBokeh(bokehSource2, bokehSource, finalDefocus);
				}
				dofMaterial.SetTexture("_TapLowBackground", finalDefocus);
				dofMaterial.SetTexture("_TapMedium", mediumRezWorkTexture);
				Graphics.Blit(source, flag ? foregroundTexture : destination, dofMaterial, visualize ? 2 : 0);
				if (flag)
				{
					Graphics.Blit(foregroundTexture, source, dofMaterial, 5);
					Downsample(source, mediumRezWorkTexture);
					BlurFg(mediumRezWorkTexture, mediumRezWorkTexture, DofBlurriness.Low, 2, maxBlurSpread);
					if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
					{
						dofMaterial.SetVector("_Threshhold", new Vector4(bokehThresholdContrast * 0.5f, bokehThresholdLuminance, 0f, 0f));
						Graphics.Blit(mediumRezWorkTexture, bokehSource2, dofMaterial, 11);
						Graphics.Blit(mediumRezWorkTexture, lowRezWorkTexture);
						BlurFg(lowRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread * num);
					}
					else
					{
						BlurFg(mediumRezWorkTexture, lowRezWorkTexture, bluriness, 1, maxBlurSpread);
					}
					Graphics.Blit(lowRezWorkTexture, finalDefocus);
					dofMaterial.SetTexture("_TapLowForeground", finalDefocus);
					Graphics.Blit(source, destination, dofMaterial, visualize ? 1 : 4);
					if (bokeh && (BokehDestination.Foreground & bokehDestination) != 0)
					{
						AddBokeh(bokehSource2, bokehSource, destination);
					}
				}
				ReleaseTextures();
			}

			private void Blur(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
			{
				RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
				if (iterations > DofBlurriness.Low)
				{
					BlurHex(from, to, blurPass, spread, temporary);
					if (iterations > DofBlurriness.High)
					{
						dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
						Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
						dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
						Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
					}
				}
				else
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
				RenderTexture.ReleaseTemporary(temporary);
			}

			private void BlurFg(RenderTexture from, RenderTexture to, DofBlurriness iterations, int blurPass, float spread)
			{
				dofBlurMaterial.SetTexture("_TapHigh", from);
				RenderTexture temporary = RenderTexture.GetTemporary(to.width, to.height);
				if (iterations > DofBlurriness.Low)
				{
					BlurHex(from, to, blurPass, spread, temporary);
					if (iterations > DofBlurriness.High)
					{
						dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
						Graphics.Blit(to, temporary, dofBlurMaterial, blurPass);
						dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
						Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
					}
				}
				else
				{
					dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
					Graphics.Blit(from, temporary, dofBlurMaterial, blurPass);
					dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
					Graphics.Blit(temporary, to, dofBlurMaterial, blurPass);
				}
				RenderTexture.ReleaseTemporary(temporary);
			}

			private void BlurHex(RenderTexture from, RenderTexture to, int blurPass, float spread, RenderTexture tmp)
			{
				dofBlurMaterial.SetVector("offsets", new Vector4(0f, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(from, tmp, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, 0f, 0f, 0f));
				Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, spread * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(to, tmp, dofBlurMaterial, blurPass);
				dofBlurMaterial.SetVector("offsets", new Vector4(spread / widthOverHeight * oneOverBaseSize, (0f - spread) * oneOverBaseSize, 0f, 0f));
				Graphics.Blit(tmp, to, dofBlurMaterial, blurPass);
			}

			private void Downsample(RenderTexture from, RenderTexture to)
			{
				dofMaterial.SetVector("_InvRenderTargetSize", new Vector4(1f / (1f * (float)to.width), 1f / (1f * (float)to.height), 0f, 0f));
				Graphics.Blit(from, to, dofMaterial, SMOOTH_DOWNSAMPLE_PASS);
			}

			private void AddBokeh(RenderTexture bokehInfo, RenderTexture tempTex, RenderTexture finalTarget)
			{
				if (!bokehMaterial)
				{
					return;
				}
				Mesh[] meshes = Quads.GetMeshes(tempTex.width, tempTex.height);
				RenderTexture.active = tempTex;
				GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
				GL.PushMatrix();
				GL.LoadIdentity();
				bokehInfo.filterMode = FilterMode.Point;
				float num = (float)bokehInfo.width * 1f / ((float)bokehInfo.height * 1f);
				float num2 = 2f / (1f * (float)bokehInfo.width);
				num2 += bokehScale * maxBlurSpread * BOKEH_EXTRA_BLUR * oneOverBaseSize;
				bokehMaterial.SetTexture("_Source", bokehInfo);
				bokehMaterial.SetTexture("_MainTex", bokehTexture);
				bokehMaterial.SetVector("_ArScale", new Vector4(num2, num2 * num, 0.5f, 0.5f * num));
				bokehMaterial.SetFloat("_Intensity", bokehIntensity);
				bokehMaterial.SetPass(0);
				Mesh[] array = meshes;
				foreach (Mesh mesh in array)
				{
					if ((bool)mesh)
					{
						Graphics.DrawMeshNow(mesh, Matrix4x4.identity);
					}
				}
				GL.PopMatrix();
				Graphics.Blit(tempTex, finalTarget, dofMaterial, 8);
				bokehInfo.filterMode = FilterMode.Bilinear;
			}

			private void ReleaseTextures()
			{
				if ((bool)foregroundTexture)
				{
					RenderTexture.ReleaseTemporary(foregroundTexture);
				}
				if ((bool)finalDefocus)
				{
					RenderTexture.ReleaseTemporary(finalDefocus);
				}
				if ((bool)mediumRezWorkTexture)
				{
					RenderTexture.ReleaseTemporary(mediumRezWorkTexture);
				}
				if ((bool)lowRezWorkTexture)
				{
					RenderTexture.ReleaseTemporary(lowRezWorkTexture);
				}
				if ((bool)bokehSource)
				{
					RenderTexture.ReleaseTemporary(bokehSource);
				}
				if ((bool)bokehSource2)
				{
					RenderTexture.ReleaseTemporary(bokehSource2);
				}
			}

			private void AllocateTextures(bool blurForeground, RenderTexture source, int divider, int lowTexDivider)
			{
				foregroundTexture = null;
				if (blurForeground)
				{
					foregroundTexture = RenderTexture.GetTemporary(source.width, source.height, 0);
				}
				mediumRezWorkTexture = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
				finalDefocus = RenderTexture.GetTemporary(source.width / divider, source.height / divider, 0);
				lowRezWorkTexture = RenderTexture.GetTemporary(source.width / lowTexDivider, source.height / lowTexDivider, 0);
				bokehSource = null;
				bokehSource2 = null;
				if (bokeh)
				{
					bokehSource = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
					bokehSource2 = RenderTexture.GetTemporary(source.width / (lowTexDivider * bokehDownsample), source.height / (lowTexDivider * bokehDownsample), 0, RenderTextureFormat.ARGBHalf);
					bokehSource.filterMode = FilterMode.Bilinear;
					bokehSource2.filterMode = FilterMode.Bilinear;
					RenderTexture.active = bokehSource2;
					GL.Clear(clearDepth: false, clearColor: true, new Color(0f, 0f, 0f, 0f));
				}
				source.filterMode = FilterMode.Bilinear;
				finalDefocus.filterMode = FilterMode.Bilinear;
				mediumRezWorkTexture.filterMode = FilterMode.Bilinear;
				lowRezWorkTexture.filterMode = FilterMode.Bilinear;
				if ((bool)foregroundTexture)
				{
					foregroundTexture.filterMode = FilterMode.Bilinear;
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Edge Detection/Edge Detection")]
		public class EdgeDetection : PostEffectsBase
		{
			public enum EdgeDetectMode
			{
				TriangleDepthNormals,
				RobertsCrossDepthNormals,
				SobelDepth,
				SobelDepthThin,
				TriangleLuminance
			}

			public EdgeDetectMode mode = EdgeDetectMode.SobelDepthThin;

			public float sensitivityDepth = 1f;

			public float sensitivityNormals = 1f;

			public float lumThreshold = 0.2f;

			public float edgeExp = 1f;

			public float sampleDist = 1f;

			public float edgesOnly;

			public Color edgesOnlyBgColor = Color.white;

			public Shader edgeDetectShader;

			private Material edgeDetectMaterial;

			private EdgeDetectMode oldMode = EdgeDetectMode.SobelDepthThin;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);
				if (mode != oldMode)
				{
					SetCameraFlag();
				}
				oldMode = mode;
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private new void Start()
			{
				oldMode = mode;
			}

			private void SetCameraFlag()
			{
				if (mode == EdgeDetectMode.SobelDepth || mode == EdgeDetectMode.SobelDepthThin)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				else if (mode == EdgeDetectMode.TriangleDepthNormals || mode == EdgeDetectMode.RobertsCrossDepthNormals)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
				}
			}

			private void OnEnable()
			{
				SetCameraFlag();
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				Vector2 vector = new Vector2(sensitivityDepth, sensitivityNormals);
				edgeDetectMaterial.SetVector("_Sensitivity", new Vector4(vector.x, vector.y, 1f, vector.y));
				edgeDetectMaterial.SetFloat("_BgFade", edgesOnly);
				edgeDetectMaterial.SetFloat("_SampleDistance", sampleDist);
				edgeDetectMaterial.SetVector("_BgColor", edgesOnlyBgColor);
				edgeDetectMaterial.SetFloat("_Exponent", edgeExp);
				edgeDetectMaterial.SetFloat("_Threshold", lumThreshold);
				Graphics.Blit(source, destination, edgeDetectMaterial, (int)mode);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Displacement/Fisheye")]
		public class Fisheye : PostEffectsBase
		{
			[Range(0f, 1.5f)]
			public float strengthX = 0.05f;

			[Range(0f, 1.5f)]
			public float strengthY = 0.05f;

			public Shader fishEyeShader;

			private Material fisheyeMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				fisheyeMaterial = CheckShaderAndCreateMaterial(fishEyeShader, fisheyeMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				float num = 5f / 32f;
				float num2 = (float)source.width * 1f / ((float)source.height * 1f);
				fisheyeMaterial.SetVector("intensity", new Vector4(strengthX * num2 * num, strengthY * num, strengthX * num2 * num, strengthY * num));
				Graphics.Blit(source, destination, fisheyeMaterial);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Global Fog")]
		internal class GlobalFog : PostEffectsBase
		{
			[Tooltip("Apply distance-based fog?")]
			public bool distanceFog = true;

			[Tooltip("Exclude far plane pixels from distance-based fog? (Skybox or clear color)")]
			public bool excludeFarPixels = true;

			[Tooltip("Distance fog is based on radial distance from camera when checked")]
			public bool useRadialDistance;

			[Tooltip("Apply height-based fog?")]
			public bool heightFog = true;

			[Tooltip("Fog top Y coordinate")]
			public float height = 1f;

			[Range(0.001f, 10f)]
			public float heightDensity = 2f;

			[Tooltip("Push fog away from the camera by this amount")]
			public float startDistance;

			public Shader fogShader;

			private Material fogMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				fogMaterial = CheckShaderAndCreateMaterial(fogShader, fogMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources() || (!distanceFog && !heightFog))
				{
					Graphics.Blit(source, destination);
					return;
				}
				Camera component = GetComponent<Camera>();
				Transform obj = component.transform;
				Vector3[] array = new Vector3[4];
				component.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), component.farClipPlane, component.stereoActiveEye, array);
				Vector3 vector = obj.TransformVector(array[0]);
				Vector3 vector2 = obj.TransformVector(array[1]);
				Vector3 vector3 = obj.TransformVector(array[2]);
				Vector3 vector4 = obj.TransformVector(array[3]);
				Matrix4x4 identity = Matrix4x4.identity;
				identity.SetRow(0, vector);
				identity.SetRow(1, vector4);
				identity.SetRow(2, vector2);
				identity.SetRow(3, vector3);
				Vector3 position = obj.position;
				float num = position.y - height;
				float z = ((num <= 0f) ? 1f : 0f);
				float y = (excludeFarPixels ? 1f : 2f);
				fogMaterial.SetMatrix("_FrustumCornersWS", identity);
				fogMaterial.SetVector("_CameraWS", position);
				fogMaterial.SetVector("_HeightParams", new Vector4(height, num, z, heightDensity * 0.5f));
				fogMaterial.SetVector("_DistanceParams", new Vector4(0f - Mathf.Max(startDistance, 0f), y, 0f, 0f));
				FogMode fogMode = RenderSettings.fogMode;
				float fogDensity = RenderSettings.fogDensity;
				float fogStartDistance = RenderSettings.fogStartDistance;
				float fogEndDistance = RenderSettings.fogEndDistance;
				bool flag = fogMode == FogMode.Linear;
				float num2 = (flag ? (fogEndDistance - fogStartDistance) : 0f);
				float num3 = ((Mathf.Abs(num2) > 0.0001f) ? (1f / num2) : 0f);
				Vector4 value = default(Vector4);
				value.x = fogDensity * 1.2011224f;
				value.y = fogDensity * 1.442695f;
				value.z = (flag ? (0f - num3) : 0f);
				value.w = (flag ? (fogEndDistance * num3) : 0f);
				fogMaterial.SetVector("_SceneFogParams", value);
				fogMaterial.SetVector("_SceneFogMode", new Vector4((float)fogMode, useRadialDistance ? 1 : 0, 0f, 0f));
				int num4 = 0;
				Graphics.Blit(pass: (!distanceFog || !heightFog) ? (distanceFog ? 1 : 2) : 0, source: source, dest: destination, mat: fogMaterial);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Grayscale")]
		public class Grayscale : ImageEffectBase
		{
			public Texture textureRamp;

			[Range(-1f, 1f)]
			public float rampOffset;

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				base.material.SetTexture("_RampTex", textureRamp);
				base.material.SetFloat("_RampOffset", rampOffset);
				Graphics.Blit(source, destination, base.material);
			}
		}
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("")]
		public class ImageEffectBase : MonoBehaviour
		{
			public Shader shader;

			private Material m_Material;

			protected Material material
			{
				get
				{
					if (m_Material == null)
					{
						m_Material = new Material(shader);
						m_Material.hideFlags = HideFlags.HideAndDontSave;
					}
					return m_Material;
				}
			}

			protected virtual void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (!shader || !shader.isSupported)
				{
					base.enabled = false;
				}
			}

			protected virtual void OnDisable()
			{
				if ((bool)m_Material)
				{
					UnityEngine.Object.DestroyImmediate(m_Material);
				}
			}
		}
		[AddComponentMenu("")]
		public class ImageEffects
		{
			public static void RenderDistortion(Material material, RenderTexture source, RenderTexture destination, float angle, Vector2 center, Vector2 radius)
			{
				if (source.texelSize.y < 0f)
				{
					center.y = 1f - center.y;
					angle = 0f - angle;
				}
				Matrix4x4 value = Matrix4x4.TRS(Vector3.zero, Quaternion.Euler(0f, 0f, angle), Vector3.one);
				material.SetMatrix("_RotationMatrix", value);
				material.SetVector("_CenterRadius", new Vector4(center.x, center.y, radius.x, radius.y));
				material.SetFloat("_Angle", angle * ((float)Math.PI / 180f));
				Graphics.Blit(source, destination, material);
			}

			[Obsolete("Use Graphics.Blit(source,dest) instead")]
			public static void Blit(RenderTexture source, RenderTexture dest)
			{
				Graphics.Blit(source, dest);
			}

			[Obsolete("Use Graphics.Blit(source, destination, material) instead")]
			public static void BlitWithMaterial(Material material, RenderTexture source, RenderTexture dest)
			{
				Graphics.Blit(source, dest, material);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Blur/Motion Blur (Color Accumulation)")]
		[RequireComponent(typeof(Camera))]
		public class MotionBlur : ImageEffectBase
		{
			[Range(0f, 0.92f)]
			public float blurAmount = 0.8f;

			public bool extraBlur;

			private RenderTexture accumTexture;

			protected override void Start()
			{
				base.Start();
			}

			protected override void OnDisable()
			{
				base.OnDisable();
				UnityEngine.Object.DestroyImmediate(accumTexture);
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (accumTexture == null || accumTexture.width != source.width || accumTexture.height != source.height)
				{
					UnityEngine.Object.DestroyImmediate(accumTexture);
					accumTexture = new RenderTexture(source.width, source.height, 0);
					accumTexture.hideFlags = HideFlags.HideAndDontSave;
					Graphics.Blit(source, accumTexture);
				}
				if (extraBlur)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(source.width / 4, source.height / 4, 0);
					accumTexture.MarkRestoreExpected();
					Graphics.Blit(accumTexture, temporary);
					Graphics.Blit(temporary, accumTexture);
					RenderTexture.ReleaseTemporary(temporary);
				}
				blurAmount = Mathf.Clamp(blurAmount, 0f, 0.92f);
				base.material.SetTexture("_MainTex", accumTexture);
				base.material.SetFloat("_AccumOrig", 1f - blurAmount);
				accumTexture.MarkRestoreExpected();
				Graphics.Blit(source, accumTexture, base.material);
				Graphics.Blit(accumTexture, destination);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Noise/Noise And Grain (Filmic)")]
		public class NoiseAndGrain : PostEffectsBase
		{
			public float intensityMultiplier = 0.25f;

			public float generalIntensity = 0.5f;

			public float blackIntensity = 1f;

			public float whiteIntensity = 1f;

			public float midGrey = 0.2f;

			public bool dx11Grain;

			public float softness;

			public bool monochrome;

			public Vector3 intensities = new Vector3(1f, 1f, 1f);

			public Vector3 tiling = new Vector3(64f, 64f, 64f);

			public float monochromeTiling = 64f;

			public FilterMode filterMode = FilterMode.Bilinear;

			public Texture2D noiseTexture;

			public Shader noiseShader;

			private Material noiseMaterial;

			public Shader dx11NoiseShader;

			private Material dx11NoiseMaterial;

			private static float TILE_AMOUNT = 64f;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				noiseMaterial = CheckShaderAndCreateMaterial(noiseShader, noiseMaterial);
				if (dx11Grain && supportDX11)
				{
					dx11NoiseMaterial = CheckShaderAndCreateMaterial(dx11NoiseShader, dx11NoiseMaterial);
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources() || null == noiseTexture)
				{
					Graphics.Blit(source, destination);
					if (null == noiseTexture)
					{
						UnityEngine.Debug.LogWarning("Noise & Grain effect failing as noise texture is not assigned. please assign.", base.transform);
					}
					return;
				}
				softness = Mathf.Clamp(softness, 0f, 0.99f);
				if (dx11Grain && supportDX11)
				{
					dx11NoiseMaterial.SetFloat("_DX11NoiseTime", Time.frameCount);
					dx11NoiseMaterial.SetTexture("_NoiseTex", noiseTexture);
					dx11NoiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
					dx11NoiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
					dx11NoiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
					if (softness > Mathf.Epsilon)
					{
						RenderTexture temporary = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
						DrawNoiseQuadGrid(source, temporary, dx11NoiseMaterial, noiseTexture, monochrome ? 3 : 2);
						dx11NoiseMaterial.SetTexture("_NoiseTex", temporary);
						Graphics.Blit(source, destination, dx11NoiseMaterial, 4);
						RenderTexture.ReleaseTemporary(temporary);
					}
					else
					{
						DrawNoiseQuadGrid(source, destination, dx11NoiseMaterial, noiseTexture, monochrome ? 1 : 0);
					}
					return;
				}
				if ((bool)noiseTexture)
				{
					noiseTexture.wrapMode = TextureWrapMode.Repeat;
					noiseTexture.filterMode = filterMode;
				}
				noiseMaterial.SetTexture("_NoiseTex", noiseTexture);
				noiseMaterial.SetVector("_NoisePerChannel", monochrome ? Vector3.one : intensities);
				noiseMaterial.SetVector("_NoiseTilingPerChannel", monochrome ? (Vector3.one * monochromeTiling) : tiling);
				noiseMaterial.SetVector("_MidGrey", new Vector3(midGrey, 1f / (1f - midGrey), -1f / midGrey));
				noiseMaterial.SetVector("_NoiseAmount", new Vector3(generalIntensity, blackIntensity, whiteIntensity) * intensityMultiplier);
				if (softness > Mathf.Epsilon)
				{
					RenderTexture temporary2 = RenderTexture.GetTemporary((int)((float)source.width * (1f - softness)), (int)((float)source.height * (1f - softness)));
					DrawNoiseQuadGrid(source, temporary2, noiseMaterial, noiseTexture, 2);
					noiseMaterial.SetTexture("_NoiseTex", temporary2);
					Graphics.Blit(source, destination, noiseMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary2);
				}
				else
				{
					DrawNoiseQuadGrid(source, destination, noiseMaterial, noiseTexture, 0);
				}
			}

			private static void DrawNoiseQuadGrid(RenderTexture source, RenderTexture dest, Material fxMaterial, Texture2D noise, int passNr)
			{
				RenderTexture.active = dest;
				float num = (float)noise.width * 1f;
				float num2 = 1f * (float)source.width / TILE_AMOUNT;
				fxMaterial.SetTexture("_MainTex", source);
				GL.PushMatrix();
				GL.LoadOrtho();
				float num3 = 1f * (float)source.width / (1f * (float)source.height);
				float num4 = 1f / num2;
				float num5 = num4 * num3;
				float num6 = num / ((float)noise.width * 1f);
				fxMaterial.SetPass(passNr);
				GL.Begin(7);
				for (float num7 = 0f; num7 < 1f; num7 += num4)
				{
					for (float num8 = 0f; num8 < 1f; num8 += num5)
					{
						float num9 = UnityEngine.Random.Range(0f, 1f);
						float num10 = UnityEngine.Random.Range(0f, 1f);
						num9 = Mathf.Floor(num9 * num) / num;
						num10 = Mathf.Floor(num10 * num) / num;
						float num11 = 1f / num;
						GL.MultiTexCoord2(0, num9, num10);
						GL.MultiTexCoord2(1, 0f, 0f);
						GL.Vertex3(num7, num8, 0.1f);
						GL.MultiTexCoord2(0, num9 + num6 * num11, num10);
						GL.MultiTexCoord2(1, 1f, 0f);
						GL.Vertex3(num7 + num4, num8, 0.1f);
						GL.MultiTexCoord2(0, num9 + num6 * num11, num10 + num6 * num11);
						GL.MultiTexCoord2(1, 1f, 1f);
						GL.Vertex3(num7 + num4, num8 + num5, 0.1f);
						GL.MultiTexCoord2(0, num9, num10 + num6 * num11);
						GL.MultiTexCoord2(1, 0f, 1f);
						GL.Vertex3(num7, num8 + num5, 0.1f);
					}
				}
				GL.End();
				GL.PopMatrix();
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Noise/Noise and Scratches")]
		public class NoiseAndScratches : MonoBehaviour
		{
			public bool monochrome = true;

			private bool rgbFallback;

			[Range(0f, 5f)]
			public float grainIntensityMin = 0.1f;

			[Range(0f, 5f)]
			public float grainIntensityMax = 0.2f;

			[Range(0.1f, 50f)]
			public float grainSize = 2f;

			[Range(0f, 5f)]
			public float scratchIntensityMin = 0.05f;

			[Range(0f, 5f)]
			public float scratchIntensityMax = 0.25f;

			[Range(1f, 30f)]
			public float scratchFPS = 10f;

			[Range(0f, 1f)]
			public float scratchJitter = 0.01f;

			public Texture grainTexture;

			public Texture scratchTexture;

			public Shader shaderRGB;

			public Shader shaderYUV;

			private Material m_MaterialRGB;

			private Material m_MaterialYUV;

			private float scratchTimeLeft;

			private float scratchX;

			private float scratchY;

			protected Material material
			{
				get
				{
					if (m_MaterialRGB == null)
					{
						m_MaterialRGB = new Material(shaderRGB);
						m_MaterialRGB.hideFlags = HideFlags.HideAndDontSave;
					}
					if (m_MaterialYUV == null && !rgbFallback)
					{
						m_MaterialYUV = new Material(shaderYUV);
						m_MaterialYUV.hideFlags = HideFlags.HideAndDontSave;
					}
					if (rgbFallback || monochrome)
					{
						return m_MaterialRGB;
					}
					return m_MaterialYUV;
				}
			}

			protected void Start()
			{
				if (!SystemInfo.supportsImageEffects)
				{
					base.enabled = false;
				}
				else if (shaderRGB == null || shaderYUV == null)
				{
					UnityEngine.Debug.Log("Noise shaders are not set up! Disabling noise effect.");
					base.enabled = false;
				}
				else if (!shaderRGB.isSupported)
				{
					base.enabled = false;
				}
				else if (!shaderYUV.isSupported)
				{
					rgbFallback = true;
				}
			}

			protected void OnDisable()
			{
				if ((bool)m_MaterialRGB)
				{
					UnityEngine.Object.DestroyImmediate(m_MaterialRGB);
				}
				if ((bool)m_MaterialYUV)
				{
					UnityEngine.Object.DestroyImmediate(m_MaterialYUV);
				}
			}

			private void SanitizeParameters()
			{
				grainIntensityMin = Mathf.Clamp(grainIntensityMin, 0f, 5f);
				grainIntensityMax = Mathf.Clamp(grainIntensityMax, 0f, 5f);
				scratchIntensityMin = Mathf.Clamp(scratchIntensityMin, 0f, 5f);
				scratchIntensityMax = Mathf.Clamp(scratchIntensityMax, 0f, 5f);
				scratchFPS = Mathf.Clamp(scratchFPS, 1f, 30f);
				scratchJitter = Mathf.Clamp(scratchJitter, 0f, 1f);
				grainSize = Mathf.Clamp(grainSize, 0.1f, 50f);
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				SanitizeParameters();
				if (scratchTimeLeft <= 0f)
				{
					scratchTimeLeft = UnityEngine.Random.value * 2f / scratchFPS;
					scratchX = UnityEngine.Random.value;
					scratchY = UnityEngine.Random.value;
				}
				scratchTimeLeft -= Time.deltaTime;
				Material material = this.material;
				material.SetTexture("_GrainTex", grainTexture);
				material.SetTexture("_ScratchTex", scratchTexture);
				float num = 1f / grainSize;
				material.SetVector("_GrainOffsetScale", new Vector4(UnityEngine.Random.value, UnityEngine.Random.value, (float)Screen.width / (float)grainTexture.width * num, (float)Screen.height / (float)grainTexture.height * num));
				material.SetVector("_ScratchOffsetScale", new Vector4(scratchX + UnityEngine.Random.value * scratchJitter, scratchY + UnityEngine.Random.value * scratchJitter, (float)Screen.width / (float)scratchTexture.width, (float)Screen.height / (float)scratchTexture.height));
				material.SetVector("_Intensity", new Vector4(UnityEngine.Random.Range(grainIntensityMin, grainIntensityMax), UnityEngine.Random.Range(scratchIntensityMin, scratchIntensityMax), 0f, 0f));
				Graphics.Blit(source, destination, material);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		public class PostEffectsBase : MonoBehaviour
		{
			protected bool supportHDRTextures = true;

			protected bool supportDX11;

			protected bool isSupported = true;

			private List<Material> createdMaterials = new List<Material>();

			protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
			{
				if (!s)
				{
					UnityEngine.Debug.Log("Missing shader in " + ToString());
					base.enabled = false;
					return null;
				}
				if (s.isSupported && (bool)m2Create && m2Create.shader == s)
				{
					return m2Create;
				}
				if (!s.isSupported)
				{
					NotSupported();
					UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
					return null;
				}
				m2Create = new Material(s);
				createdMaterials.Add(m2Create);
				m2Create.hideFlags = HideFlags.DontSave;
				return m2Create;
			}

			protected Material CreateMaterial(Shader s, Material m2Create)
			{
				if (!s)
				{
					UnityEngine.Debug.Log("Missing shader in " + ToString());
					return null;
				}
				if ((bool)m2Create && m2Create.shader == s && s.isSupported)
				{
					return m2Create;
				}
				if (!s.isSupported)
				{
					return null;
				}
				m2Create = new Material(s);
				createdMaterials.Add(m2Create);
				m2Create.hideFlags = HideFlags.DontSave;
				return m2Create;
			}

			private void OnEnable()
			{
				isSupported = true;
			}

			private void OnDestroy()
			{
				RemoveCreatedMaterials();
			}

			private void RemoveCreatedMaterials()
			{
				while (createdMaterials.Count > 0)
				{
					Material obj = createdMaterials[0];
					createdMaterials.RemoveAt(0);
					UnityEngine.Object.Destroy(obj);
				}
			}

			protected bool CheckSupport()
			{
				return CheckSupport(needDepth: false);
			}

			public virtual bool CheckResources()
			{
				UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
				return isSupported;
			}

			protected void Start()
			{
				CheckResources();
			}

			protected bool CheckSupport(bool needDepth)
			{
				isSupported = true;
				supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
				supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
				if (!SystemInfo.supportsImageEffects)
				{
					NotSupported();
					return false;
				}
				if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
				{
					NotSupported();
					return false;
				}
				if (needDepth)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				return true;
			}

			protected bool CheckSupport(bool needDepth, bool needHdr)
			{
				if (!CheckSupport(needDepth))
				{
					return false;
				}
				if (needHdr && !supportHDRTextures)
				{
					NotSupported();
					return false;
				}
				return true;
			}

			public bool Dx11Support()
			{
				return supportDX11;
			}

			protected void ReportAutoDisable()
			{
				UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
			}

			private bool CheckShader(Shader s)
			{
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
				if (!s.isSupported)
				{
					NotSupported();
					return false;
				}
				return false;
			}

			protected void NotSupported()
			{
				base.enabled = false;
				isSupported = false;
			}

			protected void DrawBorder(RenderTexture dest, Material material)
			{
				RenderTexture.active = dest;
				bool flag = true;
				GL.PushMatrix();
				GL.LoadOrtho();
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					float y;
					float y2;
					if (flag)
					{
						y = 1f;
						y2 = 0f;
					}
					else
					{
						y = 0f;
						y2 = 1f;
					}
					float x = 0f + 1f / ((float)dest.width * 1f);
					float y3 = 0f;
					float y4 = 1f;
					GL.Begin(7);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					float x2 = 1f - 1f / ((float)dest.width * 1f);
					x = 1f;
					y3 = 0f;
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(x2, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(x2, y4, 0.1f);
					x = 1f;
					y3 = 0f;
					y4 = 0f + 1f / ((float)dest.height * 1f);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					x = 1f;
					y3 = 1f - 1f / ((float)dest.height * 1f);
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					GL.End();
				}
				GL.PopMatrix();
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		internal class PostEffectsHelper : MonoBehaviour
		{
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				UnityEngine.Debug.Log("OnRenderImage in Helper called ...");
			}

			private static void DrawLowLevelPlaneAlignedWithCamera(float dist, RenderTexture source, RenderTexture dest, Material material, Camera cameraForProjectionMatrix)
			{
				RenderTexture.active = dest;
				material.SetTexture("_MainTex", source);
				bool flag = true;
				GL.PushMatrix();
				GL.LoadIdentity();
				GL.LoadProjectionMatrix(cameraForProjectionMatrix.projectionMatrix);
				float f = cameraForProjectionMatrix.fieldOfView * 0.5f * ((float)Math.PI / 180f);
				float num = Mathf.Cos(f) / Mathf.Sin(f);
				float aspect = cameraForProjectionMatrix.aspect;
				float num2 = aspect / (0f - num);
				float num3 = aspect / num;
				float num4 = 1f / (0f - num);
				float num5 = 1f / num;
				float num6 = 1f;
				num2 *= dist * num6;
				num3 *= dist * num6;
				num4 *= dist * num6;
				num5 *= dist * num6;
				float z = 0f - dist;
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					GL.Begin(7);
					float y;
					float y2;
					if (flag)
					{
						y = 1f;
						y2 = 0f;
					}
					else
					{
						y = 0f;
						y2 = 1f;
					}
					GL.TexCoord2(0f, y);
					GL.Vertex3(num2, num4, z);
					GL.TexCoord2(1f, y);
					GL.Vertex3(num3, num4, z);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(num3, num5, z);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(num2, num5, z);
					GL.End();
				}
				GL.PopMatrix();
			}

			private static void DrawBorder(RenderTexture dest, Material material)
			{
				RenderTexture.active = dest;
				bool flag = true;
				GL.PushMatrix();
				GL.LoadOrtho();
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					float y;
					float y2;
					if (flag)
					{
						y = 1f;
						y2 = 0f;
					}
					else
					{
						y = 0f;
						y2 = 1f;
					}
					float x = 0f + 1f / ((float)dest.width * 1f);
					float y3 = 0f;
					float y4 = 1f;
					GL.Begin(7);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					float x2 = 1f - 1f / ((float)dest.width * 1f);
					x = 1f;
					y3 = 0f;
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(x2, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(x2, y4, 0.1f);
					x = 1f;
					y3 = 0f;
					y4 = 0f + 1f / ((float)dest.height * 1f);
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					x = 1f;
					y3 = 1f - 1f / ((float)dest.height * 1f);
					y4 = 1f;
					GL.TexCoord2(0f, y);
					GL.Vertex3(0f, y3, 0.1f);
					GL.TexCoord2(1f, y);
					GL.Vertex3(x, y3, 0.1f);
					GL.TexCoord2(1f, y2);
					GL.Vertex3(x, y4, 0.1f);
					GL.TexCoord2(0f, y2);
					GL.Vertex3(0f, y4, 0.1f);
					GL.End();
				}
				GL.PopMatrix();
			}

			private static void DrawLowLevelQuad(float x1, float x2, float y1, float y2, RenderTexture source, RenderTexture dest, Material material)
			{
				RenderTexture.active = dest;
				material.SetTexture("_MainTex", source);
				bool flag = true;
				GL.PushMatrix();
				GL.LoadOrtho();
				for (int i = 0; i < material.passCount; i++)
				{
					material.SetPass(i);
					GL.Begin(7);
					float y3;
					float y4;
					if (flag)
					{
						y3 = 1f;
						y4 = 0f;
					}
					else
					{
						y3 = 0f;
						y4 = 1f;
					}
					GL.TexCoord2(0f, y3);
					GL.Vertex3(x1, y1, 0.1f);
					GL.TexCoord2(1f, y3);
					GL.Vertex3(x2, y1, 0.1f);
					GL.TexCoord2(1f, y4);
					GL.Vertex3(x2, y2, 0.1f);
					GL.TexCoord2(0f, y4);
					GL.Vertex3(x1, y2, 0.1f);
					GL.End();
				}
				GL.PopMatrix();
			}
		}
		internal class Quads
		{
			private static Mesh[] meshes;

			private static int currentQuads;

			private static bool HasMeshes()
			{
				if (meshes == null)
				{
					return false;
				}
				Mesh[] array = meshes;
				foreach (Mesh mesh in array)
				{
					if (null == mesh)
					{
						return false;
					}
				}
				return true;
			}

			public static void Cleanup()
			{
				if (meshes == null)
				{
					return;
				}
				for (int i = 0; i < meshes.Length; i++)
				{
					if (null != meshes[i])
					{
						UnityEngine.Object.DestroyImmediate(meshes[i]);
						meshes[i] = null;
					}
				}
				meshes = null;
			}

			public static Mesh[] GetMeshes(int totalWidth, int totalHeight)
			{
				if (HasMeshes() && currentQuads == totalWidth * totalHeight)
				{
					return meshes;
				}
				int num = 10833;
				int num2 = (currentQuads = totalWidth * totalHeight);
				meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
				int num3 = 0;
				int num4 = 0;
				for (num3 = 0; num3 < num2; num3 += num)
				{
					int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
					meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
					num4++;
				}
				return meshes;
			}

			private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
			{
				Mesh mesh = new Mesh();
				mesh.hideFlags = HideFlags.DontSave;
				Vector3[] array = new Vector3[triCount * 4];
				Vector2[] array2 = new Vector2[triCount * 4];
				Vector2[] array3 = new Vector2[triCount * 4];
				int[] array4 = new int[triCount * 6];
				for (int i = 0; i < triCount; i++)
				{
					int num = i * 4;
					int num2 = i * 6;
					int num3 = triOffset + i;
					float num4 = Mathf.Floor(num3 % totalWidth) / (float)totalWidth;
					float num5 = Mathf.Floor(num3 / totalWidth) / (float)totalHeight;
					array[num + 3] = (array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num4 * 2f - 1f, num5 * 2f - 1f, 1f))));
					array2[num] = new Vector2(0f, 0f);
					array2[num + 1] = new Vector2(1f, 0f);
					array2[num + 2] = new Vector2(0f, 1f);
					array2[num + 3] = new Vector2(1f, 1f);
					array3[num] = new Vector2(num4, num5);
					array3[num + 1] = new Vector2(num4, num5);
					array3[num + 2] = new Vector2(num4, num5);
					array3[num + 3] = new Vector2(num4, num5);
					array4[num2] = num;
					array4[num2 + 1] = num + 1;
					array4[num2 + 2] = num + 2;
					array4[num2 + 3] = num + 1;
					array4[num2 + 4] = num + 2;
					array4[num2 + 5] = num + 3;
				}
				mesh.vertices = array;
				mesh.triangles = array4;
				mesh.uv = array2;
				mesh.uv2 = array3;
				return mesh;
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Other/Screen Overlay")]
		public class ScreenOverlay : PostEffectsBase
		{
			public enum OverlayBlendMode
			{
				Additive,
				ScreenBlend,
				Multiply,
				Overlay,
				AlphaBlend
			}

			public OverlayBlendMode blendMode = OverlayBlendMode.Overlay;

			public float intensity = 1f;

			public Texture2D texture;

			public Shader overlayShader;

			private Material overlayMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				overlayMaterial = CheckShaderAndCreateMaterial(overlayShader, overlayMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				Vector4 value = new Vector4(1f, 0f, 0f, 1f);
				overlayMaterial.SetVector("_UV_Transform", value);
				overlayMaterial.SetFloat("_Intensity", intensity);
				overlayMaterial.SetTexture("_Overlay", texture);
				Graphics.Blit(source, destination, overlayMaterial, (int)blendMode);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Obscurance")]
		internal class ScreenSpaceAmbientObscurance : PostEffectsBase
		{
			[Range(0f, 3f)]
			public float intensity = 0.5f;

			[Range(0.1f, 3f)]
			public float radius = 0.2f;

			[Range(0f, 3f)]
			public int blurIterations = 1;

			[Range(0f, 5f)]
			public float blurFilterDistance = 1.25f;

			[Range(0f, 1f)]
			public int downsample;

			public Texture2D rand;

			public Shader aoShader;

			private Material aoMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: true);
				aoMaterial = CheckShaderAndCreateMaterial(aoShader, aoMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnDisable()
			{
				if ((bool)aoMaterial)
				{
					UnityEngine.Object.DestroyImmediate(aoMaterial);
				}
				aoMaterial = null;
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				Camera component = GetComponent<Camera>();
				Matrix4x4 projectionMatrix = component.projectionMatrix;
				Matrix4x4 inverse = projectionMatrix.inverse;
				Vector4 value = new Vector4(-2f / projectionMatrix[0, 0], -2f / projectionMatrix[1, 1], (1f - projectionMatrix[0, 2]) / projectionMatrix[0, 0], (1f + projectionMatrix[1, 2]) / projectionMatrix[1, 1]);
				if (component.stereoEnabled)
				{
					Matrix4x4 stereoProjectionMatrix = component.GetStereoProjectionMatrix(Camera.StereoscopicEye.Left);
					Matrix4x4 stereoProjectionMatrix2 = component.GetStereoProjectionMatrix(Camera.StereoscopicEye.Right);
					Vector4 value2 = new Vector4(-2f / stereoProjectionMatrix[0, 0], -2f / stereoProjectionMatrix[1, 1], (1f - stereoProjectionMatrix[0, 2]) / stereoProjectionMatrix[0, 0], (1f + stereoProjectionMatrix[1, 2]) / stereoProjectionMatrix[1, 1]);
					Vector4 value3 = new Vector4(-2f / stereoProjectionMatrix2[0, 0], -2f / stereoProjectionMatrix2[1, 1], (1f - stereoProjectionMatrix2[0, 2]) / stereoProjectionMatrix2[0, 0], (1f + stereoProjectionMatrix2[1, 2]) / stereoProjectionMatrix2[1, 1]);
					aoMaterial.SetVector("_ProjInfoLeft", value2);
					aoMaterial.SetVector("_ProjInfoRight", value3);
				}
				aoMaterial.SetVector("_ProjInfo", value);
				aoMaterial.SetMatrix("_ProjectionInv", inverse);
				aoMaterial.SetTexture("_Rand", rand);
				aoMaterial.SetFloat("_Radius", radius);
				aoMaterial.SetFloat("_Radius2", radius * radius);
				aoMaterial.SetFloat("_Intensity", intensity);
				aoMaterial.SetFloat("_BlurFilterDistance", blurFilterDistance);
				int width = source.width;
				int height = source.height;
				RenderTexture renderTexture = RenderTexture.GetTemporary(width >> downsample, height >> downsample);
				Graphics.Blit(source, renderTexture, aoMaterial, 0);
				if (downsample > 0)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(width, height);
					Graphics.Blit(renderTexture, temporary, aoMaterial, 4);
					RenderTexture.ReleaseTemporary(renderTexture);
					renderTexture = temporary;
				}
				for (int i = 0; i < blurIterations; i++)
				{
					aoMaterial.SetVector("_Axis", new Vector2(1f, 0f));
					RenderTexture temporary = RenderTexture.GetTemporary(width, height);
					Graphics.Blit(renderTexture, temporary, aoMaterial, 1);
					RenderTexture.ReleaseTemporary(renderTexture);
					aoMaterial.SetVector("_Axis", new Vector2(0f, 1f));
					renderTexture = RenderTexture.GetTemporary(width, height);
					Graphics.Blit(temporary, renderTexture, aoMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary);
				}
				aoMaterial.SetTexture("_AOTex", renderTexture);
				Graphics.Blit(source, destination, aoMaterial, 2);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Screen Space Ambient Occlusion")]
		public class ScreenSpaceAmbientOcclusion : MonoBehaviour
		{
			public enum SSAOSamples
			{
				Low,
				Medium,
				High
			}

			[Range(0.05f, 1f)]
			public float m_Radius = 0.4f;

			public SSAOSamples m_SampleCount = SSAOSamples.Medium;

			[Range(0.5f, 4f)]
			public float m_OcclusionIntensity = 1.5f;

			[Range(0f, 4f)]
			public int m_Blur = 2;

			[Range(1f, 6f)]
			public int m_Downsampling = 2;

			[Range(0.2f, 2f)]
			public float m_OcclusionAttenuation = 1f;

			[Range(1E-05f, 0.5f)]
			public float m_MinZ = 0.01f;

			public Shader m_SSAOShader;

			private Material m_SSAOMaterial;

			public Texture2D m_RandomTexture;

			private bool m_Supported;

			private static Material CreateMaterial(Shader shader)
			{
				if (!shader)
				{
					return null;
				}
				return new Material(shader)
				{
					hideFlags = HideFlags.HideAndDontSave
				};
			}

			private static void DestroyMaterial(Material mat)
			{
				if ((bool)mat)
				{
					UnityEngine.Object.DestroyImmediate(mat);
					mat = null;
				}
			}

			private void OnDisable()
			{
				DestroyMaterial(m_SSAOMaterial);
			}

			private void Start()
			{
				if (!SystemInfo.supportsImageEffects || !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
				{
					m_Supported = false;
					base.enabled = false;
					return;
				}
				CreateMaterials();
				if (!m_SSAOMaterial || m_SSAOMaterial.passCount != 5)
				{
					m_Supported = false;
					base.enabled = false;
				}
				else
				{
					m_Supported = true;
				}
			}

			private void OnEnable()
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.DepthNormals;
			}

			private void CreateMaterials()
			{
				if (!m_SSAOMaterial && m_SSAOShader.isSupported)
				{
					m_SSAOMaterial = CreateMaterial(m_SSAOShader);
					m_SSAOMaterial.SetTexture("_RandomTexture", m_RandomTexture);
				}
			}

			[ImageEffectOpaque]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!m_Supported || !m_SSAOShader.isSupported)
				{
					base.enabled = false;
					return;
				}
				CreateMaterials();
				m_Downsampling = Mathf.Clamp(m_Downsampling, 1, 6);
				m_Radius = Mathf.Clamp(m_Radius, 0.05f, 1f);
				m_MinZ = Mathf.Clamp(m_MinZ, 1E-05f, 0.5f);
				m_OcclusionIntensity = Mathf.Clamp(m_OcclusionIntensity, 0.5f, 4f);
				m_OcclusionAttenuation = Mathf.Clamp(m_OcclusionAttenuation, 0.2f, 2f);
				m_Blur = Mathf.Clamp(m_Blur, 0, 4);
				RenderTexture renderTexture = RenderTexture.GetTemporary(source.width / m_Downsampling, source.height / m_Downsampling, 0);
				float fieldOfView = GetComponent<Camera>().fieldOfView;
				float farClipPlane = GetComponent<Camera>().farClipPlane;
				float num = Mathf.Tan(fieldOfView * ((float)Math.PI / 180f) * 0.5f) * farClipPlane;
				float x = num * GetComponent<Camera>().aspect;
				m_SSAOMaterial.SetVector("_FarCorner", new Vector3(x, num, farClipPlane));
				int num2;
				int num3;
				if ((bool)m_RandomTexture)
				{
					num2 = m_RandomTexture.width;
					num3 = m_RandomTexture.height;
				}
				else
				{
					num2 = 1;
					num3 = 1;
				}
				m_SSAOMaterial.SetVector("_NoiseScale", new Vector3((float)renderTexture.width / (float)num2, (float)renderTexture.height / (float)num3, 0f));
				m_SSAOMaterial.SetVector("_Params", new Vector4(m_Radius, m_MinZ, 1f / m_OcclusionAttenuation, m_OcclusionIntensity));
				bool num4 = m_Blur > 0;
				Graphics.Blit(num4 ? null : source, renderTexture, m_SSAOMaterial, (int)m_SampleCount);
				if (num4)
				{
					RenderTexture temporary = RenderTexture.GetTemporary(source.width, source.height, 0);
					m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4((float)m_Blur / (float)source.width, 0f, 0f, 0f));
					m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
					Graphics.Blit(null, temporary, m_SSAOMaterial, 3);
					RenderTexture.ReleaseTemporary(renderTexture);
					RenderTexture temporary2 = RenderTexture.GetTemporary(source.width, source.height, 0);
					m_SSAOMaterial.SetVector("_TexelOffsetScale", new Vector4(0f, (float)m_Blur / (float)source.height, 0f, 0f));
					m_SSAOMaterial.SetTexture("_SSAO", temporary);
					Graphics.Blit(source, temporary2, m_SSAOMaterial, 3);
					RenderTexture.ReleaseTemporary(temporary);
					renderTexture = temporary2;
				}
				m_SSAOMaterial.SetTexture("_SSAO", renderTexture);
				Graphics.Blit(source, destination, m_SSAOMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Color Adjustments/Sepia Tone")]
		public class SepiaTone : ImageEffectBase
		{
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				Graphics.Blit(source, destination, base.material);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Rendering/Sun Shafts")]
		public class SunShafts : PostEffectsBase
		{
			public enum SunShaftsResolution
			{
				Low,
				Normal,
				High
			}

			public enum ShaftsScreenBlendMode
			{
				Screen,
				Add
			}

			public SunShaftsResolution resolution = SunShaftsResolution.Normal;

			public ShaftsScreenBlendMode screenBlendMode;

			public Transform sunTransform;

			public int radialBlurIterations = 2;

			public Color sunColor = Color.white;

			public Color sunThreshold = new Color(0.87f, 0.74f, 0.65f);

			public float sunShaftBlurRadius = 2.5f;

			public float sunShaftIntensity = 1.15f;

			public float maxRadius = 0.75f;

			public bool useDepthTexture = true;

			public Shader sunShaftsShader;

			private Material sunShaftsMaterial;

			public Shader simpleClearShader;

			private Material simpleClearMaterial;

			public override bool CheckResources()
			{
				CheckSupport(useDepthTexture);
				sunShaftsMaterial = CheckShaderAndCreateMaterial(sunShaftsShader, sunShaftsMaterial);
				simpleClearMaterial = CheckShaderAndCreateMaterial(simpleClearShader, simpleClearMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				if (useDepthTexture)
				{
					GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
				}
				int num = 4;
				if (resolution == SunShaftsResolution.Normal)
				{
					num = 2;
				}
				else if (resolution == SunShaftsResolution.High)
				{
					num = 1;
				}
				Vector3 vector = Vector3.one * 0.5f;
				vector = ((!sunTransform) ? new Vector3(0.5f, 0.5f, 0f) : GetComponent<Camera>().WorldToViewportPoint(sunTransform.position));
				int width = source.width / num;
				int height = source.height / num;
				RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0);
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * sunShaftBlurRadius);
				sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
				sunShaftsMaterial.SetVector("_SunThreshold", sunThreshold);
				if (!useDepthTexture)
				{
					RenderTextureFormat format = (GetComponent<Camera>().allowHDR ? RenderTextureFormat.DefaultHDR : RenderTextureFormat.Default);
					RenderTexture renderTexture = (RenderTexture.active = RenderTexture.GetTemporary(source.width, source.height, 0, format));
					GL.ClearWithSkybox(clearDepth: false, GetComponent<Camera>());
					sunShaftsMaterial.SetTexture("_Skybox", renderTexture);
					Graphics.Blit(source, temporary, sunShaftsMaterial, 3);
					RenderTexture.ReleaseTemporary(renderTexture);
				}
				else
				{
					Graphics.Blit(source, temporary, sunShaftsMaterial, 2);
				}
				DrawBorder(temporary, simpleClearMaterial);
				radialBlurIterations = Mathf.Clamp(radialBlurIterations, 1, 4);
				float num2 = sunShaftBlurRadius * 0.0013020834f;
				sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				sunShaftsMaterial.SetVector("_SunPosition", new Vector4(vector.x, vector.y, vector.z, maxRadius));
				for (int i = 0; i < radialBlurIterations; i++)
				{
					RenderTexture temporary3 = RenderTexture.GetTemporary(width, height, 0);
					Graphics.Blit(temporary, temporary3, sunShaftsMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary);
					num2 = sunShaftBlurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
					sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
					temporary = RenderTexture.GetTemporary(width, height, 0);
					Graphics.Blit(temporary3, temporary, sunShaftsMaterial, 1);
					RenderTexture.ReleaseTemporary(temporary3);
					num2 = sunShaftBlurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
					sunShaftsMaterial.SetVector("_BlurRadius4", new Vector4(num2, num2, 0f, 0f));
				}
				if (vector.z >= 0f)
				{
					sunShaftsMaterial.SetVector("_SunColor", new Vector4(sunColor.r, sunColor.g, sunColor.b, sunColor.a) * sunShaftIntensity);
				}
				else
				{
					sunShaftsMaterial.SetVector("_SunColor", Vector4.zero);
				}
				sunShaftsMaterial.SetTexture("_ColorBuffer", temporary);
				Graphics.Blit(source, destination, sunShaftsMaterial, (screenBlendMode != 0) ? 4 : 0);
				RenderTexture.ReleaseTemporary(temporary);
			}
		}
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Tilt Shift (Lens Blur)")]
		internal class TiltShift : PostEffectsBase
		{
			public enum TiltShiftMode
			{
				TiltShiftMode,
				IrisMode
			}

			public enum TiltShiftQuality
			{
				Preview,
				Low,
				Normal,
				High
			}

			public TiltShiftMode mode;

			public TiltShiftQuality quality = TiltShiftQuality.Normal;

			[Range(0f, 15f)]
			public float blurArea = 1f;

			[Range(0f, 25f)]
			public float maxBlurSize = 5f;

			[Range(0f, 1f)]
			public int downsample;

			public Shader tiltShiftShader;

			private Material tiltShiftMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				tiltShiftMaterial = CheckShaderAndCreateMaterial(tiltShiftShader, tiltShiftMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				tiltShiftMaterial.SetFloat("_BlurSize", (maxBlurSize < 0f) ? 0f : maxBlurSize);
				tiltShiftMaterial.SetFloat("_BlurArea", blurArea);
				source.filterMode = FilterMode.Bilinear;
				RenderTexture renderTexture = destination;
				if ((float)downsample > 0f)
				{
					renderTexture = RenderTexture.GetTemporary(source.width >> downsample, source.height >> downsample, 0, source.format);
					renderTexture.filterMode = FilterMode.Bilinear;
				}
				int num = (int)quality;
				num *= 2;
				Graphics.Blit(source, renderTexture, tiltShiftMaterial, (mode == TiltShiftMode.TiltShiftMode) ? num : (num + 1));
				if (downsample > 0)
				{
					tiltShiftMaterial.SetTexture("_Blurred", renderTexture);
					Graphics.Blit(source, destination, tiltShiftMaterial, 8);
				}
				if (renderTexture != destination)
				{
					RenderTexture.ReleaseTemporary(renderTexture);
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Color Adjustments/Tonemapping")]
		public class Tonemapping : PostEffectsBase
		{
			public enum TonemapperType
			{
				SimpleReinhard,
				UserCurve,
				Hable,
				Photographic,
				OptimizedHejiDawson,
				AdaptiveReinhard,
				AdaptiveReinhardAutoWhite
			}

			public enum AdaptiveTexSize
			{
				Square16 = 0x10,
				Square32 = 0x20,
				Square64 = 0x40,
				Square128 = 0x80,
				Square256 = 0x100,
				Square512 = 0x200,
				Square1024 = 0x400
			}

			public TonemapperType type = TonemapperType.Photographic;

			public AdaptiveTexSize adaptiveTextureSize = AdaptiveTexSize.Square256;

			public AnimationCurve remapCurve;

			private Texture2D curveTex;

			public float exposureAdjustment = 1.5f;

			public float middleGrey = 0.4f;

			public float white = 2f;

			public float adaptionSpeed = 1.5f;

			public Shader tonemapper;

			public bool validRenderTextureFormat = true;

			private Material tonemapMaterial;

			private RenderTexture rt;

			private RenderTextureFormat rtFormat = RenderTextureFormat.ARGBHalf;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false, needHdr: true);
				tonemapMaterial = CheckShaderAndCreateMaterial(tonemapper, tonemapMaterial);
				if (!curveTex && type == TonemapperType.UserCurve)
				{
					curveTex = new Texture2D(256, 1, TextureFormat.ARGB32, mipChain: false, linear: true);
					curveTex.filterMode = FilterMode.Bilinear;
					curveTex.wrapMode = TextureWrapMode.Clamp;
					curveTex.hideFlags = HideFlags.DontSave;
				}
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			public float UpdateCurve()
			{
				float num = 1f;
				if (remapCurve.keys.Length < 1)
				{
					remapCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(2f, 1f));
				}
				if (remapCurve != null)
				{
					if (remapCurve.length > 0)
					{
						num = remapCurve[remapCurve.length - 1].time;
					}
					for (float num2 = 0f; num2 <= 1f; num2 += 0.003921569f)
					{
						float num3 = remapCurve.Evaluate(num2 * 1f * num);
						curveTex.SetPixel((int)Mathf.Floor(num2 * 255f), 0, new Color(num3, num3, num3));
					}
					curveTex.Apply();
				}
				return 1f / num;
			}

			private void OnDisable()
			{
				if ((bool)rt)
				{
					UnityEngine.Object.DestroyImmediate(rt);
					rt = null;
				}
				if ((bool)tonemapMaterial)
				{
					UnityEngine.Object.DestroyImmediate(tonemapMaterial);
					tonemapMaterial = null;
				}
				if ((bool)curveTex)
				{
					UnityEngine.Object.DestroyImmediate(curveTex);
					curveTex = null;
				}
			}

			private bool CreateInternalRenderTexture()
			{
				if ((bool)rt)
				{
					return false;
				}
				rtFormat = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGHalf) ? RenderTextureFormat.RGHalf : RenderTextureFormat.ARGBHalf);
				rt = new RenderTexture(1, 1, 0, rtFormat);
				rt.hideFlags = HideFlags.DontSave;
				return true;
			}

			[ImageEffectTransformsToLDR]
			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				exposureAdjustment = ((exposureAdjustment < 0.001f) ? 0.001f : exposureAdjustment);
				if (type == TonemapperType.UserCurve)
				{
					float value = UpdateCurve();
					tonemapMaterial.SetFloat("_RangeScale", value);
					tonemapMaterial.SetTexture("_Curve", curveTex);
					Graphics.Blit(source, destination, tonemapMaterial, 4);
					return;
				}
				if (type == TonemapperType.SimpleReinhard)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 6);
					return;
				}
				if (type == TonemapperType.Hable)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 5);
					return;
				}
				if (type == TonemapperType.Photographic)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 8);
					return;
				}
				if (type == TonemapperType.OptimizedHejiDawson)
				{
					tonemapMaterial.SetFloat("_ExposureAdjustment", 0.5f * exposureAdjustment);
					Graphics.Blit(source, destination, tonemapMaterial, 7);
					return;
				}
				bool flag = CreateInternalRenderTexture();
				RenderTexture temporary = RenderTexture.GetTemporary((int)adaptiveTextureSize, (int)adaptiveTextureSize, 0, rtFormat);
				Graphics.Blit(source, temporary);
				int num = (int)Mathf.Log((float)temporary.width * 1f, 2f);
				int num2 = 2;
				RenderTexture[] array = new RenderTexture[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = RenderTexture.GetTemporary(temporary.width / num2, temporary.width / num2, 0, rtFormat);
					num2 *= 2;
				}
				RenderTexture source2 = array[num - 1];
				Graphics.Blit(temporary, array[0], tonemapMaterial, 1);
				if (type == TonemapperType.AdaptiveReinhardAutoWhite)
				{
					for (int j = 0; j < num - 1; j++)
					{
						Graphics.Blit(array[j], array[j + 1], tonemapMaterial, 9);
						source2 = array[j + 1];
					}
				}
				else if (type == TonemapperType.AdaptiveReinhard)
				{
					for (int k = 0; k < num - 1; k++)
					{
						Graphics.Blit(array[k], array[k + 1]);
						source2 = array[k + 1];
					}
				}
				adaptionSpeed = ((adaptionSpeed < 0.001f) ? 0.001f : adaptionSpeed);
				tonemapMaterial.SetFloat("_AdaptionSpeed", adaptionSpeed);
				rt.MarkRestoreExpected();
				Graphics.Blit(source2, rt, tonemapMaterial, flag ? 3 : 2);
				middleGrey = ((middleGrey < 0.001f) ? 0.001f : middleGrey);
				tonemapMaterial.SetVector("_HdrParams", new Vector4(middleGrey, middleGrey, middleGrey, white * white));
				tonemapMaterial.SetTexture("_SmallTex", rt);
				if (type == TonemapperType.AdaptiveReinhard)
				{
					Graphics.Blit(source, destination, tonemapMaterial, 0);
				}
				else if (type == TonemapperType.AdaptiveReinhardAutoWhite)
				{
					Graphics.Blit(source, destination, tonemapMaterial, 10);
				}
				else
				{
					UnityEngine.Debug.LogError("No valid adaptive tonemapper type found!");
					Graphics.Blit(source, destination);
				}
				for (int l = 0; l < num; l++)
				{
					RenderTexture.ReleaseTemporary(array[l]);
				}
				RenderTexture.ReleaseTemporary(temporary);
			}
		}
		internal class Triangles
		{
			private static Mesh[] meshes;

			private static int currentTris;

			private static bool HasMeshes()
			{
				if (meshes == null)
				{
					return false;
				}
				for (int i = 0; i < meshes.Length; i++)
				{
					if (null == meshes[i])
					{
						return false;
					}
				}
				return true;
			}

			private static void Cleanup()
			{
				if (meshes == null)
				{
					return;
				}
				for (int i = 0; i < meshes.Length; i++)
				{
					if (null != meshes[i])
					{
						UnityEngine.Object.DestroyImmediate(meshes[i]);
						meshes[i] = null;
					}
				}
				meshes = null;
			}

			private static Mesh[] GetMeshes(int totalWidth, int totalHeight)
			{
				if (HasMeshes() && currentTris == totalWidth * totalHeight)
				{
					return meshes;
				}
				int num = 21666;
				int num2 = (currentTris = totalWidth * totalHeight);
				meshes = new Mesh[Mathf.CeilToInt(1f * (float)num2 / (1f * (float)num))];
				int num3 = 0;
				int num4 = 0;
				for (num3 = 0; num3 < num2; num3 += num)
				{
					int triCount = Mathf.FloorToInt(Mathf.Clamp(num2 - num3, 0, num));
					meshes[num4] = GetMesh(triCount, num3, totalWidth, totalHeight);
					num4++;
				}
				return meshes;
			}

			private static Mesh GetMesh(int triCount, int triOffset, int totalWidth, int totalHeight)
			{
				Mesh mesh = new Mesh();
				mesh.hideFlags = HideFlags.DontSave;
				Vector3[] array = new Vector3[triCount * 3];
				Vector2[] array2 = new Vector2[triCount * 3];
				Vector2[] array3 = new Vector2[triCount * 3];
				int[] array4 = new int[triCount * 3];
				for (int i = 0; i < triCount; i++)
				{
					int num = i * 3;
					int num2 = triOffset + i;
					float num3 = Mathf.Floor(num2 % totalWidth) / (float)totalWidth;
					float num4 = Mathf.Floor(num2 / totalWidth) / (float)totalHeight;
					array[num + 2] = (array[num + 1] = (array[num] = new Vector3(num3 * 2f - 1f, num4 * 2f - 1f, 1f)));
					array2[num] = new Vector2(0f, 0f);
					array2[num + 1] = new Vector2(1f, 0f);
					array2[num + 2] = new Vector2(0f, 1f);
					array3[num] = new Vector2(num3, num4);
					array3[num + 1] = new Vector2(num3, num4);
					array3[num + 2] = new Vector2(num3, num4);
					array4[num] = num;
					array4[num + 1] = num + 1;
					array4[num + 2] = num + 2;
				}
				mesh.vertices = array;
				mesh.triangles = array4;
				mesh.uv = array2;
				mesh.uv2 = array3;
				return mesh;
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Displacement/Twirl")]
		public class Twirl : ImageEffectBase
		{
			public Vector2 radius = new Vector2(0.3f, 0.3f);

			[Range(0f, 360f)]
			public float angle = 50f;

			public Vector2 center = new Vector2(0.5f, 0.5f);

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(Camera))]
		[AddComponentMenu("Image Effects/Camera/Vignette and Chromatic Aberration")]
		public class VignetteAndChromaticAberration : PostEffectsBase
		{
			public enum AberrationMode
			{
				Simple,
				Advanced
			}

			public AberrationMode mode;

			public float intensity = 0.036f;

			public float chromaticAberration = 0.2f;

			public float axialAberration = 0.5f;

			public float blur;

			public float blurSpread = 0.75f;

			public float luminanceDependency = 0.25f;

			public float blurDistance = 2.5f;

			public Shader vignetteShader;

			public Shader separableBlurShader;

			public Shader chromAberrationShader;

			private Material m_VignetteMaterial;

			private Material m_SeparableBlurMaterial;

			private Material m_ChromAberrationMaterial;

			public override bool CheckResources()
			{
				CheckSupport(needDepth: false);
				m_VignetteMaterial = CheckShaderAndCreateMaterial(vignetteShader, m_VignetteMaterial);
				m_SeparableBlurMaterial = CheckShaderAndCreateMaterial(separableBlurShader, m_SeparableBlurMaterial);
				m_ChromAberrationMaterial = CheckShaderAndCreateMaterial(chromAberrationShader, m_ChromAberrationMaterial);
				if (!isSupported)
				{
					ReportAutoDisable();
				}
				return isSupported;
			}

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				if (!CheckResources())
				{
					Graphics.Blit(source, destination);
					return;
				}
				int width = source.width;
				int height = source.height;
				bool flag = Mathf.Abs(blur) > 0f || Mathf.Abs(intensity) > 0f;
				float num = 1f * (float)width / (1f * (float)height);
				RenderTexture renderTexture = null;
				RenderTexture renderTexture2 = null;
				if (flag)
				{
					renderTexture = RenderTexture.GetTemporary(width, height, 0, source.format);
					if (Mathf.Abs(blur) > 0f)
					{
						renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
						Graphics.Blit(source, renderTexture2, m_ChromAberrationMaterial, 0);
						for (int i = 0; i < 2; i++)
						{
							m_SeparableBlurMaterial.SetVector("offsets", new Vector4(0f, blurSpread * 0.001953125f, 0f, 0f));
							RenderTexture temporary = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
							Graphics.Blit(renderTexture2, temporary, m_SeparableBlurMaterial);
							RenderTexture.ReleaseTemporary(renderTexture2);
							m_SeparableBlurMaterial.SetVector("offsets", new Vector4(blurSpread * 0.001953125f / num, 0f, 0f, 0f));
							renderTexture2 = RenderTexture.GetTemporary(width / 2, height / 2, 0, source.format);
							Graphics.Blit(temporary, renderTexture2, m_SeparableBlurMaterial);
							RenderTexture.ReleaseTemporary(temporary);
						}
					}
					m_VignetteMaterial.SetFloat("_Intensity", 1f / (1f - intensity) - 1f);
					m_VignetteMaterial.SetFloat("_Blur", 1f / (1f - blur) - 1f);
					m_VignetteMaterial.SetTexture("_VignetteTex", renderTexture2);
					Graphics.Blit(source, renderTexture, m_VignetteMaterial, 0);
				}
				m_ChromAberrationMaterial.SetFloat("_ChromaticAberration", chromaticAberration);
				m_ChromAberrationMaterial.SetFloat("_AxialAberration", axialAberration);
				m_ChromAberrationMaterial.SetVector("_BlurDistance", new Vector2(0f - blurDistance, blurDistance));
				m_ChromAberrationMaterial.SetFloat("_Luminance", 1f / Mathf.Max(Mathf.Epsilon, luminanceDependency));
				if (flag)
				{
					renderTexture.wrapMode = TextureWrapMode.Clamp;
				}
				else
				{
					source.wrapMode = TextureWrapMode.Clamp;
				}
				Graphics.Blit(flag ? renderTexture : source, destination, m_ChromAberrationMaterial, (mode != AberrationMode.Advanced) ? 1 : 2);
				RenderTexture.ReleaseTemporary(renderTexture);
				RenderTexture.ReleaseTemporary(renderTexture2);
			}
		}
		[ExecuteInEditMode]
		[AddComponentMenu("Image Effects/Displacement/Vortex")]
		public class Vortex : ImageEffectBase
		{
			public Vector2 radius = new Vector2(0.4f, 0.4f);

			public float angle = 50f;

			public Vector2 center = new Vector2(0.5f, 0.5f);

			private void OnRenderImage(RenderTexture source, RenderTexture destination)
			{
				ImageEffects.RenderDistortion(base.material, source, destination, angle, center, radius);
			}
		}
	}
	namespace UnityStandardAssets.Effects
	{
		[RequireComponent(typeof(SphereCollider))]
		public class AfterburnerPhysicsForce : MonoBehaviour
		{
			public float effectAngle = 15f;

			public float effectWidth = 1f;

			public float effectDistance = 10f;

			public float force = 10f;

			private Collider[] m_Cols;

			private SphereCollider m_Sphere;

			private void OnEnable()
			{
				m_Sphere = GetComponent<Collider>() as SphereCollider;
			}

			private void FixedUpdate()
			{
				m_Cols = Physics.OverlapSphere(base.transform.position + m_Sphere.center, m_Sphere.radius);
				for (int i = 0; i < m_Cols.Length; i++)
				{
					if (m_Cols[i].attachedRigidbody != null)
					{
						Vector3 current = base.transform.InverseTransformPoint(m_Cols[i].transform.position);
						current = Vector3.MoveTowards(current, new Vector3(0f, 0f, current.z), effectWidth * 0.5f);
						float value = Mathf.Abs(Mathf.Atan2(current.x, current.z) * 57.29578f);
						float num = Mathf.InverseLerp(effectDistance, 0f, current.magnitude);
						num *= Mathf.InverseLerp(effectAngle, 0f, value);
						Vector3 vector = m_Cols[i].transform.position - base.transform.position;
						m_Cols[i].attachedRigidbody.AddForceAtPosition(vector.normalized * force * num, Vector3.Lerp(m_Cols[i].transform.position, base.transform.TransformPoint(0f, 0f, current.z), 0.1f));
					}
				}
			}

			private void OnDrawGizmosSelected()
			{
				if (m_Sphere == null)
				{
					m_Sphere = GetComponent<Collider>() as SphereCollider;
				}
				m_Sphere.radius = effectDistance * 0.5f;
				m_Sphere.center = new Vector3(0f, 0f, effectDistance * 0.5f);
				Vector3[] array = new Vector3[4]
				{
					Vector3.up,
					-Vector3.up,
					Vector3.right,
					-Vector3.right
				};
				Vector3[] array2 = new Vector3[4]
				{
					-Vector3.right,
					Vector3.right,
					Vector3.up,
					-Vector3.up
				};
				Gizmos.color = new Color(0f, 1f, 0f, 0.5f);
				for (int i = 0; i < 4; i++)
				{
					Vector3 vector = base.transform.position + base.transform.rotation * array[i] * effectWidth * 0.5f;
					Vector3 vector2 = base.transform.TransformDirection(Quaternion.AngleAxis(effectAngle, array2[i]) * Vector3.forward);
					Gizmos.DrawLine(vector, vector + vector2 * m_Sphere.radius * 2f);
				}
			}
		}
		public class ExplosionFireAndDebris : MonoBehaviour
		{
			public Transform[] debrisPrefabs;

			public Transform firePrefab;

			public int numDebrisPieces;

			public int numFires;

			private IEnumerator Start()
			{
				float multiplier = GetComponent<ParticleSystemMultiplier>().multiplier;
				for (int i = 0; (float)i < (float)numDebrisPieces * multiplier; i++)
				{
					Transform original = debrisPrefabs[UnityEngine.Random.Range(0, debrisPrefabs.Length)];
					Vector3 position = base.transform.position + UnityEngine.Random.insideUnitSphere * 3f * multiplier;
					Quaternion rotation = UnityEngine.Random.rotation;
					UnityEngine.Object.Instantiate(original, position, rotation);
				}
				yield return null;
				float num = 10f * multiplier;
				Collider[] array = Physics.OverlapSphere(base.transform.position, num);
				foreach (Collider collider in array)
				{
					if (numFires > 0)
					{
						Ray ray = new Ray(base.transform.position, collider.transform.position - base.transform.position);
						if (collider.Raycast(ray, out var hitInfo, num))
						{
							AddFire(collider.transform, hitInfo.point, hitInfo.normal);
							numFires--;
						}
					}
				}
				float num2 = 0f;
				while (numFires > 0 && num2 < num)
				{
					if (Physics.Raycast(new Ray(base.transform.position + Vector3.up, UnityEngine.Random.onUnitSphere), out var hitInfo2, num2))
					{
						AddFire(null, hitInfo2.point, hitInfo2.normal);
						numFires--;
					}
					num2 += num * 0.1f;
				}
			}

			private void AddFire(Transform t, Vector3 pos, Vector3 normal)
			{
				pos += normal * 0.5f;
				UnityEngine.Object.Instantiate(firePrefab, pos, Quaternion.identity).parent = t;
			}
		}
		public class ExplosionPhysicsForce : MonoBehaviour
		{
			public float explosionForce = 4f;

			private IEnumerator Start()
			{
				yield return null;
				float multiplier = GetComponent<ParticleSystemMultiplier>().multiplier;
				float num = 10f * multiplier;
				Collider[] array = Physics.OverlapSphere(base.transform.position, num);
				List<Rigidbody> list = new List<Rigidbody>();
				Collider[] array2 = array;
				foreach (Collider collider in array2)
				{
					if (collider.attachedRigidbody != null && !list.Contains(collider.attachedRigidbody))
					{
						list.Add(collider.attachedRigidbody);
					}
				}
				foreach (Rigidbody item in list)
				{
					item.AddExplosionForce(explosionForce * multiplier, base.transform.position, num, 1f * multiplier, ForceMode.Impulse);
				}
			}
		}
		public class Explosive : MonoBehaviour
		{
			public Transform explosionPrefab;

			public float detonationImpactVelocity = 10f;

			public float sizeMultiplier = 1f;

			public bool reset = true;

			public float resetTimeDelay = 10f;

			private bool m_Exploded;

			private ObjectResetter m_ObjectResetter;

			private void Start()
			{
				m_ObjectResetter = GetComponent<ObjectResetter>();
			}

			private IEnumerator OnCollisionEnter(Collision col)
			{
				if (base.enabled && col.contacts.Length != 0 && (Vector3.Project(col.relativeVelocity, col.contacts[0].normal).magnitude > detonationImpactVelocity || m_Exploded) && !m_Exploded)
				{
					UnityEngine.Object.Instantiate(explosionPrefab, col.contacts[0].point, Quaternion.LookRotation(col.contacts[0].normal));
					m_Exploded = true;
					SendMessage("Immobilize");
					if (reset)
					{
						m_ObjectResetter.DelayedReset(resetTimeDelay);
					}
				}
				yield return null;
			}

			public void Reset()
			{
				m_Exploded = false;
			}
		}
		public class ExtinguishableParticleSystem : MonoBehaviour
		{
			public float multiplier = 1f;

			private ParticleSystem[] m_Systems;

			private void Start()
			{
				m_Systems = GetComponentsInChildren<ParticleSystem>();
			}

			public void Extinguish()
			{
				ParticleSystem[] systems = m_Systems;
				for (int i = 0; i < systems.Length; i++)
				{
					ParticleSystem.EmissionModule emission = systems[i].emission;
					emission.enabled = false;
				}
			}
		}
		public class FireLight : MonoBehaviour
		{
			private float m_Rnd;

			private bool m_Burning = true;

			private Light m_Light;

			private void Start()
			{
				m_Rnd = UnityEngine.Random.value * 100f;
				m_Light = GetComponent<Light>();
			}

			private void Update()
			{
				if (m_Burning)
				{
					m_Light.intensity = 2f * Mathf.PerlinNoise(m_Rnd + Time.time, m_Rnd + 1f + Time.time * 1f);
					float x = Mathf.PerlinNoise(m_Rnd + 0f + Time.time * 2f, m_Rnd + 1f + Time.time * 2f) - 0.5f;
					float y = Mathf.PerlinNoise(m_Rnd + 2f + Time.time * 2f, m_Rnd + 3f + Time.time * 2f) - 0.5f;
					float z = Mathf.PerlinNoise(m_Rnd + 4f + Time.time * 2f, m_Rnd + 5f + Time.time * 2f) - 0.5f;
					base.transform.localPosition = Vector3.up + new Vector3(x, y, z) * 1f;
				}
			}

			public void Extinguish()
			{
				m_Burning = false;
				m_Light.enabled = false;
			}
		}
		public class Hose : MonoBehaviour
		{
			public float maxPower = 20f;

			public float minPower = 5f;

			public float changeSpeed = 5f;

			public ParticleSystem[] hoseWaterSystems;

			public Renderer systemRenderer;

			private float m_Power;

			private void Update()
			{
				m_Power = Mathf.Lerp(m_Power, Input.GetMouseButton(0) ? maxPower : minPower, Time.deltaTime * changeSpeed);
				if (Input.GetKeyDown(KeyCode.Alpha1))
				{
					systemRenderer.enabled = !systemRenderer.enabled;
				}
				ParticleSystem[] array = hoseWaterSystems;
				foreach (ParticleSystem obj in array)
				{
					ParticleSystem.MainModule main = obj.main;
					main.startSpeed = m_Power;
					ParticleSystem.EmissionModule emission = obj.emission;
					emission.enabled = m_Power > minPower * 1.1f;
				}
			}
		}
		public class ParticleSystemMultiplier : MonoBehaviour
		{
			public float multiplier = 1f;

			private void Start()
			{
				ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
				foreach (ParticleSystem obj in componentsInChildren)
				{
					ParticleSystem.MainModule main = obj.main;
					main.startSizeMultiplier *= multiplier;
					main.startSpeedMultiplier *= multiplier;
					main.startLifetimeMultiplier *= Mathf.Lerp(multiplier, 1f, 0.5f);
					obj.Clear();
					obj.Play();
				}
			}
		}
		public class SmokeParticles : MonoBehaviour
		{
			public AudioClip[] extinguishSounds;

			private void Start()
			{
				GetComponent<AudioSource>().clip = extinguishSounds[UnityEngine.Random.Range(0, extinguishSounds.Length)];
				GetComponent<AudioSource>().Play();
			}
		}
		public class WaterHoseParticles : MonoBehaviour
		{
			public static float lastSoundTime;

			public float force = 1f;

			private List<ParticleCollisionEvent> m_CollisionEvents = new List<ParticleCollisionEvent>();

			private ParticleSystem m_ParticleSystem;

			private void Start()
			{
				m_ParticleSystem = GetComponent<ParticleSystem>();
			}

			private void OnParticleCollision(GameObject other)
			{
				int collisionEvents = m_ParticleSystem.GetCollisionEvents(other, m_CollisionEvents);
				for (int i = 0; i < collisionEvents; i++)
				{
					if (Time.time > lastSoundTime + 0.2f)
					{
						lastSoundTime = Time.time;
					}
					Rigidbody component = m_CollisionEvents[i].colliderComponent.GetComponent<Rigidbody>();
					if (component != null)
					{
						Vector3 velocity = m_CollisionEvents[i].velocity;
						component.AddForce(velocity * force, ForceMode.Impulse);
					}
					other.BroadcastMessage("Extinguish", SendMessageOptions.DontRequireReceiver);
				}
			}
		}
	}
	namespace UnityStandardAssets.Water
	{
		[ExecuteInEditMode]
		public class WaterBasic : MonoBehaviour
		{
			private void Update()
			{
				Renderer component = GetComponent<Renderer>();
				if ((bool)component)
				{
					Material sharedMaterial = component.sharedMaterial;
					if ((bool)sharedMaterial)
					{
						Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
						float @float = sharedMaterial.GetFloat("_WaveScale");
						float num = Time.time / 20f;
						Vector4 vector2 = vector * (num * @float);
						Vector4 value = new Vector4(Mathf.Repeat(vector2.x, 1f), Mathf.Repeat(vector2.y, 1f), Mathf.Repeat(vector2.z, 1f), Mathf.Repeat(vector2.w, 1f));
						sharedMaterial.SetVector("_WaveOffset", value);
					}
				}
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(WaterBase))]
		public class Displace : MonoBehaviour
		{
			public void Awake()
			{
				if (base.enabled)
				{
					OnEnable();
				}
				else
				{
					OnDisable();
				}
			}

			public void OnEnable()
			{
				Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
				Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
			}

			public void OnDisable()
			{
				Shader.EnableKeyword("WATER_VERTEX_DISPLACEMENT_OFF");
				Shader.DisableKeyword("WATER_VERTEX_DISPLACEMENT_ON");
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(WaterBase))]
		public class GerstnerDisplace : Displace
		{
		}
		public class MeshContainer
		{
			public Mesh mesh;

			public Vector3[] vertices;

			public Vector3[] normals;

			public MeshContainer(Mesh m)
			{
				mesh = m;
				vertices = m.vertices;
				normals = m.normals;
			}

			public void Update()
			{
				mesh.vertices = vertices;
				mesh.normals = normals;
			}
		}
		[ExecuteInEditMode]
		[RequireComponent(typeof(WaterBase))]
		public class PlanarReflection : MonoBehaviour
		{
			public LayerMask reflectionMask;

			public bool reflectSkybox;

			public Color clearColor = Color.grey;

			public string reflectionSampler = "_ReflectionTex";

			public float clipPlaneOffset = 0.07f;

			public bool onlyCalculateOnStart;

			private Texture savedTexture;

			private Vector3 m_Oldpos;

			private Camera m_ReflectionCamera;

			private Material m_SharedMaterial;

			private Dictionary<Camera, bool> m_HelperCameras;

			public void Start()
			{
				m_SharedMaterial = ((WaterBase)base.gameObject.GetComponent(typeof(WaterBase))).sharedMaterial;
			}

			private Camera CreateReflectionCameraFor(Camera cam)
			{
				string text = base.gameObject.name + "Reflection" + cam.name;
				GameObject gameObject = GameObject.Find(text);
				if (!gameObject)
				{
					gameObject = new GameObject(text, typeof(Camera));
				}
				if (!gameObject.GetComponent(typeof(Camera)))
				{
					gameObject.AddComponent(typeof(Camera));
				}
				Camera component = gameObject.GetComponent<Camera>();
				component.backgroundColor = clearColor;
				component.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
				SetStandardCameraParameter(component, reflectionMask);
				if (!component.targetTexture)
				{
					component.targetTexture = CreateTextureFor(cam);
				}
				return component;
			}

			private void SetStandardCameraParameter(Camera cam, LayerMask mask)
			{
				cam.cullingMask = (int)mask & ~(1 << LayerMask.NameToLayer("Water"));
				cam.backgroundColor = Color.black;
				cam.enabled = false;
			}

			private RenderTexture CreateTextureFor(Camera cam)
			{
				return new RenderTexture(Mathf.FloorToInt((float)cam.pixelWidth * 0.5f), Mathf.FloorToInt((float)cam.pixelHeight * 0.5f), 24)
				{
					hideFlags = HideFlags.DontSave
				};
			}

			public void RenderHelpCameras(Camera currentCam)
			{
				if (m_HelperCameras == null)
				{
					m_HelperCameras = new Dictionary<Camera, bool>();
				}
				if (!m_HelperCameras.ContainsKey(currentCam))
				{
					m_HelperCameras.Add(currentCam, value: false);
				}
				if (!m_HelperCameras[currentCam])
				{
					if (!m_ReflectionCamera)
					{
						m_ReflectionCamera = CreateReflectionCameraFor(currentCam);
					}
					RenderReflectionFor(currentCam, m_ReflectionCamera);
					m_HelperCameras[currentCam] = true;
				}
			}

			public void LateUpdate()
			{
				if (m_HelperCameras != null)
				{
					m_HelperCameras.Clear();
				}
			}

			public void WaterTileBeingRendered(Transform tr, Camera currentCam)
			{
				RenderHelpCameras(currentCam);
				if ((bool)m_ReflectionCamera && (bool)m_SharedMaterial)
				{
					m_SharedMaterial.SetTexture(reflectionSampler, m_ReflectionCamera.targetTexture);
				}
			}

			public void OnEnable()
			{
				Shader.EnableKeyword("WATER_REFLECTIVE");
				Shader.DisableKeyword("WATER_SIMPLE");
			}

			public void OnDisable()
			{
				Shader.EnableKeyword("WATER_SIMPLE");
				Shader.DisableKeyword("WATER_REFLECTIVE");
			}

			private void RenderReflectionFor(Camera cam, Camera reflectCamera)
			{
				if (!reflectCamera || ((bool)m_SharedMaterial && !m_SharedMaterial.HasProperty(reflectionSampler)))
				{
					return;
				}
				reflectCamera.cullingMask = (int)reflectionMask & ~(1 << LayerMask.NameToLayer("Water"));
				SaneCameraSettings(reflectCamera);
				reflectCamera.backgroundColor = clearColor;
				reflectCamera.clearFlags = (reflectSkybox ? CameraClearFlags.Skybox : CameraClearFlags.Color);
				if (reflectSkybox && (bool)cam.gameObject.GetComponent(typeof(Skybox)))
				{
					Skybox skybox = (Skybox)reflectCamera.gameObject.GetComponent(typeof(Skybox));
					if (!skybox)
					{
						skybox = (Skybox)reflectCamera.gameObject.AddComponent(typeof(Skybox));
					}
					skybox.material = ((Skybox)cam.GetComponent(typeof(Skybox))).material;
				}
				GL.invertCulling = true;
				Transform transform = base.transform;
				Vector3 eulerAngles = cam.transform.eulerAngles;
				reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
				reflectCamera.transform.position = cam.transform.position;
				Vector3 position = transform.transform.position;
				position.y = transform.position.y;
				Vector3 up = transform.transform.up;
				float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
				Vector4 plane = new Vector4(up.x, up.y, up.z, w);
				Matrix4x4 zero = Matrix4x4.zero;
				zero = CalculateReflectionMatrix(zero, plane);
				m_Oldpos = cam.transform.position;
				Vector3 position2 = zero.MultiplyPoint(m_Oldpos);
				reflectCamera.worldToCameraMatrix = cam.worldToCameraMatrix * zero;
				Vector4 clipPlane = CameraSpacePlane(reflectCamera, position, up, 1f);
				Matrix4x4 projectionMatrix = cam.projectionMatrix;
				projectionMatrix = CalculateObliqueMatrix(projectionMatrix, clipPlane);
				reflectCamera.projectionMatrix = projectionMatrix;
				reflectCamera.transform.position = position2;
				Vector3 eulerAngles2 = cam.transform.eulerAngles;
				reflectCamera.transform.eulerAngles = new Vector3(0f - eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
				reflectCamera.Render();
				GL.invertCulling = false;
			}

			private void SaneCameraSettings(Camera helperCam)
			{
				helperCam.depthTextureMode = DepthTextureMode.None;
				helperCam.backgroundColor = Color.black;
				helperCam.clearFlags = CameraClearFlags.Color;
				helperCam.renderingPath = RenderingPath.Forward;
			}

			private static Matrix4x4 CalculateObliqueMatrix(Matrix4x4 projection, Vector4 clipPlane)
			{
				Vector4 b = projection.inverse * new Vector4(Sgn(clipPlane.x), Sgn(clipPlane.y), 1f, 1f);
				Vector4 vector = clipPlane * (2f / Vector4.Dot(clipPlane, b));
				projection[2] = vector.x - projection[3];
				projection[6] = vector.y - projection[7];
				projection[10] = vector.z - projection[11];
				projection[14] = vector.w - projection[15];
				return projection;
			}

			private static Matrix4x4 CalculateReflectionMatrix(Matrix4x4 reflectionMat, Vector4 plane)
			{
				reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
				reflectionMat.m01 = -2f * plane[0] * plane[1];
				reflectionMat.m02 = -2f * plane[0] * plane[2];
				reflectionMat.m03 = -2f * plane[3] * plane[0];
				reflectionMat.m10 = -2f * plane[1] * plane[0];
				reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
				reflectionMat.m12 = -2f * plane[1] * plane[2];
				reflectionMat.m13 = -2f * plane[3] * plane[1];
				reflectionMat.m20 = -2f * plane[2] * plane[0];
				reflectionMat.m21 = -2f * plane[2] * plane[1];
				reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
				reflectionMat.m23 = -2f * plane[3] * plane[2];
				reflectionMat.m30 = 0f;
				reflectionMat.m31 = 0f;
				reflectionMat.m32 = 0f;
				reflectionMat.m33 = 1f;
				return reflectionMat;
			}

			private static float Sgn(float a)
			{
				if (a > 0f)
				{
					return 1f;
				}
				if (a < 0f)
				{
					return -1f;
				}
				return 0f;
			}

			private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
			{
				Vector3 point = pos + normal * clipPlaneOffset;
				Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
				Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
				Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
				return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
			}
		}
		[RequireComponent(typeof(WaterBase))]
		[ExecuteInEditMode]
		public class SpecularLighting : MonoBehaviour
		{
			public Transform specularLight;

			private WaterBase m_WaterBase;

			public void Start()
			{
				m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
			}

			public void Update()
			{
				if (!m_WaterBase)
				{
					m_WaterBase = (WaterBase)base.gameObject.GetComponent(typeof(WaterBase));
				}
				if ((bool)specularLight && (bool)m_WaterBase.sharedMaterial)
				{
					m_WaterBase.sharedMaterial.SetVector("_WorldLightDir", specularLight.transform.forward);
				}
			}
		}
		[ExecuteInEditMode]
		public class Water : MonoBehaviour
		{
			public enum WaterMode
			{
				Simple,
				Reflective,
				Refractive
			}

			public WaterMode waterMode = WaterMode.Refractive;

			public bool disablePixelLights = true;

			public int textureSize = 256;

			public float clipPlaneOffset = 0.07f;

			public LayerMask reflectLayers = -1;

			public LayerMask refractLayers = -1;

			private Dictionary<Camera, Camera> m_ReflectionCameras = new Dictionary<Camera, Camera>();

			private Dictionary<Camera, Camera> m_RefractionCameras = new Dictionary<Camera, Camera>();

			private RenderTexture m_ReflectionTexture;

			private RenderTexture m_RefractionTexture;

			private WaterMode m_HardwareWaterSupport = WaterMode.Refractive;

			private int m_OldReflectionTextureSize;

			private int m_OldRefractionTextureSize;

			private static bool s_InsideWater;

			public void OnWillRenderObject()
			{
				if (!base.enabled || !GetComponent<Renderer>() || !GetComponent<Renderer>().sharedMaterial || !GetComponent<Renderer>().enabled)
				{
					return;
				}
				Camera current = Camera.current;
				if ((bool)current && !s_InsideWater)
				{
					s_InsideWater = true;
					m_HardwareWaterSupport = FindHardwareWaterSupport();
					WaterMode waterMode = GetWaterMode();
					CreateWaterObjects(current, out var reflectionCamera, out var refractionCamera);
					Vector3 position = base.transform.position;
					Vector3 up = base.transform.up;
					int pixelLightCount = QualitySettings.pixelLightCount;
					if (disablePixelLights)
					{
						QualitySettings.pixelLightCount = 0;
					}
					UpdateCameraModes(current, reflectionCamera);
					UpdateCameraModes(current, refractionCamera);
					if (waterMode >= WaterMode.Reflective)
					{
						float w = 0f - Vector3.Dot(up, position) - clipPlaneOffset;
						Vector4 plane = new Vector4(up.x, up.y, up.z, w);
						Matrix4x4 reflectionMat = Matrix4x4.zero;
						CalculateReflectionMatrix(ref reflectionMat, plane);
						Vector3 position2 = current.transform.position;
						Vector3 position3 = reflectionMat.MultiplyPoint(position2);
						reflectionCamera.worldToCameraMatrix = current.worldToCameraMatrix * reflectionMat;
						Vector4 clipPlane = CameraSpacePlane(reflectionCamera, position, up, 1f);
						reflectionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane);
						reflectionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
						reflectionCamera.cullingMask = -17 & reflectLayers.value;
						reflectionCamera.targetTexture = m_ReflectionTexture;
						bool invertCulling = GL.invertCulling;
						GL.invertCulling = !invertCulling;
						reflectionCamera.transform.position = position3;
						Vector3 eulerAngles = current.transform.eulerAngles;
						reflectionCamera.transform.eulerAngles = new Vector3(0f - eulerAngles.x, eulerAngles.y, eulerAngles.z);
						reflectionCamera.Render();
						reflectionCamera.transform.position = position2;
						GL.invertCulling = invertCulling;
						GetComponent<Renderer>().sharedMaterial.SetTexture("_ReflectionTex", m_ReflectionTexture);
					}
					if (waterMode >= WaterMode.Refractive)
					{
						refractionCamera.worldToCameraMatrix = current.worldToCameraMatrix;
						Vector4 clipPlane2 = CameraSpacePlane(refractionCamera, position, up, -1f);
						refractionCamera.projectionMatrix = current.CalculateObliqueMatrix(clipPlane2);
						refractionCamera.cullingMatrix = current.projectionMatrix * current.worldToCameraMatrix;
						refractionCamera.cullingMask = -17 & refractLayers.value;
						refractionCamera.targetTexture = m_RefractionTexture;
						refractionCamera.transform.position = current.transform.position;
						refractionCamera.transform.rotation = current.transform.rotation;
						refractionCamera.Render();
						GetComponent<Renderer>().sharedMaterial.SetTexture("_RefractionTex", m_RefractionTexture);
					}
					if (disablePixelLights)
					{
						QualitySettings.pixelLightCount = pixelLightCount;
					}
					switch (waterMode)
					{
					case WaterMode.Simple:
						Shader.EnableKeyword("WATER_SIMPLE");
						Shader.DisableKeyword("WATER_REFLECTIVE");
						Shader.DisableKeyword("WATER_REFRACTIVE");
						break;
					case WaterMode.Reflective:
						Shader.DisableKeyword("WATER_SIMPLE");
						Shader.EnableKeyword("WATER_REFLECTIVE");
						Shader.DisableKeyword("WATER_REFRACTIVE");
						break;
					case WaterMode.Refractive:
						Shader.DisableKeyword("WATER_SIMPLE");
						Shader.DisableKeyword("WATER_REFLECTIVE");
						Shader.EnableKeyword("WATER_REFRACTIVE");
						break;
					}
					s_InsideWater = false;
				}
			}

			private void OnDisable()
			{
				if ((bool)m_ReflectionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
					m_ReflectionTexture = null;
				}
				if ((bool)m_RefractionTexture)
				{
					UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
					m_RefractionTexture = null;
				}
				foreach (KeyValuePair<Camera, Camera> reflectionCamera in m_ReflectionCameras)
				{
					UnityEngine.Object.DestroyImmediate(reflectionCamera.Value.gameObject);
				}
				m_ReflectionCameras.Clear();
				foreach (KeyValuePair<Camera, Camera> refractionCamera in m_RefractionCameras)
				{
					UnityEngine.Object.DestroyImmediate(refractionCamera.Value.gameObject);
				}
				m_RefractionCameras.Clear();
			}

			private void Update()
			{
				if ((bool)GetComponent<Renderer>())
				{
					Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
					if ((bool)sharedMaterial)
					{
						Vector4 vector = sharedMaterial.GetVector("WaveSpeed");
						float @float = sharedMaterial.GetFloat("_WaveScale");
						Vector4 value = new Vector4(@float, @float, @float * 0.4f, @float * 0.45f);
						double num = (double)Time.timeSinceLevelLoad / 20.0;
						Vector4 value2 = new Vector4((float)Math.IEEERemainder((double)(vector.x * value.x) * num, 1.0), (float)Math.IEEERemainder((double)(vector.y * value.y) * num, 1.0), (float)Math.IEEERemainder((double)(vector.z * value.z) * num, 1.0), (float)Math.IEEERemainder((double)(vector.w * value.w) * num, 1.0));
						sharedMaterial.SetVector("_WaveOffset", value2);
						sharedMaterial.SetVector("_WaveScale4", value);
					}
				}
			}

			private void UpdateCameraModes(Camera src, Camera dest)
			{
				if (dest == null)
				{
					return;
				}
				dest.clearFlags = src.clearFlags;
				dest.backgroundColor = src.backgroundColor;
				if (src.clearFlags == CameraClearFlags.Skybox)
				{
					Skybox component = src.GetComponent<Skybox>();
					Skybox component2 = dest.GetComponent<Skybox>();
					if (!component || !component.material)
					{
						component2.enabled = false;
					}
					else
					{
						component2.enabled = true;
						component2.material = component.material;
					}
				}
				dest.farClipPlane = src.farClipPlane;
				dest.nearClipPlane = src.nearClipPlane;
				dest.orthographic = src.orthographic;
				dest.fieldOfView = src.fieldOfView;
				dest.aspect = src.aspect;
				dest.orthographicSize = src.orthographicSize;
			}

			private void CreateWaterObjects(Camera currentCamera, out Camera reflectionCamera, out Camera refractionCamera)
			{
				WaterMode waterMode = GetWaterMode();
				reflectionCamera = null;
				refractionCamera = null;
				if (waterMode >= WaterMode.Reflective)
				{
					if (!m_ReflectionTexture || m_OldReflectionTextureSize != textureSize)
					{
						if ((bool)m_ReflectionTexture)
						{
							UnityEngine.Object.DestroyImmediate(m_ReflectionTexture);
						}
						m_ReflectionTexture = new RenderTexture(textureSize, textureSize, 16);
						m_ReflectionTexture.name = "__WaterReflection" + GetInstanceID();
						m_ReflectionTexture.isPowerOfTwo = true;
						m_ReflectionTexture.hideFlags = HideFlags.DontSave;
						m_OldReflectionTextureSize = textureSize;
					}
					m_ReflectionCameras.TryGetValue(currentCamera, out reflectionCamera);
					if (!reflectionCamera)
					{
						GameObject gameObject = new GameObject("Water Refl Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
						reflectionCamera = gameObject.GetComponent<Camera>();
						reflectionCamera.enabled = false;
						reflectionCamera.transform.position = base.transform.position;
						reflectionCamera.transform.rotation = base.transform.rotation;
						reflectionCamera.gameObject.AddComponent<FlareLayer>();
						gameObject.hideFlags = HideFlags.HideAndDontSave;
						m_ReflectionCameras[currentCamera] = reflectionCamera;
					}
				}
				if (waterMode < WaterMode.Refractive)
				{
					return;
				}
				if (!m_RefractionTexture || m_OldRefractionTextureSize != textureSize)
				{
					if ((bool)m_RefractionTexture)
					{
						UnityEngine.Object.DestroyImmediate(m_RefractionTexture);
					}
					m_RefractionTexture = new RenderTexture(textureSize, textureSize, 16);
					m_RefractionTexture.name = "__WaterRefraction" + GetInstanceID();
					m_RefractionTexture.isPowerOfTwo = true;
					m_RefractionTexture.hideFlags = HideFlags.DontSave;
					m_OldRefractionTextureSize = textureSize;
				}
				m_RefractionCameras.TryGetValue(currentCamera, out refractionCamera);
				if (!refractionCamera)
				{
					GameObject gameObject2 = new GameObject("Water Refr Camera id" + GetInstanceID() + " for " + currentCamera.GetInstanceID(), typeof(Camera), typeof(Skybox));
					refractionCamera = gameObject2.GetComponent<Camera>();
					refractionCamera.enabled = false;
					refractionCamera.transform.position = base.transform.position;
					refractionCamera.transform.rotation = base.transform.rotation;
					refractionCamera.gameObject.AddComponent<FlareLayer>();
					gameObject2.hideFlags = HideFlags.HideAndDontSave;
					m_RefractionCameras[currentCamera] = refractionCamera;
				}
			}

			private WaterMode GetWaterMode()
			{
				if (m_HardwareWaterSupport < waterMode)
				{
					return m_HardwareWaterSupport;
				}
				return waterMode;
			}

			private WaterMode FindHardwareWaterSupport()
			{
				if (!GetComponent<Renderer>())
				{
					return WaterMode.Simple;
				}
				Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
				if (!sharedMaterial)
				{
					return WaterMode.Simple;
				}
				string text = sharedMaterial.GetTag("WATERMODE", searchFallbacks: false);
				if (text == "Refractive")
				{
					return WaterMode.Refractive;
				}
				if (text == "Reflective")
				{
					return WaterMode.Reflective;
				}
				return WaterMode.Simple;
			}

			private Vector4 CameraSpacePlane(Camera cam, Vector3 pos, Vector3 normal, float sideSign)
			{
				Vector3 point = pos + normal * clipPlaneOffset;
				Matrix4x4 worldToCameraMatrix = cam.worldToCameraMatrix;
				Vector3 lhs = worldToCameraMatrix.MultiplyPoint(point);
				Vector3 rhs = worldToCameraMatrix.MultiplyVector(normal).normalized * sideSign;
				return new Vector4(rhs.x, rhs.y, rhs.z, 0f - Vector3.Dot(lhs, rhs));
			}

			private static void CalculateReflectionMatrix(ref Matrix4x4 reflectionMat, Vector4 plane)
			{
				reflectionMat.m00 = 1f - 2f * plane[0] * plane[0];
				reflectionMat.m01 = -2f * plane[0] * plane[1];
				reflectionMat.m02 = -2f * plane[0] * plane[2];
				reflectionMat.m03 = -2f * plane[3] * plane[0];
				reflectionMat.m10 = -2f * plane[1] * plane[0];
				reflectionMat.m11 = 1f - 2f * plane[1] * plane[1];
				reflectionMat.m12 = -2f * plane[1] * plane[2];
				reflectionMat.m13 = -2f * plane[3] * plane[1];
				reflectionMat.m20 = -2f * plane[2] * plane[0];
				reflectionMat.m21 = -2f * plane[2] * plane[1];
				reflectionMat.m22 = 1f - 2f * plane[2] * plane[2];
				reflectionMat.m23 = -2f * plane[3] * plane[2];
				reflectionMat.m30 = 0f;
				reflectionMat.m31 = 0f;
				reflectionMat.m32 = 0f;
				reflectionMat.m33 = 1f;
			}
		}
		public enum WaterQuality
		{
			High = 2,
			Medium = 1,
			Low = 0
		}
		[ExecuteInEditMode]
		public class WaterBase : MonoBehaviour
		{
			public Material sharedMaterial;

			public WaterQuality waterQuality = WaterQuality.High;

			public bool edgeBlend = true;

			public void UpdateShader()
			{
				if (waterQuality > WaterQuality.Medium)
				{
					sharedMaterial.shader.maximumLOD = 501;
				}
				else if (waterQuality > WaterQuality.Low)
				{
					sharedMaterial.shader.maximumLOD = 301;
				}
				else
				{
					sharedMaterial.shader.maximumLOD = 201;
				}
				if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
				{
					edgeBlend = false;
				}
				if (edgeBlend)
				{
					Shader.EnableKeyword("WATER_EDGEBLEND_ON");
					Shader.DisableKeyword("WATER_EDGEBLEND_OFF");
					if ((bool)Camera.main)
					{
						Camera.main.depthTextureMode |= DepthTextureMode.Depth;
					}
				}
				else
				{
					Shader.EnableKeyword("WATER_EDGEBLEND_OFF");
					Shader.DisableKeyword("WATER_EDGEBLEND_ON");
				}
			}

			public void WaterTileBeingRendered(Transform tr, Camera currentCam)
			{
				if ((bool)currentCam && edgeBlend)
				{
					currentCam.depthTextureMode |= DepthTextureMode.Depth;
				}
			}

			public void Update()
			{
				if ((bool)sharedMaterial)
				{
					UpdateShader();
				}
			}
		}
		[ExecuteInEditMode]
		public class WaterTile : MonoBehaviour
		{
			public PlanarReflection reflection;

			public WaterBase waterBase;

			public void Start()
			{
				AcquireComponents();
			}

			private void AcquireComponents()
			{
				if (!reflection)
				{
					if ((bool)base.transform.parent)
					{
						reflection = base.transform.parent.GetComponent<PlanarReflection>();
					}
					else
					{
						reflection = base.transform.GetComponent<PlanarReflection>();
					}
				}
				if (!waterBase)
				{
					if ((bool)base.transform.parent)
					{
						waterBase = base.transform.parent.GetComponent<WaterBase>();
					}
					else
					{
						waterBase = base.transform.GetComponent<WaterBase>();
					}
				}
			}

			public void OnWillRenderObject()
			{
				if ((bool)reflection)
				{
					reflection.WaterTileBeingRendered(base.transform, Camera.current);
				}
				if ((bool)waterBase)
				{
					waterBase.WaterTileBeingRendered(base.transform, Camera.current);
				}
			}
		}
	}
	namespace UnityStandardAssets.Cameras
	{
		public abstract class AbstractTargetFollower : MonoBehaviour
		{
			public enum UpdateType
			{
				FixedUpdate,
				LateUpdate,
				ManualUpdate
			}

			[SerializeField]
			protected Transform m_Target;

			[SerializeField]
			private bool m_AutoTargetPlayer = true;

			[SerializeField]
			private UpdateType m_UpdateType;

			protected Rigidbody targetRigidbody;

			public Transform Target => m_Target;

			protected virtual void Start()
			{
				if (m_AutoTargetPlayer)
				{
					FindAndTargetPlayer();
				}
				if (!(m_Target == null))
				{
					targetRigidbody = m_Target.GetComponent<Rigidbody>();
				}
			}

			private void FixedUpdate()
			{
				if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
				{
					FindAndTargetPlayer();
				}
				if (m_UpdateType == UpdateType.FixedUpdate)
				{
					FollowTarget(Time.deltaTime);
				}
			}

			private void LateUpdate()
			{
				if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
				{
					FindAndTargetPlayer();
				}
				if (m_UpdateType == UpdateType.LateUpdate)
				{
					FollowTarget(Time.deltaTime);
				}
			}

			public void ManualUpdate()
			{
				if (m_AutoTargetPlayer && (m_Target == null || !m_Target.gameObject.activeSelf))
				{
					FindAndTargetPlayer();
				}
				if (m_UpdateType == UpdateType.ManualUpdate)
				{
					FollowTarget(Time.deltaTime);
				}
			}

			protected abstract void FollowTarget(float deltaTime);

			public void FindAndTargetPlayer()
			{
				GameObject gameObject = GameObject.FindGameObjectWithTag("Player");
				if ((bool)gameObject)
				{
					SetTarget(gameObject.transform);
				}
			}

			public virtual void SetTarget(Transform newTransform)
			{
				m_Target = newTransform;
			}
		}
		[ExecuteInEditMode]
		public class AutoCam : PivotBasedCameraRig
		{
			[SerializeField]
			private float m_MoveSpeed = 3f;

			[SerializeField]
			private float m_TurnSpeed = 1f;

			[SerializeField]
			private float m_RollSpeed = 0.2f;

			[SerializeField]
			private bool m_FollowVelocity;

			[SerializeField]
			private bool m_FollowTilt = true;

			[SerializeField]
			private float m_SpinTurnLimit = 90f;

			[SerializeField]
			private float m_TargetVelocityLowerLimit = 4f;

			[SerializeField]
			private float m_SmoothTurnTime = 0.2f;

			private float m_LastFlatAngle;

			private float m_CurrentTurnAmount;

			private float m_TurnSpeedVelocityChange;

			private Vector3 m_RollUp = Vector3.up;

			public float TurnSpeed
			{
				get
				{
					return m_TurnSpeed;
				}
				set
				{
					m_TurnSpeed = value;
				}
			}

			protected override void FollowTarget(float deltaTime)
			{
				if (!(deltaTime > 0f) || m_Target == null)
				{
					return;
				}
				Vector3 forward = m_Target.forward;
				Vector3 up = m_Target.up;
				if (m_FollowVelocity && Application.isPlaying)
				{
					if (targetRigidbody.velocity.magnitude > m_TargetVelocityLowerLimit)
					{
						forward = targetRigidbody.velocity.normalized;
						up = Vector3.up;
					}
					else
					{
						up = Vector3.up;
					}
					m_CurrentTurnAmount = Mathf.SmoothDamp(m_CurrentTurnAmount, 1f, ref m_TurnSpeedVelocityChange, m_SmoothTurnTime);
				}
				else
				{
					float num = Mathf.Atan2(forward.x, forward.z) * 57.29578f;
					if (m_SpinTurnLimit > 0f)
					{
						float value = Mathf.Abs(Mathf.DeltaAngle(m_LastFlatAngle, num)) / deltaTime;
						float num2 = Mathf.InverseLerp(m_SpinTurnLimit, m_SpinTurnLimit * 0.75f, value);
						float smoothTime = ((m_CurrentTurnAmount > num2) ? 0.1f : 1f);
						if (Application.isPlaying)
						{
							m_CurrentTurnAmount = Mathf.SmoothDamp(m_CurrentTurnAmount, num2, ref m_TurnSpeedVelocityChange, smoothTime);
						}
						else
						{
							m_CurrentTurnAmount = num2;
						}
					}
					else
					{
						m_CurrentTurnAmount = 1f;
					}
					m_LastFlatAngle = num;
				}
				base.transform.position = Vector3.Lerp(base.transform.position, m_Target.position, deltaTime * m_MoveSpeed);
				if (!m_FollowTilt)
				{
					forward.y = 0f;
					if (forward.sqrMagnitude < float.Epsilon)
					{
						forward = base.transform.forward;
					}
				}
				Quaternion b = Quaternion.LookRotation(forward, m_RollUp);
				m_RollUp = ((m_RollSpeed > 0f) ? Vector3.Slerp(m_RollUp, up, m_RollSpeed * deltaTime) : Vector3.up);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, m_TurnSpeed * m_CurrentTurnAmount * deltaTime);
			}
		}
		public class FreeLookCam : PivotBasedCameraRig
		{
			[SerializeField]
			private float m_MoveSpeed = 1f;

			[Range(0f, 10f)]
			[SerializeField]
			private float m_TurnSpeed = 1.5f;

			[SerializeField]
			private float m_TurnSmoothing;

			[SerializeField]
			private float m_TiltMax = 75f;

			[SerializeField]
			private float m_TiltMin = 45f;

			[SerializeField]
			private bool m_LockCursor;

			[SerializeField]
			private bool m_VerticalAutoReturn;

			private float m_LookAngle;

			private float m_TiltAngle;

			private const float k_LookDistance = 100f;

			private Vector3 m_PivotEulers;

			private Quaternion m_PivotTargetRot;

			private Quaternion m_TransformTargetRot;

			protected override void Awake()
			{
				base.Awake();
				Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
				Cursor.visible = !m_LockCursor;
				m_PivotEulers = m_Pivot.rotation.eulerAngles;
				m_PivotTargetRot = m_Pivot.transform.localRotation;
				m_TransformTargetRot = base.transform.localRotation;
			}

			protected void Update()
			{
				HandleRotationMovement();
				if (m_LockCursor && Input.GetMouseButtonUp(0))
				{
					Cursor.lockState = (m_LockCursor ? CursorLockMode.Locked : CursorLockMode.None);
					Cursor.visible = !m_LockCursor;
				}
			}

			private void OnDisable()
			{
				Cursor.lockState = CursorLockMode.None;
				Cursor.visible = true;
			}

			protected override void FollowTarget(float deltaTime)
			{
				if (!(m_Target == null))
				{
					base.transform.position = Vector3.Lerp(base.transform.position, m_Target.position, deltaTime * m_MoveSpeed);
				}
			}

			private void HandleRotationMovement()
			{
				if (!(Time.timeScale < float.Epsilon))
				{
					float axis = CrossPlatformInputManager.GetAxis("Mouse X");
					float axis2 = CrossPlatformInputManager.GetAxis("Mouse Y");
					m_LookAngle += axis * m_TurnSpeed;
					m_TransformTargetRot = Quaternion.Euler(0f, m_LookAngle, 0f);
					if (m_VerticalAutoReturn)
					{
						m_TiltAngle = ((axis2 > 0f) ? Mathf.Lerp(0f, 0f - m_TiltMin, axis2) : Mathf.Lerp(0f, m_TiltMax, 0f - axis2));
					}
					else
					{
						m_TiltAngle -= axis2 * m_TurnSpeed;
						m_TiltAngle = Mathf.Clamp(m_TiltAngle, 0f - m_TiltMin, m_TiltMax);
					}
					m_PivotTargetRot = Quaternion.Euler(m_TiltAngle, m_PivotEulers.y, m_PivotEulers.z);
					if (m_TurnSmoothing > 0f)
					{
						m_Pivot.localRotation = Quaternion.Slerp(m_Pivot.localRotation, m_PivotTargetRot, m_TurnSmoothing * Time.deltaTime);
						base.transform.localRotation = Quaternion.Slerp(base.transform.localRotation, m_TransformTargetRot, m_TurnSmoothing * Time.deltaTime);
					}
					else
					{
						m_Pivot.localRotation = m_PivotTargetRot;
						base.transform.localRotation = m_TransformTargetRot;
					}
				}
			}
		}
		public class HandHeldCam : LookatTarget
		{
			[SerializeField]
			private float m_SwaySpeed = 0.5f;

			[SerializeField]
			private float m_BaseSwayAmount = 0.5f;

			[SerializeField]
			private float m_TrackingSwayAmount = 0.5f;

			[Range(-1f, 1f)]
			[SerializeField]
			private float m_TrackingBias;

			protected override void FollowTarget(float deltaTime)
			{
				base.FollowTarget(deltaTime);
				float num = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed) - 0.5f;
				float num2 = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed + 100f) - 0.5f;
				num *= m_BaseSwayAmount;
				num2 *= m_BaseSwayAmount;
				float num3 = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed) - 0.5f + m_TrackingBias;
				float num4 = Mathf.PerlinNoise(0f, Time.time * m_SwaySpeed + 100f) - 0.5f + m_TrackingBias;
				num3 *= (0f - m_TrackingSwayAmount) * m_FollowVelocity.x;
				num4 *= m_TrackingSwayAmount * m_FollowVelocity.y;
				base.transform.Rotate(num + num3, num2 + num4, 0f);
			}
		}
		public class LookatTarget : AbstractTargetFollower
		{
			[SerializeField]
			private Vector2 m_RotationRange;

			[SerializeField]
			private float m_FollowSpeed = 1f;

			private Vector3 m_FollowAngles;

			private Quaternion m_OriginalRotation;

			protected Vector3 m_FollowVelocity;

			protected override void Start()
			{
				base.Start();
				m_OriginalRotation = base.transform.localRotation;
			}

			protected override void FollowTarget(float deltaTime)
			{
				base.transform.localRotation = m_OriginalRotation;
				Vector3 vector = base.transform.InverseTransformPoint(m_Target.position);
				float value = Mathf.Atan2(vector.x, vector.z) * 57.29578f;
				value = Mathf.Clamp(value, (0f - m_RotationRange.y) * 0.5f, m_RotationRange.y * 0.5f);
				base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f, value, 0f);
				vector = base.transform.InverseTransformPoint(m_Target.position);
				float value2 = Mathf.Atan2(vector.y, vector.z) * 57.29578f;
				value2 = Mathf.Clamp(value2, (0f - m_RotationRange.x) * 0.5f, m_RotationRange.x * 0.5f);
				m_FollowAngles = Vector3.SmoothDamp(target: new Vector3(m_FollowAngles.x + Mathf.DeltaAngle(m_FollowAngles.x, value2), m_FollowAngles.y + Mathf.DeltaAngle(m_FollowAngles.y, value)), current: m_FollowAngles, currentVelocity: ref m_FollowVelocity, smoothTime: m_FollowSpeed);
				base.transform.localRotation = m_OriginalRotation * Quaternion.Euler(0f - m_FollowAngles.x, m_FollowAngles.y, 0f);
			}
		}
		public abstract class PivotBasedCameraRig : AbstractTargetFollower
		{
			protected Transform m_Cam;

			protected Transform m_Pivot;

			protected Vector3 m_LastTargetPosition;

			protected virtual void Awake()
			{
				m_Cam = GetComponentInChildren<Camera>().transform;
				m_Pivot = m_Cam.parent;
			}
		}
		public class ProtectCameraFromWallClip : MonoBehaviour
		{
			public class RayHitComparer : IComparer
			{
				public int Compare(object x, object y)
				{
					return ((RaycastHit)x).distance.CompareTo(((RaycastHit)y).distance);
				}
			}

			public float clipMoveTime = 0.05f;

			public float returnTime = 0.4f;

			public float sphereCastRadius = 0.1f;

			public bool visualiseInEditor;

			public float closestDistance = 0.5f;

			public string dontClipTag = "Player";

			private Transform m_Cam;

			private Transform m_Pivot;

			private float m_OriginalDist;

			private float m_MoveVelocity;

			private float m_CurrentDist;

			private Ray m_Ray;

			private RaycastHit[] m_Hits;

			private RayHitComparer m_RayHitComparer;

			public bool protecting { get; private set; }

			private void Start()
			{
				m_Cam = GetComponentInChildren<Camera>().transform;
				m_Pivot = m_Cam.parent;
				m_OriginalDist = m_Cam.localPosition.magnitude;
				m_CurrentDist = m_OriginalDist;
				m_RayHitComparer = new RayHitComparer();
			}

			private void LateUpdate()
			{
				float num = m_OriginalDist;
				m_Ray.origin = m_Pivot.position + m_Pivot.forward * sphereCastRadius;
				m_Ray.direction = -m_Pivot.forward;
				Collider[] array = Physics.OverlapSphere(m_Ray.origin, sphereCastRadius);
				bool flag = false;
				bool flag2 = false;
				for (int i = 0; i < array.Length; i++)
				{
					if (!array[i].isTrigger && (!(array[i].attachedRigidbody != null) || !array[i].attachedRigidbody.CompareTag(dontClipTag)))
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					m_Ray.origin += m_Pivot.forward * sphereCastRadius;
					m_Hits = Physics.RaycastAll(m_Ray, m_OriginalDist - sphereCastRadius);
				}
				else
				{
					m_Hits = Physics.SphereCastAll(m_Ray, sphereCastRadius, m_OriginalDist + sphereCastRadius);
				}
				Array.Sort(m_Hits, m_RayHitComparer);
				float num2 = float.PositiveInfinity;
				for (int j = 0; j < m_Hits.Length; j++)
				{
					if (m_Hits[j].distance < num2 && !m_Hits[j].collider.isTrigger && (!(m_Hits[j].collider.attachedRigidbody != null) || !m_Hits[j].collider.attachedRigidbody.CompareTag(dontClipTag)))
					{
						num2 = m_Hits[j].distance;
						num = 0f - m_Pivot.InverseTransformPoint(m_Hits[j].point).z;
						flag2 = true;
					}
				}
				if (flag2)
				{
					UnityEngine.Debug.DrawRay(m_Ray.origin, -m_Pivot.forward * (num + sphereCastRadius), Color.red);
				}
				protecting = flag2;
				m_CurrentDist = Mathf.SmoothDamp(m_CurrentDist, num, ref m_MoveVelocity, (m_CurrentDist > num) ? clipMoveTime : returnTime);
				m_CurrentDist = Mathf.Clamp(m_CurrentDist, closestDistance, m_OriginalDist);
				m_Cam.localPosition = -Vector3.forward * m_CurrentDist;
			}
		}
		public class TargetFieldOfView : AbstractTargetFollower
		{
			[SerializeField]
			private float m_FovAdjustTime = 1f;

			[SerializeField]
			private float m_ZoomAmountMultiplier = 2f;

			[SerializeField]
			private bool m_IncludeEffectsInSize;

			private float m_BoundSize;

			private float m_FovAdjustVelocity;

			private Camera m_Cam;

			private Transform m_LastTarget;

			protected override void Start()
			{
				base.Start();
				m_BoundSize = MaxBoundsExtent(m_Target, m_IncludeEffectsInSize);
				m_Cam = GetComponentInChildren<Camera>();
			}

			protected override void FollowTarget(float deltaTime)
			{
				float magnitude = (m_Target.position - base.transform.position).magnitude;
				float target = Mathf.Atan2(m_BoundSize, magnitude) * 57.29578f * m_ZoomAmountMultiplier;
				m_Cam.fieldOfView = Mathf.SmoothDamp(m_Cam.fieldOfView, target, ref m_FovAdjustVelocity, m_FovAdjustTime);
			}

			public override void SetTarget(Transform newTransform)
			{
				base.SetTarget(newTransform);
				m_BoundSize = MaxBoundsExtent(newTransform, m_IncludeEffectsInSize);
			}

			public static float MaxBoundsExtent(Transform obj, bool includeEffects)
			{
				Renderer[] componentsInChildren = obj.GetComponentsInChildren<Renderer>();
				Bounds bounds = default(Bounds);
				bool flag = false;
				Renderer[] array = componentsInChildren;
				foreach (Renderer renderer in array)
				{
					if (!(renderer is TrailRenderer) && !(renderer is ParticleSystemRenderer))
					{
						if (!flag)
						{
							flag = true;
							bounds = renderer.bounds;
						}
						else
						{
							bounds.Encapsulate(renderer.bounds);
						}
					}
				}
				return Mathf.Max(bounds.extents.x, bounds.extents.y, bounds.extents.z);
			}
		}
	}
	namespace UnityStandardAssets.CrossPlatformInput
	{
		[RequireComponent(typeof(Image))]
		public class TouchPad : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
		{
			public enum AxisOption
			{
				Both,
				OnlyHorizontal,
				OnlyVertical
			}

			public enum ControlStyle
			{
				Absolute,
				Relative,
				Swipe
			}

			public AxisOption axesToUse;

			public ControlStyle controlStyle;

			public string horizontalAxisName = "Horizontal";

			public string verticalAxisName = "Vertical";

			public float Xsensitivity = 1f;

			public float Ysensitivity = 1f;

			private Vector3 m_StartPos;

			private Vector2 m_PreviousDelta;

			private Vector3 m_JoytickOutput;

			private bool m_UseX;

			private bool m_UseY;

			private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

			private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

			private bool m_Dragging;

			private int m_Id = -1;

			private Vector2 m_PreviousTouchPos;

			private Vector3 m_Center;

			private Image m_Image;

			private void OnEnable()
			{
				CreateVirtualAxes();
			}

			private void Start()
			{
				m_Image = GetComponent<Image>();
				m_Center = m_Image.transform.position;
			}

			private void CreateVirtualAxes()
			{
				m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
				m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
				if (m_UseX)
				{
					m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
				}
			}

			private void UpdateVirtualAxes(Vector3 value)
			{
				value = value.normalized;
				if (m_UseX)
				{
					m_HorizontalVirtualAxis.Update(value.x);
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis.Update(value.y);
				}
			}

			public void OnPointerDown(PointerEventData data)
			{
				m_Dragging = true;
				m_Id = data.pointerId;
				if (controlStyle != 0)
				{
					m_Center = data.position;
				}
			}

			private void Update()
			{
				if (m_Dragging && Input.touchCount >= m_Id + 1 && m_Id != -1)
				{
					if (controlStyle == ControlStyle.Swipe)
					{
						m_Center = m_PreviousTouchPos;
						m_PreviousTouchPos = Input.touches[m_Id].position;
					}
					Vector2 normalized = new Vector2(Input.touches[m_Id].position.x - m_Center.x, Input.touches[m_Id].position.y - m_Center.y).normalized;
					normalized.x *= Xsensitivity;
					normalized.y *= Ysensitivity;
					UpdateVirtualAxes(new Vector3(normalized.x, normalized.y, 0f));
				}
			}

			public void OnPointerUp(PointerEventData data)
			{
				m_Dragging = false;
				m_Id = -1;
				UpdateVirtualAxes(Vector3.zero);
			}

			private void OnDisable()
			{
				if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
				{
					CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
				}
				if (CrossPlatformInputManager.AxisExists(verticalAxisName))
				{
					CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
				}
			}
		}
		public class AxisTouchButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
		{
			public string axisName = "Horizontal";

			public float axisValue = 1f;

			public float responseSpeed = 3f;

			public float returnToCentreSpeed = 3f;

			private AxisTouchButton m_PairedWith;

			private CrossPlatformInputManager.VirtualAxis m_Axis;

			private void OnEnable()
			{
				if (!CrossPlatformInputManager.AxisExists(axisName))
				{
					m_Axis = new CrossPlatformInputManager.VirtualAxis(axisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_Axis);
				}
				else
				{
					m_Axis = CrossPlatformInputManager.VirtualAxisReference(axisName);
				}
				FindPairedButton();
			}

			private void FindPairedButton()
			{
				if (!(UnityEngine.Object.FindObjectsOfType(typeof(AxisTouchButton)) is AxisTouchButton[] array))
				{
					return;
				}
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].axisName == axisName && array[i] != this)
					{
						m_PairedWith = array[i];
					}
				}
			}

			private void OnDisable()
			{
				m_Axis.Remove();
			}

			public void OnPointerDown(PointerEventData data)
			{
				if (m_PairedWith == null)
				{
					FindPairedButton();
				}
				m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, axisValue, responseSpeed * Time.deltaTime));
			}

			public void OnPointerUp(PointerEventData data)
			{
				m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, 0f, responseSpeed * Time.deltaTime));
			}
		}
		public class ButtonHandler : MonoBehaviour
		{
			public string Name;

			private void OnEnable()
			{
			}

			public void SetDownState()
			{
				CrossPlatformInputManager.SetButtonDown(Name);
			}

			public void SetUpState()
			{
				CrossPlatformInputManager.SetButtonUp(Name);
			}

			public void SetAxisPositiveState()
			{
				CrossPlatformInputManager.SetAxisPositive(Name);
			}

			public void SetAxisNeutralState()
			{
				CrossPlatformInputManager.SetAxisZero(Name);
			}

			public void SetAxisNegativeState()
			{
				CrossPlatformInputManager.SetAxisNegative(Name);
			}

			public void Update()
			{
			}
		}
		public static class CrossPlatformInputManager
		{
			public enum ActiveInputMethod
			{
				Hardware,
				Touch
			}

			public class VirtualAxis
			{
				private float m_Value;

				public string name { get; private set; }

				public bool matchWithInputManager { get; private set; }

				public float GetValue => m_Value;

				public float GetValueRaw => m_Value;

				public VirtualAxis(string name)
					: this(name, matchToInputSettings: true)
				{
				}

				public VirtualAxis(string name, bool matchToInputSettings)
				{
					this.name = name;
					matchWithInputManager = matchToInputSettings;
				}

				public void Remove()
				{
					UnRegisterVirtualAxis(name);
				}

				public void Update(float value)
				{
					m_Value = value;
				}
			}

			public class VirtualButton
			{
				private int m_LastPressedFrame = -5;

				private int m_ReleasedFrame = -5;

				private bool m_Pressed;

				public string name { get; private set; }

				public bool matchWithInputManager { get; private set; }

				public bool GetButton => m_Pressed;

				public bool GetButtonDown => m_LastPressedFrame - Time.frameCount == -1;

				public bool GetButtonUp => m_ReleasedFrame == Time.frameCount - 1;

				public VirtualButton(string name)
					: this(name, matchToInputSettings: true)
				{
				}

				public VirtualButton(string name, bool matchToInputSettings)
				{
					this.name = name;
					matchWithInputManager = matchToInputSettings;
				}

				public void Pressed()
				{
					if (!m_Pressed)
					{
						m_Pressed = true;
						m_LastPressedFrame = Time.frameCount;
					}
				}

				public void Released()
				{
					m_Pressed = false;
					m_ReleasedFrame = Time.frameCount;
				}

				public void Remove()
				{
					UnRegisterVirtualButton(name);
				}
			}

			private static VirtualInput activeInput;

			private static VirtualInput s_TouchInput;

			private static VirtualInput s_HardwareInput;

			public static Vector3 mousePosition => activeInput.MousePosition();

			static CrossPlatformInputManager()
			{
				s_TouchInput = new MobileInput();
				s_HardwareInput = new StandaloneInput();
				activeInput = s_TouchInput;
			}

			public static void SwitchActiveInputMethod(ActiveInputMethod activeInputMethod)
			{
				switch (activeInputMethod)
				{
				case ActiveInputMethod.Hardware:
					activeInput = s_HardwareInput;
					break;
				case ActiveInputMethod.Touch:
					activeInput = s_TouchInput;
					break;
				}
			}

			public static bool AxisExists(string name)
			{
				return activeInput.AxisExists(name);
			}

			public static bool ButtonExists(string name)
			{
				return activeInput.ButtonExists(name);
			}

			public static void RegisterVirtualAxis(VirtualAxis axis)
			{
				activeInput.RegisterVirtualAxis(axis);
			}

			public static void RegisterVirtualButton(VirtualButton button)
			{
				activeInput.RegisterVirtualButton(button);
			}

			public static void UnRegisterVirtualAxis(string name)
			{
				if (name == null)
				{
					throw new ArgumentNullException("name");
				}
				activeInput.UnRegisterVirtualAxis(name);
			}

			public static void UnRegisterVirtualButton(string name)
			{
				activeInput.UnRegisterVirtualButton(name);
			}

			public static VirtualAxis VirtualAxisReference(string name)
			{
				return activeInput.VirtualAxisReference(name);
			}

			public static float GetAxis(string name)
			{
				return GetAxis(name, raw: false);
			}

			public static float GetAxisRaw(string name)
			{
				return GetAxis(name, raw: true);
			}

			private static float GetAxis(string name, bool raw)
			{
				return activeInput.GetAxis(name, raw);
			}

			public static bool GetButton(string name)
			{
				return activeInput.GetButton(name);
			}

			public static bool GetButtonDown(string name)
			{
				return activeInput.GetButtonDown(name);
			}

			public static bool GetButtonUp(string name)
			{
				return activeInput.GetButtonUp(name);
			}

			public static void SetButtonDown(string name)
			{
				activeInput.SetButtonDown(name);
			}

			public static void SetButtonUp(string name)
			{
				activeInput.SetButtonUp(name);
			}

			public static void SetAxisPositive(string name)
			{
				activeInput.SetAxisPositive(name);
			}

			public static void SetAxisNegative(string name)
			{
				activeInput.SetAxisNegative(name);
			}

			public static void SetAxisZero(string name)
			{
				activeInput.SetAxisZero(name);
			}

			public static void SetAxis(string name, float value)
			{
				activeInput.SetAxis(name, value);
			}

			public static void SetVirtualMousePositionX(float f)
			{
				activeInput.SetVirtualMousePositionX(f);
			}

			public static void SetVirtualMousePositionY(float f)
			{
				activeInput.SetVirtualMousePositionY(f);
			}

			public static void SetVirtualMousePositionZ(float f)
			{
				activeInput.SetVirtualMousePositionZ(f);
			}
		}
		public class InputAxisScrollbar : MonoBehaviour
		{
			public string axis;

			private void Update()
			{
			}

			public void HandleInput(float value)
			{
				CrossPlatformInputManager.SetAxis(axis, value * 2f - 1f);
			}
		}
		public class Joystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
		{
			public enum AxisOption
			{
				Both,
				OnlyHorizontal,
				OnlyVertical
			}

			public int MovementRange = 100;

			public AxisOption axesToUse;

			public string horizontalAxisName = "Horizontal";

			public string verticalAxisName = "Vertical";

			private Vector3 m_StartPos;

			private bool m_UseX;

			private bool m_UseY;

			private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

			private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

			private void OnEnable()
			{
				CreateVirtualAxes();
			}

			private void Start()
			{
				m_StartPos = base.transform.position;
			}

			private void UpdateVirtualAxes(Vector3 value)
			{
				Vector3 vector = m_StartPos - value;
				vector.y = 0f - vector.y;
				vector /= (float)MovementRange;
				if (m_UseX)
				{
					m_HorizontalVirtualAxis.Update(0f - vector.x);
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis.Update(vector.y);
				}
			}

			private void CreateVirtualAxes()
			{
				m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
				m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
				if (m_UseX)
				{
					m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
				}
			}

			public void OnDrag(PointerEventData data)
			{
				Vector3 zero = Vector3.zero;
				if (m_UseX)
				{
					int value = (int)(data.position.x - m_StartPos.x);
					value = Mathf.Clamp(value, -MovementRange, MovementRange);
					zero.x = value;
				}
				if (m_UseY)
				{
					int value2 = (int)(data.position.y - m_StartPos.y);
					value2 = Mathf.Clamp(value2, -MovementRange, MovementRange);
					zero.y = value2;
				}
				base.transform.position = new Vector3(m_StartPos.x + zero.x, m_StartPos.y + zero.y, m_StartPos.z + zero.z);
				UpdateVirtualAxes(base.transform.position);
			}

			public void OnPointerUp(PointerEventData data)
			{
				base.transform.position = m_StartPos;
				UpdateVirtualAxes(m_StartPos);
			}

			public void OnPointerDown(PointerEventData data)
			{
			}

			private void OnDisable()
			{
				if (m_UseX)
				{
					m_HorizontalVirtualAxis.Remove();
				}
				if (m_UseY)
				{
					m_VerticalVirtualAxis.Remove();
				}
			}
		}
		public class TiltInput : MonoBehaviour
		{
			public enum AxisOptions
			{
				ForwardAxis,
				SidewaysAxis
			}

			[Serializable]
			public class AxisMapping
			{
				public enum MappingType
				{
					NamedAxis,
					MousePositionX,
					MousePositionY,
					MousePositionZ
				}

				public MappingType type;

				public string axisName;
			}

			public AxisMapping mapping;

			public AxisOptions tiltAroundAxis;

			public float fullTiltAngle = 25f;

			public float centreAngleOffset;

			private CrossPlatformInputManager.VirtualAxis m_SteerAxis;

			private void OnEnable()
			{
				if (mapping.type == AxisMapping.MappingType.NamedAxis)
				{
					m_SteerAxis = new CrossPlatformInputManager.VirtualAxis(mapping.axisName);
					CrossPlatformInputManager.RegisterVirtualAxis(m_SteerAxis);
				}
			}

			private void Update()
			{
				float value = 0f;
				if (Input.acceleration != Vector3.zero)
				{
					switch (tiltAroundAxis)
					{
					case AxisOptions.ForwardAxis:
						value = Mathf.Atan2(Input.acceleration.x, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
						break;
					case AxisOptions.SidewaysAxis:
						value = Mathf.Atan2(Input.acceleration.z, 0f - Input.acceleration.y) * 57.29578f + centreAngleOffset;
						break;
					}
				}
				float num = Mathf.InverseLerp(0f - fullTiltAngle, fullTiltAngle, value) * 2f - 1f;
				switch (mapping.type)
				{
				case AxisMapping.MappingType.NamedAxis:
					m_SteerAxis.Update(num);
					break;
				case AxisMapping.MappingType.MousePositionX:
					CrossPlatformInputManager.SetVirtualMousePositionX(num * (float)Screen.width);
					break;
				case AxisMapping.MappingType.MousePositionY:
					CrossPlatformInputManager.SetVirtualMousePositionY(num * (float)Screen.width);
					break;
				case AxisMapping.MappingType.MousePositionZ:
					CrossPlatformInputManager.SetVirtualMousePositionZ(num * (float)Screen.width);
					break;
				}
			}

			private void OnDisable()
			{
				m_SteerAxis.Remove();
			}
		}
		public abstract class VirtualInput
		{
			protected Dictionary<string, CrossPlatformInputManager.VirtualAxis> m_VirtualAxes = new Dictionary<string, CrossPlatformInputManager.VirtualAxis>();

			protected Dictionary<string, CrossPlatformInputManager.VirtualButton> m_VirtualButtons = new Dictionary<string, CrossPlatformInputManager.VirtualButton>();

			protected List<string> m_AlwaysUseVirtual = new List<string>();

			public Vector3 virtualMousePosition { get; private set; }

			public bool AxisExists(string name)
			{
				return m_VirtualAxes.ContainsKey(name);
			}

			public bool ButtonExists(string name)
			{
				return m_VirtualButtons.ContainsKey(name);
			}

			public void RegisterVirtualAxis(CrossPlatformInputManager.VirtualAxis axis)
			{
				if (m_VirtualAxes.ContainsKey(axis.name))
				{
					UnityEngine.Debug.LogError("There is already a virtual axis named " + axis.name + " registered.");
					return;
				}
				m_VirtualAxes.Add(axis.name, axis);
				if (!axis.matchWithInputManager)
				{
					m_AlwaysUseVirtual.Add(axis.name);
				}
			}

			public void RegisterVirtualButton(CrossPlatformInputManager.VirtualButton button)
			{
				if (m_VirtualButtons.ContainsKey(button.name))
				{
					UnityEngine.Debug.LogError("There is already a virtual button named " + button.name + " registered.");
					return;
				}
				m_VirtualButtons.Add(button.name, button);
				if (!button.matchWithInputManager)
				{
					m_AlwaysUseVirtual.Add(button.name);
				}
			}

			public void UnRegisterVirtualAxis(string name)
			{
				if (m_VirtualAxes.ContainsKey(name))
				{
					m_VirtualAxes.Remove(name);
				}
			}

			public void UnRegisterVirtualButton(string name)
			{
				if (m_VirtualButtons.ContainsKey(name))
				{
					m_VirtualButtons.Remove(name);
				}
			}

			public CrossPlatformInputManager.VirtualAxis VirtualAxisReference(string name)
			{
				if (!m_VirtualAxes.ContainsKey(name))
				{
					return null;
				}
				return m_VirtualAxes[name];
			}

			public void SetVirtualMousePositionX(float f)
			{
				virtualMousePosition = new Vector3(f, virtualMousePosition.y, virtualMousePosition.z);
			}

			public void SetVirtualMousePositionY(float f)
			{
				virtualMousePosition = new Vector3(virtualMousePosition.x, f, virtualMousePosition.z);
			}

			public void SetVirtualMousePositionZ(float f)
			{
				virtualMousePosition = new Vector3(virtualMousePosition.x, virtualMousePosition.y, f);
			}

			public abstract float GetAxis(string name, bool raw);

			public abstract bool GetButton(string name);

			public abstract bool GetButtonDown(string name);

			public abstract bool GetButtonUp(string name);

			public abstract void SetButtonDown(string name);

			public abstract void SetButtonUp(string name);

			public abstract void SetAxisPositive(string name);

			public abstract void SetAxisNegative(string name);

			public abstract void SetAxisZero(string name);

			public abstract void SetAxis(string name, float value);

			public abstract Vector3 MousePosition();
		}
	}
	namespace UnityStandardAssets.CrossPlatformInput.PlatformSpecific
	{
		public class MobileInput : VirtualInput
		{
			private void AddButton(string name)
			{
				CrossPlatformInputManager.RegisterVirtualButton(new CrossPlatformInputManager.VirtualButton(name));
			}

			private void AddAxes(string name)
			{
				CrossPlatformInputManager.RegisterVirtualAxis(new CrossPlatformInputManager.VirtualAxis(name));
			}

			public override float GetAxis(string name, bool raw)
			{
				if (!m_VirtualAxes.ContainsKey(name))
				{
					AddAxes(name);
				}
				return m_VirtualAxes[name].GetValue;
			}

			public override void SetButtonDown(string name)
			{
				if (!m_VirtualButtons.ContainsKey(name))
				{
					AddButton(name);
				}
				m_VirtualButtons[name].Pressed();
			}

			public override void SetButtonUp(string name)
			{
				if (!m_VirtualButtons.ContainsKey(name))
				{
					AddButton(name);
				}
				m_VirtualButtons[name].Released();
			}

			public override void SetAxisPositive(string name)
			{
				if (!m_VirtualAxes.ContainsKey(name))
				{
					AddAxes(name);
				}
				m_VirtualAxes[name].Update(1f);
			}

			public override void SetAxisNegative(string name)
			{
				if (!m_VirtualAxes.ContainsKey(name))
				{
					AddAxes(name);
				}
				m_VirtualAxes[name].Update(-1f);
			}

			public override void SetAxisZero(string name)
			{
				if (!m_VirtualAxes.ContainsKey(name))
				{
					AddAxes(name);
				}
				m_VirtualAxes[name].Update(0f);
			}

			public override void SetAxis(string name, float value)
			{
				if (!m_VirtualAxes.ContainsKey(name))
				{
					AddAxes(name);
				}
				m_VirtualAxes[name].Update(value);
			}

			public override bool GetButtonDown(string name)
			{
				if (m_VirtualButtons.ContainsKey(name))
				{
					return m_VirtualButtons[name].GetButtonDown;
				}
				AddButton(name);
				return m_VirtualButtons[name].GetButtonDown;
			}

			public override bool GetButtonUp(string name)
			{
				if (m_VirtualButtons.ContainsKey(name))
				{
					return m_VirtualButtons[name].GetButtonUp;
				}
				AddButton(name);
				return m_VirtualButtons[name].GetButtonUp;
			}

			public override bool GetButton(string name)
			{
				if (m_VirtualButtons.ContainsKey(name))
				{
					return m_VirtualButtons[name].GetButton;
				}
				AddButton(name);
				return m_VirtualButtons[name].GetButton;
			}

			public override Vector3 MousePosition()
			{
				return base.virtualMousePosition;
			}
		}
		public class StandaloneInput : VirtualInput
		{
			public override float GetAxis(string name, bool raw)
			{
				if (!raw)
				{
					return Input.GetAxis(name);
				}
				return Input.GetAxisRaw(name);
			}

			public override bool GetButton(string name)
			{
				return Input.GetButton(name);
			}

			public override bool GetButtonDown(string name)
			{
				return Input.GetButtonDown(name);
			}

			public override bool GetButtonUp(string name)
			{
				return Input.GetButtonUp(name);
			}

			public override void SetButtonDown(string name)
			{
				throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
			}

			public override void SetButtonUp(string name)
			{
				throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
			}

			public override void SetAxisPositive(string name)
			{
				throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
			}

			public override void SetAxisNegative(string name)
			{
				throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
			}

			public override void SetAxisZero(string name)
			{
				throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
			}

			public override void SetAxis(string name, float value)
			{
				throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
			}

			public override Vector3 MousePosition()
			{
				return Input.mousePosition;
			}
		}
	}
	namespace UnityStandardAssets.Vehicles.Ball
	{
		public class Ball : MonoBehaviour
		{
			[SerializeField]
			private float m_MovePower = 5f;

			[SerializeField]
			private bool m_UseTorque = true;

			[SerializeField]
			private float m_MaxAngularVelocity = 25f;

			[SerializeField]
			private float m_JumpPower = 2f;

			private const float k_GroundRayLength = 1f;

			private Rigidbody m_Rigidbody;

			private void Start()
			{
				m_Rigidbody = GetComponent<Rigidbody>();
				GetComponent<Rigidbody>().maxAngularVelocity = m_MaxAngularVelocity;
			}

			public void Move(Vector3 moveDirection, bool jump)
			{
				if (m_UseTorque)
				{
					m_Rigidbody.AddTorque(new Vector3(moveDirection.z, 0f, 0f - moveDirection.x) * m_MovePower);
				}
				else
				{
					m_Rigidbody.AddForce(moveDirection * m_MovePower);
				}
				if (Physics.Raycast(base.transform.position, -Vector3.up, 1f) && jump)
				{
					m_Rigidbody.AddForce(Vector3.up * m_JumpPower, ForceMode.Impulse);
				}
			}
		}
		public class BallUserControl : MonoBehaviour
		{
			private Ball ball;

			private Vector3 move;

			private Transform cam;

			private Vector3 camForward;

			private bool jump;

			private void Awake()
			{
				ball = GetComponent<Ball>();
				if (Camera.main != null)
				{
					cam = Camera.main.transform;
				}
				else
				{
					UnityEngine.Debug.LogWarning("Warning: no main camera found. Ball needs a Camera tagged \"MainCamera\", for camera-relative controls.");
				}
			}

			private void Update()
			{
				float axis = CrossPlatformInputManager.GetAxis("Horizontal");
				float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
				jump = CrossPlatformInputManager.GetButton("Jump");
				if (cam != null)
				{
					camForward = Vector3.Scale(cam.forward, new Vector3(1f, 0f, 1f)).normalized;
					move = (axis2 * camForward + axis * cam.right).normalized;
				}
				else
				{
					move = (axis2 * Vector3.forward + axis * Vector3.right).normalized;
				}
			}

			private void FixedUpdate()
			{
				ball.Move(move, jump);
				jump = false;
			}
		}
	}
	namespace UnityStandardAssets.Vehicles.Aeroplane
	{
		[RequireComponent(typeof(Rigidbody))]
		public class AeroplaneController : MonoBehaviour
		{
			[Tooltip("The maximum output of the engine.")]
			[SerializeField]
			private float m_MaxEnginePower = 40f;

			[Tooltip("The amount of lift generated by the aeroplane moving forwards.")]
			[SerializeField]
			private float m_Lift = 0.002f;

			[Tooltip("The speed at which lift is no longer applied.")]
			[SerializeField]
			private float m_ZeroLiftSpeed = 300f;

			[Tooltip("The strength of effect for roll input.")]
			[SerializeField]
			private float m_RollEffect = 1f;

			[Tooltip("The strength of effect for pitch input.")]
			[SerializeField]
			private float m_PitchEffect = 1f;

			[Tooltip("The strength of effect for yaw input.")]
			[SerializeField]
			private float m_YawEffect = 0.2f;

			[Tooltip("The amount of turn from doing a banked turn.")]
			[SerializeField]
			private float m_BankedTurnEffect = 0.5f;

			[Tooltip("How much aerodynamics affect the speed of the aeroplane.")]
			[SerializeField]
			private float m_AerodynamicEffect = 0.02f;

			[Tooltip("How much the aeroplane automatically pitches when in a banked turn.")]
			[SerializeField]
			private float m_AutoTurnPitch = 0.5f;

			[Tooltip("How much the aeroplane tries to level when not rolling.")]
			[SerializeField]
			private float m_AutoRollLevel = 0.2f;

			[Tooltip("How much the aeroplane tries to level when not pitching.")]
			[SerializeField]
			private float m_AutoPitchLevel = 0.2f;

			[Tooltip("How much the air brakes effect the drag.")]
			[SerializeField]
			private float m_AirBrakesEffect = 3f;

			[Tooltip("The speed with which the throttle changes.")]
			[SerializeField]
			private float m_ThrottleChangeSpeed = 0.3f;

			[Tooltip("How much drag should increase with speed.")]
			[SerializeField]
			private float m_DragIncreaseFactor = 0.001f;

			[Tooltip("Maximum speed possible to achieve with this ariplane.")]
			[SerializeField]
			private float m_MaxSpeed = 10f;

			public Animator animator;

			private bool turnAround;

			public bool adjustHanlingToSpeed;

			private float currentSpeedMod = 1f;

			private float initialMaxSpeed;

			private float initialEnginePower;

			private float initialYaw;

			private float initialPitch;

			private float initialRoll;

			private float speedMod = 1f;

			private float modTime;

			private bool modInvert;

			private Bullet.Effect currentEffect;

			[HideInInspector]
			public bool disabled;

			public VRBirdController vrController;

			public VRBirdController picoController;

			private float m_OriginalDrag;

			private float m_OriginalAngularDrag;

			private float m_AeroFactor;

			private bool m_Immobilized;

			private float m_BankedTurnAmount;

			private Rigidbody m_Rigidbody;

			private WheelCollider[] m_WheelColliders;

			private const float ACCELERATION = 0.5f;

			private const float MIN_SPEED = 0.5f;

			private const float MAX_SPEED = 1.5f;

			private float inputModifier = 1f;

			private bool speedModified;

			public float Altitude { get; private set; }

			public float Throttle { get; private set; }

			public bool AirBrakes { get; private set; }

			public float ForwardSpeed { get; private set; }

			public float EnginePower { get; private set; }

			public float MaxEnginePower => m_MaxEnginePower;

			public float RollAngle { get; private set; }

			public float PitchAngle { get; private set; }

			public float RollInput { get; private set; }

			public float PitchInput { get; private set; }

			public float YawInput { get; private set; }

			public float ThrottleInput { get; private set; }

			public float MaxSpeed => m_MaxSpeed;

			public float AerodynamicEffect
			{
				get
				{
					return m_AerodynamicEffect;
				}
				set
				{
					m_AerodynamicEffect = value;
				}
			}

			private void Start()
			{
				initialEnginePower = m_MaxEnginePower;
				initialMaxSpeed = m_MaxSpeed;
				initialYaw = m_YawEffect;
				initialPitch = m_PitchEffect;
				initialRoll = m_RollEffect;
				m_Rigidbody = GetComponent<Rigidbody>();
				m_OriginalDrag = m_Rigidbody.drag;
				m_OriginalAngularDrag = m_Rigidbody.angularDrag;
				for (int i = 0; i < base.transform.childCount; i++)
				{
					WheelCollider[] componentsInChildren = base.transform.GetChild(i).GetComponentsInChildren<WheelCollider>();
					for (int j = 0; j < componentsInChildren.Length; j++)
					{
						componentsInChildren[j].motorTorque = 0.18f;
					}
				}
				StartCoroutine(Flatter(5f));
			}

			private void Update()
			{
				if (Input.GetButton("Faster"))
				{
					currentSpeedMod = Mathf.Min(currentSpeedMod + Time.deltaTime * 0.5f, 1.5f);
				}
				else if (Input.GetButton("Brakes"))
				{
					currentSpeedMod = Mathf.Max(currentSpeedMod - Time.deltaTime * 0.5f * 2f, 0.5f);
				}
				else
				{
					currentSpeedMod = Mathf.Lerp(currentSpeedMod, 1f, Time.deltaTime / 0.5f);
				}
				m_MaxEnginePower = initialEnginePower * currentSpeedMod * inputModifier * speedMod;
				m_MaxSpeed = initialMaxSpeed * currentSpeedMod * inputModifier * speedMod;
				if (adjustHanlingToSpeed)
				{
					m_RollEffect = initialRoll * currentSpeedMod;
					m_PitchEffect = initialPitch * currentSpeedMod;
					m_YawEffect = initialYaw * currentSpeedMod;
				}
				if (modTime > 0f)
				{
					modTime -= Time.deltaTime;
					return;
				}
				if (speedMod != 1f)
				{
					speedMod = 1f;
				}
				if (modInvert)
				{
					modInvert = false;
				}
				if (currentEffect != 0)
				{
					currentEffect = Bullet.Effect.None;
				}
			}

			public void Move(float rollInput, float pitchInput, float yawInput, float throttleInput, bool airBrakes)
			{
				if (!disabled)
				{
					RollInput = rollInput;
					PitchInput = pitchInput;
					YawInput = yawInput;
					YawInput = picoController.yawn;
					PitchInput = picoController.pitch;
					if (modInvert)
					{
						YawInput = 0f - YawInput;
					}
					if (turnAround)
					{
						PitchInput = 0.15f;
					}
					if (turnAround)
					{
						YawInput = -1f;
					}
					ThrottleInput = throttleInput;
					AirBrakes = airBrakes;
					ClampInputs();
					CalculateRollAndPitchAngles();
					AutoLevel();
					CalculateForwardSpeed();
					ControlThrottle();
					CalculateDrag();
					CaluclateAerodynamicEffect();
					CalculateLinearForces();
					CalculateTorque();
					CalculateAltitude();
					LimitVelocity();
				}
			}

			public void ModifySpeed(Bullet.Effect effect, float time)
			{
				if (currentEffect == effect || currentEffect == Bullet.Effect.None)
				{
					speedMod = ((effect == Bullet.Effect.Speed) ? 1.5f : 0.5f);
					modTime = ((modTime < time) ? time : modTime);
				}
			}

			public void ModifySpeed(float modifier)
			{
				if (!speedModified)
				{
					speedModified = true;
					inputModifier = modifier;
					StartCoroutine(ResetSpeed(modifier));
				}
			}

			public IEnumerator ResetSpeed(float modifier)
			{
				yield return new WaitForSeconds(3f);
				float old_inputModifier = 1f;
				while (inputModifier > old_inputModifier)
				{
					inputModifier -= old_inputModifier * 0.01f;
					yield return null;
				}
				speedModified = false;
			}

			public void InvertControls(float time)
			{
				if (currentEffect == Bullet.Effect.None || currentEffect == Bullet.Effect.Invert)
				{
					modInvert = true;
					modTime = ((modTime < time) ? time : modTime);
				}
			}

			private void LimitVelocity()
			{
				if (!disabled && m_Rigidbody.velocity.sqrMagnitude > m_MaxSpeed * m_MaxSpeed)
				{
					m_Rigidbody.velocity = m_Rigidbody.velocity.normalized * m_MaxSpeed;
				}
			}

			private void ClampInputs()
			{
				if (!disabled)
				{
					RollInput = Mathf.Clamp(RollInput, -1f, 1f);
					PitchInput = Mathf.Clamp(PitchInput, -1f, 1f);
					YawInput = Mathf.Clamp(YawInput, -1f, 1f);
					ThrottleInput = Mathf.Clamp(ThrottleInput, -1f, 1f);
				}
			}

			private void CalculateRollAndPitchAngles()
			{
				if (!disabled)
				{
					Vector3 forward = base.transform.forward;
					forward.y = 0f;
					if (forward.sqrMagnitude > 0f)
					{
						forward.Normalize();
						Vector3 vector = base.transform.InverseTransformDirection(forward);
						PitchAngle = Mathf.Atan2(vector.y, vector.z);
						Vector3 direction = Vector3.Cross(Vector3.up, forward);
						Vector3 vector2 = base.transform.InverseTransformDirection(direction);
						RollAngle = Mathf.Atan2(vector2.y, vector2.x);
					}
				}
			}

			private void AutoLevel()
			{
				if (!disabled)
				{
					m_BankedTurnAmount = Mathf.Sin(RollAngle);
					if (RollInput == 0f)
					{
						RollInput = (0f - RollAngle) * m_AutoRollLevel;
					}
					if (PitchInput == 0f)
					{
						PitchInput = (0f - PitchAngle) * m_AutoPitchLevel;
						PitchInput -= Mathf.Abs(m_BankedTurnAmount * m_BankedTurnAmount * m_AutoTurnPitch);
					}
				}
			}

			private void CalculateForwardSpeed()
			{
				if (!disabled)
				{
					ForwardSpeed = Mathf.Max(0f, base.transform.InverseTransformDirection(m_Rigidbody.velocity).z);
				}
			}

			private void ControlThrottle()
			{
				if (!disabled)
				{
					if (m_Immobilized)
					{
						ThrottleInput = -0.5f;
					}
					Throttle = Mathf.Clamp01(Throttle + ThrottleInput * Time.deltaTime * m_ThrottleChangeSpeed);
					EnginePower = Throttle * m_MaxEnginePower;
				}
			}

			private void CalculateDrag()
			{
				if (!disabled)
				{
					float num = m_Rigidbody.velocity.magnitude * m_DragIncreaseFactor;
					m_Rigidbody.drag = (AirBrakes ? ((m_OriginalDrag + num) * m_AirBrakesEffect) : (m_OriginalDrag + num));
					m_Rigidbody.angularDrag = m_OriginalAngularDrag * ForwardSpeed;
				}
			}

			private void CaluclateAerodynamicEffect()
			{
				if (!disabled && m_Rigidbody.velocity.magnitude > 0f)
				{
					m_AeroFactor = Vector3.Dot(base.transform.forward, m_Rigidbody.velocity.normalized);
					m_AeroFactor *= m_AeroFactor;
					Vector3 velocity = Vector3.Lerp(m_Rigidbody.velocity, base.transform.forward * ForwardSpeed, m_AeroFactor * ForwardSpeed * m_AerodynamicEffect * Time.deltaTime);
					m_Rigidbody.velocity = velocity;
					if ((double)m_Rigidbody.velocity.sqrMagnitude > (double)(MaxSpeed * MaxSpeed) * 0.01)
					{
						Quaternion b = Quaternion.LookRotation(m_Rigidbody.velocity, base.transform.up);
						m_Rigidbody.rotation = Quaternion.Slerp(m_Rigidbody.rotation, b, m_AerodynamicEffect * Time.deltaTime);
					}
				}
			}

			private void CalculateLinearForces()
			{
				if (!disabled)
				{
					if (animator != null)
					{
						animator.SetFloat("Speed", GetComponent<Rigidbody>().velocity.magnitude / m_MaxSpeed);
					}
					Vector3 zero = Vector3.zero;
					zero += EnginePower * base.transform.forward;
					Vector3 normalized = Vector3.Cross(m_Rigidbody.velocity, base.transform.right).normalized;
					float num = Mathf.InverseLerp(m_ZeroLiftSpeed, 0f, ForwardSpeed);
					float num2 = ForwardSpeed * ForwardSpeed * m_Lift * num * m_AeroFactor;
					zero += num2 * normalized;
					m_Rigidbody.AddForce(zero);
				}
			}

			private void CalculateTorque()
			{
				if (!disabled)
				{
					Vector3 zero = Vector3.zero;
					zero += PitchInput * m_PitchEffect * base.transform.right;
					zero += YawInput * m_YawEffect * base.transform.up;
					zero += (0f - RollInput) * m_RollEffect * base.transform.forward;
					zero += m_BankedTurnAmount * m_BankedTurnEffect * base.transform.up;
					m_Rigidbody.AddTorque(zero * ForwardSpeed * m_AeroFactor);
					if (animator != null)
					{
						animator.SetFloat("Rotate", YawInput * -1f);
					}
				}
			}

			private void CalculateAltitude()
			{
				if (!disabled)
				{
					Ray ray = new Ray(base.transform.position - Vector3.up * 10f, -Vector3.up);
					Altitude = (Physics.Raycast(ray, out var hitInfo) ? (hitInfo.distance + 10f) : base.transform.position.y);
				}
			}

			public void Immobilize()
			{
				if (!disabled)
				{
					m_Immobilized = true;
				}
			}

			public void Reset()
			{
				if (!disabled)
				{
					m_Immobilized = false;
				}
			}

			public IEnumerator Flatter(float delay)
			{
				yield return new WaitForSeconds(delay);
				if ((double)(GetComponent<Rigidbody>().velocity.magnitude / m_MaxSpeed) > 0.75 && animator != null)
				{
					animator.SetTrigger("Flatter");
				}
				StartCoroutine(Flatter(5f + UnityEngine.Random.Range(0.1f, 1f)));
			}

			public void TurnAround(bool turn)
			{
				turnAround = turn;
				UnityEngine.Debug.Log("TurnAround: " + turn);
			}
		}
		public class AeroplanePropellerAnimator : MonoBehaviour
		{
			[SerializeField]
			private Transform m_PropellerModel;

			[SerializeField]
			private Transform m_PropellerBlur;

			[SerializeField]
			private Texture2D[] m_PropellerBlurTextures;

			[SerializeField]
			[Range(0f, 1f)]
			private float m_ThrottleBlurStart = 0.25f;

			[SerializeField]
			[Range(0f, 1f)]
			private float m_ThrottleBlurEnd = 0.5f;

			[SerializeField]
			private float m_MaxRpm = 2000f;

			public bool rotateAroundX;

			private AeroplaneController m_Plane;

			private int m_PropellorBlurState = -1;

			private const float k_RpmToDps = 60f;

			private Renderer m_PropellorModelRenderer;

			private Renderer m_PropellorBlurRenderer;

			private void Awake()
			{
				m_Plane = GetComponent<AeroplaneController>();
				m_PropellorModelRenderer = m_PropellerModel.GetComponent<Renderer>();
				m_PropellorBlurRenderer = m_PropellerBlur.GetComponent<Renderer>();
				m_PropellerBlur.parent = m_PropellerModel;
			}

			private void Update()
			{
				float num = m_MaxRpm * m_Plane.Throttle * Time.deltaTime * 60f;
				if (rotateAroundX)
				{
					m_PropellerModel.Rotate(num, 0f, 0f);
				}
				else
				{
					m_PropellerModel.Rotate(0f, num, 0f);
				}
				int num2 = 0;
				if (m_Plane.Throttle > m_ThrottleBlurStart)
				{
					num2 = Mathf.FloorToInt(Mathf.InverseLerp(m_ThrottleBlurStart, m_ThrottleBlurEnd, m_Plane.Throttle) * (float)(m_PropellerBlurTextures.Length - 1));
				}
				if (num2 != m_PropellorBlurState)
				{
					m_PropellorBlurState = num2;
					if (m_PropellorBlurState == 0)
					{
						m_PropellorModelRenderer.enabled = true;
						m_PropellorBlurRenderer.enabled = false;
					}
					else
					{
						m_PropellorModelRenderer.enabled = false;
						m_PropellorBlurRenderer.enabled = true;
						m_PropellorBlurRenderer.material.mainTexture = m_PropellerBlurTextures[m_PropellorBlurState];
					}
				}
			}
		}
	}
	namespace UnityStandardAssets.Characters.ThirdPerson
	{
		[RequireComponent(typeof(NavMeshAgent))]
		[RequireComponent(typeof(ThirdPersonCharacter))]
		public class AICharacterControl : MonoBehaviour
		{
			public Transform target;

			public NavMeshAgent agent { get; private set; }

			public ThirdPersonCharacter character { get; private set; }

			private void Start()
			{
				agent = GetComponentInChildren<NavMeshAgent>();
				character = GetComponent<ThirdPersonCharacter>();
				agent.updateRotation = false;
				agent.updatePosition = true;
			}

			private void Update()
			{
				if (target != null)
				{
					agent.SetDestination(target.position);
				}
				if (agent.remainingDistance > agent.stoppingDistance)
				{
					character.Move(agent.desiredVelocity, crouch: false, jump: false);
				}
				else
				{
					character.Move(Vector3.zero, crouch: false, jump: false);
				}
			}

			public void SetTarget(Transform target)
			{
				this.target = target;
			}
		}
		[RequireComponent(typeof(Rigidbody))]
		[RequireComponent(typeof(CapsuleCollider))]
		[RequireComponent(typeof(Animator))]
		public class ThirdPersonCharacter : MonoBehaviour
		{
			[SerializeField]
			private float m_MovingTurnSpeed = 360f;

			[SerializeField]
			private float m_StationaryTurnSpeed = 180f;

			[SerializeField]
			private float m_JumpPower = 12f;

			[Range(1f, 4f)]
			[SerializeField]
			private float m_GravityMultiplier = 2f;

			[SerializeField]
			private float m_RunCycleLegOffset = 0.2f;

			[SerializeField]
			private float m_MoveSpeedMultiplier = 1f;

			[SerializeField]
			private float m_AnimSpeedMultiplier = 1f;

			[SerializeField]
			private float m_GroundCheckDistance = 0.1f;

			private Rigidbody m_Rigidbody;

			private Animator m_Animator;

			private bool m_IsGrounded;

			private float m_OrigGroundCheckDistance;

			private const float k_Half = 0.5f;

			private float m_TurnAmount;

			private float m_ForwardAmount;

			private Vector3 m_GroundNormal;

			private float m_CapsuleHeight;

			private Vector3 m_CapsuleCenter;

			private CapsuleCollider m_Capsule;

			private bool m_Crouching;

			private void Start()
			{
				m_Animator = GetComponent<Animator>();
				m_Rigidbody = GetComponent<Rigidbody>();
				m_Capsule = GetComponent<CapsuleCollider>();
				m_CapsuleHeight = m_Capsule.height;
				m_CapsuleCenter = m_Capsule.center;
				m_Rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
				m_OrigGroundCheckDistance = m_GroundCheckDistance;
			}

			public void Move(Vector3 move, bool crouch, bool jump)
			{
				if (move.magnitude > 1f)
				{
					move.Normalize();
				}
				move = base.transform.InverseTransformDirection(move);
				CheckGroundStatus();
				move = Vector3.ProjectOnPlane(move, m_GroundNormal);
				m_TurnAmount = Mathf.Atan2(move.x, move.z);
				m_ForwardAmount = move.z;
				ApplyExtraTurnRotation();
				if (m_IsGrounded)
				{
					HandleGroundedMovement(crouch, jump);
				}
				else
				{
					HandleAirborneMovement();
				}
				ScaleCapsuleForCrouching(crouch);
				PreventStandingInLowHeadroom();
				UpdateAnimator(move);
			}

			private void ScaleCapsuleForCrouching(bool crouch)
			{
				if (m_IsGrounded && crouch)
				{
					if (!m_Crouching)
					{
						m_Capsule.height /= 2f;
						m_Capsule.center /= 2f;
						m_Crouching = true;
					}
				}
				else if (Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f, layerMask: -1, queryTriggerInteraction: QueryTriggerInteraction.Ignore))
				{
					m_Crouching = true;
				}
				else
				{
					m_Capsule.height = m_CapsuleHeight;
					m_Capsule.center = m_CapsuleCenter;
					m_Crouching = false;
				}
			}

			private void PreventStandingInLowHeadroom()
			{
				if (!m_Crouching && Physics.SphereCast(new Ray(m_Rigidbody.position + Vector3.up * m_Capsule.radius * 0.5f, Vector3.up), maxDistance: m_CapsuleHeight - m_Capsule.radius * 0.5f, radius: m_Capsule.radius * 0.5f, layerMask: -1, queryTriggerInteraction: QueryTriggerInteraction.Ignore))
				{
					m_Crouching = true;
				}
			}

			private void UpdateAnimator(Vector3 move)
			{
				m_Animator.SetFloat("Forward", m_ForwardAmount, 0.1f, Time.deltaTime);
				m_Animator.SetFloat("Turn", m_TurnAmount, 0.1f, Time.deltaTime);
				m_Animator.SetBool("Crouch", m_Crouching);
				m_Animator.SetBool("OnGround", m_IsGrounded);
				if (!m_IsGrounded)
				{
					m_Animator.SetFloat("Jump", m_Rigidbody.velocity.y);
				}
				float value = (float)((Mathf.Repeat(m_Animator.GetCurrentAnimatorStateInfo(0).normalizedTime + m_RunCycleLegOffset, 1f) < 0.5f) ? 1 : (-1)) * m_ForwardAmount;
				if (m_IsGrounded)
				{
					m_Animator.SetFloat("JumpLeg", value);
				}
				if (m_IsGrounded && move.magnitude > 0f)
				{
					m_Animator.speed = m_AnimSpeedMultiplier;
				}
				else
				{
					m_Animator.speed = 1f;
				}
			}

			private void HandleAirborneMovement()
			{
				Vector3 force = Physics.gravity * m_GravityMultiplier - Physics.gravity;
				m_Rigidbody.AddForce(force);
				m_GroundCheckDistance = ((m_Rigidbody.velocity.y < 0f) ? m_OrigGroundCheckDistance : 0.01f);
			}

			private void HandleGroundedMovement(bool crouch, bool jump)
			{
				if (jump && !crouch && m_Animator.GetCurrentAnimatorStateInfo(0).IsName("Grounded"))
				{
					m_Rigidbody.velocity = new Vector3(m_Rigidbody.velocity.x, m_JumpPower, m_Rigidbody.velocity.z);
					m_IsGrounded = false;
					m_Animator.applyRootMotion = false;
					m_GroundCheckDistance = 0.1f;
				}
			}

			private void ApplyExtraTurnRotation()
			{
				float num = Mathf.Lerp(m_StationaryTurnSpeed, m_MovingTurnSpeed, m_ForwardAmount);
				base.transform.Rotate(0f, m_TurnAmount * num * Time.deltaTime, 0f);
			}

			public void OnAnimatorMove()
			{
				if (m_IsGrounded && Time.deltaTime > 0f)
				{
					Vector3 velocity = m_Animator.deltaPosition * m_MoveSpeedMultiplier / Time.deltaTime;
					velocity.y = m_Rigidbody.velocity.y;
					m_Rigidbody.velocity = velocity;
				}
			}

			private void CheckGroundStatus()
			{
				if (Physics.Raycast(base.transform.position + Vector3.up * 0.1f, Vector3.down, out var hitInfo, m_GroundCheckDistance))
				{
					m_GroundNormal = hitInfo.normal;
					m_IsGrounded = true;
					m_Animator.applyRootMotion = true;
				}
				else
				{
					m_IsGrounded = false;
					m_GroundNormal = Vector3.up;
					m_Animator.applyRootMotion = false;
				}
			}
		}
	}
	namespace UnityStandardAssets.Characters.FirstPerson
	{
		[RequireComponent(typeof(CharacterController))]
		[RequireComponent(typeof(AudioSource))]
		public class FirstPersonController : MonoBehaviour
		{
			[SerializeField]
			private bool m_IsWalking;

			[SerializeField]
			private float m_WalkSpeed;

			[SerializeField]
			private float m_RunSpeed;

			[SerializeField]
			[Range(0f, 1f)]
			private float m_RunstepLenghten;

			[SerializeField]
			private float m_JumpSpeed;

			[SerializeField]
			private float m_StickToGroundForce;

			[SerializeField]
			private float m_GravityMultiplier;

			[SerializeField]
			private MouseLook m_MouseLook;

			[SerializeField]
			private bool m_UseFovKick;

			[SerializeField]
			private FOVKick m_FovKick = new FOVKick();

			[SerializeField]
			private bool m_UseHeadBob;

			[SerializeField]
			private CurveControlledBob m_HeadBob = new CurveControlledBob();

			[SerializeField]
			private LerpControlledBob m_JumpBob = new LerpControlledBob();

			[SerializeField]
			private float m_StepInterval;

			[SerializeField]
			private AudioClip[] m_FootstepSounds;

			[SerializeField]
			private AudioClip m_JumpSound;

			[SerializeField]
			private AudioClip m_LandSound;

			private Camera m_Camera;

			private bool m_Jump;

			private float m_YRotation;

			private Vector2 m_Input;

			private Vector3 m_MoveDir = Vector3.zero;

			private CharacterController m_CharacterController;

			private CollisionFlags m_CollisionFlags;

			private bool m_PreviouslyGrounded;

			private Vector3 m_OriginalCameraPosition;

			private float m_StepCycle;

			private float m_NextStep;

			private bool m_Jumping;

			private AudioSource m_AudioSource;

			private void Start()
			{
				m_CharacterController = GetComponent<CharacterController>();
				m_Camera = Camera.main;
				m_OriginalCameraPosition = m_Camera.transform.localPosition;
				m_FovKick.Setup(m_Camera);
				m_HeadBob.Setup(m_Camera, m_StepInterval);
				m_StepCycle = 0f;
				m_NextStep = m_StepCycle / 2f;
				m_Jumping = false;
				m_AudioSource = GetComponent<AudioSource>();
				m_MouseLook.Init(base.transform, m_Camera.transform);
			}

			private void Update()
			{
				RotateView();
				if (!m_Jump)
				{
					m_Jump = CrossPlatformInputManager.GetButtonDown("Jump");
				}
				if (!m_PreviouslyGrounded && m_CharacterController.isGrounded)
				{
					StartCoroutine(m_JumpBob.DoBobCycle());
					PlayLandingSound();
					m_MoveDir.y = 0f;
					m_Jumping = false;
				}
				if (!m_CharacterController.isGrounded && !m_Jumping && m_PreviouslyGrounded)
				{
					m_MoveDir.y = 0f;
				}
				m_PreviouslyGrounded = m_CharacterController.isGrounded;
			}

			private void PlayLandingSound()
			{
				m_AudioSource.clip = m_LandSound;
				m_AudioSource.Play();
				m_NextStep = m_StepCycle + 0.5f;
			}

			private void FixedUpdate()
			{
				GetInput(out var speed);
				Vector3 vector = base.transform.forward * m_Input.y + base.transform.right * m_Input.x;
				Physics.SphereCast(base.transform.position, m_CharacterController.radius, Vector3.down, out var hitInfo, m_CharacterController.height / 2f, -1, QueryTriggerInteraction.Ignore);
				vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
				m_MoveDir.x = vector.x * speed;
				m_MoveDir.z = vector.z * speed;
				if (m_CharacterController.isGrounded)
				{
					m_MoveDir.y = 0f - m_StickToGroundForce;
					if (m_Jump)
					{
						m_MoveDir.y = m_JumpSpeed;
						PlayJumpSound();
						m_Jump = false;
						m_Jumping = true;
					}
				}
				else
				{
					m_MoveDir += Physics.gravity * m_GravityMultiplier * Time.fixedDeltaTime;
				}
				m_CollisionFlags = m_CharacterController.Move(m_MoveDir * Time.fixedDeltaTime);
				ProgressStepCycle(speed);
				UpdateCameraPosition(speed);
				m_MouseLook.UpdateCursorLock();
			}

			private void PlayJumpSound()
			{
				m_AudioSource.clip = m_JumpSound;
				m_AudioSource.Play();
			}

			private void ProgressStepCycle(float speed)
			{
				if (m_CharacterController.velocity.sqrMagnitude > 0f && (m_Input.x != 0f || m_Input.y != 0f))
				{
					m_StepCycle += (m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten)) * Time.fixedDeltaTime;
				}
				if (m_StepCycle > m_NextStep)
				{
					m_NextStep = m_StepCycle + m_StepInterval;
					PlayFootStepAudio();
				}
			}

			private void PlayFootStepAudio()
			{
				if (m_CharacterController.isGrounded)
				{
					int num = UnityEngine.Random.Range(1, m_FootstepSounds.Length);
					m_AudioSource.clip = m_FootstepSounds[num];
					m_AudioSource.PlayOneShot(m_AudioSource.clip);
					m_FootstepSounds[num] = m_FootstepSounds[0];
					m_FootstepSounds[0] = m_AudioSource.clip;
				}
			}

			private void UpdateCameraPosition(float speed)
			{
				if (m_UseHeadBob)
				{
					Vector3 localPosition;
					if (m_CharacterController.velocity.magnitude > 0f && m_CharacterController.isGrounded)
					{
						m_Camera.transform.localPosition = m_HeadBob.DoHeadBob(m_CharacterController.velocity.magnitude + speed * (m_IsWalking ? 1f : m_RunstepLenghten));
						localPosition = m_Camera.transform.localPosition;
						localPosition.y = m_Camera.transform.localPosition.y - m_JumpBob.Offset();
					}
					else
					{
						localPosition = m_Camera.transform.localPosition;
						localPosition.y = m_OriginalCameraPosition.y - m_JumpBob.Offset();
					}
					m_Camera.transform.localPosition = localPosition;
				}
			}

			private void GetInput(out float speed)
			{
				float axis = CrossPlatformInputManager.GetAxis("Horizontal");
				float axis2 = CrossPlatformInputManager.GetAxis("Vertical");
				bool isWalking = m_IsWalking;
				speed = (m_IsWalking ? m_WalkSpeed : m_RunSpeed);
				m_Input = new Vector2(axis, axis2);
				if (m_Input.sqrMagnitude > 1f)
				{
					m_Input.Normalize();
				}
				if (m_IsWalking != isWalking && m_UseFovKick && m_CharacterController.velocity.sqrMagnitude > 0f)
				{
					StopAllCoroutines();
					StartCoroutine((!m_IsWalking) ? m_FovKick.FOVKickUp() : m_FovKick.FOVKickDown());
				}
			}

			private void RotateView()
			{
				m_MouseLook.LookRotation(base.transform, m_Camera.transform);
			}

			private void OnControllerColliderHit(ControllerColliderHit hit)
			{
				Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
				if (m_CollisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
				{
					attachedRigidbody.AddForceAtPosition(m_CharacterController.velocity * 0.1f, hit.point, ForceMode.Impulse);
				}
			}
		}
		public class HeadBob : MonoBehaviour
		{
			public Camera Camera;

			public CurveControlledBob motionBob = new CurveControlledBob();

			public LerpControlledBob jumpAndLandingBob = new LerpControlledBob();

			public RigidbodyFirstPersonController rigidbodyFirstPersonController;

			public float StrideInterval;

			[Range(0f, 1f)]
			public float RunningStrideLengthen;

			private bool m_PreviouslyGrounded;

			private Vector3 m_OriginalCameraPosition;

			private void Start()
			{
				motionBob.Setup(Camera, StrideInterval);
				m_OriginalCameraPosition = Camera.transform.localPosition;
			}

			private void Update()
			{
				Vector3 localPosition;
				if (rigidbodyFirstPersonController.Velocity.magnitude > 0f && rigidbodyFirstPersonController.Grounded)
				{
					Camera.transform.localPosition = motionBob.DoHeadBob(rigidbodyFirstPersonController.Velocity.magnitude * (rigidbodyFirstPersonController.Running ? RunningStrideLengthen : 1f));
					localPosition = Camera.transform.localPosition;
					localPosition.y = Camera.transform.localPosition.y - jumpAndLandingBob.Offset();
				}
				else
				{
					localPosition = Camera.transform.localPosition;
					localPosition.y = m_OriginalCameraPosition.y - jumpAndLandingBob.Offset();
				}
				Camera.transform.localPosition = localPosition;
				if (!m_PreviouslyGrounded && rigidbodyFirstPersonController.Grounded)
				{
					StartCoroutine(jumpAndLandingBob.DoBobCycle());
				}
				m_PreviouslyGrounded = rigidbodyFirstPersonController.Grounded;
			}
		}
		[Serializable]
		public class MouseLook
		{
			public float XSensitivity = 2f;

			public float YSensitivity = 2f;

			public bool clampVerticalRotation = true;

			public float MinimumX = -90f;

			public float MaximumX = 90f;

			public bool smooth;

			public float smoothTime = 5f;

			public bool lockCursor = true;

			private Quaternion m_CharacterTargetRot;

			private Quaternion m_CameraTargetRot;

			private bool m_cursorIsLocked = true;

			public void Init(Transform character, Transform camera)
			{
				m_CharacterTargetRot = character.localRotation;
				m_CameraTargetRot = camera.localRotation;
			}

			public void LookRotation(Transform character, Transform camera)
			{
				float y = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity;
				float num = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity;
				m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
				m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
				if (clampVerticalRotation)
				{
					m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
				}
				if (smooth)
				{
					character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
					camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
				}
				else
				{
					character.localRotation = m_CharacterTargetRot;
					camera.localRotation = m_CameraTargetRot;
				}
				UpdateCursorLock();
			}

			public void SetCursorLock(bool value)
			{
				lockCursor = value;
				if (!lockCursor)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}

			public void UpdateCursorLock()
			{
				if (lockCursor)
				{
					InternalLockUpdate();
				}
			}

			private void InternalLockUpdate()
			{
				if (Input.GetKeyUp(KeyCode.Escape))
				{
					m_cursorIsLocked = false;
				}
				else if (Input.GetMouseButtonUp(0))
				{
					m_cursorIsLocked = true;
				}
				if (m_cursorIsLocked)
				{
					Cursor.lockState = CursorLockMode.Locked;
					Cursor.visible = false;
				}
				else if (!m_cursorIsLocked)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}

			private Quaternion ClampRotationAroundXAxis(Quaternion q)
			{
				q.x /= q.w;
				q.y /= q.w;
				q.z /= q.w;
				q.w = 1f;
				float value = 114.59156f * Mathf.Atan(q.x);
				value = Mathf.Clamp(value, MinimumX, MaximumX);
				q.x = Mathf.Tan((float)Math.PI / 360f * value);
				return q;
			}
		}
		[RequireComponent(typeof(Rigidbody))]
		[RequireComponent(typeof(CapsuleCollider))]
		public class RigidbodyFirstPersonController : MonoBehaviour
		{
			[Serializable]
			public class MovementSettings
			{
				public float ForwardSpeed = 8f;

				public float BackwardSpeed = 4f;

				public float StrafeSpeed = 4f;

				public float RunMultiplier = 2f;

				public KeyCode RunKey = KeyCode.LeftShift;

				public float JumpForce = 30f;

				public AnimationCurve SlopeCurveModifier = new AnimationCurve(new Keyframe(-90f, 1f), new Keyframe(0f, 1f), new Keyframe(90f, 0f));

				[HideInInspector]
				public float CurrentTargetSpeed = 8f;

				public void UpdateDesiredTargetSpeed(Vector2 input)
				{
					if (!(input == Vector2.zero))
					{
						if (input.x > 0f || input.x < 0f)
						{
							CurrentTargetSpeed = StrafeSpeed;
						}
						if (input.y < 0f)
						{
							CurrentTargetSpeed = BackwardSpeed;
						}
						if (input.y > 0f)
						{
							CurrentTargetSpeed = ForwardSpeed;
						}
					}
				}
			}

			[Serializable]
			public class AdvancedSettings
			{
				public float groundCheckDistance = 0.01f;

				public float stickToGroundHelperDistance = 0.5f;

				public float slowDownRate = 20f;

				public bool airControl;

				[Tooltip("set it to 0.1 or more if you get stuck in wall")]
				public float shellOffset;
			}

			public Camera cam;

			public MovementSettings movementSettings = new MovementSettings();

			public MouseLook mouseLook = new MouseLook();

			public AdvancedSettings advancedSettings = new AdvancedSettings();

			private Rigidbody m_RigidBody;

			private CapsuleCollider m_Capsule;

			private float m_YRotation;

			private Vector3 m_GroundContactNormal;

			private bool m_Jump;

			private bool m_PreviouslyGrounded;

			private bool m_Jumping;

			private bool m_IsGrounded;

			public Vector3 Velocity => m_RigidBody.velocity;

			public bool Grounded => m_IsGrounded;

			public bool Jumping => m_Jumping;

			public bool Running => false;

			private void Start()
			{
				m_RigidBody = GetComponent<Rigidbody>();
				m_Capsule = GetComponent<CapsuleCollider>();
				mouseLook.Init(base.transform, cam.transform);
			}

			private void Update()
			{
				RotateView();
				if (CrossPlatformInputManager.GetButtonDown("Jump") && !m_Jump)
				{
					m_Jump = true;
				}
			}

			private void FixedUpdate()
			{
				GroundCheck();
				Vector2 input = GetInput();
				if ((Mathf.Abs(input.x) > float.Epsilon || Mathf.Abs(input.y) > float.Epsilon) && (advancedSettings.airControl || m_IsGrounded))
				{
					Vector3 vector = cam.transform.forward * input.y + cam.transform.right * input.x;
					vector = Vector3.ProjectOnPlane(vector, m_GroundContactNormal).normalized;
					vector.x *= movementSettings.CurrentTargetSpeed;
					vector.z *= movementSettings.CurrentTargetSpeed;
					vector.y *= movementSettings.CurrentTargetSpeed;
					if (m_RigidBody.velocity.sqrMagnitude < movementSettings.CurrentTargetSpeed * movementSettings.CurrentTargetSpeed)
					{
						m_RigidBody.AddForce(vector * SlopeMultiplier(), ForceMode.Impulse);
					}
				}
				if (m_IsGrounded)
				{
					m_RigidBody.drag = 5f;
					if (m_Jump)
					{
						m_RigidBody.drag = 0f;
						m_RigidBody.velocity = new Vector3(m_RigidBody.velocity.x, 0f, m_RigidBody.velocity.z);
						m_RigidBody.AddForce(new Vector3(0f, movementSettings.JumpForce, 0f), ForceMode.Impulse);
						m_Jumping = true;
					}
					if (!m_Jumping && Mathf.Abs(input.x) < float.Epsilon && Mathf.Abs(input.y) < float.Epsilon && m_RigidBody.velocity.magnitude < 1f)
					{
						m_RigidBody.Sleep();
					}
				}
				else
				{
					m_RigidBody.drag = 0f;
					if (m_PreviouslyGrounded && !m_Jumping)
					{
						StickToGroundHelper();
					}
				}
				m_Jump = false;
			}

			private float SlopeMultiplier()
			{
				float time = Vector3.Angle(m_GroundContactNormal, Vector3.up);
				return movementSettings.SlopeCurveModifier.Evaluate(time);
			}

			private void StickToGroundHelper()
			{
				if (Physics.SphereCast(base.transform.position, m_Capsule.radius * (1f - advancedSettings.shellOffset), Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.stickToGroundHelperDistance, -1, QueryTriggerInteraction.Ignore) && Mathf.Abs(Vector3.Angle(hitInfo.normal, Vector3.up)) < 85f)
				{
					m_RigidBody.velocity = Vector3.ProjectOnPlane(m_RigidBody.velocity, hitInfo.normal);
				}
			}

			private Vector2 GetInput()
			{
				Vector2 vector = default(Vector2);
				vector.x = CrossPlatformInputManager.GetAxis("Horizontal");
				vector.y = CrossPlatformInputManager.GetAxis("Vertical");
				Vector2 vector2 = vector;
				movementSettings.UpdateDesiredTargetSpeed(vector2);
				return vector2;
			}

			private void RotateView()
			{
				if (!(Mathf.Abs(Time.timeScale) < float.Epsilon))
				{
					float y = base.transform.eulerAngles.y;
					mouseLook.LookRotation(base.transform, cam.transform);
					if (m_IsGrounded || advancedSettings.airControl)
					{
						Quaternion quaternion = Quaternion.AngleAxis(base.transform.eulerAngles.y - y, Vector3.up);
						m_RigidBody.velocity = quaternion * m_RigidBody.velocity;
					}
				}
			}

			private void GroundCheck()
			{
				m_PreviouslyGrounded = m_IsGrounded;
				if (Physics.SphereCast(base.transform.position, m_Capsule.radius * (1f - advancedSettings.shellOffset), Vector3.down, out var hitInfo, m_Capsule.height / 2f - m_Capsule.radius + advancedSettings.groundCheckDistance, -1, QueryTriggerInteraction.Ignore))
				{
					m_IsGrounded = true;
					m_GroundContactNormal = hitInfo.normal;
				}
				else
				{
					m_IsGrounded = false;
					m_GroundContactNormal = Vector3.up;
				}
				if (!m_PreviouslyGrounded && m_IsGrounded && m_Jumping)
				{
					m_Jumping = false;
				}
			}
		}
	}
	namespace AquariusMax.UPF
	{
		public class AxeAction : MonoBehaviour
		{
			private Animator axeAnim;

			public float choppingSpeed = 1f;

			private float choppingCooldown;

			private void Start()
			{
				axeAnim = base.gameObject.GetComponent<Animator>();
			}

			private void Update()
			{
				if (Input.GetMouseButtonDown(0))
				{
					axeAnim.SetTrigger("Active");
				}
			}
		}
		public class GoldUI : MonoBehaviour
		{
			public Text goldText;

			private void Update()
			{
				goldText.text = PlayerResources.Gold.ToString() ?? "";
			}
		}
		public class Inventory : MonoBehaviour
		{
			public delegate void OnItemChanged();

			public static Inventory instance;

			public OnItemChanged onItemChangedCallback;

			public int space = 20;

			public List<ItemReference> items = new List<ItemReference>();

			private void Awake()
			{
				if (instance != null)
				{
					UnityEngine.Debug.LogWarning("More than one Inventory Instance found in your scene!");
				}
				else
				{
					instance = this;
				}
			}

			public bool Add(ItemReference item)
			{
				if (!item.isDefaultItem)
				{
					if (items.Count >= space)
					{
						UnityEngine.Debug.Log("Not enough room!");
						return false;
					}
					items.Add(item);
					if (onItemChangedCallback != null)
					{
						onItemChangedCallback();
					}
				}
				return true;
			}

			public void Remove(ItemReference item)
			{
				items.Remove(item);
				if (onItemChangedCallback != null)
				{
					onItemChangedCallback();
				}
			}
		}
		public class ItemPickup : ObjectInteraction
		{
			public ItemReference item;

			public override void Interact()
			{
				base.Interact();
				PickUp();
			}

			private void PickUp()
			{
				UnityEngine.Debug.Log("Picking up" + item.name);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		[CreateAssetMenu(fileName = "New Item", menuName = "Inventory/Item")]
		public class ItemReference : ScriptableObject
		{
			public new string name = "New Item";

			public Sprite icon;

			public bool isDefaultItem;
		}
		public class ItemScript : MonoBehaviour
		{
			private GameObject selectedItem;

			[HideInInspector]
			public int clicksToPickup = 1;

			public int goldGainedOnPickup = 1;

			public int woodGainedOnPickup = 1;

			public int stoneGainedOnPickup = 1;

			private bool pickUp;

			private void Start()
			{
				selectedItem = base.gameObject;
			}

			private void Update()
			{
				if (clicksToPickup <= 0 && !pickUp)
				{
					StartCoroutine(destroyItem());
					pickUp = true;
				}
			}

			private IEnumerator destroyItem()
			{
				UnityEngine.Debug.Log("You've Gained" + goldGainedOnPickup + "Gold");
				PlayerResources.Gold += goldGainedOnPickup;
				UnityEngine.Debug.Log("You've Gained" + woodGainedOnPickup + "Wood");
				PlayerResources.Wood += woodGainedOnPickup;
				UnityEngine.Debug.Log("You've Gained" + stoneGainedOnPickup + "Stone");
				PlayerResources.Stone += stoneGainedOnPickup;
				yield return new WaitForSeconds(0f);
				UnityEngine.Debug.Log("Picking up" + base.tag);
				UnityEngine.Object.Destroy(selectedItem);
			}
		}
		public class MiningScript : MonoBehaviour
		{
			private GameObject selectedRock;

			public int rockHealth = 24;

			public int stoneGained = 4;

			private bool isBroken;

			public GameObject deathEffect;

			private void Start()
			{
				selectedRock = base.gameObject;
			}

			private void Update()
			{
				if (rockHealth <= 0 && !isBroken)
				{
					StartCoroutine(destroyRock());
					isBroken = true;
				}
			}

			private IEnumerator destroyRock()
			{
				yield return new WaitForSeconds(0f);
				UnityEngine.Object.Destroy(selectedRock);
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(deathEffect, base.transform.position, Quaternion.identity), 3f);
				UnityEngine.Debug.Log("You've Gained" + stoneGained + "Stone");
				PlayerResources.Stone += stoneGained;
			}
		}
		public class ObjectInteraction : MonoBehaviour
		{
			public float radius = 3f;

			public Transform interactionTransform;

			private bool isFocus;

			public Transform player;

			private bool hasInteracted;

			public virtual void Interact()
			{
				UnityEngine.Debug.Log("Interacting With" + base.transform.name);
			}

			private void Update()
			{
				if (isFocus && !hasInteracted && Vector3.Distance(player.position, interactionTransform.position) <= radius)
				{
					Interact();
					hasInteracted = true;
				}
			}

			public void OnFocused(Transform playerTransform)
			{
				isFocus = true;
				player = playerTransform;
				hasInteracted = false;
			}

			public void OnDefocused()
			{
				isFocus = false;
				player = null;
				hasInteracted = false;
			}

			private void OnDrawGizmosSelected()
			{
				if (interactionTransform == null)
				{
					interactionTransform = base.transform;
				}
				Gizmos.color = Color.green;
				Gizmos.DrawWireSphere(interactionTransform.position, radius);
			}
		}
		public class PickaxeAction : MonoBehaviour
		{
			private Animator pickaxeAnim;

			private void Start()
			{
				pickaxeAnim = base.gameObject.GetComponent<Animator>();
			}

			private void Update()
			{
				if (Input.GetMouseButtonDown(0))
				{
					pickaxeAnim.SetTrigger("Active");
				}
			}
		}
		public class PlayerResources : MonoBehaviour
		{
			public static int Gold;

			public int startingGold = 15;

			public static int Wood;

			public int startingWood;

			public static int Stone;

			public int startingStone;

			private void Start()
			{
				Gold = startingGold;
				Wood = startingWood;
				Stone = startingStone;
			}
		}
		public class ResourceActivation : MonoBehaviour
		{
			public GameObject objectToBuild;

			public GameObject buildEffect;

			public bool isBuilt;

			public bool canBuild = true;

			[HideInInspector]
			public bool hasResources = true;

			[Header("Resource Costs")]
			public int goldCost = 10;

			public int woodCost = 10;

			public int stoneCost = 10;

			private void Start()
			{
				canBuild = true;
				isBuilt = false;
				objectToBuild.SetActive(value: false);
			}

			public void BuildObject()
			{
				if (PlayerResources.Stone < stoneCost && PlayerResources.Wood < woodCost && PlayerResources.Gold < goldCost)
				{
					UnityEngine.Debug.Log("Not enough resources to build!");
					hasResources = false;
					canBuild = false;
				}
				else if (PlayerResources.Stone >= stoneCost && PlayerResources.Wood >= woodCost && PlayerResources.Gold >= goldCost && !isBuilt)
				{
					hasResources = true;
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(buildEffect, base.transform.position, Quaternion.identity), 3f);
					PlayerResources.Stone -= stoneCost;
					PlayerResources.Wood -= woodCost;
					PlayerResources.Gold -= goldCost;
					isBuilt = true;
					canBuild = false;
					objectToBuild.SetActive(value: true);
				}
			}
		}
		public class ResourceCollecting : MonoBehaviour
		{
			[SerializeField]
			private Camera cam;

			public float choppingSpeed = 1f;

			private float choppingCooldown;

			[Header("Tree Chopping")]
			public GameObject axeOfChoice;

			[Header("Mining")]
			public GameObject pickaxeOfChoice;

			private bool axeIsEquipped;

			private bool pickaxeIsEquipped;

			[Header("Focus")]
			public ObjectInteraction focus;

			private void Start()
			{
				if (cam == null)
				{
					cam = Camera.main;
				}
			}

			private void Update()
			{
				choppingCooldown -= Time.deltaTime;
				if (!axeOfChoice.activeSelf && Input.GetKeyDown(KeyCode.Alpha1))
				{
					axeIsEquipped = true;
					axeOfChoice.SetActive(value: true);
					pickaxeOfChoice.SetActive(value: false);
					pickaxeIsEquipped = false;
				}
				else if (Input.GetKeyDown(KeyCode.Alpha1))
				{
					axeIsEquipped = false;
					axeOfChoice.SetActive(value: false);
				}
				if (!pickaxeOfChoice.activeSelf && Input.GetKeyDown(KeyCode.Alpha2))
				{
					pickaxeIsEquipped = true;
					pickaxeOfChoice.SetActive(value: true);
					axeOfChoice.SetActive(value: false);
					axeIsEquipped = false;
				}
				else if (Input.GetKeyDown(KeyCode.Alpha2))
				{
					pickaxeIsEquipped = false;
					pickaxeOfChoice.SetActive(value: false);
				}
				Vector3 direction = base.transform.TransformDirection(Vector3.forward);
				if (Physics.Raycast(base.transform.position, direction, out var hitInfo, 7f))
				{
					if (hitInfo.collider.GetComponent<Collider>().tag == "Tree" && axeIsEquipped && Input.GetMouseButtonDown(0) && choppingCooldown <= 0f)
					{
						UnityEngine.Debug.Log("Hitting the Tree!");
						hitInfo.collider.gameObject.GetComponent<TreeScript>().treeHealth--;
						choppingCooldown = 1f / choppingSpeed;
					}
					if (hitInfo.collider.GetComponent<Collider>().tag == "TreeSimple" && axeIsEquipped && Input.GetMouseButtonDown(0))
					{
						hitInfo.collider.gameObject.GetComponent<TreeSimpleScript>().treeHealth--;
					}
					if (hitInfo.collider.GetComponent<Collider>().tag == "MiningRock" && pickaxeIsEquipped && Input.GetMouseButtonDown(0))
					{
						hitInfo.collider.gameObject.GetComponent<MiningScript>().rockHealth--;
					}
					if (hitInfo.collider.GetComponent<Collider>().tag == "Item" && Input.GetMouseButtonDown(1))
					{
						hitInfo.collider.gameObject.GetComponent<ItemScript>().clicksToPickup--;
					}
				}
			}

			private void SetFocus(ObjectInteraction newFocus)
			{
				focus = newFocus;
			}

			private void RemoveFocus()
			{
				focus = null;
			}
		}
		public class StoneUI : MonoBehaviour
		{
			public Text stoneText;

			private void Update()
			{
				stoneText.text = PlayerResources.Stone.ToString() ?? "";
			}
		}
		public class TreeScript : MonoBehaviour
		{
			private GameObject selectedTree;

			public Transform leafEffectPos;

			public GameObject theStump;

			public int treeHealth = 14;

			public int woodGained = 10;

			private bool isFalling;

			public GameObject leafEffect;

			public GameObject deathEffect;

			private void Start()
			{
				selectedTree = base.gameObject;
			}

			private void Update()
			{
				if (treeHealth <= 0 && !isFalling)
				{
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(leafEffect, leafEffectPos.position, Quaternion.identity), 7f);
					Rigidbody rigidbody = selectedTree.AddComponent<Rigidbody>();
					rigidbody.mass = 10f;
					rigidbody.isKinematic = false;
					rigidbody.useGravity = true;
					rigidbody.AddForce(Vector3.forward, ForceMode.Impulse);
					StartCoroutine(destroyTree());
					isFalling = true;
				}
			}

			private IEnumerator destroyTree()
			{
				yield return new WaitForSeconds(7f);
				UnityEngine.Object.Destroy(selectedTree);
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(deathEffect, base.transform.position, Quaternion.identity), 3f);
				UnityEngine.Object.Destroy(theStump);
				UnityEngine.Debug.Log("You've Gained" + woodGained + "Wood");
				PlayerResources.Wood += woodGained;
			}
		}
		public class TreeSimpleScript : MonoBehaviour
		{
			private GameObject selectedTree;

			public int treeHealth = 5;

			public int woodGained = 3;

			private bool isChopped;

			public GameObject deathEffect;

			private void Start()
			{
				selectedTree = base.gameObject;
			}

			private void Update()
			{
				if (treeHealth <= 0 && !isChopped)
				{
					isChopped = true;
					UnityEngine.Object.Destroy(selectedTree);
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(deathEffect, base.transform.position, Quaternion.identity), 3f);
					PlayerResources.Wood += woodGained;
				}
			}
		}
		public class WoodUI : MonoBehaviour
		{
			public Text woodText;

			private void Update()
			{
				woodText.text = PlayerResources.Wood.ToString() ?? "";
			}
		}
		public enum ArmorUnit
		{
			Helm,
			Chest,
			Shoulders,
			Bracers,
			Gloves,
			Pants,
			Legs,
			Boots
		}
		public enum ArmorElement
		{
			None,
			Fire,
			Water,
			Air,
			Earth,
			Spirit,
			Holy,
			Dark,
			Poison
		}
		public enum ArmorClass
		{
			Light,
			Heavy,
			Medium
		}
		public enum ArmorBuff
		{
			none,
			defenseUp,
			speedUp,
			healthUp,
			damageUp,
			staminaUp
		}
		[Serializable]
		public class Armor
		{
			public string armorName;

			public int cost = 10;

			public int sellPrice = 5;

			public ArmorUnit typeOfArmor;

			public ArmorClass armorClass;

			public ArmorElement element;

			public ArmorBuff buff;
		}
		public class ArmorShop : MonoBehaviour
		{
			public Armor[] armorToBuy;
		}
		public enum ItemUnit
		{
			Sword,
			Axe,
			Dagger,
			Mace,
			Staff,
			Shield,
			Bow
		}
		public enum ItemEffect
		{
			None,
			Fire,
			Water,
			Air,
			Earth,
			Spirit,
			Holy,
			Dark,
			Poison
		}
		public enum ItemBuff
		{
			none,
			defenseUp,
			attackSpeedUp,
			healthUp,
			damageUp,
			staminaUp
		}
		[Serializable]
		public class Items
		{
			public string itemName;

			public int cost = 10;

			public int sellPrice = 5;

			public ItemUnit typeOfItem;

			public ItemEffect element;

			public ItemBuff buff;
		}
		public class ItemShop : MonoBehaviour
		{
			public Items itemsToBuy;
		}
		public enum MaterialUnit
		{
			Sword,
			Axe,
			Dagger,
			Mace,
			Staff,
			Shield,
			Bow
		}
		[Serializable]
		public class Materials
		{
			public string materialName;

			public int cost = 10;

			public int sellPrice = 5;
		}
		public class MaterialShop : MonoBehaviour
		{
			public Materials[] materialsToBuy;
		}
		public enum WeaponUnit
		{
			Sword,
			Axe,
			Dagger,
			Mace,
			Staff,
			Shield,
			Bow
		}
		public enum WeaponElement
		{
			None,
			Fire,
			Water,
			Air,
			Earth,
			Spirit,
			Holy,
			Dark,
			Poison
		}
		public enum WeaponBuff
		{
			none,
			defenseUp,
			attackSpeedUp,
			healthUp,
			damageUp,
			staminaUp
		}
		[Serializable]
		public class Weapon
		{
			public string weaponName;

			public int cost = 10;

			public int sellPrice = 5;

			public WeaponUnit typeOfWeapon;

			public WeaponElement element;

			public WeaponBuff buff;
		}
		public class WeaponShop : MonoBehaviour
		{
			public Weapon[] weaponsToBuy;
		}
	}
	namespace AquariusMax.Demo
	{
		[RequireComponent(typeof(Animator))]
		public class AnimTriggerEvent : MonoBehaviour
		{
			public bool isOpen = true;

			private Animator anim;

			private void Awake()
			{
				anim = GetComponent<Animator>();
			}

			private void Start()
			{
				if (anim.GetBool("isOpen") != isOpen)
				{
					anim.SetBool("isOpen", isOpen);
				}
			}

			public void OnTriggerEnter()
			{
				anim.SetTrigger("activate");
				isOpen = true;
			}

			public void OnTriggerExit()
			{
				anim.SetTrigger("activate");
				isOpen = !isOpen;
			}
		}
		public class CursorLock : MonoBehaviour
		{
			private bool isLocked;

			private void Update()
			{
				if (Input.GetKeyUp(KeyCode.Escape))
				{
					isLocked = false;
				}
				else if (Input.GetMouseButtonUp(0))
				{
					isLocked = true;
				}
				if (isLocked)
				{
					Cursor.lockState = CursorLockMode.Locked;
					Cursor.visible = false;
				}
				else if (!isLocked)
				{
					Cursor.lockState = CursorLockMode.None;
					Cursor.visible = true;
				}
			}
		}
		public class Interact : MonoBehaviour
		{
			[SerializeField]
			private float interactionDistance = 3f;

			[SerializeField]
			private float interactionSize = 1f;

			private GameObject focusedObject;

			private Vector3 hitPoint = Vector3.zero;

			private void OnDrawGizmos()
			{
				if (hitPoint != Vector3.zero)
				{
					Gizmos.DrawWireSphere(hitPoint, interactionSize);
				}
			}

			private void Update()
			{
				hitPoint = Vector3.zero;
				Vector3 dir = base.transform.TransformDirection(Vector3.forward) * interactionDistance;
				UnityEngine.Debug.DrawRay(base.transform.position, dir, Color.green);
				Interactable interactable = null;
				if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, interactionDistance) && hitInfo.collider != base.gameObject.GetComponentInParent<Collider>())
				{
					hitPoint = hitInfo.point;
					interactable = hitInfo.collider.gameObject.GetComponent<Interactable>();
					if (interactable == null)
					{
						Collider[] array = Physics.OverlapSphere(hitInfo.point, interactionSize);
						int i = 0;
						float num = 999f;
						for (; i < array.Length; i++)
						{
							Interactable component = array[i].gameObject.GetComponent<Interactable>();
							if (component != null)
							{
								float num2 = Vector3.Distance(array[i].ClosestPoint(hitInfo.point), hitInfo.point);
								if (num2 < num)
								{
									num = num2;
									interactable = component;
								}
							}
						}
					}
				}
				if (interactable != null)
				{
					if (interactable.gameObject != focusedObject)
					{
						if (focusedObject != null)
						{
							LoseFocus();
						}
						focusedObject = interactable.gameObject;
						interactable.OnFocus();
					}
				}
				else
				{
					LoseFocus();
				}
				if (focusedObject != null && Input.GetKeyDown(KeyCode.E))
				{
					focusedObject.GetComponent<Interactable>().OnInteract();
				}
			}

			private void LoseFocus()
			{
				if (focusedObject != null)
				{
					focusedObject.GetComponent<Interactable>().OnBlur();
					focusedObject = null;
				}
			}
		}
		[Serializable]
		public class InteractEvent : UnityEvent<GameObject>
		{
		}
		[RequireComponent(typeof(Renderer))]
		public class Interactable : MonoBehaviour
		{
			public Color highlightColor = Color.green;

			public Material highlightMaterial;

			private Material materialInstance;

			private bool isFocused;

			[SerializeField]
			private InteractEvent interactEvent;

			public void OnFocus()
			{
				isFocused = true;
				AddFocusMaterial();
			}

			public void OnBlur()
			{
				isFocused = false;
				RemoveFocusMaterial();
			}

			public void OnInteract()
			{
				interactEvent.Invoke(base.gameObject);
			}

			private void AddFocusMaterial()
			{
				if (highlightMaterial == null)
				{
					return;
				}
				Renderer component = GetComponent<Renderer>();
				if (materialInstance != null)
				{
					for (int i = 0; i < component.materials.Length; i++)
					{
						if (component.materials[i] == materialInstance)
						{
							return;
						}
					}
				}
				Material[] array = new Material[component.materials.Length + 1];
				Array.Copy(component.materials, array, component.materials.Length);
				array[component.materials.Length] = highlightMaterial;
				component.materials = array;
				materialInstance = component.materials[component.materials.Length - 1];
				if (materialInstance.HasProperty("_OutlineColor"))
				{
					materialInstance.SetColor("_OutlineColor", highlightColor);
				}
			}

			private void RemoveFocusMaterial()
			{
				if (materialInstance == null)
				{
					return;
				}
				Renderer component = GetComponent<Renderer>();
				bool flag = false;
				for (int i = 0; i < component.materials.Length; i++)
				{
					if (component.materials[i] == materialInstance)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return;
				}
				Material[] array = new Material[component.materials.Length - 1];
				int num = 0;
				for (int j = 0; j < component.materials.Length; j++)
				{
					if (component.materials[j] != materialInstance)
					{
						array[num] = component.materials[j];
						num++;
					}
				}
				component.materials = array;
				materialInstance = null;
			}
		}
		public class JumpPad : MonoBehaviour
		{
			public float speedUp;

			public bool isGround;

			public GameObject player;
		}
		public class Lift : MonoBehaviour
		{
			public Transform start;

			public Transform target;

			public float speed;

			public bool _isActiv;

			public bool _isPlayer = true;

			private void Awake()
			{
			}

			private void Update()
			{
				if (_isActiv && start.position != target.position)
				{
					float maxDistanceDelta = speed * Time.deltaTime;
					start.transform.position = Vector3.MoveTowards(base.transform.position, target.position, maxDistanceDelta);
				}
				if (start.position == target.position)
				{
					_isActiv = false;
				}
			}

			public void OnTriggerEnter(Collider other)
			{
				_isActiv = true;
				UnityEngine.Debug.Log(_isActiv);
			}

			public void OnTriggerExit(Collider other)
			{
			}
		}
		public class LoadSiegeWeapon : MonoBehaviour
		{
			[SerializeField]
			private SiegeWeaponFire weapon;

			[SerializeField]
			private PickupItem playerCarry;

			[SerializeField]
			private string validTag = "catapult_bullet";

			private void OnTriggerEnter(Collider other)
			{
				if (other.CompareTag(validTag) && weapon.isReady)
				{
					playerCarry.Drop();
					weapon.LoadBullet(other.gameObject);
				}
			}
		}
		public class MakeSomeNoise : MonoBehaviour
		{
			public float power = 3f;

			public float scale = 1f;

			public float timeScale = 1f;

			private float xOffset;

			private float yOffset;

			private MeshFilter mf;

			private void Start()
			{
				mf = GetComponent<MeshFilter>();
				MakeNoise();
			}

			private void Update()
			{
				MakeNoise();
				xOffset += Time.deltaTime * timeScale;
				yOffset += Time.deltaTime * timeScale;
			}

			private void MakeNoise()
			{
				Vector3[] vertices = mf.mesh.vertices;
				for (int i = 0; i < vertices.Length; i++)
				{
					vertices[i].y = CalculateHeight(vertices[i].x, vertices[i].z) * power;
				}
				mf.mesh.vertices = vertices;
			}

			private float CalculateHeight(float x, float y)
			{
				float x2 = x * scale + xOffset;
				float y2 = y * scale + yOffset;
				return Mathf.PerlinNoise(x2, y2);
			}
		}
		public class MovingPlatformController : MonoBehaviour
		{
			public bool triggerSensor;

			public List<Rigidbody> rigidbodies = new List<Rigidbody>();

			private Vector3 lastPosition;

			private Transform _transform;

			[HideInInspector]
			public Rigidbody _rigidbody;

			private void Start()
			{
				_transform = base.transform;
				lastPosition = _transform.position;
				_rigidbody = GetComponent<Rigidbody>();
				if (triggerSensor)
				{
					MovingPlatformSensor[] componentsInChildren = GetComponentsInChildren<MovingPlatformSensor>();
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].gravityLi = this;
					}
				}
			}

			private void LateUpdate()
			{
				if (rigidbodies.Count > 0)
				{
					for (int i = 0; i < rigidbodies.Count; i++)
					{
						Rigidbody rigidbody = rigidbodies[i];
						Vector3 translation = _transform.position - lastPosition;
						rigidbody.transform.Translate(translation, _transform);
					}
				}
				lastPosition = _transform.position;
			}

			private void OnCollisionEnter(Collision collision)
			{
				if (!triggerSensor)
				{
					Rigidbody component = collision.collider.GetComponent<Rigidbody>();
					if (component != null)
					{
						Add(component);
					}
				}
			}

			private void OnCollisionExit(Collision collision)
			{
				if (!triggerSensor)
				{
					Rigidbody component = collision.collider.GetComponent<Rigidbody>();
					if (component != null)
					{
						Remove(component);
					}
				}
			}

			public void Add(Rigidbody rb)
			{
				if (!rigidbodies.Contains(rb))
				{
					rigidbodies.Add(rb);
				}
			}

			public void Remove(Rigidbody rb)
			{
				if (rigidbodies.Contains(rb))
				{
					rigidbodies.Remove(rb);
				}
			}
		}
		public class MovingPlatformSensor : MonoBehaviour
		{
			[HideInInspector]
			public MovingPlatformController gravityLi;

			public void OnTriggerEnter(Collider ob)
			{
				Rigidbody component = ob.GetComponent<Rigidbody>();
				if (component != null && component != gravityLi._rigidbody)
				{
					gravityLi.Add(component);
				}
			}

			public void OnTriggerExit(Collider ob)
			{
				Rigidbody component = ob.GetComponent<Rigidbody>();
				if (component != null && component != gravityLi._rigidbody)
				{
					gravityLi.Remove(component);
				}
			}
		}
		public class PickupItem : MonoBehaviour
		{
			[SerializeField]
			private float pickupDistance = 3f;

			private GameObject carriedItem;

			private GameObject hand;

			private void Start()
			{
				hand = new GameObject("CarryHand");
				hand.transform.parent = base.transform;
				hand.transform.localPosition = new Vector3(0f, 0f, pickupDistance);
				hand.AddComponent<Rigidbody>().isKinematic = true;
			}

			public void Pickup(GameObject item)
			{
				if (!(carriedItem != null))
				{
					Rigidbody component = item.GetComponent<Rigidbody>();
					if (component != null)
					{
						FixedJoint fixedJoint = hand.AddComponent<FixedJoint>();
						fixedJoint.enableCollision = false;
						fixedJoint.connectedBody = component;
					}
					Interactable component2 = item.GetComponent<Interactable>();
					if (component2 != null)
					{
						component2.OnBlur();
						component2.enabled = false;
					}
					item.layer = 2;
					carriedItem = item;
				}
			}

			public void Drop()
			{
				if (!(carriedItem == null))
				{
					FixedJoint component = hand.GetComponent<FixedJoint>();
					component.connectedBody.angularDrag = 0.05f;
					component.connectedBody = null;
					UnityEngine.Object.Destroy(component);
					Interactable component2 = carriedItem.GetComponent<Interactable>();
					if (component2 != null)
					{
						component2.enabled = true;
					}
					carriedItem.layer = 0;
					carriedItem = null;
				}
			}

			private void Update()
			{
				if (Input.GetKeyDown(KeyCode.F))
				{
					Drop();
				}
			}
		}
		public class Portal : MonoBehaviour
		{
			[SerializeField]
			public Transform PortalEndPoint;

			public void OnTriggerEnter(Collider other)
			{
				other.gameObject.transform.position = PortalEndPoint.position;
			}
		}
		public class SiegeWeaponFire : MonoBehaviour
		{
			public GameObject bulletPrefab;

			[SerializeField]
			private bool autoSpawnBullets;

			[HideInInspector]
			public bool isLoaded;

			[HideInInspector]
			public bool isReady;

			[SerializeField]
			private float fireSpeed = 1800f;

			private Animator anim;

			[SerializeField]
			private Transform loadPoint;

			private GameObject bulletInstance;

			private void Awake()
			{
				anim = GetComponent<Animator>();
				if (loadPoint == null)
				{
					loadPoint = base.transform.Find("LoadPoint");
				}
			}

			public void Activate()
			{
				if (!isReady)
				{
					Ready();
				}
				else if (isReady && !isLoaded)
				{
					LoadBullet(null);
				}
				else if (isReady && isLoaded)
				{
					Fire();
				}
			}

			public void Ready()
			{
				if (!isReady)
				{
					anim.SetTrigger("Load");
					isReady = true;
				}
			}

			public void LoadBullet(GameObject bullet)
			{
				if (!isReady || isLoaded)
				{
					return;
				}
				if (bullet == null && autoSpawnBullets)
				{
					bulletInstance = UnityEngine.Object.Instantiate(bulletPrefab, loadPoint);
					Rigidbody component = bulletInstance.GetComponent<Rigidbody>();
					if (component != null)
					{
						component.isKinematic = true;
					}
					isLoaded = true;
				}
				if (bullet != null)
				{
					bulletInstance = bullet;
					bullet.transform.position = loadPoint.position;
					bullet.transform.parent = loadPoint;
					Rigidbody component2 = bullet.GetComponent<Rigidbody>();
					if (component2 != null)
					{
						component2.isKinematic = true;
					}
					isLoaded = true;
				}
			}

			public void Fire()
			{
				if (isLoaded)
				{
					anim.SetTrigger("Fire");
				}
			}

			private void OnAnimFire()
			{
				isReady = false;
				isLoaded = false;
				Rigidbody component = bulletInstance.GetComponent<Rigidbody>();
				if (component != null)
				{
					component.isKinematic = false;
					bulletInstance.transform.parent = null;
					component.velocity = loadPoint.forward * fireSpeed * Time.deltaTime;
				}
				bulletInstance = null;
			}
		}
		public class TextureScroll : MonoBehaviour
		{
			public float scrollSpeed = 0.5f;

			public Renderer rend;

			private void Start()
			{
				rend = GetComponent<Renderer>();
			}

			private void Update()
			{
				float x = Time.time * scrollSpeed;
				rend.material.SetTextureOffset("_MainTex", new Vector2(x, 0f));
			}
		}
		public class ToggleIsOpenBehavior : StateMachineBehaviour
		{
			public override void OnStateEnter(Animator animator, AnimatorStateInfo animatorStateInfo, int layerIndex)
			{
				bool @bool = animator.GetBool("isOpen");
				animator.SetBool("isOpen", !@bool);
			}
		}
		[RequireComponent(typeof(Animator))]
		public class TwoStateToggle : MonoBehaviour
		{
			public bool isOpen = true;

			private Animator anim;

			private void Awake()
			{
				anim = GetComponent<Animator>();
			}

			private void Start()
			{
				if (anim.GetBool("isOpen") != isOpen)
				{
					anim.SetBool("isOpen", isOpen);
				}
			}

			public void Activate()
			{
				anim.SetTrigger("activate");
				isOpen = !isOpen;
			}
		}
	}
	namespace AquariusMax.PolyNature
	{
		[RequireComponent(typeof(CharacterController))]
		public class DemoCharacter : MonoBehaviour
		{
			[SerializeField]
			private Camera cam;

			[SerializeField]
			private float gravityModifier = 2f;

			[SerializeField]
			private float walkSpeed = 5f;

			[SerializeField]
			private float runSpeed = 10f;

			[SerializeField]
			public float jumpSpeed = 10f;

			[SerializeField]
			private float jumpIndicator;

			[SerializeField]
			public bool isJumpPad;

			[SerializeField]
			private float landingForce = 10f;

			[SerializeField]
			private float mouseXSensitivity = 2f;

			[SerializeField]
			private float mouseYSensitivity = 2f;

			private CharacterController charControl;

			private Quaternion characterTargetRot;

			private Quaternion cameraTargetRot;

			private bool isWalking = true;

			private Vector2 moveInput = Vector2.zero;

			private Vector3 move = Vector3.zero;

			private bool jumpPressed;

			private CollisionFlags collisionFlags;

			private void Awake()
			{
				Cursor.lockState = CursorLockMode.Locked;
				Cursor.visible = false;
			}

			private void Start()
			{
				if (cam == null)
				{
					cam = Camera.main;
				}
				charControl = GetComponent<CharacterController>();
				characterTargetRot = base.transform.localRotation;
				cameraTargetRot = cam.transform.localRotation;
			}

			private void OnTriggerEnter(Collider other)
			{
				if (other.gameObject.tag == "JumpPad")
				{
					isJumpPad = true;
					UnityEngine.Debug.Log(isJumpPad);
					UnityEngine.Debug.Log(jumpIndicator);
				}
			}

			private void OnTriggerExit(Collider other)
			{
				if (other.gameObject.tag == "JumpPad")
				{
					isJumpPad = false;
				}
			}

			private void GetMoveInput(out float speed)
			{
				float axis = Input.GetAxis("Horizontal");
				float axis2 = Input.GetAxis("Vertical");
				moveInput = new Vector2(axis, axis2);
				if (moveInput.sqrMagnitude > 1f)
				{
					moveInput.Normalize();
				}
				isWalking = !Input.GetKey(KeyCode.LeftShift);
				speed = (isWalking ? walkSpeed : runSpeed);
			}

			private void CameraLook()
			{
				float y = Input.GetAxis("Mouse X") * mouseXSensitivity;
				float num = Input.GetAxis("Mouse Y") * mouseYSensitivity;
				characterTargetRot *= Quaternion.Euler(0f, y, 0f);
				cameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
				cameraTargetRot = ClampRotationAroundXAxis(cameraTargetRot);
				base.transform.localRotation = characterTargetRot;
				cam.transform.localRotation = cameraTargetRot;
			}

			private void Update()
			{
				CameraLook();
				jumpPressed = Input.GetKeyDown(KeyCode.Space);
			}

			private void FixedUpdate()
			{
				GetMoveInput(out var speed);
				Vector3 vector = base.transform.forward * moveInput.y + base.transform.right * moveInput.x;
				Physics.SphereCast(base.transform.position, charControl.radius, Vector3.down, out var hitInfo, charControl.height / 2f, -1, QueryTriggerInteraction.Ignore);
				vector = Vector3.ProjectOnPlane(vector, hitInfo.normal).normalized;
				move.x = vector.x * speed;
				move.z = vector.z * speed;
				if (charControl.isGrounded)
				{
					move.y = 0f - landingForce;
					if (jumpPressed)
					{
						move.y = jumpSpeed;
						jumpPressed = false;
						if (isJumpPad)
						{
							move.y = jumpIndicator;
							jumpPressed = false;
						}
					}
				}
				else
				{
					move += Physics.gravity * gravityModifier * Time.fixedDeltaTime;
				}
				collisionFlags = charControl.Move(move * Time.fixedDeltaTime);
			}

			private Quaternion ClampRotationAroundXAxis(Quaternion q)
			{
				q.x /= q.w;
				q.y /= q.w;
				q.z /= q.w;
				q.w = 1f;
				float value = 114.59156f * Mathf.Atan(q.x);
				value = Mathf.Clamp(value, -90f, 90f);
				q.x = Mathf.Tan((float)Math.PI / 360f * value);
				return q;
			}

			private void OnControllerColliderHit(ControllerColliderHit hit)
			{
				Rigidbody attachedRigidbody = hit.collider.attachedRigidbody;
				if (collisionFlags != CollisionFlags.Below && !(attachedRigidbody == null) && !attachedRigidbody.isKinematic)
				{
					attachedRigidbody.AddForceAtPosition(charControl.velocity * 0.1f, hit.point, ForceMode.Impulse);
				}
			}
		}
		[Serializable]
		public class BobbingObject : MonoBehaviour
		{
			public float amplitude;

			public float speed;

			public Vector3 tempVal;

			public Vector3 tempPos;

			private void Start()
			{
				tempVal = base.transform.position;
			}

			private void Update()
			{
				tempPos = base.transform.position;
				tempPos.y = tempVal.y + amplitude * Mathf.Sin(speed * Time.time);
				base.transform.position = tempPos;
			}
		}
		public class MakeSomeNoise : MonoBehaviour
		{
			public float power = 3f;

			public float scale = 1f;

			public float timeScale = 1f;

			private float xOffset;

			private float yOffset;

			private MeshFilter mf;

			private void Start()
			{
				mf = GetComponent<MeshFilter>();
				MakeNoise();
			}

			private void Update()
			{
				MakeNoise();
				xOffset += Time.deltaTime * timeScale;
				yOffset += Time.deltaTime * timeScale;
			}

			private void MakeNoise()
			{
				Vector3[] vertices = mf.mesh.vertices;
				for (int i = 0; i < vertices.Length; i++)
				{
					vertices[i].y = CalculateHeight(vertices[i].x, vertices[i].z) * power;
				}
				mf.mesh.vertices = vertices;
			}

			private float CalculateHeight(float x, float y)
			{
				float x2 = x * scale + xOffset;
				float y2 = y * scale + yOffset;
				return Mathf.PerlinNoise(x2, y2);
			}
		}
		public class PathMovement : MonoBehaviour
		{
			public WaypointPath pathToFollow;

			public int currentWayPointID;

			public float moveSpeed;

			public float reach = 1f;

			public float rotationSpeed = 0.5f;

			public string pathName;

			private Vector3 lastPosition;

			private Vector3 currentPosition;

			private void Start()
			{
				lastPosition = base.transform.position;
			}

			private void Update()
			{
				float num = Vector3.Distance(pathToFollow.pathPoints[currentWayPointID].position, base.transform.position);
				base.transform.position = Vector3.MoveTowards(base.transform.position, pathToFollow.pathPoints[currentWayPointID].position, Time.deltaTime * moveSpeed);
				Quaternion b = Quaternion.LookRotation(pathToFollow.pathPoints[currentWayPointID].position - base.transform.position);
				base.transform.rotation = Quaternion.Slerp(base.transform.rotation, b, Time.deltaTime * rotationSpeed);
				if (num <= reach)
				{
					currentWayPointID++;
				}
				if (currentWayPointID >= pathToFollow.pathPoints.Count)
				{
					currentWayPointID = 0;
				}
			}
		}
		public class Rotator2 : MonoBehaviour
		{
			public float x;

			public float y;

			public float z;

			private void Update()
			{
				base.transform.Rotate(x, y, z);
			}
		}
		public class TextureScroll : MonoBehaviour
		{
			public float scrollSpeed = 0.5f;

			public Renderer rend;

			private void Start()
			{
				rend = GetComponent<Renderer>();
			}

			private void Update()
			{
				float x = Time.time * scrollSpeed;
				rend.material.SetTextureOffset("_MainTex", new Vector2(x, 0f));
			}
		}
		public class WaypointPath : MonoBehaviour
		{
			public Color rayColor = Color.white;

			public List<Transform> pathPoints = new List<Transform>();

			private Transform[] theArray;

			private void OnDrawGizmos()
			{
				Gizmos.color = rayColor;
				theArray = GetComponentsInChildren<Transform>();
				pathPoints.Clear();
				Transform[] array = theArray;
				foreach (Transform transform in array)
				{
					if (transform != base.transform)
					{
						pathPoints.Add(transform);
					}
				}
				for (int j = 0; j < pathPoints.Count; j++)
				{
					Vector3 position = pathPoints[j].position;
					if (j > 0)
					{
						Gizmos.DrawLine(pathPoints[j - 1].position, position);
						Gizmos.DrawSphere(position, 0.4f);
					}
				}
			}

			private void Start()
			{
			}

			private void Update()
			{
			}
		}
	}
	namespace UnityTemplateProjects
	{
		public class SimpleCameraController : MonoBehaviour
		{
			private class CameraState
			{
				public float yaw;

				public float pitch;

				public float roll;

				public float x;

				public float y;

				public float z;

				public void SetFromTransform(Transform t)
				{
					pitch = t.eulerAngles.x;
					yaw = t.eulerAngles.y;
					roll = t.eulerAngles.z;
					x = t.position.x;
					y = t.position.y;
					z = t.position.z;
				}

				public void Translate(Vector3 translation)
				{
					Vector3 vector = Quaternion.Euler(pitch, yaw, roll) * translation;
					x += vector.x;
					y += vector.y;
					z += vector.z;
				}

				public void LerpTowards(CameraState target, float positionLerpPct, float rotationLerpPct)
				{
					yaw = Mathf.Lerp(yaw, target.yaw, rotationLerpPct);
					pitch = Mathf.Lerp(pitch, target.pitch, rotationLerpPct);
					roll = Mathf.Lerp(roll, target.roll, rotationLerpPct);
					x = Mathf.Lerp(x, target.x, positionLerpPct);
					y = Mathf.Lerp(y, target.y, positionLerpPct);
					z = Mathf.Lerp(z, target.z, positionLerpPct);
				}

				public void UpdateTransform(Transform t)
				{
					t.eulerAngles = new Vector3(pitch, yaw, roll);
					t.position = new Vector3(x, y, z);
				}
			}

			private CameraState m_TargetCameraState = new CameraState();

			private CameraState m_InterpolatingCameraState = new CameraState();

			[Header("Movement Settings")]
			[Tooltip("Exponential boost factor on translation, controllable by mouse wheel.")]
			public float boost = 3.5f;

			[Tooltip("Time it takes to interpolate camera position 99% of the way to the target.")]
			[Range(0.001f, 1f)]
			public float positionLerpTime = 0.2f;

			[Header("Rotation Settings")]
			[Tooltip("X = Change in mouse position.\nY = Multiplicative factor for camera rotation.")]
			public AnimationCurve mouseSensitivityCurve = new AnimationCurve(new Keyframe(0f, 0.5f, 0f, 5f), new Keyframe(1f, 2.5f, 0f, 0f));

			[Tooltip("Time it takes to interpolate camera rotation 99% of the way to the target.")]
			[Range(0.001f, 1f)]
			public float rotationLerpTime = 0.01f;

			[Tooltip("Whether or not to invert our Y axis for mouse input to rotation.")]
			public bool invertY;

			private void OnEnable()
			{
				m_TargetCameraState.SetFromTransform(base.transform);
				m_InterpolatingCameraState.SetFromTransform(base.transform);
			}

			private Vector3 GetInputTranslationDirection()
			{
				Vector3 result = default(Vector3);
				if (Input.GetKey(KeyCode.W))
				{
					result += Vector3.forward;
				}
				if (Input.GetKey(KeyCode.S))
				{
					result += Vector3.back;
				}
				if (Input.GetKey(KeyCode.A))
				{
					result += Vector3.left;
				}
				if (Input.GetKey(KeyCode.D))
				{
					result += Vector3.right;
				}
				if (Input.GetKey(KeyCode.Q))
				{
					result += Vector3.down;
				}
				if (Input.GetKey(KeyCode.E))
				{
					result += Vector3.up;
				}
				return result;
			}

			private void Update()
			{
				if (Input.GetKey(KeyCode.Escape))
				{
					Application.Quit();
				}
				if (Input.GetMouseButtonDown(1))
				{
					Cursor.lockState = CursorLockMode.Locked;
				}
				if (Input.GetMouseButtonUp(1))
				{
					Cursor.visible = true;
					Cursor.lockState = CursorLockMode.None;
				}
				if (Input.GetMouseButton(1))
				{
					Vector2 vector = new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y") * (float)(invertY ? 1 : (-1)));
					float num = mouseSensitivityCurve.Evaluate(vector.magnitude);
					m_TargetCameraState.yaw += vector.x * num;
					m_TargetCameraState.pitch += vector.y * num;
				}
				Vector3 translation = GetInputTranslationDirection() * Time.deltaTime;
				if (Input.GetKey(KeyCode.LeftShift))
				{
					translation *= 10f;
				}
				boost += Input.mouseScrollDelta.y * 0.2f;
				translation *= Mathf.Pow(2f, boost);
				m_TargetCameraState.Translate(translation);
				float positionLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / positionLerpTime * Time.deltaTime);
				float rotationLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / rotationLerpTime * Time.deltaTime);
				m_InterpolatingCameraState.LerpTowards(m_TargetCameraState, positionLerpPct, rotationLerpPct);
				m_InterpolatingCameraState.UpdateTransform(base.transform);
			}
		}
	}
	namespace DistantLands
	{
		public class BirdFollow : MonoBehaviour
		{
			public Transform target;

			public float speed;

			public float angularSpeed;

			public float stoppingDistance;

			public bool paused;

			private void Start()
			{
			}

			private void Update()
			{
				if (!paused && (bool)target && Vector3.Distance(base.transform.position, target.position) > stoppingDistance)
				{
					base.transform.position = Vector3.MoveTowards(base.transform.position, target.position, speed * Time.deltaTime);
					base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(new Vector3(target.position.x, base.transform.position.y, target.position.z) - base.transform.position, Vector3.up), angularSpeed * Time.deltaTime);
				}
			}
		}
		public class Water : MonoBehaviour
		{
			private Vector3 waveSource1 = new Vector3(2f, 0f, 2f);

			public float waveFrequency = 0.53f;

			public float waveHeight = 0.48f;

			public float waveLength = 0.71f;

			public bool edgeBlend = true;

			public bool forceFlatShading = true;

			private Mesh mesh;

			private Vector3[] verts;

			private void Start()
			{
				Camera.main.depthTextureMode |= DepthTextureMode.Depth;
				MeshFilter component = GetComponent<MeshFilter>();
				makeMeshLowPoly(component);
			}

			private MeshFilter makeMeshLowPoly(MeshFilter mf)
			{
				mesh = mf.sharedMesh;
				Vector3[] vertices = mesh.vertices;
				int[] triangles = mesh.triangles;
				Vector3[] array = new Vector3[triangles.Length];
				for (int i = 0; i < triangles.Length; i++)
				{
					array[i] = vertices[triangles[i]];
					triangles[i] = i;
				}
				mesh.vertices = array;
				mesh.triangles = triangles;
				mesh.RecalculateBounds();
				mesh.RecalculateNormals();
				verts = mesh.vertices;
				return mf;
			}

			private void setEdgeBlend()
			{
				if (!SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
				{
					edgeBlend = false;
				}
				if (edgeBlend)
				{
					Shader.EnableKeyword("WATER_EDGEBLEND_ON");
					if ((bool)Camera.main)
					{
						Camera.main.depthTextureMode |= DepthTextureMode.Depth;
					}
				}
				else
				{
					Shader.DisableKeyword("WATER_EDGEBLEND_ON");
				}
			}

			private void Update()
			{
				CalcWave();
				setEdgeBlend();
			}

			private void CalcWave()
			{
				for (int i = 0; i < verts.Length; i++)
				{
					Vector3 vector = verts[i];
					vector.y = 0f;
					float num = vector.magnitude + 1f * vector.normalized.x * vector.normalized.y;
					num = num / waveLength + Mathf.PerlinNoise(100f, i);
					vector.y = waveHeight * Mathf.Sin(Time.time * (float)Math.PI * 2f * waveFrequency + (float)Math.PI * 2f * num);
					verts[i] = vector;
				}
				mesh.vertices = verts;
				mesh.RecalculateNormals();
				mesh.MarkDynamic();
				GetComponent<MeshFilter>().mesh = mesh;
			}
		}
	}
	namespace PhoenixThirdPersonCamera
	{
		public class PhoenixThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace PhoenixPlayer
	{
		public class PhoenixPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace BirdThirdPersonCamera
	{
		public class BirdThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace BirdPlayer
	{
		public class BirdPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace WoodpeckerThirdPersonCamera
	{
		public class WoodpeckerThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace WoodpeckerPlayer
	{
		public class WoodpeckerPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace VultureThirdPersonCamera
	{
		public class VultureThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace VulturePlayer
	{
		public class VulturePlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace TucanThirdPersonCamera
	{
		public class TucanThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace TucanPlayer
	{
		public class TucanPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace SwallowThirdPersonCamera
	{
		public class SwallowThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace SwallowPlayer
	{
		public class SwallowPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace SeagullThirdPersonCamera
	{
		public class SeagullThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace SeagullPlayer
	{
		public class SeagullPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace RavenThirdPersonCamera
	{
		public class RavenThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace RavenPlayer
	{
		public class RavenPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace PigeonThirdPersonCamera
	{
		public class PigeonThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace PigeonPlayer
	{
		public class PigeonPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace PheasantThirdPersonCamera
	{
		public class PheasantThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace PheasantPlayer
	{
		public class PheasantPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace OrioleThirdPersonCamera
	{
		public class OrioleThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace OriolePlayer
	{
		public class OriolePlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace NorthernCardinalThirdPersonCamera
	{
		public class NorthernCardinalThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace NorthernCardinalPlayer
	{
		public class NorthernCardinalPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace MagpieThirdPersonCamera
	{
		public class MagpieThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace MagpiePlayer
	{
		public class MagpiePlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace KingfisherThirdPersonCamera
	{
		public class KingfisherThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace KingfisherPlayer
	{
		public class KingfisherPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace HummingbirdThirdPersonCamera
	{
		public class HummingbirdThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace HummingbirdPlayer
	{
		public class HummingbirdPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace GoldenEagleThirdPersonCamera
	{
		public class GoldenEagleThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace GoldenEaglePlayer
	{
		public class GoldenEaglePlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace FalconThirdPersonCamera
	{
		public class FalconThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace FalconPlayer
	{
		public class FalconPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace EurasianJayThirdPersonCamera
	{
		public class EurasianJayThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace EurasianJayPlayer
	{
		public class EurasianJayPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace CockatooThirdPersonCamera
	{
		public class CockatooThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace CockatooPlayer
	{
		public class CockatooPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace CockatielThirdPersonCamera
	{
		public class CockatielThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace CockatielPlayer
	{
		public class CockatielPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace BaldEagleThirdPersonCamera
	{
		public class BaldEagleThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace BaldEaglePlayer
	{
		public class BaldEaglePlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace ParrotThirdPersonCamera
	{
		public class ParrotThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace ParrotPlayer
	{
		public class ParrotPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace BarnOwlThirdPersonCamera
	{
		public class BarnOwlThirdPersonCamera : MonoBehaviour
		{
			private const float Y_ANGLE_MIN = 0f;

			private const float Y_ANGLE_MAX = 50f;

			public Transform lookAt;

			public Transform camTransform;

			public float distance = 5f;

			private float currentX;

			private float currentY = 45f;

			private float sensitivityX = 20f;

			private float sensitivityY = 20f;

			private void Start()
			{
				camTransform = base.transform;
			}

			private void Update()
			{
				currentX += Input.GetAxis("Mouse X");
				currentY += Input.GetAxis("Mouse Y");
				currentY = Mathf.Clamp(currentY, 0f, 50f);
			}

			private void LateUpdate()
			{
				Vector3 vector = new Vector3(0f, 0f, 0f - distance);
				Quaternion quaternion = Quaternion.Euler(currentY, currentX, 0f);
				camTransform.position = lookAt.position + quaternion * vector;
				camTransform.LookAt(lookAt.position);
			}
		}
	}
	namespace BarnOwlPlayer
	{
		public class BarnOwlPlayer : MonoBehaviour
		{
			private Animator anim;

			private CharacterController controller;

			public float speed = 600f;

			public float turnSpeed = 400f;

			private Vector3 moveDirection = Vector3.zero;

			public float gravity = 20f;

			private void Start()
			{
				controller = GetComponent<CharacterController>();
				anim = base.gameObject.GetComponentInChildren<Animator>();
			}

			private void Update()
			{
				if (Input.GetKey("w"))
				{
					anim.SetInteger("AnimationPar", 1);
				}
				else
				{
					anim.SetInteger("AnimationPar", 0);
				}
				if (controller.isGrounded)
				{
					moveDirection = base.transform.forward * Input.GetAxis("Vertical") * speed;
				}
				float axis = Input.GetAxis("Horizontal");
				base.transform.Rotate(0f, axis * turnSpeed * Time.deltaTime, 0f);
				controller.Move(moveDirection * Time.deltaTime);
				moveDirection.y -= gravity * Time.deltaTime;
			}
		}
	}
	namespace PolyPerfect
	{
		[ExecuteInEditMode]
		public class RandomCharacterPlacer : MonoBehaviour
		{
			[SerializeField]
			private float spawnSize;

			[SerializeField]
			private int spawnAmmount;

			[SerializeField]
			private GameObject[] characters;

			[ContextMenu("Spawn Characters")]
			private void SpawnAnimals()
			{
				GameObject gameObject = new GameObject("SpawnedCharacters");
				for (int i = 0; i < spawnAmmount; i++)
				{
					int num = UnityEngine.Random.Range(0, characters.Length);
					UnityEngine.Object.Instantiate(characters[num], RandomNavmeshLocation(spawnSize), Quaternion.identity, gameObject.transform);
				}
			}

			public Vector3 RandomNavmeshLocation(float radius)
			{
				Vector3 sourcePosition = UnityEngine.Random.insideUnitSphere * radius + base.transform.position;
				Vector3 result = Vector3.zero;
				if (NavMesh.SamplePosition(sourcePosition, out var hit, radius, 1))
				{
					result = hit.position;
				}
				return result;
			}

			private void OnDrawGizmosSelected()
			{
				Gizmos.DrawWireSphere(base.transform.position, spawnSize);
			}
		}
	}
